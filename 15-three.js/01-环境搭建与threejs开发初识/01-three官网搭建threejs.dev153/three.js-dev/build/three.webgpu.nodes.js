/**
 * @license
 * Copyright 2010-2024 Three.js Authors
 * SPDX-License-Identifier: MIT
 */
import { Color, Vector2, Vector3, Vector4, Matrix3, Matrix4, EventDispatcher, MathUtils, ColorManagement, SRGBTransfer, NoToneMapping, StaticDrawUsage, InterleavedBuffer, DynamicDrawUsage, InterleavedBufferAttribute, NoColorSpace, UnsignedIntType, IntType, WebGLCoordinateSystem, BackSide, CubeReflectionMapping, CubeRefractionMapping, WebGPUCoordinateSystem, TangentSpaceNormalMap, ObjectSpaceNormalMap, InstancedInterleavedBuffer, InstancedBufferAttribute, DataArrayTexture, FloatType, FramebufferTexture, LinearMipmapLinearFilter, DepthTexture, Material, NormalBlending, PointsMaterial, LineBasicMaterial, LineDashedMaterial, NoBlending, MeshNormalMaterial, WebGLCubeRenderTarget, BoxGeometry, Mesh, Scene, LinearFilter, CubeCamera, CubeTexture, EquirectangularReflectionMapping, EquirectangularRefractionMapping, AddOperation, MixOperation, MultiplyOperation, MeshBasicMaterial, MeshLambertMaterial, MeshPhongMaterial, Texture, MeshStandardMaterial, MeshPhysicalMaterial, MeshToonMaterial, MeshMatcapMaterial, SpriteMaterial, ShadowMaterial, Uint32BufferAttribute, Uint16BufferAttribute, DoubleSide, DepthStencilFormat, DepthFormat, UnsignedInt248Type, UnsignedByteType, RenderTarget, Plane, Object3D, HalfFloatType, LinearMipMapLinearFilter, OrthographicCamera, BufferGeometry, Float32BufferAttribute, BufferAttribute, UVMapping, Euler, LinearSRGBColorSpace, LessCompare, VSMShadowMap, RGFormat, BasicShadowMap, SphereGeometry, CubeUVReflectionMapping, PerspectiveCamera, RGBAFormat, LinearMipmapNearestFilter, NearestMipmapLinearFilter, Float16BufferAttribute, REVISION, SRGBColorSpace, PCFShadowMap, FrontSide, Frustum, DataTexture, RedIntegerFormat, RedFormat, RGIntegerFormat, RGBIntegerFormat, RGBFormat, RGBAIntegerFormat, UnsignedShortType, ByteType, ShortType, createCanvasElement, AddEquation, SubtractEquation, ReverseSubtractEquation, ZeroFactor, OneFactor, SrcColorFactor, SrcAlphaFactor, SrcAlphaSaturateFactor, DstColorFactor, DstAlphaFactor, OneMinusSrcColorFactor, OneMinusSrcAlphaFactor, OneMinusDstColorFactor, OneMinusDstAlphaFactor, CullFaceNone, CullFaceBack, CullFaceFront, CustomBlending, MultiplyBlending, SubtractiveBlending, AdditiveBlending, NotEqualDepth, GreaterDepth, GreaterEqualDepth, EqualDepth, LessEqualDepth, LessDepth, AlwaysDepth, NeverDepth, UnsignedShort4444Type, UnsignedShort5551Type, UnsignedInt5999Type, AlphaFormat, LuminanceFormat, LuminanceAlphaFormat, RGB_S3TC_DXT1_Format, RGBA_S3TC_DXT1_Format, RGBA_S3TC_DXT3_Format, RGBA_S3TC_DXT5_Format, RGB_PVRTC_4BPPV1_Format, RGB_PVRTC_2BPPV1_Format, RGBA_PVRTC_4BPPV1_Format, RGBA_PVRTC_2BPPV1_Format, RGB_ETC1_Format, RGB_ETC2_Format, RGBA_ETC2_EAC_Format, RGBA_ASTC_4x4_Format, RGBA_ASTC_5x4_Format, RGBA_ASTC_5x5_Format, RGBA_ASTC_6x5_Format, RGBA_ASTC_6x6_Format, RGBA_ASTC_8x5_Format, RGBA_ASTC_8x6_Format, RGBA_ASTC_8x8_Format, RGBA_ASTC_10x5_Format, RGBA_ASTC_10x6_Format, RGBA_ASTC_10x8_Format, RGBA_ASTC_10x10_Format, RGBA_ASTC_12x10_Format, RGBA_ASTC_12x12_Format, RGBA_BPTC_Format, RED_RGTC1_Format, SIGNED_RED_RGTC1_Format, RED_GREEN_RGTC2_Format, SIGNED_RED_GREEN_RGTC2_Format, RepeatWrapping, ClampToEdgeWrapping, MirroredRepeatWrapping, NearestFilter, NearestMipmapNearestFilter, NeverCompare, AlwaysCompare, LessEqualCompare, EqualCompare, GreaterEqualCompare, GreaterCompare, NotEqualCompare, warnOnce, NotEqualStencilFunc, GreaterStencilFunc, GreaterEqualStencilFunc, EqualStencilFunc, LessEqualStencilFunc, LessStencilFunc, AlwaysStencilFunc, NeverStencilFunc, DecrementWrapStencilOp, IncrementWrapStencilOp, DecrementStencilOp, IncrementStencilOp, InvertStencilOp, ReplaceStencilOp, ZeroStencilOp, KeepStencilOp, MaxEquation, MinEquation, SpotLight, PointLight, DirectionalLight, RectAreaLight, AmbientLight, HemisphereLight, LightProbe, LinearToneMapping, ReinhardToneMapping, CineonToneMapping, ACESFilmicToneMapping, AgXToneMapping, NeutralToneMapping, Group, Loader, FileLoader, MaterialLoader, ObjectLoader } from './three.core.js';
export { AdditiveAnimationBlendMode, AnimationAction, AnimationClip, AnimationLoader, AnimationMixer, AnimationObjectGroup, AnimationUtils, ArcCurve, ArrayCamera, ArrowHelper, AttachedBindMode, Audio, AudioAnalyser, AudioContext, AudioListener, AudioLoader, AxesHelper, BasicDepthPacking, BatchedMesh, Bone, BooleanKeyframeTrack, Box2, Box3, Box3Helper, BoxHelper, BufferGeometryLoader, Cache, Camera, CameraHelper, CanvasTexture, CapsuleGeometry, CatmullRomCurve3, CircleGeometry, Clock, ColorKeyframeTrack, CompressedArrayTexture, CompressedCubeTexture, CompressedTexture, CompressedTextureLoader, ConeGeometry, ConstantAlphaFactor, ConstantColorFactor, Controls, CubeTextureLoader, CubicBezierCurve, CubicBezierCurve3, CubicInterpolant, CullFaceFrontBack, Curve, CurvePath, CustomToneMapping, CylinderGeometry, Cylindrical, Data3DTexture, DataTextureLoader, DataUtils, DefaultLoadingManager, DetachedBindMode, DirectionalLightHelper, DiscreteInterpolant, DodecahedronGeometry, DynamicCopyUsage, DynamicReadUsage, EdgesGeometry, EllipseCurve, ExtrudeGeometry, Fog, FogExp2, GLBufferAttribute, GLSL1, GLSL3, GridHelper, HemisphereLightHelper, IcosahedronGeometry, ImageBitmapLoader, ImageLoader, ImageUtils, InstancedBufferGeometry, InstancedMesh, Int16BufferAttribute, Int32BufferAttribute, Int8BufferAttribute, Interpolant, InterpolateDiscrete, InterpolateLinear, InterpolateSmooth, KeyframeTrack, LOD, LatheGeometry, Layers, Light, Line, Line3, LineCurve, LineCurve3, LineLoop, LineSegments, LinearInterpolant, LinearMipMapNearestFilter, LinearTransfer, LoaderUtils, LoadingManager, LoopOnce, LoopPingPong, LoopRepeat, MOUSE, Matrix2, MeshDepthMaterial, MeshDistanceMaterial, NearestMipMapLinearFilter, NearestMipMapNearestFilter, NormalAnimationBlendMode, NumberKeyframeTrack, OctahedronGeometry, OneMinusConstantAlphaFactor, OneMinusConstantColorFactor, PCFSoftShadowMap, Path, PlaneGeometry, PlaneHelper, PointLightHelper, Points, PolarGridHelper, PolyhedronGeometry, PositionalAudio, PropertyBinding, PropertyMixer, QuadraticBezierCurve, QuadraticBezierCurve3, Quaternion, QuaternionKeyframeTrack, QuaternionLinearInterpolant, RGBADepthPacking, RGBDepthPacking, RGB_BPTC_SIGNED_Format, RGB_BPTC_UNSIGNED_Format, RGDepthPacking, RawShaderMaterial, Ray, Raycaster, RingGeometry, ShaderMaterial, Shape, ShapeGeometry, ShapePath, ShapeUtils, Skeleton, SkeletonHelper, SkinnedMesh, Source, Sphere, Spherical, SphericalHarmonics3, SplineCurve, SpotLightHelper, Sprite, StaticCopyUsage, StaticReadUsage, StereoCamera, StreamCopyUsage, StreamDrawUsage, StreamReadUsage, StringKeyframeTrack, TOUCH, TetrahedronGeometry, TextureLoader, TextureUtils, TorusGeometry, TorusKnotGeometry, Triangle, TriangleFanDrawMode, TriangleStripDrawMode, TrianglesDrawMode, TubeGeometry, Uint8BufferAttribute, Uint8ClampedBufferAttribute, Uniform, UniformsGroup, VectorKeyframeTrack, VideoTexture, WebGL3DRenderTarget, WebGLArrayRenderTarget, WebGLRenderTarget, WireframeGeometry, WrapAroundEnding, ZeroCurvatureEnding, ZeroSlopeEnding } from './three.core.js';

const refreshUniforms = [
	'alphaMap',
	'alphaTest',
	'anisotropy',
	'anisotropyMap',
	'anisotropyRotation',
	'aoMap',
	'attenuationColor',
	'attenuationDistance',
	'bumpMap',
	'clearcoat',
	'clearcoatMap',
	'clearcoatNormalMap',
	'clearcoatNormalScale',
	'clearcoatRoughness',
	'color',
	'dispersion',
	'displacementMap',
	'emissive',
	'emissiveMap',
	'envMap',
	'gradientMap',
	'ior',
	'iridescence',
	'iridescenceIOR',
	'iridescenceMap',
	'iridescenceThicknessMap',
	'lightMap',
	'map',
	'matcap',
	'metalness',
	'metalnessMap',
	'normalMap',
	'normalScale',
	'opacity',
	'roughness',
	'roughnessMap',
	'sheen',
	'sheenColor',
	'sheenColorMap',
	'sheenRoughnessMap',
	'shininess',
	'specular',
	'specularColor',
	'specularColorMap',
	'specularIntensity',
	'specularIntensityMap',
	'specularMap',
	'thickness',
	'transmission',
	'transmissionMap'
];

class NodeMaterialObserver {

	constructor( builder ) {

		this.renderObjects = new WeakMap();
		this.hasNode = this.containsNode( builder );
		this.hasAnimation = builder.object.isSkinnedMesh === true;
		this.refreshUniforms = refreshUniforms;
		this.renderId = 0;

	}

	firstInitialization( renderObject ) {

		const hasInitialized = this.renderObjects.has( renderObject );

		if ( hasInitialized === false ) {

			this.getRenderObjectData( renderObject );

			return true;

		}

		return false;

	}

	getRenderObjectData( renderObject ) {

		let data = this.renderObjects.get( renderObject );

		if ( data === undefined ) {

			const { geometry, material, object } = renderObject;

			data = {
				material: this.getMaterialData( material ),
				geometry: {
					attributes: this.getAttributesData( geometry.attributes ),
					indexVersion: geometry.index ? geometry.index.version : null,
					drawRange: { start: geometry.drawRange.start, count: geometry.drawRange.count }
				},
				worldMatrix: object.matrixWorld.clone()
			};

			if ( object.center ) {

				data.center = object.center.clone();

			}

			if ( object.morphTargetInfluences ) {

				data.morphTargetInfluences = object.morphTargetInfluences.slice();

			}

			if ( renderObject.bundle !== null ) {

				data.version = renderObject.bundle.version;

			}

			if ( data.material.transmission > 0 ) {

				const { width, height } = renderObject.context;

				data.bufferWidth = width;
				data.bufferHeight = height;

			}

			this.renderObjects.set( renderObject, data );

		}

		return data;

	}

	getAttributesData( attributes ) {

		const attributesData = {};

		for ( const name in attributes ) {

			const attribute = attributes[ name ];

			attributesData[ name ] = {
				version: attribute.version
			};

		}

		return attributesData;

	}

	containsNode( builder ) {

		const material = builder.material;

		for ( const property in material ) {

			if ( material[ property ] && material[ property ].isNode )
				return true;

		}

		if ( builder.renderer.nodes.modelViewMatrix !== null || builder.renderer.nodes.modelNormalViewMatrix !== null )
			return true;

		return false;

	}

	getMaterialData( material ) {

		const data = {};

		for ( const property of this.refreshUniforms ) {

			const value = material[ property ];

			if ( value === null || value === undefined ) continue;

			if ( typeof value === 'object' && value.clone !== undefined ) {

				if ( value.isTexture === true ) {

					data[ property ] = { id: value.id, version: value.version };

				} else {

					data[ property ] = value.clone();

				}

			} else {

				data[ property ] = value;

			}

		}

		return data;

	}

	equals( renderObject ) {

		const { object, material, geometry } = renderObject;

		const renderObjectData = this.getRenderObjectData( renderObject );

		// world matrix

		if ( renderObjectData.worldMatrix.equals( object.matrixWorld ) !== true ) {

			renderObjectData.worldMatrix.copy( object.matrixWorld );

			return false;

		}

		// material

		const materialData = renderObjectData.material;

		for ( const property in materialData ) {

			const value = materialData[ property ];
			const mtlValue = material[ property ];

			if ( value.equals !== undefined ) {

				if ( value.equals( mtlValue ) === false ) {

					value.copy( mtlValue );

					return false;

				}

			} else if ( mtlValue.isTexture === true ) {

				if ( value.id !== mtlValue.id || value.version !== mtlValue.version ) {

					value.id = mtlValue.id;
					value.version = mtlValue.version;

					return false;

				}

			} else if ( value !== mtlValue ) {

				materialData[ property ] = mtlValue;

				return false;

			}

		}

		if ( materialData.transmission > 0 ) {

			const { width, height } = renderObject.context;

			if ( renderObjectData.bufferWidth !== width || renderObjectData.bufferHeight !== height ) {

				renderObjectData.bufferWidth = width;
				renderObjectData.bufferHeight = height;

				return false;

			}

		}

		// geometry

		const storedGeometryData = renderObjectData.geometry;
		const attributes = geometry.attributes;
		const storedAttributes = storedGeometryData.attributes;

		const storedAttributeNames = Object.keys( storedAttributes );
		const currentAttributeNames = Object.keys( attributes );

		if ( storedAttributeNames.length !== currentAttributeNames.length ) {

			renderObjectData.geometry.attributes = this.getAttributesData( attributes );
			return false;

		}

		// compare each attribute

		for ( const name of storedAttributeNames ) {

			const storedAttributeData = storedAttributes[ name ];
			const attribute = attributes[ name ];

			if ( attribute === undefined ) {

				// attribute was removed
				delete storedAttributes[ name ];
				return false;

			}

			if ( storedAttributeData.version !== attribute.version ) {

				storedAttributeData.version = attribute.version;
				return false;

			}

		}

		// check index

		const index = geometry.index;
		const storedIndexVersion = storedGeometryData.indexVersion;
		const currentIndexVersion = index ? index.version : null;

		if ( storedIndexVersion !== currentIndexVersion ) {

			storedGeometryData.indexVersion = currentIndexVersion;
			return false;

		}

		// check drawRange

		if ( storedGeometryData.drawRange.start !== geometry.drawRange.start || storedGeometryData.drawRange.count !== geometry.drawRange.count ) {

			storedGeometryData.drawRange.start = geometry.drawRange.start;
			storedGeometryData.drawRange.count = geometry.drawRange.count;
			return false;

		}

		// morph targets

		if ( renderObjectData.morphTargetInfluences ) {

			let morphChanged = false;

			for ( let i = 0; i < renderObjectData.morphTargetInfluences.length; i ++ ) {

				if ( renderObjectData.morphTargetInfluences[ i ] !== object.morphTargetInfluences[ i ] ) {

					morphChanged = true;

				}

			}

			if ( morphChanged ) return true;

		}

		// center

		if ( renderObjectData.center ) {

			if ( renderObjectData.center.equals( object.center ) === false ) {

				renderObjectData.center.copy( object.center );

				return true;

			}

		}

		// bundle

		if ( renderObject.bundle !== null ) {

			renderObjectData.version = renderObject.bundle.version;

		}

		return true;

	}

	needsRefresh( renderObject, nodeFrame ) {

		if ( this.hasNode || this.hasAnimation || this.firstInitialization( renderObject ) )
			return true;

		const { renderId } = nodeFrame;

		if ( this.renderId !== renderId ) {

			this.renderId = renderId;

			return true;

		}

		const isStatic = renderObject.object.static === true;
		const isBundle = renderObject.bundle !== null && renderObject.bundle.static === true && this.getRenderObjectData( renderObject ).version === renderObject.bundle.version;

		if ( isStatic || isBundle )
			return false;

		const notEqual = this.equals( renderObject ) !== true;

		return notEqual;

	}

}

/** @module NodeUtils **/

// cyrb53 (c) 2018 bryc (github.com/bryc). License: Public domain. Attribution appreciated.
// A fast and simple 64-bit (or 53-bit) string hash function with decent collision resistance.
// Largely inspired by MurmurHash2/3, but with a focus on speed/simplicity.
// See https://stackoverflow.com/questions/7616461/generate-a-hash-from-string-in-javascript/52171480#52171480
// https://github.com/bryc/code/blob/master/jshash/experimental/cyrb53.js
function cyrb53( value, seed = 0 ) {

	let h1 = 0xdeadbeef ^ seed, h2 = 0x41c6ce57 ^ seed;

	if ( value instanceof Array ) {

		for ( let i = 0, val; i < value.length; i ++ ) {

			val = value[ i ];
			h1 = Math.imul( h1 ^ val, 2654435761 );
			h2 = Math.imul( h2 ^ val, 1597334677 );

		}

	} else {

		for ( let i = 0, ch; i < value.length; i ++ ) {

			ch = value.charCodeAt( i );
			h1 = Math.imul( h1 ^ ch, 2654435761 );
			h2 = Math.imul( h2 ^ ch, 1597334677 );

		}

	}

	h1 = Math.imul( h1 ^ ( h1 >>> 16 ), 2246822507 );
	h1 ^= Math.imul( h2 ^ ( h2 >>> 13 ), 3266489909 );
	h2 = Math.imul( h2 ^ ( h2 >>> 16 ), 2246822507 );
	h2 ^= Math.imul( h1 ^ ( h1 >>> 13 ), 3266489909 );

	return 4294967296 * ( 2097151 & h2 ) + ( h1 >>> 0 );

}

/**
 * Computes a hash for the given string.
 *
 * @method
 * @param {String} str - The string to be hashed.
 * @return {Number} The hash.
 */
const hashString = ( str ) => cyrb53( str );

/**
 * Computes a hash for the given array.
 *
 * @method
 * @param {Array<Number>} array - The array to be hashed.
 * @return {Number} The hash.
 */
const hashArray = ( array ) => cyrb53( array );

/**
 * Computes a hash for the given list of parameters.
 *
 * @method
 * @param {...Number} params - A list of parameters.
 * @return {Number} The hash.
 */
const hash$1 = ( ...params ) => cyrb53( params );

/**
 * Computes a cache key for the given node.
 *
 * @method
 * @param {Object} object - The object to be hashed.
 * @param {Boolean} [force=false] - Whether to force a cache key computation or not.
 * @return {Number} The hash.
 */
function getCacheKey$1( object, force = false ) {

	const values = [];

	if ( object.isNode === true ) {

		values.push( object.id );
		object = object.getSelf();

	}

	for ( const { property, childNode } of getNodeChildren( object ) ) {

		values.push( values, cyrb53( property.slice( 0, - 4 ) ), childNode.getCacheKey( force ) );

	}

	return cyrb53( values );

}

/**
 * This generator function can be used to iterate over the node children
 * of the given object.
 *
 * @generator
 * @param {Object} node - The object to be hashed.
 * @param {Boolean} [toJSON=false] - Whether to return JSON or not.
 * @yields {Object} A result node holding the property, index (if available) and the child node.
 */
function* getNodeChildren( node, toJSON = false ) {

	for ( const property in node ) {

		// Ignore private properties.
		if ( property.startsWith( '_' ) === true ) continue;

		const object = node[ property ];

		if ( Array.isArray( object ) === true ) {

			for ( let i = 0; i < object.length; i ++ ) {

				const child = object[ i ];

				if ( child && ( child.isNode === true || toJSON && typeof child.toJSON === 'function' ) ) {

					yield { property, index: i, childNode: child };

				}

			}

		} else if ( object && object.isNode === true ) {

			yield { property, childNode: object };

		} else if ( typeof object === 'object' ) {

			for ( const subProperty in object ) {

				const child = object[ subProperty ];

				if ( child && ( child.isNode === true || toJSON && typeof child.toJSON === 'function' ) ) {

					yield { property, index: subProperty, childNode: child };

				}

			}

		}

	}

}

const typeFromLength = /*@__PURE__*/ new Map( [
	[ 1, 'float' ],
	[ 2, 'vec2' ],
	[ 3, 'vec3' ],
	[ 4, 'vec4' ],
	[ 9, 'mat3' ],
	[ 16, 'mat4' ]
] );

/**
 * Returns the data type for the given the length.
 *
 * @method
 * @param {Number} length - The length.
 * @return {String} The data type.
 */
function getTypeFromLength( length ) {

	return typeFromLength.get( length );

}

/**
 * Returns the length for the given data type.
 *
 * @method
 * @param {String} type - The data type.
 * @return {Number} The length.
 */
function getLengthFromType( type ) {

	if ( /float|int|uint/.test( type ) ) return 1;
	if ( /vec2/.test( type ) ) return 2;
	if ( /vec3/.test( type ) ) return 3;
	if ( /vec4/.test( type ) ) return 4;
	if ( /mat3/.test( type ) ) return 9;
	if ( /mat4/.test( type ) ) return 16;

	console.error( 'THREE.TSL: Unsupported type:', type );

}

/**
 * Returns the data type for the given value.
 *
 * @method
 * @param {Any} value - The value.
 * @return {String?} The data type.
 */
function getValueType( value ) {

	if ( value === undefined || value === null ) return null;

	const typeOf = typeof value;

	if ( value.isNode === true ) {

		return 'node';

	} else if ( typeOf === 'number' ) {

		return 'float';

	} else if ( typeOf === 'boolean' ) {

		return 'bool';

	} else if ( typeOf === 'string' ) {

		return 'string';

	} else if ( typeOf === 'function' ) {

		return 'shader';

	} else if ( value.isVector2 === true ) {

		return 'vec2';

	} else if ( value.isVector3 === true ) {

		return 'vec3';

	} else if ( value.isVector4 === true ) {

		return 'vec4';

	} else if ( value.isMatrix3 === true ) {

		return 'mat3';

	} else if ( value.isMatrix4 === true ) {

		return 'mat4';

	} else if ( value.isColor === true ) {

		return 'color';

	} else if ( value instanceof ArrayBuffer ) {

		return 'ArrayBuffer';

	}

	return null;

}

/**
 * Returns the value/object for the given data type and parameters.
 *
 * @method
 * @param {String} type - The given type.
 * @param {...Any} params - A parameter list.
 * @return {Any} The value/object.
 */
function getValueFromType( type, ...params ) {

	const last4 = type ? type.slice( - 4 ) : undefined;

	if ( params.length === 1 ) { // ensure same behaviour as in NodeBuilder.format()

		if ( last4 === 'vec2' ) params = [ params[ 0 ], params[ 0 ] ];
		else if ( last4 === 'vec3' ) params = [ params[ 0 ], params[ 0 ], params[ 0 ] ];
		else if ( last4 === 'vec4' ) params = [ params[ 0 ], params[ 0 ], params[ 0 ], params[ 0 ] ];

	}

	if ( type === 'color' ) {

		return new Color( ...params );

	} else if ( last4 === 'vec2' ) {

		return new Vector2( ...params );

	} else if ( last4 === 'vec3' ) {

		return new Vector3( ...params );

	} else if ( last4 === 'vec4' ) {

		return new Vector4( ...params );

	} else if ( last4 === 'mat3' ) {

		return new Matrix3( ...params );

	} else if ( last4 === 'mat4' ) {

		return new Matrix4( ...params );

	} else if ( type === 'bool' ) {

		return params[ 0 ] || false;

	} else if ( ( type === 'float' ) || ( type === 'int' ) || ( type === 'uint' ) ) {

		return params[ 0 ] || 0;

	} else if ( type === 'string' ) {

		return params[ 0 ] || '';

	} else if ( type === 'ArrayBuffer' ) {

		return base64ToArrayBuffer( params[ 0 ] );

	}

	return null;

}

/**
 * Converts the given array buffer to a Base64 string.
 *
 * @method
 * @param {ArrayBuffer} arrayBuffer - The array buffer.
 * @return {String} The Base64 string.
 */
function arrayBufferToBase64( arrayBuffer ) {

	let chars = '';

	const array = new Uint8Array( arrayBuffer );

	for ( let i = 0; i < array.length; i ++ ) {

		chars += String.fromCharCode( array[ i ] );

	}

	return btoa( chars );

}

/**
 * Converts the given Base64 string to an array buffer.
 *
 * @method
 * @param {String} base64 - The Base64 string.
 * @return {ArrayBuffer} The array buffer.
 */
function base64ToArrayBuffer( base64 ) {

	return Uint8Array.from( atob( base64 ), c => c.charCodeAt( 0 ) ).buffer;

}

var NodeUtils = /*#__PURE__*/Object.freeze({
	__proto__: null,
	arrayBufferToBase64: arrayBufferToBase64,
	base64ToArrayBuffer: base64ToArrayBuffer,
	getCacheKey: getCacheKey$1,
	getLengthFromType: getLengthFromType,
	getNodeChildren: getNodeChildren,
	getTypeFromLength: getTypeFromLength,
	getValueFromType: getValueFromType,
	getValueType: getValueType,
	hash: hash$1,
	hashArray: hashArray,
	hashString: hashString
});

/** @module NodeConstants **/

/**
 * Possible shader stages.
 *
 * @property {string} VERTEX The vertex shader stage.
 * @property {string} FRAGMENT The fragment shader stage.
 */
const NodeShaderStage = {
	VERTEX: 'vertex',
	FRAGMENT: 'fragment'
};

/**
 * Update types of a node.
 *
 * @property {string} NONE The update method is not executed.
 * @property {string} FRAME The update method is executed per frame.
 * @property {string} RENDER The update method is executed per render. A frame might be produced by multiple render calls so this value allows more detailed updates than FRAME.
 * @property {string} OBJECT The update method is executed per {@link Object3D} that uses the node for rendering.
 */
const NodeUpdateType = {
	NONE: 'none',
	FRAME: 'frame',
	RENDER: 'render',
	OBJECT: 'object'
};

/**
 * Data types of a node.
 *
 * @property {string} BOOLEAN Boolean type.
 * @property {string} INTEGER Integer type.
 * @property {string} FLOAT Float type.
 * @property {string} VECTOR2 Two-dimensional vector type.
 * @property {string} VECTOR3 Three-dimensional vector type.
 * @property {string} VECTOR4 Four-dimensional vector type.
 * @property {string} MATRIX2 2x2 matrix type.
 * @property {string} MATRIX3 3x3 matrix type.
 * @property {string} MATRIX4 4x4 matrix type.
 */
const NodeType = {
	BOOLEAN: 'bool',
	INTEGER: 'int',
	FLOAT: 'float',
	VECTOR2: 'vec2',
	VECTOR3: 'vec3',
	VECTOR4: 'vec4',
	MATRIX2: 'mat2',
	MATRIX3: 'mat3',
	MATRIX4: 'mat4'
};

/**
 * Access types of a node. These are relevant for compute and storage usage.
 *
 * @property {string} READ_ONLY Read-only access
 * @property {string} WRITE_ONLY Write-only access.
 * @property {string} READ_WRITE Read and write access.
 */
const NodeAccess = {
	READ_ONLY: 'readOnly',
	WRITE_ONLY: 'writeOnly',
	READ_WRITE: 'readWrite',
};

const defaultShaderStages = [ 'fragment', 'vertex' ];
const defaultBuildStages = [ 'setup', 'analyze', 'generate' ];
const shaderStages = [ ...defaultShaderStages, 'compute' ];
const vectorComponents = [ 'x', 'y', 'z', 'w' ];

let _nodeId = 0;

/**
 * Base class for all nodes.
 *
 * @augments EventDispatcher
 */
class Node extends EventDispatcher {

	static get type() {

		return 'Node';

	}

	/**
	 * Constructs a new node.
	 *
	 * @param {String?} nodeType - The node type.
	 */
	constructor( nodeType = null ) {

		super();

		/**
		 * The node type. This represents the result type of the node (e.g. `float` or `vec3`).
		 *
		 * @type {String?}
		 * @default null
		 */
		this.nodeType = nodeType;

		/**
		 * The update type of the node's {@link Node#update} method. Possible values are listed in {@link NodeUpdateType}.
		 *
		 * @type {String}
		 * @default 'none'
		 */
		this.updateType = NodeUpdateType.NONE;

		/**
		 * The update type of the node's {@link Node#updateBefore} method. Possible values are listed in {@link NodeUpdateType}.
		 *
		 * @type {String}
		 * @default 'none'
		 */
		this.updateBeforeType = NodeUpdateType.NONE;

		/**
		 * The update type of the node's {@link Node#updateAfter} method. Possible values are listed in {@link NodeUpdateType}.
		 *
		 * @type {String}
		 * @default 'none'
		 */
		this.updateAfterType = NodeUpdateType.NONE;

		/**
		 * The UUID of the node.
		 *
		 * @type {String}
		 * @readonly
		 */
		this.uuid = MathUtils.generateUUID();

		/**
		 * The version of the node. The version automatically is increased when {@link Node#needsUpdate} is set to `true`.
		 *
		 * @type {Number}
		 * @readonly
		 * @default 0
		 */
		this.version = 0;

		/**
		 * Whether this node is global or not. This property is relevant for the internal
		 * node caching system. All nodes which should be declared just once should
		 * set this flag to `true` (a typical example is {@link AttributeNode}).
		 *
		 * @type {Boolean}
		 * @default false
		 */
		this.global = false;

		/**
		 * This flag can be used for type testing.
		 *
		 * @type {Boolean}
		 * @readonly
		 * @default true
		 */
		this.isNode = true;

		// private

		/**
		 * The cache key of this node.
		 *
		 * @private
		 * @type {Number?}
		 * @default null
		 */
		this._cacheKey = null;

		/**
		 * The cache key 's version.
		 *
		 * @private
		 * @type {Number}
		 * @default 0
		 */
		this._cacheKeyVersion = 0;

		Object.defineProperty( this, 'id', { value: _nodeId ++ } );

	}

	/**
	 * Set this property to `true` when the node should be regenerated.
	 *
	 * @type {Boolean}
	 * @default false
	 * @param {boolean} value
	 */
	set needsUpdate( value ) {

		if ( value === true ) {

			this.version ++;

		}

	}

	/**
	 * The type of the class. The value is usually the constructor name.
	 *
	 * @type {String}
 	 * @readonly
	 */
	get type() {

		return this.constructor.type;

	}

	/**
	 * Convenient method for defining {@link Node#update}.
	 *
	 * @param {Function} callback - The update method.
	 * @param {String} updateType - The update type.
	 * @return {Node} A reference to this node.
	 */
	onUpdate( callback, updateType ) {

		this.updateType = updateType;
		this.update = callback.bind( this.getSelf() );

		return this;

	}

	/**
	 * Convenient method for defining {@link Node#update}. Similar to {@link Node#onUpdate}, but
	 * this method automatically sets the update type to `FRAME`.
	 *
	 * @param {Function} callback - The update method.
	 * @return {Node} A reference to this node.
	 */
	onFrameUpdate( callback ) {

		return this.onUpdate( callback, NodeUpdateType.FRAME );

	}

	/**
	 * Convenient method for defining {@link Node#update}. Similar to {@link Node#onUpdate}, but
	 * this method automatically sets the update type to `RENDER`.
	 *
	 * @param {Function} callback - The update method.
	 * @return {Node} A reference to this node.
	 */
	onRenderUpdate( callback ) {

		return this.onUpdate( callback, NodeUpdateType.RENDER );

	}

	/**
	 * Convenient method for defining {@link Node#update}. Similar to {@link Node#onUpdate}, but
	 * this method automatically sets the update type to `OBJECT`.
	 *
	 * @param {Function} callback - The update method.
	 * @return {Node} A reference to this node.
	 */
	onObjectUpdate( callback ) {

		return this.onUpdate( callback, NodeUpdateType.OBJECT );

	}

	/**
	 * Convenient method for defining {@link Node#updateReference}.
	 *
	 * @param {Function} callback - The update method.
	 * @return {Node} A reference to this node.
	 */
	onReference( callback ) {

		this.updateReference = callback.bind( this.getSelf() );

		return this;

	}

	/**
	 * The `this` reference might point to a Proxy so this method can be used
	 * to get the reference to the actual node instance.
	 *
	 * @return {Node} A reference to the node.
	 */
	getSelf() {

		// Returns non-node object.

		return this.self || this;

	}

	/**
	 * Nodes might refer to other objects like materials. This method allows to dynamically update the reference
	 * to such objects based on a given state (e.g. the current node frame or builder).
	 *
	 * @param {Any} state - This method can be invocated in different contexts so `state` can refer to any object type.
	 * @return {Any} The updated reference.
	 */
	updateReference( /*state*/ ) {

		return this;

	}

	/**
	 * By default this method returns the value of the {@link Node#global} flag. This method
	 * can be overwritten in derived classes if an analytical way is required to determine the
	 * global status.
	 *
	 * @param {NodeBuilder} builder - The current node builder.
	 * @return {Boolean} Whether this node is global or not.
	 */
	isGlobal( /*builder*/ ) {

		return this.global;

	}

	/**
	 * Generator function that can be used to iterate over the child nodes.
	 *
	 * @generator
	 * @yields {Node} A child node.
	 */
	* getChildren() {

		for ( const { childNode } of getNodeChildren( this ) ) {

			yield childNode;

		}

	}

	/**
	 * Calling this method dispatches the `dispose` event. This event can be used
	 * to register event listeners for clean up tasks.
	 */
	dispose() {

		this.dispatchEvent( { type: 'dispose' } );

	}

	/**
	 * Callback for {@link Node#traverse}.
	 *
	 * @callback traverseCallback
	 * @param {Node} node - The current node.
	 */

	/**
	 * Can be used to traverse through the node's hierarchy.
	 *
	 * @param {traverseCallback} callback - A callback that is executed per node.
	 */
	traverse( callback ) {

		callback( this );

		for ( const childNode of this.getChildren() ) {

			childNode.traverse( callback );

		}

	}

	/**
	 * Returns the cache key for this node.
	 *
	 * @param {Boolean} [force=false] - When set to `true`, a recomputation of the cache key is forced.
	 * @return {Number} The cache key of the node.
	 */
	getCacheKey( force = false ) {

		force = force || this.version !== this._cacheKeyVersion;

		if ( force === true || this._cacheKey === null ) {

			this._cacheKey = hash$1( getCacheKey$1( this, force ), this.customCacheKey() );
			this._cacheKeyVersion = this.version;

		}

		return this._cacheKey;

	}

	/**
	 * Generate a custom cache key for this node.
	 *
	 * @return {Number} The cache key of the node.
	 */
	customCacheKey() {

		return 0;

	}

	/**
	 * Returns the references to this node which is by default `this`.
	 *
	 * @return {Node} A reference to this node.
	 */
	getScope() {

		return this;

	}

	/**
	 * Returns the hash of the node which is used to identify the node. By default it's
	 * the {@link Node#uuid} however derived node classes might have to overwrite this method
	 * depending on their implementation.
	 *
	 * @param {NodeBuilder} builder - The current node builder.
	 * @return {String} The hash.
	 */
	getHash( /*builder*/ ) {

		return this.uuid;

	}

	/**
	 * Returns the update type of {@link Node#update}.
	 *
	 * @return {NodeUpdateType} The update type.
	 */
	getUpdateType() {

		return this.updateType;

	}

	/**
	 * Returns the update type of {@link Node#updateBefore}.
	 *
	 * @return {NodeUpdateType} The update type.
	 */
	getUpdateBeforeType() {

		return this.updateBeforeType;

	}

	/**
	 * Returns the update type of {@link Node#updateAfter}.
	 *
	 * @return {NodeUpdateType} The update type.
	 */
	getUpdateAfterType() {

		return this.updateAfterType;

	}

	/**
	 * Certain types are composed of multiple elements. For example a `vec3`
	 * is composed of three `float` values. This method returns the type of
	 * these elements.
	 *
	 * @param {NodeBuilder} builder - The current node builder.
	 * @return {String} The type of the node.
	 */
	getElementType( builder ) {

		const type = this.getNodeType( builder );
		const elementType = builder.getElementType( type );

		return elementType;

	}

	/**
	 * Returns the node's type.
	 *
	 * @param {NodeBuilder} builder - The current node builder.
	 * @return {String} The type of the node.
	 */
	getNodeType( builder ) {

		const nodeProperties = builder.getNodeProperties( this );

		if ( nodeProperties.outputNode ) {

			return nodeProperties.outputNode.getNodeType( builder );

		}

		return this.nodeType;

	}

	/**
	 * This method is used during the build process of a node and ensures
	 * equal nodes are not built multiple times but just once. For example if
	 * `attribute( 'uv' )` is used multiple times by the user, the build
	 * process makes sure to process just the first node.
	 *
	 * @param {NodeBuilder} builder - The current node builder.
	 * @return {Node} The shared node if possible. Otherwise `this` is returned.
	 */
	getShared( builder ) {

		const hash = this.getHash( builder );
		const nodeFromHash = builder.getNodeFromHash( hash );

		return nodeFromHash || this;

	}

	/**
	 * Represents the setup stage which is the first step of the build process, see {@link Node#build} method.
	 * This method is often overwritten in derived modules to prepare the node which is used as the output/result.
	 * The output node must be returned in the `return` statement.
	 *
	 * @param {NodeBuilder} builder - The current node builder.
	 * @return {Node?} The output node.
	 */
	setup( builder ) {

		const nodeProperties = builder.getNodeProperties( this );

		let index = 0;

		for ( const childNode of this.getChildren() ) {

			nodeProperties[ 'node' + index ++ ] = childNode;

		}

		// return a outputNode if exists
		return null;

	}

	/**
	 * Represents the analyze stage which is the second step of the build process, see {@link Node#build} method.
	 * This stage analyzes the node hierarchy and ensures descendent nodes are built.
	 *
	 * @param {NodeBuilder} builder - The current node builder.
	 */
	analyze( builder ) {

		const usageCount = builder.increaseUsage( this );

		if ( usageCount === 1 ) {

			// node flow children

			const nodeProperties = builder.getNodeProperties( this );

			for ( const childNode of Object.values( nodeProperties ) ) {

				if ( childNode && childNode.isNode === true ) {

					childNode.build( builder );

				}

			}

		}

	}

	/**
	 * Represents the generate stage which is the third step of the build process, see {@link Node#build} method.
	 * This state builds the output node and returns the resulting shader string.
	 *
	 * @param {NodeBuilder} builder - The current node builder.
	 * @param {String?} output - Can be used to define the output type.
	 * @return {String?} The generated shader string.
	 */
	generate( builder, output ) {

		const { outputNode } = builder.getNodeProperties( this );

		if ( outputNode && outputNode.isNode === true ) {

			return outputNode.build( builder, output );

		}

	}

	/**
	 * The method can be implemented to update the node's internal state before it is used to render an object.
	 * The {@link Node#updateBeforeType} property defines how often the update is executed.
	 *
	 * @abstract
	 * @param {NodeFrame} frame - A reference to the current node frame.
	 * @return {Boolean?} An optional bool that indicates whether the implementation actually performed an update or not (e.g. due to caching).
	 */
	updateBefore( /*frame*/ ) {

		console.warn( 'Abstract function.' );

	}

	/**
	 * The method can be implemented to update the node's internal state after it was used to render an object.
	 * The {@link Node#updateAfterType} property defines how often the update is executed.
	 *
	 * @abstract
	 * @param {NodeFrame} frame - A reference to the current node frame.
	 * @return {Boolean?} An optional bool that indicates whether the implementation actually performed an update or not (e.g. due to caching).
	 */
	updateAfter( /*frame*/ ) {

		console.warn( 'Abstract function.' );

	}

	/**
	 * The method can be implemented to update the node's internal state when it is used to render an object.
	 * The {@link Node#updateType} property defines how often the update is executed.
	 *
	 * @abstract
	 * @param {NodeFrame} frame - A reference to the current node frame.
	 * @return {Boolean?} An optional bool that indicates whether the implementation actually performed an update or not (e.g. due to caching).
	 */
	update( /*frame*/ ) {

		console.warn( 'Abstract function.' );

	}

	/**
	 * This method performs the build of a node. The behavior of this method as well as its return value depend
	 * on the current build stage (setup, analyze or generate).
	 *
	 * @param {NodeBuilder} builder - The current node builder.
	 * @param {String?} output - Can be used to define the output type.
	 * @return {String?} When this method is executed in the setup or analyze stage, `null` is returned. In the generate stage, the generated shader string.
	 */
	build( builder, output = null ) {

		const refNode = this.getShared( builder );

		if ( this !== refNode ) {

			return refNode.build( builder, output );

		}

		builder.addNode( this );
		builder.addChain( this );

		/* Build stages expected results:
			- "setup"		-> Node
			- "analyze"		-> null
			- "generate"	-> String
		*/
		let result = null;

		const buildStage = builder.getBuildStage();

		if ( buildStage === 'setup' ) {

			this.updateReference( builder );

			const properties = builder.getNodeProperties( this );

			if ( properties.initialized !== true ) {

				const stackNodesBeforeSetup = builder.stack.nodes.length;

				properties.initialized = true;
				properties.outputNode = this.setup( builder );

				if ( properties.outputNode !== null && builder.stack.nodes.length !== stackNodesBeforeSetup ) ;

				for ( const childNode of Object.values( properties ) ) {

					if ( childNode && childNode.isNode === true ) {

						childNode.build( builder );

					}

				}

			}

		} else if ( buildStage === 'analyze' ) {

			this.analyze( builder );

		} else if ( buildStage === 'generate' ) {

			const isGenerateOnce = this.generate.length === 1;

			if ( isGenerateOnce ) {

				const type = this.getNodeType( builder );
				const nodeData = builder.getDataFromNode( this );

				result = nodeData.snippet;

				if ( result === undefined ) {

					result = this.generate( builder ) || '';

					nodeData.snippet = result;

				} else if ( nodeData.flowCodes !== undefined && builder.context.nodeBlock !== undefined ) {

					builder.addFlowCodeHierarchy( this, builder.context.nodeBlock );

				}

				result = builder.format( result, type, output );

			} else {

				result = this.generate( builder, output ) || '';

			}

		}

		builder.removeChain( this );
		builder.addSequentialNode( this );

		return result;

	}

	/**
	 * Returns the child nodes as a JSON object.
	 *
	 * @return {Object} The serialized child objects as JSON.
	 */
	getSerializeChildren() {

		return getNodeChildren( this );

	}

	/**
	 * Serializes the node to JSON.
	 *
	 * @param {Object} json - The output JSON object.
	 */
	serialize( json ) {

		const nodeChildren = this.getSerializeChildren();

		const inputNodes = {};

		for ( const { property, index, childNode } of nodeChildren ) {

			if ( index !== undefined ) {

				if ( inputNodes[ property ] === undefined ) {

					inputNodes[ property ] = Number.isInteger( index ) ? [] : {};

				}

				inputNodes[ property ][ index ] = childNode.toJSON( json.meta ).uuid;

			} else {

				inputNodes[ property ] = childNode.toJSON( json.meta ).uuid;

			}

		}

		if ( Object.keys( inputNodes ).length > 0 ) {

			json.inputNodes = inputNodes;

		}

	}

	/**
	 * Deserializes the node from the given JSON.
	 *
	 * @param {Object} json - The JSON object.
	 */
	deserialize( json ) {

		if ( json.inputNodes !== undefined ) {

			const nodes = json.meta.nodes;

			for ( const property in json.inputNodes ) {

				if ( Array.isArray( json.inputNodes[ property ] ) ) {

					const inputArray = [];

					for ( const uuid of json.inputNodes[ property ] ) {

						inputArray.push( nodes[ uuid ] );

					}

					this[ property ] = inputArray;

				} else if ( typeof json.inputNodes[ property ] === 'object' ) {

					const inputObject = {};

					for ( const subProperty in json.inputNodes[ property ] ) {

						const uuid = json.inputNodes[ property ][ subProperty ];

						inputObject[ subProperty ] = nodes[ uuid ];

					}

					this[ property ] = inputObject;

				} else {

					const uuid = json.inputNodes[ property ];

					this[ property ] = nodes[ uuid ];

				}

			}

		}

	}

	/**
	 * Serializes the node into the three.js JSON Object/Scene format.
	 *
	 * @param {Object?} meta - An optional JSON object that already holds serialized data from other scene objects.
	 * @return {Object} The serialized node.
	 */
	toJSON( meta ) {

		const { uuid, type } = this;
		const isRoot = ( meta === undefined || typeof meta === 'string' );

		if ( isRoot ) {

			meta = {
				textures: {},
				images: {},
				nodes: {}
			};

		}

		// serialize

		let data = meta.nodes[ uuid ];

		if ( data === undefined ) {

			data = {
				uuid,
				type,
				meta,
				metadata: {
					version: 4.6,
					type: 'Node',
					generator: 'Node.toJSON'
				}
			};

			if ( isRoot !== true ) meta.nodes[ data.uuid ] = data;

			this.serialize( data );

			delete data.meta;

		}

		// TODO: Copied from Object3D.toJSON

		function extractFromCache( cache ) {

			const values = [];

			for ( const key in cache ) {

				const data = cache[ key ];
				delete data.metadata;
				values.push( data );

			}

			return values;

		}

		if ( isRoot ) {

			const textures = extractFromCache( meta.textures );
			const images = extractFromCache( meta.images );
			const nodes = extractFromCache( meta.nodes );

			if ( textures.length > 0 ) data.textures = textures;
			if ( images.length > 0 ) data.images = images;
			if ( nodes.length > 0 ) data.nodes = nodes;

		}

		return data;

	}

}

/**
 * Base class for representing element access on an array-like
 * node data structures.
 *
 * @augments Node
 */
class ArrayElementNode extends Node { // @TODO: If extending from TempNode it breaks webgpu_compute

	static get type() {

		return 'ArrayElementNode';

	}

	/**
	 * Constructs an array element node.
	 *
	 * @param {Node} node - The array-like node.
	 * @param {Node} indexNode - The index node that defines the element access.
	 */
	constructor( node, indexNode ) {

		super();

		/**
		 * The array-like node.
		 *
		 * @type {Node}
		 */
		this.node = node;

		/**
		 * The index node that defines the element access.
		 *
		 * @type {Node}
		 */
		this.indexNode = indexNode;

		/**
		 * This flag can be used for type testing.
		 *
		 * @type {Boolean}
		 * @readonly
		 * @default true
		 */
		this.isArrayElementNode = true;

	}

	/**
	 * This method is overwritten since the node type is inferred from the array-like node.
	 *
	 * @param {NodeBuilder} builder - The current node builder.
	 * @return {String} The node type.
	 */
	getNodeType( builder ) {

		return this.node.getElementType( builder );

	}

	generate( builder ) {

		const nodeSnippet = this.node.build( builder );
		const indexSnippet = this.indexNode.build( builder, 'uint' );

		return `${nodeSnippet}[ ${indexSnippet} ]`;

	}

}

/**
 * This module is part of the TSL core and usually not used in app level code.
 * It represents a convert operation during the shader generation process
 * meaning it converts the data type of a node to a target data type.
 *
 * @augments Node
 */
class ConvertNode extends Node {

	static get type() {

		return 'ConvertNode';

	}

	/**
	 * Constructs a new convert node.
	 *
	 * @param {Node} node - The node which type should be converted.
	 * @param {String} convertTo - The target node type. Multiple types can be defined by separating them with a `|` sign.
	 */
	constructor( node, convertTo ) {

		super();

		/**
		 * The node which type should be converted.
		 *
		 * @type {Node}
		 */
		this.node = node;

		/**
		 * The target node type. Multiple types can be defined by separating them with a `|` sign.
		 *
		 * @type {String}
		 */
		this.convertTo = convertTo;

	}

	/**
	 * This method is overwritten since the implementation tries to infer the best
	 * matching type from the {@link ConvertNode#convertTo} property.
	 *
	 * @param {NodeBuilder} builder - The current node builder.
	 * @return {String} The node type.
	 */
	getNodeType( builder ) {

		const requestType = this.node.getNodeType( builder );

		let convertTo = null;

		for ( const overloadingType of this.convertTo.split( '|' ) ) {

			if ( convertTo === null || builder.getTypeLength( requestType ) === builder.getTypeLength( overloadingType ) ) {

				convertTo = overloadingType;

			}

		}

		return convertTo;

	}

	serialize( data ) {

		super.serialize( data );

		data.convertTo = this.convertTo;

	}

	deserialize( data ) {

		super.deserialize( data );

		this.convertTo = data.convertTo;

	}

	generate( builder, output ) {

		const node = this.node;
		const type = this.getNodeType( builder );

		const snippet = node.build( builder, type );

		return builder.format( snippet, type, output );

	}

}

/**
 * This module uses cache management to create temporary variables
 * if the node is used more than once to prevent duplicate calculations.
 *
 * The class acts as a base class for many other nodes types.
 *
 * @augments Node
 */
class TempNode extends Node {

	static get type() {

		return 'TempNode';

	}

	/**
	 * Constructs a temp node.
	 *
	 * @param {String?} nodeType - The node type.
	 */
	constructor( nodeType = null ) {

		super( nodeType );

		/**
		 * This flag can be used for type testing.
		 *
		 * @type {Boolean}
		 * @readonly
		 * @default true
		 */
		this.isTempNode = true;

	}

	/**
	 * Whether this node is used more than once in context of other nodes.
	 *
	 * @param {NodeBuilder} builder - The node builder.
	 * @return {Boolean} A flag that indicates if there is more than one dependency to other nodes.
	 */
	hasDependencies( builder ) {

		return builder.getDataFromNode( this ).usageCount > 1;

	}

	build( builder, output ) {

		const buildStage = builder.getBuildStage();

		if ( buildStage === 'generate' ) {

			const type = builder.getVectorType( this.getNodeType( builder, output ) );
			const nodeData = builder.getDataFromNode( this );

			if ( nodeData.propertyName !== undefined ) {

				return builder.format( nodeData.propertyName, type, output );

			} else if ( type !== 'void' && output !== 'void' && this.hasDependencies( builder ) ) {

				const snippet = super.build( builder, type );

				const nodeVar = builder.getVarFromNode( this, null, type );
				const propertyName = builder.getPropertyName( nodeVar );

				builder.addLineFlowCode( `${propertyName} = ${snippet}`, this );

				nodeData.snippet = snippet;
				nodeData.propertyName = propertyName;

				return builder.format( nodeData.propertyName, type, output );

			}

		}

		return super.build( builder, output );

	}

}

/**
 * This module is part of the TSL core and usually not used in app level code.
 * It represents a join operation during the shader generation process.
 * For example in can compose/join two single floats into a `vec2` type.
 *
 * @augments TempNode
 */
class JoinNode extends TempNode {

	static get type() {

		return 'JoinNode';

	}

	/**
	 * Constructs a new join node.
	 *
	 * @param {Array<Node>} nodes - An array of nodes that should be joined.
	 * @param {String?} [nodeType=null] - The node type.
	 */
	constructor( nodes = [], nodeType = null ) {

		super( nodeType );

		/**
		 * An array of nodes that should be joined.
		 *
		 * @type {Array<Node>}
		 */
		this.nodes = nodes;

	}

	/**
	 * This method is overwritten since the node type must be inferred from the
	 * joined data length if not explicitly defined.
	 *
	 * @param {NodeBuilder} builder - The current node builder.
	 * @return {String} The node type.
	 */
	getNodeType( builder ) {

		if ( this.nodeType !== null ) {

			return builder.getVectorType( this.nodeType );

		}

		return builder.getTypeFromLength( this.nodes.reduce( ( count, cur ) => count + builder.getTypeLength( cur.getNodeType( builder ) ), 0 ) );

	}

	generate( builder, output ) {

		const type = this.getNodeType( builder );
		const nodes = this.nodes;

		const primitiveType = builder.getComponentType( type );

		const snippetValues = [];

		for ( const input of nodes ) {

			let inputSnippet = input.build( builder );

			const inputPrimitiveType = builder.getComponentType( input.getNodeType( builder ) );

			if ( inputPrimitiveType !== primitiveType ) {

				inputSnippet = builder.format( inputSnippet, inputPrimitiveType, primitiveType );

			}

			snippetValues.push( inputSnippet );

		}

		const snippet = `${ builder.getType( type ) }( ${ snippetValues.join( ', ' ) } )`;

		return builder.format( snippet, type, output );

	}

}

const _stringVectorComponents = vectorComponents.join( '' );

/**
 * This module is part of the TSL core and usually not used in app level code.
 * `SplitNode` represents a property access operation which means it is
 * used to implement any `.xyzw`, `.rgba` and `stpq` usage on node objects.
 * For example:
 * ```js
 * const redValue = color.r;
 * ```
 *
 * @augments Node
 */
class SplitNode extends Node {

	static get type() {

		return 'SplitNode';

	}

	/**
	 * Constructs a new split node.
	 *
	 * @param {Node} node - The node that should be accessed.
	 * @param {String} [components='x'] - The components that should be accessed.
	 */
	constructor( node, components = 'x' ) {

		super();

		/**
		 * The node that should be accessed.
		 *
		 * @type {Node}
		 */
		this.node = node;

		/**
		 * The components that should be accessed.
		 *
		 * @type {string}
		 */
		this.components = components;

		/**
		 * This flag can be used for type testing.
		 *
		 * @type {Boolean}
		 * @readonly
		 * @default true
		 */
		this.isSplitNode = true;

	}

	/**
	 * Returns the vector length which is computed based on the requested components.
	 *
	 * @return {Number} The vector length.
	 */
	getVectorLength() {

		let vectorLength = this.components.length;

		for ( const c of this.components ) {

			vectorLength = Math.max( vectorComponents.indexOf( c ) + 1, vectorLength );

		}

		return vectorLength;

	}

	/**
	 * Returns the component type of the node's type.
	 *
	 * @param {NodeBuilder} builder - The current node builder.
	 * @return {String} The component type.
	 */
	getComponentType( builder ) {

		return builder.getComponentType( this.node.getNodeType( builder ) );

	}

	/**
	 * This method is overwritten since the node type is inferred from requested components.
	 *
	 * @param {NodeBuilder} builder - The current node builder.
	 * @return {String} The node type.
	 */
	getNodeType( builder ) {

		return builder.getTypeFromLength( this.components.length, this.getComponentType( builder ) );

	}

	generate( builder, output ) {

		const node = this.node;
		const nodeTypeLength = builder.getTypeLength( node.getNodeType( builder ) );

		let snippet = null;

		if ( nodeTypeLength > 1 ) {

			let type = null;

			const componentsLength = this.getVectorLength();

			if ( componentsLength >= nodeTypeLength ) {

				// needed expand the input node

				type = builder.getTypeFromLength( this.getVectorLength(), this.getComponentType( builder ) );

			}

			const nodeSnippet = node.build( builder, type );

			if ( this.components.length === nodeTypeLength && this.components === _stringVectorComponents.slice( 0, this.components.length ) ) {

				// unnecessary swizzle

				snippet = builder.format( nodeSnippet, type, output );

			} else {

				snippet = builder.format( `${nodeSnippet}.${this.components}`, this.getNodeType( builder ), output );

			}

		} else {

			// ignore .components if .node returns float/integer

			snippet = node.build( builder, output );

		}

		return snippet;

	}

	serialize( data ) {

		super.serialize( data );

		data.components = this.components;

	}

	deserialize( data ) {

		super.deserialize( data );

		this.components = data.components;

	}

}

/**
 * This module is part of the TSL core and usually not used in app level code.
 * `SetNode` represents a set operation which means it is used to implement any
 * `setXYZW()`, `setRGBA()` and `setSTPQ()` method invocations on node objects.
 * For example:
 * ```js
 * materialLine.colorNode = color( 0, 0, 0 ).setR( float( 1 ) );
 * ```
 *
 * @augments TempNode
 */
class SetNode extends TempNode {

	static get type() {

		return 'SetNode';

	}

	/**
	 * Constructs a new set node.
	 *
	 * @param {Node} sourceNode - The node that should be updated.
	 * @param {String} components - The components that should be updated.
	 * @param {Node} targetNode - The value node.
	 */
	constructor( sourceNode, components, targetNode ) {

		super();

		/**
		 * The node that should be updated.
		 *
		 * @type {Node}
		 */
		this.sourceNode = sourceNode;

		/**
		 * The components that should be updated.
		 *
		 * @type {String}
		 */
		this.components = components;

		/**
		 * The value node.
		 *
		 * @type {Node}
		 */
		this.targetNode = targetNode;

	}

	/**
	 * This method is overwritten since the node type is inferred from {@link SetNode#sourceNode}.
	 *
	 * @param {NodeBuilder} builder - The current node builder.
	 * @return {String} The node type.
	 */
	getNodeType( builder ) {

		return this.sourceNode.getNodeType( builder );

	}

	generate( builder ) {

		const { sourceNode, components, targetNode } = this;

		const sourceType = this.getNodeType( builder );

		const componentType = builder.getComponentType( targetNode.getNodeType( builder ) );
		const targetType = builder.getTypeFromLength( components.length, componentType );

		const targetSnippet = targetNode.build( builder, targetType );
		const sourceSnippet = sourceNode.build( builder, sourceType );

		const length = builder.getTypeLength( sourceType );
		const snippetValues = [];

		for ( let i = 0; i < length; i ++ ) {

			const component = vectorComponents[ i ];

			if ( component === components[ 0 ] ) {

				snippetValues.push( targetSnippet );

				i += components.length - 1;

			} else {

				snippetValues.push( sourceSnippet + '.' + component );

			}

		}

		return `${ builder.getType( sourceType ) }( ${ snippetValues.join( ', ' ) } )`;

	}

}

/**
 * This module is part of the TSL core and usually not used in app level code.
 * It represents a flip operation during the shader generation process
 * meaning it flips normalized values with the following formula:
 * ```
 * x = 1 - x;
 * ```
 * `FlipNode` is internally used to implement any `flipXYZW()`, `flipRGBA()` and
 * `flipSTPQ()` method invocations on node objects. For example:
 * ```js
 * uvNode = uvNode.flipY();
 * ```
 *
 * @augments TempNode
 */
class FlipNode extends TempNode {

	static get type() {

		return 'FlipNode';

	}

	/**
	 * Constructs a new flip node.
	 *
	 * @param {Node} sourceNode - The node which component(s) should be flipped.
	 * @param {String} components - The components that should be flipped e.g. `'x'` or `'xy'`.
	 */
	constructor( sourceNode, components ) {

		super();

		/**
		 * The node which component(s) should be flipped.
		 *
		 * @type {Node}
		 */
		this.sourceNode = sourceNode;

		/**
		 * The components that should be flipped e.g. `'x'` or `'xy'`.
		 *
		 * @type {String}
		 */
		this.components = components;

	}

	/**
	 * This method is overwritten since the node type is inferred from the source node.
	 *
	 * @param {NodeBuilder} builder - The current node builder.
	 * @return {String} The node type.
	 */
	getNodeType( builder ) {

		return this.sourceNode.getNodeType( builder );

	}

	generate( builder ) {

		const { components, sourceNode } = this;

		const sourceType = this.getNodeType( builder );
		const sourceSnippet = sourceNode.build( builder );

		const sourceCache = builder.getVarFromNode( this );
		const sourceProperty = builder.getPropertyName( sourceCache );

		builder.addLineFlowCode( sourceProperty + ' = ' + sourceSnippet, this );

		const length = builder.getTypeLength( sourceType );
		const snippetValues = [];

		let componentIndex = 0;

		for ( let i = 0; i < length; i ++ ) {

			const component = vectorComponents[ i ];

			if ( component === components[ componentIndex ] ) {

				snippetValues.push( '1.0 - ' + ( sourceProperty + '.' + component ) );

				componentIndex ++;

			} else {

				snippetValues.push( sourceProperty + '.' + component );

			}

		}

		return `${ builder.getType( sourceType ) }( ${ snippetValues.join( ', ' ) } )`;

	}

}

/**
 * Base class for representing data input nodes.
 *
 * @augments Node
 */
class InputNode extends Node {

	static get type() {

		return 'InputNode';

	}

	/**
	 * Constructs a new input node.
	 *
	 * @param {Any} value - The value of this node. This can be a any JS primitive, functions, array buffers or even three.js objects (vector, matrices, colors).
	 * @param {String?} nodeType - The node type. If no explicit type is defined, the node tries to derive the type from its value.
	 */
	constructor( value, nodeType = null ) {

		super( nodeType );

		/**
		 * This flag can be used for type testing.
		 *
		 * @type {Boolean}
		 * @readonly
		 * @default true
		 */
		this.isInputNode = true;

		/**
		 * The value of this node. This can be a any JS primitive, functions, array buffers or even three.js objects (vector, matrices, colors).
		 *
		 * @type {Any}
		 */
		this.value = value;

		/**
		 * The precision of the value in the shader.
		 *
		 * @type {('low'|'medium'|'high')?}
		 * @default null
		 */
		this.precision = null;

	}

	getNodeType( /*builder*/ ) {

		if ( this.nodeType === null ) {

			return getValueType( this.value );

		}

		return this.nodeType;

	}

	/**
	 * Returns the input type of the node which is by default the node type. Derived modules
	 * might overwrite this method and use a fixed type or compute one analytically.
	 *
	 * A typical example for different input and node types are textures. The input type of a
	 * normal RGBA texture is `texture` whereas its node type is `vec4`.
	 *
	 * @param {NodeBuilder} builder - The current node builder.
	 * @return {String} The input type.
	 */
	getInputType( builder ) {

		return this.getNodeType( builder );

	}

	/**
	 * Sets the precision to the given value. The method can be
	 * overwritten in derived classes if the final precision must be computed
	 * analytically.
	 *
	 * @param {('low'|'medium'|'high')} precision - The precision of the input value in the shader.
	 * @return {InputNode} A reference to this node.
	 */
	setPrecision( precision ) {

		this.precision = precision;

		return this;

	}

	serialize( data ) {

		super.serialize( data );

		data.value = this.value;

		if ( this.value && this.value.toArray ) data.value = this.value.toArray();

		data.valueType = getValueType( this.value );
		data.nodeType = this.nodeType;

		if ( data.valueType === 'ArrayBuffer' ) data.value = arrayBufferToBase64( data.value );

		data.precision = this.precision;

	}

	deserialize( data ) {

		super.deserialize( data );

		this.nodeType = data.nodeType;
		this.value = Array.isArray( data.value ) ? getValueFromType( data.valueType, ...data.value ) : data.value;

		this.precision = data.precision || null;

		if ( this.value && this.value.fromArray ) this.value = this.value.fromArray( data.value );

	}

	generate( /*builder, output*/ ) {

		console.warn( 'Abstract function.' );

	}

}

/**
 * Class for representing a constant value in the shader.
 *
 * @augments InputNode
 */
class ConstNode extends InputNode {

	static get type() {

		return 'ConstNode';

	}

	/**
	 * Constructs a new input node.
	 *
	 * @param {Any} value - The value of this node. Usually a JS primitive or three.js object (vector, matrix, color).
	 * @param {String?} nodeType - The node type. If no explicit type is defined, the node tries to derive the type from its value.
	 */
	constructor( value, nodeType = null ) {

		super( value, nodeType );

		/**
		 * This flag can be used for type testing.
		 *
		 * @type {Boolean}
		 * @readonly
		 * @default true
		 */
		this.isConstNode = true;

	}

	/**
	 * Generates the shader string of the value with the current node builder.
	 *
	 * @param {NodeBuilder} builder - The current node builder.
	 * @return {String} The generated value as a shader string.
	 */
	generateConst( builder ) {

		return builder.generateConst( this.getNodeType( builder ), this.value );

	}

	generate( builder, output ) {

		const type = this.getNodeType( builder );

		return builder.format( this.generateConst( builder ), type, output );

	}

}

//

let currentStack = null;

const NodeElements = new Map();

function addMethodChaining( name, nodeElement ) {

	if ( NodeElements.has( name ) ) {

		console.warn( `Redefinition of method chaining ${ name }` );
		return;

	}

	if ( typeof nodeElement !== 'function' ) throw new Error( `Node element ${ name } is not a function` );

	NodeElements.set( name, nodeElement );

}

const parseSwizzle = ( props ) => props.replace( /r|s/g, 'x' ).replace( /g|t/g, 'y' ).replace( /b|p/g, 'z' ).replace( /a|q/g, 'w' );
const parseSwizzleAndSort = ( props ) => parseSwizzle( props ).split( '' ).sort().join( '' );

const shaderNodeHandler = {

	setup( NodeClosure, params ) {

		const inputs = params.shift();

		return NodeClosure( nodeObjects( inputs ), ...params );

	},

	get( node, prop, nodeObj ) {

		if ( typeof prop === 'string' && node[ prop ] === undefined ) {

			if ( node.isStackNode !== true && prop === 'assign' ) {

				return ( ...params ) => {

					currentStack.assign( nodeObj, ...params );

					return nodeObj;

				};

			} else if ( NodeElements.has( prop ) ) {

				const nodeElement = NodeElements.get( prop );

				return node.isStackNode ? ( ...params ) => nodeObj.add( nodeElement( ...params ) ) : ( ...params ) => nodeElement( nodeObj, ...params );

			} else if ( prop === 'self' ) {

				return node;

			} else if ( prop.endsWith( 'Assign' ) && NodeElements.has( prop.slice( 0, prop.length - 'Assign'.length ) ) ) {

				const nodeElement = NodeElements.get( prop.slice( 0, prop.length - 'Assign'.length ) );

				return node.isStackNode ? ( ...params ) => nodeObj.assign( params[ 0 ], nodeElement( ...params ) ) : ( ...params ) => nodeObj.assign( nodeElement( nodeObj, ...params ) );

			} else if ( /^[xyzwrgbastpq]{1,4}$/.test( prop ) === true ) {

				// accessing properties ( swizzle )

				prop = parseSwizzle( prop );

				return nodeObject( new SplitNode( nodeObj, prop ) );

			} else if ( /^set[XYZWRGBASTPQ]{1,4}$/.test( prop ) === true ) {

				// set properties ( swizzle ) and sort to xyzw sequence

				prop = parseSwizzleAndSort( prop.slice( 3 ).toLowerCase() );

				return ( value ) => nodeObject( new SetNode( node, prop, value ) );

			} else if ( /^flip[XYZWRGBASTPQ]{1,4}$/.test( prop ) === true ) {

				// set properties ( swizzle ) and sort to xyzw sequence

				prop = parseSwizzleAndSort( prop.slice( 4 ).toLowerCase() );

				return () => nodeObject( new FlipNode( nodeObject( node ), prop ) );

			} else if ( prop === 'width' || prop === 'height' || prop === 'depth' ) {

				// accessing property

				if ( prop === 'width' ) prop = 'x';
				else if ( prop === 'height' ) prop = 'y';
				else if ( prop === 'depth' ) prop = 'z';

				return nodeObject( new SplitNode( node, prop ) );

			} else if ( /^\d+$/.test( prop ) === true ) {

				// accessing array

				return nodeObject( new ArrayElementNode( nodeObj, new ConstNode( Number( prop ), 'uint' ) ) );

			}

		}

		return Reflect.get( node, prop, nodeObj );

	},

	set( node, prop, value, nodeObj ) {

		if ( typeof prop === 'string' && node[ prop ] === undefined ) {

			// setting properties

			if ( /^[xyzwrgbastpq]{1,4}$/.test( prop ) === true || prop === 'width' || prop === 'height' || prop === 'depth' || /^\d+$/.test( prop ) === true ) {

				nodeObj[ prop ].assign( value );

				return true;

			}

		}

		return Reflect.set( node, prop, value, nodeObj );

	}

};

const nodeObjectsCacheMap = new WeakMap();
const nodeBuilderFunctionsCacheMap = new WeakMap();

const ShaderNodeObject = function ( obj, altType = null ) {

	const type = getValueType( obj );

	if ( type === 'node' ) {

		let nodeObject = nodeObjectsCacheMap.get( obj );

		if ( nodeObject === undefined ) {

			nodeObject = new Proxy( obj, shaderNodeHandler );

			nodeObjectsCacheMap.set( obj, nodeObject );
			nodeObjectsCacheMap.set( nodeObject, nodeObject );

		}

		return nodeObject;

	} else if ( ( altType === null && ( type === 'float' || type === 'boolean' ) ) || ( type && type !== 'shader' && type !== 'string' ) ) {

		return nodeObject( getConstNode( obj, altType ) );

	} else if ( type === 'shader' ) {

		return Fn( obj );

	}

	return obj;

};

const ShaderNodeObjects = function ( objects, altType = null ) {

	for ( const name in objects ) {

		objects[ name ] = nodeObject( objects[ name ], altType );

	}

	return objects;

};

const ShaderNodeArray = function ( array, altType = null ) {

	const len = array.length;

	for ( let i = 0; i < len; i ++ ) {

		array[ i ] = nodeObject( array[ i ], altType );

	}

	return array;

};

const ShaderNodeProxy = function ( NodeClass, scope = null, factor = null, settings = null ) {

	const assignNode = ( node ) => nodeObject( settings !== null ? Object.assign( node, settings ) : node );

	if ( scope === null ) {

		return ( ...params ) => {

			return assignNode( new NodeClass( ...nodeArray( params ) ) );

		};

	} else if ( factor !== null ) {

		factor = nodeObject( factor );

		return ( ...params ) => {

			return assignNode( new NodeClass( scope, ...nodeArray( params ), factor ) );

		};

	} else {

		return ( ...params ) => {

			return assignNode( new NodeClass( scope, ...nodeArray( params ) ) );

		};

	}

};

const ShaderNodeImmutable = function ( NodeClass, ...params ) {

	return nodeObject( new NodeClass( ...nodeArray( params ) ) );

};

class ShaderCallNodeInternal extends Node {

	constructor( shaderNode, inputNodes ) {

		super();

		this.shaderNode = shaderNode;
		this.inputNodes = inputNodes;

	}

	getNodeType( builder ) {

		return this.shaderNode.nodeType || this.getOutputNode( builder ).getNodeType( builder );

	}

	call( builder ) {

		const { shaderNode, inputNodes } = this;

		const properties = builder.getNodeProperties( shaderNode );
		if ( properties.onceOutput ) return properties.onceOutput;

		//

		let result = null;

		if ( shaderNode.layout ) {

			let functionNodesCacheMap = nodeBuilderFunctionsCacheMap.get( builder.constructor );

			if ( functionNodesCacheMap === undefined ) {

				functionNodesCacheMap = new WeakMap();

				nodeBuilderFunctionsCacheMap.set( builder.constructor, functionNodesCacheMap );

			}

			let functionNode = functionNodesCacheMap.get( shaderNode );

			if ( functionNode === undefined ) {

				functionNode = nodeObject( builder.buildFunctionNode( shaderNode ) );

				functionNodesCacheMap.set( shaderNode, functionNode );

			}

			if ( builder.currentFunctionNode !== null ) {

				builder.currentFunctionNode.includes.push( functionNode );

			}

			result = nodeObject( functionNode.call( inputNodes ) );

		} else {

			const jsFunc = shaderNode.jsFunc;
			const outputNode = inputNodes !== null ? jsFunc( inputNodes, builder ) : jsFunc( builder );

			result = nodeObject( outputNode );

		}

		if ( shaderNode.once ) {

			properties.onceOutput = result;

		}

		return result;

	}

	getOutputNode( builder ) {

		const properties = builder.getNodeProperties( this );

		if ( properties.outputNode === null ) {

			properties.outputNode = this.setupOutput( builder );

		}

		return properties.outputNode;

	}

	setup( builder ) {

		return this.getOutputNode( builder );

	}

	setupOutput( builder ) {

		builder.addStack();

		builder.stack.outputNode = this.call( builder );

		return builder.removeStack();

	}

	generate( builder, output ) {

		const outputNode = this.getOutputNode( builder );

		return outputNode.build( builder, output );

	}

}

class ShaderNodeInternal extends Node {

	constructor( jsFunc, nodeType ) {

		super( nodeType );

		this.jsFunc = jsFunc;
		this.layout = null;

		this.global = true;

		this.once = false;

	}

	setLayout( layout ) {

		this.layout = layout;

		return this;

	}

	call( inputs = null ) {

		nodeObjects( inputs );

		return nodeObject( new ShaderCallNodeInternal( this, inputs ) );

	}

	setup() {

		return this.call();

	}

}

const bools = [ false, true ];
const uints = [ 0, 1, 2, 3 ];
const ints = [ - 1, - 2 ];
const floats = [ 0.5, 1.5, 1 / 3, 1e-6, 1e6, Math.PI, Math.PI * 2, 1 / Math.PI, 2 / Math.PI, 1 / ( Math.PI * 2 ), Math.PI / 2 ];

const boolsCacheMap = new Map();
for ( const bool of bools ) boolsCacheMap.set( bool, new ConstNode( bool ) );

const uintsCacheMap = new Map();
for ( const uint of uints ) uintsCacheMap.set( uint, new ConstNode( uint, 'uint' ) );

const intsCacheMap = new Map( [ ...uintsCacheMap ].map( el => new ConstNode( el.value, 'int' ) ) );
for ( const int of ints ) intsCacheMap.set( int, new ConstNode( int, 'int' ) );

const floatsCacheMap = new Map( [ ...intsCacheMap ].map( el => new ConstNode( el.value ) ) );
for ( const float of floats ) floatsCacheMap.set( float, new ConstNode( float ) );
for ( const float of floats ) floatsCacheMap.set( - float, new ConstNode( - float ) );

const cacheMaps = { bool: boolsCacheMap, uint: uintsCacheMap, ints: intsCacheMap, float: floatsCacheMap };

const constNodesCacheMap = new Map( [ ...boolsCacheMap, ...floatsCacheMap ] );

const getConstNode = ( value, type ) => {

	if ( constNodesCacheMap.has( value ) ) {

		return constNodesCacheMap.get( value );

	} else if ( value.isNode === true ) {

		return value;

	} else {

		return new ConstNode( value, type );

	}

};

const safeGetNodeType = ( node ) => {

	try {

		return node.getNodeType();

	} catch ( _ ) {

		return undefined;

	}

};

const ConvertType = function ( type, cacheMap = null ) {

	return ( ...params ) => {

		if ( params.length === 0 || ( ! [ 'bool', 'float', 'int', 'uint' ].includes( type ) && params.every( param => typeof param !== 'object' ) ) ) {

			params = [ getValueFromType( type, ...params ) ];

		}

		if ( params.length === 1 && cacheMap !== null && cacheMap.has( params[ 0 ] ) ) {

			return nodeObject( cacheMap.get( params[ 0 ] ) );

		}

		if ( params.length === 1 ) {

			const node = getConstNode( params[ 0 ], type );
			if ( safeGetNodeType( node ) === type ) return nodeObject( node );
			return nodeObject( new ConvertNode( node, type ) );

		}

		const nodes = params.map( param => getConstNode( param ) );
		return nodeObject( new JoinNode( nodes, type ) );

	};

};

// exports

const defined = ( v ) => typeof v === 'object' && v !== null ? v.value : v; // TODO: remove boolean conversion and defined function

// utils

const getConstNodeType = ( value ) => ( value !== undefined && value !== null ) ? ( value.nodeType || value.convertTo || ( typeof value === 'string' ? value : null ) ) : null;

// shader node base

function ShaderNode( jsFunc, nodeType ) {

	return new Proxy( new ShaderNodeInternal( jsFunc, nodeType ), shaderNodeHandler );

}

const nodeObject = ( val, altType = null ) => /* new */ ShaderNodeObject( val, altType );
const nodeObjects = ( val, altType = null ) => new ShaderNodeObjects( val, altType );
const nodeArray = ( val, altType = null ) => new ShaderNodeArray( val, altType );
const nodeProxy = ( ...params ) => new ShaderNodeProxy( ...params );
const nodeImmutable = ( ...params ) => new ShaderNodeImmutable( ...params );

const Fn = ( jsFunc, nodeType ) => {

	const shaderNode = new ShaderNode( jsFunc, nodeType );

	const fn = ( ...params ) => {

		let inputs;

		nodeObjects( params );

		if ( params[ 0 ] && params[ 0 ].isNode ) {

			inputs = [ ...params ];

		} else {

			inputs = params[ 0 ];

		}

		return shaderNode.call( inputs );

	};

	fn.shaderNode = shaderNode;

	fn.setLayout = ( layout ) => {

		shaderNode.setLayout( layout );

		return fn;

	};

	fn.once = () => {

		shaderNode.once = true;

		return fn;

	};

	return fn;

};

const tslFn = ( ...params ) => { // @deprecated, r168

	console.warn( 'TSL.ShaderNode: tslFn() has been renamed to Fn().' );
	return Fn( ...params );

};

//

addMethodChaining( 'toGlobal', ( node ) => {

	node.global = true;

	return node;

} );

//

const setCurrentStack = ( stack ) => {

	currentStack = stack;

};

const getCurrentStack = () => currentStack;

const If = ( ...params ) => currentStack.If( ...params );

function append( node ) {

	if ( currentStack ) currentStack.add( node );

	return node;

}

addMethodChaining( 'append', append );

// types

const color = new ConvertType( 'color' );

const float = new ConvertType( 'float', cacheMaps.float );
const int = new ConvertType( 'int', cacheMaps.ints );
const uint = new ConvertType( 'uint', cacheMaps.uint );
const bool = new ConvertType( 'bool', cacheMaps.bool );

const vec2 = new ConvertType( 'vec2' );
const ivec2 = new ConvertType( 'ivec2' );
const uvec2 = new ConvertType( 'uvec2' );
const bvec2 = new ConvertType( 'bvec2' );

const vec3 = new ConvertType( 'vec3' );
const ivec3 = new ConvertType( 'ivec3' );
const uvec3 = new ConvertType( 'uvec3' );
const bvec3 = new ConvertType( 'bvec3' );

const vec4 = new ConvertType( 'vec4' );
const ivec4 = new ConvertType( 'ivec4' );
const uvec4 = new ConvertType( 'uvec4' );
const bvec4 = new ConvertType( 'bvec4' );

const mat2 = new ConvertType( 'mat2' );
const mat3 = new ConvertType( 'mat3' );
const mat4 = new ConvertType( 'mat4' );

const string = ( value = '' ) => nodeObject( new ConstNode( value, 'string' ) );
const arrayBuffer = ( value ) => nodeObject( new ConstNode( value, 'ArrayBuffer' ) );

addMethodChaining( 'toColor', color );
addMethodChaining( 'toFloat', float );
addMethodChaining( 'toInt', int );
addMethodChaining( 'toUint', uint );
addMethodChaining( 'toBool', bool );
addMethodChaining( 'toVec2', vec2 );
addMethodChaining( 'toIVec2', ivec2 );
addMethodChaining( 'toUVec2', uvec2 );
addMethodChaining( 'toBVec2', bvec2 );
addMethodChaining( 'toVec3', vec3 );
addMethodChaining( 'toIVec3', ivec3 );
addMethodChaining( 'toUVec3', uvec3 );
addMethodChaining( 'toBVec3', bvec3 );
addMethodChaining( 'toVec4', vec4 );
addMethodChaining( 'toIVec4', ivec4 );
addMethodChaining( 'toUVec4', uvec4 );
addMethodChaining( 'toBVec4', bvec4 );
addMethodChaining( 'toMat2', mat2 );
addMethodChaining( 'toMat3', mat3 );
addMethodChaining( 'toMat4', mat4 );

// basic nodes

const element = /*@__PURE__*/ nodeProxy( ArrayElementNode );
const convert = ( node, types ) => nodeObject( new ConvertNode( nodeObject( node ), types ) );
const split = ( node, channels ) => nodeObject( new SplitNode( nodeObject( node ), channels ) );

addMethodChaining( 'element', element );
addMethodChaining( 'convert', convert );

/** @module UniformGroupNode **/

/**
 * This node can be used to group single instances of {@link UniformNode}
 * and manage them as a uniform buffer.
 *
 * In most cases, the predefined nodes `objectGroup`, `renderGroup` and `frameGroup`
 * will be used when defining the {@link UniformNode#groupNode} property.
 *
 * - `objectGroup`: Uniform buffer per object.
 * - `renderGroup`: Shared uniform buffer, updated once per render call.
 * - `frameGroup`: Shared uniform buffer, updated once per frame.
 *
 * @augments Node
 */
class UniformGroupNode extends Node {

	static get type() {

		return 'UniformGroupNode';

	}

	/**
	 * Constructs a new uniform group node.
	 *
	 * @param {String} name - The name of the uniform group node.
	 * @param {Boolean} [shared=false] - Whether this uniform group node is shared or not.
	 * @param {Number} [order=1] - Influences the internal sorting.
	 */
	constructor( name, shared = false, order = 1 ) {

		super( 'string' );

		/**
		 * The name of the uniform group node.
		 *
		 * @type {String}
		 */
		this.name = name;

		/**
		 * Whether this uniform group node is shared or not.
		 *
		 * @type {Boolean}
		 * @default false
		 */
		this.shared = shared;

		/**
		 * Influences the internal sorting.
		 * TODO: Add details when this property should be changed.
		 *
		 * @type {Number}
		 * @default 1
		 */
		this.order = order;

		/**
		 * This flag can be used for type testing.
		 *
		 * @type {Boolean}
		 * @readonly
		 * @default true
		 */
		this.isUniformGroup = true;

	}

	serialize( data ) {

		super.serialize( data );

		data.name = this.name;
		data.version = this.version;
		data.shared = this.shared;

	}

	deserialize( data ) {

		super.deserialize( data );

		this.name = data.name;
		this.version = data.version;
		this.shared = data.shared;

	}

}

/**
 * TSL function for creating a uniform group node with the given name.
 *
 * @function
 * @param {String} name - The name of the uniform group node.
 * @returns {UniformGroupNode}
 */
const uniformGroup = ( name ) => new UniformGroupNode( name );

/**
 * TSL function for creating a shared uniform group node with the given name and order.
 *
 * @function
 * @param {String} name - The name of the uniform group node.
 * @param {Number} [order=0] - Influences the internal sorting.
 * @returns {UniformGroupNode}
 */
const sharedUniformGroup = ( name, order = 0 ) => new UniformGroupNode( name, true, order );

/**
 * TSL object that represents a shared uniform group node which is updated once per frame.
 *
 * @type {UniformGroupNode}
 */
const frameGroup = /*@__PURE__*/ sharedUniformGroup( 'frame' );

/**
 * TSL object that represents a shared uniform group node which is updated once per render.
 *
 * @type {UniformGroupNode}
 */
const renderGroup = /*@__PURE__*/ sharedUniformGroup( 'render' );

/**
 * TSL object that represents a uniform group node which is updated once per object.
 *
 * @type {UniformGroupNode}
 */
const objectGroup = /*@__PURE__*/ uniformGroup( 'object' );

/** @module UniformNode **/

/**
 * Class for representing a uniform.
 *
 * @augments InputNode
 */
class UniformNode extends InputNode {

	static get type() {

		return 'UniformNode';

	}

	/**
	 * Constructs a new uniform node.
	 *
	 * @param {Any} value - The value of this node. Usually a JS primitive or three.js object (vector, matrix, color, texture).
	 * @param {String?} nodeType - The node type. If no explicit type is defined, the node tries to derive the type from its value.
	 */
	constructor( value, nodeType = null ) {

		super( value, nodeType );

		/**
		 * This flag can be used for type testing.
		 *
		 * @type {Boolean}
		 * @readonly
		 * @default true
		 */
		this.isUniformNode = true;

		/**
		 * The name or label of the uniform.
		 *
		 * @type {String}
		 * @default ''
		 */
		this.name = '';

		/**
		 * The uniform group of this uniform. By default, uniforms are
		 * managed per object but they might belong to a shared group
		 * which is updated per frame or render call.
		 *
		 * @type {UniformGroupNode}
		 */
		this.groupNode = objectGroup;

	}

	/**
	 * Sets the {@link UniformNode#name} property.
	 *
	 * @param {String} name - The name of the uniform.
	 * @return {UniformNode} A reference to this node.
	 */
	label( name ) {

		this.name = name;

		return this;

	}

	/**
	 * Sets the {@link UniformNode#groupNode} property.
	 *
	 * @param {UniformGroupNode} group - The uniform group.
	 * @return {UniformNode} A reference to this node.
	 */
	setGroup( group ) {

		this.groupNode = group;

		return this;

	}

	/**
	 * Returns the {@link UniformNode#groupNode}.
	 *
	 * @return {UniformGroupNode} The uniform group.
	 */
	getGroup() {

		return this.groupNode;

	}

	/**
	 * By default, this method returns the result of {@link Node#getHash} but derived
	 * classes might overwrite this method with a different implementation.
	 *
	 * @param {NodeBuilder} builder - The current node builder.
	 * @return {String} The uniform hash.
	 */
	getUniformHash( builder ) {

		return this.getHash( builder );

	}

	onUpdate( callback, updateType ) {

		const self = this.getSelf();

		callback = callback.bind( self );

		return super.onUpdate( ( frame ) => {

			const value = callback( frame, self );

			if ( value !== undefined ) {

				this.value = value;

			}

	 	}, updateType );

	}

	generate( builder, output ) {

		const type = this.getNodeType( builder );

		const hash = this.getUniformHash( builder );

		let sharedNode = builder.getNodeFromHash( hash );

		if ( sharedNode === undefined ) {

			builder.setHashNode( this, hash );

			sharedNode = this;

		}

		const sharedNodeType = sharedNode.getInputType( builder );

		const nodeUniform = builder.getUniformFromNode( sharedNode, sharedNodeType, builder.shaderStage, this.name || builder.context.label );
		const propertyName = builder.getPropertyName( nodeUniform );

		if ( builder.context.label !== undefined ) delete builder.context.label;

		return builder.format( propertyName, type, output );

	}

}

/**
 * TSL function for creating a uniform node.
 *
 * @function
 * @param {Any} arg1 - The value of this node. Usually a JS primitive or three.js object (vector, matrix, color, texture).
 * @param {String?} arg2 - The node type. If no explicit type is defined, the node tries to derive the type from its value.
 * @returns {UniformNode}
 */
const uniform = ( arg1, arg2 ) => {

	const nodeType = getConstNodeType( arg2 || arg1 );

	// @TODO: get ConstNode from .traverse() in the future
	const value = ( arg1 && arg1.isNode === true ) ? ( arg1.node && arg1.node.value ) || arg1.value : arg1;

	return nodeObject( new UniformNode( value, nodeType ) );

};

/**
 * This class represents a shader property. It can be used on
 * to explicitly define a property and assign a value to it.
 *
 * ```js
 * const threshold = property( 'float', 'threshold' ).assign( THRESHOLD );
 *```
 * `PropertyNode` is used by the engine to predefined common material properties
 * for TSL code.
 *
 * @augments Node
 */
class PropertyNode extends Node {

	static get type() {

		return 'PropertyNode';

	}

	/**
	 * Constructs a new property node.
	 *
	 * @param {String} nodeType - The type of the node.
	 * @param {String?} [name=null] - The name of the property in the shader.
	 * @param {Boolean} [varying=false] - Whether this property is a varying or not.
	 */
	constructor( nodeType, name = null, varying = false ) {

		super( nodeType );

		/**
		 * The name of the property in the shader. If no name is defined,
		 * the node system auto-generates one.
		 *
		 * @type {String?}
		 * @default null
		 */
		this.name = name;

		/**
		 * Whether this property is a varying or not.
		 *
		 * @type {Boolean}
		 * @default false
		 */
		this.varying = varying;

		/**
		 * This flag can be used for type testing.
		 *
		 * @type {Boolean}
		 * @readonly
		 * @default true
		 */
		this.isPropertyNode = true;

	}

	getHash( builder ) {

		return this.name || super.getHash( builder );

	}

	/**
	 * The method is overwritten so it always returns `true`.
	 *
	 * @param {NodeBuilder} builder - The current node builder.
	 * @return {Boolean} Whether this node is global or not.
	 */
	isGlobal( /*builder*/ ) {

		return true;

	}

	generate( builder ) {

		let nodeVar;

		if ( this.varying === true ) {

			nodeVar = builder.getVaryingFromNode( this, this.name );
			nodeVar.needsInterpolation = true;

		} else {

			nodeVar = builder.getVarFromNode( this, this.name );

		}

		return builder.getPropertyName( nodeVar );

	}

}

const property = ( type, name ) => nodeObject( new PropertyNode( type, name ) );
const varyingProperty = ( type, name ) => nodeObject( new PropertyNode( type, name, true ) );

const diffuseColor = /*@__PURE__*/ nodeImmutable( PropertyNode, 'vec4', 'DiffuseColor' );
const emissive = /*@__PURE__*/ nodeImmutable( PropertyNode, 'vec3', 'EmissiveColor' );
const roughness = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'Roughness' );
const metalness = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'Metalness' );
const clearcoat = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'Clearcoat' );
const clearcoatRoughness = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'ClearcoatRoughness' );
const sheen = /*@__PURE__*/ nodeImmutable( PropertyNode, 'vec3', 'Sheen' );
const sheenRoughness = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'SheenRoughness' );
const iridescence = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'Iridescence' );
const iridescenceIOR = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'IridescenceIOR' );
const iridescenceThickness = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'IridescenceThickness' );
const alphaT = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'AlphaT' );
const anisotropy = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'Anisotropy' );
const anisotropyT = /*@__PURE__*/ nodeImmutable( PropertyNode, 'vec3', 'AnisotropyT' );
const anisotropyB = /*@__PURE__*/ nodeImmutable( PropertyNode, 'vec3', 'AnisotropyB' );
const specularColor = /*@__PURE__*/ nodeImmutable( PropertyNode, 'color', 'SpecularColor' );
const specularF90 = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'SpecularF90' );
const shininess = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'Shininess' );
const output = /*@__PURE__*/ nodeImmutable( PropertyNode, 'vec4', 'Output' );
const dashSize = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'dashSize' );
const gapSize = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'gapSize' );
const pointWidth = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'pointWidth' );
const ior = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'IOR' );
const transmission = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'Transmission' );
const thickness = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'Thickness' );
const attenuationDistance = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'AttenuationDistance' );
const attenuationColor = /*@__PURE__*/ nodeImmutable( PropertyNode, 'color', 'AttenuationColor' );
const dispersion = /*@__PURE__*/ nodeImmutable( PropertyNode, 'float', 'Dispersion' );

/** @module AssignNode **/

/**
 * These node represents an assign operation. Meaning a node is assigned
 * to another node.
 *
 * @augments TempNode
 */
class AssignNode extends TempNode {

	static get type() {

		return 'AssignNode';

	}

	/**
	 * Constructs a new assign node.
	 *
	 * @param {Node} targetNode - The target node.
	 * @param {Node} sourceNode - The source type.
	 */
	constructor( targetNode, sourceNode ) {

		super();

		/**
		 * The target node.
		 *
		 * @type {Node}
		 */
		this.targetNode = targetNode;

		/**
		 * The source node.
		 *
		 * @type {Node}
		 */
		this.sourceNode = sourceNode;

	}

	/**
	 * Whether this node is used more than once in context of other nodes. This method
	 * is overwritten since it always returns `false` (assigns are unique).
	 *
	 * @return {Boolean} A flag that indicates if there is more than one dependency to other nodes. Always `false`.
	 */
	hasDependencies() {

		return false;

	}

	getNodeType( builder, output ) {

		return output !== 'void' ? this.targetNode.getNodeType( builder ) : 'void';

	}

	/**
	 * Whether a split is required when assigning source to target. This can happen when the component length of
	 * target and source data type does not match.
	 *
	 * @param {NodeBuilder} builder - The current node builder.
	 * @return {Boolean} Whether a split is required when assigning source to target.
	 */
	needsSplitAssign( builder ) {

		const { targetNode } = this;

		if ( builder.isAvailable( 'swizzleAssign' ) === false && targetNode.isSplitNode && targetNode.components.length > 1 ) {

			const targetLength = builder.getTypeLength( targetNode.node.getNodeType( builder ) );
			const assignDifferentVector = vectorComponents.join( '' ).slice( 0, targetLength ) !== targetNode.components;

			return assignDifferentVector;

		}

		return false;

	}

	generate( builder, output ) {

		const { targetNode, sourceNode } = this;

		const needsSplitAssign = this.needsSplitAssign( builder );

		const targetType = targetNode.getNodeType( builder );

		const target = targetNode.context( { assign: true } ).build( builder );
		const source = sourceNode.build( builder, targetType );

		const sourceType = sourceNode.getNodeType( builder );

		const nodeData = builder.getDataFromNode( this );

		//

		let snippet;

		if ( nodeData.initialized === true ) {

			if ( output !== 'void' ) {

				snippet = target;

			}

		} else if ( needsSplitAssign ) {

			const sourceVar = builder.getVarFromNode( this, null, targetType );
			const sourceProperty = builder.getPropertyName( sourceVar );

			builder.addLineFlowCode( `${ sourceProperty } = ${ source }`, this );

			const targetRoot = targetNode.node.context( { assign: true } ).build( builder );

			for ( let i = 0; i < targetNode.components.length; i ++ ) {

				const component = targetNode.components[ i ];

				builder.addLineFlowCode( `${ targetRoot }.${ component } = ${ sourceProperty }[ ${ i } ]`, this );

			}

			if ( output !== 'void' ) {

				snippet = target;

			}

		} else {

			snippet = `${ target } = ${ source }`;

			if ( output === 'void' || sourceType === 'void' ) {

				builder.addLineFlowCode( snippet, this );

				if ( output !== 'void' ) {

					snippet = target;

				}

			}

		}

		nodeData.initialized = true;

		return builder.format( snippet, targetType, output );

	}

}

/**
 * TSL function for creating an assign node.
 *
 * @function
 * @param {Node} targetNode - The target node.
 * @param {Node} sourceNode - The source type.
 * @returns {AssignNode}
 */
const assign = /*@__PURE__*/ nodeProxy( AssignNode );

addMethodChaining( 'assign', assign );

/**
 * This module represents the call of a {@link FunctionNode}. Developers are usually not confronted
 * with this module since they use the predefined TSL syntax `wgslFn` and `glslFn` which encapsulate
 * this logic.
 *
 * @augments TempNode
 */
class FunctionCallNode extends TempNode {

	static get type() {

		return 'FunctionCallNode';

	}

	/**
	 * Constructs a new function call node.
	 *
	 * @param {FunctionNode?} functionNode - The function node.
	 * @param {Object<String, Node>} [parameters={}] - The parameters for the function call.
	 */
	constructor( functionNode = null, parameters = {} ) {

		super();

		/**
		 * The function node.
		 *
		 * @type {FunctionNode}
		 * @default null
		 */
		this.functionNode = functionNode;

		/**
		 * The parameters of the function call.
		 *
		 * @type {Object<String, Node>}
		 * @default {}
		 */
		this.parameters = parameters;

	}

	/**
	 * Sets the parameters of the function call node.
	 *
	 * @param {Object<String, Node>} parameters - The parameters to set.
	 * @return {FunctionCallNode} A reference to this node.
	 */
	setParameters( parameters ) {

		this.parameters = parameters;

		return this;

	}

	/**
	 * Returns the parameters of the function call node.
	 *
	 * @return {Object<String, Node>} The parameters of this node.
	 */
	getParameters() {

		return this.parameters;

	}

	getNodeType( builder ) {

		return this.functionNode.getNodeType( builder );

	}

	generate( builder ) {

		const params = [];

		const functionNode = this.functionNode;

		const inputs = functionNode.getInputs( builder );
		const parameters = this.parameters;

		const generateInput = ( node, inputNode ) => {

			const type = inputNode.type;
			const pointer = type === 'pointer';

			let output;

			if ( pointer ) output = '&' + node.build( builder );
			else output = node.build( builder, type );

			return output;

		};

		if ( Array.isArray( parameters ) ) {

			for ( let i = 0; i < parameters.length; i ++ ) {

				params.push( generateInput( parameters[ i ], inputs[ i ] ) );

			}

		} else {

			for ( const inputNode of inputs ) {

				const node = parameters[ inputNode.name ];

				if ( node !== undefined ) {

					params.push( generateInput( node, inputNode ) );

				} else {

					throw new Error( `FunctionCallNode: Input '${inputNode.name}' not found in FunctionNode.` );

				}

			}

		}

		const functionName = functionNode.build( builder, 'property' );

		return `${functionName}( ${params.join( ', ' )} )`;

	}

}

const call = ( func, ...params ) => {

	params = params.length > 1 || ( params[ 0 ] && params[ 0 ].isNode === true ) ? nodeArray( params ) : nodeObjects( params[ 0 ] );

	return nodeObject( new FunctionCallNode( nodeObject( func ), params ) );

};

addMethodChaining( 'call', call );

/** @module OperatorNode **/

/**
 * This node represents basic mathematical and logical operations like addition,
 * subtraction or comparisons (e.g. `equal()`).
 *
 * @augments TempNode
 */
class OperatorNode extends TempNode {

	static get type() {

		return 'OperatorNode';

	}

	/**
	 * Constructs a new operator node.
	 *
	 * @param {String} op - The operator.
	 * @param {Node} aNode - The first input.
	 * @param {Node} bNode - The second input.
	 * @param {...Node} params - Additional input parameters.
	 */
	constructor( op, aNode, bNode, ...params ) {

		super();

		if ( params.length > 0 ) {

			let finalOp = new OperatorNode( op, aNode, bNode );

			for ( let i = 0; i < params.length - 1; i ++ ) {

				finalOp = new OperatorNode( op, finalOp, params[ i ] );

			}

			aNode = finalOp;
			bNode = params[ params.length - 1 ];

		}

		/**
		 * The operator.
		 *
		 * @type {String}
		 */
		this.op = op;

		/**
		 * The first input.
		 *
		 * @type {Node}
		 */
		this.aNode = aNode;

		/**
		 * The second input.
		 *
		 * @type {Node}
		 */
		this.bNode = bNode;

	}

	/**
	 * This method is overwritten since the node type is inferred from the operator
	 * and the input node types.
	 *
	 * @param {NodeBuilder} builder - The current node builder.
	 * @param {String} output - The current output string.
	 * @return {String} The node type.
	 */
	getNodeType( builder, output ) {

		const op = this.op;

		const aNode = this.aNode;
		const bNode = this.bNode;

		const typeA = aNode.getNodeType( builder );
		const typeB = typeof bNode !== 'undefined' ? bNode.getNodeType( builder ) : null;

		if ( typeA === 'void' || typeB === 'void' ) {

			return 'void';

		} else if ( op === '%' ) {

			return typeA;

		} else if ( op === '~' || op === '&' || op === '|' || op === '^' || op === '>>' || op === '<<' ) {

			return builder.getIntegerType( typeA );

		} else if ( op === '!' || op === '==' || op === '&&' || op === '||' || op === '^^' ) {

			return 'bool';

		} else if ( op === '<' || op === '>' || op === '<=' || op === '>=' ) {

			const typeLength = output ? builder.getTypeLength( output ) : Math.max( builder.getTypeLength( typeA ), builder.getTypeLength( typeB ) );

			return typeLength > 1 ? `bvec${ typeLength }` : 'bool';

		} else {

			if ( typeA === 'float' && builder.isMatrix( typeB ) ) {

				return typeB;

			} else if ( builder.isMatrix( typeA ) && builder.isVector( typeB ) ) {

				// matrix x vector

				return builder.getVectorFromMatrix( typeA );

			} else if ( builder.isVector( typeA ) && builder.isMatrix( typeB ) ) {

				// vector x matrix

				return builder.getVectorFromMatrix( typeB );

			} else if ( builder.getTypeLength( typeB ) > builder.getTypeLength( typeA ) ) {

				// anytype x anytype: use the greater length vector

				return typeB;

			}

			return typeA;

		}

	}

	generate( builder, output ) {

		const op = this.op;

		const aNode = this.aNode;
		const bNode = this.bNode;

		const type = this.getNodeType( builder, output );

		let typeA = null;
		let typeB = null;

		if ( type !== 'void' ) {

			typeA = aNode.getNodeType( builder );
			typeB = typeof bNode !== 'undefined' ? bNode.getNodeType( builder ) : null;

			if ( op === '<' || op === '>' || op === '<=' || op === '>=' || op === '==' ) {

				if ( builder.isVector( typeA ) ) {

					typeB = typeA;

				} else if ( typeA !== typeB ) {

					typeA = typeB = 'float';

				}

			} else if ( op === '>>' || op === '<<' ) {

				typeA = type;
				typeB = builder.changeComponentType( typeB, 'uint' );

			} else if ( builder.isMatrix( typeA ) && builder.isVector( typeB ) ) {

				// matrix x vector

				typeB = builder.getVectorFromMatrix( typeA );

			} else if ( builder.isVector( typeA ) && builder.isMatrix( typeB ) ) {

				// vector x matrix

				typeA = builder.getVectorFromMatrix( typeB );

			} else {

				// anytype x anytype

				typeA = typeB = type;

			}

		} else {

			typeA = typeB = type;

		}

		const a = aNode.build( builder, typeA );
		const b = typeof bNode !== 'undefined' ? bNode.build( builder, typeB ) : null;

		const outputLength = builder.getTypeLength( output );
		const fnOpSnippet = builder.getFunctionOperator( op );

		if ( output !== 'void' ) {

			if ( op === '<' && outputLength > 1 ) {

				if ( builder.useComparisonMethod ) {

					return builder.format( `${ builder.getMethod( 'lessThan', output ) }( ${ a }, ${ b } )`, type, output );

				} else {

					return builder.format( `( ${ a } < ${ b } )`, type, output );

				}

			} else if ( op === '<=' && outputLength > 1 ) {

				if ( builder.useComparisonMethod ) {

					return builder.format( `${ builder.getMethod( 'lessThanEqual', output ) }( ${ a }, ${ b } )`, type, output );

				} else {

					return builder.format( `( ${ a } <= ${ b } )`, type, output );

				}

			} else if ( op === '>' && outputLength > 1 ) {

				if ( builder.useComparisonMethod ) {

					return builder.format( `${ builder.getMethod( 'greaterThan', output ) }( ${ a }, ${ b } )`, type, output );

				} else {

					return builder.format( `( ${ a } > ${ b } )`, type, output );

				}

			} else if ( op === '>=' && outputLength > 1 ) {

				if ( builder.useComparisonMethod ) {

					return builder.format( `${ builder.getMethod( 'greaterThanEqual', output ) }( ${ a }, ${ b } )`, type, output );

				} else {

					return builder.format( `( ${ a } >= ${ b } )`, type, output );

				}

			} else if ( op === '!' || op === '~' ) {

				return builder.format( `(${op}${a})`, typeA, output );

			} else if ( fnOpSnippet ) {

				return builder.format( `${ fnOpSnippet }( ${ a }, ${ b } )`, type, output );

			} else {

				return builder.format( `( ${ a } ${ op } ${ b } )`, type, output );

			}

		} else if ( typeA !== 'void' ) {

			if ( fnOpSnippet ) {

				return builder.format( `${ fnOpSnippet }( ${ a }, ${ b } )`, type, output );

			} else {

				return builder.format( `${ a } ${ op } ${ b }`, type, output );

			}

		}

	}

	serialize( data ) {

		super.serialize( data );

		data.op = this.op;

	}

	deserialize( data ) {

		super.deserialize( data );

		this.op = data.op;

	}

}

/**
 * Returns the addition of two or more value.
 *
 * @function
 * @param {Node} aNode - The first input.
 * @param {Node} bNode - The second input.
 * @param {...Node} params - Additional input parameters.
 * @returns {OperatorNode}
 */
const add = /*@__PURE__*/ nodeProxy( OperatorNode, '+' );

/**
 * Returns the subraction of two or more value.
 *
 * @function
 * @param {Node} aNode - The first input.
 * @param {Node} bNode - The second input.
 * @param {...Node} params - Additional input parameters.
 * @returns {OperatorNode}
 */
const sub = /*@__PURE__*/ nodeProxy( OperatorNode, '-' );

/**
 * Returns the multiplication of two or more value.
 *
 * @function
 * @param {Node} aNode - The first input.
 * @param {Node} bNode - The second input.
 * @param {...Node} params - Additional input parameters.
 * @returns {OperatorNode}
 */
const mul = /*@__PURE__*/ nodeProxy( OperatorNode, '*' );

/**
 * Returns the division of two or more value.
 *
 * @function
 * @param {Node} aNode - The first input.
 * @param {Node} bNode - The second input.
 * @param {...Node} params - Additional input parameters.
 * @returns {OperatorNode}
 */
const div = /*@__PURE__*/ nodeProxy( OperatorNode, '/' );

/**
 * Computes the remainder of dividing the first node by the second, for integer values.
 *
 * @function
 * @param {Node} aNode - The first input.
 * @param {Node} bNode - The second input.
 * @returns {OperatorNode}
 */
const modInt = /*@__PURE__*/ nodeProxy( OperatorNode, '%' );

/**
 * Checks if two nodes are equal.
 *
 * @function
 * @param {Node} aNode - The first input.
 * @param {Node} bNode - The second input.
 * @returns {OperatorNode}
 */
const equal = /*@__PURE__*/ nodeProxy( OperatorNode, '==' );

/**
 * Checks if two nodes are not equal.
 *
 * @function
 * @param {Node} aNode - The first input.
 * @param {Node} bNode - The second input.
 * @returns {OperatorNode}
 */
const notEqual = /*@__PURE__*/ nodeProxy( OperatorNode, '!=' );

/**
 * Checks if the first node is less than the second.
 *
 * @function
 * @param {Node} aNode - The first input.
 * @param {Node} bNode - The second input.
 * @returns {OperatorNode}
 */
const lessThan = /*@__PURE__*/ nodeProxy( OperatorNode, '<' );

/**
 * Checks if the first node is greater than the second.
 *
 * @function
 * @param {Node} aNode - The first input.
 * @param {Node} bNode - The second input.
 * @returns {OperatorNode}
 */
const greaterThan = /*@__PURE__*/ nodeProxy( OperatorNode, '>' );

/**
 * Checks if the first node is less than or equal to the second.
 *
 * @function
 * @param {Node} aNode - The first input.
 * @param {Node} bNode - The second input.
 * @returns {OperatorNode}
 */
const lessThanEqual = /*@__PURE__*/ nodeProxy( OperatorNode, '<=' );

/**
 * Checks if the first node is greater than or equal to the second.
 *
 * @function
 * @param {Node} aNode - The first input.
 * @param {Node} bNode - The second input.
 * @returns {OperatorNode}
 */
const greaterThanEqual = /*@__PURE__*/ nodeProxy( OperatorNode, '>=' );

/**
 * Performs logical AND on two nodes.
 *
 * @function
 * @param {Node} aNode - The first input.
 * @param {Node} bNode - The second input.
 * @returns {OperatorNode}
 */
const and = /*@__PURE__*/ nodeProxy( OperatorNode, '&&' );

/**
 * Performs logical OR on two nodes.
 *
 * @function
 * @param {Node} aNode - The first input.
 * @param {Node} bNode - The second input.
 * @returns {OperatorNode}
 */
const or = /*@__PURE__*/ nodeProxy( OperatorNode, '||' );

/**
 * Performs logical NOT on a node.
 *
 * @function
 * @param {Node} aNode - The first input.
 * @param {Node} bNode - The second input.
 * @returns {OperatorNode}
 */
const not = /*@__PURE__*/ nodeProxy( OperatorNode, '!' );

/**
 * Performs logical XOR on two nodes.
 *
 * @function
 * @param {Node} aNode - The first input.
 * @param {Node} bNode - The second input.
 * @returns {OperatorNode}
 */
const xor = /*@__PURE__*/ nodeProxy( OperatorNode, '^^' );

/**
 * Performs bitwise AND on two nodes.
 *
 * @function
 * @param {Node} aNode - The first input.
 * @param {Node} bNode - The second input.
 * @returns {OperatorNode}
 */
const bitAnd = /*@__PURE__*/ nodeProxy( OperatorNode, '&' );

/**
 * Performs bitwise NOT on a node.
 *
 * @function
 * @param {Node} aNode - The first input.
 * @param {Node} bNode - The second input.
 * @returns {OperatorNode}
 */
const bitNot = /*@__PURE__*/ nodeProxy( OperatorNode, '~' );

/**
 * Performs bitwise OR on two nodes.
 *
 * @function
 * @param {Node} aNode - The first input.
 * @param {Node} bNode - The second input.
 * @returns {OperatorNode}
 */
const bitOr = /*@__PURE__*/ nodeProxy( OperatorNode, '|' );

/**
 * Performs bitwise XOR on two nodes.
 *
 * @function
 * @param {Node} aNode - The first input.
 * @param {Node} bNode - The second input.
 * @returns {OperatorNode}
 */
const bitXor = /*@__PURE__*/ nodeProxy( OperatorNode, '^' );

/**
 * Shifts a node to the left.
 *
 * @function
 * @param {Node} aNode - The node to shift.
 * @param {Node} bNode - The value to shift.
 * @returns {OperatorNode}
 */
const shiftLeft = /*@__PURE__*/ nodeProxy( OperatorNode, '<<' );

/**
 * Shifts a node to the right.
 *
 * @function
 * @param {Node} aNode - The node to shift.
 * @param {Node} bNode - The value to shift.
 * @returns {OperatorNode}
 */
const shiftRight = /*@__PURE__*/ nodeProxy( OperatorNode, '>>' );

addMethodChaining( 'add', add );
addMethodChaining( 'sub', sub );
addMethodChaining( 'mul', mul );
addMethodChaining( 'div', div );
addMethodChaining( 'modInt', modInt );
addMethodChaining( 'equal', equal );
addMethodChaining( 'notEqual', notEqual );
addMethodChaining( 'lessThan', lessThan );
addMethodChaining( 'greaterThan', greaterThan );
addMethodChaining( 'lessThanEqual', lessThanEqual );
addMethodChaining( 'greaterThanEqual', greaterThanEqual );
addMethodChaining( 'and', and );
addMethodChaining( 'or', or );
addMethodChaining( 'not', not );
addMethodChaining( 'xor', xor );
addMethodChaining( 'bitAnd', bitAnd );
addMethodChaining( 'bitNot', bitNot );
addMethodChaining( 'bitOr', bitOr );
addMethodChaining( 'bitXor', bitXor );
addMethodChaining( 'shiftLeft', shiftLeft );
addMethodChaining( 'shiftRight', shiftRight );


const remainder = ( ...params ) => { // @deprecated, r168

	console.warn( 'TSL.OperatorNode: .remainder() has been renamed to .modInt().' );
	return modInt( ...params );

};

addMethodChaining( 'remainder', remainder );

/**
 * This node represents a variety of mathematical methods available in shaders.
 * They are divided into three categories:
 *
 * - Methods with one input like `sin`, `cos` or `normalize`.
 * - Methods with two inputs like `dot`, `cross` or `pow`.
 * - Methods with three inputs like `mix`, `clamp` or `smoothstep`.
 *
 * @augments TempNode
 */
class MathNode extends TempNode {

	static get type() {

		return 'MathNode';

	}

	/**
	 * Constructs a new math node.
	 *
	 * @param {String} method - The method name.
	 * @param {Node} aNode - The first input.
	 * @param {Node?} [bNode=null] - The second input.
	 * @param {Node?} [cNode=null] - The third input.
	 */
	constructor( method, aNode, bNode = null, cNode = null ) {

		super();

		/**
		 * The method name.
		 *
		 * @type {String}
		 */
		this.method = method;

		/**
		 * The first input.
		 *
		 * @type {Node}
		 */
		this.aNode = aNode;

		/**
		 * The second input.
		 *
		 * @type {Node?}
		 * @default null
		 */
		this.bNode = bNode;

		/**
		 * The third input.
		 *
		 * @type {Node?}
		 * @default null
		 */
		this.cNode = cNode;

	}

	/**
	 * The input type is inferred from the node types of the input nodes.
	 *
	 * @param {NodeBuilder} builder - The current node builder.
	 * @return {String} The input type.
	 */
	getInputType( builder ) {

		const aType = this.aNode.getNodeType( builder );
		const bType = this.bNode ? this.bNode.getNodeType( builder ) : null;
		const cType = this.cNode ? this.cNode.getNodeType( builder ) : null;

		const aLen = builder.isMatrix( aType ) ? 0 : builder.getTypeLength( aType );
		const bLen = builder.isMatrix( bType ) ? 0 : builder.getTypeLength( bType );
		const cLen = builder.isMatrix( cType ) ? 0 : builder.getTypeLength( cType );

		if ( aLen > bLen && aLen > cLen ) {

			return aType;

		} else if ( bLen > cLen ) {

			return bType;

		} else if ( cLen > aLen ) {

			return cType;

		}

		return aType;

	}

	/**
	 * The selected method as well as the input type determine the node type of this node.
	 *
	 * @param {NodeBuilder} builder - The current node builder.
	 * @return {String} The node type.
	 */
	getNodeType( builder ) {

		const method = this.method;

		if ( method === MathNode.LENGTH || method === MathNode.DISTANCE || method === MathNode.DOT ) {

			return 'float';

		} else if ( method === MathNode.CROSS ) {

			return 'vec3';

		} else if ( method === MathNode.ALL ) {

			return 'bool';

		} else if ( method === MathNode.EQUALS ) {

			return builder.changeComponentType( this.aNode.getNodeType( builder ), 'bool' );

		} else if ( method === MathNode.MOD ) {

			return this.aNode.getNodeType( builder );

		} else {

			return this.getInputType( builder );

		}

	}

	generate( builder, output ) {

		const method = this.method;

		const type = this.getNodeType( builder );
		const inputType = this.getInputType( builder );

		const a = this.aNode;
		const b = this.bNode;
		const c = this.cNode;

		const isWebGL = builder.renderer.isWebGLRenderer === true;

		if ( method === MathNode.TRANSFORM_DIRECTION ) {

			// dir can be either a direction vector or a normal vector
			// upper-left 3x3 of matrix is assumed to be orthogonal

			let tA = a;
			let tB = b;

			if ( builder.isMatrix( tA.getNodeType( builder ) ) ) {

				tB = vec4( vec3( tB ), 0.0 );

			} else {

				tA = vec4( vec3( tA ), 0.0 );

			}

			const mulNode = mul( tA, tB ).xyz;

			return normalize( mulNode ).build( builder, output );

		} else if ( method === MathNode.NEGATE ) {

			return builder.format( '( - ' + a.build( builder, inputType ) + ' )', type, output );

		} else if ( method === MathNode.ONE_MINUS ) {

			return sub( 1.0, a ).build( builder, output );

		} else if ( method === MathNode.RECIPROCAL ) {

			return div( 1.0, a ).build( builder, output );

		} else if ( method === MathNode.DIFFERENCE ) {

			return abs( sub( a, b ) ).build( builder, output );

		} else {

			const params = [];

			if ( method === MathNode.CROSS || method === MathNode.MOD ) {

				params.push(
					a.build( builder, type ),
					b.build( builder, type )
				);

			} else if ( isWebGL && method === MathNode.STEP ) {

				params.push(
					a.build( builder, builder.getTypeLength( a.getNodeType( builder ) ) === 1 ? 'float' : inputType ),
					b.build( builder, inputType )
				);

			} else if ( ( isWebGL && ( method === MathNode.MIN || method === MathNode.MAX ) ) || method === MathNode.MOD ) {

				params.push(
					a.build( builder, inputType ),
					b.build( builder, builder.getTypeLength( b.getNodeType( builder ) ) === 1 ? 'float' : inputType )
				);

			} else if ( method === MathNode.REFRACT ) {

				params.push(
					a.build( builder, inputType ),
					b.build( builder, inputType ),
					c.build( builder, 'float' )
				);

			} else if ( method === MathNode.MIX ) {

				params.push(
					a.build( builder, inputType ),
					b.build( builder, inputType ),
					c.build( builder, builder.getTypeLength( c.getNodeType( builder ) ) === 1 ? 'float' : inputType )
				);

			} else {

				params.push( a.build( builder, inputType ) );
				if ( b !== null ) params.push( b.build( builder, inputType ) );
				if ( c !== null ) params.push( c.build( builder, inputType ) );

			}

			return builder.format( `${ builder.getMethod( method, type ) }( ${params.join( ', ' )} )`, type, output );

		}

	}

	serialize( data ) {

		super.serialize( data );

		data.method = this.method;

	}

	deserialize( data ) {

		super.deserialize( data );

		this.method = data.method;

	}

}

// 1 input

MathNode.ALL = 'all';
MathNode.ANY = 'any';
MathNode.EQUALS = 'equals';

MathNode.RADIANS = 'radians';
MathNode.DEGREES = 'degrees';
MathNode.EXP = 'exp';
MathNode.EXP2 = 'exp2';
MathNode.LOG = 'log';
MathNode.LOG2 = 'log2';
MathNode.SQRT = 'sqrt';
MathNode.INVERSE_SQRT = 'inversesqrt';
MathNode.FLOOR = 'floor';
MathNode.CEIL = 'ceil';
MathNode.NORMALIZE = 'normalize';
MathNode.FRACT = 'fract';
MathNode.SIN = 'sin';
MathNode.COS = 'cos';
MathNode.TAN = 'tan';
MathNode.ASIN = 'asin';
MathNode.ACOS = 'acos';
MathNode.ATAN = 'atan';
MathNode.ABS = 'abs';
MathNode.SIGN = 'sign';
MathNode.LENGTH = 'length';
MathNode.NEGATE = 'negate';
MathNode.ONE_MINUS = 'oneMinus';
MathNode.DFDX = 'dFdx';
MathNode.DFDY = 'dFdy';
MathNode.ROUND = 'round';
MathNode.RECIPROCAL = 'reciprocal';
MathNode.TRUNC = 'trunc';
MathNode.FWIDTH = 'fwidth';
MathNode.BITCAST = 'bitcast';
MathNode.TRANSPOSE = 'transpose';

// 2 inputs

MathNode.ATAN2 = 'atan2';
MathNode.MIN = 'min';
MathNode.MAX = 'max';
MathNode.MOD = 'mod';
MathNode.STEP = 'step';
MathNode.REFLECT = 'reflect';
MathNode.DISTANCE = 'distance';
MathNode.DIFFERENCE = 'difference';
MathNode.DOT = 'dot';
MathNode.CROSS = 'cross';
MathNode.POW = 'pow';
MathNode.TRANSFORM_DIRECTION = 'transformDirection';

// 3 inputs

MathNode.MIX = 'mix';
MathNode.CLAMP = 'clamp';
MathNode.REFRACT = 'refract';
MathNode.SMOOTHSTEP = 'smoothstep';
MathNode.FACEFORWARD = 'faceforward';

const EPSILON = /*@__PURE__*/ float( 1e-6 );
const INFINITY = /*@__PURE__*/ float( 1e6 );
const PI = /*@__PURE__*/ float( Math.PI );
const PI2 = /*@__PURE__*/ float( Math.PI * 2 );

const all = /*@__PURE__*/ nodeProxy( MathNode, MathNode.ALL );
const any = /*@__PURE__*/ nodeProxy( MathNode, MathNode.ANY );
const equals = /*@__PURE__*/ nodeProxy( MathNode, MathNode.EQUALS );

const radians = /*@__PURE__*/ nodeProxy( MathNode, MathNode.RADIANS );
const degrees = /*@__PURE__*/ nodeProxy( MathNode, MathNode.DEGREES );
const exp = /*@__PURE__*/ nodeProxy( MathNode, MathNode.EXP );
const exp2 = /*@__PURE__*/ nodeProxy( MathNode, MathNode.EXP2 );
const log = /*@__PURE__*/ nodeProxy( MathNode, MathNode.LOG );
const log2 = /*@__PURE__*/ nodeProxy( MathNode, MathNode.LOG2 );
const sqrt = /*@__PURE__*/ nodeProxy( MathNode, MathNode.SQRT );
const inverseSqrt = /*@__PURE__*/ nodeProxy( MathNode, MathNode.INVERSE_SQRT );
const floor = /*@__PURE__*/ nodeProxy( MathNode, MathNode.FLOOR );
const ceil = /*@__PURE__*/ nodeProxy( MathNode, MathNode.CEIL );
const normalize = /*@__PURE__*/ nodeProxy( MathNode, MathNode.NORMALIZE );
const fract = /*@__PURE__*/ nodeProxy( MathNode, MathNode.FRACT );
const sin = /*@__PURE__*/ nodeProxy( MathNode, MathNode.SIN );
const cos = /*@__PURE__*/ nodeProxy( MathNode, MathNode.COS );
const tan = /*@__PURE__*/ nodeProxy( MathNode, MathNode.TAN );
const asin = /*@__PURE__*/ nodeProxy( MathNode, MathNode.ASIN );
const acos = /*@__PURE__*/ nodeProxy( MathNode, MathNode.ACOS );
const atan = /*@__PURE__*/ nodeProxy( MathNode, MathNode.ATAN );
const abs = /*@__PURE__*/ nodeProxy( MathNode, MathNode.ABS );
const sign = /*@__PURE__*/ nodeProxy( MathNode, MathNode.SIGN );
const length = /*@__PURE__*/ nodeProxy( MathNode, MathNode.LENGTH );
const negate = /*@__PURE__*/ nodeProxy( MathNode, MathNode.NEGATE );
const oneMinus = /*@__PURE__*/ nodeProxy( MathNode, MathNode.ONE_MINUS );
const dFdx = /*@__PURE__*/ nodeProxy( MathNode, MathNode.DFDX );
const dFdy = /*@__PURE__*/ nodeProxy( MathNode, MathNode.DFDY );
const round = /*@__PURE__*/ nodeProxy( MathNode, MathNode.ROUND );
const reciprocal = /*@__PURE__*/ nodeProxy( MathNode, MathNode.RECIPROCAL );
const trunc = /*@__PURE__*/ nodeProxy( MathNode, MathNode.TRUNC );
const fwidth = /*@__PURE__*/ nodeProxy( MathNode, MathNode.FWIDTH );
const bitcast = /*@__PURE__*/ nodeProxy( MathNode, MathNode.BITCAST );
const transpose = /*@__PURE__*/ nodeProxy( MathNode, MathNode.TRANSPOSE );

const atan2 = /*@__PURE__*/ nodeProxy( MathNode, MathNode.ATAN2 );
const min$1 = /*@__PURE__*/ nodeProxy( MathNode, MathNode.MIN );
const max$1 = /*@__PURE__*/ nodeProxy( MathNode, MathNode.MAX );
const mod = /*@__PURE__*/ nodeProxy( MathNode, MathNode.MOD );
const step = /*@__PURE__*/ nodeProxy( MathNode, MathNode.STEP );
const reflect = /*@__PURE__*/ nodeProxy( MathNode, MathNode.REFLECT );
const distance = /*@__PURE__*/ nodeProxy( MathNode, MathNode.DISTANCE );
const difference = /*@__PURE__*/ nodeProxy( MathNode, MathNode.DIFFERENCE );
const dot = /*@__PURE__*/ nodeProxy( MathNode, MathNode.DOT );
const cross = /*@__PURE__*/ nodeProxy( MathNode, MathNode.CROSS );
const pow = /*@__PURE__*/ nodeProxy( MathNode, MathNode.POW );
const pow2 = /*@__PURE__*/ nodeProxy( MathNode, MathNode.POW, 2 );
const pow3 = /*@__PURE__*/ nodeProxy( MathNode, MathNode.POW, 3 );
const pow4 = /*@__PURE__*/ nodeProxy( MathNode, MathNode.POW, 4 );
const transformDirection = /*@__PURE__*/ nodeProxy( MathNode, MathNode.TRANSFORM_DIRECTION );

const cbrt = ( a ) => mul( sign( a ), pow( abs( a ), 1.0 / 3.0 ) );
const lengthSq = ( a ) => dot( a, a );
const mix = /*@__PURE__*/ nodeProxy( MathNode, MathNode.MIX );
const clamp = ( value, low = 0, high = 1 ) => nodeObject( new MathNode( MathNode.CLAMP, nodeObject( value ), nodeObject( low ), nodeObject( high ) ) );
const saturate = ( value ) => clamp( value );
const refract = /*@__PURE__*/ nodeProxy( MathNode, MathNode.REFRACT );
const smoothstep = /*@__PURE__*/ nodeProxy( MathNode, MathNode.SMOOTHSTEP );
const faceForward = /*@__PURE__*/ nodeProxy( MathNode, MathNode.FACEFORWARD );

const rand = /*@__PURE__*/ Fn( ( [ uv ] ) => {

	const a = 12.9898, b = 78.233, c = 43758.5453;
	const dt = dot( uv.xy, vec2( a, b ) ), sn = mod( dt, PI );

	return fract( sin( sn ).mul( c ) );

} );

const mixElement = ( t, e1, e2 ) => mix( e1, e2, t );
const smoothstepElement = ( x, low, high ) => smoothstep( low, high, x );

addMethodChaining( 'all', all );
addMethodChaining( 'any', any );
addMethodChaining( 'equals', equals );

addMethodChaining( 'radians', radians );
addMethodChaining( 'degrees', degrees );
addMethodChaining( 'exp', exp );
addMethodChaining( 'exp2', exp2 );
addMethodChaining( 'log', log );
addMethodChaining( 'log2', log2 );
addMethodChaining( 'sqrt', sqrt );
addMethodChaining( 'inverseSqrt', inverseSqrt );
addMethodChaining( 'floor', floor );
addMethodChaining( 'ceil', ceil );
addMethodChaining( 'normalize', normalize );
addMethodChaining( 'fract', fract );
addMethodChaining( 'sin', sin );
addMethodChaining( 'cos', cos );
addMethodChaining( 'tan', tan );
addMethodChaining( 'asin', asin );
addMethodChaining( 'acos', acos );
addMethodChaining( 'atan', atan );
addMethodChaining( 'abs', abs );
addMethodChaining( 'sign', sign );
addMethodChaining( 'length', length );
addMethodChaining( 'lengthSq', lengthSq );
addMethodChaining( 'negate', negate );
addMethodChaining( 'oneMinus', oneMinus );
addMethodChaining( 'dFdx', dFdx );
addMethodChaining( 'dFdy', dFdy );
addMethodChaining( 'round', round );
addMethodChaining( 'reciprocal', reciprocal );
addMethodChaining( 'trunc', trunc );
addMethodChaining( 'fwidth', fwidth );
addMethodChaining( 'atan2', atan2 );
addMethodChaining( 'min', min$1 );
addMethodChaining( 'max', max$1 );
addMethodChaining( 'mod', mod );
addMethodChaining( 'step', step );
addMethodChaining( 'reflect', reflect );
addMethodChaining( 'distance', distance );
addMethodChaining( 'dot', dot );
addMethodChaining( 'cross', cross );
addMethodChaining( 'pow', pow );
addMethodChaining( 'pow2', pow2 );
addMethodChaining( 'pow3', pow3 );
addMethodChaining( 'pow4', pow4 );
addMethodChaining( 'transformDirection', transformDirection );
addMethodChaining( 'mix', mixElement );
addMethodChaining( 'clamp', clamp );
addMethodChaining( 'refract', refract );
addMethodChaining( 'smoothstep', smoothstepElement );
addMethodChaining( 'faceForward', faceForward );
addMethodChaining( 'difference', difference );
addMethodChaining( 'saturate', saturate );
addMethodChaining( 'cbrt', cbrt );
addMethodChaining( 'transpose', transpose );
addMethodChaining( 'rand', rand );

/** @module ConditionalNode **/

/**
 * Represents a logical `if/else` statement. Can be used as an alternative
 * to the `If()`/`Else()` syntax.
 *
 * The corresponding TSL `select()` looks like so:
 * ```js
 * velocity = position.greaterThanEqual( limit ).select( velocity.negate(), velocity );
 * ```
 * The `select()` method is called in a chaining fashion on a condition. The parameter nodes of `select()`
 * determine the outcome of the entire statement.
 *
 * @augments Node
 */
class ConditionalNode extends Node {

	static get type() {

		return 'ConditionalNode';

	}

	/**
	 * Constructs a new conditional node.
	 *
	 * @param {Node} condNode - The node that defines the condition.
	 * @param {Node} ifNode - The node that is evaluate when the condition ends up `true`.
	 * @param {Node?} [elseNode=null] - The node that is evaluate when the condition ends up `false`.
	 */
	constructor( condNode, ifNode, elseNode = null ) {

		super();

		/**
		 * The node that defines the condition.
		 *
		 * @type {Node}
		 */
		this.condNode = condNode;

		/**
		 * The node that is evaluate when the condition ends up `true`.
		 *
		 * @type {Node}
		 */
		this.ifNode = ifNode;

		/**
		 * The node that is evaluate when the condition ends up `false`.
		 *
		 * @type {Node?}
		 * @default null
		 */
		this.elseNode = elseNode;

	}

	/**
	 * This method is overwritten since the node type is inferred from the if/else
	 * nodes.
	 *
	 * @param {NodeBuilder} builder - The current node builder.
	 * @return {String} The node type.
	 */
	getNodeType( builder ) {

		const ifType = this.ifNode.getNodeType( builder );

		if ( this.elseNode !== null ) {

			const elseType = this.elseNode.getNodeType( builder );

			if ( builder.getTypeLength( elseType ) > builder.getTypeLength( ifType ) ) {

				return elseType;

			}

		}

		return ifType;

	}

	setup( builder ) {

		const condNode = this.condNode.cache();
		const ifNode = this.ifNode.cache();
		const elseNode = this.elseNode ? this.elseNode.cache() : null;

		//

		const currentNodeBlock = builder.context.nodeBlock;

		builder.getDataFromNode( ifNode ).parentNodeBlock = currentNodeBlock;
		if ( elseNode !== null ) builder.getDataFromNode( elseNode ).parentNodeBlock = currentNodeBlock;

		//

		const properties = builder.getNodeProperties( this );
		properties.condNode = condNode;
		properties.ifNode = ifNode.context( { nodeBlock: ifNode } );
		properties.elseNode = elseNode ? elseNode.context( { nodeBlock: elseNode } ) : null;

	}

	generate( builder, output ) {

		const type = this.getNodeType( builder );

		const nodeData = builder.getDataFromNode( this );

		if ( nodeData.nodeProperty !== undefined ) {

			return nodeData.nodeProperty;

		}

		const { condNode, ifNode, elseNode } = builder.getNodeProperties( this );

		const needsOutput = output !== 'void';
		const nodeProperty = needsOutput ? property( type ).build( builder ) : '';

		nodeData.nodeProperty = nodeProperty;

		const nodeSnippet = condNode.build( builder, 'bool' );

		builder.addFlowCode( `\n${ builder.tab }if ( ${ nodeSnippet } ) {\n\n` ).addFlowTab();

		let ifSnippet = ifNode.build( builder, type );

		if ( ifSnippet ) {

			if ( needsOutput ) {

				ifSnippet = nodeProperty + ' = ' + ifSnippet + ';';

			} else {

				ifSnippet = 'return ' + ifSnippet + ';';

			}

		}

		builder.removeFlowTab().addFlowCode( builder.tab + '\t' + ifSnippet + '\n\n' + builder.tab + '}' );

		if ( elseNode !== null ) {

			builder.addFlowCode( ' else {\n\n' ).addFlowTab();

			let elseSnippet = elseNode.build( builder, type );

			if ( elseSnippet ) {

				if ( needsOutput ) {

					elseSnippet = nodeProperty + ' = ' + elseSnippet + ';';

				} else {

					elseSnippet = 'return ' + elseSnippet + ';';

				}

			}

			builder.removeFlowTab().addFlowCode( builder.tab + '\t' + elseSnippet + '\n\n' + builder.tab + '}\n\n' );

		} else {

			builder.addFlowCode( '\n\n' );

		}

		return builder.format( nodeProperty, type, output );

	}

}

/**
 * TSL function for creating a conditional node.
 *
 * @function
 * @param {Node} condNode - The node that defines the condition.
 * @param {Node} ifNode - The node that is evaluate when the condition ends up `true`.
 * @param {Node?} [elseNode=null] - The node that is evaluate when the condition ends up `false`.
 * @returns {ConditionalNode}
 */
const select = /*@__PURE__*/ nodeProxy( ConditionalNode );

addMethodChaining( 'select', select );

//

const cond = ( ...params ) => { // @deprecated, r168

	console.warn( 'TSL.ConditionalNode: cond() has been renamed to select().' );
	return select( ...params );

};

addMethodChaining( 'cond', cond );

/** @module ContextNode **/

/**
 * This node can be used as a context management component for another node.
 * {@link NodeBuilder} performs its node building process in a specific context and
 * this node allows the modify the context. A typical use case is to overwrite `getUV()` e.g.:
 *
 * ```js
 *node.context( { getUV: () => customCoord } );
 *```
 * @augments Node
 */
class ContextNode extends Node {

	static get type() {

		return 'ContextNode';

	}

	/**
	 * Constructs a new context node.
	 *
	 * @param {Node} node - The node whose context should be modified.
	 * @param {Object} [value={}] - The modified context data.
	 */
	constructor( node, value = {} ) {

		super();

		/**
		 * This flag can be used for type testing.
		 *
		 * @type {Boolean}
		 * @readonly
		 * @default true
		 */
		this.isContextNode = true;

		/**
		 * The node whose context should be modified.
		 *
		 * @type {Node}
		 */
		this.node = node;

		/**
		 * The modified context data.
		 *
		 * @type {Object}
		 * @default {}
		 */
		this.value = value;

	}

	/**
	 * This method is overwritten to ensure it returns the reference to {@link module:ContextNode~ContextNode#node}.
	 *
	 * @return {Node} A reference to {@link module:ContextNode~ContextNode#node}.
	 */
	getScope() {

		return this.node.getScope();

	}

	/**
	 * This method is overwritten to ensure it returns the type of {@link module:ContextNode~ContextNode#node}.
	 *
	 * @param {NodeBuilder} builder - The current node builder.
	 * @return {String} The node type.
	 */
	getNodeType( builder ) {

		return this.node.getNodeType( builder );

	}

	analyze( builder ) {

		this.node.build( builder );

	}

	setup( builder ) {

		const previousContext = builder.getContext();

		builder.setContext( { ...builder.context, ...this.value } );

		const node = this.node.build( builder );

		builder.setContext( previousContext );

		return node;

	}

	generate( builder, output ) {

		const previousContext = builder.getContext();

		builder.setContext( { ...builder.context, ...this.value } );

		const snippet = this.node.build( builder, output );

		builder.setContext( previousContext );

		return snippet;

	}

}

/**
 * TSL function for creating a context node.
 *
 * @function
 * @param {Node} node - The node whose context should be modified.
 * @param {Object} [value={}] - The modified context data.
 * @returns {ContextNode}
 */
const context = /*@__PURE__*/ nodeProxy( ContextNode );

/**
 * TSL function for defining a label context value for a given node.
 *
 * @function
 * @param {Node} node - The node whose context should be modified.
 * @param {String} name - The name/label to set.
 * @returns {ContextNode}
 */
const label = ( node, name ) => context( node, { label: name } );

addMethodChaining( 'context', context );
addMethodChaining( 'label', label );

/** @module VarNode **/

/**
 * Class for representing shader variables as nodes. Variables are created from
 * existing nodes like the following:
 *
 * ```js
 * const depth = sampleDepth( uvNode ).toVar( 'depth' );
 * ```
 *
 * @augments Node
 */
class VarNode extends Node {

	static get type() {

		return 'VarNode';

	}

	/**
	 * Constructs a new variable node.
	 *
	 * @param {Node} node - The node for which a variable should be created.
	 * @param {String?} name - The name of the variable in the shader.
	 */
	constructor( node, name = null ) {

		super();

		/**
		 * The node for which a variable should be created.
		 *
		 * @type {Node}
		 */
		this.node = node;

		/**
		 * The name of the variable in the shader. If no name is defined,
		 * the node system auto-generates one.
		 *
		 * @type {String?}
		 * @default null
		 */
		this.name = name;

		/**
		 * `VarNode` sets this property to `true` by default.
		 *
		 * @type {Boolean}
		 * @default true
		 */
		this.global = true;

		/**
		 * This flag can be used for type testing.
		 *
		 * @type {Boolean}
		 * @readonly
		 * @default true
		 */
		this.isVarNode = true;

	}

	getHash( builder ) {

		return this.name || super.getHash( builder );

	}

	getNodeType( builder ) {

		return this.node.getNodeType( builder );

	}

	generate( builder ) {

		const { node, name } = this;

		const nodeVar = builder.getVarFromNode( this, name, builder.getVectorType( this.getNodeType( builder ) ) );

		const propertyName = builder.getPropertyName( nodeVar );

		const snippet = node.build( builder, nodeVar.type );

		builder.addLineFlowCode( `${propertyName} = ${snippet}`, this );

		return propertyName;

	}

}

/**
 * TSL function for creating a var node.
 *
 * @function
 * @param {Node} node - The node for which a variable should be created.
 * @param {String?} name - The name of the variable in the shader.
 * @returns {VarNode}
 */
const createVar = /*@__PURE__*/ nodeProxy( VarNode );

addMethodChaining( 'toVar', ( ...params ) => createVar( ...params ).append() );

// Deprecated

const temp = ( node ) => { // @deprecated, r170

	console.warn( 'TSL: "temp" is deprecated. Use ".toVar()" instead.' );

	return createVar( node );

};

addMethodChaining( 'temp', temp );

/** @module VaryingNode **/

/**
 * Class for representing shader varyings as nodes. Varyings are create from
 * existing nodes like the following:
 *
 * ```js
 * const positionLocal = positionGeometry.varying( 'vPositionLocal' );
 * ```
 *
 * @augments Node
 */
class VaryingNode extends Node {

	static get type() {

		return 'VaryingNode';

	}

	/**
	 * Constructs a new varying node.
	 *
	 * @param {Node} node - The node for which a varying should be created.
	 * @param {String?} name - The name of the varying in the shader.
	 */
	constructor( node, name = null ) {

		super();

		/**
		 * The node for which a varying should be created.
		 *
		 * @type {Node}
		 */
		this.node = node;

		/**
		 * The name of the varying in the shader. If no name is defined,
		 * the node system auto-generates one.
		 *
		 * @type {String?}
		 * @default null
		 */
		this.name = name;

		/**
		 * This flag can be used for type testing.
		 *
		 * @type {Boolean}
		 * @readonly
		 * @default true
		 */
		this.isVaryingNode = true;

	}

	/**
	 * The method is overwritten so it always returns `true`.
	 *
	 * @param {NodeBuilder} builder - The current node builder.
	 * @return {Boolean} Whether this node is global or not.
	 */
	isGlobal( /*builder*/ ) {

		return true;

	}

	getHash( builder ) {

		return this.name || super.getHash( builder );

	}

	getNodeType( builder ) {

		// VaryingNode is auto type

		return this.node.getNodeType( builder );

	}

	/**
	 * This method performs the setup of a varying node with the current node builder.
	 *
	 * @param {NodeBuilder} builder - The current node builder.
	 * @return {NodeVarying} The node varying from the node builder.
	 */
	setupVarying( builder ) {

		const properties = builder.getNodeProperties( this );

		let varying = properties.varying;

		if ( varying === undefined ) {

			const name = this.name;
			const type = this.getNodeType( builder );

			properties.varying = varying = builder.getVaryingFromNode( this, name, type );
			properties.node = this.node;

		}

		// this property can be used to check if the varying can be optimized for a variable
		varying.needsInterpolation || ( varying.needsInterpolation = ( builder.shaderStage === 'fragment' ) );

		return varying;

	}

	setup( builder ) {

		this.setupVarying( builder );

	}

	analyze( builder ) {

		this.setupVarying( builder );

		return this.node.analyze( builder );

	}

	generate( builder ) {

		const properties = builder.getNodeProperties( this );
		const varying = this.setupVarying( builder );

		const needsReassign = builder.shaderStage === 'fragment' && properties.reassignPosition === true && builder.context.needsPositionReassign;

		if ( properties.propertyName === undefined || needsReassign ) {

			const type = this.getNodeType( builder );
			const propertyName = builder.getPropertyName( varying, NodeShaderStage.VERTEX );

			// force node run in vertex stage
			builder.flowNodeFromShaderStage( NodeShaderStage.VERTEX, this.node, type, propertyName );

			properties.propertyName = propertyName;

			if ( needsReassign ) {

				// once reassign varying in fragment stage
				properties.reassignPosition = false;

			} else if ( properties.reassignPosition === undefined && builder.context.isPositionNodeInput ) {

				properties.reassignPosition = true;

			}

		}

		return builder.getPropertyName( varying );

	}

}

/**
 * TSL function for creating a varying node.
 *
 * @function
 * @param {Node} node - The node for which a varying should be created.
 * @param {String?} name - The name of the varying in the shader.
 * @returns {VaryingNode}
 */
const varying = /*@__PURE__*/ nodeProxy( VaryingNode );

addMethodChaining( 'varying', varying );

/** @module ColorSpaceFunctions **/

/**
 * Converts the given color value from sRGB to linear-sRGB color space.
 *
 * @method
 * @param {Node<vec3>} color - The sRGB color.
 * @return {Node<vec3>} The linear-sRGB color.
 */
const sRGBTransferEOTF = /*@__PURE__*/ Fn( ( [ color ] ) => {

	const a = color.mul( 0.9478672986 ).add( 0.0521327014 ).pow( 2.4 );
	const b = color.mul( 0.0773993808 );
	const factor = color.lessThanEqual( 0.04045 );

	const rgbResult = mix( a, b, factor );

	return rgbResult;

} ).setLayout( {
	name: 'sRGBTransferEOTF',
	type: 'vec3',
	inputs: [
		{ name: 'color', type: 'vec3' }
	]
} );

/**
 * Converts the given color value from linear-sRGB to sRGB color space.
 *
 * @method
 * @param {Node<vec3>} color - The linear-sRGB color.
 * @return {Node<vec3>} The sRGB color.
 */
const sRGBTransferOETF = /*@__PURE__*/ Fn( ( [ color ] ) => {

	const a = color.pow( 0.41666 ).mul( 1.055 ).sub( 0.055 );
	const b = color.mul( 12.92 );
	const factor = color.lessThanEqual( 0.0031308 );

	const rgbResult = mix( a, b, factor );

	return rgbResult;

} ).setLayout( {
	name: 'sRGBTransferOETF',
	type: 'vec3',
	inputs: [
		{ name: 'color', type: 'vec3' }
	]
} );

/** @module ColorSpaceNode **/

const WORKING_COLOR_SPACE = 'WorkingColorSpace';
const OUTPUT_COLOR_SPACE = 'OutputColorSpace';

/**
 * This node represents a color space conversion. Meaning it converts
 * a color value from a source to a target color space.
 *
 * @augments TempNode
 */
class ColorSpaceNode extends TempNode {

	static get type() {

		return 'ColorSpaceNode';

	}

	/**
	 * Constructs a new color space node.
	 *
	 * @param {Node} colorNode - Represents the color to convert.
	 * @param {String} source - The source color space.
	 * @param {String} target - The target color space.
	 */
	constructor( colorNode, source, target ) {

		super( 'vec4' );

		/**
		 * Represents the color to convert.
		 *
		 * @type {Node}
		 */
		this.colorNode = colorNode;

		/**
		 * The source color space.
		 *
		 * @type {String}
		 */
		this.source = source;

		/**
		 * The target color space.
		 *
		 * @type {String}
		 */
		this.target = target;

	}

	/**
	 * This method resolves the constants `WORKING_COLOR_SPACE` and
	 * `OUTPUT_COLOR_SPACE` based on the current configuration of the
	 * color management and renderer.
	 *
	 * @param {NodeBuilder} builder - The current node builder.
	 * @param {String} colorSpace - The color space to resolve.
	 * @return {String} The resolved color space.
	 */
	resolveColorSpace( builder, colorSpace ) {

		if ( colorSpace === WORKING_COLOR_SPACE ) {

			return ColorManagement.workingColorSpace;

		} else if ( colorSpace === OUTPUT_COLOR_SPACE ) {

			return builder.context.outputColorSpace || builder.renderer.outputColorSpace;

		}

		return colorSpace;

	}

	setup( builder ) {

		const { colorNode } = this;

		const source = this.resolveColorSpace( builder, this.source );
		const target = this.resolveColorSpace( builder, this.target );

		let outputNode = colorNode;

		if ( ColorManagement.enabled === false || source === target || ! source || ! target ) {

			return outputNode;

		}

		if ( ColorManagement.getTransfer( source ) === SRGBTransfer ) {

			outputNode = vec4( sRGBTransferEOTF( outputNode.rgb ), outputNode.a );

		}

		if ( ColorManagement.getPrimaries( source ) !== ColorManagement.getPrimaries( target ) ) {

			outputNode = vec4(
				mat3( ColorManagement._getMatrix( new Matrix3(), source, target ) ).mul( outputNode.rgb ),
				outputNode.a
			);

		}

		if ( ColorManagement.getTransfer( target ) === SRGBTransfer ) {

			outputNode = vec4( sRGBTransferOETF( outputNode.rgb ), outputNode.a );

		}

		return outputNode;

	}

}

/**
 * TSL function for converting a given color node to the current output color space.
 *
 * @function
 * @param {Node} node - Represents the node to convert.
 * @returns {ColorSpaceNode}
 */
const toOutputColorSpace = ( node ) => nodeObject( new ColorSpaceNode( nodeObject( node ), WORKING_COLOR_SPACE, OUTPUT_COLOR_SPACE ) );

/**
 * TSL function for converting a given color node to the current working color space.
 *
 * @function
 * @param {Node} node - Represents the node to convert.
 * @returns {ColorSpaceNode}
 */
const toWorkingColorSpace = ( node ) => nodeObject( new ColorSpaceNode( nodeObject( node ), OUTPUT_COLOR_SPACE, WORKING_COLOR_SPACE ) );

/**
 * TSL function for converting a given color node from the current working color space to the given color space.
 *
 * @function
 * @param {Node} node - Represents the node to convert.
 * @param {String} colorSpace - The target color space.
 * @returns {ColorSpaceNode}
 */
const workingToColorSpace = ( node, colorSpace ) => nodeObject( new ColorSpaceNode( nodeObject( node ), WORKING_COLOR_SPACE, colorSpace ) );

/**
 * TSL function for converting a given color node from the given color space to the current working color space.
 *
 * @function
 * @param {Node} node - Represents the node to convert.
 * @param {String} colorSpace - The source color space.
 * @returns {ColorSpaceNode}
 */
const colorSpaceToWorking = ( node, colorSpace ) => nodeObject( new ColorSpaceNode( nodeObject( node ), colorSpace, WORKING_COLOR_SPACE ) );

/**
 * TSL function for converting a given color node from one color space to another one.
 *
 * @function
 * @param {Node} node - Represents the node to convert.
 * @param {String} sourceColorSpace - The source color space.
 * @param {String} targetColorSpace - The target color space.
 * @returns {ColorSpaceNode}
 */
const convertColorSpace = ( node, sourceColorSpace, targetColorSpace ) => nodeObject( new ColorSpaceNode( nodeObject( node ), sourceColorSpace, targetColorSpace ) );

addMethodChaining( 'toOutputColorSpace', toOutputColorSpace );
addMethodChaining( 'toWorkingColorSpace', toWorkingColorSpace );

addMethodChaining( 'workingToColorSpace', workingToColorSpace );
addMethodChaining( 'colorSpaceToWorking', colorSpaceToWorking );

let ReferenceElementNode$1 = class ReferenceElementNode extends ArrayElementNode {

	static get type() {

		return 'ReferenceElementNode';

	}

	constructor( referenceNode, indexNode ) {

		super( referenceNode, indexNode );

		this.referenceNode = referenceNode;

		this.isReferenceElementNode = true;

	}

	getNodeType() {

		return this.referenceNode.uniformType;

	}

	generate( builder ) {

		const snippet = super.generate( builder );
		const arrayType = this.referenceNode.getNodeType();
		const elementType = this.getNodeType();

		return builder.format( snippet, arrayType, elementType );

	}

};

class ReferenceBaseNode extends Node {

	static get type() {

		return 'ReferenceBaseNode';

	}

	constructor( property, uniformType, object = null, count = null ) {

		super();

		this.property = property;
		this.uniformType = uniformType;
		this.object = object;
		this.count = count;

		this.properties = property.split( '.' );
		this.reference = object;
		this.node = null;
		this.group = null;

		this.updateType = NodeUpdateType.OBJECT;

	}

	setGroup( group ) {

		this.group = group;

		return this;

	}

	element( indexNode ) {

		return nodeObject( new ReferenceElementNode$1( this, nodeObject( indexNode ) ) );

	}

	setNodeType( uniformType ) {

		const node = uniform( null, uniformType ).getSelf();

		if ( this.group !== null ) {

			node.setGroup( this.group );

		}

		this.node = node;

	}

	getNodeType( builder ) {

		if ( this.node === null ) {

			this.updateReference( builder );
			this.updateValue();

		}

		return this.node.getNodeType( builder );

	}

	getValueFromReference( object = this.reference ) {

		const { properties } = this;

		let value = object[ properties[ 0 ] ];

		for ( let i = 1; i < properties.length; i ++ ) {

			value = value[ properties[ i ] ];

		}

		return value;

	}

	updateReference( state ) {

		this.reference = this.object !== null ? this.object : state.object;

		return this.reference;

	}

	setup() {

		this.updateValue();

		return this.node;

	}

	update( /*frame*/ ) {

		this.updateValue();

	}

	updateValue() {

		if ( this.node === null ) this.setNodeType( this.uniformType );

		const value = this.getValueFromReference();

		if ( Array.isArray( value ) ) {

			this.node.array = value;

		} else {

			this.node.value = value;

		}

	}

}

const reference$1 = ( name, type, object ) => nodeObject( new ReferenceBaseNode( name, type, object ) );

class RendererReferenceNode extends ReferenceBaseNode {

	static get type() {

		return 'RendererReferenceNode';

	}

	constructor( property, inputType, renderer = null ) {

		super( property, inputType, renderer );

		this.renderer = renderer;

		this.setGroup( renderGroup );

	}

	updateReference( state ) {

		this.reference = this.renderer !== null ? this.renderer : state.renderer;

		return this.reference;

	}

}

const rendererReference = ( name, type, renderer ) => nodeObject( new RendererReferenceNode( name, type, renderer ) );

/** @module ToneMappingNode **/

/**
 * This node represents a tone mapping operation.
 *
 * @augments TempNode
 */
class ToneMappingNode extends TempNode {

	static get type() {

		return 'ToneMappingNode';

	}

	/**
	 * Constructs a new tone mapping node.
	 *
	 * @param {Number} toneMapping - The tone mapping type.
	 * @param {Node} exposureNode - The tone mapping exposure.
	 * @param {Node} [colorNode=null] - The color node to process.
	 */
	constructor( toneMapping, exposureNode = toneMappingExposure, colorNode = null ) {

		super( 'vec3' );

		/**
		 * The tone mapping type.
		 *
		 * @type {Number}
		 */
		this.toneMapping = toneMapping;

		/**
		 * The tone mapping exposure.
		 *
		 * @type {Node}
		 * @default null
		 */
		this.exposureNode = exposureNode;

		/**
		 * Represents the color to process.
		 *
		 * @type {Node?}
		 * @default null
		 */
		this.colorNode = colorNode;

	}

	/**
	 * Overwrites the default `customCacheKey()` implementation by including the tone
	 * mapping type into the cache key.
	 *
	 * @return {Number} The hash.
	 */
	customCacheKey() {

		return hash$1( this.toneMapping );

	}

	setup( builder ) {

		const colorNode = this.colorNode || builder.context.color;
		const toneMapping = this.toneMapping;

		if ( toneMapping === NoToneMapping ) return colorNode;

		let outputNode = null;

		const toneMappingFn = builder.renderer.library.getToneMappingFunction( toneMapping );

		if ( toneMappingFn !== null ) {

			outputNode = vec4( toneMappingFn( colorNode.rgb, this.exposureNode ), colorNode.a );

		} else {

			console.error( 'ToneMappingNode: Unsupported Tone Mapping configuration.', toneMapping );

			outputNode = colorNode;

		}

		return outputNode;

	}

}

/**
 * TSL function for creating a tone mapping node.
 *
 * @function
 * @param {Number} mapping - The tone mapping type.
 * @param {Node<float> | Number} exposure - The tone mapping exposure.
 * @param {Node<vec3> | Color} color - The color node to process.
 * @returns {ToneMappingNode<vec3>}
 */
const toneMapping = ( mapping, exposure, color ) => nodeObject( new ToneMappingNode( mapping, nodeObject( exposure ), nodeObject( color ) ) );

/**
 * TSL object that represents the global tone mapping exposure of the renderer.
 *
 * @type {RendererReferenceNode<vec3>}
 */
const toneMappingExposure = /*@__PURE__*/ rendererReference( 'toneMappingExposure', 'float' );

addMethodChaining( 'toneMapping', ( color, mapping, exposure ) => toneMapping( mapping, exposure, color ) );

class BufferAttributeNode extends InputNode {

	static get type() {

		return 'BufferAttributeNode';

	}

	constructor( value, bufferType = null, bufferStride = 0, bufferOffset = 0 ) {

		super( value, bufferType );

		this.isBufferNode = true;

		this.bufferType = bufferType;
		this.bufferStride = bufferStride;
		this.bufferOffset = bufferOffset;

		this.usage = StaticDrawUsage;
		this.instanced = false;

		this.attribute = null;

		this.global = true;

		if ( value && value.isBufferAttribute === true ) {

			this.attribute = value;
			this.usage = value.usage;
			this.instanced = value.isInstancedBufferAttribute;

		}

	}

	getHash( builder ) {

		if ( this.bufferStride === 0 && this.bufferOffset === 0 ) {

			let bufferData = builder.globalCache.getData( this.value );

			if ( bufferData === undefined ) {

				bufferData = {
					node: this
				};

				builder.globalCache.setData( this.value, bufferData );

			}

			return bufferData.node.uuid;

		}

		return this.uuid;

	}

	getNodeType( builder ) {

		if ( this.bufferType === null ) {

			this.bufferType = builder.getTypeFromAttribute( this.attribute );

		}

		return this.bufferType;

	}

	setup( builder ) {

		if ( this.attribute !== null ) return;

		const type = this.getNodeType( builder );
		const array = this.value;
		const itemSize = builder.getTypeLength( type );
		const stride = this.bufferStride || itemSize;
		const offset = this.bufferOffset;

		const buffer = array.isInterleavedBuffer === true ? array : new InterleavedBuffer( array, stride );
		const bufferAttribute = new InterleavedBufferAttribute( buffer, itemSize, offset );

		buffer.setUsage( this.usage );

		this.attribute = bufferAttribute;
		this.attribute.isInstancedBufferAttribute = this.instanced; // @TODO: Add a possible: InstancedInterleavedBufferAttribute

	}

	generate( builder ) {

		const nodeType = this.getNodeType( builder );

		const nodeAttribute = builder.getBufferAttributeFromNode( this, nodeType );
		const propertyName = builder.getPropertyName( nodeAttribute );

		let output = null;

		if ( builder.shaderStage === 'vertex' || builder.shaderStage === 'compute' ) {

			this.name = propertyName;

			output = propertyName;

		} else {

			const nodeVarying = varying( this );

			output = nodeVarying.build( builder, nodeType );

		}

		return output;

	}

	getInputType( /*builder*/ ) {

		return 'bufferAttribute';

	}

	setUsage( value ) {

		this.usage = value;

		if ( this.attribute && this.attribute.isBufferAttribute === true ) {

			this.attribute.usage = value;

		}

		return this;

	}

	setInstanced( value ) {

		this.instanced = value;

		return this;

	}

}

const bufferAttribute = ( array, type, stride, offset ) => nodeObject( new BufferAttributeNode( array, type, stride, offset ) );
const dynamicBufferAttribute = ( array, type, stride, offset ) => bufferAttribute( array, type, stride, offset ).setUsage( DynamicDrawUsage );

const instancedBufferAttribute = ( array, type, stride, offset ) => bufferAttribute( array, type, stride, offset ).setInstanced( true );
const instancedDynamicBufferAttribute = ( array, type, stride, offset ) => dynamicBufferAttribute( array, type, stride, offset ).setInstanced( true );

addMethodChaining( 'toAttribute', ( bufferNode ) => bufferAttribute( bufferNode.value ) );

class ComputeNode extends Node {

	static get type() {

		return 'ComputeNode';

	}

	constructor( computeNode, count, workgroupSize = [ 64 ] ) {

		super( 'void' );

		this.isComputeNode = true;

		this.computeNode = computeNode;

		this.count = count;
		this.workgroupSize = workgroupSize;
		this.dispatchCount = 0;

		this.version = 1;
		this.updateBeforeType = NodeUpdateType.OBJECT;

		this.onInitFunction = null;

		this.updateDispatchCount();

	}

	dispose() {

		this.dispatchEvent( { type: 'dispose' } );

	}

	set needsUpdate( value ) {

		if ( value === true ) this.version ++;

	}

	updateDispatchCount() {

		const { count, workgroupSize } = this;

		let size = workgroupSize[ 0 ];

		for ( let i = 1; i < workgroupSize.length; i ++ )
			size *= workgroupSize[ i ];

		this.dispatchCount = Math.ceil( count / size );

	}

	onInit( callback ) {

		this.onInitFunction = callback;

		return this;

	}

	updateBefore( { renderer } ) {

		renderer.compute( this );

	}

	generate( builder ) {

		const { shaderStage } = builder;

		if ( shaderStage === 'compute' ) {

			const snippet = this.computeNode.build( builder, 'void' );

			if ( snippet !== '' ) {

				builder.addLineFlowCode( snippet, this );

			}

		}

	}

}

const compute = ( node, count, workgroupSize ) => nodeObject( new ComputeNode( nodeObject( node ), count, workgroupSize ) );

addMethodChaining( 'compute', compute );

/** @module CacheNode **/

/**
 * This node can be used as a cache management component for another node.
 * Caching is in general used by default in {@link NodeBuilder} but this node
 * allows the usage of a shared parent cache during the build process.
 *
 * @augments Node
 */
class CacheNode extends Node {

	static get type() {

		return 'CacheNode';

	}

	/**
	 * Constructs a new cache node.
	 *
	 * @param {Node} node - The node that should be cached.
	 * @param {Boolean} [parent=true] - Whether this node refers to a shared parent cache or not.
	 */
	constructor( node, parent = true ) {

		super();

		/**
		 * The node that should be cached.
		 *
		 * @type {Node}
		 */
		this.node = node;

		/**
		 * Whether this node refers to a shared parent cache or not.
		 *
		 * @type {Boolean}
		 * @default true
		 */
		this.parent = parent;

		/**
		 * This flag can be used for type testing.
		 *
		 * @type {Boolean}
		 * @readonly
		 * @default true
		 */
		this.isCacheNode = true;

	}

	getNodeType( builder ) {

		return this.node.getNodeType( builder );

	}

	build( builder, ...params ) {

		const previousCache = builder.getCache();
		const cache = builder.getCacheFromNode( this, this.parent );

		builder.setCache( cache );

		const data = this.node.build( builder, ...params );

		builder.setCache( previousCache );

		return data;

	}

}

/**
 * TSL function for creating a cache node.
 *
 * @function
 * @param {Node} node - The node that should be cached.
 * @param {Boolean} parent - Whether this node refers to a shared parent cache or not.
 * @returns {CacheNode}
 */
const cache = ( node, parent ) => nodeObject( new CacheNode( nodeObject( node ), parent ) );

addMethodChaining( 'cache', cache );

/** @module BypassNode **/

/**
 * The class generates the code of a given node but returns another node in the output.
 * This can be used to call a method or node that does not return a value, i.e.
 * type `void` on an input where returning a value is required. Example:
 *
 * ```js
 * material.colorNode = myColor.bypass( runVoidFn() )
 *```
 *
 * @augments Node
 */
class BypassNode extends Node {

	static get type() {

		return 'BypassNode';

	}

	/**
	 * Constructs a new bypass node.
	 *
	 * @param {Node} outputNode - The output node.
	 * @param {Node} callNode - The call node.
	 */
	constructor( outputNode, callNode ) {

		super();

		/**
		 * This flag can be used for type testing.
		 *
		 * @type {Boolean}
		 * @readonly
		 * @default true
		 */
		this.isBypassNode = true;

		/**
		 * The output node.
		 *
		 * @type {Node}
		 */
		this.outputNode = outputNode;

		/**
		 * The call node.
		 *
		 * @type {Node}
		 */
		this.callNode = callNode;

	}

	getNodeType( builder ) {

		return this.outputNode.getNodeType( builder );

	}

	generate( builder ) {

		const snippet = this.callNode.build( builder, 'void' );

		if ( snippet !== '' ) {

			builder.addLineFlowCode( snippet, this );

		}

		return this.outputNode.build( builder );

	}

}

/**
 * TSL function for creating a bypass node.
 *
 * @function
 * @param {Node} outputNode - The output node.
 * @param {Node} callNode - The call node.
 * @returns {BypassNode}
 */
const bypass = /*@__PURE__*/ nodeProxy( BypassNode );

addMethodChaining( 'bypass', bypass );

/** @module RemapNode **/

/**
 * This node allows to remap a node value from one range into another. E.g a value of
 * `0.4` in the range `[ 0.3, 0.5 ]` should be remapped into the normalized range `[ 0, 1 ]`.
 * `RemapNode` takes care of that and converts the original value of `0.4` to `0.5`.
 *
 * @augments Node
 */
class RemapNode extends Node {

	static get type() {

		return 'RemapNode';

	}

	/**
	 * Constructs a new remap node.
	 *
	 * @param {Node} node - The node that should be remapped.
	 * @param {Node} inLowNode - The source or current lower bound of the range.
	 * @param {Node} inHighNode - The source or current upper bound of the range.
	 * @param {Node} [outLowNode=float(0)] - The target lower bound of the range.
	 * @param {Node} [outHighNode=float(1)] - The target upper bound of the range.
	 */
	constructor( node, inLowNode, inHighNode, outLowNode = float( 0 ), outHighNode = float( 1 ) ) {

		super();

		/**
		 * The node that should be remapped.
		 *
		 * @type {Node}
		 */
		this.node = node;

		/**
		 * The source or current lower bound of the range.
		 *
		 * @type {Node}
		 */
		this.inLowNode = inLowNode;

		/**
		 * The source or current upper bound of the range.
		 *
		 * @type {Node}
		 */
		this.inHighNode = inHighNode;

		/**
		 * The target lower bound of the range.
		 *
		 * @type {Node}
		 * @default float(0)
		 */
		this.outLowNode = outLowNode;

		/**
		 * The target upper bound of the range.
		 *
		 * @type {Node}
		 * @default float(1)
		 */
		this.outHighNode = outHighNode;

		/**
		 * Whether the node value should be clamped before
		 * remapping it to the target range.
		 *
		 * @type {Boolean}
		 * @default true
		 */
		this.doClamp = true;

	}

	setup() {

		const { node, inLowNode, inHighNode, outLowNode, outHighNode, doClamp } = this;

		let t = node.sub( inLowNode ).div( inHighNode.sub( inLowNode ) );

		if ( doClamp === true ) t = t.clamp();

		return t.mul( outHighNode.sub( outLowNode ) ).add( outLowNode );

	}

}

/**
 * TSL function for creating a remap node.
 *
 * @function
 * @param {Node} node - The node that should be remapped.
 * @param {Node} inLowNode - The source or current lower bound of the range.
 * @param {Node} inHighNode - The source or current upper bound of the range.
 * @param {Node} [outLowNode=float(0)] - The target lower bound of the range.
 * @param {Node} [outHighNode=float(1)] - The target upper bound of the range.
 * @returns {RemapNode}
 */
const remap = /*@__PURE__*/ nodeProxy( RemapNode, null, null, { doClamp: false } );

/**
 * TSL function for creating a remap node, but with enabled clamping.
 *
 * @function
 * @param {Node} node - The node that should be remapped.
 * @param {Node} inLowNode - The source or current lower bound of the range.
 * @param {Node} inHighNode - The source or current upper bound of the range.
 * @param {Node} [outLowNode=float(0)] - The target lower bound of the range.
 * @param {Node} [outHighNode=float(1)] - The target upper bound of the range.
 * @returns {RemapNode}
 */
const remapClamp = /*@__PURE__*/ nodeProxy( RemapNode );

addMethodChaining( 'remap', remap );
addMethodChaining( 'remapClamp', remapClamp );

/** @module ExpressionNode **/

/**
 * This class can be used to implement basic expressions in shader code.
 * Basic examples for that are `return`, `continue` or `discard` statements.
 *
 * @augments Node
 */
class ExpressionNode extends Node {

	static get type() {

		return 'ExpressionNode';

	}

	/**
	 * Constructs a new expression node.
	 *
	 * @param {String} [snippet=''] - The native code snippet.
	 * @param {String} [nodeType='void'] - The node type.
	 */
	constructor( snippet = '', nodeType = 'void' ) {

		super( nodeType );

		/**
		 * The native code snippet.
		 *
		 * @type {String}
		 * @default ''
		 */
		this.snippet = snippet;

	}

	generate( builder, output ) {

		const type = this.getNodeType( builder );
		const snippet = this.snippet;

		if ( type === 'void' ) {

			builder.addLineFlowCode( snippet, this );

		} else {

			return builder.format( `( ${ snippet } )`, type, output );

		}

	}

}

/**
 * TSL function for creating an expression node.
 *
 * @function
 * @param {String} [snippet=''] - The native code snippet.
 * @param {String} [nodeType='void'] - The node type.
 * @returns {ExpressionNode}
 */
const expression = /*@__PURE__*/ nodeProxy( ExpressionNode );

/** @module Discard **/

/**
 * Represents a `discard` shader operation in TSL.
 *
 * @method
 * @param {ConditionalNode?} conditional - An optional conditional node. It allows to decide whether the discard should be executed or not.
 * @return {Node} The `discard` expression.
 */
const Discard = ( conditional ) => ( conditional ? select( conditional, expression( 'discard' ) ) : expression( 'discard' ) ).append();

/**
 * Represents a `return` shader operation in TSL.
 *
 * @method
 * @return {ExpressionNode} The `return` expression.
 */
const Return = () => expression( 'return' ).append();

addMethodChaining( 'discard', Discard );

/** @module RenderOutputNode **/

/**
 * Normally, tone mapping and color conversion happens automatically
 * before outputting pixel too the default (screen) framebuffer. In certain
 * post processing setups this happens to late because certain effects
 * require e.g. sRGB input. For such scenarios, `RenderOutputNode` can be used
 * to apply tone mapping and color space conversion at an arbitrary point
 * in the effect chain.
 *
 * When applying tone mapping and color space conversion manually with this node,
 * you have to set {@link PostProcessing#outputColorTransform} to `false`.
 *
 * ```js
 * const postProcessing = new PostProcessing( renderer );
 * postProcessing.outputColorTransform = false;
 *
 * const scenePass = pass( scene, camera );
 * const outputPass = renderOutput( scenePass );
 *
 * postProcessing.outputNode = outputPass;
 * ```
 *
 * @augments TempNode
 */
class RenderOutputNode extends TempNode {

	static get type() {

		return 'RenderOutputNode';

	}

	/**
	 * Constructs a new render output node.
	 *
	 * @param {Node} colorNode - The color node to process.
	 * @param {Number} toneMapping - The tone mapping type.
	 * @param {String} outputColorSpace - The output color space.
	 */
	constructor( colorNode, toneMapping, outputColorSpace ) {

		super( 'vec4' );

		/**
		 * The color node to process.
		 *
		 * @type {Node}
		 */
		this.colorNode = colorNode;

		/**
		 * The tone mapping type.
		 *
		 * @type {Number?}
		 */
		this.toneMapping = toneMapping;

		/**
		 * The output color space.
		 *
		 * @type {String?}
		 */
		this.outputColorSpace = outputColorSpace;

		/**
		 * This flag can be used for type testing.
		 *
		 * @type {Boolean}
		 * @readonly
		 * @default true
		 */
		this.isRenderOutputNode = true;

	}

	setup( { context } ) {

		let outputNode = this.colorNode || context.color;

		// tone mapping

		const toneMapping = ( this.toneMapping !== null ? this.toneMapping : context.toneMapping ) || NoToneMapping;
		const outputColorSpace = ( this.outputColorSpace !== null ? this.outputColorSpace : context.outputColorSpace ) || NoColorSpace;

		if ( toneMapping !== NoToneMapping ) {

			outputNode = outputNode.toneMapping( toneMapping );

		}

		// working to output color space

		if ( outputColorSpace !== NoColorSpace && outputColorSpace !== ColorManagement.workingColorSpace ) {

			outputNode = outputNode.workingToColorSpace( outputColorSpace );

		}

		return outputNode;

	}

}

/**
 * TSL function for creating a posterize node.
 *
 * @function
 * @param {Node} color - The color node to process.
 * @param {Number?} [toneMapping=null] - The tone mapping type.
 * @param {String?} [outputColorSpace=null] - The output color space.
 * @returns {RenderOutputNode}
 */
const renderOutput = ( color, toneMapping = null, outputColorSpace = null ) => nodeObject( new RenderOutputNode( nodeObject( color ), toneMapping, outputColorSpace ) );

addMethodChaining( 'renderOutput', renderOutput );

// Non-PURE exports list, side-effects are required here.
// TSL Base Syntax


function addNodeElement( name/*, nodeElement*/ ) {

	console.warn( 'THREE.TSLBase: AddNodeElement has been removed in favor of tree-shaking. Trying add', name );

}

/** @module AttributeNode **/

/**
 * Base class for representing shader attributes as nodes.
 *
 * @augments Node
 */
class AttributeNode extends Node {

	static get type() {

		return 'AttributeNode';

	}

	/**
	 * Constructs a new attribute node.
	 *
	 * @param {String} attributeName - The name of the attribute.
	 * @param {String?} nodeType - The node type.
	 */
	constructor( attributeName, nodeType = null ) {

		super( nodeType );

		/**
		 * `AttributeNode` sets this property to `true` by default.
		 *
		 * @type {Boolean}
		 * @default true
		 */
		this.global = true;

		this._attributeName = attributeName;

	}

	getHash( builder ) {

		return this.getAttributeName( builder );

	}

	getNodeType( builder ) {

		let nodeType = this.nodeType;

		if ( nodeType === null ) {

			const attributeName = this.getAttributeName( builder );

			if ( builder.hasGeometryAttribute( attributeName ) ) {

				const attribute = builder.geometry.getAttribute( attributeName );

				nodeType = builder.getTypeFromAttribute( attribute );

			} else {

				nodeType = 'float';

			}

		}

		return nodeType;

	}

	/**
	 * Sets the attribute name to the given value. The method can be
	 * overwritten in derived classes if the final name must be computed
	 * analytically.
	 *
	 * @param {String} attributeName - The name of the attribute.
	 * @return {AttributeNode} A reference to this node.
	 */
	setAttributeName( attributeName ) {

		this._attributeName = attributeName;

		return this;

	}

	/**
	 * Returns the attribute name of this node. The method can be
	 * overwritten in derived classes if the final name must be computed
	 * analytically.
	 *
	 * @param {NodeBuilder} builder - The current node builder.
	 * @return {String} The attribute name.
	 */
	getAttributeName( /*builder*/ ) {

		return this._attributeName;

	}

	generate( builder ) {

		const attributeName = this.getAttributeName( builder );
		const nodeType = this.getNodeType( builder );
		const geometryAttribute = builder.hasGeometryAttribute( attributeName );

		if ( geometryAttribute === true ) {

			const attribute = builder.geometry.getAttribute( attributeName );
			const attributeType = builder.getTypeFromAttribute( attribute );

			const nodeAttribute = builder.getAttribute( attributeName, attributeType );

			if ( builder.shaderStage === 'vertex' ) {

				return builder.format( nodeAttribute.name, attributeType, nodeType );

			} else {

				const nodeVarying = varying( this );

				return nodeVarying.build( builder, nodeType );

			}

		} else {

			console.warn( `AttributeNode: Vertex attribute "${ attributeName }" not found on geometry.` );

			return builder.generateConst( nodeType );

		}

	}

	serialize( data ) {

		super.serialize( data );

		data.global = this.global;
		data._attributeName = this._attributeName;

	}

	deserialize( data ) {

		super.deserialize( data );

		this.global = data.global;
		this._attributeName = data._attributeName;

	}

}

/**
 * TSL function for creating an attribute node.
 *
 * @function
 * @param {String} name - The name of the attribute.
 * @param {String?} nodeType - The node type.
 * @returns {AttributeNode}
 */
const attribute = ( name, nodeType ) => nodeObject( new AttributeNode( name, nodeType ) );

/** @module UV **/

/**
 * TSL function for creating an uv attribute node with the given index.
 *
 * @function
 * @param {Number} [index=0] - The uv index.
 * @return {AttributeNode<vec2>} The uv attribute node.
 */
const uv = ( index = 0 ) => attribute( 'uv' + ( index > 0 ? index : '' ), 'vec2' );

/** @module TextureSizeNode **/

/**
 * A node that represents the dimensions of a texture. The texture size is
 * retrieved in the shader via built-in shader functions like `textureDimensions()`
 * or `textureSize()`.
 *
 * @augments Node
 */
class TextureSizeNode extends Node {

	static get type() {

		return 'TextureSizeNode';

	}

	/**
	 * Constructs a new texture size node.
	 *
	 * @param {TextureNode} textureNode - A texture node which size should be retrieved.
	 * @param {Node<int>?} [levelNode=null] - A level node which defines the requested mip.
	 */
	constructor( textureNode, levelNode = null ) {

		super( 'uvec2' );

		/**
		 * This flag can be used for type testing.
		 *
		 * @type {Boolean}
		 * @readonly
		 * @default true
		 */
		this.isTextureSizeNode = true;

		/**
		 * A texture node which size should be retrieved.
		 *
		 * @type {TextureNode}
		 */
		this.textureNode = textureNode;

		/**
		 * A level node which defines the requested mip.
		 *
		 * @type {Node<int>}
		 * @default null
		 */
		this.levelNode = levelNode;

	}

	generate( builder, output ) {

		const textureProperty = this.textureNode.build( builder, 'property' );
		const level = this.levelNode === null ? '0' : this.levelNode.build( builder, 'int' );

		return builder.format( `${ builder.getMethod( 'textureDimensions' ) }( ${ textureProperty }, ${ level } )`, this.getNodeType( builder ), output );

	}

}

/**
 * TSL function for creating a texture size node.
 *
 * @function
 * @param {TextureNode} textureNode - A texture node which size should be retrieved.
 * @param {Node<int>?} [levelNode=null] - A level node which defines the requested mip.
 * @returns {TextureSizeNode}
 */
const textureSize = /*@__PURE__*/ nodeProxy( TextureSizeNode );

/** @module MatcapUVNode **/

/**
 * A special type of uniform node that computes the
 * maximum mipmap level for a given texture node.
 *
 * ```js
 * const level = maxMipLevel( textureNode );
 * ```
 *
 * @augments module:UniformNode~UniformNode
 */
class MaxMipLevelNode extends UniformNode {

	static get type() {

		return 'MaxMipLevelNode';

	}

	/**
	 * Constructs a new max mip level node.
	 *
	 * @param {TextureNode} textureNode - The texture node to compute the max mip level for.
	 */
	constructor( textureNode ) {

		super( 0 );

		/**
		 * The texture node to compute the max mip level for.
		 *
		 * @private
		 * @type {TextureNode}
		 */
		this._textureNode = textureNode;

		/**
		 * The `updateType` is set to `NodeUpdateType.FRAME` since the node updates
		 * the texture once per frame in its {@link MaxMipLevelNode#update} method.
		 *
		 * @type {String}
		 * @default 'frame'
		 */
		this.updateType = NodeUpdateType.FRAME;

	}

	/**
	 * The texture node to compute the max mip level for.
	 *
	 * @readonly
	 * @type {TextureNode}
	 */
	get textureNode() {

		return this._textureNode;

	}

	/**
	 * The texture.
	 *
	 * @readonly
	 * @type {Texture}
	 */
	get texture() {

		return this._textureNode.value;

	}

	update() {

		const texture = this.texture;
		const images = texture.images;
		const image = ( images && images.length > 0 ) ? ( ( images[ 0 ] && images[ 0 ].image ) || images[ 0 ] ) : texture.image;

		if ( image && image.width !== undefined ) {

			const { width, height } = image;

			this.value = Math.log2( Math.max( width, height ) );

		}

	}

}

/**
 * TSL function for creating a max mip level node.
 *
 * @function
 * @param {TextureNode} textureNode - The texture node to compute the max mip level for.
 * @returns {MaxMipLevelNode}
 */
const maxMipLevel = /*@__PURE__*/ nodeProxy( MaxMipLevelNode );

class TextureNode extends UniformNode {

	static get type() {

		return 'TextureNode';

	}

	constructor( value, uvNode = null, levelNode = null, biasNode = null ) {

		super( value );

		this.isTextureNode = true;

		this.uvNode = uvNode;
		this.levelNode = levelNode;
		this.biasNode = biasNode;
		this.compareNode = null;
		this.depthNode = null;
		this.gradNode = null;

		this.sampler = true;
		this.updateMatrix = false;
		this.updateType = NodeUpdateType.NONE;

		this.referenceNode = null;

		this._value = value;
		this._matrixUniform = null;

		this.setUpdateMatrix( uvNode === null );

	}

	set value( value ) {

		if ( this.referenceNode ) {

			this.referenceNode.value = value;

		} else {

			this._value = value;

		}

	}

	get value() {

		return this.referenceNode ? this.referenceNode.value : this._value;

	}

	getUniformHash( /*builder*/ ) {

		return this.value.uuid;

	}

	getNodeType( /*builder*/ ) {

		if ( this.value.isDepthTexture === true ) return 'float';

		if ( this.value.type === UnsignedIntType ) {

			return 'uvec4';

		} else if ( this.value.type === IntType ) {

			return 'ivec4';

		}

		return 'vec4';

	}

	getInputType( /*builder*/ ) {

		return 'texture';

	}

	getDefaultUV() {

		return uv( this.value.channel );

	}

	updateReference( /*state*/ ) {

		return this.value;

	}

	getTransformedUV( uvNode ) {

		if ( this._matrixUniform === null ) this._matrixUniform = uniform( this.value.matrix );

		return this._matrixUniform.mul( vec3( uvNode, 1 ) ).xy;

	}

	setUpdateMatrix( value ) {

		this.updateMatrix = value;
		this.updateType = value ? NodeUpdateType.FRAME : NodeUpdateType.NONE;

		return this;

	}

	setupUV( builder, uvNode ) {

		const texture = this.value;

		if ( builder.isFlipY() && ( ( texture.image instanceof ImageBitmap && texture.flipY === true ) || texture.isRenderTargetTexture === true || texture.isFramebufferTexture === true || texture.isDepthTexture === true ) ) {

			if ( this.sampler ) {

				uvNode = uvNode.flipY();

			} else {

				uvNode = uvNode.setY( int( textureSize( this, this.levelNode ).y ).sub( uvNode.y ).sub( 1 ) );

			}

		}

		return uvNode;

	}

	setup( builder ) {

		const properties = builder.getNodeProperties( this );
		properties.referenceNode = this.referenceNode;

		//

		let uvNode = this.uvNode;

		if ( ( uvNode === null || builder.context.forceUVContext === true ) && builder.context.getUV ) {

			uvNode = builder.context.getUV( this );

		}

		if ( ! uvNode ) uvNode = this.getDefaultUV();

		if ( this.updateMatrix === true ) {

			uvNode = this.getTransformedUV( uvNode );

		}

		uvNode = this.setupUV( builder, uvNode );

		//

		let levelNode = this.levelNode;

		if ( levelNode === null && builder.context.getTextureLevel ) {

			levelNode = builder.context.getTextureLevel( this );

		}

		//

		properties.uvNode = uvNode;
		properties.levelNode = levelNode;
		properties.biasNode = this.biasNode;
		properties.compareNode = this.compareNode;
		properties.gradNode = this.gradNode;
		properties.depthNode = this.depthNode;

	}

	generateUV( builder, uvNode ) {

		return uvNode.build( builder, this.sampler === true ? 'vec2' : 'ivec2' );

	}

	generateSnippet( builder, textureProperty, uvSnippet, levelSnippet, biasSnippet, depthSnippet, compareSnippet, gradSnippet ) {

		const texture = this.value;

		let snippet;

		if ( levelSnippet ) {

			snippet = builder.generateTextureLevel( texture, textureProperty, uvSnippet, levelSnippet, depthSnippet );

		} else if ( biasSnippet ) {

			snippet = builder.generateTextureBias( texture, textureProperty, uvSnippet, biasSnippet, depthSnippet );

		} else if ( gradSnippet ) {

			snippet = builder.generateTextureGrad( texture, textureProperty, uvSnippet, gradSnippet, depthSnippet );

		} else if ( compareSnippet ) {

			snippet = builder.generateTextureCompare( texture, textureProperty, uvSnippet, compareSnippet, depthSnippet );

		} else if ( this.sampler === false ) {

			snippet = builder.generateTextureLoad( texture, textureProperty, uvSnippet, depthSnippet );

		} else {

			snippet = builder.generateTexture( texture, textureProperty, uvSnippet, depthSnippet );

		}

		return snippet;

	}

	generate( builder, output ) {

		const properties = builder.getNodeProperties( this );

		const texture = this.value;

		if ( ! texture || texture.isTexture !== true ) {

			throw new Error( 'TextureNode: Need a three.js texture.' );

		}

		const textureProperty = super.generate( builder, 'property' );

		if ( output === 'sampler' ) {

			return textureProperty + '_sampler';

		} else if ( builder.isReference( output ) ) {

			return textureProperty;

		} else {

			const nodeData = builder.getDataFromNode( this );

			let propertyName = nodeData.propertyName;

			if ( propertyName === undefined ) {

				const { uvNode, levelNode, biasNode, compareNode, depthNode, gradNode } = properties;

				const uvSnippet = this.generateUV( builder, uvNode );
				const levelSnippet = levelNode ? levelNode.build( builder, 'float' ) : null;
				const biasSnippet = biasNode ? biasNode.build( builder, 'float' ) : null;
				const depthSnippet = depthNode ? depthNode.build( builder, 'int' ) : null;
				const compareSnippet = compareNode ? compareNode.build( builder, 'float' ) : null;
				const gradSnippet = gradNode ? [ gradNode[ 0 ].build( builder, 'vec2' ), gradNode[ 1 ].build( builder, 'vec2' ) ] : null;

				const nodeVar = builder.getVarFromNode( this );

				propertyName = builder.getPropertyName( nodeVar );

				const snippet = this.generateSnippet( builder, textureProperty, uvSnippet, levelSnippet, biasSnippet, depthSnippet, compareSnippet, gradSnippet );

				builder.addLineFlowCode( `${propertyName} = ${snippet}`, this );

				nodeData.snippet = snippet;
				nodeData.propertyName = propertyName;

			}

			let snippet = propertyName;
			const nodeType = this.getNodeType( builder );

			if ( builder.needsToWorkingColorSpace( texture ) ) {

				snippet = colorSpaceToWorking( expression( snippet, nodeType ), texture.colorSpace ).setup( builder ).build( builder, nodeType );

			}

			return builder.format( snippet, nodeType, output );

		}

	}

	setSampler( value ) {

		this.sampler = value;

		return this;

	}

	getSampler() {

		return this.sampler;

	}

	// @TODO: Move to TSL

	uv( uvNode ) { // @deprecated, r172

		console.warn( 'THREE.TextureNode: .uv() has been renamed. Use .sample() instead.' );

		return this.sample( uvNode );

	}

	sample( uvNode ) {

		const textureNode = this.clone();
		textureNode.uvNode = nodeObject( uvNode );
		textureNode.referenceNode = this.getSelf();

		return nodeObject( textureNode );

	}

	blur( amountNode ) {

		const textureNode = this.clone();
		textureNode.biasNode = nodeObject( amountNode ).mul( maxMipLevel( textureNode ) );
		textureNode.referenceNode = this.getSelf();

		return nodeObject( textureNode );

	}

	level( levelNode ) {

		const textureNode = this.clone();
		textureNode.levelNode = nodeObject( levelNode );
		textureNode.referenceNode = this.getSelf();

		return nodeObject( textureNode );

	}

	size( levelNode ) {

		return textureSize( this, levelNode );

	}

	bias( biasNode ) {

		const textureNode = this.clone();
		textureNode.biasNode = nodeObject( biasNode );
		textureNode.referenceNode = this.getSelf();

		return nodeObject( textureNode );

	}

	compare( compareNode ) {

		const textureNode = this.clone();
		textureNode.compareNode = nodeObject( compareNode );
		textureNode.referenceNode = this.getSelf();

		return nodeObject( textureNode );

	}

	grad( gradNodeX, gradNodeY ) {

		const textureNode = this.clone();
		textureNode.gradNode = [ nodeObject( gradNodeX ), nodeObject( gradNodeY ) ];
		textureNode.referenceNode = this.getSelf();

		return nodeObject( textureNode );

	}

	depth( depthNode ) {

		const textureNode = this.clone();
		textureNode.depthNode = nodeObject( depthNode );
		textureNode.referenceNode = this.getSelf();

		return nodeObject( textureNode );

	}

	// --

	serialize( data ) {

		super.serialize( data );

		data.value = this.value.toJSON( data.meta ).uuid;
		data.sampler = this.sampler;
		data.updateMatrix = this.updateMatrix;
		data.updateType = this.updateType;

	}

	deserialize( data ) {

		super.deserialize( data );

		this.value = data.meta.textures[ data.value ];
		this.sampler = data.sampler;
		this.updateMatrix = data.updateMatrix;
		this.updateType = data.updateType;

	}

	update() {

		const texture = this.value;
		const matrixUniform = this._matrixUniform;

		if ( matrixUniform !== null ) matrixUniform.value = texture.matrix;

		if ( texture.matrixAutoUpdate === true ) {

			texture.updateMatrix();

		}

	}

	clone() {

		const newNode = new this.constructor( this.value, this.uvNode, this.levelNode, this.biasNode );
		newNode.sampler = this.sampler;

		return newNode;

	}

}

const texture = /*@__PURE__*/ nodeProxy( TextureNode );
const textureLoad = ( ...params ) => texture( ...params ).setSampler( false );

//export const textureLevel = ( value, uv, level ) => texture( value, uv ).level( level );

const sampler = ( aTexture ) => ( aTexture.isNode === true ? aTexture : texture( aTexture ) ).convert( 'sampler' );

/** @module Camera **/

/**
 * TSL object that represents the `near` value of the camera used for the current render.
 *
 * @type {UniformNode<float>}
 */
const cameraNear = /*@__PURE__*/ uniform( 'float' ).label( 'cameraNear' ).setGroup( renderGroup ).onRenderUpdate( ( { camera } ) => camera.near );

/**
 * TSL object that represents the `far` value of the camera used for the current render.
 *
 * @type {UniformNode<float>}
 */
const cameraFar = /*@__PURE__*/ uniform( 'float' ).label( 'cameraFar' ).setGroup( renderGroup ).onRenderUpdate( ( { camera } ) => camera.far );

/**
 * TSL object that represents the projection matrix of the camera used for the current render.
 *
 * @type {UniformNode<mat4>}
 */
const cameraProjectionMatrix = /*@__PURE__*/ uniform( 'mat4' ).label( 'cameraProjectionMatrix' ).setGroup( renderGroup ).onRenderUpdate( ( { camera } ) => camera.projectionMatrix );

/**
 * TSL object that represents the inverse projection matrix of the camera used for the current render.
 *
 * @type {UniformNode<mat4>}
 */
const cameraProjectionMatrixInverse = /*@__PURE__*/ uniform( 'mat4' ).label( 'cameraProjectionMatrixInverse' ).setGroup( renderGroup ).onRenderUpdate( ( { camera } ) => camera.projectionMatrixInverse );

/**
 * TSL object that represents the view matrix of the camera used for the current render.
 *
 * @type {UniformNode<mat4>}
 */
const cameraViewMatrix = /*@__PURE__*/ uniform( 'mat4' ).label( 'cameraViewMatrix' ).setGroup( renderGroup ).onRenderUpdate( ( { camera } ) => camera.matrixWorldInverse );

/**
 * TSL object that represents the world matrix of the camera used for the current render.
 *
 * @type {UniformNode<mat4>}
 */
const cameraWorldMatrix = /*@__PURE__*/ uniform( 'mat4' ).label( 'cameraWorldMatrix' ).setGroup( renderGroup ).onRenderUpdate( ( { camera } ) => camera.matrixWorld );

/**
 * TSL object that represents the normal matrix of the camera used for the current render.
 *
 * @type {UniformNode<mat3>}
 */
const cameraNormalMatrix = /*@__PURE__*/ uniform( 'mat3' ).label( 'cameraNormalMatrix' ).setGroup( renderGroup ).onRenderUpdate( ( { camera } ) => camera.normalMatrix );

/**
 * TSL object that represents the positon in world space of the camera used for the current render.
 *
 * @type {UniformNode<vec3>}
 */
const cameraPosition = /*@__PURE__*/ uniform( new Vector3() ).label( 'cameraPosition' ).setGroup( renderGroup ).onRenderUpdate( ( { camera }, self ) => self.value.setFromMatrixPosition( camera.matrixWorld ) );

class Object3DNode extends Node {

	static get type() {

		return 'Object3DNode';

	}

	constructor( scope, object3d = null ) {

		super();

		this.scope = scope;
		this.object3d = object3d;

		this.updateType = NodeUpdateType.OBJECT;

		this._uniformNode = new UniformNode( null );

	}

	getNodeType() {

		const scope = this.scope;

		if ( scope === Object3DNode.WORLD_MATRIX ) {

			return 'mat4';

		} else if ( scope === Object3DNode.POSITION || scope === Object3DNode.VIEW_POSITION || scope === Object3DNode.DIRECTION || scope === Object3DNode.SCALE ) {

			return 'vec3';

		}

	}

	update( frame ) {

		const object = this.object3d;
		const uniformNode = this._uniformNode;
		const scope = this.scope;

		if ( scope === Object3DNode.WORLD_MATRIX ) {

			uniformNode.value = object.matrixWorld;

		} else if ( scope === Object3DNode.POSITION ) {

			uniformNode.value = uniformNode.value || new Vector3();

			uniformNode.value.setFromMatrixPosition( object.matrixWorld );

		} else if ( scope === Object3DNode.SCALE ) {

			uniformNode.value = uniformNode.value || new Vector3();

			uniformNode.value.setFromMatrixScale( object.matrixWorld );

		} else if ( scope === Object3DNode.DIRECTION ) {

			uniformNode.value = uniformNode.value || new Vector3();

			object.getWorldDirection( uniformNode.value );

		} else if ( scope === Object3DNode.VIEW_POSITION ) {

			const camera = frame.camera;

			uniformNode.value = uniformNode.value || new Vector3();
			uniformNode.value.setFromMatrixPosition( object.matrixWorld );

			uniformNode.value.applyMatrix4( camera.matrixWorldInverse );

		}

	}

	generate( builder ) {

		const scope = this.scope;

		if ( scope === Object3DNode.WORLD_MATRIX ) {

			this._uniformNode.nodeType = 'mat4';

		} else if ( scope === Object3DNode.POSITION || scope === Object3DNode.VIEW_POSITION || scope === Object3DNode.DIRECTION || scope === Object3DNode.SCALE ) {

			this._uniformNode.nodeType = 'vec3';

		}

		return this._uniformNode.build( builder );

	}

	serialize( data ) {

		super.serialize( data );

		data.scope = this.scope;

	}

	deserialize( data ) {

		super.deserialize( data );

		this.scope = data.scope;

	}

}

Object3DNode.WORLD_MATRIX = 'worldMatrix';
Object3DNode.POSITION = 'position';
Object3DNode.SCALE = 'scale';
Object3DNode.VIEW_POSITION = 'viewPosition';
Object3DNode.DIRECTION = 'direction';

const objectDirection = /*@__PURE__*/ nodeProxy( Object3DNode, Object3DNode.DIRECTION );
const objectWorldMatrix = /*@__PURE__*/ nodeProxy( Object3DNode, Object3DNode.WORLD_MATRIX );
const objectPosition = /*@__PURE__*/ nodeProxy( Object3DNode, Object3DNode.POSITION );
const objectScale = /*@__PURE__*/ nodeProxy( Object3DNode, Object3DNode.SCALE );
const objectViewPosition = /*@__PURE__*/ nodeProxy( Object3DNode, Object3DNode.VIEW_POSITION );

class ModelNode extends Object3DNode {

	static get type() {

		return 'ModelNode';

	}

	constructor( scope ) {

		super( scope );

	}

	update( frame ) {

		this.object3d = frame.object;

		super.update( frame );

	}

}

const modelDirection = /*@__PURE__*/ nodeImmutable( ModelNode, ModelNode.DIRECTION );
const modelWorldMatrix = /*@__PURE__*/ nodeImmutable( ModelNode, ModelNode.WORLD_MATRIX );
const modelPosition = /*@__PURE__*/ nodeImmutable( ModelNode, ModelNode.POSITION );
const modelScale = /*@__PURE__*/ nodeImmutable( ModelNode, ModelNode.SCALE );
const modelViewPosition = /*@__PURE__*/ nodeImmutable( ModelNode, ModelNode.VIEW_POSITION );
const modelNormalMatrix = /*@__PURE__*/ uniform( new Matrix3() ).onObjectUpdate( ( { object }, self ) => self.value.getNormalMatrix( object.matrixWorld ) );
const modelWorldMatrixInverse = /*@__PURE__*/ uniform( new Matrix4() ).onObjectUpdate( ( { object }, self ) => self.value.copy( object.matrixWorld ).invert() );

const modelViewMatrix = /*@__PURE__*/ ( Fn( ( builder ) => {

	return builder.renderer.nodes.modelViewMatrix || mediumpModelViewMatrix;

} ).once() )().toVar( 'modelViewMatrix' );

// GPU Precision

const mediumpModelViewMatrix = /*@__PURE__*/ cameraViewMatrix.mul( modelWorldMatrix );

// CPU Precision

const highpModelViewMatrix = /*@__PURE__*/ ( Fn( ( builder ) => {

	builder.context.isHighPrecisionModelViewMatrix = true;

	return uniform( 'mat4' ).onObjectUpdate( ( { object, camera } ) => {

		return object.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );

	} );

} ).once() )().toVar( 'highpModelViewMatrix' );

const highpModelNormalViewMatrix = /*@__PURE__*/ ( Fn( ( builder ) => {

	const isHighPrecisionModelViewMatrix = builder.context.isHighPrecisionModelViewMatrix;

	return uniform( 'mat3' ).onObjectUpdate( ( { object, camera } ) => {

		if ( isHighPrecisionModelViewMatrix !== true ) {

			object.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );

		}

		return object.normalMatrix.getNormalMatrix( object.modelViewMatrix );

	} );

} ).once() )().toVar( 'highpModelNormalViewMatrix' );

/** @module Position **/

/**
 * TSL object that represents the position attribute of the current rendered object.
 *
 * @type {AttributeNode<vec3>}
 */
const positionGeometry = /*@__PURE__*/ attribute( 'position', 'vec3' );

/**
 * TSL object that represents the vertex position in local space of the current rendered object.
 *
 * @type {AttributeNode<vec3>}
 */
const positionLocal = /*@__PURE__*/ positionGeometry.varying( 'positionLocal' );

/**
 * TSL object that represents the previous vertex position in local space of the current rendered object.
 * Used in context of {@link module:VelocityNode~VelocityNode} for rendering motion vectors.
 *
 * @type {AttributeNode<vec3>}
 */
const positionPrevious = /*@__PURE__*/ positionGeometry.varying( 'positionPrevious' );

/**
 * TSL object that represents the vertex position in world space of the current rendered object.
 *
 * @type {VaryingNode<vec3>}
 */
const positionWorld = /*@__PURE__*/ modelWorldMatrix.mul( positionLocal ).xyz.varying( 'v_positionWorld' ).context( { needsPositionReassign: true } );

/**
 * TSL object that represents the position world direction of the current rendered object.
 *
 * @type {Node<vec3>}
 */
const positionWorldDirection = /*@__PURE__*/ positionLocal.transformDirection( modelWorldMatrix ).varying( 'v_positionWorldDirection' ).normalize().toVar( 'positionWorldDirection' ).context( { needsPositionReassign: true } );

/**
 * TSL object that represents the vertex position in view space of the current rendered object.
 *
 * @type {VaryingNode<vec3>}
 */
const positionView = /*@__PURE__*/ ( Fn( ( builder ) => {

	return builder.context.setupPositionView();

}, 'vec3' ).once() )().varying( 'v_positionView' ).context( { needsPositionReassign: true } );

/**
 * TSL object that represents the position view direction of the current rendered object.
 *
 * @type {VaryingNode<vec3>}
 */
const positionViewDirection = /*@__PURE__*/ positionView.negate().varying( 'v_positionViewDirection' ).normalize().toVar( 'positionViewDirection' );

/** @module FrontFacingNode **/

/**
 * This node can be used to evaluate whether a primitive is front or back facing.
 *
 * @augments Node
 */
class FrontFacingNode extends Node {

	static get type() {

		return 'FrontFacingNode';

	}

	/**
	 * Constructs a new front facing node.
	 */
	constructor() {

		super( 'bool' );

		/**
		 * This flag can be used for type testing.
		 *
		 * @type {Boolean}
		 * @readonly
		 * @default true
		 */
		this.isFrontFacingNode = true;

	}

	generate( builder ) {

		const { renderer, material } = builder;

		if ( renderer.coordinateSystem === WebGLCoordinateSystem ) {

			if ( material.side === BackSide ) {

				return 'false';

			}

		}

		return builder.getFrontFacing();

	}

}

/**
 * TSL object that represents whether a primitive is front or back facing
 *
 * @type {FrontFacingNode<bool>}
 */
const frontFacing = /*@__PURE__*/ nodeImmutable( FrontFacingNode );

/**
 * TSL object that represents the front facing status as a number instead of a bool.
 * `1` means front facing, `-1` means back facing.
 *
 * @type {Node<float>}
 */
const faceDirection = /*@__PURE__*/ float( frontFacing ).mul( 2.0 ).sub( 1.0 );

/** @module Normal **/

/**
 * TSL object that represents the normal attribute of the current rendered object.
 *
 * @type {Node<vec3>}
 */
const normalGeometry = /*@__PURE__*/ attribute( 'normal', 'vec3' );

/**
 * TSL object that represents the vertex normal in local space of the current rendered object.
 *
 * @type {Node<vec3>}
 */
const normalLocal = /*@__PURE__*/ ( Fn( ( builder ) => {

	if ( builder.geometry.hasAttribute( 'normal' ) === false ) {

		console.warn( 'TSL.NormalNode: Vertex attribute "normal" not found on geometry.' );

		return vec3( 0, 1, 0 );

	}

	return normalGeometry;

}, 'vec3' ).once() )().toVar( 'normalLocal' );

/**
 * TSL object that represents the flat vertex normal in view space of the current rendered object.
 *
 * @type {Node<vec3>}
 */
const normalFlat = /*@__PURE__*/ positionView.dFdx().cross( positionView.dFdy() ).normalize().toVar( 'normalFlat' );

/**
 * TSL object that represents the vertex normal in view space of the current rendered object.
 *
 * @type {Node<vec3>}
 */
const normalView = /*@__PURE__*/ ( Fn( ( builder ) => {

	let node;

	if ( builder.material.flatShading === true ) {

		node = normalFlat;

	} else {

		node = varying( transformNormalToView( normalLocal ), 'v_normalView' ).normalize();

	}

	return node;

}, 'vec3' ).once() )().toVar( 'normalView' );

/**
 * TSL object that represents the vertex normal in world space of the current rendered object.
 *
 * @type {Node<vec3>}
 */
const normalWorld = /*@__PURE__*/ varying( normalView.transformDirection( cameraViewMatrix ), 'v_normalWorld' ).normalize().toVar( 'normalWorld' );

/**
 * TSL object that represents the transformed vertex normal in view space of the current rendered object.
 *
 * @type {Node<vec3>}
 */
const transformedNormalView = /*@__PURE__*/ ( Fn( ( builder ) => {

	return builder.context.setupNormal();

}, 'vec3' ).once() )().mul( faceDirection ).toVar( 'transformedNormalView' );

/**
 * TSL object that represents the transformed vertex normal in world space of the current rendered object.
 *
 * @type {Node<vec3>}
 */
const transformedNormalWorld = /*@__PURE__*/ transformedNormalView.transformDirection( cameraViewMatrix ).toVar( 'transformedNormalWorld' );

/**
 * TSL object that represents the transformed clearcoat vertex normal in view space of the current rendered object.
 *
 * @type {Node<vec3>}
 */
const transformedClearcoatNormalView = /*@__PURE__*/ ( Fn( ( builder ) => {

	return builder.context.setupClearcoatNormal();

}, 'vec3' ).once() )().mul( faceDirection ).toVar( 'transformedClearcoatNormalView' );

/**
 * Transforms the normal with the given matrix.
 *
 * @function
 * @param {Node<vec3>} normal - The normal.
 * @param {Node<mat3>} [matrix=modelWorldMatrix] - The matrix.
 * @return {Node<vec3>} The transformed normal.
 */
const transformNormal = /*@__PURE__*/ Fn( ( [ normal, matrix = modelWorldMatrix ] ) => {

	const m = mat3( matrix );

	const transformedNormal = normal.div( vec3( m[ 0 ].dot( m[ 0 ] ), m[ 1 ].dot( m[ 1 ] ), m[ 2 ].dot( m[ 2 ] ) ) );

	return m.mul( transformedNormal ).xyz;

} );

/**
 * Transforms the given normal from local to view space.
 *
 * @function
 * @param {Node<vec3>} normal - The normal.
 * @param {NodeBuilder} builder - The current node builder.
 * @return {Node<vec3>} The transformed normal.
 */
const transformNormalToView = /*@__PURE__*/ Fn( ( [ normal ], builder ) => {

	const modelNormalViewMatrix = builder.renderer.nodes.modelNormalViewMatrix;

	if ( modelNormalViewMatrix !== null ) {

		return modelNormalViewMatrix.transformDirection( normal );

	}

	//

	const transformedNormal = modelNormalMatrix.mul( normal );

	return cameraViewMatrix.transformDirection( transformedNormal );

} );

const materialRefractionRatio = /*@__PURE__*/ uniform( 0 ).onReference( ( { material } ) => material ).onRenderUpdate( ( { material } ) => material.refractionRatio );

const reflectView = /*@__PURE__*/ positionViewDirection.negate().reflect( transformedNormalView );
const refractView = /*@__PURE__*/ positionViewDirection.negate().refract( transformedNormalView, materialRefractionRatio );

const reflectVector = /*@__PURE__*/ reflectView.transformDirection( cameraViewMatrix ).toVar( 'reflectVector' );
const refractVector = /*@__PURE__*/ refractView.transformDirection( cameraViewMatrix ).toVar( 'reflectVector' );

class CubeTextureNode extends TextureNode {

	static get type() {

		return 'CubeTextureNode';

	}

	constructor( value, uvNode = null, levelNode = null, biasNode = null ) {

		super( value, uvNode, levelNode, biasNode );

		this.isCubeTextureNode = true;

	}

	getInputType( /*builder*/ ) {

		return 'cubeTexture';

	}

	getDefaultUV() {

		const texture = this.value;

		if ( texture.mapping === CubeReflectionMapping ) {

			return reflectVector;

		} else if ( texture.mapping === CubeRefractionMapping ) {

			return refractVector;

		} else {

			console.error( 'THREE.CubeTextureNode: Mapping "%s" not supported.', texture.mapping );

			return vec3( 0, 0, 0 );

		}

	}

	setUpdateMatrix( /*updateMatrix*/ ) { } // Ignore .updateMatrix for CubeTextureNode

	setupUV( builder, uvNode ) {

		const texture = this.value;

		if ( builder.renderer.coordinateSystem === WebGPUCoordinateSystem || ! texture.isRenderTargetTexture ) {

			return vec3( uvNode.x.negate(), uvNode.yz );

		} else {

			return uvNode;

		}

	}

	generateUV( builder, cubeUV ) {

		return cubeUV.build( builder, 'vec3' );

	}

}

const cubeTexture = /*@__PURE__*/ nodeProxy( CubeTextureNode );

/** @module BufferNode **/

/**
 * A special type of uniform node which represents array-like data
 * as uniform buffers. The access usually happens via `element()`
 * which returns an instance of {@link ArrayElementNode}. For example:
 *
 * ```js
 * const bufferNode = buffer( array, 'mat4', count );
 * const matrixNode = bufferNode.element( index ); // access a matrix from the buffer
 * ```
 * In general, it is recommened to use the more managed {@link UniformArrayNode}
 * since it handles more input types and automatically cares about buffer paddings.
 *
 * @augments module:UniformNode~UniformNode
 */
class BufferNode extends UniformNode {

	static get type() {

		return 'BufferNode';

	}

	/**
	 * Constructs a new buffer node.
	 *
	 * @param {Array<Number>} value - Array-like buffer data.
	 * @param {String} bufferType - The data type of the buffer.
	 * @param {Number} [bufferCount=0] - The count of buffer elements.
	 */
	constructor( value, bufferType, bufferCount = 0 ) {

		super( value, bufferType );

		/**
		 * This flag can be used for type testing.
		 *
		 * @type {Boolean}
		 * @readonly
		 * @default true
		 */
		this.isBufferNode = true;

		/**
		 * The data type of the buffer.
		 *
		 * @type {String}
		 */
		this.bufferType = bufferType;

		/**
		 * The uniform node that holds the value of the reference node.
		 *
		 * @type {Number}
		 * @default 0
		 */
		this.bufferCount = bufferCount;

	}

	/**
	 * The data type of the buffer elements.
	 *
	 * @param {NodeBuilder} builder - The current node builder.
	 * @return {String} The element type.
	 */
	getElementType( builder ) {

		return this.getNodeType( builder );

	}

	/**
	 * Overwrites the default implementation to return a fixed value `'buffer'`.
	 *
	 * @param {NodeBuilder} builder - The current node builder.
	 * @return {String} The input type.
	 */
	getInputType( /*builder*/ ) {

		return 'buffer';

	}

}

/**
 * TSL function for creating a buffer node.
 *
 * @function
 * @param {Array} value - Array-like buffer data.
 * @param {String} type - The data type of a buffer element.
 * @param {Number} count - The count of buffer elements.
 * @returns {BufferNode}
 */
const buffer = ( value, type, count ) => nodeObject( new BufferNode( value, type, count ) );

/** @module UniformArrayNode **/

/**
 * Represents the element access on uniform array nodes.
 *
 * @augments ArrayElementNode
 */
class UniformArrayElementNode extends ArrayElementNode {

	static get type() {

		return 'UniformArrayElementNode';

	}

	/**
	 * Constructs a new buffer node.
	 *
	 * @param {UniformArrayNode} uniformArrayNode - The uniform array node to access.
	 * @param {IndexNode} indexNode - The index data that define the position of the accessed element in the array.
	 */
	constructor( uniformArrayNode, indexNode ) {

		super( uniformArrayNode, indexNode );

		/**
		 * This flag can be used for type testing.
		 *
		 * @type {Boolean}
		 * @readonly
		 * @default true
		 */
		this.isArrayBufferElementNode = true;

	}

	generate( builder ) {

		const snippet = super.generate( builder );
		const type = this.getNodeType();
		const paddedType = this.node.getPaddedType();

		return builder.format( snippet, paddedType, type );

	}

}

/**
 * Similar to {@link module:BufferNode~BufferNode} this module represents array-like data as
 * uniform buffers. Unlike {@link module:BufferNode~BufferNode}, it can handle more common
 * data types in the array (e.g `three.js` primitives) and automatically
 * manage buffer padding. It should be the first choice when working with
 * uniforms buffers.
 * ```js
 * const tintColors = uniformArray( [
 * 	new Color( 1, 0, 0 ),
 * 	new Color( 0, 1, 0 ),
 * 	new Color( 0, 0, 1 )
 * ], 'color' );
 *
 * const redColor = tintColors.element( 0 );
 *
 * @augments module:BufferNode~BufferNode
 */
class UniformArrayNode extends BufferNode {

	static get type() {

		return 'UniformArrayNode';

	}

	/**
	 * Constructs a new uniform array node.
	 *
	 * @param {Array<Any>} value - Array holding the buffer data.
	 * @param {String?} [elementType=null] - The data type of a buffer element.
	 */
	constructor( value, elementType = null ) {

		super( null );

		/**
		 * Array holding the buffer data. Unlike {@link module:BufferNode~BufferNode}, the array can
		 * hold number primitives as well as three.js objects like vectors, matrices
		 * or colors.
		 *
		 * @type {Array<Any>}
		 */
		this.array = value;

		/**
		 * The data type of an array element.
		 *
		 * @type {String}
		 */
		this.elementType = elementType === null ? getValueType( value[ 0 ] ) : elementType;

		/**
		 * The padded type. Uniform buffers must conform to a certain buffer layout
		 * so a separate type is computed to ensure correct buffer size.
		 *
		 * @type {String}
		 */
		this.paddedType = this.getPaddedType();

		/**
		 * Overwritten since uniform array nodes are updated per render.
		 *
		 * @type {String}
		 * @default 'render'
		 */
		this.updateType = NodeUpdateType.RENDER;

		/**
		 * This flag can be used for type testing.
		 *
		 * @type {Boolean}
		 * @readonly
		 * @default true
		 */
		this.isArrayBufferNode = true;

	}

	/**
	 * This method is overwritten since the node type is inferred from the
	 * {@link module:UniformArrayNode~UniformArrayNode#paddedType}.
	 *
	 * @param {NodeBuilder} builder - The current node builder.
	 * @return {String} The node type.
	 */
	getNodeType( /*builder*/ ) {

		return this.paddedType;

	}

	/**
	 * The data type of the array elements.
	 *
	 * @param {NodeBuilder} builder - The current node builder.
	 * @return {String} The element type.
	 */
	getElementType() {

		return this.elementType;

	}

	/**
	 * Returns the padded type based on the element type.
	 *
	 * @return {String} The padded type.
	 */
	getPaddedType() {

		const elementType = this.elementType;

		let paddedType = 'vec4';

		if ( elementType === 'mat2' ) {

			paddedType = 'mat2';

		} else if ( /mat/.test( elementType ) === true ) {

			paddedType = 'mat4';

		} else if ( elementType.charAt( 0 ) === 'i' ) {

			paddedType = 'ivec4';

		} else if ( elementType.charAt( 0 ) === 'u' ) {

			paddedType = 'uvec4';

		}

		return paddedType;

	}

	/**
	 * The update makes sure to correctly transfer the data from the (complex) objects
	 * in the array to the internal, correctly padded value buffer.
	 *
	 * @param {NodeFrame} frame - A reference to the current node frame.
	 */
	update( /*frame*/ ) {

		const { array, value } = this;

		const elementType = this.elementType;

		if ( elementType === 'float' || elementType === 'int' || elementType === 'uint' ) {

			for ( let i = 0; i < array.length; i ++ ) {

				const index = i * 4;

				value[ index ] = array[ i ];

			}

		} else if ( elementType === 'color' ) {

			for ( let i = 0; i < array.length; i ++ ) {

				const index = i * 4;
				const vector = array[ i ];

				value[ index ] = vector.r;
				value[ index + 1 ] = vector.g;
				value[ index + 2 ] = vector.b || 0;
				//value[ index + 3 ] = vector.a || 0;

			}

		} else if ( elementType === 'mat2' ) {

			for ( let i = 0; i < array.length; i ++ ) {

				const index = i * 4;
				const matrix = array[ i ];

				value[ index ] = matrix.elements[ 0 ];
				value[ index + 1 ] = matrix.elements[ 1 ];
				value[ index + 2 ] = matrix.elements[ 2 ];
				value[ index + 3 ] = matrix.elements[ 3 ];

			}

		} else if ( elementType === 'mat3' ) {

			for ( let i = 0; i < array.length; i ++ ) {

				const index = i * 16;
				const matrix = array[ i ];

				value[ index ] = matrix.elements[ 0 ];
				value[ index + 1 ] = matrix.elements[ 1 ];
				value[ index + 2 ] = matrix.elements[ 2 ];

				value[ index + 4 ] = matrix.elements[ 3 ];
				value[ index + 5 ] = matrix.elements[ 4 ];
				value[ index + 6 ] = matrix.elements[ 5 ];

				value[ index + 8 ] = matrix.elements[ 6 ];
				value[ index + 9 ] = matrix.elements[ 7 ];
				value[ index + 10 ] = matrix.elements[ 8 ];

				value[ index + 15 ] = 1;

			}

		} else if ( elementType === 'mat4' ) {

			for ( let i = 0; i < array.length; i ++ ) {

				const index = i * 16;
				const matrix = array[ i ];

				for ( let i = 0; i < matrix.elements.length; i ++ ) {

					value[ index + i ] = matrix.elements[ i ];

				}

			}

		} else {

			for ( let i = 0; i < array.length; i ++ ) {

				const index = i * 4;
				const vector = array[ i ];

				value[ index ] = vector.x;
				value[ index + 1 ] = vector.y;
				value[ index + 2 ] = vector.z || 0;
				value[ index + 3 ] = vector.w || 0;

			}

		}

	}

	/**
	 * Implement the value buffer creation based on the array data.
	 *
	 * @param {NodeBuilder} builder - A reference to the current node builder.
	 * @return {null}
	 */
	setup( builder ) {

		const length = this.array.length;
		const elementType = this.elementType;

		let arrayType = Float32Array;

		const paddedType = this.paddedType;
		const paddedElementLength = builder.getTypeLength( paddedType );

		if ( elementType.charAt( 0 ) === 'i' ) arrayType = Int32Array;
		if ( elementType.charAt( 0 ) === 'u' ) arrayType = Uint32Array;

		this.value = new arrayType( length * paddedElementLength );
		this.bufferCount = length;
		this.bufferType = paddedType;

		return super.setup( builder );

	}

	/**
	 * Overwrites the default `element()` method to provide element access
	 * based on {@link module:UniformArrayNode~UniformArrayNode}.
	 *
	 * @param {IndexNode} indexNode - The index node.
	 * @return {UniformArrayElementNode}
	 */
	element( indexNode ) {

		return nodeObject( new UniformArrayElementNode( this, nodeObject( indexNode ) ) );

	}

}

/**
 * TSL function for creating an uniform array node.
 *
 * @function
 * @param {Array<Any>} values - Array-like data.
 * @param {String} nodeType - The data type of the array elements.
 * @returns {UniformArrayNode}
 */
const uniformArray = ( values, nodeType ) => nodeObject( new UniformArrayNode( values, nodeType ) );

//

const uniforms = ( values, nodeType ) => { // @deprecated, r168

	console.warn( 'TSL.UniformArrayNode: uniforms() has been renamed to uniformArray().' );
	return nodeObject( new UniformArrayNode( values, nodeType ) );

};

/** @module ReferenceNode **/

/**
 * This class is only relevant if the referenced property is array-like.
 * In this case, `ReferenceElementNode` allows to refer to a specific
 * element inside the data structure via an index.
 *
 * @augments ArrayElementNode
 */
class ReferenceElementNode extends ArrayElementNode {

	static get type() {

		return 'ReferenceElementNode';

	}

	/**
	 * Constructs a new reference element node.
	 *
	 * @param {Node} referenceNode - The reference node.
	 * @param {Node} indexNode - The index node that defines the element access.
	 */
	constructor( referenceNode, indexNode ) {

		super( referenceNode, indexNode );

		/**
		 * Similar to {@link module:ReferenceNode~ReferenceNode#reference}, an additional
		 * property references to the current node.
		 *
		 * @type {Node}
		 * @default null
		 */
		this.referenceNode = referenceNode;

		/**
		 * This flag can be used for type testing.
		 *
		 * @type {Boolean}
		 * @readonly
		 * @default true
		 */
		this.isReferenceElementNode = true;

	}

	/**
	 * This method is overwritten since the node type is inferred from
	 * the uniform type of the reference node.
	 *
	 * @param {NodeBuilder} builder - The current node builder.
	 * @return {String} The node type.
	 */
	getNodeType() {

		return this.referenceNode.uniformType;

	}

	generate( builder ) {

		const snippet = super.generate( builder );
		const arrayType = this.referenceNode.getNodeType();
		const elementType = this.getNodeType();

		return builder.format( snippet, arrayType, elementType );

	}

}

/**
 * This type of node establishes a reference to a property of another object.
 * In this way, the value of the node is automatically linked to the value of
 * referenced object. Reference nodes internally represent the linked value
 * as a uniform.
 *
 * @augments Node
 */
class ReferenceNode extends Node {

	static get type() {

		return 'ReferenceNode';

	}

	/**
	 * Constructs a new reference node.
	 *
	 * @param {String} property - The name of the property the node refers to.
	 * @param {String} uniformType - The uniform type that should be used to represent the property value.
	 * @param {Object?} [object=null] - The object the property belongs to.
	 * @param {Number?} [count=null] - When the linked property is an array-like, this parameter defines its length.
	 */
	constructor( property, uniformType, object = null, count = null ) {

		super();

		/**
		 * The name of the property the node refers to.
		 *
		 * @type {String}
		 */
		this.property = property;

		/**
		 * The uniform type that should be used to represent the property value.
		 *
		 * @type {String}
		 */
		this.uniformType = uniformType;

		/**
		 * The object the property belongs to.
		 *
		 * @type {Object?}
		 * @default null
		 */
		this.object = object;

		/**
		 * When the linked property is an array, this parameter defines its length.
		 *
		 * @type {Number?}
		 * @default null
		 */
		this.count = count;

		/**
		 * The property name might have dots so nested properties can be referred.
		 * The hierarchy of the names is stored inside this array.
		 *
		 * @type {Array<String>}
		 */
		this.properties = property.split( '.' );

		/**
		 * Points to the current referred object. This property exists next to {@link module:ReferenceNode~ReferenceNode#object}
		 * since the final reference might be updated from calling code.
		 *
		 * @type {Object?}
		 * @default null
		 */
		this.reference = object;

		/**
		 * The uniform node that holds the value of the reference node.
		 *
		 * @type {UniformNode}
		 * @default null
		 */
		this.node = null;

		/**
		 * The uniform group of the internal uniform.
		 *
		 * @type {UniformGroupNode}
		 * @default null
		 */
		this.group = null;

		/**
		 * An optional label of the internal uniform node.
		 *
		 * @type {String?}
		 * @default null
		 */
		this.name = null;

		/**
		 * Overwritten since velocity nodes are updated per object.
		 *
		 * @type {String}
		 * @default 'object'
		 */
		this.updateType = NodeUpdateType.OBJECT;

	}

	/**
	 * When the referred property is array-like, this method can be used
	 * to access elements via an index node.
	 *
	 * @param {IndexNode} indexNode - indexNode.
	 * @return {ReferenceElementNode} A reference to an element.
	 */
	element( indexNode ) {

		return nodeObject( new ReferenceElementNode( this, nodeObject( indexNode ) ) );

	}

	/**
	 * Sets the uniform group for this reference node.
	 *
	 * @param {UniformGroupNode} group - The uniform group to set.
	 * @return {ReferenceNode} A reference to this node.
	 */
	setGroup( group ) {

		this.group = group;

		return this;

	}

	/**
	 * Sets the label for the internal uniform.
	 *
	 * @param {String} name - The label to set.
	 * @return {ReferenceNode} A reference to this node.
	 */
	label( name ) {

		this.name = name;

		return this;

	}

	/**
	 * Sets the node type which automatically defines the internal
	 * uniform type.
	 *
	 * @param {String} uniformType - The type to set.
	 */
	setNodeType( uniformType ) {

		let node = null;

		if ( this.count !== null ) {

			node = buffer( null, uniformType, this.count );

		} else if ( Array.isArray( this.getValueFromReference() ) ) {

			node = uniformArray( null, uniformType );

		} else if ( uniformType === 'texture' ) {

			node = texture( null );

		} else if ( uniformType === 'cubeTexture' ) {

			node = cubeTexture( null );

		} else {

			node = uniform( null, uniformType );

		}

		if ( this.group !== null ) {

			node.setGroup( this.group );

		}

		if ( this.name !== null ) node.label( this.name );

		this.node = node.getSelf();

	}

	/**
	 * This method is overwritten since the node type is inferred from
	 * the type of the reference node.
	 *
	 * @param {NodeBuilder} builder - The current node builder.
	 * @return {String} The node type.
	 */
	getNodeType( builder ) {

		if ( this.node === null ) {

			this.updateReference( builder );
			this.updateValue();

		}

		return this.node.getNodeType( builder );

	}

	/**
	 * Returns the property value from the given referred object.
	 *
	 * @param {Object} [object=this.reference] - The object to retrieve the property value from.
	 * @return {Any} The value.
	 */
	getValueFromReference( object = this.reference ) {

		const { properties } = this;

		let value = object[ properties[ 0 ] ];

		for ( let i = 1; i < properties.length; i ++ ) {

			value = value[ properties[ i ] ];

		}

		return value;

	}

	/**
	 * Allows to update the reference based on the given state. The state is only
	 * evaluated {@link module:ReferenceNode~ReferenceNode#object} is not set.
	 *
	 * @param {(NodeFrame|NodeBuilder)} state - The current state.
	 * @return {Object} The updated reference.
	 */
	updateReference( state ) {

		this.reference = this.object !== null ? this.object : state.object;

		return this.reference;

	}

	/**
	 * The output of the reference node is the internal uniform node.
	 *
	 * @param {NodeBuilder} builder - The current node builder.
	 * @return {UniformNode} The output node.
	 */
	setup( /* builder */ ) {

		this.updateValue();

		return this.node;

	}

	/**
	 * Overwritten to to update the internal uniform value.
	 *
	 * @param {NodeFrame} frame - A reference to the current node frame.
	 */
	update( /*frame*/ ) {

		this.updateValue();

	}

	/**
	 * Retrieves the value from the referred object property and uses it
	 * to updated the internal uniform.
	 */
	updateValue() {

		if ( this.node === null ) this.setNodeType( this.uniformType );

		const value = this.getValueFromReference();

		if ( Array.isArray( value ) ) {

			this.node.array = value;

		} else {

			this.node.value = value;

		}

	}

}

/**
 * TSL function for creating a reference node.
 *
 * @function
 * @param {String} name - The name of the property the node refers to.
 * @param {String} type - The uniform type that should be used to represent the property value.
 * @param {Object} object - The object the property belongs to.
 * @returns {ReferenceNode}
 */
const reference = ( name, type, object ) => nodeObject( new ReferenceNode( name, type, object ) );

/**
 * TSL function for creating a reference node.
 *
 * @function
 * @param {String} name - The name of the property the node refers to.
 * @param {String} type - The uniform type that should be used to represent the property value.
 * @param {Number} count - The number of value inside the array-like object.
 * @param {Object} object - An array-like object the property belongs to.
 * @returns {ReferenceNode}
 */
const referenceBuffer = ( name, type, count, object ) => nodeObject( new ReferenceNode( name, type, object, count ) );

class MaterialReferenceNode extends ReferenceNode {

	static get type() {

		return 'MaterialReferenceNode';

	}

	constructor( property, inputType, material = null ) {

		super( property, inputType, material );

		this.material = material;

		//this.updateType = NodeUpdateType.RENDER;

		this.isMaterialReferenceNode = true;

	}

	/*setNodeType( node ) {

		super.setNodeType( node );

		this.node.groupNode = renderGroup;

	}*/

	updateReference( state ) {

		this.reference = this.material !== null ? this.material : state.material;

		return this.reference;

	}

}

const materialReference = ( name, type, material ) => nodeObject( new MaterialReferenceNode( name, type, material ) );

/** @module Tangent **/

/**
 * TSL object that represents the tangent attribute of the current rendered object.
 *
 * @type {Node<vec4>}
 */
const tangentGeometry = /*@__PURE__*/ Fn( ( builder ) => {

	if ( builder.geometry.hasAttribute( 'tangent' ) === false ) {

		builder.geometry.computeTangents();

	}

	return attribute( 'tangent', 'vec4' );

} )();

/**
 * TSL object that represents the vertex tangent in local space of the current rendered object.
 *
 * @type {Node<vec4>}
 */
const tangentLocal = /*@__PURE__*/ tangentGeometry.xyz.toVar( 'tangentLocal' );

/**
 * TSL object that represents the vertex tangent in view space of the current rendered object.
 *
 * @type {Node<vec4>}
 */
const tangentView = /*@__PURE__*/ modelViewMatrix.mul( vec4( tangentLocal, 0 ) ).xyz.varying( 'v_tangentView' ).normalize().toVar( 'tangentView' );

/**
 * TSL object that represents the vertex tangent in world space of the current rendered object.
 *
 * @type {Node<vec4>}
 */
const tangentWorld = /*@__PURE__*/ tangentView.transformDirection( cameraViewMatrix ).varying( 'v_tangentWorld' ).normalize().toVar( 'tangentWorld' );

/**
 * TSL object that represents the transformed vertex tangent in view space of the current rendered object.
 *
 * @type {Node<vec4>}
 */
const transformedTangentView = /*@__PURE__*/ tangentView.toVar( 'transformedTangentView' );

/**
 * TSL object that represents the transformed vertex tangent in world space of the current rendered object.
 *
 * @type {Node<vec4>}
 */
const transformedTangentWorld = /*@__PURE__*/ transformedTangentView.transformDirection( cameraViewMatrix ).normalize().toVar( 'transformedTangentWorld' );

const getBitangent = ( crossNormalTangent ) => crossNormalTangent.mul( tangentGeometry.w ).xyz;

const bitangentGeometry = /*@__PURE__*/ varying( getBitangent( normalGeometry.cross( tangentGeometry ) ), 'v_bitangentGeometry' ).normalize().toVar( 'bitangentGeometry' );
const bitangentLocal = /*@__PURE__*/ varying( getBitangent( normalLocal.cross( tangentLocal ) ), 'v_bitangentLocal' ).normalize().toVar( 'bitangentLocal' );
const bitangentView = /*@__PURE__*/ varying( getBitangent( normalView.cross( tangentView ) ), 'v_bitangentView' ).normalize().toVar( 'bitangentView' );
const bitangentWorld = /*@__PURE__*/ varying( getBitangent( normalWorld.cross( tangentWorld ) ), 'v_bitangentWorld' ).normalize().toVar( 'bitangentWorld' );
const transformedBitangentView = /*@__PURE__*/ getBitangent( transformedNormalView.cross( transformedTangentView ) ).normalize().toVar( 'transformedBitangentView' );
const transformedBitangentWorld = /*@__PURE__*/ transformedBitangentView.transformDirection( cameraViewMatrix ).normalize().toVar( 'transformedBitangentWorld' );

const TBNViewMatrix = /*@__PURE__*/ mat3( tangentView, bitangentView, normalView );

const parallaxDirection = /*@__PURE__*/ positionViewDirection.mul( TBNViewMatrix )/*.normalize()*/;
const parallaxUV = ( uv, scale ) => uv.sub( parallaxDirection.mul( scale ) );

const transformedBentNormalView = /*@__PURE__*/ ( () => {

	// https://google.github.io/filament/Filament.md.html#lighting/imagebasedlights/anisotropy

	let bentNormal = anisotropyB.cross( positionViewDirection );
	bentNormal = bentNormal.cross( anisotropyB ).normalize();
	bentNormal = mix( bentNormal, transformedNormalView, anisotropy.mul( roughness.oneMinus() ).oneMinus().pow2().pow2() ).normalize();

	return bentNormal;


} )();

/** @module NormalMapNode **/

// Normal Mapping Without Precomputed Tangents
// http://www.thetenthplanet.de/archives/1180

const perturbNormal2Arb = /*@__PURE__*/ Fn( ( inputs ) => {

	const { eye_pos, surf_norm, mapN, uv } = inputs;

	const q0 = eye_pos.dFdx();
	const q1 = eye_pos.dFdy();
	const st0 = uv.dFdx();
	const st1 = uv.dFdy();

	const N = surf_norm; // normalized

	const q1perp = q1.cross( N );
	const q0perp = N.cross( q0 );

	const T = q1perp.mul( st0.x ).add( q0perp.mul( st1.x ) );
	const B = q1perp.mul( st0.y ).add( q0perp.mul( st1.y ) );

	const det = T.dot( T ).max( B.dot( B ) );
	const scale = faceDirection.mul( det.inverseSqrt() );

	return add( T.mul( mapN.x, scale ), B.mul( mapN.y, scale ), N.mul( mapN.z ) ).normalize();

} );

/**
 * This class can be used for applying normals maps to materials.
 *
 * ```js
 * material.normalNode = normalMap( texture( normalTex ) );
 * ```
 *
 * @augments TempNode
 */
class NormalMapNode extends TempNode {

	static get type() {

		return 'NormalMapNode';

	}

	/**
	 * Constructs a new normal map node.
	 *
	 * @param {Node} node - Represents the normal map data.
	 * @param {Node?} [scaleNode=null] - Controls the intensity of the effect.
	 */
	constructor( node, scaleNode = null ) {

		super( 'vec3' );

		/**
		 * Represents the normal map data.
		 *
		 * @type {Node}
		 */
		this.node = node;

		/**
		 * Controls the intensity of the effect.
		 *
		 * @type {Node?}
		 * @default null
		 */
		this.scaleNode = scaleNode;

		/**
		 * The normal map type.
		 *
		 * @type {(TangentSpaceNormalMap|ObjectSpaceNormalMap)}
		 * @default TangentSpaceNormalMap
		 */
		this.normalMapType = TangentSpaceNormalMap;

	}

	setup( builder ) {

		const { normalMapType, scaleNode } = this;

		let normalMap = this.node.mul( 2.0 ).sub( 1.0 );

		if ( scaleNode !== null ) {

			normalMap = vec3( normalMap.xy.mul( scaleNode ), normalMap.z );

		}

		let outputNode = null;

		if ( normalMapType === ObjectSpaceNormalMap ) {

			outputNode = transformNormalToView( normalMap );

		} else if ( normalMapType === TangentSpaceNormalMap ) {

			const tangent = builder.hasGeometryAttribute( 'tangent' );

			if ( tangent === true ) {

				outputNode = TBNViewMatrix.mul( normalMap ).normalize();

			} else {

				outputNode = perturbNormal2Arb( {
					eye_pos: positionView,
					surf_norm: normalView,
					mapN: normalMap,
					uv: uv()
				} );

			}

		}

		return outputNode;

	}

}

/**
 * TSL function for creating a normal map node.
 *
 * @function
 * @param {Node} node - Represents the normal map data.
 * @param {Node?} [scaleNode=null] - Controls the intensity of the effect.
 * @returns {NormalMapNode}
 */
const normalMap = /*@__PURE__*/ nodeProxy( NormalMapNode );

/** @module BumpMapNode **/

// Bump Mapping Unparametrized Surfaces on the GPU by Morten S. Mikkelsen
// https://mmikk.github.io/papers3d/mm_sfgrad_bump.pdf

const dHdxy_fwd = Fn( ( { textureNode, bumpScale } ) => {

	// It's used to preserve the same TextureNode instance
	const sampleTexture = ( callback ) => textureNode.cache().context( { getUV: ( texNode ) => callback( texNode.uvNode || uv() ), forceUVContext: true } );

	const Hll = float( sampleTexture( ( uvNode ) => uvNode ) );

	return vec2(
		float( sampleTexture( ( uvNode ) => uvNode.add( uvNode.dFdx() ) ) ).sub( Hll ),
		float( sampleTexture( ( uvNode ) => uvNode.add( uvNode.dFdy() ) ) ).sub( Hll )
	).mul( bumpScale );

} );

// Evaluate the derivative of the height w.r.t. screen-space using forward differencing (listing 2)

const perturbNormalArb = Fn( ( inputs ) => {

	const { surf_pos, surf_norm, dHdxy } = inputs;

	// normalize is done to ensure that the bump map looks the same regardless of the texture's scale
	const vSigmaX = surf_pos.dFdx().normalize();
	const vSigmaY = surf_pos.dFdy().normalize();
	const vN = surf_norm; // normalized

	const R1 = vSigmaY.cross( vN );
	const R2 = vN.cross( vSigmaX );

	const fDet = vSigmaX.dot( R1 ).mul( faceDirection );

	const vGrad = fDet.sign().mul( dHdxy.x.mul( R1 ).add( dHdxy.y.mul( R2 ) ) );

	return fDet.abs().mul( surf_norm ).sub( vGrad ).normalize();

} );

/**
 * This class can be used for applying bump maps to materials.
 *
 * ```js
 * material.normalNode = bumpMap( texture( bumpTex ) );
 * ```
 *
 * @augments TempNode
 */
class BumpMapNode extends TempNode {

	static get type() {

		return 'BumpMapNode';

	}

	/**
	 * Constructs a new bump map node.
	 *
	 * @param {Node} textureNode - Represents the bump map data.
	 * @param {Node?} [scaleNode=null] - Controls the intensity of the bump effect.
	 */
	constructor( textureNode, scaleNode = null ) {

		super( 'vec3' );

		/**
		 * Represents the bump map data.
		 *
		 * @type {Node}
		 */
		this.textureNode = textureNode;

		/**
		 * Controls the intensity of the bump effect.
		 *
		 * @type {Node?}
		 * @default null
		 */
		this.scaleNode = scaleNode;

	}

	setup() {

		const bumpScale = this.scaleNode !== null ? this.scaleNode : 1;
		const dHdxy = dHdxy_fwd( { textureNode: this.textureNode, bumpScale } );

		return perturbNormalArb( {
			surf_pos: positionView,
			surf_norm: normalView,
			dHdxy
		} );

	}

}

/**
 * TSL function for creating a bump map node.
 *
 * @function
 * @param {Node} textureNode - Represents the bump map data.
 * @param {Node?} [scaleNode=null] - Controls the intensity of the bump effect.
 * @returns {BumpMapNode}
 */
const bumpMap = /*@__PURE__*/ nodeProxy( BumpMapNode );

const _propertyCache = new Map();

class MaterialNode extends Node {

	static get type() {

		return 'MaterialNode';

	}

	constructor( scope ) {

		super();

		this.scope = scope;

	}

	getCache( property, type ) {

		let node = _propertyCache.get( property );

		if ( node === undefined ) {

			node = materialReference( property, type );

			_propertyCache.set( property, node );

		}

		return node;

	}

	getFloat( property ) {

		return this.getCache( property, 'float' );

	}

	getColor( property ) {

		return this.getCache( property, 'color' );

	}

	getTexture( property ) {

		return this.getCache( property === 'map' ? 'map' : property + 'Map', 'texture' );

	}

	setup( builder ) {

		const material = builder.context.material;
		const scope = this.scope;

		let node = null;

		if ( scope === MaterialNode.COLOR ) {

			const colorNode = material.color !== undefined ? this.getColor( scope ) : vec3();

			if ( material.map && material.map.isTexture === true ) {

				node = colorNode.mul( this.getTexture( 'map' ) );

			} else {

				node = colorNode;

			}

		} else if ( scope === MaterialNode.OPACITY ) {

			const opacityNode = this.getFloat( scope );

			if ( material.alphaMap && material.alphaMap.isTexture === true ) {

				node = opacityNode.mul( this.getTexture( 'alpha' ) );

			} else {

				node = opacityNode;

			}

		} else if ( scope === MaterialNode.SPECULAR_STRENGTH ) {

			if ( material.specularMap && material.specularMap.isTexture === true ) {

				node = this.getTexture( 'specular' ).r;

			} else {

				node = float( 1 );

			}

		} else if ( scope === MaterialNode.SPECULAR_INTENSITY ) {

			const specularIntensity = this.getFloat( scope );

			if ( material.specularMap ) {

				node = specularIntensity.mul( this.getTexture( scope ).a );

			} else {

				node = specularIntensity;

			}

		} else if ( scope === MaterialNode.SPECULAR_COLOR ) {

			const specularColorNode = this.getColor( scope );

			if ( material.specularColorMap && material.specularColorMap.isTexture === true ) {

				node = specularColorNode.mul( this.getTexture( scope ).rgb );

			} else {

				node = specularColorNode;

			}

		} else if ( scope === MaterialNode.ROUGHNESS ) { // TODO: cleanup similar branches

			const roughnessNode = this.getFloat( scope );

			if ( material.roughnessMap && material.roughnessMap.isTexture === true ) {

				node = roughnessNode.mul( this.getTexture( scope ).g );

			} else {

				node = roughnessNode;

			}

		} else if ( scope === MaterialNode.METALNESS ) {

			const metalnessNode = this.getFloat( scope );

			if ( material.metalnessMap && material.metalnessMap.isTexture === true ) {

				node = metalnessNode.mul( this.getTexture( scope ).b );

			} else {

				node = metalnessNode;

			}

		} else if ( scope === MaterialNode.EMISSIVE ) {

			const emissiveIntensityNode = this.getFloat( 'emissiveIntensity' );
			const emissiveNode = this.getColor( scope ).mul( emissiveIntensityNode );

			if ( material.emissiveMap && material.emissiveMap.isTexture === true ) {

				node = emissiveNode.mul( this.getTexture( scope ) );

			} else {

				node = emissiveNode;

			}

		} else if ( scope === MaterialNode.NORMAL ) {

			if ( material.normalMap ) {

				node = normalMap( this.getTexture( 'normal' ), this.getCache( 'normalScale', 'vec2' ) );
				node.normalMapType = material.normalMapType;

			} else if ( material.bumpMap ) {

				node = bumpMap( this.getTexture( 'bump' ).r, this.getFloat( 'bumpScale' ) );

			} else {

				node = normalView;

			}

		} else if ( scope === MaterialNode.CLEARCOAT ) {

			const clearcoatNode = this.getFloat( scope );

			if ( material.clearcoatMap && material.clearcoatMap.isTexture === true ) {

				node = clearcoatNode.mul( this.getTexture( scope ).r );

			} else {

				node = clearcoatNode;

			}

		} else if ( scope === MaterialNode.CLEARCOAT_ROUGHNESS ) {

			const clearcoatRoughnessNode = this.getFloat( scope );

			if ( material.clearcoatRoughnessMap && material.clearcoatRoughnessMap.isTexture === true ) {

				node = clearcoatRoughnessNode.mul( this.getTexture( scope ).r );

			} else {

				node = clearcoatRoughnessNode;

			}

		} else if ( scope === MaterialNode.CLEARCOAT_NORMAL ) {

			if ( material.clearcoatNormalMap ) {

				node = normalMap( this.getTexture( scope ), this.getCache( scope + 'Scale', 'vec2' ) );

			} else {

				node = normalView;

			}

		} else if ( scope === MaterialNode.SHEEN ) {

			const sheenNode = this.getColor( 'sheenColor' ).mul( this.getFloat( 'sheen' ) ); // Move this mul() to CPU

			if ( material.sheenColorMap && material.sheenColorMap.isTexture === true ) {

				node = sheenNode.mul( this.getTexture( 'sheenColor' ).rgb );

			} else {

				node = sheenNode;

			}

		} else if ( scope === MaterialNode.SHEEN_ROUGHNESS ) {

			const sheenRoughnessNode = this.getFloat( scope );

			if ( material.sheenRoughnessMap && material.sheenRoughnessMap.isTexture === true ) {

				node = sheenRoughnessNode.mul( this.getTexture( scope ).a );

			} else {

				node = sheenRoughnessNode;

			}

			node = node.clamp( 0.07, 1.0 );

		} else if ( scope === MaterialNode.ANISOTROPY ) {

			if ( material.anisotropyMap && material.anisotropyMap.isTexture === true ) {

				const anisotropyPolar = this.getTexture( scope );
				const anisotropyMat = mat2( materialAnisotropyVector.x, materialAnisotropyVector.y, materialAnisotropyVector.y.negate(), materialAnisotropyVector.x );

				node = anisotropyMat.mul( anisotropyPolar.rg.mul( 2.0 ).sub( vec2( 1.0 ) ).normalize().mul( anisotropyPolar.b ) );

			} else {

				node = materialAnisotropyVector;

			}

		} else if ( scope === MaterialNode.IRIDESCENCE_THICKNESS ) {

			const iridescenceThicknessMaximum = reference( '1', 'float', material.iridescenceThicknessRange );

			if ( material.iridescenceThicknessMap ) {

				const iridescenceThicknessMinimum = reference( '0', 'float', material.iridescenceThicknessRange );

				node = iridescenceThicknessMaximum.sub( iridescenceThicknessMinimum ).mul( this.getTexture( scope ).g ).add( iridescenceThicknessMinimum );

			} else {

				node = iridescenceThicknessMaximum;

			}

		} else if ( scope === MaterialNode.TRANSMISSION ) {

			const transmissionNode = this.getFloat( scope );

			if ( material.transmissionMap ) {

				node = transmissionNode.mul( this.getTexture( scope ).r );

			} else {

				node = transmissionNode;

			}

		} else if ( scope === MaterialNode.THICKNESS ) {

			const thicknessNode = this.getFloat( scope );

			if ( material.thicknessMap ) {

				node = thicknessNode.mul( this.getTexture( scope ).g );

			} else {

				node = thicknessNode;

			}

		} else if ( scope === MaterialNode.IOR ) {

			node = this.getFloat( scope );

		} else if ( scope === MaterialNode.LIGHT_MAP ) {

			node = this.getTexture( scope ).rgb.mul( this.getFloat( 'lightMapIntensity' ) );

		} else if ( scope === MaterialNode.AO_MAP ) {

			node = this.getTexture( scope ).r.sub( 1.0 ).mul( this.getFloat( 'aoMapIntensity' ) ).add( 1.0 );

		} else {

			const outputType = this.getNodeType( builder );

			node = this.getCache( scope, outputType );

		}

		return node;

	}

}

MaterialNode.ALPHA_TEST = 'alphaTest';
MaterialNode.COLOR = 'color';
MaterialNode.OPACITY = 'opacity';
MaterialNode.SHININESS = 'shininess';
MaterialNode.SPECULAR = 'specular';
MaterialNode.SPECULAR_STRENGTH = 'specularStrength';
MaterialNode.SPECULAR_INTENSITY = 'specularIntensity';
MaterialNode.SPECULAR_COLOR = 'specularColor';
MaterialNode.REFLECTIVITY = 'reflectivity';
MaterialNode.ROUGHNESS = 'roughness';
MaterialNode.METALNESS = 'metalness';
MaterialNode.NORMAL = 'normal';
MaterialNode.CLEARCOAT = 'clearcoat';
MaterialNode.CLEARCOAT_ROUGHNESS = 'clearcoatRoughness';
MaterialNode.CLEARCOAT_NORMAL = 'clearcoatNormal';
MaterialNode.EMISSIVE = 'emissive';
MaterialNode.ROTATION = 'rotation';
MaterialNode.SHEEN = 'sheen';
MaterialNode.SHEEN_ROUGHNESS = 'sheenRoughness';
MaterialNode.ANISOTROPY = 'anisotropy';
MaterialNode.IRIDESCENCE = 'iridescence';
MaterialNode.IRIDESCENCE_IOR = 'iridescenceIOR';
MaterialNode.IRIDESCENCE_THICKNESS = 'iridescenceThickness';
MaterialNode.IOR = 'ior';
MaterialNode.TRANSMISSION = 'transmission';
MaterialNode.THICKNESS = 'thickness';
MaterialNode.ATTENUATION_DISTANCE = 'attenuationDistance';
MaterialNode.ATTENUATION_COLOR = 'attenuationColor';
MaterialNode.LINE_SCALE = 'scale';
MaterialNode.LINE_DASH_SIZE = 'dashSize';
MaterialNode.LINE_GAP_SIZE = 'gapSize';
MaterialNode.LINE_WIDTH = 'linewidth';
MaterialNode.LINE_DASH_OFFSET = 'dashOffset';
MaterialNode.POINT_WIDTH = 'pointWidth';
MaterialNode.DISPERSION = 'dispersion';
MaterialNode.LIGHT_MAP = 'light';
MaterialNode.AO_MAP = 'ao';

const materialAlphaTest = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.ALPHA_TEST );
const materialColor = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.COLOR );
const materialShininess = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.SHININESS );
const materialEmissive = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.EMISSIVE );
const materialOpacity = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.OPACITY );
const materialSpecular = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.SPECULAR );

const materialSpecularIntensity = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.SPECULAR_INTENSITY );
const materialSpecularColor = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.SPECULAR_COLOR );

const materialSpecularStrength = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.SPECULAR_STRENGTH );
const materialReflectivity = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.REFLECTIVITY );
const materialRoughness = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.ROUGHNESS );
const materialMetalness = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.METALNESS );
const materialNormal = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.NORMAL ).context( { getUV: null } );
const materialClearcoat = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.CLEARCOAT );
const materialClearcoatRoughness = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.CLEARCOAT_ROUGHNESS );
const materialClearcoatNormal = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.CLEARCOAT_NORMAL ).context( { getUV: null } );
const materialRotation = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.ROTATION );
const materialSheen = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.SHEEN );
const materialSheenRoughness = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.SHEEN_ROUGHNESS );
const materialAnisotropy = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.ANISOTROPY );
const materialIridescence = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.IRIDESCENCE );
const materialIridescenceIOR = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.IRIDESCENCE_IOR );
const materialIridescenceThickness = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.IRIDESCENCE_THICKNESS );
const materialTransmission = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.TRANSMISSION );
const materialThickness = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.THICKNESS );
const materialIOR = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.IOR );
const materialAttenuationDistance = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.ATTENUATION_DISTANCE );
const materialAttenuationColor = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.ATTENUATION_COLOR );
const materialLineScale = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.LINE_SCALE );
const materialLineDashSize = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.LINE_DASH_SIZE );
const materialLineGapSize = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.LINE_GAP_SIZE );
const materialLineWidth = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.LINE_WIDTH );
const materialLineDashOffset = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.LINE_DASH_OFFSET );
const materialPointWidth = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.POINT_WIDTH );
const materialDispersion = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.DISPERSION );
const materialLightMap = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.LIGHT_MAP );
const materialAOMap = /*@__PURE__*/ nodeImmutable( MaterialNode, MaterialNode.AO_MAP );
const materialAnisotropyVector = /*@__PURE__*/ uniform( new Vector2() ).onReference( function ( frame ) {

	return frame.material;

} ).onRenderUpdate( function ( { material } ) {

	this.value.set( material.anisotropy * Math.cos( material.anisotropyRotation ), material.anisotropy * Math.sin( material.anisotropyRotation ) );

} );

const modelViewProjection = /*@__PURE__*/ cameraProjectionMatrix.mul( positionView ).varying( 'v_modelViewProjection' );

/** @module IndexNode **/

/**
 * This class represents shader indices of different types. The following predefined node
 * objects cover frequent use cases:
 *
 * - `vertexIndex`: The index of a vertex within a mesh.
 * - `instanceIndex`: The index of either a mesh instance or an invocation of a compute shader.
 * - `drawIndex`: The index of a draw call.
 * - `invocationLocalIndex`: The index of a compute invocation within the scope of a workgroup load.
 * - `invocationSubgroupIndex`: The index of a compute invocation within the scope of a subgroup.
 * - `subgroupIndex`: The index of the subgroup the current compute invocation belongs to.
 *
 * @augments Node
 */
class IndexNode extends Node {

	static get type() {

		return 'IndexNode';

	}

	/**
	 * Constructs a new index node.
	 *
	 * @param {('vertex'|'instance'|'subgroup'|'invocationLocal'|'invocationSubgroup'|'draw')} scope - The scope of the index node.
	 */
	constructor( scope ) {

		super( 'uint' );

		/**
		 * The scope of the index node.
		 *
		 * @type {String}
		 */
		this.scope = scope;

		/**
		 * This flag can be used for type testing.
		 *
		 * @type {Boolean}
		 * @readonly
		 * @default true
		 */
		this.isIndexNode = true;

	}

	generate( builder ) {

		const nodeType = this.getNodeType( builder );
		const scope = this.scope;

		let propertyName;

		if ( scope === IndexNode.VERTEX ) {

			propertyName = builder.getVertexIndex();

		} else if ( scope === IndexNode.INSTANCE ) {

			propertyName = builder.getInstanceIndex();

		} else if ( scope === IndexNode.DRAW ) {

			propertyName = builder.getDrawIndex();

		} else if ( scope === IndexNode.INVOCATION_LOCAL ) {

			propertyName = builder.getInvocationLocalIndex();

		} else if ( scope === IndexNode.INVOCATION_SUBGROUP ) {

			propertyName = builder.getInvocationSubgroupIndex();

		} else if ( scope === IndexNode.SUBGROUP ) {

			propertyName = builder.getSubgroupIndex();

		} else {

			throw new Error( 'THREE.IndexNode: Unknown scope: ' + scope );

		}

		let output;

		if ( builder.shaderStage === 'vertex' || builder.shaderStage === 'compute' ) {

			output = propertyName;

		} else {

			const nodeVarying = varying( this );

			output = nodeVarying.build( builder, nodeType );

		}

		return output;

	}

}

IndexNode.VERTEX = 'vertex';
IndexNode.INSTANCE = 'instance';
IndexNode.SUBGROUP = 'subgroup';
IndexNode.INVOCATION_LOCAL = 'invocationLocal';
IndexNode.INVOCATION_SUBGROUP = 'invocationSubgroup';
IndexNode.DRAW = 'draw';

/**
 * TSL object that represents the index of a vertex within a mesh.
 *
 * @type {IndexNode}
 */
const vertexIndex = /*@__PURE__*/ nodeImmutable( IndexNode, IndexNode.VERTEX );

/**
 * TSL object that represents the index of either a mesh instance or an invocation of a compute shader.
 *
 * @type {IndexNode}
 */
const instanceIndex = /*@__PURE__*/ nodeImmutable( IndexNode, IndexNode.INSTANCE );

/**
 * TSL object that represents the index of the subgroup the current compute invocation belongs to.
 *
 * @type {IndexNode}
 */
const subgroupIndex = /*@__PURE__*/ nodeImmutable( IndexNode, IndexNode.SUBGROUP );

/**
 * TSL object that represents the index of a compute invocation within the scope of a subgroup.
 *
 * @type {IndexNode}
 */
const invocationSubgroupIndex = /*@__PURE__*/ nodeImmutable( IndexNode, IndexNode.INVOCATION_SUBGROUP );

/**
 * TSL object that represents the index of a compute invocation within the scope of a workgroup load.
 *
 * @type {IndexNode}
 */
const invocationLocalIndex = /*@__PURE__*/ nodeImmutable( IndexNode, IndexNode.INVOCATION_LOCAL );

/**
 * TSL object that represents the index of a draw call.
 *
 * @type {IndexNode}
 */
const drawIndex = /*@__PURE__*/ nodeImmutable( IndexNode, IndexNode.DRAW );

class InstanceNode extends Node {

	static get type() {

		return 'InstanceNode';

	}

	constructor( count, instanceMatrix, instanceColor ) {

		super( 'void' );

		this.count = count;
		this.instanceMatrix = instanceMatrix;
		this.instanceColor = instanceColor;

		this.instanceMatrixNode = null;

		this.instanceColorNode = null;

		this.updateType = NodeUpdateType.FRAME;

		this.buffer = null;
		this.bufferColor = null;

	}

	setup( builder ) {

		const { count, instanceMatrix, instanceColor } = this;

		let { instanceMatrixNode, instanceColorNode } = this;

		if ( instanceMatrixNode === null ) {

			// Both WebGPU and WebGL backends have UBO max limited to 64kb. Matrix count number bigger than 1000 ( 16 * 4 * 1000 = 64kb ) will fallback to attribute.

			if ( count <= 1000 ) {

				instanceMatrixNode = buffer( instanceMatrix.array, 'mat4', Math.max( count, 1 ) ).element( instanceIndex );

			} else {

				const buffer = new InstancedInterleavedBuffer( instanceMatrix.array, 16, 1 );

				this.buffer = buffer;

				const bufferFn = instanceMatrix.usage === DynamicDrawUsage ? instancedDynamicBufferAttribute : instancedBufferAttribute;

				const instanceBuffers = [
					// F.Signature -> bufferAttribute( array, type, stride, offset )
					bufferFn( buffer, 'vec4', 16, 0 ),
					bufferFn( buffer, 'vec4', 16, 4 ),
					bufferFn( buffer, 'vec4', 16, 8 ),
					bufferFn( buffer, 'vec4', 16, 12 )
				];

				instanceMatrixNode = mat4( ...instanceBuffers );

			}

			this.instanceMatrixNode = instanceMatrixNode;

		}

		if ( instanceColor && instanceColorNode === null ) {

			const buffer = new InstancedBufferAttribute( instanceColor.array, 3 );

			const bufferFn = instanceColor.usage === DynamicDrawUsage ? instancedDynamicBufferAttribute : instancedBufferAttribute;

			this.bufferColor = buffer;

			instanceColorNode = vec3( bufferFn( buffer, 'vec3', 3, 0 ) );

			this.instanceColorNode = instanceColorNode;

		}

		// POSITION

		const instancePosition = instanceMatrixNode.mul( positionLocal ).xyz;
		positionLocal.assign( instancePosition );

		// NORMAL

		if ( builder.hasGeometryAttribute( 'normal' ) ) {

			const instanceNormal = transformNormal( normalLocal, instanceMatrixNode );

			// ASSIGNS

			normalLocal.assign( instanceNormal );

		}

		// COLOR

		if ( this.instanceColorNode !== null ) {

			varyingProperty( 'vec3', 'vInstanceColor' ).assign( this.instanceColorNode );

		}

	}

	update( /*frame*/ ) {

		if ( this.instanceMatrix.usage !== DynamicDrawUsage && this.buffer !== null && this.instanceMatrix.version !== this.buffer.version ) {

			this.buffer.version = this.instanceMatrix.version;

		}

		if ( this.instanceColor && this.instanceColor.usage !== DynamicDrawUsage && this.bufferColor !== null && this.instanceColor.version !== this.bufferColor.version ) {

			this.bufferColor.version = this.instanceColor.version;

		}

	}

}

const instance = /*@__PURE__*/ nodeProxy( InstanceNode );

class InstancedMeshNode extends InstanceNode {

	static get type() {

		return 'InstancedMeshNode';

	}

	constructor( instanceMesh ) {

		const { count, instanceMatrix, instanceColor } = instanceMesh;

		super( count, instanceMatrix, instanceColor );

		this.instanceMesh = instanceMesh;

	}

}

const instancedMesh = /*@__PURE__*/ nodeProxy( InstancedMeshNode );

class BatchNode extends Node {

	static get type() {

		return 'BatchNode';

	}

	constructor( batchMesh ) {

		super( 'void' );

		this.batchMesh = batchMesh;


		this.batchingIdNode = null;

	}

	setup( builder ) {

		// POSITION

		if ( this.batchingIdNode === null ) {

			if ( builder.getDrawIndex() === null ) {

				this.batchingIdNode = instanceIndex;

			} else {

				this.batchingIdNode = drawIndex;

			}

		}

		const getIndirectIndex = Fn( ( [ id ] ) => {

			const size = textureSize( textureLoad( this.batchMesh._indirectTexture ), 0 );
			const x = int( id ).modInt( int( size ) );
			const y = int( id ).div( int( size ) );
			return textureLoad( this.batchMesh._indirectTexture, ivec2( x, y ) ).x;

		} ).setLayout( {
			name: 'getIndirectIndex',
			type: 'uint',
			inputs: [
				{ name: 'id', type: 'int' }
			]
		} );

		const indirectId = getIndirectIndex( int( this.batchingIdNode ) );

		const matricesTexture = this.batchMesh._matricesTexture;

		const size = textureSize( textureLoad( matricesTexture ), 0 );
		const j = float( indirectId ).mul( 4 ).toInt().toVar();

		const x = j.modInt( size );
		const y = j.div( int( size ) );
		const batchingMatrix = mat4(
			textureLoad( matricesTexture, ivec2( x, y ) ),
			textureLoad( matricesTexture, ivec2( x.add( 1 ), y ) ),
			textureLoad( matricesTexture, ivec2( x.add( 2 ), y ) ),
			textureLoad( matricesTexture, ivec2( x.add( 3 ), y ) )
		);


		const colorsTexture = this.batchMesh._colorsTexture;

		if ( colorsTexture !== null ) {

			const getBatchingColor = Fn( ( [ id ] ) => {

				const size = textureSize( textureLoad( colorsTexture ), 0 ).x;
				const j = id;
				const x = j.modInt( size );
				const y = j.div( size );
				return textureLoad( colorsTexture, ivec2( x, y ) ).rgb;

			} ).setLayout( {
				name: 'getBatchingColor',
				type: 'vec3',
				inputs: [
					{ name: 'id', type: 'int' }
				]
			} );

			const color = getBatchingColor( indirectId );

			varyingProperty( 'vec3', 'vBatchColor' ).assign( color );

		}

		const bm = mat3( batchingMatrix );

		positionLocal.assign( batchingMatrix.mul( positionLocal ) );

		const transformedNormal = normalLocal.div( vec3( bm[ 0 ].dot( bm[ 0 ] ), bm[ 1 ].dot( bm[ 1 ] ), bm[ 2 ].dot( bm[ 2 ] ) ) );

		const batchingNormal = bm.mul( transformedNormal ).xyz;

		normalLocal.assign( batchingNormal );

		if ( builder.hasGeometryAttribute( 'tangent' ) ) {

			tangentLocal.mulAssign( bm );

		}

	}

}

const batch = /*@__PURE__*/ nodeProxy( BatchNode );

const _frameId = new WeakMap();

class SkinningNode extends Node {

	static get type() {

		return 'SkinningNode';

	}

	constructor( skinnedMesh, useReference = false ) {

		super( 'void' );

		this.skinnedMesh = skinnedMesh;
		this.useReference = useReference;

		this.updateType = NodeUpdateType.OBJECT;

		//

		this.skinIndexNode = attribute( 'skinIndex', 'uvec4' );
		this.skinWeightNode = attribute( 'skinWeight', 'vec4' );

		let bindMatrixNode, bindMatrixInverseNode, boneMatricesNode;

		if ( useReference ) {

			bindMatrixNode = reference( 'bindMatrix', 'mat4' );
			bindMatrixInverseNode = reference( 'bindMatrixInverse', 'mat4' );
			boneMatricesNode = referenceBuffer( 'skeleton.boneMatrices', 'mat4', skinnedMesh.skeleton.bones.length );

		} else {

			bindMatrixNode = uniform( skinnedMesh.bindMatrix, 'mat4' );
			bindMatrixInverseNode = uniform( skinnedMesh.bindMatrixInverse, 'mat4' );
			boneMatricesNode = buffer( skinnedMesh.skeleton.boneMatrices, 'mat4', skinnedMesh.skeleton.bones.length );

		}

		this.bindMatrixNode = bindMatrixNode;
		this.bindMatrixInverseNode = bindMatrixInverseNode;
		this.boneMatricesNode = boneMatricesNode;
		this.previousBoneMatricesNode = null;

	}

	getSkinnedPosition( boneMatrices = this.boneMatricesNode, position = positionLocal ) {

		const { skinIndexNode, skinWeightNode, bindMatrixNode, bindMatrixInverseNode } = this;

		const boneMatX = boneMatrices.element( skinIndexNode.x );
		const boneMatY = boneMatrices.element( skinIndexNode.y );
		const boneMatZ = boneMatrices.element( skinIndexNode.z );
		const boneMatW = boneMatrices.element( skinIndexNode.w );

		// POSITION

		const skinVertex = bindMatrixNode.mul( position );

		const skinned = add(
			boneMatX.mul( skinWeightNode.x ).mul( skinVertex ),
			boneMatY.mul( skinWeightNode.y ).mul( skinVertex ),
			boneMatZ.mul( skinWeightNode.z ).mul( skinVertex ),
			boneMatW.mul( skinWeightNode.w ).mul( skinVertex )
		);

		return bindMatrixInverseNode.mul( skinned ).xyz;

	}

	getSkinnedNormal( boneMatrices = this.boneMatricesNode, normal = normalLocal ) {

		const { skinIndexNode, skinWeightNode, bindMatrixNode, bindMatrixInverseNode } = this;

		const boneMatX = boneMatrices.element( skinIndexNode.x );
		const boneMatY = boneMatrices.element( skinIndexNode.y );
		const boneMatZ = boneMatrices.element( skinIndexNode.z );
		const boneMatW = boneMatrices.element( skinIndexNode.w );

		// NORMAL

		let skinMatrix = add(
			skinWeightNode.x.mul( boneMatX ),
			skinWeightNode.y.mul( boneMatY ),
			skinWeightNode.z.mul( boneMatZ ),
			skinWeightNode.w.mul( boneMatW )
		);

		skinMatrix = bindMatrixInverseNode.mul( skinMatrix ).mul( bindMatrixNode );

		return skinMatrix.transformDirection( normal ).xyz;

	}

	getPreviousSkinnedPosition( builder ) {

		const skinnedMesh = builder.object;

		if ( this.previousBoneMatricesNode === null ) {

			skinnedMesh.skeleton.previousBoneMatrices = new Float32Array( skinnedMesh.skeleton.boneMatrices );

			this.previousBoneMatricesNode = referenceBuffer( 'skeleton.previousBoneMatrices', 'mat4', skinnedMesh.skeleton.bones.length );

		}

		return this.getSkinnedPosition( this.previousBoneMatricesNode, positionPrevious );

	}

	needsPreviousBoneMatrices( builder ) {

		const mrt = builder.renderer.getMRT();

		return mrt && mrt.has( 'velocity' );

	}

	setup( builder ) {

		if ( this.needsPreviousBoneMatrices( builder ) ) {

			positionPrevious.assign( this.getPreviousSkinnedPosition( builder ) );

		}

		const skinPosition = this.getSkinnedPosition();


		positionLocal.assign( skinPosition );

		if ( builder.hasGeometryAttribute( 'normal' ) ) {

			const skinNormal = this.getSkinnedNormal();

			normalLocal.assign( skinNormal );

			if ( builder.hasGeometryAttribute( 'tangent' ) ) {

				tangentLocal.assign( skinNormal );

			}

		}

	}

	generate( builder, output ) {

		if ( output !== 'void' ) {

			return positionLocal.build( builder, output );

		}

	}

	update( frame ) {

		const object = this.useReference ? frame.object : this.skinnedMesh;
		const skeleton = object.skeleton;

		if ( _frameId.get( skeleton ) === frame.frameId ) return;

		_frameId.set( skeleton, frame.frameId );

		if ( this.previousBoneMatricesNode !== null ) skeleton.previousBoneMatrices.set( skeleton.boneMatrices );

		skeleton.update();

	}

}

const skinning = ( skinnedMesh ) => nodeObject( new SkinningNode( skinnedMesh ) );
const skinningReference = ( skinnedMesh ) => nodeObject( new SkinningNode( skinnedMesh, true ) );

/** @module LoopNode **/

/**
 * This module offers a variety of ways to implement loops in TSL. In it's basic form it's:
 * ```js
 * Loop( count, ( { i } ) => {
 *
 * } );
 * ```
 * However, it is also possible to define a start and end ranges, data types and loop conditions:
 * ```js
 * Loop( { start: int( 0 ), end: int( 10 ), type: 'int', condition: '<' }, ( { i } ) => {
 *
 * } );
 *```
 * Nested loops can be defined in a compacted form:
 * ```js
 * Loop( 10, 5, ( { i, j } ) => {
 *
 * } );
 * ```
 * Loops that should run backwards can be defined like so:
 * ```js
 * Loop( { start: 10 }, () => {} );
 * ```
 * The module also provides `Break()` and `Continue()` TSL expression for loop control.
 * @augments Node
 */
class LoopNode extends Node {

	static get type() {

		return 'LoopNode';

	}

	/**
	 * Constructs a new loop node.
	 *
	 * @param {Array<Any>} params - Depending on the loop type, array holds different parameterization values for the loop.
	 */
	constructor( params = [] ) {

		super();

		this.params = params;

	}

	/**
	 * Returns a loop variable name based on an index. The pattern is
	 * `0` = `i`, `1`= `j`, `2`= `k` and so on.
	 *
	 * @param {Number} index - The index.
	 * @return {String} The loop variable name.
	 */
	getVarName( index ) {

		return String.fromCharCode( 'i'.charCodeAt( 0 ) + index );

	}

	/**
	 * Returns properties about this node.
	 *
	 * @param {NodeBuilder} builder - The current node builder.
	 * @return {Object} The node properties.
	 */
	getProperties( builder ) {

		const properties = builder.getNodeProperties( this );

		if ( properties.stackNode !== undefined ) return properties;

		//

		const inputs = {};

		for ( let i = 0, l = this.params.length - 1; i < l; i ++ ) {

			const param = this.params[ i ];

			const name = ( param.isNode !== true && param.name ) || this.getVarName( i );
			const type = ( param.isNode !== true && param.type ) || 'int';

			inputs[ name ] = expression( name, type );

		}

		const stack = builder.addStack(); // TODO: cache() it

		properties.returnsNode = this.params[ this.params.length - 1 ]( inputs, stack, builder );
		properties.stackNode = stack;

		builder.removeStack();

		return properties;

	}

	/**
	 * This method is overwritten since the node type is inferred based on the loop configuration.
	 *
	 * @param {NodeBuilder} builder - The current node builder.
	 * @return {String} The node type.
	 */
	getNodeType( builder ) {

		const { returnsNode } = this.getProperties( builder );

		return returnsNode ? returnsNode.getNodeType( builder ) : 'void';

	}

	setup( builder ) {

		// setup properties

		this.getProperties( builder );

	}

	generate( builder ) {

		const properties = this.getProperties( builder );

		const params = this.params;
		const stackNode = properties.stackNode;

		for ( let i = 0, l = params.length - 1; i < l; i ++ ) {

			const param = params[ i ];

			let start = null, end = null, name = null, type = null, condition = null, update = null;

			if ( param.isNode ) {

				type = 'int';
				name = this.getVarName( i );
				start = '0';
				end = param.build( builder, type );
				condition = '<';

			} else {

				type = param.type || 'int';
				name = param.name || this.getVarName( i );
				start = param.start;
				end = param.end;
				condition = param.condition;
				update = param.update;

				if ( typeof start === 'number' ) start = builder.generateConst( type, start );
				else if ( start && start.isNode ) start = start.build( builder, type );

				if ( typeof end === 'number' ) end = builder.generateConst( type, end );
				else if ( end && end.isNode ) end = end.build( builder, type );

				if ( start !== undefined && end === undefined ) {

					start = start + ' - 1';
					end = '0';
					condition = '>=';

				} else if ( end !== undefined && start === undefined ) {

					start = '0';
					condition = '<';

				}

				if ( condition === undefined ) {

					if ( Number( start ) > Number( end ) ) {

						condition = '>=';

					} else {

						condition = '<';

					}

				}

			}

			const internalParam = { start, end, condition };

			//

			const startSnippet = internalParam.start;
			const endSnippet = internalParam.end;

			let declarationSnippet = '';
			let conditionalSnippet = '';
			let updateSnippet = '';

			if ( ! update ) {

				if ( type === 'int' || type === 'uint' ) {

					if ( condition.includes( '<' ) ) update = '++';
					else update = '--';

				} else {

					if ( condition.includes( '<' ) ) update = '+= 1.';
					else update = '-= 1.';

				}

			}

			declarationSnippet += builder.getVar( type, name ) + ' = ' + startSnippet;

			conditionalSnippet += name + ' ' + condition + ' ' + endSnippet;
			updateSnippet += name + ' ' + update;

			const forSnippet = `for ( ${ declarationSnippet }; ${ conditionalSnippet }; ${ updateSnippet } )`;

			builder.addFlowCode( ( i === 0 ? '\n' : '' ) + builder.tab + forSnippet + ' {\n\n' ).addFlowTab();

		}

		const stackSnippet = stackNode.build( builder, 'void' );

		const returnsSnippet = properties.returnsNode ? properties.returnsNode.build( builder ) : '';

		builder.removeFlowTab().addFlowCode( '\n' + builder.tab + stackSnippet );

		for ( let i = 0, l = this.params.length - 1; i < l; i ++ ) {

			builder.addFlowCode( ( i === 0 ? '' : builder.tab ) + '}\n\n' ).removeFlowTab();

		}

		builder.addFlowTab();

		return returnsSnippet;

	}

}

/**
 * TSL function for creating a loop node.
 *
 * @function
 * @param {...Any} params - A list of parameters.
 * @returns {LoopNode}
 */
const Loop = ( ...params ) => nodeObject( new LoopNode( nodeArray( params, 'int' ) ) ).append();

/**
 * TSL function for creating a `Continue()` expression.
 *
 * @function
 * @returns {ExpressionNode}
 */
const Continue = () => expression( 'continue' ).append();

/**
 * TSL function for creating a `Break()` expression.
 *
 * @function
 * @returns {ExpressionNode}
 */
const Break = () => expression( 'break' ).append();

//

const loop = ( ...params ) => { // @deprecated, r168

	console.warn( 'TSL.LoopNode: loop() has been renamed to Loop().' );
	return Loop( ...params );

};

const _morphTextures = /*@__PURE__*/ new WeakMap();
const _morphVec4 = /*@__PURE__*/ new Vector4();

const getMorph = /*@__PURE__*/ Fn( ( { bufferMap, influence, stride, width, depth, offset } ) => {

	const texelIndex = int( vertexIndex ).mul( stride ).add( offset );

	const y = texelIndex.div( width );
	const x = texelIndex.sub( y.mul( width ) );

	const bufferAttrib = textureLoad( bufferMap, ivec2( x, y ) ).depth( depth );

	return bufferAttrib.mul( influence );

} );

function getEntry( geometry ) {

	const hasMorphPosition = geometry.morphAttributes.position !== undefined;
	const hasMorphNormals = geometry.morphAttributes.normal !== undefined;
	const hasMorphColors = geometry.morphAttributes.color !== undefined;

	// instead of using attributes, the WebGL 2 code path encodes morph targets
	// into an array of data textures. Each layer represents a single morph target.

	const morphAttribute = geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color;
	const morphTargetsCount = ( morphAttribute !== undefined ) ? morphAttribute.length : 0;

	let entry = _morphTextures.get( geometry );

	if ( entry === undefined || entry.count !== morphTargetsCount ) {

		if ( entry !== undefined ) entry.texture.dispose();

		const morphTargets = geometry.morphAttributes.position || [];
		const morphNormals = geometry.morphAttributes.normal || [];
		const morphColors = geometry.morphAttributes.color || [];

		let vertexDataCount = 0;

		if ( hasMorphPosition === true ) vertexDataCount = 1;
		if ( hasMorphNormals === true ) vertexDataCount = 2;
		if ( hasMorphColors === true ) vertexDataCount = 3;

		let width = geometry.attributes.position.count * vertexDataCount;
		let height = 1;

		const maxTextureSize = 4096; // @TODO: Use 'capabilities.maxTextureSize'

		if ( width > maxTextureSize ) {

			height = Math.ceil( width / maxTextureSize );
			width = maxTextureSize;

		}

		const buffer = new Float32Array( width * height * 4 * morphTargetsCount );

		const bufferTexture = new DataArrayTexture( buffer, width, height, morphTargetsCount );
		bufferTexture.type = FloatType;
		bufferTexture.needsUpdate = true;

		// fill buffer

		const vertexDataStride = vertexDataCount * 4;

		for ( let i = 0; i < morphTargetsCount; i ++ ) {

			const morphTarget = morphTargets[ i ];
			const morphNormal = morphNormals[ i ];
			const morphColor = morphColors[ i ];

			const offset = width * height * 4 * i;

			for ( let j = 0; j < morphTarget.count; j ++ ) {

				const stride = j * vertexDataStride;

				if ( hasMorphPosition === true ) {

					_morphVec4.fromBufferAttribute( morphTarget, j );

					buffer[ offset + stride + 0 ] = _morphVec4.x;
					buffer[ offset + stride + 1 ] = _morphVec4.y;
					buffer[ offset + stride + 2 ] = _morphVec4.z;
					buffer[ offset + stride + 3 ] = 0;

				}

				if ( hasMorphNormals === true ) {

					_morphVec4.fromBufferAttribute( morphNormal, j );

					buffer[ offset + stride + 4 ] = _morphVec4.x;
					buffer[ offset + stride + 5 ] = _morphVec4.y;
					buffer[ offset + stride + 6 ] = _morphVec4.z;
					buffer[ offset + stride + 7 ] = 0;

				}

				if ( hasMorphColors === true ) {

					_morphVec4.fromBufferAttribute( morphColor, j );

					buffer[ offset + stride + 8 ] = _morphVec4.x;
					buffer[ offset + stride + 9 ] = _morphVec4.y;
					buffer[ offset + stride + 10 ] = _morphVec4.z;
					buffer[ offset + stride + 11 ] = ( morphColor.itemSize === 4 ) ? _morphVec4.w : 1;

				}

			}

		}

		entry = {
			count: morphTargetsCount,
			texture: bufferTexture,
			stride: vertexDataCount,
			size: new Vector2( width, height )
		};

		_morphTextures.set( geometry, entry );

		function disposeTexture() {

			bufferTexture.dispose();

			_morphTextures.delete( geometry );

			geometry.removeEventListener( 'dispose', disposeTexture );

		}

		geometry.addEventListener( 'dispose', disposeTexture );

	}

	return entry;

}


class MorphNode extends Node {

	static get type() {

		return 'MorphNode';

	}

	constructor( mesh ) {

		super( 'void' );

		this.mesh = mesh;
		this.morphBaseInfluence = uniform( 1 );

		this.updateType = NodeUpdateType.OBJECT;

	}

	setup( builder ) {

		const { geometry } = builder;

		const hasMorphPosition = geometry.morphAttributes.position !== undefined;
		const hasMorphNormals = geometry.hasAttribute( 'normal' ) && geometry.morphAttributes.normal !== undefined;

		const morphAttribute = geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color;
		const morphTargetsCount = ( morphAttribute !== undefined ) ? morphAttribute.length : 0;

		// nodes

		const { texture: bufferMap, stride, size } = getEntry( geometry );

		if ( hasMorphPosition === true ) positionLocal.mulAssign( this.morphBaseInfluence );
		if ( hasMorphNormals === true ) normalLocal.mulAssign( this.morphBaseInfluence );

		const width = int( size.width );

		Loop( morphTargetsCount, ( { i } ) => {

			const influence = float( 0 ).toVar();

			if ( this.mesh.count > 1 && ( this.mesh.morphTexture !== null && this.mesh.morphTexture !== undefined ) ) {

				influence.assign( textureLoad( this.mesh.morphTexture, ivec2( int( i ).add( 1 ), int( instanceIndex ) ) ).r );

			} else {

				influence.assign( reference( 'morphTargetInfluences', 'float' ).element( i ).toVar() );

			}

			if ( hasMorphPosition === true ) {

				positionLocal.addAssign( getMorph( {
					bufferMap,
					influence,
					stride,
					width,
					depth: i,
					offset: int( 0 )
				} ) );

			}

			if ( hasMorphNormals === true ) {

				normalLocal.addAssign( getMorph( {
					bufferMap,
					influence,
					stride,
					width,
					depth: i,
					offset: int( 1 )
				} ) );

			}

		} );

	}

	update() {

		const morphBaseInfluence = this.morphBaseInfluence;

		if ( this.mesh.geometry.morphTargetsRelative ) {

			morphBaseInfluence.value = 1;

		} else {

			morphBaseInfluence.value = 1 - this.mesh.morphTargetInfluences.reduce( ( a, b ) => a + b, 0 );

		}

	}

}

const morphReference = /*@__PURE__*/ nodeProxy( MorphNode );

/**
 * Base class for lighting nodes.
 *
 * @augments Node
 */
class LightingNode extends Node {

	static get type() {

		return 'LightingNode';

	}

	/**
	 * Constructs a new lighting node.
	 */
	constructor() {

		super( 'vec3' );

		/**
		 * This flag can be used for type testing.
		 *
		 * @type {Boolean}
		 * @readonly
		 * @default true
		 */
		this.isLightingNode = true;

	}

}

/**
 * A generic class that can be used by nodes which contribute
 * ambient occlusion to the scene. E.g. an ambient occlusion map
 * node can be used as input for this module. Used in {@link NodeMaterial}.
 *
 * @augments LightingNode
 */
class AONode extends LightingNode {

	static get type() {

		return 'AONode';

	}

	/**
	 * Constructs a new AO node.
	 *
	 * @param {Node<float>?} [aoNode=null] - The ambient occlusion node.
	 */
	constructor( aoNode = null ) {

		super();

		/**
		 * The ambient occlusion node.
		 *
		 * @type {Node<float>?}
		 * @default null
		 */
		this.aoNode = aoNode;

	}

	setup( builder ) {

		builder.context.ambientOcclusion.mulAssign( this.aoNode );

	}

}

/**
 * `LightingContextNode` represents an extension of the {@link module:ContextNode~ContextNode} module
 * by adding lighting specific context data. It represents the runtime context of
 * {@link LightsNode}.
 *
 * @augments ContextNode
 */
class LightingContextNode extends ContextNode {

	static get type() {

		return 'LightingContextNode';

	}

	/**
	 * Constructs a new lighting context node.
	 *
	 * @param {LightsNode} node - The lights node.
	 * @param {LightingModel?} [lightingModel=null] - The current lighting model.
	 * @param {Node<vec3>?} [backdropNode=null] - A backdrop node.
	 * @param {Node<float>?} [backdropAlphaNode=null] - A backdrop alpha node.
	 */
	constructor( node, lightingModel = null, backdropNode = null, backdropAlphaNode = null ) {

		super( node );

		/**
		 * The current lighting model.
		 *
		 * @type {LightingModel?}
		 * @default null
		 */
		this.lightingModel = lightingModel;

		/**
		 * A backdrop node.
		 *
		 * @type {Node<vec3>?}
		 * @default null
		 */
		this.backdropNode = backdropNode;

		/**
		 * A backdrop alpha node.
		 *
		 * @type {Node<float>?}
		 * @default null
		 */
		this.backdropAlphaNode = backdropAlphaNode;

		this._value = null;

	}

	/**
	 * Returns a lighting context object.
	 *
	 * @return {{
	 * radiance: Node<vec3>,
	 * irradiance: Node<vec3>,
	 * iblIrradiance: Node<vec3>,
	 * ambientOcclusion: Node<float>,
	 * reflectedLight: {directDiffuse: Node<vec3>, directSpecular: Node<vec3>, indirectDiffuse: Node<vec3>, indirectSpecular: Node<vec3>},
	 * backdrop: Node<vec3>,
	 * backdropAlpha: Node<float>
	 * }} The lighting context object.
	 */
	getContext() {

		const { backdropNode, backdropAlphaNode } = this;

		const directDiffuse = vec3().toVar( 'directDiffuse' ),
			directSpecular = vec3().toVar( 'directSpecular' ),
			indirectDiffuse = vec3().toVar( 'indirectDiffuse' ),
			indirectSpecular = vec3().toVar( 'indirectSpecular' );

		const reflectedLight = {
			directDiffuse,
			directSpecular,
			indirectDiffuse,
			indirectSpecular
		};

		const context = {
			radiance: vec3().toVar( 'radiance' ),
			irradiance: vec3().toVar( 'irradiance' ),
			iblIrradiance: vec3().toVar( 'iblIrradiance' ),
			ambientOcclusion: float( 1 ).toVar( 'ambientOcclusion' ),
			reflectedLight,
			backdrop: backdropNode,
			backdropAlpha: backdropAlphaNode
		};

		return context;

	}

	setup( builder ) {

		this.value = this._value || ( this._value = this.getContext() );
		this.value.lightingModel = this.lightingModel || builder.context.lightingModel;

		return super.setup( builder );

	}

}

const lightingContext = /*@__PURE__*/ nodeProxy( LightingContextNode );

/**
 * A generic class that can be used by nodes which contribute
 * irradiance to the scene. E.g. a light map node can be used
 * as input for this module. Used in {@link NodeMaterial}.
 *
 * @augments LightingNode
 */
class IrradianceNode extends LightingNode {

	static get type() {

		return 'IrradianceNode';

	}

	/**
	 * Constructs a new irradiance node.
	 *
	 * @param {Node<vec3>} node - A node contributing irradiance.
	 */
	constructor( node ) {

		super();

		/**
		 * A node contributing irradiance.
		 *
		 * @type {Node<vec3>}
		 */
		this.node = node;

	}

	setup( builder ) {

		builder.context.irradiance.addAssign( this.node );

	}

}

/** @module ScreenNode **/

let screenSizeVec, viewportVec;

/**
 * This node provides a collection of screen related metrics.
 * Depending on {@link module:ScreenNode~ScreenNode#scope}, the nodes can represent
 * resolution or viewport data as well as fragment or uv coordinates.
 *
 * @augments Node
 */
class ScreenNode extends Node {

	static get type() {

		return 'ScreenNode';

	}

	/**
	 * Constructs a new screen node.
	 *
	 * @param {('coordinate'|'viewport'|'size'|'uv')} scope - The node's scope.
	 */
	constructor( scope ) {

		super();

		/**
		 * The node represents different metric depending on which scope is selected.
		 *
		 * - `ScreenNode.COORDINATE`: Window-relative coordinates of the current fragment according to WebGPU standards.
		 * - `ScreenNode.VIEWPORT`: The current viewport defined as a four-dimensional vector.
		 * - `ScreenNode.SIZE`: The dimensions of the current bound framebuffer.
		 * - `ScreenNode.UV`: Normalized coordinates.
		 *
		 * @type {('coordinate'|'viewport'|'size'|'uv')}
		 */
		this.scope = scope;

		/**
		 * This flag can be used for type testing.
		 *
		 * @type {Boolean}
		 * @readonly
		 * @default true
		 */
		this.isViewportNode = true;

	}

	/**
	 * This method is overwritten since the node type depends on the selected scope.
	 *
	 * @return {('vec2'|'vec4')} The node type.
	 */
	getNodeType() {

		if ( this.scope === ScreenNode.VIEWPORT ) return 'vec4';
		else return 'vec2';

	}

	/**
	 * This method is overwritten since the node's update type depends on the selected scope.
	 *
	 * @return {NodeUpdateType} The update type.
	 */
	getUpdateType() {

		let updateType = NodeUpdateType.NONE;

		if ( this.scope === ScreenNode.SIZE || this.scope === ScreenNode.VIEWPORT ) {

			updateType = NodeUpdateType.RENDER;

		}

		this.updateType = updateType;

		return updateType;

	}

	/**
	 * `ScreenNode` implements {@link Node#update} to retrieve viewport and size information
	 * from the current renderer.
	 *
	 * @param {NodeFrame} frame - A reference to the current node frame.
	 */
	update( { renderer } ) {

		const renderTarget = renderer.getRenderTarget();

		if ( this.scope === ScreenNode.VIEWPORT ) {

			if ( renderTarget !== null ) {

				viewportVec.copy( renderTarget.viewport );

			} else {

				renderer.getViewport( viewportVec );

				viewportVec.multiplyScalar( renderer.getPixelRatio() );

			}

		} else {

			if ( renderTarget !== null ) {

				screenSizeVec.width = renderTarget.width;
				screenSizeVec.height = renderTarget.height;

			} else {

				renderer.getDrawingBufferSize( screenSizeVec );

			}

		}

	}

	setup( /*builder*/ ) {

		const scope = this.scope;

		let output = null;

		if ( scope === ScreenNode.SIZE ) {

			output = uniform( screenSizeVec || ( screenSizeVec = new Vector2() ) );

		} else if ( scope === ScreenNode.VIEWPORT ) {

			output = uniform( viewportVec || ( viewportVec = new Vector4() ) );

		} else {

			output = vec2( screenCoordinate.div( screenSize ) );

		}

		return output;

	}

	generate( builder ) {

		if ( this.scope === ScreenNode.COORDINATE ) {

			let coord = builder.getFragCoord();

			if ( builder.isFlipY() ) {

				// follow webgpu standards

				const size = builder.getNodeProperties( screenSize ).outputNode.build( builder );

				coord = `${ builder.getType( 'vec2' ) }( ${ coord }.x, ${ size }.y - ${ coord }.y )`;

			}

			return coord;

		}

		return super.generate( builder );

	}

}

ScreenNode.COORDINATE = 'coordinate';
ScreenNode.VIEWPORT = 'viewport';
ScreenNode.SIZE = 'size';
ScreenNode.UV = 'uv';

// Screen

/**
 * TSL object that represents normalized screen coordinates, unitless in `[0, 1]`.
 *
 * @type {ScreenNode<vec2>}
 */
const screenUV = /*@__PURE__*/ nodeImmutable( ScreenNode, ScreenNode.UV );

/**
 * TSL object that represents the screen resolution in physical pixel units.
 *
 * @type {ScreenNode<vec2>}
 */
const screenSize = /*@__PURE__*/ nodeImmutable( ScreenNode, ScreenNode.SIZE );

/**
 * TSL object that represents the current `x`/`y` pixel position on the screen in physical pixel units.
 *
 * @type {ScreenNode<vec2>}
 */
const screenCoordinate = /*@__PURE__*/ nodeImmutable( ScreenNode, ScreenNode.COORDINATE );

// Viewport

/**
 * TSL object that represents the viewport rectangle as `x`, `y`, `width` and `height` in physical pixel units.
 *
 * @type {ScreenNode<vec4>}
 */
const viewport = /*@__PURE__*/ nodeImmutable( ScreenNode, ScreenNode.VIEWPORT );

/**
 * TSL object that represents the viewport resolution in physical pixel units.
 *
 * @type {ScreenNode<vec2>}
 */
const viewportSize = viewport.zw;

/**
 * TSL object that represents the current `x`/`y` pixel position on the viewport in physical pixel units.
 *
 * @type {ScreenNode<vec2>}
 */
const viewportCoordinate = /*@__PURE__*/ screenCoordinate.sub( viewport.xy );

/**
 * TSL object that represents normalized viewport coordinates, unitless in `[0, 1]`.
 *
 * @type {ScreenNode<vec2>}
 */
const viewportUV = /*@__PURE__*/ viewportCoordinate.div( viewportSize );

// Deprecated

const viewportResolution = /*@__PURE__*/ ( Fn( () => { // @deprecated, r169

	console.warn( 'TSL.ViewportNode: "viewportResolution" is deprecated. Use "screenSize" instead.' );

	return screenSize;

}, 'vec2' ).once() )();

const viewportTopLeft = /*@__PURE__*/ ( Fn( () => { // @deprecated, r168

	console.warn( 'TSL.ViewportNode: "viewportTopLeft" is deprecated. Use "screenUV" instead.' );

	return screenUV;

}, 'vec2' ).once() )();

const viewportBottomLeft = /*@__PURE__*/ ( Fn( () => { // @deprecated, r168

	console.warn( 'TSL.ViewportNode: "viewportBottomLeft" is deprecated. Use "screenUV.flipY()" instead.' );

	return screenUV.flipY();

}, 'vec2' ).once() )();

/** @module ViewportTextureNode **/

const _size$4 = /*@__PURE__*/ new Vector2();

/**
 * A special type of texture node which represents the data of the current viewport
 * as a texture. The module extracts data from the current bound framebuffer with
 * a copy operation so no extra render pass is required to produce the texture data
 * (which is good for performance). `ViewportTextureNode` can be used as an input for a
 * variety of effects like refractive or transmissive materials.
 *
 * @augments module:TextureNode~TextureNode
 */
class ViewportTextureNode extends TextureNode {

	static get type() {

		return 'ViewportTextureNode';

	}

	/**
	 * Constructs a new viewport texture node.
	 *
	 * @param {Node} [uvNode=screenUV] - The uv node.
	 * @param {Node?} [levelNode=null] - The level node.
	 * @param {Texture?} [framebufferTexture=null] - A framebuffer texture holding the viewport data. If not provided, a framebuffer texture is created automatically.
	 */
	constructor( uvNode = screenUV, levelNode = null, framebufferTexture = null ) {

		if ( framebufferTexture === null ) {

			framebufferTexture = new FramebufferTexture();
			framebufferTexture.minFilter = LinearMipmapLinearFilter;

		}

		super( framebufferTexture, uvNode, levelNode );

		/**
		 * Whether to generate mipmaps or not.
		 *
		 * @type {Boolean}
		 * @default false
		 */
		this.generateMipmaps = false;

		/**
		 * This flag can be used for type testing.
		 *
		 * @type {Boolean}
		 * @readonly
		 * @default true
		 */
		this.isOutputTextureNode = true;

		/**
		 * The `updateBeforeType` is set to `NodeUpdateType.FRAME` since the node renders the
		 * scene once per frame in its {@link ViewportTextureNode#updateBefore} method.
		 *
		 * @type {String}
		 * @default 'frame'
		 */
		this.updateBeforeType = NodeUpdateType.FRAME;

	}

	updateBefore( frame ) {

		const renderer = frame.renderer;
		renderer.getDrawingBufferSize( _size$4 );

		//

		const framebufferTexture = this.value;

		if ( framebufferTexture.image.width !== _size$4.width || framebufferTexture.image.height !== _size$4.height ) {

			framebufferTexture.image.width = _size$4.width;
			framebufferTexture.image.height = _size$4.height;
			framebufferTexture.needsUpdate = true;

		}

		//

		const currentGenerateMipmaps = framebufferTexture.generateMipmaps;
		framebufferTexture.generateMipmaps = this.generateMipmaps;

		renderer.copyFramebufferToTexture( framebufferTexture );

		framebufferTexture.generateMipmaps = currentGenerateMipmaps;

	}

	clone() {

		const viewportTextureNode = new this.constructor( this.uvNode, this.levelNode, this.value );
		viewportTextureNode.generateMipmaps = this.generateMipmaps;

		return viewportTextureNode;

	}

}

/**
 * TSL function for creating a viewport texture node.
 *
 * @function
 * @param {Node} [uvNode=screenUV] - The uv node.
 * @param {Node?} [levelNode=null] - The level node.
 * @param {Texture?} [framebufferTexture=null] - A framebuffer texture holding the viewport data. If not provided, a framebuffer texture is created automatically.
 * @returns {ViewportTextureNode}
 */
const viewportTexture = /*@__PURE__*/ nodeProxy( ViewportTextureNode );

/**
 * TSL function for creating a viewport texture node with enabled mipmap generation.
 *
 * @function
 * @param {Node} [uvNode=screenUV] - The uv node.
 * @param {Node?} [levelNode=null] - The level node.
 * @param {Texture?} [framebufferTexture=null] - A framebuffer texture holding the viewport data. If not provided, a framebuffer texture is created automatically.
 * @returns {ViewportTextureNode}
 */
const viewportMipTexture = /*@__PURE__*/ nodeProxy( ViewportTextureNode, null, null, { generateMipmaps: true } );

/** @module ViewportDepthTextureNode **/

let sharedDepthbuffer = null;

/**
 * Represents the depth of the current viewport as a texture. This module
 * can be used in combination with viewport texture to achieve effects
 * that require depth evaluation.
 *
 * @augments module:ViewportTextureNode~ViewportTextureNode
 */
class ViewportDepthTextureNode extends ViewportTextureNode {

	static get type() {

		return 'ViewportDepthTextureNode';

	}

	/**
	 * Constructs a new viewport depth texture node.
	 *
	 * @param {Node} [uvNode=screenUV] - The uv node.
	 * @param {Node?} [levelNode=null] - The level node.
	 */
	constructor( uvNode = screenUV, levelNode = null ) {

		if ( sharedDepthbuffer === null ) {

			sharedDepthbuffer = new DepthTexture();

		}

		super( uvNode, levelNode, sharedDepthbuffer );

	}

}

/**
 * TSL function for a viewport depth texture node.
 *
 * @function
 * @param {Node} [uvNode=screenUV] - The uv node.
 * @param {Node?} [levelNode=null] - The level node.
 * @returns {ViewportDepthTextureNode}
 */
const viewportDepthTexture = /*@__PURE__*/ nodeProxy( ViewportDepthTextureNode );

/** @module ViewportDepthNode **/

/**
 * This node offers a collection of features in context of the depth logic in the fragment shader.
 * Depending on {@link ViewportDepthNode#scope}, it can be used to define a depth value for the current
 * fragment or for depth evaluation purposes.
 *
 * @augments Node
 */
class ViewportDepthNode extends Node {

	static get type() {

		return 'ViewportDepthNode';

	}

	/**
	 * Constructs a new viewport depth node.
	 *
	 * @param {('depth'|'depthBase'|'linearDepth')} scope - The node's scope.
	 * @param {Node?} [valueNode=null] - The value node.
	 */
	constructor( scope, valueNode = null ) {

		super( 'float' );

		/**
		 * The node behaves differently depending on which scope is selected.
		 *
		 * - `ViewportDepthNode.DEPTH_BASE`: Allows to define a value for the current fragment's depth.
		 * - `ViewportDepthNode.DEPTH`: Represents the depth value for the current fragment (`valueNode` is ignored).
		 * - `ViewportDepthNode.LINEAR_DEPTH`: Represents the linear (orthographic) depth value of the current fragment.
		 * If a `valueNode` is set, the scope can be used to convert perspective depth data to linear data.
		 *
		 * @type {('depth'|'depthBase'|'linearDepth')}
		 */
		this.scope = scope;

		/**
		 * Can be used to define a custom depth value.
		 * The property is ignored in the `ViewportDepthNode.DEPTH` scope.
		 *
		 * @type {Node?}
		 * @default null
		 */
		this.valueNode = valueNode;

		/**
		 * This flag can be used for type testing.
		 *
		 * @type {Boolean}
		 * @readonly
		 * @default true
		 */
		this.isViewportDepthNode = true;

	}

	generate( builder ) {

		const { scope } = this;

		if ( scope === ViewportDepthNode.DEPTH_BASE ) {

			return builder.getFragDepth();

		}

		return super.generate( builder );

	}

	setup( { camera } ) {

		const { scope } = this;
		const value = this.valueNode;

		let node = null;

		if ( scope === ViewportDepthNode.DEPTH_BASE ) {

			if ( value !== null ) {

 				node = depthBase().assign( value );

			}

		} else if ( scope === ViewportDepthNode.DEPTH ) {

			if ( camera.isPerspectiveCamera ) {

				node = viewZToPerspectiveDepth( positionView.z, cameraNear, cameraFar );

			} else {

				node = viewZToOrthographicDepth( positionView.z, cameraNear, cameraFar );

			}

		} else if ( scope === ViewportDepthNode.LINEAR_DEPTH ) {

			if ( value !== null ) {

				if ( camera.isPerspectiveCamera ) {

					const viewZ = perspectiveDepthToViewZ( value, cameraNear, cameraFar );

					node = viewZToOrthographicDepth( viewZ, cameraNear, cameraFar );

				} else {

					node = value;

				}

			} else {

				node = viewZToOrthographicDepth( positionView.z, cameraNear, cameraFar );

			}

		}

		return node;

	}

}

ViewportDepthNode.DEPTH_BASE = 'depthBase';
ViewportDepthNode.DEPTH = 'depth';
ViewportDepthNode.LINEAR_DEPTH = 'linearDepth';

// NOTE: viewZ, the z-coordinate in camera space, is negative for points in front of the camera

/**
 * TSL function for converting a viewZ value to an orthographic depth value.
 *
 * @function
 * @param {Node<float>} viewZ - The viewZ node.
 * @param {Node<float>} near - The camera's near value.
 * @param {Node<float>} far - The camera's far value.
 * @returns {Node<float>}
 */
const viewZToOrthographicDepth = ( viewZ, near, far ) => viewZ.add( near ).div( near.sub( far ) );

/**
 * TSL function for converting an orthographic depth value to a viewZ value.
 *
 * @function
 * @param {Node<float>} depth - The orthographic depth.
 * @param {Node<float>} near - The camera's near value.
 * @param {Node<float>} far - The camera's far value.
 * @returns {Node<float>}
 */
const orthographicDepthToViewZ = ( depth, near, far ) => near.sub( far ).mul( depth ).sub( near );

/**
 * TSL function for converting a viewZ value to a perspective depth value.
 *
 * Note: {link https://twitter.com/gonnavis/status/1377183786949959682}.
 *
 * @function
 * @param {Node<float>} viewZ - The viewZ node.
 * @param {Node<float>} near - The camera's near value.
 * @param {Node<float>} far - The camera's far value.
 * @returns {Node<float>}
 */
const viewZToPerspectiveDepth = ( viewZ, near, far ) => near.add( viewZ ).mul( far ).div( far.sub( near ).mul( viewZ ) );

/**
 * TSL function for converting a perspective depth value to a viewZ value.
 *
 * @function
 * @param {Node<float>} depth - The perspective depth.
 * @param {Node<float>} near - The camera's near value.
 * @param {Node<float>} far - The camera's far value.
 * @returns {Node<float>}
 */
const perspectiveDepthToViewZ = ( depth, near, far ) => near.mul( far ).div( far.sub( near ).mul( depth ).sub( far ) );

/**
 * TSL function for converting a viewZ value to a logarithmic depth value.
 *
 * @function
 * @param {Node<float>} viewZ - The viewZ node.
 * @param {Node<float>} near - The camera's near value.
 * @param {Node<float>} far - The camera's far value.
 * @returns {Node<float>}
 */
const viewZToLogarithmicDepth = ( viewZ, near, far ) => {

	// NOTE: viewZ must be negative--see explanation at the end of this comment block.
	// The final logarithmic depth formula used here is adapted from one described in an
	// article by Thatcher Ulrich (see http://tulrich.com/geekstuff/log_depth_buffer.txt),
	// which was an improvement upon an earlier formula one described in an
	// Outerra article (https://outerra.blogspot.com/2009/08/logarithmic-z-buffer.html).
	// Ulrich's formula is the following:
	//     z = K * log( w / cameraNear ) / log( cameraFar / cameraNear )
	//     where K = 2^k - 1, and k is the number of bits in the depth buffer.
	// The Outerra variant ignored the camera near plane (it assumed it was 0) and instead
	// opted for a "C-constant" for resolution adjustment of objects near the camera.
	// Outerra states: "Notice that the 'C' variant doesn’t use a near plane distance, it has it
	// set at 0" (quote from https://outerra.blogspot.com/2012/11/maximizing-depth-buffer-range-and.html).
	// Ulrich's variant has the benefit of constant relative precision over the whole near-far range.
	// It was debated here whether Outerra's "C-constant" or Ulrich's "near plane" variant should
	// be used, and ultimately Ulrich's "near plane" version was chosen.
	// Outerra eventually made another improvement to their original "C-constant" variant,
	// but it still does not incorporate the camera near plane (for this version,
	// see https://outerra.blogspot.com/2013/07/logarithmic-depth-buffer-optimizations.html).
	// Here we make 4 changes to Ulrich's formula:
	// 1. Clamp the camera near plane so we don't divide by 0.
	// 2. Use log2 instead of log to avoid an extra multiply (shaders implement log using log2).
	// 3. Assume K is 1 (K = maximum value in depth buffer; see Ulrich's formula above).
	// 4. To maintain consistency with the functions "viewZToOrthographicDepth" and "viewZToPerspectiveDepth",
	//    we modify the formula here to use 'viewZ' instead of 'w'. The other functions expect a negative viewZ,
	//    so we do the same here, hence the 'viewZ.negate()' call.
	// For visual representation of this depth curve, see https://www.desmos.com/calculator/uyqk0vex1u
	near = near.max( 1e-6 ).toVar();
	const numerator = log2( viewZ.negate().div( near ) );
	const denominator = log2( far.div( near ) );
	return numerator.div( denominator );

};

/**
 * TSL function for converting a logarithmic depth value to a viewZ value.
 *
 * @function
 * @param {Node<float>} depth - The logarithmic depth.
 * @param {Node<float>} near - The camera's near value.
 * @param {Node<float>} far - The camera's far value.
 * @returns {Node<float>}
 */
const logarithmicDepthToViewZ = ( depth, near, far ) => {

	// NOTE: we add a 'negate()' call to the return value here to maintain consistency with
	// the functions "orthographicDepthToViewZ" and "perspectiveDepthToViewZ" (they return
	// a negative viewZ).
	const exponent = depth.mul( log( far.div( near ) ) );
	return float( Math.E ).pow( exponent ).mul( near ).negate();

};

/**
 * TSL function for defining a value for the current fragment's depth.
 *
 * @function
 * @param {Node<float>} value - The depth value to set.
 * @returns {ViewportDepthNode<float>}
 */
const depthBase = /*@__PURE__*/ nodeProxy( ViewportDepthNode, ViewportDepthNode.DEPTH_BASE );

/**
 * TSL object that represents the depth value for the current fragment.
 *
 * @type {ViewportDepthNode}
 */
const depth = /*@__PURE__*/ nodeImmutable( ViewportDepthNode, ViewportDepthNode.DEPTH );

/**
 * TSL function for converting a perspective depth value to linear depth.
 *
 * @function
 * @param {Node<float>} value - The perspective depth.
 * @returns {ViewportDepthNode<float>}
 */
const linearDepth = /*@__PURE__*/ nodeProxy( ViewportDepthNode, ViewportDepthNode.LINEAR_DEPTH );

/**
 * TSL object that represents the linear (orthographic) depth value of the current fragment
 *
 * @type {ViewportDepthNode}
 */
const viewportLinearDepth = /*@__PURE__*/ linearDepth( viewportDepthTexture() );

depth.assign = ( value ) => depthBase( value );

class BuiltinNode extends Node {

	constructor( name ) {

		super( 'float' );

		this.name = name;

		this.isBuiltinNode = true;

	}

	generate( /* builder */ ) {

		return this.name;

	}

}

const builtin = nodeProxy( BuiltinNode );

class ClippingNode extends Node {

	static get type() {

		return 'ClippingNode';

	}

	constructor( scope = ClippingNode.DEFAULT ) {

		super();

		this.scope = scope;

	}

	setup( builder ) {

		super.setup( builder );

		const clippingContext = builder.clippingContext;
		const { intersectionPlanes, unionPlanes } = clippingContext;

		this.hardwareClipping = builder.material.hardwareClipping;

		if ( this.scope === ClippingNode.ALPHA_TO_COVERAGE ) {

			return this.setupAlphaToCoverage( intersectionPlanes, unionPlanes );

		} else if ( this.scope === ClippingNode.HARDWARE ) {

			return this.setupHardwareClipping( unionPlanes, builder );

		} else {

			return this.setupDefault( intersectionPlanes, unionPlanes );

		}

	}

	setupAlphaToCoverage( intersectionPlanes, unionPlanes ) {

		return Fn( () => {

			const distanceToPlane = float().toVar( 'distanceToPlane' );
			const distanceGradient = float().toVar( 'distanceToGradient' );

			const clipOpacity = float( 1 ).toVar( 'clipOpacity' );

			const numUnionPlanes = unionPlanes.length;

			if ( ! this.hardwareClipping && numUnionPlanes > 0 ) {

				const clippingPlanes = uniformArray( unionPlanes );

				Loop( numUnionPlanes, ( { i } ) => {

					const plane = clippingPlanes.element( i );

					distanceToPlane.assign( positionView.dot( plane.xyz ).negate().add( plane.w ) );
					distanceGradient.assign( distanceToPlane.fwidth().div( 2.0 ) );

					clipOpacity.mulAssign( smoothstep( distanceGradient.negate(), distanceGradient, distanceToPlane ) );

				} );

			}

			const numIntersectionPlanes = intersectionPlanes.length;

			if ( numIntersectionPlanes > 0 ) {

				const clippingPlanes = uniformArray( intersectionPlanes );
				const intersectionClipOpacity = float( 1 ).toVar( 'intersectionClipOpacity' );

				Loop( numIntersectionPlanes, ( { i } ) => {

					const plane = clippingPlanes.element( i );

					distanceToPlane.assign( positionView.dot( plane.xyz ).negate().add( plane.w ) );
					distanceGradient.assign( distanceToPlane.fwidth().div( 2.0 ) );

					intersectionClipOpacity.mulAssign( smoothstep( distanceGradient.negate(), distanceGradient, distanceToPlane ).oneMinus() );

				} );

				clipOpacity.mulAssign( intersectionClipOpacity.oneMinus() );

			}

			diffuseColor.a.mulAssign( clipOpacity );

			diffuseColor.a.equal( 0.0 ).discard();

		} )();

	}

	setupDefault( intersectionPlanes, unionPlanes ) {

		return Fn( () => {

			const numUnionPlanes = unionPlanes.length;

			if ( ! this.hardwareClipping && numUnionPlanes > 0 ) {

				const clippingPlanes = uniformArray( unionPlanes );

				Loop( numUnionPlanes, ( { i } ) => {

					const plane = clippingPlanes.element( i );
					positionView.dot( plane.xyz ).greaterThan( plane.w ).discard();

				} );

			}

			const numIntersectionPlanes = intersectionPlanes.length;

			if ( numIntersectionPlanes > 0 ) {

				const clippingPlanes = uniformArray( intersectionPlanes );
				const clipped = bool( true ).toVar( 'clipped' );

				Loop( numIntersectionPlanes, ( { i } ) => {

					const plane = clippingPlanes.element( i );
					clipped.assign( positionView.dot( plane.xyz ).greaterThan( plane.w ).and( clipped ) );

				} );

				clipped.discard();

			}

		} )();

	}

	setupHardwareClipping( unionPlanes, builder ) {

		const numUnionPlanes = unionPlanes.length;

		builder.enableHardwareClipping( numUnionPlanes );

		return Fn( () => {

			const clippingPlanes = uniformArray( unionPlanes );
			const hw_clip_distances = builtin( builder.getClipDistance() );

			Loop( numUnionPlanes, ( { i } ) => {

				const plane = clippingPlanes.element( i );

				const distance = positionView.dot( plane.xyz ).sub( plane.w ).negate();
				hw_clip_distances.element( i ).assign( distance );

			} );

		} )();

	}

}

ClippingNode.ALPHA_TO_COVERAGE = 'alphaToCoverage';
ClippingNode.DEFAULT = 'default';
ClippingNode.HARDWARE = 'hardware';

const clipping = () => nodeObject( new ClippingNode() );
const clippingAlpha = () => nodeObject( new ClippingNode( ClippingNode.ALPHA_TO_COVERAGE ) );
const hardwareClipping = () => nodeObject( new ClippingNode( ClippingNode.HARDWARE ) );

// See: https://casual-effects.com/research/Wyman2017Hashed/index.html

const ALPHA_HASH_SCALE = 0.05; // Derived from trials only, and may be changed.

const hash2D = /*@__PURE__*/ Fn( ( [ value ] ) => {

	return fract( mul( 1.0e4, sin( mul( 17.0, value.x ).add( mul( 0.1, value.y ) ) ) ).mul( add( 0.1, abs( sin( mul( 13.0, value.y ).add( value.x ) ) ) ) ) );

} );

const hash3D = /*@__PURE__*/ Fn( ( [ value ] ) => {

	return hash2D( vec2( hash2D( value.xy ), value.z ) );

} );

const getAlphaHashThreshold = /*@__PURE__*/ Fn( ( [ position ] ) => {

	// Find the discretized derivatives of our coordinates
	const maxDeriv = max$1(
		length( dFdx( position.xyz ) ),
		length( dFdy( position.xyz ) )
	);

	const pixScale = float( 1 ).div( float( ALPHA_HASH_SCALE ).mul( maxDeriv ) ).toVar( 'pixScale' );

	// Find two nearest log-discretized noise scales
	const pixScales = vec2(
		exp2( floor( log2( pixScale ) ) ),
		exp2( ceil( log2( pixScale ) ) )
	);

	// Compute alpha thresholds at our two noise scales
	const alpha = vec2(
		hash3D( floor( pixScales.x.mul( position.xyz ) ) ),
		hash3D( floor( pixScales.y.mul( position.xyz ) ) ),
	);

	// Factor to interpolate lerp with
	const lerpFactor = fract( log2( pixScale ) );

	// Interpolate alpha threshold from noise at two scales
	const x = add( mul( lerpFactor.oneMinus(), alpha.x ), mul( lerpFactor, alpha.y ) );

	// Pass into CDF to compute uniformly distrib threshold
	const a = min$1( lerpFactor, lerpFactor.oneMinus() );
	const cases = vec3(
		x.mul( x ).div( mul( 2.0, a ).mul( sub( 1.0, a ) ) ),
		x.sub( mul( 0.5, a ) ).div( sub( 1.0, a ) ),
		sub( 1.0, sub( 1.0, x ).mul( sub( 1.0, x ) ).div( mul( 2.0, a ).mul( sub( 1.0, a ) ) ) ) );

	// Find our final, uniformly distributed alpha threshold (ατ)
	const threshold = x.lessThan( a.oneMinus() ).select( x.lessThan( a ).select( cases.x, cases.y ), cases.z );

	// Avoids ατ == 0. Could also do ατ =1-ατ
	return clamp( threshold, 1.0e-6, 1.0 );

} ).setLayout( {
	name: 'getAlphaHashThreshold',
	type: 'float',
	inputs: [
		{ name: 'position', type: 'vec3' }
	]
} );

class NodeMaterial extends Material {

	static get type() {

		return 'NodeMaterial';

	}

	get type() {

		return this.constructor.type;

	}

	set type( _value ) { /* */ }

	constructor() {

		super();

		this.isNodeMaterial = true;

		this.forceSinglePass = false;

		this.fog = true;
		this.lights = false;
		this.hardwareClipping = false;

		this.lightsNode = null;
		this.envNode = null;
		this.aoNode = null;

		this.colorNode = null;
		this.normalNode = null;
		this.opacityNode = null;
		this.backdropNode = null;
		this.backdropAlphaNode = null;
		this.alphaTestNode = null;

		this.positionNode = null;
		this.geometryNode = null;

		this.depthNode = null;
		this.shadowPositionNode = null;
		this.receivedShadowNode = null;
		this.castShadowNode = null;

		this.outputNode = null;
		this.mrtNode = null;

		this.fragmentNode = null;
		this.vertexNode = null;

	}

	customProgramCacheKey() {

		return this.type + getCacheKey$1( this );

	}

	build( builder ) {

		this.setup( builder );

	}

	setupObserver( builder ) {

		return new NodeMaterialObserver( builder );

	}

	setup( builder ) {

		builder.context.setupNormal = () => this.setupNormal( builder );
		builder.context.setupPositionView = () => this.setupPositionView( builder );

		const renderer = builder.renderer;
		const renderTarget = renderer.getRenderTarget();

		// < VERTEX STAGE >

		builder.addStack();

		const vertexNode = this.vertexNode || this.setupVertex( builder );

		builder.stack.outputNode = vertexNode;

		this.setupHardwareClipping( builder );

		if ( this.geometryNode !== null ) {

			builder.stack.outputNode = builder.stack.outputNode.bypass( this.geometryNode );

		}

		builder.addFlow( 'vertex', builder.removeStack() );

		// < FRAGMENT STAGE >

		builder.addStack();

		let resultNode;

		const clippingNode = this.setupClipping( builder );

		if ( this.depthWrite === true ) {

			// only write depth if depth buffer is configured

			if ( renderTarget !== null ) {

				if ( renderTarget.depthBuffer === true ) this.setupDepth( builder );

			} else {

				if ( renderer.depth === true ) this.setupDepth( builder );

			}

		}

		if ( this.fragmentNode === null ) {

			this.setupDiffuseColor( builder );
			this.setupVariants( builder );

			const outgoingLightNode = this.setupLighting( builder );

			if ( clippingNode !== null ) builder.stack.add( clippingNode );

			// force unsigned floats - useful for RenderTargets

			const basicOutput = vec4( outgoingLightNode, diffuseColor.a ).max( 0 );

			resultNode = this.setupOutput( builder, basicOutput );

			// OUTPUT NODE

			output.assign( resultNode );

			//

			if ( this.outputNode !== null ) resultNode = this.outputNode;

			// MRT

			if ( renderTarget !== null ) {

				const mrt = renderer.getMRT();
				const materialMRT = this.mrtNode;

				if ( mrt !== null ) {

					resultNode = mrt;

					if ( materialMRT !== null ) {

						resultNode = mrt.merge( materialMRT );

					}

				} else if ( materialMRT !== null ) {

					resultNode = materialMRT;

				}

			}

		} else {

			let fragmentNode = this.fragmentNode;

			if ( fragmentNode.isOutputStructNode !== true ) {

				fragmentNode = vec4( fragmentNode );

			}

			resultNode = this.setupOutput( builder, fragmentNode );

		}

		builder.stack.outputNode = resultNode;

		builder.addFlow( 'fragment', builder.removeStack() );

		// < MONITOR >

		builder.monitor = this.setupObserver( builder );

	}

	setupClipping( builder ) {

		if ( builder.clippingContext === null ) return null;

		const { unionPlanes, intersectionPlanes } = builder.clippingContext;

		let result = null;

		if ( unionPlanes.length > 0 || intersectionPlanes.length > 0 ) {

			const samples = builder.renderer.samples;

			if ( this.alphaToCoverage && samples > 1 ) {

				// to be added to flow when the color/alpha value has been determined
				result = clippingAlpha();

			} else {

				builder.stack.add( clipping() );

			}

		}

		return result;

	}

	setupHardwareClipping( builder ) {

		this.hardwareClipping = false;

		if ( builder.clippingContext === null ) return;

		const candidateCount = builder.clippingContext.unionPlanes.length;

		// 8 planes supported by WebGL ANGLE_clip_cull_distance and WebGPU clip-distances

		if ( candidateCount > 0 && candidateCount <= 8 && builder.isAvailable( 'clipDistance' ) ) {

			builder.stack.add( hardwareClipping() );

			this.hardwareClipping = true;

		}

		return;

	}

	setupDepth( builder ) {

		const { renderer, camera } = builder;

		// Depth

		let depthNode = this.depthNode;

		if ( depthNode === null ) {

			const mrt = renderer.getMRT();

			if ( mrt && mrt.has( 'depth' ) ) {

				depthNode = mrt.get( 'depth' );

			} else if ( renderer.logarithmicDepthBuffer === true ) {

				if ( camera.isPerspectiveCamera ) {

					depthNode = viewZToLogarithmicDepth( positionView.z, cameraNear, cameraFar );

				} else {

					depthNode = viewZToOrthographicDepth( positionView.z, cameraNear, cameraFar );

				}

			}

		}

		if ( depthNode !== null ) {

			depth.assign( depthNode ).append();

		}

	}

	setupPositionView() {

		return modelViewMatrix.mul( positionLocal ).xyz;

	}

	setupVertex( builder ) {

		builder.addStack();

		this.setupPosition( builder );

		builder.context.vertex = builder.removeStack();

		return modelViewProjection;

	}

	setupPosition( builder ) {

		const { object, geometry } = builder;

		if ( geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color ) {

			morphReference( object ).append();

		}

		if ( object.isSkinnedMesh === true ) {

			skinningReference( object ).append();

		}

		if ( this.displacementMap ) {

			const displacementMap = materialReference( 'displacementMap', 'texture' );
			const displacementScale = materialReference( 'displacementScale', 'float' );
			const displacementBias = materialReference( 'displacementBias', 'float' );

			positionLocal.addAssign( normalLocal.normalize().mul( ( displacementMap.x.mul( displacementScale ).add( displacementBias ) ) ) );

		}

		if ( object.isBatchedMesh ) {

			batch( object ).append();

		}

		if ( ( object.isInstancedMesh && object.instanceMatrix && object.instanceMatrix.isInstancedBufferAttribute === true ) ) {

			instancedMesh( object ).append();

		}

		if ( this.positionNode !== null ) {

			positionLocal.assign( this.positionNode.context( { isPositionNodeInput: true } ) );

		}

		return positionLocal;

	}

	setupDiffuseColor( { object, geometry } ) {

		let colorNode = this.colorNode ? vec4( this.colorNode ) : materialColor;

		// VERTEX COLORS

		if ( this.vertexColors === true && geometry.hasAttribute( 'color' ) ) {

			colorNode = vec4( colorNode.xyz.mul( attribute( 'color', 'vec3' ) ), colorNode.a );

		}

		// Instanced colors

		if ( object.instanceColor ) {

			const instanceColor = varyingProperty( 'vec3', 'vInstanceColor' );

			colorNode = instanceColor.mul( colorNode );

		}

		if ( object.isBatchedMesh && object._colorsTexture ) {

			const batchColor = varyingProperty( 'vec3', 'vBatchColor' );

			colorNode = batchColor.mul( colorNode );

		}


		// COLOR

		diffuseColor.assign( colorNode );

		// OPACITY

		const opacityNode = this.opacityNode ? float( this.opacityNode ) : materialOpacity;
		diffuseColor.a.assign( diffuseColor.a.mul( opacityNode ) );

		// ALPHA TEST

		if ( this.alphaTestNode !== null || this.alphaTest > 0 ) {

			const alphaTestNode = this.alphaTestNode !== null ? float( this.alphaTestNode ) : materialAlphaTest;

			diffuseColor.a.lessThanEqual( alphaTestNode ).discard();

		}

		// ALPHA HASH

		if ( this.alphaHash === true ) {

			diffuseColor.a.lessThan( getAlphaHashThreshold( positionLocal ) ).discard();

		}

		if ( this.transparent === false && this.blending === NormalBlending && this.alphaToCoverage === false ) {

			diffuseColor.a.assign( 1.0 );

		}

	}

	setupVariants( /*builder*/ ) {

		// Interface function.

	}

	setupOutgoingLight() {

		return ( this.lights === true ) ? vec3( 0 ) : diffuseColor.rgb;

	}

	setupNormal() {

		return this.normalNode ? vec3( this.normalNode ) : materialNormal;

	}

	setupEnvironment( /*builder*/ ) {

		let node = null;

		if ( this.envNode ) {

			node = this.envNode;

		} else if ( this.envMap ) {

			node = this.envMap.isCubeTexture ? materialReference( 'envMap', 'cubeTexture' ) : materialReference( 'envMap', 'texture' );

		}

		return node;

	}

	setupLightMap( builder ) {

		let node = null;

		if ( builder.material.lightMap ) {

			node = new IrradianceNode( materialLightMap );

		}

		return node;

	}

	setupLights( builder ) {

		const materialLightsNode = [];

		//

		const envNode = this.setupEnvironment( builder );

		if ( envNode && envNode.isLightingNode ) {

			materialLightsNode.push( envNode );

		}

		const lightMapNode = this.setupLightMap( builder );

		if ( lightMapNode && lightMapNode.isLightingNode ) {

			materialLightsNode.push( lightMapNode );

		}

		if ( this.aoNode !== null || builder.material.aoMap ) {

			const aoNode = this.aoNode !== null ? this.aoNode : materialAOMap;

			materialLightsNode.push( new AONode( aoNode ) );

		}

		let lightsN = this.lightsNode || builder.lightsNode;

		if ( materialLightsNode.length > 0 ) {

			lightsN = builder.renderer.lighting.createNode( [ ...lightsN.getLights(), ...materialLightsNode ] );

		}

		return lightsN;

	}

	setupLightingModel( /*builder*/ ) {

		// Interface function.

	}

	setupLighting( builder ) {

		const { material } = builder;
		const { backdropNode, backdropAlphaNode, emissiveNode } = this;

		// OUTGOING LIGHT

		const lights = this.lights === true || this.lightsNode !== null;

		const lightsNode = lights ? this.setupLights( builder ) : null;

		let outgoingLightNode = this.setupOutgoingLight( builder );

		if ( lightsNode && lightsNode.getScope().hasLights ) {

			const lightingModel = this.setupLightingModel( builder );

			outgoingLightNode = lightingContext( lightsNode, lightingModel, backdropNode, backdropAlphaNode );

		} else if ( backdropNode !== null ) {

			outgoingLightNode = vec3( backdropAlphaNode !== null ? mix( outgoingLightNode, backdropNode, backdropAlphaNode ) : backdropNode );

		}

		// EMISSIVE

		if ( ( emissiveNode && emissiveNode.isNode === true ) || ( material.emissive && material.emissive.isColor === true ) ) {

			emissive.assign( vec3( emissiveNode ? emissiveNode : materialEmissive ) );

			outgoingLightNode = outgoingLightNode.add( emissive );

		}

		return outgoingLightNode;

	}

	setupOutput( builder, outputNode ) {

		// FOG

		if ( this.fog === true ) {

			const fogNode = builder.fogNode;

			if ( fogNode ) {

				output.assign( outputNode );

				outputNode = vec4( fogNode );

			}

		}

		return outputNode;

	}

	setDefaultValues( material ) {

		// This approach is to reuse the native refreshUniforms*
		// and turn available the use of features like transmission and environment in core

		for ( const property in material ) {

			const value = material[ property ];

			if ( this[ property ] === undefined ) {

				this[ property ] = value;

				if ( value && value.clone ) this[ property ] = value.clone();

			}

		}

		const descriptors = Object.getOwnPropertyDescriptors( material.constructor.prototype );

		for ( const key in descriptors ) {

			if ( Object.getOwnPropertyDescriptor( this.constructor.prototype, key ) === undefined &&
			     descriptors[ key ].get !== undefined ) {

				Object.defineProperty( this.constructor.prototype, key, descriptors[ key ] );

			}

		}

	}

	toJSON( meta ) {

		const isRoot = ( meta === undefined || typeof meta === 'string' );

		if ( isRoot ) {

			meta = {
				textures: {},
				images: {},
				nodes: {}
			};

		}

		const data = Material.prototype.toJSON.call( this, meta );
		const nodeChildren = getNodeChildren( this );

		data.inputNodes = {};

		for ( const { property, childNode } of nodeChildren ) {

			data.inputNodes[ property ] = childNode.toJSON( meta ).uuid;

		}

		// TODO: Copied from Object3D.toJSON

		function extractFromCache( cache ) {

			const values = [];

			for ( const key in cache ) {

				const data = cache[ key ];
				delete data.metadata;
				values.push( data );

			}

			return values;

		}

		if ( isRoot ) {

			const textures = extractFromCache( meta.textures );
			const images = extractFromCache( meta.images );
			const nodes = extractFromCache( meta.nodes );

			if ( textures.length > 0 ) data.textures = textures;
			if ( images.length > 0 ) data.images = images;
			if ( nodes.length > 0 ) data.nodes = nodes;

		}

		return data;

	}

	copy( source ) {

		this.lightsNode = source.lightsNode;
		this.envNode = source.envNode;

		this.colorNode = source.colorNode;
		this.normalNode = source.normalNode;
		this.opacityNode = source.opacityNode;
		this.backdropNode = source.backdropNode;
		this.backdropAlphaNode = source.backdropAlphaNode;
		this.alphaTestNode = source.alphaTestNode;

		this.positionNode = source.positionNode;
		this.geometryNode = source.geometryNode;

		this.depthNode = source.depthNode;
		this.shadowPositionNode = source.shadowPositionNode;
		this.receivedShadowNode = source.receivedShadowNode;
		this.castShadowNode = source.castShadowNode;

		this.outputNode = source.outputNode;
		this.mrtNode = source.mrtNode;

		this.fragmentNode = source.fragmentNode;
		this.vertexNode = source.vertexNode;

		return super.copy( source );

	}

}

const _defaultValues$e = /*@__PURE__*/ new PointsMaterial();

class InstancedPointsNodeMaterial extends NodeMaterial {

	static get type() {

		return 'InstancedPointsNodeMaterial';

	}

	constructor( params = {} ) {

		super();

		this.lights = false;

		this.useAlphaToCoverage = true;

		this.useColor = params.vertexColors;

		this.pointWidth = 1;

		this.pointColorNode = null;

		this.pointWidthNode = null;

		this.setDefaultValues( _defaultValues$e );

		this.setValues( params );

	}

	setup( builder ) {

		this.setupShaders( builder );

		super.setup( builder );

	}

	setupShaders( { renderer } ) {

		const useAlphaToCoverage = this.alphaToCoverage;
		const useColor = this.useColor;

		this.vertexNode = Fn( () => {

			const instancePosition = attribute( 'instancePosition' ).xyz;

			// camera space
			const mvPos = vec4( modelViewMatrix.mul( vec4( instancePosition, 1.0 ) ) );

			const aspect = viewport.z.div( viewport.w );

			// clip space
			const clipPos = cameraProjectionMatrix.mul( mvPos );

			// offset in ndc space
			const offset = positionGeometry.xy.toVar();

			offset.mulAssign( this.pointWidthNode ? this.pointWidthNode : materialPointWidth );

			offset.assign( offset.div( viewport.z ) );
			offset.y.assign( offset.y.mul( aspect ) );

			// back to clip space
			offset.assign( offset.mul( clipPos.w ) );

			//clipPos.xy += offset;
			clipPos.addAssign( vec4( offset, 0, 0 ) );

			return clipPos;

		} )();

		this.fragmentNode = Fn( () => {

			const alpha = float( 1 ).toVar();

			const len2 = lengthSq( uv().mul( 2 ).sub( 1 ) );

			if ( useAlphaToCoverage && renderer.samples > 1 ) {

				const dlen = float( len2.fwidth() ).toVar();

				alpha.assign( smoothstep( dlen.oneMinus(), dlen.add( 1 ), len2 ).oneMinus() );

			} else {

				len2.greaterThan( 1.0 ).discard();

			}

			let pointColorNode;

			if ( this.pointColorNode ) {

				pointColorNode = this.pointColorNode;

			} else {

				if ( useColor ) {

					const instanceColor = attribute( 'instanceColor' );

					pointColorNode = instanceColor.mul( materialColor );

				} else {

					pointColorNode = materialColor;

				}

			}

			alpha.mulAssign( materialOpacity );

			return vec4( pointColorNode, alpha );

		} )();

	}

	get alphaToCoverage() {

		return this.useAlphaToCoverage;

	}

	set alphaToCoverage( value ) {

		if ( this.useAlphaToCoverage !== value ) {

			this.useAlphaToCoverage = value;
			this.needsUpdate = true;

		}

	}

}

const _defaultValues$d = /*@__PURE__*/ new LineBasicMaterial();

class LineBasicNodeMaterial extends NodeMaterial {

	static get type() {

		return 'LineBasicNodeMaterial';

	}

	constructor( parameters ) {

		super();

		this.isLineBasicNodeMaterial = true;

		this.lights = false;

		this.setDefaultValues( _defaultValues$d );

		this.setValues( parameters );

	}

}

const _defaultValues$c = /*@__PURE__*/ new LineDashedMaterial();

class LineDashedNodeMaterial extends NodeMaterial {

	static get type() {

		return 'LineDashedNodeMaterial';

	}

	constructor( parameters ) {

		super();

		this.isLineDashedNodeMaterial = true;

		this.lights = false;

		this.setDefaultValues( _defaultValues$c );

		this.dashOffset = 0;

		this.offsetNode = null;
		this.dashScaleNode = null;
		this.dashSizeNode = null;
		this.gapSizeNode = null;

		this.setValues( parameters );

	}

	setupVariants() {

		const offsetNode = this.offsetNode ? float( this.offsetNodeNode ) : materialLineDashOffset;
		const dashScaleNode = this.dashScaleNode ? float( this.dashScaleNode ) : materialLineScale;
		const dashSizeNode = this.dashSizeNode ? float( this.dashSizeNode ) : materialLineDashSize;
		const gapSizeNode = this.dashSizeNode ? float( this.dashGapNode ) : materialLineGapSize;

		dashSize.assign( dashSizeNode );
		gapSize.assign( gapSizeNode );

		const vLineDistance = varying( attribute( 'lineDistance' ).mul( dashScaleNode ) );
		const vLineDistanceOffset = offsetNode ? vLineDistance.add( offsetNode ) : vLineDistance;

		vLineDistanceOffset.mod( dashSize.add( gapSize ) ).greaterThan( dashSize ).discard();

	}

}

/** @module ViewportSharedTextureNode **/

let _sharedFramebuffer = null;

/**
 * `ViewportTextureNode` creates an internal texture for each node instance. This module
 * shares a texture across all instances of `ViewportSharedTextureNode`. It should
 * be the first choice when using data of the default/screen framebuffer for performance reasons.
 *
 * @augments module:ViewportTextureNode~ViewportTextureNode
 */
class ViewportSharedTextureNode extends ViewportTextureNode {

	static get type() {

		return 'ViewportSharedTextureNode';

	}

	/**
	 * Constructs a new viewport shared texture node.
	 *
	 * @param {Node} [uvNode=screenUV] - The uv node.
	 * @param {Node?} [levelNode=null] - The level node.
	 */
	constructor( uvNode = screenUV, levelNode = null ) {

		if ( _sharedFramebuffer === null ) {

			_sharedFramebuffer = new FramebufferTexture();

		}

		super( uvNode, levelNode, _sharedFramebuffer );

	}

	updateReference() {

		return this;

	}

}

/**
 * TSL function for creating a shared viewport texture node.
 *
 * @function
 * @param {Node} [uvNode=screenUV] - The uv node.
 * @param {Node?} [levelNode=null] - The level node.
 * @returns {ViewportSharedTextureNode}
 */
const viewportSharedTexture = /*@__PURE__*/ nodeProxy( ViewportSharedTextureNode );

const _defaultValues$b = /*@__PURE__*/ new LineDashedMaterial();

class Line2NodeMaterial extends NodeMaterial {

	static get type() {

		return 'Line2NodeMaterial';

	}

	constructor( params = {} ) {

		super();

		this.lights = false;

		this.setDefaultValues( _defaultValues$b );

		this.useAlphaToCoverage = true;
		this.useColor = params.vertexColors;
		this.useDash = params.dashed;
		this.useWorldUnits = false;

		this.dashOffset = 0;
		this.lineWidth = 1;

		this.lineColorNode = null;

		this.offsetNode = null;
		this.dashScaleNode = null;
		this.dashSizeNode = null;
		this.gapSizeNode = null;

		this.blending = NoBlending;

		this.setValues( params );

	}

	setup( builder ) {

		this.setupShaders( builder );

		super.setup( builder );

	}

	setupShaders( { renderer } ) {

		const useAlphaToCoverage = this.alphaToCoverage;
		const useColor = this.useColor;
		const useDash = this.dashed;
		const useWorldUnits = this.worldUnits;

		const trimSegment = Fn( ( { start, end } ) => {

			const a = cameraProjectionMatrix.element( 2 ).element( 2 ); // 3nd entry in 3th column
			const b = cameraProjectionMatrix.element( 3 ).element( 2 ); // 3nd entry in 4th column
			const nearEstimate = b.mul( - 0.5 ).div( a );

			const alpha = nearEstimate.sub( start.z ).div( end.z.sub( start.z ) );

			return vec4( mix( start.xyz, end.xyz, alpha ), end.w );

		} ).setLayout( {
			name: 'trimSegment',
			type: 'vec4',
			inputs: [
				{ name: 'start', type: 'vec4' },
				{ name: 'end', type: 'vec4' }
			]
		} );

		this.vertexNode = Fn( () => {

			const instanceStart = attribute( 'instanceStart' );
			const instanceEnd = attribute( 'instanceEnd' );

			// camera space

			const start = vec4( modelViewMatrix.mul( vec4( instanceStart, 1.0 ) ) ).toVar( 'start' );
			const end = vec4( modelViewMatrix.mul( vec4( instanceEnd, 1.0 ) ) ).toVar( 'end' );

			if ( useDash ) {

				const dashScaleNode = this.dashScaleNode ? float( this.dashScaleNode ) : materialLineScale;
				const offsetNode = this.offsetNode ? float( this.offsetNode ) : materialLineDashOffset;

				const instanceDistanceStart = attribute( 'instanceDistanceStart' );
				const instanceDistanceEnd = attribute( 'instanceDistanceEnd' );

				let lineDistance = positionGeometry.y.lessThan( 0.5 ).select( dashScaleNode.mul( instanceDistanceStart ), dashScaleNode.mul( instanceDistanceEnd ) );
				lineDistance = lineDistance.add( offsetNode );

				varyingProperty( 'float', 'lineDistance' ).assign( lineDistance );

			}

			if ( useWorldUnits ) {

				varyingProperty( 'vec3', 'worldStart' ).assign( start.xyz );
				varyingProperty( 'vec3', 'worldEnd' ).assign( end.xyz );

			}

			const aspect = viewport.z.div( viewport.w );

			// special case for perspective projection, and segments that terminate either in, or behind, the camera plane
			// clearly the gpu firmware has a way of addressing this issue when projecting into ndc space
			// but we need to perform ndc-space calculations in the shader, so we must address this issue directly
			// perhaps there is a more elegant solution -- WestLangley

			const perspective = cameraProjectionMatrix.element( 2 ).element( 3 ).equal( - 1.0 ); // 4th entry in the 3rd column

			If( perspective, () => {

				If( start.z.lessThan( 0.0 ).and( end.z.greaterThan( 0.0 ) ), () => {

					end.assign( trimSegment( { start: start, end: end } ) );

				} ).ElseIf( end.z.lessThan( 0.0 ).and( start.z.greaterThanEqual( 0.0 ) ), () => {

					start.assign( trimSegment( { start: end, end: start } ) );

			 	} );

			} );

			// clip space
			const clipStart = cameraProjectionMatrix.mul( start );
			const clipEnd = cameraProjectionMatrix.mul( end );

			// ndc space
			const ndcStart = clipStart.xyz.div( clipStart.w );
			const ndcEnd = clipEnd.xyz.div( clipEnd.w );

			// direction
			const dir = ndcEnd.xy.sub( ndcStart.xy ).toVar();

			// account for clip-space aspect ratio
			dir.x.assign( dir.x.mul( aspect ) );
			dir.assign( dir.normalize() );

			const clip = vec4().toVar();

			if ( useWorldUnits ) {

				// get the offset direction as perpendicular to the view vector

				const worldDir = end.xyz.sub( start.xyz ).normalize();
				const tmpFwd = mix( start.xyz, end.xyz, 0.5 ).normalize();
				const worldUp = worldDir.cross( tmpFwd ).normalize();
				const worldFwd = worldDir.cross( worldUp );

				const worldPos = varyingProperty( 'vec4', 'worldPos' );

				worldPos.assign( positionGeometry.y.lessThan( 0.5 ).select( start, end ) );

				// height offset
				const hw = materialLineWidth.mul( 0.5 );
				worldPos.addAssign( vec4( positionGeometry.x.lessThan( 0.0 ).select( worldUp.mul( hw ), worldUp.mul( hw ).negate() ), 0 ) );

				// don't extend the line if we're rendering dashes because we
				// won't be rendering the endcaps
				if ( ! useDash ) {

					// cap extension
					worldPos.addAssign( vec4( positionGeometry.y.lessThan( 0.5 ).select( worldDir.mul( hw ).negate(), worldDir.mul( hw ) ), 0 ) );

					// add width to the box
					worldPos.addAssign( vec4( worldFwd.mul( hw ), 0 ) );

					// endcaps
					If( positionGeometry.y.greaterThan( 1.0 ).or( positionGeometry.y.lessThan( 0.0 ) ), () => {

						worldPos.subAssign( vec4( worldFwd.mul( 2.0 ).mul( hw ), 0 ) );

					} );

				}

				// project the worldpos
				clip.assign( cameraProjectionMatrix.mul( worldPos ) );

				// shift the depth of the projected points so the line
				// segments overlap neatly
				const clipPose = vec3().toVar();

				clipPose.assign( positionGeometry.y.lessThan( 0.5 ).select( ndcStart, ndcEnd ) );
				clip.z.assign( clipPose.z.mul( clip.w ) );

			} else {

				const offset = vec2( dir.y, dir.x.negate() ).toVar( 'offset' );

				// undo aspect ratio adjustment
				dir.x.assign( dir.x.div( aspect ) );
				offset.x.assign( offset.x.div( aspect ) );

				// sign flip
				offset.assign( positionGeometry.x.lessThan( 0.0 ).select( offset.negate(), offset ) );

				// endcaps
				If( positionGeometry.y.lessThan( 0.0 ), () => {

					offset.assign( offset.sub( dir ) );

				} ).ElseIf( positionGeometry.y.greaterThan( 1.0 ), () => {

					offset.assign( offset.add( dir ) );

				} );

				// adjust for linewidth
				offset.assign( offset.mul( materialLineWidth ) );

				// adjust for clip-space to screen-space conversion // maybe resolution should be based on viewport ...
				offset.assign( offset.div( viewport.w ) );

				// select end
				clip.assign( positionGeometry.y.lessThan( 0.5 ).select( clipStart, clipEnd ) );

				// back to clip space
				offset.assign( offset.mul( clip.w ) );

				clip.assign( clip.add( vec4( offset, 0, 0 ) ) );

			}

			return clip;

		} )();

		const closestLineToLine = Fn( ( { p1, p2, p3, p4 } ) => {

			const p13 = p1.sub( p3 );
			const p43 = p4.sub( p3 );

			const p21 = p2.sub( p1 );

			const d1343 = p13.dot( p43 );
			const d4321 = p43.dot( p21 );
			const d1321 = p13.dot( p21 );
			const d4343 = p43.dot( p43 );
			const d2121 = p21.dot( p21 );

			const denom = d2121.mul( d4343 ).sub( d4321.mul( d4321 ) );
			const numer = d1343.mul( d4321 ).sub( d1321.mul( d4343 ) );

			const mua = numer.div( denom ).clamp();
			const mub = d1343.add( d4321.mul( mua ) ).div( d4343 ).clamp();

			return vec2( mua, mub );

		} );

		this.colorNode = Fn( () => {

			const vUv = uv();

			if ( useDash ) {

				const dashSizeNode = this.dashSizeNode ? float( this.dashSizeNode ) : materialLineDashSize;
				const gapSizeNode = this.gapSizeNode ? float( this.gapSizeNode ) : materialLineGapSize;

				dashSize.assign( dashSizeNode );
				gapSize.assign( gapSizeNode );

				const vLineDistance = varyingProperty( 'float', 'lineDistance' );

				vUv.y.lessThan( - 1.0 ).or( vUv.y.greaterThan( 1.0 ) ).discard(); // discard endcaps
				vLineDistance.mod( dashSize.add( gapSize ) ).greaterThan( dashSize ).discard(); // todo - FIX

			}

			const alpha = float( 1 ).toVar( 'alpha' );

			if ( useWorldUnits ) {

				const worldStart = varyingProperty( 'vec3', 'worldStart' );
				const worldEnd = varyingProperty( 'vec3', 'worldEnd' );

				// Find the closest points on the view ray and the line segment
				const rayEnd = varyingProperty( 'vec4', 'worldPos' ).xyz.normalize().mul( 1e5 );
				const lineDir = worldEnd.sub( worldStart );
				const params = closestLineToLine( { p1: worldStart, p2: worldEnd, p3: vec3( 0.0, 0.0, 0.0 ), p4: rayEnd } );

				const p1 = worldStart.add( lineDir.mul( params.x ) );
				const p2 = rayEnd.mul( params.y );
				const delta = p1.sub( p2 );
				const len = delta.length();
				const norm = len.div( materialLineWidth );

				if ( ! useDash ) {

					if ( useAlphaToCoverage && renderer.samples > 1 ) {

						const dnorm = norm.fwidth();
						alpha.assign( smoothstep( dnorm.negate().add( 0.5 ), dnorm.add( 0.5 ), norm ).oneMinus() );

					} else {

						norm.greaterThan( 0.5 ).discard();

					}

				}

			} else {

				// round endcaps

				if ( useAlphaToCoverage && renderer.samples > 1 ) {

					const a = vUv.x;
					const b = vUv.y.greaterThan( 0.0 ).select( vUv.y.sub( 1.0 ), vUv.y.add( 1.0 ) );

					const len2 = a.mul( a ).add( b.mul( b ) );

					const dlen = float( len2.fwidth() ).toVar( 'dlen' );

					If( vUv.y.abs().greaterThan( 1.0 ), () => {

						alpha.assign( smoothstep( dlen.oneMinus(), dlen.add( 1 ), len2 ).oneMinus() );

					} );

				} else {

					If( vUv.y.abs().greaterThan( 1.0 ), () => {

						const a = vUv.x;
						const b = vUv.y.greaterThan( 0.0 ).select( vUv.y.sub( 1.0 ), vUv.y.add( 1.0 ) );
						const len2 = a.mul( a ).add( b.mul( b ) );

						len2.greaterThan( 1.0 ).discard();

					} );

				}

			}

			let lineColorNode;

			if ( this.lineColorNode ) {

				lineColorNode = this.lineColorNode;

			} else {

				if ( useColor ) {

					const instanceColorStart = attribute( 'instanceColorStart' );
					const instanceColorEnd = attribute( 'instanceColorEnd' );

					const instanceColor = positionGeometry.y.lessThan( 0.5 ).select( instanceColorStart, instanceColorEnd );

					lineColorNode = instanceColor.mul( materialColor );

				} else {

					lineColorNode = materialColor;

				}

			}

			return vec4( lineColorNode, alpha );

		} )();

		if ( this.transparent ) {

			const opacityNode = this.opacityNode ? float( this.opacityNode ) : materialOpacity;

			this.outputNode = vec4( this.colorNode.rgb.mul( opacityNode ).add( viewportSharedTexture().rgb.mul( opacityNode.oneMinus() ) ), this.colorNode.a );

		}

	}


	get worldUnits() {

		return this.useWorldUnits;

	}

	set worldUnits( value ) {

		if ( this.useWorldUnits !== value ) {

			this.useWorldUnits = value;
			this.needsUpdate = true;

		}

	}


	get dashed() {

		return this.useDash;

	}

	set dashed( value ) {

		if ( this.useDash !== value ) {

			this.useDash = value;
			this.needsUpdate = true;

		}

	}


	get alphaToCoverage() {

		return this.useAlphaToCoverage;

	}

	set alphaToCoverage( value ) {

		if ( this.useAlphaToCoverage !== value ) {

			this.useAlphaToCoverage = value;
			this.needsUpdate = true;

		}

	}

}

/** @module Packing **/

/**
 * Packs a direction vector into a color value.
 *
 * @method
 * @param {Node<vec3>} node - The direction to pack.
 * @return {Node<vec3>} The color.
 */
const directionToColor = ( node ) => nodeObject( node ).mul( 0.5 ).add( 0.5 );

/**
 * Unpacks a color value into a direction vector.
 *
 * @method
 * @param {Node<vec3>} node - The color to unpack.
 * @return {Node<vec3>} The direction.
 */
const colorToDirection = ( node ) => nodeObject( node ).mul( 2.0 ).sub( 1 );

const _defaultValues$a = /*@__PURE__*/ new MeshNormalMaterial();

class MeshNormalNodeMaterial extends NodeMaterial {

	static get type() {

		return 'MeshNormalNodeMaterial';

	}

	constructor( parameters ) {

		super();

		this.lights = false;

		this.isMeshNormalNodeMaterial = true;

		this.setDefaultValues( _defaultValues$a );

		this.setValues( parameters );

	}

	setupDiffuseColor() {

		const opacityNode = this.opacityNode ? float( this.opacityNode ) : materialOpacity;

		diffuseColor.assign( vec4( directionToColor( transformedNormalView ), opacityNode ) );

	}

}

/** @module EquirectUVNode **/

/**
 * Can be used to compute texture coordinates for projecting an
 * equirectangular texture onto a mesh for using it as the scene's
 * background.
 *
 * ```js
 * scene.backgroundNode = texture( equirectTexture, equirectUV() );
 * ```
 *
 * @augments TempNode
 */
class EquirectUVNode extends TempNode {

	static get type() {

		return 'EquirectUVNode';

	}

	/**
	 * Constructs a new equirect uv node.
	 *
	 * @param {Node<vec3>} [dirNode=positionWorldDirection] - A direction vector for sampling which is by default `positionWorldDirection`.
	 */
	constructor( dirNode = positionWorldDirection ) {

		super( 'vec2' );

		/**
		 * A direction vector for sampling why is by default `positionWorldDirection`.
		 *
		 * @type {Node<vec3>}
		 */
		this.dirNode = dirNode;

	}

	setup() {

		const dir = this.dirNode;

		const u = dir.z.atan2( dir.x ).mul( 1 / ( Math.PI * 2 ) ).add( 0.5 );
		const v = dir.y.clamp( - 1.0, 1.0 ).asin().mul( 1 / Math.PI ).add( 0.5 );

		return vec2( u, v );

	}

}

/**
 * TSL function for creating an equirect uv node.
 *
 * @function
 * @param {Node<vec3>} [dirNode=positionWorldDirection] - A direction vector for sampling which is by default `positionWorldDirection`.
 * @returns {EquirectUVNode}
 */
const equirectUV = /*@__PURE__*/ nodeProxy( EquirectUVNode );

// @TODO: Consider rename WebGLCubeRenderTarget to just CubeRenderTarget

class CubeRenderTarget extends WebGLCubeRenderTarget {

	constructor( size = 1, options = {} ) {

		super( size, options );

		this.isCubeRenderTarget = true;

	}

	fromEquirectangularTexture( renderer, texture$1 ) {

		const currentMinFilter = texture$1.minFilter;
		const currentGenerateMipmaps = texture$1.generateMipmaps;

		texture$1.generateMipmaps = true;

		this.texture.type = texture$1.type;
		this.texture.colorSpace = texture$1.colorSpace;

		this.texture.generateMipmaps = texture$1.generateMipmaps;
		this.texture.minFilter = texture$1.minFilter;
		this.texture.magFilter = texture$1.magFilter;

		const geometry = new BoxGeometry( 5, 5, 5 );

		const uvNode = equirectUV( positionWorldDirection );

		const material = new NodeMaterial();
		material.colorNode = texture( texture$1, uvNode, 0 );
		material.side = BackSide;
		material.blending = NoBlending;

		const mesh = new Mesh( geometry, material );

		const scene = new Scene();
		scene.add( mesh );

		// Avoid blurred poles
		if ( texture$1.minFilter === LinearMipmapLinearFilter ) texture$1.minFilter = LinearFilter;

		const camera = new CubeCamera( 1, 10, this );

		const currentMRT = renderer.getMRT();
		renderer.setMRT( null );

		camera.update( renderer, scene );

		renderer.setMRT( currentMRT );

		texture$1.minFilter = currentMinFilter;
		texture$1.currentGenerateMipmaps = currentGenerateMipmaps;

		mesh.geometry.dispose();
		mesh.material.dispose();

		return this;

	}

}

/** @module CubeMapNode **/

const _cache$1 = new WeakMap();

/**
 * This node can be used to automatically convert environment maps in the
 * equirectangular format into the cube map format.
 *
 * @augments TempNode
 */
class CubeMapNode extends TempNode {

	static get type() {

		return 'CubeMapNode';

	}

	/**
	 * Constructs a new cube map node.
	 *
	 * @param {Node} envNode - The node representing the environment map.
	 */
	constructor( envNode ) {

		super( 'vec3' );

		/**
		 * The node representing the environment map.
		 *
		 * @type {Node}
		 */
		this.envNode = envNode;

		/**
		 * A reference to the internal cube texture.
		 *
		 * @private
		 * @type {CubeTexture}
		 * @default null
		 */
		this._cubeTexture = null;

		/**
		 * A reference to the internal cube texture node.
		 *
		 * @private
		 * @type {CubeTextureNode}
		 */
		this._cubeTextureNode = cubeTexture();

		const defaultTexture = new CubeTexture();
		defaultTexture.isRenderTargetTexture = true;

		/**
		 * A default cube texture that acts as a placeholder.
		 * It is used when the conversion from equirectangular to cube
		 * map has not finished yet for a given texture.
		 *
		 * @private
		 * @type {CubeTexture}
		 */
		this._defaultTexture = defaultTexture;

		/**
		 * The `updateBeforeType` is set to `NodeUpdateType.RENDER` since the node updates
		 * the texture once per render in its {@link CubeMapNode#updateBefore} method.
		 *
		 * @type {String}
		 * @default 'render'
		 */
		this.updateBeforeType = NodeUpdateType.RENDER;

	}

	updateBefore( frame ) {

		const { renderer, material } = frame;

		const envNode = this.envNode;

		if ( envNode.isTextureNode || envNode.isMaterialReferenceNode ) {

			const texture = ( envNode.isTextureNode ) ? envNode.value : material[ envNode.property ];

			if ( texture && texture.isTexture ) {

				const mapping = texture.mapping;

				if ( mapping === EquirectangularReflectionMapping || mapping === EquirectangularRefractionMapping ) {

					// check for converted cubemap map

					if ( _cache$1.has( texture ) ) {

						const cubeMap = _cache$1.get( texture );

						mapTextureMapping( cubeMap, texture.mapping );
						this._cubeTexture = cubeMap;

					} else {

						// create cube map from equirectangular map

						const image = texture.image;

						if ( isEquirectangularMapReady$1( image ) ) {

							const renderTarget = new CubeRenderTarget( image.height );
							renderTarget.fromEquirectangularTexture( renderer, texture );

							mapTextureMapping( renderTarget.texture, texture.mapping );
							this._cubeTexture = renderTarget.texture;

							_cache$1.set( texture, renderTarget.texture );

							texture.addEventListener( 'dispose', onTextureDispose );

						} else {

							// default cube texture as fallback when equirectangular texture is not yet loaded

							this._cubeTexture = this._defaultTexture;

						}

					}

					//

					this._cubeTextureNode.value = this._cubeTexture;

				} else {

					// envNode already refers to a cube map

					this._cubeTextureNode = this.envNode;

				}

			}

		}

	}

	setup( builder ) {

		this.updateBefore( builder );

		return this._cubeTextureNode;

	}

}

/**
 * Returns true if the given equirectangular image has been fully loaded
 * and is ready for further processing.
 *
 * @private
 * @param {Image} image - The equirectangular image to check.
 * @return {Boolean} Whether the image is ready or not.
 */
function isEquirectangularMapReady$1( image ) {

	if ( image === null || image === undefined ) return false;

	return image.height > 0;

}

/**
 * This function is executed when `dispose()` is called on the equirectangular
 * texture. In this case, the generated cube map with its render target
 * is deleted as well.
 *
 * @private
 * @param {Object} event - The event object.
 */
function onTextureDispose( event ) {

	const texture = event.target;

	texture.removeEventListener( 'dispose', onTextureDispose );

	const renderTarget = _cache$1.get( texture );

	if ( renderTarget !== undefined ) {

		_cache$1.delete( texture );

		renderTarget.dispose();

	}

}

/**
 * This function makes sure the generated cube map uses the correct
 * texture mapping that corresponds to the equirectangular original.
 *
 * @private
 * @param {Texture} texture - The cube texture.
 * @param {Number} mapping - The original texture mapping.
 */
function mapTextureMapping( texture, mapping ) {

	if ( mapping === EquirectangularReflectionMapping ) {

		texture.mapping = CubeReflectionMapping;

	} else if ( mapping === EquirectangularRefractionMapping ) {

		texture.mapping = CubeRefractionMapping;

	}

}

/**
 * TSL function for creating a cube map node.
 *
 * @function
 * @param {Node} envNode - The node representing the environment map.
 * @returns {CubeMapNode}
 */
const cubeMapNode = /*@__PURE__*/ nodeProxy( CubeMapNode );

/**
 * Represents a basic model for Image-based lighting (IBL). The environment
 * is defined via environment maps in the equirectanular or cube map format.
 * `BasicEnvironmentNode` is intended for non-PBR materials like {@link MeshBasicNodeMaterial}
 * or {@link MeshPhongNodeMaterial}.
 *
 * @augments LightingNode
 */
class BasicEnvironmentNode extends LightingNode {

	static get type() {

		return 'BasicEnvironmentNode';

	}

	/**
	 * Constructs a new basic environment node.
	 *
	 * @param {Node} [envNode=null] - A node representing the environment.
	 */
	constructor( envNode = null ) {

		super();

		/**
		 * A node representing the environment.
		 *
		 * @type {Node}
		 * @default null
		 */
		this.envNode = envNode;

	}

	setup( builder ) {

		// environment property is used in the finish() method of BasicLightingModel

		builder.context.environment = cubeMapNode( this.envNode );

	}

}

/**
 * A specific version of {@link IrradianceNode} that is only relevant
 * for {@link MeshBasicNodeMaterial}. Since the material is unlit, it
 * requires a special scaling factor for the light map.
 *
 * @augments LightingNode
 */
class BasicLightMapNode extends LightingNode {

	static get type() {

		return 'BasicLightMapNode';

	}

	/**
	 * Constructs a new basic light map node.
	 *
	 * @param {Node<vec3>?} [lightMapNode=null] - The light map node.
	 */
	constructor( lightMapNode = null ) {

		super();

		/**
		 * The light map node.
		 *
		 * @type {Node<vec3>?}
		 */
		this.lightMapNode = lightMapNode;

	}

	setup( builder ) {

		// irradianceLightMap property is used in the indirectDiffuse() method of BasicLightingModel

		const RECIPROCAL_PI = float( 1 / Math.PI );

		builder.context.irradianceLightMap = this.lightMapNode.mul( RECIPROCAL_PI );

	}

}

/**
 * Abstract class for implementing lighting models. The module defines
 * multiple methods that concrete lighting models can implement. These
 * methods are executed at different points during the light evaluation
 * process.
 */
class LightingModel {

	/**
	 * This method is intended for setting up lighting model and context data
	 * which are later used in the evaluation process.
	 *
	 * @abstract
	 * @param {ContextNode} input - The current node context.
	 * @param {StackNode} stack - The current stack.
	 * @param {NodeBuilder} builder - The current node builder.
	 */
	start( /*input, stack, builder*/ ) { }

	/**
	 * This method is intended for executing final tasks like final updates
	 * to the outgoing light.
	 *
	 * @abstract
	 * @param {ContextNode} input - The current node context.
	 * @param {StackNode} stack - The current stack.
	 * @param {NodeBuilder} builder - The current node builder.
	 */
	finish( /*input, stack, builder*/ ) { }

	/**
	 * This method is intended for implementing the direct light term and
	 * executed during the build process of directional, point and spot light nodes.
	 *
	 * @abstract
	 * @param {Object} input - The input data.
	 * @param {StackNode} stack - The current stack.
	 * @param {NodeBuilder} builder - The current node builder.
	 */
	direct( /*input, stack, builder*/ ) { }

	/**
	 * This method is intended for implementing the direct light term for
	 * rect area light nodes.
	 *
	 * @abstract
	 * @param {Object} input - The input data.
	 * @param {StackNode} stack - The current stack.
	 * @param {NodeBuilder} builder - The current node builder.
	 */
	directRectArea( /*input, stack, builder*/ ) {}

	/**
	 * This method is intended for implementing the indirect light term.
	 *
	 * @abstract
	 * @param {ContextNode} input - The current node context.
	 * @param {StackNode} stack - The current stack.
	 * @param {NodeBuilder} builder - The current node builder.
	 */
	indirect( /*input, stack, builder*/ ) { }

	/**
	 * This method is intended for implementing the ambient occlusion term.
	 * Unlike other methods, this method must be called manually by the lighting
	 * model in its indirect term.
	 *
	 * @abstract
	 * @param {ContextNode} input - The current node context.
	 * @param {StackNode} stack - The current stack.
	 * @param {NodeBuilder} builder - The current node builder.
	 */
	ambientOcclusion( /*input, stack, builder*/ ) { }

}

/**
 * Represents the lighting model for unlit materials. The only light contribution
 * is baked indirect lighting modulated with ambient occlusion and the material's
 * diffuse color. Environment mapping is supported. Used in {@link MeshBasicNodeMaterial}.
 *
 * @augments LightingModel
 */
class BasicLightingModel extends LightingModel {

	/**
	 * Constructs a new basic lighting model.
	 */
	constructor() {

		super();

	}

	/**
	 * Implements the baked indirect lighting with its modulation.
	 *
	 * @param {ContextNode} context - The current node context.
	 * @param {StackNode} stack - The current stack.
	 * @param {NodeBuilder} builder - The current node builder.
	 */
	indirect( context, stack, builder ) {

		const ambientOcclusion = context.ambientOcclusion;
		const reflectedLight = context.reflectedLight;
		const irradianceLightMap = builder.context.irradianceLightMap;

		reflectedLight.indirectDiffuse.assign( vec4( 0.0 ) );

		// accumulation (baked indirect lighting only)

		if ( irradianceLightMap ) {

			reflectedLight.indirectDiffuse.addAssign( irradianceLightMap );

		} else {

			reflectedLight.indirectDiffuse.addAssign( vec4( 1.0, 1.0, 1.0, 0.0 ) );

		}

		// modulation

		reflectedLight.indirectDiffuse.mulAssign( ambientOcclusion );

		reflectedLight.indirectDiffuse.mulAssign( diffuseColor.rgb );

	}

	/**
	 * Implements the environment mapping.
	 *
	 * @param {ContextNode} context - The current node context.
	 * @param {StackNode} stack - The current stack.
	 * @param {NodeBuilder} builder - The current node builder.
	 */
	finish( context, stack, builder ) {

		const material = builder.material;
		const outgoingLight = context.outgoingLight;
		const envNode = builder.context.environment;

		if ( envNode ) {

			switch ( material.combine ) {

				case MultiplyOperation:
					outgoingLight.rgb.assign( mix( outgoingLight.rgb, outgoingLight.rgb.mul( envNode.rgb ), materialSpecularStrength.mul( materialReflectivity ) ) );
					break;

				case MixOperation:
					outgoingLight.rgb.assign( mix( outgoingLight.rgb, envNode.rgb, materialSpecularStrength.mul( materialReflectivity ) ) );
					break;

				case AddOperation:
					outgoingLight.rgb.addAssign( envNode.rgb.mul( materialSpecularStrength.mul( materialReflectivity ) ) );
					break;

				default:
					console.warn( 'THREE.BasicLightingModel: Unsupported .combine value:', material.combine );
					break;

			}

		}

	}

}

const _defaultValues$9 = /*@__PURE__*/ new MeshBasicMaterial();

class MeshBasicNodeMaterial extends NodeMaterial {

	static get type() {

		return 'MeshBasicNodeMaterial';

	}

	constructor( parameters ) {

		super();

		this.isMeshBasicNodeMaterial = true;

		this.lights = true;

		this.setDefaultValues( _defaultValues$9 );

		this.setValues( parameters );

	}

	setupNormal() {

		return normalView; // see #28839

	}

	setupEnvironment( builder ) {

		const envNode = super.setupEnvironment( builder );

		return envNode ? new BasicEnvironmentNode( envNode ) : null;

	}

	setupLightMap( builder ) {

		let node = null;

		if ( builder.material.lightMap ) {

			node = new BasicLightMapNode( materialLightMap );

		}

		return node;

	}

	setupOutgoingLight() {

		return diffuseColor.rgb;

	}

	setupLightingModel() {

		return new BasicLightingModel();

	}

}

const F_Schlick = /*@__PURE__*/ Fn( ( { f0, f90, dotVH } ) => {

	// Original approximation by Christophe Schlick '94
	// float fresnel = pow( 1.0 - dotVH, 5.0 );

	// Optimized variant (presented by Epic at SIGGRAPH '13)
	// https://cdn2.unrealengine.com/Resources/files/2013SiggraphPresentationsNotes-26915738.pdf
	const fresnel = dotVH.mul( - 5.55473 ).sub( 6.98316 ).mul( dotVH ).exp2();

	return f0.mul( fresnel.oneMinus() ).add( f90.mul( fresnel ) );

} ); // validated

const BRDF_Lambert = /*@__PURE__*/ Fn( ( inputs ) => {

	return inputs.diffuseColor.mul( 1 / Math.PI ); // punctual light

} ); // validated

const G_BlinnPhong_Implicit = () => float( 0.25 );

const D_BlinnPhong = /*@__PURE__*/ Fn( ( { dotNH } ) => {

	return shininess.mul( float( 0.5 ) ).add( 1.0 ).mul( float( 1 / Math.PI ) ).mul( dotNH.pow( shininess ) );

} );

const BRDF_BlinnPhong = /*@__PURE__*/ Fn( ( { lightDirection } ) => {

	const halfDir = lightDirection.add( positionViewDirection ).normalize();

	const dotNH = transformedNormalView.dot( halfDir ).clamp();
	const dotVH = positionViewDirection.dot( halfDir ).clamp();

	const F = F_Schlick( { f0: specularColor, f90: 1.0, dotVH } );
	const G = G_BlinnPhong_Implicit();
	const D = D_BlinnPhong( { dotNH } );

	return F.mul( G ).mul( D );

} );

/**
 * Represents the lighting model for a phong material. Used in {@link MeshPhongNodeMaterial}.
 *
 * @augments BasicLightingModel
 */
class PhongLightingModel extends BasicLightingModel {

	/**
	 * Constructs a new phong lighting model.
	 *
	 * @param {Boolean} [specular=true] - Whether specular is supported or not.
	 */
	constructor( specular = true ) {

		super();

		/**
		 * Whether specular is supported or not. Set this to `false` if you are
		 * looking for a Lambert-like material meaning a material for non-shiny
		 * surfaces, without specular highlights.
		 *
		 * @type {Boolean}
		 * @default true
		 */
		this.specular = specular;

	}

	/**
	 * Implements the direct lighting. The specular portion is optional an can be controlled
	 * with the {@link PhongLightingModel#specular} flag.
	 *
	 * @param {Object} input - The input data.
	 * @param {StackNode} stack - The current stack.
	 * @param {NodeBuilder} builder - The current node builder.
	 */
	direct( { lightDirection, lightColor, reflectedLight } ) {

		const dotNL = transformedNormalView.dot( lightDirection ).clamp();
		const irradiance = dotNL.mul( lightColor );

		reflectedLight.directDiffuse.addAssign( irradiance.mul( BRDF_Lambert( { diffuseColor: diffuseColor.rgb } ) ) );

		if ( this.specular === true ) {

			reflectedLight.directSpecular.addAssign( irradiance.mul( BRDF_BlinnPhong( { lightDirection } ) ).mul( materialSpecularStrength ) );

		}

	}

	/**
	 * Implements the indirect lighting.
	 *
	 * @param {ContextNode} input - The current node context.
	 * @param {StackNode} stack - The current stack.
	 * @param {NodeBuilder} builder - The current node builder.
	 */
	indirect( { ambientOcclusion, irradiance, reflectedLight } ) {

		reflectedLight.indirectDiffuse.addAssign( irradiance.mul( BRDF_Lambert( { diffuseColor } ) ) );

		reflectedLight.indirectDiffuse.mulAssign( ambientOcclusion );

	}

}

const _defaultValues$8 = /*@__PURE__*/ new MeshLambertMaterial();

class MeshLambertNodeMaterial extends NodeMaterial {

	static get type() {

		return 'MeshLambertNodeMaterial';

	}

	constructor( parameters ) {

		super();

		this.isMeshLambertNodeMaterial = true;

		this.lights = true;

		this.setDefaultValues( _defaultValues$8 );

		this.setValues( parameters );

	}

	setupEnvironment( builder ) {

		const envNode = super.setupEnvironment( builder );

		return envNode ? new BasicEnvironmentNode( envNode ) : null;

	}

	setupLightingModel( /*builder*/ ) {

		return new PhongLightingModel( false ); // ( specular ) -> force lambert

	}

}

const _defaultValues$7 = /*@__PURE__*/ new MeshPhongMaterial();

class MeshPhongNodeMaterial extends NodeMaterial {

	static get type() {

		return 'MeshPhongNodeMaterial';

	}

	constructor( parameters ) {

		super();

		this.isMeshPhongNodeMaterial = true;

		this.lights = true;

		this.shininessNode = null;
		this.specularNode = null;

		this.setDefaultValues( _defaultValues$7 );

		this.setValues( parameters );

	}

	setupEnvironment( builder ) {

		const envNode = super.setupEnvironment( builder );

		return envNode ? new BasicEnvironmentNode( envNode ) : null;

	}

	setupLightingModel( /*builder*/ ) {

		return new PhongLightingModel();

	}

	setupVariants() {

		// SHININESS

		const shininessNode = ( this.shininessNode ? float( this.shininessNode ) : materialShininess ).max( 1e-4 ); // to prevent pow( 0.0, 0.0 )

		shininess.assign( shininessNode );

		// SPECULAR COLOR

		const specularNode = this.specularNode || materialSpecular;

		specularColor.assign( specularNode );

	}

	copy( source ) {

		this.shininessNode = source.shininessNode;
		this.specularNode = source.specularNode;

		return super.copy( source );

	}

}

const getGeometryRoughness = /*@__PURE__*/ Fn( ( builder ) => {

	if ( builder.geometry.hasAttribute( 'normal' ) === false ) {

		return float( 0 );

	}

	const dxy = normalView.dFdx().abs().max( normalView.dFdy().abs() );
	const geometryRoughness = dxy.x.max( dxy.y ).max( dxy.z );

	return geometryRoughness;

} );

const getRoughness = /*@__PURE__*/ Fn( ( inputs ) => {

	const { roughness } = inputs;

	const geometryRoughness = getGeometryRoughness();

	let roughnessFactor = roughness.max( 0.0525 ); // 0.0525 corresponds to the base mip of a 256 cubemap.
	roughnessFactor = roughnessFactor.add( geometryRoughness );
	roughnessFactor = roughnessFactor.min( 1.0 );

	return roughnessFactor;

} );

// Moving Frostbite to Physically Based Rendering 3.0 - page 12, listing 2
// https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
const V_GGX_SmithCorrelated = /*@__PURE__*/ Fn( ( { alpha, dotNL, dotNV } ) => {

	const a2 = alpha.pow2();

	const gv = dotNL.mul( a2.add( a2.oneMinus().mul( dotNV.pow2() ) ).sqrt() );
	const gl = dotNV.mul( a2.add( a2.oneMinus().mul( dotNL.pow2() ) ).sqrt() );

	return div( 0.5, gv.add( gl ).max( EPSILON ) );

} ).setLayout( {
	name: 'V_GGX_SmithCorrelated',
	type: 'float',
	inputs: [
		{ name: 'alpha', type: 'float' },
		{ name: 'dotNL', type: 'float' },
		{ name: 'dotNV', type: 'float' }
	]
} ); // validated

// https://google.github.io/filament/Filament.md.html#materialsystem/anisotropicmodel/anisotropicspecularbrdf

const V_GGX_SmithCorrelated_Anisotropic = /*@__PURE__*/ Fn( ( { alphaT, alphaB, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL } ) => {

	const gv = dotNL.mul( vec3( alphaT.mul( dotTV ), alphaB.mul( dotBV ), dotNV ).length() );
	const gl = dotNV.mul( vec3( alphaT.mul( dotTL ), alphaB.mul( dotBL ), dotNL ).length() );
	const v = div( 0.5, gv.add( gl ) );

	return v.saturate();

} ).setLayout( {
	name: 'V_GGX_SmithCorrelated_Anisotropic',
	type: 'float',
	inputs: [
		{ name: 'alphaT', type: 'float', qualifier: 'in' },
		{ name: 'alphaB', type: 'float', qualifier: 'in' },
		{ name: 'dotTV', type: 'float', qualifier: 'in' },
		{ name: 'dotBV', type: 'float', qualifier: 'in' },
		{ name: 'dotTL', type: 'float', qualifier: 'in' },
		{ name: 'dotBL', type: 'float', qualifier: 'in' },
		{ name: 'dotNV', type: 'float', qualifier: 'in' },
		{ name: 'dotNL', type: 'float', qualifier: 'in' }
	]
} );

// Microfacet Models for Refraction through Rough Surfaces - equation (33)
// http://graphicrants.blogspot.com/2013/08/specular-brdf-reference.html
// alpha is "roughness squared" in Disney’s reparameterization
const D_GGX = /*@__PURE__*/ Fn( ( { alpha, dotNH } ) => {

	const a2 = alpha.pow2();

	const denom = dotNH.pow2().mul( a2.oneMinus() ).oneMinus(); // avoid alpha = 0 with dotNH = 1

	return a2.div( denom.pow2() ).mul( 1 / Math.PI );

} ).setLayout( {
	name: 'D_GGX',
	type: 'float',
	inputs: [
		{ name: 'alpha', type: 'float' },
		{ name: 'dotNH', type: 'float' }
	]
} ); // validated

const RECIPROCAL_PI = /*@__PURE__*/ float( 1 / Math.PI );

// https://google.github.io/filament/Filament.md.html#materialsystem/anisotropicmodel/anisotropicspecularbrdf

const D_GGX_Anisotropic = /*@__PURE__*/ Fn( ( { alphaT, alphaB, dotNH, dotTH, dotBH } ) => {

	const a2 = alphaT.mul( alphaB );
	const v = vec3( alphaB.mul( dotTH ), alphaT.mul( dotBH ), a2.mul( dotNH ) );
	const v2 = v.dot( v );
	const w2 = a2.div( v2 );

	return RECIPROCAL_PI.mul( a2.mul( w2.pow2() ) );

} ).setLayout( {
	name: 'D_GGX_Anisotropic',
	type: 'float',
	inputs: [
		{ name: 'alphaT', type: 'float', qualifier: 'in' },
		{ name: 'alphaB', type: 'float', qualifier: 'in' },
		{ name: 'dotNH', type: 'float', qualifier: 'in' },
		{ name: 'dotTH', type: 'float', qualifier: 'in' },
		{ name: 'dotBH', type: 'float', qualifier: 'in' }
	]
} );

// GGX Distribution, Schlick Fresnel, GGX_SmithCorrelated Visibility
const BRDF_GGX = /*@__PURE__*/ Fn( ( inputs ) => {

	const { lightDirection, f0, f90, roughness, f, USE_IRIDESCENCE, USE_ANISOTROPY } = inputs;

	const normalView = inputs.normalView || transformedNormalView;

	const alpha = roughness.pow2(); // UE4's roughness

	const halfDir = lightDirection.add( positionViewDirection ).normalize();

	const dotNL = normalView.dot( lightDirection ).clamp();
	const dotNV = normalView.dot( positionViewDirection ).clamp(); // @ TODO: Move to core dotNV
	const dotNH = normalView.dot( halfDir ).clamp();
	const dotVH = positionViewDirection.dot( halfDir ).clamp();

	let F = F_Schlick( { f0, f90, dotVH } );
	let V, D;

	if ( defined( USE_IRIDESCENCE ) ) {

		F = iridescence.mix( F, f );

	}

	if ( defined( USE_ANISOTROPY ) ) {

		const dotTL = anisotropyT.dot( lightDirection );
		const dotTV = anisotropyT.dot( positionViewDirection );
		const dotTH = anisotropyT.dot( halfDir );
		const dotBL = anisotropyB.dot( lightDirection );
		const dotBV = anisotropyB.dot( positionViewDirection );
		const dotBH = anisotropyB.dot( halfDir );

		V = V_GGX_SmithCorrelated_Anisotropic( { alphaT, alphaB: alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL } );
		D = D_GGX_Anisotropic( { alphaT, alphaB: alpha, dotNH, dotTH, dotBH } );

	} else {

		V = V_GGX_SmithCorrelated( { alpha, dotNL, dotNV } );
		D = D_GGX( { alpha, dotNH } );

	}

	return F.mul( V ).mul( D );

} ); // validated

// Analytical approximation of the DFG LUT, one half of the
// split-sum approximation used in indirect specular lighting.
// via 'environmentBRDF' from "Physically Based Shading on Mobile"
// https://www.unrealengine.com/blog/physically-based-shading-on-mobile
const DFGApprox = /*@__PURE__*/ Fn( ( { roughness, dotNV } ) => {

	const c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );

	const c1 = vec4( 1, 0.0425, 1.04, - 0.04 );

	const r = roughness.mul( c0 ).add( c1 );

	const a004 = r.x.mul( r.x ).min( dotNV.mul( - 9.28 ).exp2() ).mul( r.x ).add( r.y );

	const fab = vec2( - 1.04, 1.04 ).mul( a004 ).add( r.zw );

	return fab;

} ).setLayout( {
	name: 'DFGApprox',
	type: 'vec2',
	inputs: [
		{ name: 'roughness', type: 'float' },
		{ name: 'dotNV', type: 'vec3' }
	]
} );

const EnvironmentBRDF = /*@__PURE__*/ Fn( ( inputs ) => {

	const { dotNV, specularColor, specularF90, roughness } = inputs;

	const fab = DFGApprox( { dotNV, roughness } );
	return specularColor.mul( fab.x ).add( specularF90.mul( fab.y ) );

} );

const Schlick_to_F0 = /*@__PURE__*/ Fn( ( { f, f90, dotVH } ) => {

	const x = dotVH.oneMinus().saturate();
	const x2 = x.mul( x );
	const x5 = x.mul( x2, x2 ).clamp( 0, .9999 );

	return f.sub( vec3( f90 ).mul( x5 ) ).div( x5.oneMinus() );

} ).setLayout( {
	name: 'Schlick_to_F0',
	type: 'vec3',
	inputs: [
		{ name: 'f', type: 'vec3' },
		{ name: 'f90', type: 'float' },
		{ name: 'dotVH', type: 'float' }
	]
} );

// https://github.com/google/filament/blob/master/shaders/src/brdf.fs
const D_Charlie = /*@__PURE__*/ Fn( ( { roughness, dotNH } ) => {

	const alpha = roughness.pow2();

	// Estevez and Kulla 2017, "Production Friendly Microfacet Sheen BRDF"
	const invAlpha = float( 1.0 ).div( alpha );
	const cos2h = dotNH.pow2();
	const sin2h = cos2h.oneMinus().max( 0.0078125 ); // 2^(-14/2), so sin2h^2 > 0 in fp16

	return float( 2.0 ).add( invAlpha ).mul( sin2h.pow( invAlpha.mul( 0.5 ) ) ).div( 2.0 * Math.PI );

} ).setLayout( {
	name: 'D_Charlie',
	type: 'float',
	inputs: [
		{ name: 'roughness', type: 'float' },
		{ name: 'dotNH', type: 'float' }
	]
} );

// https://github.com/google/filament/blob/master/shaders/src/brdf.fs
const V_Neubelt = /*@__PURE__*/ Fn( ( { dotNV, dotNL } ) => {

	// Neubelt and Pettineo 2013, "Crafting a Next-gen Material Pipeline for The Order: 1886"
	return float( 1.0 ).div( float( 4.0 ).mul( dotNL.add( dotNV ).sub( dotNL.mul( dotNV ) ) ) );

} ).setLayout( {
	name: 'V_Neubelt',
	type: 'float',
	inputs: [
		{ name: 'dotNV', type: 'float' },
		{ name: 'dotNL', type: 'float' }
	]
} );

const BRDF_Sheen = /*@__PURE__*/ Fn( ( { lightDirection } ) => {

	const halfDir = lightDirection.add( positionViewDirection ).normalize();

	const dotNL = transformedNormalView.dot( lightDirection ).clamp();
	const dotNV = transformedNormalView.dot( positionViewDirection ).clamp();
	const dotNH = transformedNormalView.dot( halfDir ).clamp();

	const D = D_Charlie( { roughness: sheenRoughness, dotNH } );
	const V = V_Neubelt( { dotNV, dotNL } );

	return sheen.mul( D ).mul( V );

} );

// Rect Area Light

// Real-Time Polygonal-Light Shading with Linearly Transformed Cosines
// by Eric Heitz, Jonathan Dupuy, Stephen Hill and David Neubelt
// code: https://github.com/selfshadow/ltc_code/

const LTC_Uv = /*@__PURE__*/ Fn( ( { N, V, roughness } ) => {

	const LUT_SIZE = 64.0;
	const LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const LUT_BIAS = 0.5 / LUT_SIZE;

	const dotNV = N.dot( V ).saturate();

	// texture parameterized by sqrt( GGX alpha ) and sqrt( 1 - cos( theta ) )
	const uv = vec2( roughness, dotNV.oneMinus().sqrt() );

	uv.assign( uv.mul( LUT_SCALE ).add( LUT_BIAS ) );

	return uv;

} ).setLayout( {
	name: 'LTC_Uv',
	type: 'vec2',
	inputs: [
		{ name: 'N', type: 'vec3' },
		{ name: 'V', type: 'vec3' },
		{ name: 'roughness', type: 'float' }
	]
} );

const LTC_ClippedSphereFormFactor = /*@__PURE__*/ Fn( ( { f } ) => {

	// Real-Time Area Lighting: a Journey from Research to Production (p.102)
	// An approximation of the form factor of a horizon-clipped rectangle.

	const l = f.length();

	return max$1( l.mul( l ).add( f.z ).div( l.add( 1.0 ) ), 0 );

} ).setLayout( {
	name: 'LTC_ClippedSphereFormFactor',
	type: 'float',
	inputs: [
		{ name: 'f', type: 'vec3' }
	]
} );

const LTC_EdgeVectorFormFactor = /*@__PURE__*/ Fn( ( { v1, v2 } ) => {

	const x = v1.dot( v2 );
	const y = x.abs().toVar();

	// rational polynomial approximation to theta / sin( theta ) / 2PI
	const a = y.mul( 0.0145206 ).add( 0.4965155 ).mul( y ).add( 0.8543985 ).toVar();
	const b = y.add( 4.1616724 ).mul( y ).add( 3.4175940 ).toVar();
	const v = a.div( b );

	const theta_sintheta = x.greaterThan( 0.0 ).select( v, max$1( x.mul( x ).oneMinus(), 1e-7 ).inverseSqrt().mul( 0.5 ).sub( v ) );

	return v1.cross( v2 ).mul( theta_sintheta );

} ).setLayout( {
	name: 'LTC_EdgeVectorFormFactor',
	type: 'vec3',
	inputs: [
		{ name: 'v1', type: 'vec3' },
		{ name: 'v2', type: 'vec3' }
	]
} );

const LTC_Evaluate = /*@__PURE__*/ Fn( ( { N, V, P, mInv, p0, p1, p2, p3 } ) => {

	// bail if point is on back side of plane of light
	// assumes ccw winding order of light vertices
	const v1 = p1.sub( p0 ).toVar();
	const v2 = p3.sub( p0 ).toVar();

	const lightNormal = v1.cross( v2 );
	const result = vec3().toVar();

	If( lightNormal.dot( P.sub( p0 ) ).greaterThanEqual( 0.0 ), () => {

		// construct orthonormal basis around N
		const T1 = V.sub( N.mul( V.dot( N ) ) ).normalize();
		const T2 = N.cross( T1 ).negate(); // negated from paper; possibly due to a different handedness of world coordinate system

		// compute transform
		const mat = mInv.mul( mat3( T1, T2, N ).transpose() ).toVar();

		// transform rect
		// & project rect onto sphere
		const coords0 = mat.mul( p0.sub( P ) ).normalize().toVar();
		const coords1 = mat.mul( p1.sub( P ) ).normalize().toVar();
		const coords2 = mat.mul( p2.sub( P ) ).normalize().toVar();
		const coords3 = mat.mul( p3.sub( P ) ).normalize().toVar();

		// calculate vector form factor
		const vectorFormFactor = vec3( 0 ).toVar();
		vectorFormFactor.addAssign( LTC_EdgeVectorFormFactor( { v1: coords0, v2: coords1 } ) );
		vectorFormFactor.addAssign( LTC_EdgeVectorFormFactor( { v1: coords1, v2: coords2 } ) );
		vectorFormFactor.addAssign( LTC_EdgeVectorFormFactor( { v1: coords2, v2: coords3 } ) );
		vectorFormFactor.addAssign( LTC_EdgeVectorFormFactor( { v1: coords3, v2: coords0 } ) );

		// adjust for horizon clipping
		result.assign( vec3( LTC_ClippedSphereFormFactor( { f: vectorFormFactor } ) ) );

	} );

	return result;

} ).setLayout( {
	name: 'LTC_Evaluate',
	type: 'vec3',
	inputs: [
		{ name: 'N', type: 'vec3' },
		{ name: 'V', type: 'vec3' },
		{ name: 'P', type: 'vec3' },
		{ name: 'mInv', type: 'mat3' },
		{ name: 'p0', type: 'vec3' },
		{ name: 'p1', type: 'vec3' },
		{ name: 'p2', type: 'vec3' },
		{ name: 'p3', type: 'vec3' }
	]
} );

// Mipped Bicubic Texture Filtering by N8
// https://www.shadertoy.com/view/Dl2SDW

const bC = 1.0 / 6.0;

const w0 = ( a ) => mul( bC, mul( a, mul( a, a.negate().add( 3.0 ) ).sub( 3.0 ) ).add( 1.0 ) );

const w1 = ( a ) => mul( bC, mul( a, mul( a, mul( 3.0, a ).sub( 6.0 ) ) ).add( 4.0 ) );

const w2 = ( a ) => mul( bC, mul( a, mul( a, mul( - 3.0, a ).add( 3.0 ) ).add( 3.0 ) ).add( 1.0 ) );

const w3 = ( a ) => mul( bC, pow( a, 3 ) );

const g0 = ( a ) => w0( a ).add( w1( a ) );

const g1 = ( a ) => w2( a ).add( w3( a ) );

// h0 and h1 are the two offset functions
const h0 = ( a ) => add( - 1.0, w1( a ).div( w0( a ).add( w1( a ) ) ) );

const h1 = ( a ) => add( 1.0, w3( a ).div( w2( a ).add( w3( a ) ) ) );

const bicubic = ( textureNode, texelSize, lod ) => {

	const uv = textureNode.uvNode;
	const uvScaled = mul( uv, texelSize.zw ).add( 0.5 );

	const iuv = floor( uvScaled );
	const fuv = fract( uvScaled );

	const g0x = g0( fuv.x );
	const g1x = g1( fuv.x );
	const h0x = h0( fuv.x );
	const h1x = h1( fuv.x );
	const h0y = h0( fuv.y );
	const h1y = h1( fuv.y );

	const p0 = vec2( iuv.x.add( h0x ), iuv.y.add( h0y ) ).sub( 0.5 ).mul( texelSize.xy );
	const p1 = vec2( iuv.x.add( h1x ), iuv.y.add( h0y ) ).sub( 0.5 ).mul( texelSize.xy );
	const p2 = vec2( iuv.x.add( h0x ), iuv.y.add( h1y ) ).sub( 0.5 ).mul( texelSize.xy );
	const p3 = vec2( iuv.x.add( h1x ), iuv.y.add( h1y ) ).sub( 0.5 ).mul( texelSize.xy );

	const a = g0( fuv.y ).mul( add( g0x.mul( textureNode.sample( p0 ).level( lod ) ), g1x.mul( textureNode.sample( p1 ).level( lod ) ) ) );
	const b = g1( fuv.y ).mul( add( g0x.mul( textureNode.sample( p2 ).level( lod ) ), g1x.mul( textureNode.sample( p3 ).level( lod ) ) ) );

	return a.add( b );

};

const textureBicubic = /*@__PURE__*/ Fn( ( [ textureNode, lodNode = float( 3 ) ] ) => {

	const fLodSize = vec2( textureNode.size( int( lodNode ) ) );
	const cLodSize = vec2( textureNode.size( int( lodNode.add( 1.0 ) ) ) );
	const fLodSizeInv = div( 1.0, fLodSize );
	const cLodSizeInv = div( 1.0, cLodSize );
	const fSample = bicubic( textureNode, vec4( fLodSizeInv, fLodSize ), floor( lodNode ) );
	const cSample = bicubic( textureNode, vec4( cLodSizeInv, cLodSize ), ceil( lodNode ) );

	return fract( lodNode ).mix( fSample, cSample );

} );

//
// Transmission
//

const getVolumeTransmissionRay = /*@__PURE__*/ Fn( ( [ n, v, thickness, ior, modelMatrix ] ) => {

	// Direction of refracted light.
	const refractionVector = vec3( refract( v.negate(), normalize( n ), div( 1.0, ior ) ) );

	// Compute rotation-independent scaling of the model matrix.
	const modelScale = vec3(
		length( modelMatrix[ 0 ].xyz ),
		length( modelMatrix[ 1 ].xyz ),
		length( modelMatrix[ 2 ].xyz )
	);

	// The thickness is specified in local space.
	return normalize( refractionVector ).mul( thickness.mul( modelScale ) );

} ).setLayout( {
	name: 'getVolumeTransmissionRay',
	type: 'vec3',
	inputs: [
		{ name: 'n', type: 'vec3' },
		{ name: 'v', type: 'vec3' },
		{ name: 'thickness', type: 'float' },
		{ name: 'ior', type: 'float' },
		{ name: 'modelMatrix', type: 'mat4' }
	]
} );

const applyIorToRoughness = /*@__PURE__*/ Fn( ( [ roughness, ior ] ) => {

	// Scale roughness with IOR so that an IOR of 1.0 results in no microfacet refraction and
	// an IOR of 1.5 results in the default amount of microfacet refraction.
	return roughness.mul( clamp( ior.mul( 2.0 ).sub( 2.0 ), 0.0, 1.0 ) );

} ).setLayout( {
	name: 'applyIorToRoughness',
	type: 'float',
	inputs: [
		{ name: 'roughness', type: 'float' },
		{ name: 'ior', type: 'float' }
	]
} );

const viewportBackSideTexture = /*@__PURE__*/ viewportMipTexture();
const viewportFrontSideTexture = /*@__PURE__*/ viewportMipTexture();

const getTransmissionSample = /*@__PURE__*/ Fn( ( [ fragCoord, roughness, ior ], { material } ) => {

	const vTexture = material.side === BackSide ? viewportBackSideTexture : viewportFrontSideTexture;

	const transmissionSample = vTexture.sample( fragCoord );
	//const transmissionSample = viewportMipTexture( fragCoord );

	const lod = log2( screenSize.x ).mul( applyIorToRoughness( roughness, ior ) );

	return textureBicubic( transmissionSample, lod );

} );

const volumeAttenuation = /*@__PURE__*/ Fn( ( [ transmissionDistance, attenuationColor, attenuationDistance ] ) => {

	If( attenuationDistance.notEqual( 0 ), () => {

		// Compute light attenuation using Beer's law.
		const attenuationCoefficient = log( attenuationColor ).negate().div( attenuationDistance );
		const transmittance = exp( attenuationCoefficient.negate().mul( transmissionDistance ) );

		return transmittance;

	} );

	// Attenuation distance is +∞, i.e. the transmitted color is not attenuated at all.
	return vec3( 1.0 );

} ).setLayout( {
	name: 'volumeAttenuation',
	type: 'vec3',
	inputs: [
		{ name: 'transmissionDistance', type: 'float' },
		{ name: 'attenuationColor', type: 'vec3' },
		{ name: 'attenuationDistance', type: 'float' }
	]
} );

const getIBLVolumeRefraction = /*@__PURE__*/ Fn( ( [ n, v, roughness, diffuseColor, specularColor, specularF90, position, modelMatrix, viewMatrix, projMatrix, ior, thickness, attenuationColor, attenuationDistance, dispersion ] ) => {

	let transmittedLight, transmittance;

	if ( dispersion ) {

		transmittedLight = vec4().toVar();
		transmittance = vec3().toVar();

		const halfSpread = ior.sub( 1.0 ).mul( dispersion.mul( 0.025 ) );
		const iors = vec3( ior.sub( halfSpread ), ior, ior.add( halfSpread ) );

		Loop( { start: 0, end: 3 }, ( { i } ) => {

			const ior = iors.element( i );

			const transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
			const refractedRayExit = position.add( transmissionRay );

			// Project refracted vector on the framebuffer, while mapping to normalized device coordinates.
			const ndcPos = projMatrix.mul( viewMatrix.mul( vec4( refractedRayExit, 1.0 ) ) );
			const refractionCoords = vec2( ndcPos.xy.div( ndcPos.w ) ).toVar();
			refractionCoords.addAssign( 1.0 );
			refractionCoords.divAssign( 2.0 );
			refractionCoords.assign( vec2( refractionCoords.x, refractionCoords.y.oneMinus() ) ); // webgpu

			// Sample framebuffer to get pixel the refracted ray hits.
			const transmissionSample = getTransmissionSample( refractionCoords, roughness, ior );

			transmittedLight.element( i ).assign( transmissionSample.element( i ) );
			transmittedLight.a.addAssign( transmissionSample.a );

			transmittance.element( i ).assign( diffuseColor.element( i ).mul( volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance ).element( i ) ) );

		} );

		transmittedLight.a.divAssign( 3.0 );

	} else {

		const transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
		const refractedRayExit = position.add( transmissionRay );

		// Project refracted vector on the framebuffer, while mapping to normalized device coordinates.
		const ndcPos = projMatrix.mul( viewMatrix.mul( vec4( refractedRayExit, 1.0 ) ) );
		const refractionCoords = vec2( ndcPos.xy.div( ndcPos.w ) ).toVar();
		refractionCoords.addAssign( 1.0 );
		refractionCoords.divAssign( 2.0 );
		refractionCoords.assign( vec2( refractionCoords.x, refractionCoords.y.oneMinus() ) ); // webgpu

		// Sample framebuffer to get pixel the refracted ray hits.
		transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
		transmittance = diffuseColor.mul( volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance ) );

	}

	const attenuatedColor = transmittance.rgb.mul( transmittedLight.rgb );
	const dotNV = n.dot( v ).clamp();

	// Get the specular component.
	const F = vec3( EnvironmentBRDF( { // n, v, specularColor, specularF90, roughness
		dotNV,
		specularColor,
		specularF90,
		roughness
	} ) );

	// As less light is transmitted, the opacity should be increased. This simple approximation does a decent job
	// of modulating a CSS background, and has no effect when the buffer is opaque, due to a solid object or clear color.
	const transmittanceFactor = transmittance.r.add( transmittance.g, transmittance.b ).div( 3.0 );

	return vec4( F.oneMinus().mul( attenuatedColor ), transmittedLight.a.oneMinus().mul( transmittanceFactor ).oneMinus() );

} );

//
// Iridescence
//

// XYZ to linear-sRGB color space
const XYZ_TO_REC709 = /*@__PURE__*/ mat3(
	3.2404542, - 0.9692660, 0.0556434,
	- 1.5371385, 1.8760108, - 0.2040259,
	- 0.4985314, 0.0415560, 1.0572252
);

// Assume air interface for top
// Note: We don't handle the case fresnel0 == 1
const Fresnel0ToIor = ( fresnel0 ) => {

	const sqrtF0 = fresnel0.sqrt();
	return vec3( 1.0 ).add( sqrtF0 ).div( vec3( 1.0 ).sub( sqrtF0 ) );

};

// ior is a value between 1.0 and 3.0. 1.0 is air interface
const IorToFresnel0 = ( transmittedIor, incidentIor ) => {

	return transmittedIor.sub( incidentIor ).div( transmittedIor.add( incidentIor ) ).pow2();

};

// Fresnel equations for dielectric/dielectric interfaces.
// Ref: https://belcour.github.io/blog/research/2017/05/01/brdf-thin-film.html
// Evaluation XYZ sensitivity curves in Fourier space
const evalSensitivity = ( OPD, shift ) => {

	const phase = OPD.mul( 2.0 * Math.PI * 1.0e-9 );
	const val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );
	const pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );
	const VAR = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );

	const x = float( 9.7470e-14 * Math.sqrt( 2.0 * Math.PI * 4.5282e+09 ) ).mul( phase.mul( 2.2399e+06 ).add( shift.x ).cos() ).mul( phase.pow2().mul( - 4.5282e+09 ).exp() );

	let xyz = val.mul( VAR.mul( 2.0 * Math.PI ).sqrt() ).mul( pos.mul( phase ).add( shift ).cos() ).mul( phase.pow2().negate().mul( VAR ).exp() );
	xyz = vec3( xyz.x.add( x ), xyz.y, xyz.z ).div( 1.0685e-7 );

	const rgb = XYZ_TO_REC709.mul( xyz );

	return rgb;

};

const evalIridescence = /*@__PURE__*/ Fn( ( { outsideIOR, eta2, cosTheta1, thinFilmThickness, baseF0 } ) => {

	// Force iridescenceIOR -> outsideIOR when thinFilmThickness -> 0.0
	const iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );
	// Evaluate the cosTheta on the base layer (Snell law)
	const sinTheta2Sq = outsideIOR.div( iridescenceIOR ).pow2().mul( cosTheta1.pow2().oneMinus() );

	// Handle TIR:
	const cosTheta2Sq = sinTheta2Sq.oneMinus();

	If( cosTheta2Sq.lessThan( 0 ), () => {

		return vec3( 1.0 );

	} );

	const cosTheta2 = cosTheta2Sq.sqrt();

	// First interface
	const R0 = IorToFresnel0( iridescenceIOR, outsideIOR );
	const R12 = F_Schlick( { f0: R0, f90: 1.0, dotVH: cosTheta1 } );
	//const R21 = R12;
	const T121 = R12.oneMinus();
	const phi12 = iridescenceIOR.lessThan( outsideIOR ).select( Math.PI, 0.0 );
	const phi21 = float( Math.PI ).sub( phi12 );

	// Second interface
	const baseIOR = Fresnel0ToIor( baseF0.clamp( 0.0, 0.9999 ) ); // guard against 1.0
	const R1 = IorToFresnel0( baseIOR, iridescenceIOR.toVec3() );
	const R23 = F_Schlick( { f0: R1, f90: 1.0, dotVH: cosTheta2 } );
	const phi23 = vec3(
		baseIOR.x.lessThan( iridescenceIOR ).select( Math.PI, 0.0 ),
		baseIOR.y.lessThan( iridescenceIOR ).select( Math.PI, 0.0 ),
		baseIOR.z.lessThan( iridescenceIOR ).select( Math.PI, 0.0 )
	);

	// Phase shift
	const OPD = iridescenceIOR.mul( thinFilmThickness, cosTheta2, 2.0 );
	const phi = vec3( phi21 ).add( phi23 );

	// Compound terms
	const R123 = R12.mul( R23 ).clamp( 1e-5, 0.9999 );
	const r123 = R123.sqrt();
	const Rs = T121.pow2().mul( R23 ).div( vec3( 1.0 ).sub( R123 ) );

	// Reflectance term for m = 0 (DC term amplitude)
	const C0 = R12.add( Rs );
	const I = C0.toVar();

	// Reflectance term for m > 0 (pairs of diracs)
	const Cm = Rs.sub( T121 ).toVar();

	Loop( { start: 1, end: 2, condition: '<=', name: 'm' }, ( { m } ) => {

		Cm.mulAssign( r123 );
		const Sm = evalSensitivity( float( m ).mul( OPD ), float( m ).mul( phi ) ).mul( 2.0 );
		I.addAssign( Cm.mul( Sm ) );

	} );

	// Since out of gamut colors might be produced, negative color values are clamped to 0.
	return I.max( vec3( 0.0 ) );

} ).setLayout( {
	name: 'evalIridescence',
	type: 'vec3',
	inputs: [
		{ name: 'outsideIOR', type: 'float' },
		{ name: 'eta2', type: 'float' },
		{ name: 'cosTheta1', type: 'float' },
		{ name: 'thinFilmThickness', type: 'float' },
		{ name: 'baseF0', type: 'vec3' }
	]
} );

//
//	Sheen
//

// This is a curve-fit approximation to the "Charlie sheen" BRDF integrated over the hemisphere from
// Estevez and Kulla 2017, "Production Friendly Microfacet Sheen BRDF". The analysis can be found
// in the Sheen section of https://drive.google.com/file/d/1T0D1VSyR4AllqIJTQAraEIzjlb5h4FKH/view?usp=sharing
const IBLSheenBRDF = /*@__PURE__*/ Fn( ( { normal, viewDir, roughness } ) => {

	const dotNV = normal.dot( viewDir ).saturate();

	const r2 = roughness.pow2();

	const a = select(
		roughness.lessThan( 0.25 ),
		float( - 339.2 ).mul( r2 ).add( float( 161.4 ).mul( roughness ) ).sub( 25.9 ),
		float( - 8.48 ).mul( r2 ).add( float( 14.3 ).mul( roughness ) ).sub( 9.95 )
	);

	const b = select(
		roughness.lessThan( 0.25 ),
		float( 44.0 ).mul( r2 ).sub( float( 23.7 ).mul( roughness ) ).add( 3.26 ),
		float( 1.97 ).mul( r2 ).sub( float( 3.27 ).mul( roughness ) ).add( 0.72 )
	);

	const DG = select( roughness.lessThan( 0.25 ), 0.0, float( 0.1 ).mul( roughness ).sub( 0.025 ) ).add( a.mul( dotNV ).add( b ).exp() );

	return DG.mul( 1.0 / Math.PI ).saturate();

} );

const clearcoatF0 = vec3( 0.04 );
const clearcoatF90 = float( 1 );


/**
 * Represents the lighting model for a PBR material.
 *
 * @augments LightingModel
 */
class PhysicalLightingModel extends LightingModel {

	/**
	 * Constructs a new physical lighting model.
	 *
	 * @param {Boolean} [clearcoat=false] - Whether clearcoat is supported or not.
	 * @param {Boolean} [sheen=false] - Whether sheen is supported or not.
	 * @param {Boolean} [iridescence=false] - Whether iridescence is supported or not.
	 * @param {Boolean} [anisotropy=false] - Whether anisotropy is supported or not.
	 * @param {Boolean} [transmission=false] - Whether transmission is supported or not.
	 * @param {Boolean} [dispersion=false] - Whether dispersion is supported or not.
	 */
	constructor( clearcoat = false, sheen = false, iridescence = false, anisotropy = false, transmission = false, dispersion = false ) {

		super();

		/**
		 * Whether clearcoat is supported or not.
		 *
		 * @type {Boolean}
		 * @default false
		 */
		this.clearcoat = clearcoat;

		/**
		 * Whether sheen is supported or not.
		 *
		 * @type {Boolean}
		 * @default false
		 */
		this.sheen = sheen;

		/**
		 * Whether iridescence is supported or not.
		 *
		 * @type {Boolean}
		 * @default false
		 */
		this.iridescence = iridescence;

		/**
		 * Whether anisotropy is supported or not.
		 *
		 * @type {Boolean}
		 * @default false
		 */
		this.anisotropy = anisotropy;

		/**
		 * Whether transmission is supported or not.
		 *
		 * @type {Boolean}
		 * @default false
		 */
		this.transmission = transmission;

		/**
		 * Whether dispersion is supported or not.
		 *
		 * @type {Boolean}
		 * @default false
		 */
		this.dispersion = dispersion;

		/**
		 * The clear coat radiance.
		 *
		 * @type {Node?}
		 * @default null
		 */
		this.clearcoatRadiance = null;

		/**
		 * The clear coat specular direct.
		 *
		 * @type {Node?}
		 * @default null
		 */
		this.clearcoatSpecularDirect = null;

		/**
		 * The clear coat specular indirect.
		 *
		 * @type {Node?}
		 * @default null
		 */
		this.clearcoatSpecularIndirect = null;

		/**
		 * The sheen specular direct.
		 *
		 * @type {Node?}
		 * @default null
		 */
		this.sheenSpecularDirect = null;

		/**
		 * The sheen specular indirect.
		 *
		 * @type {Node?}
		 * @default null
		 */
		this.sheenSpecularIndirect = null;

		/**
		 * The iridescence Fresnel.
		 *
		 * @type {Node?}
		 * @default null
		 */
		this.iridescenceFresnel = null;

		/**
		 * The iridescence F0.
		 *
		 * @type {Node?}
		 * @default null
		 */
		this.iridescenceF0 = null;

	}

	/**
	 * Depending on what features are requested, the method prepares certain node variables
	 * which are later used for lighting computations.
	 *
	 * @param {ContextNode} context - The current node context.
	 */
	start( context ) {

		if ( this.clearcoat === true ) {

			this.clearcoatRadiance = vec3().toVar( 'clearcoatRadiance' );
			this.clearcoatSpecularDirect = vec3().toVar( 'clearcoatSpecularDirect' );
			this.clearcoatSpecularIndirect = vec3().toVar( 'clearcoatSpecularIndirect' );

		}

		if ( this.sheen === true ) {

			this.sheenSpecularDirect = vec3().toVar( 'sheenSpecularDirect' );
			this.sheenSpecularIndirect = vec3().toVar( 'sheenSpecularIndirect' );

		}

		if ( this.iridescence === true ) {

			const dotNVi = transformedNormalView.dot( positionViewDirection ).clamp();

			this.iridescenceFresnel = evalIridescence( {
				outsideIOR: float( 1.0 ),
				eta2: iridescenceIOR,
				cosTheta1: dotNVi,
				thinFilmThickness: iridescenceThickness,
				baseF0: specularColor
			} );

			this.iridescenceF0 = Schlick_to_F0( { f: this.iridescenceFresnel, f90: 1.0, dotVH: dotNVi } );

		}

		if ( this.transmission === true ) {

			const position = positionWorld;
			const v = cameraPosition.sub( positionWorld ).normalize(); // TODO: Create Node for this, same issue in MaterialX
			const n = transformedNormalWorld;

			context.backdrop = getIBLVolumeRefraction(
				n,
				v,
				roughness,
				diffuseColor,
				specularColor,
				specularF90, // specularF90
				position, // positionWorld
				modelWorldMatrix, // modelMatrix
				cameraViewMatrix, // viewMatrix
				cameraProjectionMatrix, // projMatrix
				ior,
				thickness,
				attenuationColor,
				attenuationDistance,
				this.dispersion ? dispersion : null
			);

			context.backdropAlpha = transmission;

			diffuseColor.a.mulAssign( mix( 1, context.backdrop.a, transmission ) );

		}

	}

	// Fdez-Agüera's "Multiple-Scattering Microfacet Model for Real-Time Image Based Lighting"
	// Approximates multi-scattering in order to preserve energy.
	// http://www.jcgt.org/published/0008/01/03/

	computeMultiscattering( singleScatter, multiScatter, specularF90 ) {

		const dotNV = transformedNormalView.dot( positionViewDirection ).clamp(); // @ TODO: Move to core dotNV

		const fab = DFGApprox( { roughness, dotNV } );

		const Fr = this.iridescenceF0 ? iridescence.mix( specularColor, this.iridescenceF0 ) : specularColor;

		const FssEss = Fr.mul( fab.x ).add( specularF90.mul( fab.y ) );

		const Ess = fab.x.add( fab.y );
		const Ems = Ess.oneMinus();

		const Favg = specularColor.add( specularColor.oneMinus().mul( 0.047619 ) ); // 1/21
		const Fms = FssEss.mul( Favg ).div( Ems.mul( Favg ).oneMinus() );

		singleScatter.addAssign( FssEss );
		multiScatter.addAssign( Fms.mul( Ems ) );

	}

	/**
	 * Implements the direct light.
	 *
	 * @param {Object} input - The input data.
	 * @param {StackNode} stack - The current stack.
	 * @param {NodeBuilder} builder - The current node builder.
	 */
	direct( { lightDirection, lightColor, reflectedLight } ) {

		const dotNL = transformedNormalView.dot( lightDirection ).clamp();
		const irradiance = dotNL.mul( lightColor );

		if ( this.sheen === true ) {

			this.sheenSpecularDirect.addAssign( irradiance.mul( BRDF_Sheen( { lightDirection } ) ) );

		}

		if ( this.clearcoat === true ) {

			const dotNLcc = transformedClearcoatNormalView.dot( lightDirection ).clamp();
			const ccIrradiance = dotNLcc.mul( lightColor );

			this.clearcoatSpecularDirect.addAssign( ccIrradiance.mul( BRDF_GGX( { lightDirection, f0: clearcoatF0, f90: clearcoatF90, roughness: clearcoatRoughness, normalView: transformedClearcoatNormalView } ) ) );

		}

		reflectedLight.directDiffuse.addAssign( irradiance.mul( BRDF_Lambert( { diffuseColor: diffuseColor.rgb } ) ) );

		reflectedLight.directSpecular.addAssign( irradiance.mul( BRDF_GGX( { lightDirection, f0: specularColor, f90: 1, roughness, iridescence: this.iridescence, f: this.iridescenceFresnel, USE_IRIDESCENCE: this.iridescence, USE_ANISOTROPY: this.anisotropy } ) ) );

	}

	/**
	 * This method is intended for implementing the direct light term for
	 * rect area light nodes.
	 *
	 * @param {Object} input - The input data.
	 * @param {StackNode} stack - The current stack.
	 * @param {NodeBuilder} builder - The current node builder.
	 */
	directRectArea( { lightColor, lightPosition, halfWidth, halfHeight, reflectedLight, ltc_1, ltc_2 } ) {

		const p0 = lightPosition.add( halfWidth ).sub( halfHeight ); // counterclockwise; light shines in local neg z direction
		const p1 = lightPosition.sub( halfWidth ).sub( halfHeight );
		const p2 = lightPosition.sub( halfWidth ).add( halfHeight );
		const p3 = lightPosition.add( halfWidth ).add( halfHeight );

		const N = transformedNormalView;
		const V = positionViewDirection;
		const P = positionView.toVar();

		const uv = LTC_Uv( { N, V, roughness } );

		const t1 = ltc_1.sample( uv ).toVar();
		const t2 = ltc_2.sample( uv ).toVar();

		const mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3( 0, 1, 0 ),
			vec3( t1.z, 0, t1.w )
		).toVar();

		// LTC Fresnel Approximation by Stephen Hill
		// http://blog.selfshadow.com/publications/s2016-advances/s2016_ltc_fresnel.pdf
		const fresnel = specularColor.mul( t2.x ).add( specularColor.oneMinus().mul( t2.y ) ).toVar();

		reflectedLight.directSpecular.addAssign( lightColor.mul( fresnel ).mul( LTC_Evaluate( { N, V, P, mInv, p0, p1, p2, p3 } ) ) );

		reflectedLight.directDiffuse.addAssign( lightColor.mul( diffuseColor ).mul( LTC_Evaluate( { N, V, P, mInv: mat3( 1, 0, 0, 0, 1, 0, 0, 0, 1 ), p0, p1, p2, p3 } ) ) );

	}

	/**
	 * Implements the indirect lighting.
	 *
	 * @param {ContextNode} context - The current node context.
	 * @param {StackNode} stack - The current stack.
	 * @param {NodeBuilder} builder - The current node builder.
	 */
	indirect( context, stack, builder ) {

		this.indirectDiffuse( context, stack, builder );
		this.indirectSpecular( context, stack, builder );
		this.ambientOcclusion( context, stack, builder );

	}

	/**
	 * Implements the indirect diffuse term.
	 *
	 * @param {ContextNode} input - The current node context.
	 * @param {StackNode} stack - The current stack.
	 * @param {NodeBuilder} builder - The current node builder.
	 */
	indirectDiffuse( { irradiance, reflectedLight } ) {

		reflectedLight.indirectDiffuse.addAssign( irradiance.mul( BRDF_Lambert( { diffuseColor } ) ) );

	}

	/**
	 * Implements the indirect specular term.
	 *
	 * @param {ContextNode} input - The current node context.
	 * @param {StackNode} stack - The current stack.
	 * @param {NodeBuilder} builder - The current node builder.
	 */
	indirectSpecular( { radiance, iblIrradiance, reflectedLight } ) {

		if ( this.sheen === true ) {

			this.sheenSpecularIndirect.addAssign( iblIrradiance.mul(
				sheen,
				IBLSheenBRDF( {
					normal: transformedNormalView,
					viewDir: positionViewDirection,
					roughness: sheenRoughness
				} )
			) );

		}

		if ( this.clearcoat === true ) {

			const dotNVcc = transformedClearcoatNormalView.dot( positionViewDirection ).clamp();

			const clearcoatEnv = EnvironmentBRDF( {
				dotNV: dotNVcc,
				specularColor: clearcoatF0,
				specularF90: clearcoatF90,
				roughness: clearcoatRoughness
			} );

			this.clearcoatSpecularIndirect.addAssign( this.clearcoatRadiance.mul( clearcoatEnv ) );

		}

		// Both indirect specular and indirect diffuse light accumulate here

		const singleScattering = vec3().toVar( 'singleScattering' );
		const multiScattering = vec3().toVar( 'multiScattering' );
		const cosineWeightedIrradiance = iblIrradiance.mul( 1 / Math.PI );

		this.computeMultiscattering( singleScattering, multiScattering, specularF90 );

		const totalScattering = singleScattering.add( multiScattering );

		const diffuse = diffuseColor.mul( totalScattering.r.max( totalScattering.g ).max( totalScattering.b ).oneMinus() );

		reflectedLight.indirectSpecular.addAssign( radiance.mul( singleScattering ) );
		reflectedLight.indirectSpecular.addAssign( multiScattering.mul( cosineWeightedIrradiance ) );

		reflectedLight.indirectDiffuse.addAssign( diffuse.mul( cosineWeightedIrradiance ) );

	}

	/**
	 * Implements the ambient occlusion term.
	 *
	 * @param {ContextNode} input - The current node context.
	 * @param {StackNode} stack - The current stack.
	 * @param {NodeBuilder} builder - The current node builder.
	 */
	ambientOcclusion( { ambientOcclusion, reflectedLight } ) {

		const dotNV = transformedNormalView.dot( positionViewDirection ).clamp(); // @ TODO: Move to core dotNV

		const aoNV = dotNV.add( ambientOcclusion );
		const aoExp = roughness.mul( - 16.0 ).oneMinus().negate().exp2();

		const aoNode = ambientOcclusion.sub( aoNV.pow( aoExp ).oneMinus() ).clamp();

		if ( this.clearcoat === true ) {

			this.clearcoatSpecularIndirect.mulAssign( ambientOcclusion );

		}

		if ( this.sheen === true ) {

			this.sheenSpecularIndirect.mulAssign( ambientOcclusion );

		}

		reflectedLight.indirectDiffuse.mulAssign( ambientOcclusion );
		reflectedLight.indirectSpecular.mulAssign( aoNode );

	}

	/**
	 * Used for final lighting accumulations depending on the requested features.
	 *
	 * @param {ContextNode} context - The current node context.
	 * @param {StackNode} stack - The current stack.
	 * @param {NodeBuilder} builder - The current node builder.
	 */
	finish( context ) {

		const { outgoingLight } = context;

		if ( this.clearcoat === true ) {

			const dotNVcc = transformedClearcoatNormalView.dot( positionViewDirection ).clamp();

			const Fcc = F_Schlick( {
				dotVH: dotNVcc,
				f0: clearcoatF0,
				f90: clearcoatF90
			} );

			const clearcoatLight = outgoingLight.mul( clearcoat.mul( Fcc ).oneMinus() ).add( this.clearcoatSpecularDirect.add( this.clearcoatSpecularIndirect ).mul( clearcoat ) );

			outgoingLight.assign( clearcoatLight );

		}

		if ( this.sheen === true ) {

			const sheenEnergyComp = sheen.r.max( sheen.g ).max( sheen.b ).mul( 0.157 ).oneMinus();
			const sheenLight = outgoingLight.mul( sheenEnergyComp ).add( this.sheenSpecularDirect, this.sheenSpecularIndirect );

			outgoingLight.assign( sheenLight );

		}

	}

}

// These defines must match with PMREMGenerator

const cubeUV_r0 = /*@__PURE__*/ float( 1.0 );
const cubeUV_m0 = /*@__PURE__*/ float( - 2.0 );
const cubeUV_r1 = /*@__PURE__*/ float( 0.8 );
const cubeUV_m1 = /*@__PURE__*/ float( - 1.0 );
const cubeUV_r4 = /*@__PURE__*/ float( 0.4 );
const cubeUV_m4 = /*@__PURE__*/ float( 2.0 );
const cubeUV_r5 = /*@__PURE__*/ float( 0.305 );
const cubeUV_m5 = /*@__PURE__*/ float( 3.0 );
const cubeUV_r6 = /*@__PURE__*/ float( 0.21 );
const cubeUV_m6 = /*@__PURE__*/ float( 4.0 );

const cubeUV_minMipLevel = /*@__PURE__*/ float( 4.0 );
const cubeUV_minTileSize = /*@__PURE__*/ float( 16.0 );

// These shader functions convert between the UV coordinates of a single face of
// a cubemap, the 0-5 integer index of a cube face, and the direction vector for
// sampling a textureCube (not generally normalized ).

const getFace = /*@__PURE__*/ Fn( ( [ direction ] ) => {

	const absDirection = vec3( abs( direction ) ).toVar();
	const face = float( - 1.0 ).toVar();

	If( absDirection.x.greaterThan( absDirection.z ), () => {

		If( absDirection.x.greaterThan( absDirection.y ), () => {

			face.assign( select( direction.x.greaterThan( 0.0 ), 0.0, 3.0 ) );

		} ).Else( () => {

			face.assign( select( direction.y.greaterThan( 0.0 ), 1.0, 4.0 ) );

		} );

	} ).Else( () => {

		If( absDirection.z.greaterThan( absDirection.y ), () => {

			face.assign( select( direction.z.greaterThan( 0.0 ), 2.0, 5.0 ) );

		} ).Else( () => {

			face.assign( select( direction.y.greaterThan( 0.0 ), 1.0, 4.0 ) );

		} );

	} );

	return face;

} ).setLayout( {
	name: 'getFace',
	type: 'float',
	inputs: [
		{ name: 'direction', type: 'vec3' }
	]
} );

// RH coordinate system; PMREM face-indexing convention
const getUV = /*@__PURE__*/ Fn( ( [ direction, face ] ) => {

	const uv = vec2().toVar();

	If( face.equal( 0.0 ), () => {

		uv.assign( vec2( direction.z, direction.y ).div( abs( direction.x ) ) ); // pos x

	} ).ElseIf( face.equal( 1.0 ), () => {

		uv.assign( vec2( direction.x.negate(), direction.z.negate() ).div( abs( direction.y ) ) ); // pos y

	} ).ElseIf( face.equal( 2.0 ), () => {

		uv.assign( vec2( direction.x.negate(), direction.y ).div( abs( direction.z ) ) ); // pos z

	} ).ElseIf( face.equal( 3.0 ), () => {

		uv.assign( vec2( direction.z.negate(), direction.y ).div( abs( direction.x ) ) ); // neg x

	} ).ElseIf( face.equal( 4.0 ), () => {

		uv.assign( vec2( direction.x.negate(), direction.z ).div( abs( direction.y ) ) ); // neg y

	} ).Else( () => {

		uv.assign( vec2( direction.x, direction.y ).div( abs( direction.z ) ) ); // neg z

	} );

	return mul( 0.5, uv.add( 1.0 ) );

} ).setLayout( {
	name: 'getUV',
	type: 'vec2',
	inputs: [
		{ name: 'direction', type: 'vec3' },
		{ name: 'face', type: 'float' }
	]
} );

const roughnessToMip = /*@__PURE__*/ Fn( ( [ roughness ] ) => {

	const mip = float( 0.0 ).toVar();

	If( roughness.greaterThanEqual( cubeUV_r1 ), () => {

		mip.assign( cubeUV_r0.sub( roughness ).mul( cubeUV_m1.sub( cubeUV_m0 ) ).div( cubeUV_r0.sub( cubeUV_r1 ) ).add( cubeUV_m0 ) );

	} ).ElseIf( roughness.greaterThanEqual( cubeUV_r4 ), () => {

		mip.assign( cubeUV_r1.sub( roughness ).mul( cubeUV_m4.sub( cubeUV_m1 ) ).div( cubeUV_r1.sub( cubeUV_r4 ) ).add( cubeUV_m1 ) );

	} ).ElseIf( roughness.greaterThanEqual( cubeUV_r5 ), () => {

		mip.assign( cubeUV_r4.sub( roughness ).mul( cubeUV_m5.sub( cubeUV_m4 ) ).div( cubeUV_r4.sub( cubeUV_r5 ) ).add( cubeUV_m4 ) );

	} ).ElseIf( roughness.greaterThanEqual( cubeUV_r6 ), () => {

		mip.assign( cubeUV_r5.sub( roughness ).mul( cubeUV_m6.sub( cubeUV_m5 ) ).div( cubeUV_r5.sub( cubeUV_r6 ) ).add( cubeUV_m5 ) );

	} ).Else( () => {

		mip.assign( float( - 2.0 ).mul( log2( mul( 1.16, roughness ) ) ) ); // 1.16 = 1.79^0.25

	} );

	return mip;

} ).setLayout( {
	name: 'roughnessToMip',
	type: 'float',
	inputs: [
		{ name: 'roughness', type: 'float' }
	]
} );

// RH coordinate system; PMREM face-indexing convention
const getDirection = /*@__PURE__*/ Fn( ( [ uv_immutable, face ] ) => {

	const uv = uv_immutable.toVar();
	uv.assign( mul( 2.0, uv ).sub( 1.0 ) );
	const direction = vec3( uv, 1.0 ).toVar();

	If( face.equal( 0.0 ), () => {

		direction.assign( direction.zyx ); // ( 1, v, u ) pos x

	} ).ElseIf( face.equal( 1.0 ), () => {

		direction.assign( direction.xzy );
		direction.xz.mulAssign( - 1.0 ); // ( -u, 1, -v ) pos y

	} ).ElseIf( face.equal( 2.0 ), () => {

		direction.x.mulAssign( - 1.0 ); // ( -u, v, 1 ) pos z

	} ).ElseIf( face.equal( 3.0 ), () => {

		direction.assign( direction.zyx );
		direction.xz.mulAssign( - 1.0 ); // ( -1, v, -u ) neg x

	} ).ElseIf( face.equal( 4.0 ), () => {

		direction.assign( direction.xzy );
		direction.xy.mulAssign( - 1.0 ); // ( -u, -1, v ) neg y

	} ).ElseIf( face.equal( 5.0 ), () => {

		direction.z.mulAssign( - 1.0 ); // ( u, v, -1 ) neg zS

	} );

	return direction;

} ).setLayout( {
	name: 'getDirection',
	type: 'vec3',
	inputs: [
		{ name: 'uv', type: 'vec2' },
		{ name: 'face', type: 'float' }
	]
} );

//

const textureCubeUV = /*@__PURE__*/ Fn( ( [ envMap, sampleDir_immutable, roughness_immutable, CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP ] ) => {

	const roughness = float( roughness_immutable );
	const sampleDir = vec3( sampleDir_immutable );

	const mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );
	const mipF = fract( mip );
	const mipInt = floor( mip );
	const color0 = vec3( bilinearCubeUV( envMap, sampleDir, mipInt, CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP ) ).toVar();

	If( mipF.notEqual( 0.0 ), () => {

		const color1 = vec3( bilinearCubeUV( envMap, sampleDir, mipInt.add( 1.0 ), CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP ) ).toVar();

		color0.assign( mix( color0, color1, mipF ) );

	} );

	return color0;

} );

const bilinearCubeUV = /*@__PURE__*/ Fn( ( [ envMap, direction_immutable, mipInt_immutable, CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP ] ) => {

	const mipInt = float( mipInt_immutable ).toVar();
	const direction = vec3( direction_immutable );
	const face = float( getFace( direction ) ).toVar();
	const filterInt = float( max$1( cubeUV_minMipLevel.sub( mipInt ), 0.0 ) ).toVar();
	mipInt.assign( max$1( mipInt, cubeUV_minMipLevel ) );
	const faceSize = float( exp2( mipInt ) ).toVar();
	const uv = vec2( getUV( direction, face ).mul( faceSize.sub( 2.0 ) ).add( 1.0 ) ).toVar();

	If( face.greaterThan( 2.0 ), () => {

		uv.y.addAssign( faceSize );
		face.subAssign( 3.0 );

	} );

	uv.x.addAssign( face.mul( faceSize ) );
	uv.x.addAssign( filterInt.mul( mul( 3.0, cubeUV_minTileSize ) ) );
	uv.y.addAssign( mul( 4.0, exp2( CUBEUV_MAX_MIP ).sub( faceSize ) ) );
	uv.x.mulAssign( CUBEUV_TEXEL_WIDTH );
	uv.y.mulAssign( CUBEUV_TEXEL_HEIGHT );

	return envMap.sample( uv ).grad( vec2(), vec2() ); // disable anisotropic filtering

} );

const getSample = /*@__PURE__*/ Fn( ( { envMap, mipInt, outputDirection, theta, axis, CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP } ) => {

	const cosTheta = cos( theta );

	// Rodrigues' axis-angle rotation
	const sampleDirection = outputDirection.mul( cosTheta )
		.add( axis.cross( outputDirection ).mul( sin( theta ) ) )
		.add( axis.mul( axis.dot( outputDirection ).mul( cosTheta.oneMinus() ) ) );

	return bilinearCubeUV( envMap, sampleDirection, mipInt, CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP );

} );

const blur = /*@__PURE__*/ Fn( ( { n, latitudinal, poleAxis, outputDirection, weights, samples, dTheta, mipInt, envMap, CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP } ) => {

	const axis = vec3( select( latitudinal, poleAxis, cross( poleAxis, outputDirection ) ) ).toVar();

	If( all( axis.equals( vec3( 0.0 ) ) ), () => {

		axis.assign( vec3( outputDirection.z, 0.0, outputDirection.x.negate() ) );

	} );

	axis.assign( normalize( axis ) );

	const gl_FragColor = vec3().toVar();
	gl_FragColor.addAssign( weights.element( int( 0 ) ).mul( getSample( { theta: 0.0, axis, outputDirection, mipInt, envMap, CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP } ) ) );

	Loop( { start: int( 1 ), end: n }, ( { i } ) => {

		If( i.greaterThanEqual( samples ), () => {

			Break();

		} );

		const theta = float( dTheta.mul( float( i ) ) ).toVar();
		gl_FragColor.addAssign( weights.element( i ).mul( getSample( { theta: theta.mul( - 1.0 ), axis, outputDirection, mipInt, envMap, CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP } ) ) );
		gl_FragColor.addAssign( weights.element( i ).mul( getSample( { theta, axis, outputDirection, mipInt, envMap, CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP } ) ) );

	} );

	return vec4( gl_FragColor, 1 );

} );

/** @module PMREMNode **/

let _generator = null;

const _cache = new WeakMap();

/**
 * Generates the cubeUV size based on the given image height.
 *
 * @private
 * @param {Number} imageHeight - The image height.
 * @return {{texelWidth: Number,texelHeight: Number, maxMip: Number}} The result object.
 */
function _generateCubeUVSize( imageHeight ) {

	const maxMip = Math.log2( imageHeight ) - 2;

	const texelHeight = 1.0 / imageHeight;

	const texelWidth = 1.0 / ( 3 * Math.max( Math.pow( 2, maxMip ), 7 * 16 ) );

	return { texelWidth, texelHeight, maxMip };

}

/**
 * Generates a PMREM from the given texture .
 *
 * @private
 * @param {Texture} texture - The texture to create the PMREM for.
 * @return {Texture} The PMREM.
 */
function _getPMREMFromTexture( texture ) {

	let cacheTexture = _cache.get( texture );

	const pmremVersion = cacheTexture !== undefined ? cacheTexture.pmremVersion : - 1;

	if ( pmremVersion !== texture.pmremVersion ) {

		const image = texture.image;

		if ( texture.isCubeTexture ) {

			if ( isCubeMapReady( image ) ) {

				cacheTexture = _generator.fromCubemap( texture, cacheTexture );

			} else {

				return null;

			}


		} else {

			if ( isEquirectangularMapReady( image ) ) {

				cacheTexture = _generator.fromEquirectangular( texture, cacheTexture );

			} else {

				return null;

			}

		}

		cacheTexture.pmremVersion = texture.pmremVersion;

		_cache.set( texture, cacheTexture );

	}

	return cacheTexture.texture;

}

/**
 * This node represents a PMREM which is a special type of preprocessed
 * environment map intended for PBR materials.
 *
 * ```js
 * const material = new MeshStandardNodeMaterial();
 * material.envNode = pmremTexture( envMap );
 * ```
 *
 * @augments TempNode
 */
class PMREMNode extends TempNode {

	static get type() {

		return 'PMREMNode';

	}

	/**
	 * Constructs a new function overloading node.
	 *
	 * @param {Texture} value - The input texture.
	 * @param {Node<vec2>} [uvNode=null] - The uv node.
	 * @param {Node<float>} [levelNode=null] - The level node.
	 */
	constructor( value, uvNode = null, levelNode = null ) {

		super( 'vec3' );

		/**
		 * Reference to the input texture.
		 *
		 * @private
		 * @type {Texture}
		 */
		this._value = value;

		/**
		 * Reference to the generated PMREM.
		 *
		 * @private
		 * @type {Texture | null}
		 * @default null
		 */
		this._pmrem = null;

		/**
		 *  The uv node.
		 *
		 * @type {Node<vec2>}
		 */
		this.uvNode = uvNode;

		/**
		 *  The level node.
		 *
		 * @type {Node<float>}
		 */
		this.levelNode = levelNode;

		/**
		 * Reference to a PMREM generator.
		 *
		 * @private
		 * @type {PMREMGenerator}
		 * @default null
		 */
		this._generator = null;

		const defaultTexture = new Texture();
		defaultTexture.isRenderTargetTexture = true;

		/**
		 * The texture node holding the generated PMREM.
		 *
		 * @private
		 * @type {TextureNode}
		 */
		this._texture = texture( defaultTexture );

		/**
		 * A uniform representing the PMREM's width.
		 *
		 * @private
		 * @type {UniformNode<float>}
		 */
		this._width = uniform( 0 );

		/**
		 * A uniform representing the PMREM's height.
		 *
		 * @private
		 * @type {UniformNode<float>}
		 */
		this._height = uniform( 0 );

		/**
		 * A uniform representing the PMREM's max Mip.
		 *
		 * @private
		 * @type {UniformNode<float>}
		 */
		this._maxMip = uniform( 0 );

		/**
		 * The `updateBeforeType` is set to `NodeUpdateType.RENDER`.
		 *
		 * @type {String}
		 * @default 'render'
		 */
		this.updateBeforeType = NodeUpdateType.RENDER;

	}

	set value( value ) {

		this._value = value;
		this._pmrem = null;

	}

	/**
	 * The node's texture value.
	 *
	 * @type {Texture}
	 */
	get value() {

		return this._value;

	}

	/**
	 * Uses the given PMREM texture to update internal values.
	 *
	 * @param {Texture} texture - The PMREM texture.
	 */
	updateFromTexture( texture ) {

		const cubeUVSize = _generateCubeUVSize( texture.image.height );

		this._texture.value = texture;
		this._width.value = cubeUVSize.texelWidth;
		this._height.value = cubeUVSize.texelHeight;
		this._maxMip.value = cubeUVSize.maxMip;

	}

	updateBefore() {

		let pmrem = this._pmrem;

		const pmremVersion = pmrem ? pmrem.pmremVersion : - 1;
		const texture = this._value;

		if ( pmremVersion !== texture.pmremVersion ) {

			if ( texture.isPMREMTexture === true ) {

				pmrem = texture;

			} else {

				pmrem = _getPMREMFromTexture( texture );

			}

			if ( pmrem !== null ) {

				this._pmrem = pmrem;

				this.updateFromTexture( pmrem );

			}

		}

	}

	setup( builder ) {

		if ( _generator === null ) {

			_generator = builder.createPMREMGenerator();

		}

		//

		this.updateBefore( builder );

		//

		let uvNode = this.uvNode;

		if ( uvNode === null && builder.context.getUV ) {

			uvNode = builder.context.getUV( this );

		}

		//

		const texture = this.value;

		if ( builder.renderer.coordinateSystem === WebGLCoordinateSystem && texture.isPMREMTexture !== true && texture.isRenderTargetTexture === true ) {

			uvNode = vec3( uvNode.x.negate(), uvNode.yz );

		}

		uvNode = vec3( uvNode.x, uvNode.y.negate(), uvNode.z );

		//

		let levelNode = this.levelNode;

		if ( levelNode === null && builder.context.getTextureLevel ) {

			levelNode = builder.context.getTextureLevel( this );

		}

		//

		return textureCubeUV( this._texture, uvNode, levelNode, this._width, this._height, this._maxMip );

	}

}

/**
 * Returns `true` if the given cube map image has been fully loaded.
 *
 * @private
 * @param {Array<(Image|Object)>} image - The cube map image.
 * @return {Boolean} Whether the given cube map is ready or not.
 */
function isCubeMapReady( image ) {

	if ( image === null || image === undefined ) return false;

	let count = 0;
	const length = 6;

	for ( let i = 0; i < length; i ++ ) {

		if ( image[ i ] !== undefined ) count ++;

	}

	return count === length;


}

/**
 * Returns `true` if the given equirectangular image has been fully loaded.
 *
 * @private
 * @param {(Image|Object)} image - The equirectangular image.
 * @return {Boolean} Whether the given cube map is ready or not.
 */
function isEquirectangularMapReady( image ) {

	if ( image === null || image === undefined ) return false;

	return image.height > 0;

}

/**
 * TSL function for creating a PMREM node.
 *
 * @function
 * @param {Texture} value - The input texture.
 * @param {Node<vec2>} [uvNode=null] - The uv node.
 * @param {Node<float>} [levelNode=null] - The level node.
 * @returns {PMREMNode}
 */
const pmremTexture = /*@__PURE__*/ nodeProxy( PMREMNode );

const _envNodeCache = new WeakMap();

/**
 * Represents a physical model for Image-based lighting (IBL). The environment
 * is defined via environment maps in the equirectanular, cube map or cubeUV (PMREM) format.
 * `EnvironmentNode` is intended for PBR materials like {@link MeshStandardNodeMaterial}.
 *
 * @augments LightingNode
 */
class EnvironmentNode extends LightingNode {

	static get type() {

		return 'EnvironmentNode';

	}

	/**
	 * Constructs a new environment node.
	 *
	 * @param {Node} [envNode=null] - A node representing the environment.
	 */
	constructor( envNode = null ) {

		super();

		/**
		 * A node representing the environment.
		 *
		 * @type {Node?}
		 * @default null
		 */
		this.envNode = envNode;

	}

	setup( builder ) {

		const { material } = builder;

		let envNode = this.envNode;

		if ( envNode.isTextureNode || envNode.isMaterialReferenceNode ) {

			const value = ( envNode.isTextureNode ) ? envNode.value : material[ envNode.property ];

			let cacheEnvNode = _envNodeCache.get( value );

			if ( cacheEnvNode === undefined ) {

				cacheEnvNode = pmremTexture( value );

				_envNodeCache.set( value, cacheEnvNode );

			}

			envNode	= cacheEnvNode;

		}

		//

		const envMap = material.envMap;
		const intensity = envMap ? reference( 'envMapIntensity', 'float', builder.material ) : reference( 'environmentIntensity', 'float', builder.scene ); // @TODO: Add materialEnvIntensity in MaterialNode

		const useAnisotropy = material.useAnisotropy === true || material.anisotropy > 0;
		const radianceNormalView = useAnisotropy ? transformedBentNormalView : transformedNormalView;

		const radiance = envNode.context( createRadianceContext( roughness, radianceNormalView ) ).mul( intensity );
		const irradiance = envNode.context( createIrradianceContext( transformedNormalWorld ) ).mul( Math.PI ).mul( intensity );

		const isolateRadiance = cache( radiance );
		const isolateIrradiance = cache( irradiance );

		//

		builder.context.radiance.addAssign( isolateRadiance );

		builder.context.iblIrradiance.addAssign( isolateIrradiance );

		//

		const clearcoatRadiance = builder.context.lightingModel.clearcoatRadiance;

		if ( clearcoatRadiance ) {

			const clearcoatRadianceContext = envNode.context( createRadianceContext( clearcoatRoughness, transformedClearcoatNormalView ) ).mul( intensity );
			const isolateClearcoatRadiance = cache( clearcoatRadianceContext );

			clearcoatRadiance.addAssign( isolateClearcoatRadiance );

		}

	}

}

const createRadianceContext = ( roughnessNode, normalViewNode ) => {

	let reflectVec = null;

	return {
		getUV: () => {

			if ( reflectVec === null ) {

				reflectVec = positionViewDirection.negate().reflect( normalViewNode );

				// Mixing the reflection with the normal is more accurate and keeps rough objects from gathering light from behind their tangent plane.
				reflectVec = roughnessNode.mul( roughnessNode ).mix( reflectVec, normalViewNode ).normalize();

				reflectVec = reflectVec.transformDirection( cameraViewMatrix );

			}

			return reflectVec;

		},
		getTextureLevel: () => {

			return roughnessNode;

		}
	};

};

const createIrradianceContext = ( normalWorldNode ) => {

	return {
		getUV: () => {

			return normalWorldNode;

		},
		getTextureLevel: () => {

			return float( 1.0 );

		}
	};

};

const _defaultValues$6 = /*@__PURE__*/ new MeshStandardMaterial();

class MeshStandardNodeMaterial extends NodeMaterial {

	static get type() {

		return 'MeshStandardNodeMaterial';

	}

	constructor( parameters ) {

		super();

		this.isMeshStandardNodeMaterial = true;

		this.lights = true;

		this.emissiveNode = null;

		this.metalnessNode = null;
		this.roughnessNode = null;

		this.setDefaultValues( _defaultValues$6 );

		this.setValues( parameters );

	}

	setupEnvironment( builder ) {

		let envNode = super.setupEnvironment( builder );

		if ( envNode === null && builder.environmentNode ) {

			envNode = builder.environmentNode;

		}

		return envNode ? new EnvironmentNode( envNode ) : null;

	}

	setupLightingModel( /*builder*/ ) {

		return new PhysicalLightingModel();

	}

	setupSpecular() {

		const specularColorNode = mix( vec3( 0.04 ), diffuseColor.rgb, metalness );

		specularColor.assign( specularColorNode );
		specularF90.assign( 1.0 );

	}

	setupVariants() {

		// METALNESS

		const metalnessNode = this.metalnessNode ? float( this.metalnessNode ) : materialMetalness;

		metalness.assign( metalnessNode );

		// ROUGHNESS

		let roughnessNode = this.roughnessNode ? float( this.roughnessNode ) : materialRoughness;
		roughnessNode = getRoughness( { roughness: roughnessNode } );

		roughness.assign( roughnessNode );

		// SPECULAR COLOR

		this.setupSpecular();

		// DIFFUSE COLOR

		diffuseColor.assign( vec4( diffuseColor.rgb.mul( metalnessNode.oneMinus() ), diffuseColor.a ) );

	}

	copy( source ) {

		this.emissiveNode = source.emissiveNode;

		this.metalnessNode = source.metalnessNode;
		this.roughnessNode = source.roughnessNode;

		return super.copy( source );

	}

}

const _defaultValues$5 = /*@__PURE__*/ new MeshPhysicalMaterial();

class MeshPhysicalNodeMaterial extends MeshStandardNodeMaterial {

	static get type() {

		return 'MeshPhysicalNodeMaterial';

	}

	constructor( parameters ) {

		super();

		this.isMeshPhysicalNodeMaterial = true;

		this.clearcoatNode = null;
		this.clearcoatRoughnessNode = null;
		this.clearcoatNormalNode = null;

		this.sheenNode = null;
		this.sheenRoughnessNode = null;

		this.iridescenceNode = null;
		this.iridescenceIORNode = null;
		this.iridescenceThicknessNode = null;

		this.specularIntensityNode = null;
		this.specularColorNode = null;

		this.iorNode = null;
		this.transmissionNode = null;
		this.thicknessNode = null;
		this.attenuationDistanceNode = null;
		this.attenuationColorNode = null;
		this.dispersionNode = null;

		this.anisotropyNode = null;

		this.setDefaultValues( _defaultValues$5 );

		this.setValues( parameters );

	}

	get useClearcoat() {

		return this.clearcoat > 0 || this.clearcoatNode !== null;

	}

	get useIridescence() {

		return this.iridescence > 0 || this.iridescenceNode !== null;

	}

	get useSheen() {

		return this.sheen > 0 || this.sheenNode !== null;

	}

	get useAnisotropy() {

		return this.anisotropy > 0 || this.anisotropyNode !== null;

	}

	get useTransmission() {

		return this.transmission > 0 || this.transmissionNode !== null;

	}

	get useDispersion() {

		return this.dispersion > 0 || this.dispersionNode !== null;

	}

	setupSpecular() {

		const iorNode = this.iorNode ? float( this.iorNode ) : materialIOR;

		ior.assign( iorNode );
		specularColor.assign( mix( min$1( pow2( ior.sub( 1.0 ).div( ior.add( 1.0 ) ) ).mul( materialSpecularColor ), vec3( 1.0 ) ).mul( materialSpecularIntensity ), diffuseColor.rgb, metalness ) );
		specularF90.assign( mix( materialSpecularIntensity, 1.0, metalness ) );

	}

	setupLightingModel( /*builder*/ ) {

		return new PhysicalLightingModel( this.useClearcoat, this.useSheen, this.useIridescence, this.useAnisotropy, this.useTransmission, this.useDispersion );

	}

	setupVariants( builder ) {

		super.setupVariants( builder );

		// CLEARCOAT

		if ( this.useClearcoat ) {

			const clearcoatNode = this.clearcoatNode ? float( this.clearcoatNode ) : materialClearcoat;
			const clearcoatRoughnessNode = this.clearcoatRoughnessNode ? float( this.clearcoatRoughnessNode ) : materialClearcoatRoughness;

			clearcoat.assign( clearcoatNode );
			clearcoatRoughness.assign( getRoughness( { roughness: clearcoatRoughnessNode } ) );

		}

		// SHEEN

		if ( this.useSheen ) {

			const sheenNode = this.sheenNode ? vec3( this.sheenNode ) : materialSheen;
			const sheenRoughnessNode = this.sheenRoughnessNode ? float( this.sheenRoughnessNode ) : materialSheenRoughness;

			sheen.assign( sheenNode );
			sheenRoughness.assign( sheenRoughnessNode );

		}

		// IRIDESCENCE

		if ( this.useIridescence ) {

			const iridescenceNode = this.iridescenceNode ? float( this.iridescenceNode ) : materialIridescence;
			const iridescenceIORNode = this.iridescenceIORNode ? float( this.iridescenceIORNode ) : materialIridescenceIOR;
			const iridescenceThicknessNode = this.iridescenceThicknessNode ? float( this.iridescenceThicknessNode ) : materialIridescenceThickness;

			iridescence.assign( iridescenceNode );
			iridescenceIOR.assign( iridescenceIORNode );
			iridescenceThickness.assign( iridescenceThicknessNode );

		}

		// ANISOTROPY

		if ( this.useAnisotropy ) {

			const anisotropyV = ( this.anisotropyNode ? vec2( this.anisotropyNode ) : materialAnisotropy ).toVar();

			anisotropy.assign( anisotropyV.length() );

			If( anisotropy.equal( 0.0 ), () => {

				anisotropyV.assign( vec2( 1.0, 0.0 ) );

			} ).Else( () => {

				anisotropyV.divAssign( vec2( anisotropy ) );
				anisotropy.assign( anisotropy.saturate() );

			} );

			// Roughness along the anisotropy bitangent is the material roughness, while the tangent roughness increases with anisotropy.
			alphaT.assign( anisotropy.pow2().mix( roughness.pow2(), 1.0 ) );

			anisotropyT.assign( TBNViewMatrix[ 0 ].mul( anisotropyV.x ).add( TBNViewMatrix[ 1 ].mul( anisotropyV.y ) ) );
			anisotropyB.assign( TBNViewMatrix[ 1 ].mul( anisotropyV.x ).sub( TBNViewMatrix[ 0 ].mul( anisotropyV.y ) ) );

		}

		// TRANSMISSION

		if ( this.useTransmission ) {

			const transmissionNode = this.transmissionNode ? float( this.transmissionNode ) : materialTransmission;
			const thicknessNode = this.thicknessNode ? float( this.thicknessNode ) : materialThickness;
			const attenuationDistanceNode = this.attenuationDistanceNode ? float( this.attenuationDistanceNode ) : materialAttenuationDistance;
			const attenuationColorNode = this.attenuationColorNode ? vec3( this.attenuationColorNode ) : materialAttenuationColor;

			transmission.assign( transmissionNode );
			thickness.assign( thicknessNode );
			attenuationDistance.assign( attenuationDistanceNode );
			attenuationColor.assign( attenuationColorNode );

			if ( this.useDispersion ) {

				const dispersionNode = this.dispersionNode ? float( this.dispersionNode ) : materialDispersion;

				dispersion.assign( dispersionNode );

			}

		}

	}

	setupClearcoatNormal() {

		return this.clearcoatNormalNode ? vec3( this.clearcoatNormalNode ) : materialClearcoatNormal;

	}

	setup( builder ) {

		builder.context.setupClearcoatNormal = () => this.setupClearcoatNormal( builder );

		super.setup( builder );

	}

	copy( source ) {

		this.clearcoatNode = source.clearcoatNode;
		this.clearcoatRoughnessNode = source.clearcoatRoughnessNode;
		this.clearcoatNormalNode = source.clearcoatNormalNode;

		this.sheenNode = source.sheenNode;
		this.sheenRoughnessNode = source.sheenRoughnessNode;

		this.iridescenceNode = source.iridescenceNode;
		this.iridescenceIORNode = source.iridescenceIORNode;
		this.iridescenceThicknessNode = source.iridescenceThicknessNode;

		this.specularIntensityNode = source.specularIntensityNode;
		this.specularColorNode = source.specularColorNode;

		this.transmissionNode = source.transmissionNode;
		this.thicknessNode = source.thicknessNode;
		this.attenuationDistanceNode = source.attenuationDistanceNode;
		this.attenuationColorNode = source.attenuationColorNode;
		this.dispersionNode = source.dispersionNode;

		this.anisotropyNode = source.anisotropyNode;

		return super.copy( source );

	}

}

class SSSLightingModel extends PhysicalLightingModel {

	constructor( useClearcoat, useSheen, useIridescence, useSSS ) {

		super( useClearcoat, useSheen, useIridescence );

		this.useSSS = useSSS;

	}

	direct( { lightDirection, lightColor, reflectedLight }, stack, builder ) {

		if ( this.useSSS === true ) {

			const material = builder.material;

			const { thicknessColorNode, thicknessDistortionNode, thicknessAmbientNode, thicknessAttenuationNode, thicknessPowerNode, thicknessScaleNode } = material;

			const scatteringHalf = lightDirection.add( transformedNormalView.mul( thicknessDistortionNode ) ).normalize();
			const scatteringDot = float( positionViewDirection.dot( scatteringHalf.negate() ).saturate().pow( thicknessPowerNode ).mul( thicknessScaleNode ) );
			const scatteringIllu = vec3( scatteringDot.add( thicknessAmbientNode ).mul( thicknessColorNode ) );

			reflectedLight.directDiffuse.addAssign( scatteringIllu.mul( thicknessAttenuationNode.mul( lightColor ) ) );

		}

		super.direct( { lightDirection, lightColor, reflectedLight }, stack, builder );

	}

}

class MeshSSSNodeMaterial extends MeshPhysicalNodeMaterial {

	static get type() {

		return 'MeshSSSNodeMaterial';

	}

	constructor( parameters ) {

		super( parameters );

		this.thicknessColorNode = null;
		this.thicknessDistortionNode = float( 0.1 );
		this.thicknessAmbientNode = float( 0.0 );
		this.thicknessAttenuationNode = float( .1 );
		this.thicknessPowerNode = float( 2.0 );
		this.thicknessScaleNode = float( 10.0 );

	}

	get useSSS() {

		return this.thicknessColorNode !== null;

	}

	setupLightingModel( /*builder*/ ) {

		return new SSSLightingModel( this.useClearcoat, this.useSheen, this.useIridescence, this.useSSS );

	}

	copy( source ) {

		this.thicknessColorNode = source.thicknessColorNode;
		this.thicknessDistortionNode = source.thicknessDistortionNode;
		this.thicknessAmbientNode = source.thicknessAmbientNode;
		this.thicknessAttenuationNode = source.thicknessAttenuationNode;
		this.thicknessPowerNode = source.thicknessPowerNode;
		this.thicknessScaleNode = source.thicknessScaleNode;

		return super.copy( source );

	}

}

const getGradientIrradiance = /*@__PURE__*/ Fn( ( { normal, lightDirection, builder } ) => {

	// dotNL will be from -1.0 to 1.0
	const dotNL = normal.dot( lightDirection );
	const coord = vec2( dotNL.mul( 0.5 ).add( 0.5 ), 0.0 );

	if ( builder.material.gradientMap ) {

		const gradientMap = materialReference( 'gradientMap', 'texture' ).context( { getUV: () => coord } );

		return vec3( gradientMap.r );

	} else {

		const fw = coord.fwidth().mul( 0.5 );

		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( float( 0.7 ).sub( fw.x ), float( 0.7 ).add( fw.x ), coord.x ) );

	}

} );

/**
 * Represents the lighting model for a toon material. Used in {@link MeshToonNodeMaterial}.
 *
 * @augments LightingModel
 */
class ToonLightingModel extends LightingModel {

	/**
	 * Implements the direct lighting. Instead of using a conventional smooth irradiance, the irradiance is
	 * reduced to a small number of discrete shades to create a comic-like, flat look.
	 *
	 * @param {Object} input - The input data.
	 * @param {StackNode} stack - The current stack.
	 * @param {NodeBuilder} builder - The current node builder.
	 */
	direct( { lightDirection, lightColor, reflectedLight }, stack, builder ) {

		const irradiance = getGradientIrradiance( { normal: normalGeometry, lightDirection, builder } ).mul( lightColor );

		reflectedLight.directDiffuse.addAssign( irradiance.mul( BRDF_Lambert( { diffuseColor: diffuseColor.rgb } ) ) );

	}

	/**
	 * Implements the indirect lighting.
	 *
	 * @param {ContextNode} input - The current node context.
	 * @param {StackNode} stack - The current stack.
	 * @param {NodeBuilder} builder - The current node builder.
	 */
	indirect( { ambientOcclusion, irradiance, reflectedLight } ) {

		reflectedLight.indirectDiffuse.addAssign( irradiance.mul( BRDF_Lambert( { diffuseColor } ) ) );

		reflectedLight.indirectDiffuse.mulAssign( ambientOcclusion );

	}

}

const _defaultValues$4 = /*@__PURE__*/ new MeshToonMaterial();

class MeshToonNodeMaterial extends NodeMaterial {

	static get type() {

		return 'MeshToonNodeMaterial';

	}

	constructor( parameters ) {

		super();

		this.isMeshToonNodeMaterial = true;

		this.lights = true;

		this.setDefaultValues( _defaultValues$4 );

		this.setValues( parameters );

	}

	setupLightingModel( /*builder*/ ) {

		return new ToonLightingModel();

	}

}

/** @module MatcapUVNode **/

/**
 * Can be used to compute texture coordinates for projecting a
 * matcap onto a mesh. Used by {@link MeshMatcapNodeMaterial}.
 *
 * @augments TempNode
 */
class MatcapUVNode extends TempNode {

	static get type() {

		return 'MatcapUVNode';

	}

	/**
	 * Constructs a new matcap uv node.
	 */
	constructor() {

		super( 'vec2' );

	}

	setup() {

		const x = vec3( positionViewDirection.z, 0, positionViewDirection.x.negate() ).normalize();
		const y = positionViewDirection.cross( x );

		return vec2( x.dot( transformedNormalView ), y.dot( transformedNormalView ) ).mul( 0.495 ).add( 0.5 ); // 0.495 to remove artifacts caused by undersized matcap disks

	}

}

/**
 * TSL function for creating a matcap uv node.
 *
 * @function
 * @returns {MatcapUVNode}
 */
const matcapUV = /*@__PURE__*/ nodeImmutable( MatcapUVNode );

const _defaultValues$3 = /*@__PURE__*/ new MeshMatcapMaterial();

class MeshMatcapNodeMaterial extends NodeMaterial {

	static get type() {

		return 'MeshMatcapNodeMaterial';

	}

	constructor( parameters ) {

		super();

		this.lights = false;

		this.isMeshMatcapNodeMaterial = true;

		this.setDefaultValues( _defaultValues$3 );

		this.setValues( parameters );

	}

	setupVariants( builder ) {

		const uv = matcapUV;

		let matcapColor;

		if ( builder.material.matcap ) {

			matcapColor = materialReference( 'matcap', 'texture' ).context( { getUV: () => uv } );

		} else {

			matcapColor = vec3( mix( 0.2, 0.8, uv.y ) ); // default if matcap is missing

		}

		diffuseColor.rgb.mulAssign( matcapColor.rgb );

	}

}

const _defaultValues$2 = /*@__PURE__*/ new PointsMaterial();

class PointsNodeMaterial extends NodeMaterial {

	static get type() {

		return 'PointsNodeMaterial';

	}

	constructor( parameters ) {

		super();

		this.isPointsNodeMaterial = true;

		this.lights = false;
		this.transparent = true;

		this.sizeNode = null;

		this.setDefaultValues( _defaultValues$2 );

		this.setValues( parameters );

	}

	copy( source ) {

		this.sizeNode = source.sizeNode;

		return super.copy( source );

	}

}

/** @module RotateNode **/

/**
 * Applies a rotation to the given position node.
 *
 * @augments TempNode
 */
class RotateNode extends TempNode {

	static get type() {

		return 'RotateNode';

	}

	/**
	 * Constructs a new rotate node.
	 *
	 * @param {Node} positionNode - The position node.
	 * @param {Node} rotationNode - Represents the rotation that is applied to the position node. Depending
	 * on whether the position data are 2D or 3D, the rotation is expressed a single float value or an Euler value.
	 */
	constructor( positionNode, rotationNode ) {

		super();

		/**
		 * The position node.
		 *
		 * @type {Node}
		 */
		this.positionNode = positionNode;

		/**
		 *  Represents the rotation that is applied to the position node.
		 *  Depending on whether the position data are 2D or 3D, the rotation is expressed a single float value or an Euler value.
		 *
		 * @type {Node}
		 */
		this.rotationNode = rotationNode;

	}

	/**
	 * The type of the {@link RotateNode#positionNode} defines the node's type.
	 *
	 * @param {NodeBuilder} builder - The current node builder.
	 * @return {String} The node's type.
	 */
	getNodeType( builder ) {

		return this.positionNode.getNodeType( builder );

	}

	setup( builder ) {

		const { rotationNode, positionNode } = this;

		const nodeType = this.getNodeType( builder );

		if ( nodeType === 'vec2' ) {

			const cosAngle = rotationNode.cos();
			const sinAngle = rotationNode.sin();

			const rotationMatrix = mat2(
				cosAngle, sinAngle,
				sinAngle.negate(), cosAngle
			);

			return rotationMatrix.mul( positionNode );

		} else {

			const rotation = rotationNode;
			const rotationXMatrix = mat4( vec4( 1.0, 0.0, 0.0, 0.0 ), vec4( 0.0, cos( rotation.x ), sin( rotation.x ).negate(), 0.0 ), vec4( 0.0, sin( rotation.x ), cos( rotation.x ), 0.0 ), vec4( 0.0, 0.0, 0.0, 1.0 ) );
			const rotationYMatrix = mat4( vec4( cos( rotation.y ), 0.0, sin( rotation.y ), 0.0 ), vec4( 0.0, 1.0, 0.0, 0.0 ), vec4( sin( rotation.y ).negate(), 0.0, cos( rotation.y ), 0.0 ), vec4( 0.0, 0.0, 0.0, 1.0 ) );
			const rotationZMatrix = mat4( vec4( cos( rotation.z ), sin( rotation.z ).negate(), 0.0, 0.0 ), vec4( sin( rotation.z ), cos( rotation.z ), 0.0, 0.0 ), vec4( 0.0, 0.0, 1.0, 0.0 ), vec4( 0.0, 0.0, 0.0, 1.0 ) );

			return rotationXMatrix.mul( rotationYMatrix ).mul( rotationZMatrix ).mul( vec4( positionNode, 1.0 ) ).xyz;

		}

	}

}

/**
 * TSL function for creating a rotate node.
 *
 * @function
 * @param {Node} positionNode - The position node.
 * @param {Node} rotationNode - Represents the rotation that is applied to the position node. Depending
 * on whether the position data are 2D or 3D, the rotation is expressed a single float value or an Euler value.
 * @returns {RotateNode}
 */
const rotate = /*@__PURE__*/ nodeProxy( RotateNode );

const _defaultValues$1 = /*@__PURE__*/ new SpriteMaterial();

class SpriteNodeMaterial extends NodeMaterial {

	static get type() {

		return 'SpriteNodeMaterial';

	}

	constructor( parameters ) {

		super();

		this.isSpriteNodeMaterial = true;

		this.lights = false;
		this._useSizeAttenuation = true;

		this.positionNode = null;
		this.rotationNode = null;
		this.scaleNode = null;

		this.setDefaultValues( _defaultValues$1 );

		this.setValues( parameters );

	}

	setupPositionView( builder ) {

		const { object, camera } = builder;

		const sizeAttenuation = this.sizeAttenuation;

		// < VERTEX STAGE >

		const { rotationNode, scaleNode } = this;

		const mvPosition = modelViewMatrix.mul( positionLocal );

		let scale = vec2( modelWorldMatrix[ 0 ].xyz.length(), modelWorldMatrix[ 1 ].xyz.length() );

		if ( scaleNode !== null ) {

			scale = scale.mul( scaleNode );

		}


		if ( ! sizeAttenuation ) {

			if ( camera.isPerspectiveCamera ) {

				scale = scale.mul( mvPosition.z.negate() );

			} else {

				const orthoScale = float( 2.0 ).div( cameraProjectionMatrix.element( 1 ).element( 1 ) );
				scale = scale.mul( orthoScale.mul( 2 ) );

			}

		}

		let alignedPosition = positionGeometry.xy;

		if ( object.center && object.center.isVector2 === true ) {

			const center = reference$1( 'center', 'vec2' );

			alignedPosition = alignedPosition.sub( center.sub( 0.5 ) );

		}

		alignedPosition = alignedPosition.mul( scale );

		const rotation = float( rotationNode || materialRotation );

		const rotatedPosition = rotate( alignedPosition, rotation );

		return vec4( mvPosition.xy.add( rotatedPosition ), mvPosition.zw );

	}

	copy( source ) {

		this.positionNode = source.positionNode;
		this.rotationNode = source.rotationNode;
		this.scaleNode = source.scaleNode;

		return super.copy( source );

	}

	get sizeAttenuation() {

		return this._useSizeAttenuation;

	}

	set sizeAttenuation( value ) {

		if ( this._useSizeAttenuation !== value ) {

			this._useSizeAttenuation = value;
			this.needsUpdate = true;

		}

	}

}

/**
 * Represents lighting model for a shadow material. Used in {@link ShadowNodeMaterial}.
 *
 * @augments LightingModel
 */
class ShadowMaskModel extends LightingModel {

	/**
	 * Constructs a new shadow mask model.
	 */
	constructor() {

		super();

		/**
		 * The shadow mask node.
		 *
		 * @type {Node}
		 */
		this.shadowNode = float( 1 ).toVar( 'shadowMask' );

	}

	/**
	 * Only used to save the shadow mask.
	 *
	 * @param {Object} input - The input data.
	 */
	direct( { shadowMask } ) {

		this.shadowNode.mulAssign( shadowMask );

	}

	/**
	 * Uses the shadow mask to produce the final color.
	 *
	 * @param {ContextNode} context - The current node context.
	 */
	finish( context ) {

		diffuseColor.a.mulAssign( this.shadowNode.oneMinus() );

		context.outgoingLight.rgb.assign( diffuseColor.rgb ); // TODO: Optimize LightsNode to avoid this assignment

	}

}

const _defaultValues = /*@__PURE__*/ new ShadowMaterial();

class ShadowNodeMaterial extends NodeMaterial {

	static get type() {

		return 'ShadowNodeMaterial';

	}

	constructor( parameters ) {

		super();

		this.isShadowNodeMaterial = true;

		this.lights = true;

		this.setDefaultValues( _defaultValues );

		this.setValues( parameters );

	}

	setupLightingModel( /*builder*/ ) {

		return new ShadowMaskModel();

	}

}

const normal = Fn( ( { texture, uv } ) => {

	const epsilon = 0.0001;

	const ret = vec3().toVar();

	If( uv.x.lessThan( epsilon ), () => {

		ret.assign( vec3( 1, 0, 0 ) );

	} ).ElseIf( uv.y.lessThan( epsilon ), () => {

		ret.assign( vec3( 0, 1, 0 ) );

	} ).ElseIf( uv.z.lessThan( epsilon ), () => {

		ret.assign( vec3( 0, 0, 1 ) );

	} ).ElseIf( uv.x.greaterThan( 1 - epsilon ), () => {

		ret.assign( vec3( - 1, 0, 0 ) );

	} ).ElseIf( uv.y.greaterThan( 1 - epsilon ), () => {

		ret.assign( vec3( 0, - 1, 0 ) );

	} ).ElseIf( uv.z.greaterThan( 1 - epsilon ), () => {

		ret.assign( vec3( 0, 0, - 1 ) );

	} ).Else( () => {

		const step = 0.01;

		const x = texture.sample( uv.add( vec3( - step, 0.0, 0.0 ) ) ).r.sub( texture.sample( uv.add( vec3( step, 0.0, 0.0 ) ) ).r );
		const y = texture.sample( uv.add( vec3( 0.0, - step, 0.0 ) ) ).r.sub( texture.sample( uv.add( vec3( 0.0, step, 0.0 ) ) ).r );
		const z = texture.sample( uv.add( vec3( 0.0, 0.0, - step ) ) ).r.sub( texture.sample( uv.add( vec3( 0.0, 0.0, step ) ) ).r );

		ret.assign( vec3( x, y, z ) );

	} );

	return ret.normalize();

} );


class Texture3DNode extends TextureNode {

	static get type() {

		return 'Texture3DNode';

	}

	constructor( value, uvNode = null, levelNode = null ) {

		super( value, uvNode, levelNode );

		this.isTexture3DNode = true;

	}

	getInputType( /*builder*/ ) {

		return 'texture3D';

	}

	getDefaultUV() {

		return vec3( 0.5, 0.5, 0.5 );

	}

	setUpdateMatrix( /*updateMatrix*/ ) { } // Ignore .updateMatrix for 3d TextureNode

	setupUV( builder, uvNode ) {

		return uvNode;

	}

	generateUV( builder, uvNode ) {

		return uvNode.build( builder, 'vec3' );

	}

	normal( uvNode ) {

		return normal( { texture: this, uv: uvNode } );

	}

}

const texture3D = /*@__PURE__*/ nodeProxy( Texture3DNode );

class VolumeNodeMaterial extends NodeMaterial {

	static get type() {

		return 'VolumeNodeMaterial';

	}

	constructor( params = {} ) {

		super();

		this.lights = false;
		this.isVolumeNodeMaterial = true;
		this.testNode = null;

		this.setValues( params );

	}

	setup( builder ) {

		const map = texture3D( this.map, null, 0 );

		const hitBox = Fn( ( { orig, dir } ) => {

			const box_min = vec3( - 0.5 );
			const box_max = vec3( 0.5 );

			const inv_dir = dir.reciprocal();

			const tmin_tmp = box_min.sub( orig ).mul( inv_dir );
			const tmax_tmp = box_max.sub( orig ).mul( inv_dir );

			const tmin = min$1( tmin_tmp, tmax_tmp );
			const tmax = max$1( tmin_tmp, tmax_tmp );

			const t0 = max$1( tmin.x, max$1( tmin.y, tmin.z ) );
			const t1 = min$1( tmax.x, min$1( tmax.y, tmax.z ) );

			return vec2( t0, t1 );

		} );

		this.fragmentNode = Fn( () => {

			const vOrigin = varying( vec3( modelWorldMatrixInverse.mul( vec4( cameraPosition, 1.0 ) ) ) );
			const vDirection = varying( positionGeometry.sub( vOrigin ) );

			const rayDir = vDirection.normalize();
			const bounds = vec2( hitBox( { orig: vOrigin, dir: rayDir } ) ).toVar();

			bounds.x.greaterThan( bounds.y ).discard();

			bounds.assign( vec2( max$1( bounds.x, 0.0 ), bounds.y ) );

			const p = vec3( vOrigin.add( bounds.x.mul( rayDir ) ) ).toVar();
			const inc = vec3( rayDir.abs().reciprocal() ).toVar();
			const delta = float( min$1( inc.x, min$1( inc.y, inc.z ) ) ).toVar( 'delta' ); // used 'delta' name in loop

			delta.divAssign( materialReference( 'steps', 'float' ) );

			const ac = vec4( materialReference( 'base', 'color' ), 0.0 ).toVar();

			Loop( { type: 'float', start: bounds.x, end: bounds.y, update: '+= delta' }, () => {

				const d = property( 'float', 'd' ).assign( map.sample( p.add( 0.5 ) ).r );

				if ( this.testNode !== null ) {

					this.testNode( { map: map, mapValue: d, probe: p, finalColor: ac } ).append();

				} else {

					// default to show surface of mesh
					ac.a.assign( 1 );
					Break();

				}

				p.addAssign( rayDir.mul( delta ) );

			} );

			ac.a.equal( 0 ).discard();

			return vec4( ac );

		} )();

		super.setup( builder );

	}

}

class Animation {

	constructor( nodes, info ) {

		this.nodes = nodes;
		this.info = info;

		this._context = self;
		this._animationLoop = null;
		this._requestId = null;

	}

	start() {

		const update = ( time, frame ) => {

			this._requestId = this._context.requestAnimationFrame( update );

			if ( this.info.autoReset === true ) this.info.reset();

			this.nodes.nodeFrame.update();

			this.info.frame = this.nodes.nodeFrame.frameId;

			if ( this._animationLoop !== null ) this._animationLoop( time, frame );

		};

		update();

	}

	stop() {

		this._context.cancelAnimationFrame( this._requestId );

		this._requestId = null;

	}

	setAnimationLoop( callback ) {

		this._animationLoop = callback;

	}

	setContext( context ) {

		this._context = context;

	}

	dispose() {

		this.stop();

	}

}

class ChainMap {

	constructor() {

		this.weakMap = new WeakMap();

	}

	get( keys ) {

		let map = this.weakMap;

		for ( let i = 0; i < keys.length; i ++ ) {

			map = map.get( keys[ i ] );

			if ( map === undefined ) return undefined;

		}

		return map.get( keys[ keys.length - 1 ] );

	}

	set( keys, value ) {

		let map = this.weakMap;

		for ( let i = 0; i < keys.length; i ++ ) {

			const key = keys[ i ];

			if ( map.has( key ) === false ) map.set( key, new WeakMap() );

			map = map.get( key );

		}

		return map.set( keys[ keys.length - 1 ], value );

	}

	delete( keys ) {

		let map = this.weakMap;

		for ( let i = 0; i < keys.length; i ++ ) {

			map = map.get( keys[ i ] );

			if ( map === undefined ) return false;

		}

		return map.delete( keys[ keys.length - 1 ] );

	}

}

let _id$8 = 0;

function getKeys( obj ) {

	const keys = Object.keys( obj );

	let proto = Object.getPrototypeOf( obj );

	while ( proto ) {

		const descriptors = Object.getOwnPropertyDescriptors( proto );

		for ( const key in descriptors ) {

			if ( descriptors[ key ] !== undefined ) {

				const descriptor = descriptors[ key ];

				if ( descriptor && typeof descriptor.get === 'function' ) {

					keys.push( key );

				}

			}

		}

		proto = Object.getPrototypeOf( proto );

	}

	return keys;

}

class RenderObject {

	constructor( nodes, geometries, renderer, object, material, scene, camera, lightsNode, renderContext, clippingContext ) {

		this._nodes = nodes;
		this._geometries = geometries;

		this.id = _id$8 ++;

		this.renderer = renderer;
		this.object = object;
		this.material = material;
		this.scene = scene;
		this.camera = camera;
		this.lightsNode = lightsNode;
		this.context = renderContext;

		this.geometry = object.geometry;
		this.version = material.version;

		this.drawRange = null;

		this.attributes = null;
		this.pipeline = null;
		this.vertexBuffers = null;
		this.drawParams = null;

		this.bundle = null;

		this.clippingContext = clippingContext;
		this.clippingContextCacheKey = clippingContext !== null ? clippingContext.cacheKey : '';

		this.initialNodesCacheKey = this.getDynamicCacheKey();
		this.initialCacheKey = this.getCacheKey();

		this._nodeBuilderState = null;
		this._bindings = null;
		this._monitor = null;

		this.onDispose = null;

		this.isRenderObject = true;

		this.onMaterialDispose = () => {

			this.dispose();

		};

		this.material.addEventListener( 'dispose', this.onMaterialDispose );

	}

	updateClipping( parent ) {

		this.clippingContext = parent;

	}

	get clippingNeedsUpdate() {

		if ( this.clippingContext === null || this.clippingContext.cacheKey === this.clippingContextCacheKey ) return false;

		this.clippingContextCacheKey = this.clippingContext.cacheKey;

		return true;

	}

	get hardwareClippingPlanes() {

		return this.material.hardwareClipping === true ? this.clippingContext.unionClippingCount : 0;

	}

	getNodeBuilderState() {

		return this._nodeBuilderState || ( this._nodeBuilderState = this._nodes.getForRender( this ) );

	}

	getMonitor() {

		return this._monitor || ( this._monitor = this.getNodeBuilderState().monitor );

	}

	getBindings() {

		return this._bindings || ( this._bindings = this.getNodeBuilderState().createBindings() );

	}

	getIndex() {

		return this._geometries.getIndex( this );

	}

	getIndirect() {

		return this._geometries.getIndirect( this );

	}

	getChainArray() {

		return [ this.object, this.material, this.context, this.lightsNode ];

	}

	setGeometry( geometry ) {

		this.geometry = geometry;
		this.attributes = null;

	}

	getAttributes() {

		if ( this.attributes !== null ) return this.attributes;

		const nodeAttributes = this.getNodeBuilderState().nodeAttributes;
		const geometry = this.geometry;

		const attributes = [];
		const vertexBuffers = new Set();

		for ( const nodeAttribute of nodeAttributes ) {

			const attribute = nodeAttribute.node && nodeAttribute.node.attribute ? nodeAttribute.node.attribute : geometry.getAttribute( nodeAttribute.name );

			if ( attribute === undefined ) continue;

			attributes.push( attribute );

			const bufferAttribute = attribute.isInterleavedBufferAttribute ? attribute.data : attribute;
			vertexBuffers.add( bufferAttribute );

		}

		this.attributes = attributes;
		this.vertexBuffers = Array.from( vertexBuffers.values() );

		return attributes;

	}

	getVertexBuffers() {

		if ( this.vertexBuffers === null ) this.getAttributes();

		return this.vertexBuffers;

	}

	getDrawParameters() {

		const { object, material, geometry, group, drawRange } = this;

		const drawParams = this.drawParams || ( this.drawParams = {
			vertexCount: 0,
			firstVertex: 0,
			instanceCount: 0,
			firstInstance: 0
		} );

		const index = this.getIndex();
		const hasIndex = ( index !== null );
		const instanceCount = geometry.isInstancedBufferGeometry ? geometry.instanceCount : ( object.count > 1 ? object.count : 1 );

		if ( instanceCount === 0 ) return null;

		drawParams.instanceCount = instanceCount;

		if ( object.isBatchedMesh === true ) return drawParams;

		let rangeFactor = 1;

		if ( material.wireframe === true && ! object.isPoints && ! object.isLineSegments && ! object.isLine && ! object.isLineLoop ) {

			rangeFactor = 2;

		}

		let firstVertex = drawRange.start * rangeFactor;
		let lastVertex = ( drawRange.start + drawRange.count ) * rangeFactor;

		if ( group !== null ) {

			firstVertex = Math.max( firstVertex, group.start * rangeFactor );
			lastVertex = Math.min( lastVertex, ( group.start + group.count ) * rangeFactor );

		}

		const position = geometry.attributes.position;
		let itemCount = Infinity;

		if ( hasIndex ) {

			itemCount = index.count;

		} else if ( position !== undefined && position !== null ) {

			itemCount = position.count;

		}

		firstVertex = Math.max( firstVertex, 0 );
		lastVertex = Math.min( lastVertex, itemCount );

		const count = lastVertex - firstVertex;

		if ( count < 0 || count === Infinity ) return null;

		drawParams.vertexCount = count;
		drawParams.firstVertex = firstVertex;

		return drawParams;

	}

	getGeometryCacheKey() {

		const { geometry } = this;

		let cacheKey = '';

		for ( const name of Object.keys( geometry.attributes ).sort() ) {

			const attribute = geometry.attributes[ name ];

			cacheKey += name + ',';

			if ( attribute.data ) cacheKey += attribute.data.stride + ',';
			if ( attribute.offset ) cacheKey += attribute.offset + ',';
			if ( attribute.itemSize ) cacheKey += attribute.itemSize + ',';
			if ( attribute.normalized ) cacheKey += 'n,';

		}

		if ( geometry.index ) {

			cacheKey += 'index,';

		}

		return cacheKey;

	}

	getMaterialCacheKey() {

		const { object, material } = this;

		let cacheKey = material.customProgramCacheKey();

		for ( const property of getKeys( material ) ) {

			if ( /^(is[A-Z]|_)|^(visible|version|uuid|name|opacity|userData)$/.test( property ) ) continue;

			const value = material[ property ];

			let valueKey;

			if ( value !== null ) {

				// some material values require a formatting

				const type = typeof value;

				if ( type === 'number' ) {

					valueKey = value !== 0 ? '1' : '0'; // Convert to on/off, important for clearcoat, transmission, etc

				} else if ( type === 'object' ) {

					valueKey = '{';

					if ( value.isTexture ) {

						valueKey += value.mapping;

					}

					valueKey += '}';

				} else {

					valueKey = String( value );

				}

			} else {

				valueKey = String( value );

			}

			cacheKey += /*property + ':' +*/ valueKey + ',';

		}

		cacheKey += this.clippingContextCacheKey + ',';

		if ( object.geometry ) {

			cacheKey += this.getGeometryCacheKey();

		}

		if ( object.skeleton ) {

			cacheKey += object.skeleton.bones.length + ',';

		}

		if ( object.morphTargetInfluences ) {

			cacheKey += object.morphTargetInfluences.length + ',';

		}

		if ( object.isBatchedMesh ) {

			cacheKey += object._matricesTexture.uuid + ',';

			if ( object._colorsTexture !== null ) {

				cacheKey += object._colorsTexture.uuid + ',';

			}

		}

		if ( object.count > 1 ) {

			// TODO: https://github.com/mrdoob/three.js/pull/29066#issuecomment-2269400850

			cacheKey += object.uuid + ',';

		}

		cacheKey += object.receiveShadow + ',';

		return hashString( cacheKey );

	}

	get needsGeometryUpdate() {

		return this.geometry.id !== this.object.geometry.id;

	}

	get needsUpdate() {

		return /*this.object.static !== true &&*/ ( this.initialNodesCacheKey !== this.getDynamicCacheKey() || this.clippingNeedsUpdate );

	}

	getDynamicCacheKey() {

		// Environment Nodes Cache Key

		let cacheKey = this._nodes.getCacheKey( this.scene, this.lightsNode );

		if ( this.object.receiveShadow ) {

			cacheKey += 1;

		}

		return cacheKey;

	}

	getCacheKey() {

		return this.getMaterialCacheKey() + this.getDynamicCacheKey();

	}

	dispose() {

		this.material.removeEventListener( 'dispose', this.onMaterialDispose );

		this.onDispose();

	}

}

const chainArray = [];

class RenderObjects {

	constructor( renderer, nodes, geometries, pipelines, bindings, info ) {

		this.renderer = renderer;
		this.nodes = nodes;
		this.geometries = geometries;
		this.pipelines = pipelines;
		this.bindings = bindings;
		this.info = info;

		this.chainMaps = {};

	}

	get( object, material, scene, camera, lightsNode, renderContext, clippingContext, passId ) {

		const chainMap = this.getChainMap( passId );

		// reuse chainArray
		chainArray[ 0 ] = object;
		chainArray[ 1 ] = material;
		chainArray[ 2 ] = renderContext;
		chainArray[ 3 ] = lightsNode;

		let renderObject = chainMap.get( chainArray );

		if ( renderObject === undefined ) {

			renderObject = this.createRenderObject( this.nodes, this.geometries, this.renderer, object, material, scene, camera, lightsNode, renderContext, clippingContext, passId );

			chainMap.set( chainArray, renderObject );

		} else {

			renderObject.updateClipping( clippingContext );

			if ( renderObject.needsGeometryUpdate ) {

				renderObject.setGeometry( object.geometry );

			}

			if ( renderObject.version !== material.version || renderObject.needsUpdate ) {

				if ( renderObject.initialCacheKey !== renderObject.getCacheKey() ) {

					renderObject.dispose();

					renderObject = this.get( object, material, scene, camera, lightsNode, renderContext, clippingContext, passId );

				} else {

					renderObject.version = material.version;

				}

			}

		}

		return renderObject;

	}

	getChainMap( passId = 'default' ) {

		return this.chainMaps[ passId ] || ( this.chainMaps[ passId ] = new ChainMap() );

	}

	dispose() {

		this.chainMaps = {};

	}

	createRenderObject( nodes, geometries, renderer, object, material, scene, camera, lightsNode, renderContext, clippingContext, passId ) {

		const chainMap = this.getChainMap( passId );

		const renderObject = new RenderObject( nodes, geometries, renderer, object, material, scene, camera, lightsNode, renderContext, clippingContext );

		renderObject.onDispose = () => {

			this.pipelines.delete( renderObject );
			this.bindings.delete( renderObject );
			this.nodes.delete( renderObject );

			chainMap.delete( renderObject.getChainArray() );

		};

		return renderObject;

	}


}

class DataMap {

	constructor() {

		this.data = new WeakMap();

	}

	get( object ) {

		let map = this.data.get( object );

		if ( map === undefined ) {

			map = {};
			this.data.set( object, map );

		}

		return map;

	}

	delete( object ) {

		let map;

		if ( this.data.has( object ) ) {

			map = this.data.get( object );

			this.data.delete( object );

		}

		return map;

	}

	has( object ) {

		return this.data.has( object );

	}

	dispose() {

		this.data = new WeakMap();

	}

}

const AttributeType = {
	VERTEX: 1,
	INDEX: 2,
	STORAGE: 3,
	INDIRECT: 4
};

// size of a chunk in bytes (STD140 layout)

const GPU_CHUNK_BYTES = 16;

// @TODO: Move to src/constants.js

const BlendColorFactor = 211;
const OneMinusBlendColorFactor = 212;

class Attributes extends DataMap {

	constructor( backend ) {

		super();

		this.backend = backend;

	}

	delete( attribute ) {

		const attributeData = super.delete( attribute );

		if ( attributeData !== undefined ) {

			this.backend.destroyAttribute( attribute );

		}

		return attributeData;

	}

	update( attribute, type ) {

		const data = this.get( attribute );

		if ( data.version === undefined ) {

			if ( type === AttributeType.VERTEX ) {

				this.backend.createAttribute( attribute );

			} else if ( type === AttributeType.INDEX ) {

				this.backend.createIndexAttribute( attribute );

			} else if ( type === AttributeType.STORAGE ) {

				this.backend.createStorageAttribute( attribute );

			} else if ( type === AttributeType.INDIRECT ) {

				this.backend.createIndirectStorageAttribute( attribute );

			}

			data.version = this._getBufferAttribute( attribute ).version;

		} else {

			const bufferAttribute = this._getBufferAttribute( attribute );

			if ( data.version < bufferAttribute.version || bufferAttribute.usage === DynamicDrawUsage ) {

				this.backend.updateAttribute( attribute );

				data.version = bufferAttribute.version;

			}

		}

	}

	_getBufferAttribute( attribute ) {

		if ( attribute.isInterleavedBufferAttribute ) attribute = attribute.data;

		return attribute;

	}

}

function arrayNeedsUint32( array ) {

	// assumes larger values usually on last

	for ( let i = array.length - 1; i >= 0; -- i ) {

		if ( array[ i ] >= 65535 ) return true; // account for PRIMITIVE_RESTART_FIXED_INDEX, #24565

	}

	return false;

}

function getWireframeVersion( geometry ) {

	return ( geometry.index !== null ) ? geometry.index.version : geometry.attributes.position.version;

}

function getWireframeIndex( geometry ) {

	const indices = [];

	const geometryIndex = geometry.index;
	const geometryPosition = geometry.attributes.position;

	if ( geometryIndex !== null ) {

		const array = geometryIndex.array;

		for ( let i = 0, l = array.length; i < l; i += 3 ) {

			const a = array[ i + 0 ];
			const b = array[ i + 1 ];
			const c = array[ i + 2 ];

			indices.push( a, b, b, c, c, a );

		}

	} else {

		const array = geometryPosition.array;

		for ( let i = 0, l = ( array.length / 3 ) - 1; i < l; i += 3 ) {

			const a = i + 0;
			const b = i + 1;
			const c = i + 2;

			indices.push( a, b, b, c, c, a );

		}

	}

	const attribute = new ( arrayNeedsUint32( indices ) ? Uint32BufferAttribute : Uint16BufferAttribute )( indices, 1 );
	attribute.version = getWireframeVersion( geometry );

	return attribute;

}

class Geometries extends DataMap {

	constructor( attributes, info ) {

		super();

		this.attributes = attributes;
		this.info = info;

		this.wireframes = new WeakMap();

		this.attributeCall = new WeakMap();

	}

	has( renderObject ) {

		const geometry = renderObject.geometry;

		return super.has( geometry ) && this.get( geometry ).initialized === true;

	}

	updateForRender( renderObject ) {

		if ( this.has( renderObject ) === false ) this.initGeometry( renderObject );

		this.updateAttributes( renderObject );

	}

	initGeometry( renderObject ) {

		const geometry = renderObject.geometry;
		const geometryData = this.get( geometry );

		geometryData.initialized = true;

		this.info.memory.geometries ++;

		const onDispose = () => {

			this.info.memory.geometries --;

			const index = geometry.index;
			const geometryAttributes = renderObject.getAttributes();

			if ( index !== null ) {

				this.attributes.delete( index );

			}

			for ( const geometryAttribute of geometryAttributes ) {

				this.attributes.delete( geometryAttribute );

			}

			const wireframeAttribute = this.wireframes.get( geometry );

			if ( wireframeAttribute !== undefined ) {

				this.attributes.delete( wireframeAttribute );

			}

			geometry.removeEventListener( 'dispose', onDispose );

		};

		geometry.addEventListener( 'dispose', onDispose );

	}

	updateAttributes( renderObject ) {

		// attributes

		const attributes = renderObject.getAttributes();

		for ( const attribute of attributes ) {

			if ( attribute.isStorageBufferAttribute || attribute.isStorageInstancedBufferAttribute ) {

				this.updateAttribute( attribute, AttributeType.STORAGE );

			} else {

				this.updateAttribute( attribute, AttributeType.VERTEX );

			}

		}

		// indexes

		const index = this.getIndex( renderObject );

		if ( index !== null ) {

			this.updateAttribute( index, AttributeType.INDEX );

		}

		// indirect

		const indirect = renderObject.geometry.indirect;

		if ( indirect !== null ) {

			this.updateAttribute( indirect, AttributeType.INDIRECT );

		}

	}

	updateAttribute( attribute, type ) {

		const callId = this.info.render.calls;

		if ( ! attribute.isInterleavedBufferAttribute ) {

			if ( this.attributeCall.get( attribute ) !== callId ) {

				this.attributes.update( attribute, type );

				this.attributeCall.set( attribute, callId );

			}

		} else {

			if ( this.attributeCall.get( attribute ) === undefined ) {

				this.attributes.update( attribute, type );

				this.attributeCall.set( attribute, callId );

			} else if ( this.attributeCall.get( attribute.data ) !== callId ) {

				this.attributes.update( attribute, type );

				this.attributeCall.set( attribute.data, callId );

				this.attributeCall.set( attribute, callId );

			}

		}

	}

	getIndirect( renderObject ) {

		return renderObject.geometry.indirect;

	}

	getIndex( renderObject ) {

		const { geometry, material } = renderObject;

		let index = geometry.index;

		if ( material.wireframe === true ) {

			const wireframes = this.wireframes;

			let wireframeAttribute = wireframes.get( geometry );

			if ( wireframeAttribute === undefined ) {

				wireframeAttribute = getWireframeIndex( geometry );

				wireframes.set( geometry, wireframeAttribute );

			} else if ( wireframeAttribute.version !== getWireframeVersion( geometry ) ) {

				this.attributes.delete( wireframeAttribute );

				wireframeAttribute = getWireframeIndex( geometry );

				wireframes.set( geometry, wireframeAttribute );

			}

			index = wireframeAttribute;

		}

		return index;

	}

}

class Info {

	constructor() {

		this.autoReset = true;

		this.frame = 0;
		this.calls = 0;

		this.render = {
			calls: 0,
			frameCalls: 0,
			drawCalls: 0,
			triangles: 0,
			points: 0,
			lines: 0,
			timestamp: 0,
			previousFrameCalls: 0,
			timestampCalls: 0
		};

		this.compute = {
			calls: 0,
			frameCalls: 0,
			timestamp: 0,
			previousFrameCalls: 0,
			timestampCalls: 0
		};

		this.memory = {
			geometries: 0,
			textures: 0
		};

	}

	update( object, count, instanceCount ) {

		this.render.drawCalls ++;

		if ( object.isMesh || object.isSprite ) {

			this.render.triangles += instanceCount * ( count / 3 );

		} else if ( object.isPoints ) {

			this.render.points += instanceCount * count;

		} else if ( object.isLineSegments ) {

			this.render.lines += instanceCount * ( count / 2 );

		} else if ( object.isLine ) {

			this.render.lines += instanceCount * ( count - 1 );

		} else {

			console.error( 'THREE.WebGPUInfo: Unknown object type.' );

		}

	}

	updateTimestamp( type, time ) {

		if ( this[ type ].timestampCalls === 0 ) {

			this[ type ].timestamp = 0;

		}


		this[ type ].timestamp += time;

		this[ type ].timestampCalls ++;


		if ( this[ type ].timestampCalls >= this[ type ].previousFrameCalls ) {

			this[ type ].timestampCalls = 0;

		}


	}

	reset() {

		const previousRenderFrameCalls = this.render.frameCalls;
		this.render.previousFrameCalls = previousRenderFrameCalls;

		const previousComputeFrameCalls = this.compute.frameCalls;
		this.compute.previousFrameCalls = previousComputeFrameCalls;


		this.render.drawCalls = 0;
		this.render.frameCalls = 0;
		this.compute.frameCalls = 0;

		this.render.triangles = 0;
		this.render.points = 0;
		this.render.lines = 0;


	}

	dispose() {

		this.reset();

		this.calls = 0;

		this.render.calls = 0;
		this.compute.calls = 0;

		this.render.timestamp = 0;
		this.compute.timestamp = 0;
		this.memory.geometries = 0;
		this.memory.textures = 0;

	}

}

class Pipeline {

	constructor( cacheKey ) {

		this.cacheKey = cacheKey;

		this.usedTimes = 0;

	}

}

class RenderPipeline extends Pipeline {

	constructor( cacheKey, vertexProgram, fragmentProgram ) {

		super( cacheKey );

		this.vertexProgram = vertexProgram;
		this.fragmentProgram = fragmentProgram;

	}

}

class ComputePipeline extends Pipeline {

	constructor( cacheKey, computeProgram ) {

		super( cacheKey );

		this.computeProgram = computeProgram;

		this.isComputePipeline = true;

	}

}

let _id$7 = 0;

class ProgrammableStage {

	constructor( code, type, transforms = null, attributes = null ) {

		this.id = _id$7 ++;

		this.code = code;
		this.stage = type;
		this.transforms = transforms;
		this.attributes = attributes;

		this.usedTimes = 0;

	}

}

class Pipelines extends DataMap {

	constructor( backend, nodes ) {

		super();

		this.backend = backend;
		this.nodes = nodes;

		this.bindings = null; // set by the bindings

		this.caches = new Map();
		this.programs = {
			vertex: new Map(),
			fragment: new Map(),
			compute: new Map()
		};

	}

	getForCompute( computeNode, bindings ) {

		const { backend } = this;

		const data = this.get( computeNode );

		if ( this._needsComputeUpdate( computeNode ) ) {

			const previousPipeline = data.pipeline;

			if ( previousPipeline ) {

				previousPipeline.usedTimes --;
				previousPipeline.computeProgram.usedTimes --;

			}

			// get shader

			const nodeBuilderState = this.nodes.getForCompute( computeNode );

			// programmable stage

			let stageCompute = this.programs.compute.get( nodeBuilderState.computeShader );

			if ( stageCompute === undefined ) {

				if ( previousPipeline && previousPipeline.computeProgram.usedTimes === 0 ) this._releaseProgram( previousPipeline.computeProgram );

				stageCompute = new ProgrammableStage( nodeBuilderState.computeShader, 'compute', nodeBuilderState.transforms, nodeBuilderState.nodeAttributes );
				this.programs.compute.set( nodeBuilderState.computeShader, stageCompute );

				backend.createProgram( stageCompute );

			}

			// determine compute pipeline

			const cacheKey = this._getComputeCacheKey( computeNode, stageCompute );

			let pipeline = this.caches.get( cacheKey );

			if ( pipeline === undefined ) {

				if ( previousPipeline && previousPipeline.usedTimes === 0 ) this._releasePipeline( previousPipeline );

				pipeline = this._getComputePipeline( computeNode, stageCompute, cacheKey, bindings );

			}

			// keep track of all used times

			pipeline.usedTimes ++;
			stageCompute.usedTimes ++;

			//

			data.version = computeNode.version;
			data.pipeline = pipeline;

		}

		return data.pipeline;

	}

	getForRender( renderObject, promises = null ) {

		const { backend } = this;

		const data = this.get( renderObject );

		if ( this._needsRenderUpdate( renderObject ) ) {

			const previousPipeline = data.pipeline;

			if ( previousPipeline ) {

				previousPipeline.usedTimes --;
				previousPipeline.vertexProgram.usedTimes --;
				previousPipeline.fragmentProgram.usedTimes --;

			}

			// get shader

			const nodeBuilderState = renderObject.getNodeBuilderState();

			// programmable stages

			let stageVertex = this.programs.vertex.get( nodeBuilderState.vertexShader );

			if ( stageVertex === undefined ) {

				if ( previousPipeline && previousPipeline.vertexProgram.usedTimes === 0 ) this._releaseProgram( previousPipeline.vertexProgram );

				stageVertex = new ProgrammableStage( nodeBuilderState.vertexShader, 'vertex' );
				this.programs.vertex.set( nodeBuilderState.vertexShader, stageVertex );

				backend.createProgram( stageVertex );

			}

			let stageFragment = this.programs.fragment.get( nodeBuilderState.fragmentShader );

			if ( stageFragment === undefined ) {

				if ( previousPipeline && previousPipeline.fragmentProgram.usedTimes === 0 ) this._releaseProgram( previousPipeline.fragmentProgram );

				stageFragment = new ProgrammableStage( nodeBuilderState.fragmentShader, 'fragment' );
				this.programs.fragment.set( nodeBuilderState.fragmentShader, stageFragment );

				backend.createProgram( stageFragment );

			}

			// determine render pipeline

			const cacheKey = this._getRenderCacheKey( renderObject, stageVertex, stageFragment );

			let pipeline = this.caches.get( cacheKey );

			if ( pipeline === undefined ) {

				if ( previousPipeline && previousPipeline.usedTimes === 0 ) this._releasePipeline( previousPipeline );

				pipeline = this._getRenderPipeline( renderObject, stageVertex, stageFragment, cacheKey, promises );

			} else {

				renderObject.pipeline = pipeline;

			}

			// keep track of all used times

			pipeline.usedTimes ++;
			stageVertex.usedTimes ++;
			stageFragment.usedTimes ++;

			//

			data.pipeline = pipeline;

		}

		return data.pipeline;

	}

	delete( object ) {

		const pipeline = this.get( object ).pipeline;

		if ( pipeline ) {

			// pipeline

			pipeline.usedTimes --;

			if ( pipeline.usedTimes === 0 ) this._releasePipeline( pipeline );

			// programs

			if ( pipeline.isComputePipeline ) {

				pipeline.computeProgram.usedTimes --;

				if ( pipeline.computeProgram.usedTimes === 0 ) this._releaseProgram( pipeline.computeProgram );

			} else {

				pipeline.fragmentProgram.usedTimes --;
				pipeline.vertexProgram.usedTimes --;

				if ( pipeline.vertexProgram.usedTimes === 0 ) this._releaseProgram( pipeline.vertexProgram );
				if ( pipeline.fragmentProgram.usedTimes === 0 ) this._releaseProgram( pipeline.fragmentProgram );

			}

		}

		return super.delete( object );

	}

	dispose() {

		super.dispose();

		this.caches = new Map();
		this.programs = {
			vertex: new Map(),
			fragment: new Map(),
			compute: new Map()
		};

	}

	updateForRender( renderObject ) {

		this.getForRender( renderObject );

	}

	_getComputePipeline( computeNode, stageCompute, cacheKey, bindings ) {

		// check for existing pipeline

		cacheKey = cacheKey || this._getComputeCacheKey( computeNode, stageCompute );

		let pipeline = this.caches.get( cacheKey );

		if ( pipeline === undefined ) {

			pipeline = new ComputePipeline( cacheKey, stageCompute );

			this.caches.set( cacheKey, pipeline );

			this.backend.createComputePipeline( pipeline, bindings );

		}

		return pipeline;

	}

	_getRenderPipeline( renderObject, stageVertex, stageFragment, cacheKey, promises ) {

		// check for existing pipeline

		cacheKey = cacheKey || this._getRenderCacheKey( renderObject, stageVertex, stageFragment );

		let pipeline = this.caches.get( cacheKey );

		if ( pipeline === undefined ) {

			pipeline = new RenderPipeline( cacheKey, stageVertex, stageFragment );

			this.caches.set( cacheKey, pipeline );

			renderObject.pipeline = pipeline;

			this.backend.createRenderPipeline( renderObject, promises );

		}

		return pipeline;

	}

	_getComputeCacheKey( computeNode, stageCompute ) {

		return computeNode.id + ',' + stageCompute.id;

	}

	_getRenderCacheKey( renderObject, stageVertex, stageFragment ) {

		return stageVertex.id + ',' + stageFragment.id + ',' + this.backend.getRenderCacheKey( renderObject );

	}

	_releasePipeline( pipeline ) {

		this.caches.delete( pipeline.cacheKey );

	}

	_releaseProgram( program ) {

		const code = program.code;
		const stage = program.stage;

		this.programs[ stage ].delete( code );

	}

	_needsComputeUpdate( computeNode ) {

		const data = this.get( computeNode );

		return data.pipeline === undefined || data.version !== computeNode.version;

	}

	_needsRenderUpdate( renderObject ) {

		const data = this.get( renderObject );

		return data.pipeline === undefined || this.backend.needsRenderUpdate( renderObject );

	}

}

class Bindings extends DataMap {

	constructor( backend, nodes, textures, attributes, pipelines, info ) {

		super();

		this.backend = backend;
		this.textures = textures;
		this.pipelines = pipelines;
		this.attributes = attributes;
		this.nodes = nodes;
		this.info = info;

		this.pipelines.bindings = this; // assign bindings to pipelines

	}

	getForRender( renderObject ) {

		const bindings = renderObject.getBindings();

		for ( const bindGroup of bindings ) {

			const groupData = this.get( bindGroup );

			if ( groupData.bindGroup === undefined ) {

				// each object defines an array of bindings (ubos, textures, samplers etc.)

				this._init( bindGroup );

				this.backend.createBindings( bindGroup, bindings, 0 );

				groupData.bindGroup = bindGroup;

			}

		}

		return bindings;

	}

	getForCompute( computeNode ) {

		const bindings = this.nodes.getForCompute( computeNode ).bindings;

		for ( const bindGroup of bindings ) {

			const groupData = this.get( bindGroup );

			if ( groupData.bindGroup === undefined ) {

				this._init( bindGroup );

				this.backend.createBindings( bindGroup, bindings, 0 );

				groupData.bindGroup = bindGroup;

			}

		}

		return bindings;

	}

	updateForCompute( computeNode ) {

		this._updateBindings( this.getForCompute( computeNode ) );

	}

	updateForRender( renderObject ) {

		this._updateBindings( this.getForRender( renderObject ) );

	}

	_updateBindings( bindings ) {

		for ( const bindGroup of bindings ) {

			this._update( bindGroup, bindings );

		}

	}

	_init( bindGroup ) {

		for ( const binding of bindGroup.bindings ) {

			if ( binding.isSampledTexture ) {

				this.textures.updateTexture( binding.texture );

			} else if ( binding.isStorageBuffer ) {

				const attribute = binding.attribute;
				const attributeType = attribute.isIndirectStorageBufferAttribute ? AttributeType.INDIRECT : AttributeType.STORAGE;

				this.attributes.update( attribute, attributeType );

			}

		}

	}

	_update( bindGroup, bindings ) {

		const { backend } = this;

		let needsBindingsUpdate = false;
		let cacheBindings = true;
		let cacheIndex = 0;
		let version = 0;

		// iterate over all bindings and check if buffer updates or a new binding group is required

		for ( const binding of bindGroup.bindings ) {

			if ( binding.isNodeUniformsGroup ) {

				const updated = this.nodes.updateGroup( binding );

				if ( ! updated ) continue;

			}

			if ( binding.isUniformBuffer ) {

				const updated = binding.update();

				if ( updated ) {

					backend.updateBinding( binding );

				}

			} else if ( binding.isSampler ) {

				binding.update();

			} else if ( binding.isSampledTexture ) {

				const texturesTextureData = this.textures.get( binding.texture );

				if ( binding.needsBindingsUpdate( texturesTextureData.generation ) ) needsBindingsUpdate = true;

				const updated = binding.update();

				const texture = binding.texture;

				if ( updated ) {

					this.textures.updateTexture( texture );

				}

				const textureData = backend.get( texture );

				if ( textureData.externalTexture !== undefined || texturesTextureData.isDefaultTexture ) {

					cacheBindings = false;

				} else {

					cacheIndex = cacheIndex * 10 + texture.id;
					version += texture.version;

				}

				if ( backend.isWebGPUBackend === true && textureData.texture === undefined && textureData.externalTexture === undefined ) {

					// TODO: Remove this once we found why updated === false isn't bound to a texture in the WebGPU backend
					console.error( 'Bindings._update: binding should be available:', binding, updated, texture, binding.textureNode.value, needsBindingsUpdate );

					this.textures.updateTexture( texture );
					needsBindingsUpdate = true;

				}

				if ( texture.isStorageTexture === true ) {

					const textureData = this.get( texture );

					if ( binding.store === true ) {

						textureData.needsMipmap = true;

					} else if ( this.textures.needsMipmaps( texture ) && textureData.needsMipmap === true ) {

						this.backend.generateMipmaps( texture );

						textureData.needsMipmap = false;

					}

				}

			}

		}

		if ( needsBindingsUpdate === true ) {

			this.backend.updateBindings( bindGroup, bindings, cacheBindings ? cacheIndex : 0, version );

		}

	}

}

function painterSortStable( a, b ) {

	if ( a.groupOrder !== b.groupOrder ) {

		return a.groupOrder - b.groupOrder;

	} else if ( a.renderOrder !== b.renderOrder ) {

		return a.renderOrder - b.renderOrder;

	} else if ( a.material.id !== b.material.id ) {

		return a.material.id - b.material.id;

	} else if ( a.z !== b.z ) {

		return a.z - b.z;

	} else {

		return a.id - b.id;

	}

}

function reversePainterSortStable( a, b ) {

	if ( a.groupOrder !== b.groupOrder ) {

		return a.groupOrder - b.groupOrder;

	} else if ( a.renderOrder !== b.renderOrder ) {

		return a.renderOrder - b.renderOrder;

	} else if ( a.z !== b.z ) {

		return b.z - a.z;

	} else {

		return a.id - b.id;

	}

}

function needsDoublePass( material ) {

	const hasTransmission = material.transmission > 0 || material.transmissionNode;

	return hasTransmission && material.side === DoubleSide && material.forceSinglePass === false;

}

class RenderList {

	constructor( lighting, scene, camera ) {

		this.renderItems = [];
		this.renderItemsIndex = 0;

		this.opaque = [];
		this.transparentDoublePass = [];
		this.transparent = [];
		this.bundles = [];

		this.lightsNode = lighting.getNode( scene, camera );
		this.lightsArray = [];

		this.scene = scene;
		this.camera = camera;

		this.occlusionQueryCount = 0;

	}

	begin() {

		this.renderItemsIndex = 0;

		this.opaque.length = 0;
		this.transparentDoublePass.length = 0;
		this.transparent.length = 0;
		this.bundles.length = 0;

		this.lightsArray.length = 0;

		this.occlusionQueryCount = 0;

		return this;

	}

	getNextRenderItem( object, geometry, material, groupOrder, z, group, clippingContext ) {

		let renderItem = this.renderItems[ this.renderItemsIndex ];

		if ( renderItem === undefined ) {

			renderItem = {
				id: object.id,
				object: object,
				geometry: geometry,
				material: material,
				groupOrder: groupOrder,
				renderOrder: object.renderOrder,
				z: z,
				group: group,
				clippingContext: clippingContext
			};

			this.renderItems[ this.renderItemsIndex ] = renderItem;

		} else {

			renderItem.id = object.id;
			renderItem.object = object;
			renderItem.geometry = geometry;
			renderItem.material = material;
			renderItem.groupOrder = groupOrder;
			renderItem.renderOrder = object.renderOrder;
			renderItem.z = z;
			renderItem.group = group;
			renderItem.clippingContext = clippingContext;

		}

		this.renderItemsIndex ++;

		return renderItem;

	}

	push( object, geometry, material, groupOrder, z, group, clippingContext ) {

		const renderItem = this.getNextRenderItem( object, geometry, material, groupOrder, z, group, clippingContext );

		if ( object.occlusionTest === true ) this.occlusionQueryCount ++;

		if ( material.transparent === true || material.transmission > 0 ) {

			if ( needsDoublePass( material ) ) this.transparentDoublePass.push( renderItem );

			this.transparent.push( renderItem );

		} else {

			this.opaque.push( renderItem );

		}

	}

	unshift( object, geometry, material, groupOrder, z, group, clippingContext ) {

		const renderItem = this.getNextRenderItem( object, geometry, material, groupOrder, z, group, clippingContext );

		if ( material.transparent === true || material.transmission > 0 ) {

			if ( needsDoublePass( material ) ) this.transparentDoublePass.unshift( renderItem );

			this.transparent.unshift( renderItem );

		} else {

			this.opaque.unshift( renderItem );

		}

	}

	pushBundle( group ) {

		this.bundles.push( group );

	}

	pushLight( light ) {

		this.lightsArray.push( light );

	}

	sort( customOpaqueSort, customTransparentSort ) {

		if ( this.opaque.length > 1 ) this.opaque.sort( customOpaqueSort || painterSortStable );
		if ( this.transparentDoublePass.length > 1 ) this.transparentDoublePass.sort( customTransparentSort || reversePainterSortStable );
		if ( this.transparent.length > 1 ) this.transparent.sort( customTransparentSort || reversePainterSortStable );

	}

	finish() {

		// update lights

		this.lightsNode.setLights( this.lightsArray );

		// Clear references from inactive renderItems in the list

		for ( let i = this.renderItemsIndex, il = this.renderItems.length; i < il; i ++ ) {

			const renderItem = this.renderItems[ i ];

			if ( renderItem.id === null ) break;

			renderItem.id = null;
			renderItem.object = null;
			renderItem.geometry = null;
			renderItem.material = null;
			renderItem.groupOrder = null;
			renderItem.renderOrder = null;
			renderItem.z = null;
			renderItem.group = null;
			renderItem.clippingContext = null;

		}

	}

}

class RenderLists {

	constructor( lighting ) {

		this.lighting = lighting;

		this.lists = new ChainMap();

	}

	get( scene, camera ) {

		const lists = this.lists;
		const keys = [ scene, camera ];

		let list = lists.get( keys );

		if ( list === undefined ) {

			list = new RenderList( this.lighting, scene, camera );
			lists.set( keys, list );

		}

		return list;

	}

	dispose() {

		this.lists = new ChainMap();

	}

}

let id = 0;

class RenderContext {

	constructor() {

		this.id = id ++;

		this.color = true;
		this.clearColor = true;
		this.clearColorValue = { r: 0, g: 0, b: 0, a: 1 };

		this.depth = true;
		this.clearDepth = true;
		this.clearDepthValue = 1;

		this.stencil = false;
		this.clearStencil = true;
		this.clearStencilValue = 1;

		this.viewport = false;
		this.viewportValue = new Vector4();

		this.scissor = false;
		this.scissorValue = new Vector4();

		this.textures = null;
		this.depthTexture = null;
		this.activeCubeFace = 0;
		this.sampleCount = 1;

		this.width = 0;
		this.height = 0;

		this.isRenderContext = true;

	}

	getCacheKey() {

		return getCacheKey( this );

	}

}

function getCacheKey( renderContext ) {

	const { textures, activeCubeFace } = renderContext;

	const values = [ activeCubeFace ];

	for ( const texture of textures ) {

		values.push( texture.id );

	}

	return hashArray( values );

}

class RenderContexts {

	constructor() {

		this.chainMaps = {};

	}

	get( scene, camera, renderTarget = null ) {

		const chainKey = [ scene, camera ];

		let attachmentState;

		if ( renderTarget === null ) {

			attachmentState = 'default';

		} else {

			const format = renderTarget.texture.format;
			const count = renderTarget.textures.length;

			attachmentState = `${ count }:${ format }:${ renderTarget.samples }:${ renderTarget.depthBuffer }:${ renderTarget.stencilBuffer }`;

		}

		const chainMap = this.getChainMap( attachmentState );

		let renderState = chainMap.get( chainKey );

		if ( renderState === undefined ) {

			renderState = new RenderContext();

			chainMap.set( chainKey, renderState );

		}

		if ( renderTarget !== null ) renderState.sampleCount = renderTarget.samples === 0 ? 1 : renderTarget.samples;

		return renderState;

	}

	getChainMap( attachmentState ) {

		return this.chainMaps[ attachmentState ] || ( this.chainMaps[ attachmentState ] = new ChainMap() );

	}

	dispose() {

		this.chainMaps = {};

	}

}

const _size$3 = /*@__PURE__*/ new Vector3();

class Textures extends DataMap {

	constructor( renderer, backend, info ) {

		super();

		this.renderer = renderer;
		this.backend = backend;
		this.info = info;

	}

	updateRenderTarget( renderTarget, activeMipmapLevel = 0 ) {

		const renderTargetData = this.get( renderTarget );

		const sampleCount = renderTarget.samples === 0 ? 1 : renderTarget.samples;
		const depthTextureMips = renderTargetData.depthTextureMips || ( renderTargetData.depthTextureMips = {} );

		const textures = renderTarget.textures;

		const size = this.getSize( textures[ 0 ] );

		const mipWidth = size.width >> activeMipmapLevel;
		const mipHeight = size.height >> activeMipmapLevel;

		let depthTexture = renderTarget.depthTexture || depthTextureMips[ activeMipmapLevel ];
		const useDepthTexture = renderTarget.depthBuffer === true || renderTarget.stencilBuffer === true;

		let textureNeedsUpdate = false;

		if ( depthTexture === undefined && useDepthTexture ) {

			depthTexture = new DepthTexture();
			depthTexture.format = renderTarget.stencilBuffer ? DepthStencilFormat : DepthFormat;
			depthTexture.type = renderTarget.stencilBuffer ? UnsignedInt248Type : UnsignedIntType; // FloatType
			depthTexture.image.width = mipWidth;
			depthTexture.image.height = mipHeight;

			depthTextureMips[ activeMipmapLevel ] = depthTexture;

		}

		if ( renderTargetData.width !== size.width || size.height !== renderTargetData.height ) {

			textureNeedsUpdate = true;

			if ( depthTexture ) {

				depthTexture.needsUpdate = true;
				depthTexture.image.width = mipWidth;
				depthTexture.image.height = mipHeight;

			}

		}

		renderTargetData.width = size.width;
		renderTargetData.height = size.height;
		renderTargetData.textures = textures;
		renderTargetData.depthTexture = depthTexture || null;
		renderTargetData.depth = renderTarget.depthBuffer;
		renderTargetData.stencil = renderTarget.stencilBuffer;
		renderTargetData.renderTarget = renderTarget;

		if ( renderTargetData.sampleCount !== sampleCount ) {

			textureNeedsUpdate = true;

			if ( depthTexture ) {

				depthTexture.needsUpdate = true;

			}

			renderTargetData.sampleCount = sampleCount;

		}

		//

		const options = { sampleCount };

		for ( let i = 0; i < textures.length; i ++ ) {

			const texture = textures[ i ];

			if ( textureNeedsUpdate ) texture.needsUpdate = true;

			this.updateTexture( texture, options );

		}

		if ( depthTexture ) {

			this.updateTexture( depthTexture, options );

		}

		// dispose handler

		if ( renderTargetData.initialized !== true ) {

			renderTargetData.initialized = true;

			// dispose

			const onDispose = () => {

				renderTarget.removeEventListener( 'dispose', onDispose );

				for ( let i = 0; i < textures.length; i ++ ) {

					this._destroyTexture( textures[ i ] );

				}

				if ( depthTexture ) {

					this._destroyTexture( depthTexture );

				}

				this.delete( renderTarget );

			};

			renderTarget.addEventListener( 'dispose', onDispose );

		}

	}

	updateTexture( texture, options = {} ) {

		const textureData = this.get( texture );
		if ( textureData.initialized === true && textureData.version === texture.version ) return;

		const isRenderTarget = texture.isRenderTargetTexture || texture.isDepthTexture || texture.isFramebufferTexture;
		const backend = this.backend;

		if ( isRenderTarget && textureData.initialized === true ) {

			// it's an update

			backend.destroySampler( texture );
			backend.destroyTexture( texture );

		}

		//

		if ( texture.isFramebufferTexture ) {

			const renderTarget = this.renderer.getRenderTarget();

			if ( renderTarget ) {

				texture.type = renderTarget.texture.type;

			} else {

				texture.type = UnsignedByteType;

			}

		}

		//

		const { width, height, depth } = this.getSize( texture );

		options.width = width;
		options.height = height;
		options.depth = depth;
		options.needsMipmaps = this.needsMipmaps( texture );
		options.levels = options.needsMipmaps ? this.getMipLevels( texture, width, height ) : 1;

		//

		if ( isRenderTarget || texture.isStorageTexture === true ) {

			backend.createSampler( texture );
			backend.createTexture( texture, options );

			textureData.generation = texture.version;

		} else {

			const needsCreate = textureData.initialized !== true;

			if ( needsCreate ) backend.createSampler( texture );

			if ( texture.version > 0 ) {

				const image = texture.image;

				if ( image === undefined ) {

					console.warn( 'THREE.Renderer: Texture marked for update but image is undefined.' );

				} else if ( image.complete === false ) {

					console.warn( 'THREE.Renderer: Texture marked for update but image is incomplete.' );

				} else {

					if ( texture.images ) {

						const images = [];

						for ( const image of texture.images ) {

							images.push( image );

						}

						options.images = images;

					} else {

						options.image = image;

					}

					if ( textureData.isDefaultTexture === undefined || textureData.isDefaultTexture === true ) {

						backend.createTexture( texture, options );

						textureData.isDefaultTexture = false;
						textureData.generation = texture.version;

					}

					if ( texture.source.dataReady === true ) backend.updateTexture( texture, options );

					if ( options.needsMipmaps && texture.mipmaps.length === 0 ) backend.generateMipmaps( texture );

				}

			} else {

				// async update

				backend.createDefaultTexture( texture );

				textureData.isDefaultTexture = true;
				textureData.generation = texture.version;

			}

		}

		// dispose handler

		if ( textureData.initialized !== true ) {

			textureData.initialized = true;
			textureData.generation = texture.version;

			//

			this.info.memory.textures ++;

			// dispose

			const onDispose = () => {

				texture.removeEventListener( 'dispose', onDispose );

				this._destroyTexture( texture );

				this.info.memory.textures --;

			};

			texture.addEventListener( 'dispose', onDispose );

		}

		//

		textureData.version = texture.version;

	}

	getSize( texture, target = _size$3 ) {

		let image = texture.images ? texture.images[ 0 ] : texture.image;

		if ( image ) {

			if ( image.image !== undefined ) image = image.image;

			target.width = image.width || 1;
			target.height = image.height || 1;
			target.depth = texture.isCubeTexture ? 6 : ( image.depth || 1 );

		} else {

			target.width = target.height = target.depth = 1;

		}

		return target;

	}

	getMipLevels( texture, width, height ) {

		let mipLevelCount;

		if ( texture.isCompressedTexture ) {

			if ( texture.mipmaps ) {

				mipLevelCount = texture.mipmaps.length;

			} else {

				mipLevelCount = 1;

			}

		} else {

			mipLevelCount = Math.floor( Math.log2( Math.max( width, height ) ) ) + 1;

		}

		return mipLevelCount;

	}

	needsMipmaps( texture ) {

		return this.isEnvironmentTexture( texture ) || texture.isCompressedTexture === true || texture.generateMipmaps;

	}

	isEnvironmentTexture( texture ) {

		const mapping = texture.mapping;

		return ( mapping === EquirectangularReflectionMapping || mapping === EquirectangularRefractionMapping ) || ( mapping === CubeReflectionMapping || mapping === CubeRefractionMapping );

	}

	_destroyTexture( texture ) {

		this.backend.destroySampler( texture );
		this.backend.destroyTexture( texture );

		this.delete( texture );

	}

}

class Color4 extends Color {

	constructor( r, g, b, a = 1 ) {

		super( r, g, b );

		this.a = a;

	}

	set( r, g, b, a = 1 ) {

		this.a = a;

		return super.set( r, g, b );

	}

	copy( color ) {

		if ( color.a !== undefined ) this.a = color.a;

		return super.copy( color );

	}

	clone() {

		return new this.constructor( this.r, this.g, this.b, this.a );

	}

}

/** @module ParameterNode **/

/**
 * Special version of {@link PropertyNode} which is used for parameters.
 *
 * @augments PropertyNode
 */
class ParameterNode extends PropertyNode {

	static get type() {

		return 'ParameterNode';

	}

	/**
	 * Constructs a new parameter node.
	 *
	 * @param {String} nodeType - The type of the node.
	 * @param {String?} [name=null] - The name of the parameter in the shader.
	 */
	constructor( nodeType, name = null ) {

		super( nodeType, name );

		/**
		 * This flag can be used for type testing.
		 *
		 * @type {Boolean}
		 * @readonly
		 * @default true
		 */
		this.isParameterNode = true;

	}

	getHash() {

		return this.uuid;

	}

	generate() {

		return this.name;

	}

}

/**
 * TSL function for creating a parameter node.
 *
 * @function
 * @param {String} type - The type of the node.
 * @param {String?} name - The name of the parameter in the shader.
 * @returns {ParameterNode}
 */
const parameter = ( type, name ) => nodeObject( new ParameterNode( type, name ) );

/** @module StackNode **/

/**
 * Stack is a helper for Nodes that need to produce stack-based code instead of continuous flow.
 * They are usually needed in cases like `If`, `Else`.
 *
 * @augments Node
 */
class StackNode extends Node {

	static get type() {

		return 'StackNode';

	}

	/**
	 * Constructs a new stack node.
	 *
	 * @param {StackNode?} [parent=null] - The parent stack node.
	 */
	constructor( parent = null ) {

		super();

		/**
		 * List of nodes.
		 *
		 * @type {Array<Node>}
		 */
		this.nodes = [];

		/**
		 * The output node.
		 *
		 * @type {Node?}
		 * @default null
		 */
		this.outputNode = null;

		/**
		 * The parent stack node.
		 *
		 * @type {StackNode}
		 * @default null
		 */
		this.parent = parent;

		/**
		 * The current conditional node.
		 *
		 * @private
		 * @type {ConditionalNode}
		 * @default null
		 */
		this._currentCond = null;

		/**
		 * This flag can be used for type testing.
		 *
		 * @type {Boolean}
		 * @readonly
		 * @default true
		 */
		this.isStackNode = true;

	}

	getNodeType( builder ) {

		return this.outputNode ? this.outputNode.getNodeType( builder ) : 'void';

	}

	/**
	 * Adds a node to this stack.
	 *
	 * @param {Node} node - The node to add.
	 * @return {StackNode} A reference to this stack node.
	 */
	add( node ) {

		this.nodes.push( node );

		return this;

	}

	/**
	 * Represent an `if` statement in TSL.
	 *
	 * @param {Node} boolNode - Represents the condition.
	 * @param {Function} method - TSL code which is executed if the condition evaluates to `true`.
	 * @return {StackNode} A reference to this stack node.
	 */
	If( boolNode, method ) {

		const methodNode = new ShaderNode( method );
		this._currentCond = select( boolNode, methodNode );

		return this.add( this._currentCond );

	}

	/**
	 * Represent an `elseif` statement in TSL.
	 *
	 * @param {Node} boolNode - Represents the condition.
	 * @param {Function} method - TSL code which is executed if the condition evaluates to `true`.
	 * @return {StackNode} A reference to this stack node.
	 */
	ElseIf( boolNode, method ) {

		const methodNode = new ShaderNode( method );
		const ifNode = select( boolNode, methodNode );

		this._currentCond.elseNode = ifNode;
		this._currentCond = ifNode;

		return this;

	}

	/**
	 * Represent an `else` statement in TSL.
	 *
	 * @param {Function} method - TSL code which is executed in the `else` case.
	 * @return {StackNode} A reference to this stack node.
	 */
	Else( method ) {

		this._currentCond.elseNode = new ShaderNode( method );

		return this;

	}

	build( builder, ...params ) {

		const previousStack = getCurrentStack();

		setCurrentStack( this );

		for ( const node of this.nodes ) {

			node.build( builder, 'void' );

		}

		setCurrentStack( previousStack );

		return this.outputNode ? this.outputNode.build( builder, ...params ) : super.build( builder, ...params );

	}

	//

	else( ...params ) { // @deprecated, r168

		console.warn( 'TSL.StackNode: .else() has been renamed to .Else().' );
		return this.Else( ...params );

	}

	elseif( ...params ) { // @deprecated, r168

		console.warn( 'TSL.StackNode: .elseif() has been renamed to .ElseIf().' );
		return this.ElseIf( ...params );

	}

}

/**
 * TSL function for creating a stack node.
 *
 * @function
 * @param {StackNode?} [parent=null] - The parent stack node.
 * @returns {StackNode}
 */
const stack = /*@__PURE__*/ nodeProxy( StackNode );

/** @module OutputStructNode **/

/**
 * This node can be used to define multiple outputs in a shader programs.
 *
 * @augments Node
 */
class OutputStructNode extends Node {

	static get type() {

		return 'OutputStructNode';

	}

	/**
	 * Constructs a new output struct node. The constructor can be invoked with an
	 * arbitrary number of nodes representing the members.
	 *
	 * @param {...Node} members - A parameter list of nodes.
	 */
	constructor( ...members ) {

		super();

		/**
		 * An array of nodes which defines the output.
		 *
		 * @type {Array<Node>}
		 */
		this.members = members;

		/**
		 * This flag can be used for type testing.
		 *
		 * @type {Boolean}
		 * @readonly
		 * @default true
		 */
		this.isOutputStructNode = true;

	}

	setup( builder ) {

		super.setup( builder );

		const members = this.members;
		const types = [];

		for ( let i = 0; i < members.length; i ++ ) {

			types.push( members[ i ].getNodeType( builder ) );

		}

		this.nodeType = builder.getStructTypeFromNode( this, types ).name;

	}

	generate( builder, output ) {

		const propertyName = builder.getOutputStructName();
		const members = this.members;

		const structPrefix = propertyName !== '' ? propertyName + '.' : '';

		for ( let i = 0; i < members.length; i ++ ) {

			const snippet = members[ i ].build( builder, output );

			builder.addLineFlowCode( `${ structPrefix }m${ i } = ${ snippet }`, this );

		}

		return propertyName;

	}

}

/**
 * TSL function for creating an output struct node.
 *
 * @function
 * @param {...Node} members - A parameter list of nodes.
 * @returns {OutputStructNode}
 */
const outputStruct = /*@__PURE__*/ nodeProxy( OutputStructNode );

/** @module MRTNode **/

/**
 * Returns the MRT texture index for the given name.
 *
 * @param {Array<Texture>} textures - The textures of a MRT-configured render target.
 * @param {String} name - The name of the MRT texture which index is requested.
 * @return {Number} The texture index.
 */
function getTextureIndex( textures, name ) {

	for ( let i = 0; i < textures.length; i ++ ) {

		if ( textures[ i ].name === name ) {

			return i;

		}

	}

	return - 1;

}

/**
 * This node can be used setup a MRT context for rendering. A typical MRT setup for
 * post-processing is shown below:
 * ```js
 * const mrtNode = mrt( {
 *   output: output,
 *   normal: normalView
 * } ) );
 * ```
 * The MRT output is defined as a dictionary.
 *
 * @augments OutputStructNode
 */
class MRTNode extends OutputStructNode {

	static get type() {

		return 'MRTNode';

	}

	/**
	 * Constructs a new output struct node.
	 *
	 * @param {Object<String, Node>} outputNodes - The MRT outputs.
	 */
	constructor( outputNodes ) {

		super();

		/**
		 * A dictionary representing the MRT outputs. The key
		 * is the name of the output, the value the node which produces
		 * the output result.
		 *
		 * @type {Object<String, Node>}
		 */
		this.outputNodes = outputNodes;

		/**
		 * This flag can be used for type testing.
		 *
		 * @type {Boolean}
		 * @readonly
		 * @default true
		 */
		this.isMRTNode = true;

	}

	/**
	 * Returns `true` if the MRT node has an output with the given name.
	 *
	 * @param {String} name - The name of the output.
	 * @return {NodeBuilder} Whether the MRT node has an output for the given name or not.
	 */
	has( name ) {

		return this.outputNodes[ name ] !== undefined;

	}

	/**
	 * Returns the output node for the given name.
	 *
	 * @param {String} name - The name of the output.
	 * @return {Node} The output node.
	 */
	get( name ) {

		return this.outputNodes[ name ];

	}

	/**
	 * Merges the outputs of the given MRT node with the outputs of this node.
	 *
	 * @param {MRTNode} mrtNode - The MRT to merge.
	 * @return {MRTNode} A new MRT node with merged outputs..
	 */
	merge( mrtNode ) {

		const outputs = { ...this.outputNodes, ...mrtNode.outputNodes };

		return mrt( outputs );

	}

	setup( builder ) {

		const outputNodes = this.outputNodes;
		const mrt = builder.renderer.getRenderTarget();

		const members = [];

		const textures = mrt.textures;

		for ( const name in outputNodes ) {

			const index = getTextureIndex( textures, name );

			members[ index ] = vec4( outputNodes[ name ] );

		}

		this.members = members;

		return super.setup( builder );

	}

}

/**
 * TSL function for creating a MRT node.
 *
 * @function
 * @param {Object<String, Node>} outputNodes - The MRT outputs.
 * @returns {MRTNode}
 */
const mrt = /*@__PURE__*/ nodeProxy( MRTNode );

/** @module Hash **/

/**
 * Generates a hash value in the range `[0, 1]` from the given seed.
 *
 * @method
 * @param {Node<float>} seed - The seed.
 * @return {Node<float>} The hash value.
 */
const hash = /*@__PURE__*/ Fn( ( [ seed ] ) => {

	// Taken from https://www.shadertoy.com/view/XlGcRh, originally from pcg-random.org

	const state = seed.toUint().mul( 747796405 ).add( 2891336453 );
	const word = state.shiftRight( state.shiftRight( 28 ).add( 4 ) ).bitXor( state ).mul( 277803737 );
	const result = word.shiftRight( 22 ).bitXor( word );

	return result.toFloat().mul( 1 / 2 ** 32 ); // Convert to range [0, 1)

} );

/** @module MathUtils **/

/**
 * A function that remaps the `[0,1]` interval into the `[0,1]` interval.
 * The corners are mapped to `0` and the center to `1`.
 * Reference: {@link https://iquilezles.org/articles/functions/}.
 *
 * @method
 * @param {Node<float>} x - The value to remap.
 * @param {Node<float>} k - Allows to control the remapping functions shape by rising the parabola to a power `k`.
 * @return {Node<float>} The remapped value.
 */
const parabola = ( x, k ) => pow( mul( 4.0, x.mul( sub( 1.0, x ) ) ), k );

/**
 * A function that remaps the `[0,1]` interval into the `[0,1]` interval.
 * Expands the sides and compresses the center, and keeps `0.5` mapped to `0.5`.
 * Reference: {@link https://iquilezles.org/articles/functions/}.
 *
 * @method
 * @param {Node<float>} x - The value to remap.
 * @param {Node<float>} k - `k=1` is the identity curve,`k<1` produces the classic `gain()` shape, and `k>1` produces "s" shaped curves.
 * @return {Node<float>} The remapped value.
 */
const gain = ( x, k ) => x.lessThan( 0.5 ) ? parabola( x.mul( 2.0 ), k ).div( 2.0 ) : sub( 1.0, parabola( mul( sub( 1.0, x ), 2.0 ), k ).div( 2.0 ) );

/**
 * A function that remaps the `[0,1]` interval into the `[0,1]` interval.
 * A generalization of the `parabola()`. Keeps the corners mapped to 0 but allows the control of the shape one either side of the curve.
 * Reference: {@link https://iquilezles.org/articles/functions/}.
 *
 * @method
 * @param {Node<float>} x - The value to remap.
 * @param {Node<float>} a - First control parameter.
 * @param {Node<float>} b - Second control parameter.
 * @return {Node<float>} The remapped value.
 */
const pcurve = ( x, a, b ) => pow( div( pow( x, a ), add( pow( x, a ), pow( sub( 1.0, x ), b ) ) ), 1.0 / a );

/**
 * A phase shifted sinus curve that starts at zero and ends at zero, with bouncing behavior.
 * Reference: {@link https://iquilezles.org/articles/functions/}.
 *
 * @method
 * @param {Node<float>} x - The value to compute the sin for.
 * @param {Node<float>} k - Controls the amount of bounces.
 * @return {Node<float>} The result value.
 */
const sinc = ( x, k ) => sin( PI.mul( k.mul( x ).sub( 1.0 ) ) ).div( PI.mul( k.mul( x ).sub( 1.0 ) ) );

// https://github.com/cabbibo/glsl-tri-noise-3d


/** @module TriNoise3D **/

const tri = /*@__PURE__*/ Fn( ( [ x ] ) => {

	return x.fract().sub( .5 ).abs();

} ).setLayout( {
	name: 'tri',
	type: 'float',
	inputs: [
		{ name: 'x', type: 'float' }
	]
} );

const tri3 = /*@__PURE__*/ Fn( ( [ p ] ) => {

	return vec3( tri( p.z.add( tri( p.y.mul( 1. ) ) ) ), tri( p.z.add( tri( p.x.mul( 1. ) ) ) ), tri( p.y.add( tri( p.x.mul( 1. ) ) ) ) );

} ).setLayout( {
	name: 'tri3',
	type: 'vec3',
	inputs: [
		{ name: 'p', type: 'vec3' }
	]
} );

/**
 * Generates a noise value from the given position, speed and time parameters.
 *
 * @method
 * @param {Node<vec3>} position - The position.
 * @param {Node<float>} speed - The speed.
 * @param {Node<float>} time - The time.
 * @return {Node<float>} The generated noise.
 */
const triNoise3D = /*@__PURE__*/ Fn( ( [ position, speed, time ] ) => {

	const p = vec3( position ).toVar();
	const z = float( 1.4 ).toVar();
	const rz = float( 0.0 ).toVar();
	const bp = vec3( p ).toVar();

	Loop( { start: float( 0.0 ), end: float( 3.0 ), type: 'float', condition: '<=' }, () => {

		const dg = vec3( tri3( bp.mul( 2.0 ) ) ).toVar();
		p.addAssign( dg.add( time.mul( float( 0.1 ).mul( speed ) ) ) );
		bp.mulAssign( 1.8 );
		z.mulAssign( 1.5 );
		p.mulAssign( 1.2 );

		const t = float( tri( p.z.add( tri( p.x.add( tri( p.y ) ) ) ) ) ).toVar();
		rz.addAssign( t.div( z ) );
		bp.addAssign( 0.14 );

	} );

	return rz;

} ).setLayout( {
	name: 'triNoise3D',
	type: 'float',
	inputs: [
		{ name: 'position', type: 'vec3' },
		{ name: 'speed', type: 'float' },
		{ name: 'time', type: 'float' }
	]
} );

/** @module FunctionOverloadingNode **/

/**
 * This class allows to define multiple overloaded versions
 * of the same function. Depending on the parameters of the function
 * call, the node picks the best-fit overloaded version.
 *
 * @augments Node
 */
class FunctionOverloadingNode extends Node {

	static get type() {

		return 'FunctionOverloadingNode';

	}

	/**
	 * Constructs a new function overloading node.
	 *
	 * @param {Array<Function>} functionNodes - Array of `Fn` function definitions.
	 * @param {...Node} parametersNodes - A list of parameter nodes.
	 */
	constructor( functionNodes = [], ...parametersNodes ) {

		super();

		/**
		 * Array of `Fn` function definitions.
		 *
		 * @type {Array<Function>}
		 */
		this.functionNodes = functionNodes;

		/**
		 * A list of parameter nodes.
		 *
		 * @type {Array<Node>}
		 */
		this.parametersNodes = parametersNodes;

		/**
		 * The selected overloaded function call.
		 *
		 * @private
		 * @type {ShaderCallNodeInternal}
		 */
		this._candidateFnCall = null;

		/**
		 * This node is marked as global.
		 *
		 * @type {Boolean}
		 * @default true
		 */
		this.global = true;

	}

	/**
	 * This method is overwritten since the node type is inferred from
	 * the function's return type.
	 *
	 * @param {NodeBuilder} builder - The current node builder.
	 * @return {String} The node type.
	 */
	getNodeType() {

		return this.functionNodes[ 0 ].shaderNode.layout.type;

	}

	setup( builder ) {

		const params = this.parametersNodes;

		let candidateFnCall = this._candidateFnCall;

		if ( candidateFnCall === null ) {

			let candidateFn = null;
			let candidateScore = - 1;

			for ( const functionNode of this.functionNodes ) {

				const shaderNode = functionNode.shaderNode;
				const layout = shaderNode.layout;

				if ( layout === null ) {

					throw new Error( 'FunctionOverloadingNode: FunctionNode must be a layout.' );

				}

				const inputs = layout.inputs;

				if ( params.length === inputs.length ) {

					let score = 0;

					for ( let i = 0; i < params.length; i ++ ) {

						const param = params[ i ];
						const input = inputs[ i ];

						if ( param.getNodeType( builder ) === input.type ) {

							score ++;

						} else {

							score = 0;

						}

					}

					if ( score > candidateScore ) {

						candidateFn = functionNode;
						candidateScore = score;

					}

				}

			}

			this._candidateFnCall = candidateFnCall = candidateFn( ...params );

		}

		return candidateFnCall;

	}

}

const overloadingBaseFn = /*@__PURE__*/ nodeProxy( FunctionOverloadingNode );

/**
 * TSL function for creating a function overloading node.
 *
 * @function
 * @param {Array<Function>} functionNodes - Array of `Fn` function definitions.
 * @returns {FunctionOverloadingNode}
 */
const overloadingFn = ( functionNodes ) => ( ...params ) => overloadingBaseFn( functionNodes, ...params );

/** @module Timer **/

/**
 * Represents the elapsed time in seconds.
 *
 * @type {UniformNode<float>}
 */
const time = /*@__PURE__*/ uniform( 0 ).setGroup( renderGroup ).onRenderUpdate( ( frame ) => frame.time );

/**
 * Represents the delta time in seconds.
 *
 * @type {UniformNode<float>}
 */
const deltaTime = /*@__PURE__*/ uniform( 0 ).setGroup( renderGroup ).onRenderUpdate( ( frame ) => frame.deltaTime );

/**
 * Represents the current frame ID.
 *
 * @type {UniformNode<uint>}
 */
const frameId = /*@__PURE__*/ uniform( 0, 'uint' ).setGroup( renderGroup ).onRenderUpdate( ( frame ) => frame.frameId );

// Deprecated

const timerLocal = ( timeScale = 1 ) => { // @deprecated, r170

	console.warn( 'TSL: timerLocal() is deprecated. Use "time" instead.' );
	return time.mul( timeScale );

};

const timerGlobal = ( timeScale = 1 ) => { // @deprecated, r170

	console.warn( 'TSL: timerGlobal() is deprecated. Use "time" instead.' );
	return time.mul( timeScale );

};

const timerDelta = ( timeScale = 1 ) => { // @deprecated, r170

	console.warn( 'TSL: timerDelta() is deprecated. Use "deltaTime" instead.' );
	return deltaTime.mul( timeScale );

};

/** @module Oscillators **/

/**
 * Generates a sine wave oscillation based on a timer.
 *
 * @method
 * @param {Node<float>} t - The timer to generate the oscillation with.
 * @return {Node<float>} The oscillation node.
 */
const oscSine = ( t = time ) => t.add( 0.75 ).mul( Math.PI * 2 ).sin().mul( 0.5 ).add( 0.5 );

/**
 * Generates a square wave oscillation based on a timer.
 *
 * @method
 * @param {Node<float>} t - The timer to generate the oscillation with.
 * @return {Node<float>} The oscillation node.
 */
const oscSquare = ( t = time ) => t.fract().round();

/**
 * Generates a triangle wave oscillation based on a timer.
 *
 * @method
 * @param {Node<float>} t - The timer to generate the oscillation with.
 * @return {Node<float>} The oscillation node.
 */
const oscTriangle = ( t = time ) => t.add( 0.5 ).fract().mul( 2 ).sub( 1 ).abs();

/**
 * Generates a sawtooth wave oscillation based on a timer.
 *
 * @method
 * @param {Node<float>} t - The timer to generate the oscillation with.
 * @return {Node<float>} The oscillation node.
 */
const oscSawtooth = ( t = time ) => t.fract();

/** @module UVUtils **/

/**
 * Rotates the given uv coordinates around a center point
 *
 * @method
 * @param {Node<vec2>} uv - The uv coordinates.
 * @param {Node<float>} rotation - The rotation defined in radians.
 * @param {Node<vec2>} center - The center of rotation
 * @return {Node<vec2>} The rotated uv coordinates.
 */
const rotateUV = /*@__PURE__*/ Fn( ( [ uv, rotation, center = vec2( 0.5 ) ] ) => {

	return rotate( uv.sub( center ), rotation ).add( center );

} );

/**
 * Applies a spherical warping effect to the given uv coordinates.
 *
 * @method
 * @param {Node<vec2>} uv - The uv coordinates.
 * @param {Node<float>} strength - The strength of the effect.
 * @param {Node<vec2>} center - The center point
 * @return {Node<vec2>} The updated uv coordinates.
 */
const spherizeUV = /*@__PURE__*/ Fn( ( [ uv, strength, center = vec2( 0.5 ) ] ) => {

	const delta = uv.sub( center );
	const delta2 = delta.dot( delta );
	const delta4 = delta2.mul( delta2 );
	const deltaOffset = delta4.mul( strength );

	return uv.add( delta.mul( deltaOffset ) );

} );

/** @module SpriteUtils **/

/**
 * This can be used to achieve a billboarding behavior for flat meshes. That means they are
 * oriented always towards the camera.
 *
 * ```js
 * material.vertexNode = billboarding();
 * ```
 *
 * @method
 * @param {Object} config - The configuration object.
 * @param {Node<vec3>?} [config.position=null] - Can be used to define the vertex positions in world space.
 * @param {Boolean} [config.horizontal=true] - Whether to follow the camera rotation horizontally or not.
 * @param {Boolean} [config.vertical=false] - Whether to follow the camera rotation vertically or not.
 * @return {Node<vec3>} The updated vertex position in clip space.
 */
const billboarding = /*@__PURE__*/ Fn( ( { position = null, horizontal = true, vertical = false } ) => {

	let worldMatrix;

	if ( position !== null ) {

		worldMatrix = modelWorldMatrix.toVar();
		worldMatrix[ 3 ][ 0 ] = position.x;
		worldMatrix[ 3 ][ 1 ] = position.y;
		worldMatrix[ 3 ][ 2 ] = position.z;

	} else {

		worldMatrix = modelWorldMatrix;

	}

	const modelViewMatrix = cameraViewMatrix.mul( worldMatrix );

	if ( defined( horizontal ) ) {

		modelViewMatrix[ 0 ][ 0 ] = modelWorldMatrix[ 0 ].length();
		modelViewMatrix[ 0 ][ 1 ] = 0;
		modelViewMatrix[ 0 ][ 2 ] = 0;

	}

	if ( defined( vertical ) ) {

		modelViewMatrix[ 1 ][ 0 ] = 0;
		modelViewMatrix[ 1 ][ 1 ] = modelWorldMatrix[ 1 ].length();
		modelViewMatrix[ 1 ][ 2 ] = 0;

	}

	modelViewMatrix[ 2 ][ 0 ] = 0;
	modelViewMatrix[ 2 ][ 1 ] = 0;
	modelViewMatrix[ 2 ][ 2 ] = 1;

	return cameraProjectionMatrix.mul( modelViewMatrix ).mul( positionLocal );

} );

/** @module ViewportUtils **/

/**
 * A special version of a screen uv function that involves a depth comparison
 * when computing the final uvs. The function mitigates visual errors when
 * using viewport texture nodes for refraction purposes. Without this function
 * objects in front of a refractive surface might appear on the refractive surface
 * which is incorrect.
 *
 * @method
 * @param {Node<vec2>?} uv - Optional uv coordinates. By default `screenUV` is used.
 * @return {Node<vec2>} The update uv coordinates.
 */
const viewportSafeUV = /*@__PURE__*/ Fn( ( [ uv = null ] ) => {

	const depth = linearDepth();
	const depthDiff = linearDepth( viewportDepthTexture( uv ) ).sub( depth );
	const finalUV = depthDiff.lessThan( 0 ).select( screenUV, uv );

	return finalUV;

} );

/** @module SpriteSheetUVNode **/

/**
 * Can be used to compute texture coordinates for animated sprite sheets.
 *
 * ```js
 * const uvNode = spritesheetUV( vec2( 6, 6 ), uv(), time.mul( animationSpeed ) );
 *
 * material.colorNode = texture( spriteSheet, uvNode );
 * ```
 *
 * @augments Node
 */
class SpriteSheetUVNode extends Node {

	static get type() {

		return 'SpriteSheetUVNode';

	}

	/**
	 * Constructs a new sprite sheet uv node.
	 *
	 * @param {Node<vec2>} countNode - The node that defines the number of sprites in the x and y direction (e.g 6x6).
	 * @param {Node<vec2>} [uvNode=uv()] - The uv node.
	 * @param {Node<float>} [frameNode=float()] - The node that defines the current frame/sprite.
	 */
	constructor( countNode, uvNode = uv(), frameNode = float( 0 ) ) {

		super( 'vec2' );

		/**
		 * The node that defines the number of sprites in the x and y direction (e.g 6x6).
		 *
		 * @type {Node<vec2>}
		 */
		this.countNode = countNode;

		/**
		 * The uv node.
		 *
		 * @type {Node<vec2>}
		 */
		this.uvNode = uvNode;

		/**
		 * The node that defines the current frame/sprite.
		 *
		 * @type {Node<float>}
		 */
		this.frameNode = frameNode;

	}

	setup() {

		const { frameNode, uvNode, countNode } = this;

		const { width, height } = countNode;

		const frameNum = frameNode.mod( width.mul( height ) ).floor();

		const column = frameNum.mod( width );
		const row = height.sub( frameNum.add( 1 ).div( width ).ceil() );

		const scale = countNode.reciprocal();
		const uvFrameOffset = vec2( column, row );

		return uvNode.add( uvFrameOffset ).mul( scale );

	}

}

/**
 * TSL function for creating a sprite sheet uv node.
 *
 * @function
 * @param {Node<vec2>} countNode - The node that defines the number of sprites in the x and y direction (e.g 6x6).
 * @param {Node<vec2>} [uvNode=uv()] - The uv node.
 * @param {Node<float>} [frameNode=float()] - The node that defines the current frame/sprite.
 * @returns {SpriteSheetUVNode}
 */
const spritesheetUV = /*@__PURE__*/ nodeProxy( SpriteSheetUVNode );

/** @module TriplanarTexturesNode **/

/**
 * Can be used for triplanar texture mapping.
 *
 * ```js
 * material.colorNode = triplanarTexture( texture( diffuseMap ) );
 * ```
 *
 * @augments Node
 */
class TriplanarTexturesNode extends Node {

	static get type() {

		return 'TriplanarTexturesNode';

	}

	/**
	 * Constructs a new triplanar textures node.
	 *
	 * @param {Node} textureXNode - First texture node.
	 * @param {Node?} [textureYNode=null] - Second texture node. When not set, the shader will sample from `textureXNode` instead.
	 * @param {Node?} [textureZNode=null] - Third texture node. When not set, the shader will sample from `textureXNode` instead.
	 * @param {Node<float>?} [scaleNode=float(1)] - The scale node.
	 * @param {Node<vec3>?} [positionNode=positionLocal] - Vertex positions in local space.
	 * @param {Node<vec3>?} [normalNode=normalLocal] - Normals in local space.
	 */
	constructor( textureXNode, textureYNode = null, textureZNode = null, scaleNode = float( 1 ), positionNode = positionLocal, normalNode = normalLocal ) {

		super( 'vec4' );

		/**
		 * First texture node.
		 *
		 * @type {Node}
		 */
		this.textureXNode = textureXNode;

		/**
		 * Second texture node. When not set, the shader will sample from `textureXNode` instead.
		 *
		 * @type {Node}
		 * @default null
		 */
		this.textureYNode = textureYNode;

		/**
		 * Third texture node. When not set, the shader will sample from `textureXNode` instead.
		 *
		 * @type {Node}
		 * @default null
		 */
		this.textureZNode = textureZNode;

		/**
		 * The scale node.
		 *
		 * @type {Node<float>}
		 * @default float(1)
		 */
		this.scaleNode = scaleNode;

		/**
		 * Vertex positions in local space.
		 *
		 * @type {Node<vec3>}
		 * @default positionLocal
		 */
		this.positionNode = positionNode;

		/**
		 * Normals in local space.
		 *
		 * @type {Node<vec3>}
		 * @default normalLocal
		 */
		this.normalNode = normalNode;

	}

	setup() {

		const { textureXNode, textureYNode, textureZNode, scaleNode, positionNode, normalNode } = this;

		// Ref: https://github.com/keijiro/StandardTriplanar

		// Blending factor of triplanar mapping
		let bf = normalNode.abs().normalize();
		bf = bf.div( bf.dot( vec3( 1.0 ) ) );

		// Triplanar mapping
		const tx = positionNode.yz.mul( scaleNode );
		const ty = positionNode.zx.mul( scaleNode );
		const tz = positionNode.xy.mul( scaleNode );

		// Base color
		const textureX = textureXNode.value;
		const textureY = textureYNode !== null ? textureYNode.value : textureX;
		const textureZ = textureZNode !== null ? textureZNode.value : textureX;

		const cx = texture( textureX, tx ).mul( bf.x );
		const cy = texture( textureY, ty ).mul( bf.y );
		const cz = texture( textureZ, tz ).mul( bf.z );

		return add( cx, cy, cz );

	}

}

/**
 * TSL function for creating a triplanar textures node.
 *
 * @function
 * @param {Node} textureXNode - First texture node.
 * @param {Node?} [textureYNode=null] - Second texture node. When not set, the shader will sample from `textureXNode` instead.
 * @param {Node?} [textureZNode=null] - Third texture node. When not set, the shader will sample from `textureXNode` instead.
 * @param {Node<float>?} [scaleNode=float(1)] - The scale node.
 * @param {Node<vec3>?} [positionNode=positionLocal] - Vertex positions in local space.
 * @param {Node<vec3>?} [normalNode=normalLocal] - Normals in local space.
 * @returns {TriplanarTexturesNode}
 */
const triplanarTextures = /*@__PURE__*/ nodeProxy( TriplanarTexturesNode );

/**
 * TSL function for creating a triplanar textures node.
 *
 * @function
 * @param {Node} textureXNode - First texture node.
 * @param {Node?} [textureYNode=null] - Second texture node. When not set, the shader will sample from `textureXNode` instead.
 * @param {Node?} [textureZNode=null] - Third texture node. When not set, the shader will sample from `textureXNode` instead.
 * @param {Node<float>?} [scaleNode=float(1)] - The scale node.
 * @param {Node<vec3>?} [positionNode=positionLocal] - Vertex positions in local space.
 * @param {Node<vec3>?} [normalNode=normalLocal] - Normals in local space.
 * @returns {TriplanarTexturesNode}
 */
const triplanarTexture = ( ...params ) => triplanarTextures( ...params );

/** @module ReflectorNode **/

const _reflectorPlane = new Plane();
const _normal = new Vector3();
const _reflectorWorldPosition = new Vector3();
const _cameraWorldPosition = new Vector3();
const _rotationMatrix = new Matrix4();
const _lookAtPosition = new Vector3( 0, 0, - 1 );
const clipPlane = new Vector4();

const _view = new Vector3();
const _target = new Vector3();
const _q = new Vector4();

const _size$2 = new Vector2();

const _defaultRT = new RenderTarget();
const _defaultUV = screenUV.flipX();

_defaultRT.depthTexture = new DepthTexture( 1, 1 );

let _inReflector = false;

/**
 * This node can be used to implement mirror-like flat reflective surfaces.
 *
 * ```js
 * const groundReflector = reflector();
 * material.colorNode = groundReflector;
 *
 * const plane = new Mesh( geometry, material );
 * plane.add( groundReflector.target );
 * ```
 *
 * @augments module:TextureNode~TextureNode
 */
class ReflectorNode extends TextureNode {

	static get type() {

		return 'ReflectorNode';

	}

	/**
	 * Constructs a new reflector node.
	 *
	 * @param {Object} [parameters={}] - An object holding configuration parameters.
	 * @param {Object3D} [parameters.target=new Object3D()] - The 3D object the reflector is linked to.
	 * @param {Number} [parameters.resolution=1] - The resolution scale.
	 * @param {Boolean} [parameters.generateMipmaps=false] - Whether mipmaps should be generated or not.
	 * @param {Boolean} [parameters.bounces=true] - Whether reflectors can render other reflector nodes or not.
	 * @param {Boolean} [parameters.depth=false] - Whether depth data should be generated or not.
	 * @param {TextureNode} [parameters.defaultTexture] - The default texture node.
	 * @param {ReflectorBaseNode} [parameters.reflector] - The reflector base node.
	 */
	constructor( parameters = {} ) {

		super( parameters.defaultTexture || _defaultRT.texture, _defaultUV );

		/**
		 * A reference to the internal reflector base node which holds the actual implementation.
		 *
		 * @private
		 * @type {ReflectorBaseNode?}
		 * @default null
		 */
		this._reflectorBaseNode = parameters.reflector || new ReflectorBaseNode( this, parameters );

		/**
		 * A reference to the internal depth node.
		 *
		 * @private
		 * @type {Node?}
		 * @default null
		 */
		this._depthNode = null;

		this.setUpdateMatrix( false );

	}

	/**
	 * A reference to the internal reflector node.
	 *
	 * @type {ReflectorBaseNode}
	 */
	get reflector() {

		return this._reflectorBaseNode;

	}

	/**
	 * A reference to 3D object the reflector is linked to.
	 *
	 * @type {Object3D}
	 */
	get target() {

		return this._reflectorBaseNode.target;

	}

	/**
	 * Returns a node representing the mirror's depth. That can be used
	 * to implement more advanced reflection effects like distance attenuation.
	 *
	 * @return {Node} The depth node.
	 */
	getDepthNode() {

		if ( this._depthNode === null ) {

			if ( this._reflectorBaseNode.depth !== true ) {

				throw new Error( 'THREE.ReflectorNode: Depth node can only be requested when the reflector is created with { depth: true }. ' );

			}

			this._depthNode = nodeObject( new ReflectorNode( {
				defaultTexture: _defaultRT.depthTexture,
				reflector: this._reflectorBaseNode
			} ) );

		}

		return this._depthNode;

	}

	setup( builder ) {

		// ignore if used in post-processing
		if ( ! builder.object.isQuadMesh ) this._reflectorBaseNode.build( builder );

		return super.setup( builder );

	}

	clone() {

		const texture = new this.constructor( this.reflectorNode );
		texture._reflectorBaseNode = this._reflectorBaseNode;

		return texture;

	}

}

/**
 * Holds the actual implementation of the reflector.
 *
 * TODO: Explain why `ReflectorBaseNode`. Originally the entire logic was implemented
 * in `ReflectorNode`, see #29619.
 *
 * @private
 * @augments Node
 */
class ReflectorBaseNode extends Node {

	static get type() {

		return 'ReflectorBaseNode';

	}

	/**
	 * Constructs a new reflector base node.
	 *
	 * @param {TextureNode} textureNode - Represents the rendered reflections as a texture node.
	 * @param {Object} [parameters={}] - An object holding configuration parameters.
	 * @param {Object3D} [parameters.target=new Object3D()] - The 3D object the reflector is linked to.
	 * @param {Number} [parameters.resolution=1] - The resolution scale.
	 * @param {Boolean} [parameters.generateMipmaps=false] - Whether mipmaps should be generated or not.
	 * @param {Boolean} [parameters.bounces=true] - Whether reflectors can render other reflector nodes or not.
	 * @param {Boolean} [parameters.depth=false] - Whether depth data should be generated or not.
	 */
	constructor( textureNode, parameters = {} ) {

		super();

		const {
			target = new Object3D(),
			resolution = 1,
			generateMipmaps = false,
			bounces = true,
			depth = false
		} = parameters;

		/**
		 * Represents the rendered reflections as a texture node.
		 *
		 * @type {TextureNode}
		 */
		this.textureNode = textureNode;

		/**
		 * The 3D object the reflector is linked to.
		 *
		 * @type {Object3D}
		 * @default {new Object3D()}
		 */
		this.target = target;

		/**
		 * The resolution scale.
		 *
		 * @type {Number}
		 * @default {1}
		 */
		this.resolution = resolution;

		/**
		 * Whether mipmaps should be generated or not.
		 *
		 * @type {Boolean}
		 * @default {false}
		 */
		this.generateMipmaps = generateMipmaps;

		/**
		 * Whether reflectors can render other reflector nodes or not.
		 *
		 * @type {Boolean}
		 * @default {true}
		 */
		this.bounces = bounces;

		/**
		 * Whether depth data should be generated or not.
		 *
		 * @type {Boolean}
		 * @default {false}
		 */
		this.depth = depth;

		/**
		 * The `updateBeforeType` is set to `NodeUpdateType.RENDER` when {@link ReflectorBaseNode#bounces}
		 * is `true`. Otherwise it's `NodeUpdateType.FRAME`.
		 *
		 * @type {String}
		 * @default 'render'
		 */
		this.updateBeforeType = bounces ? NodeUpdateType.RENDER : NodeUpdateType.FRAME;

		/**
		 * Weak map for managing virtual cameras.
		 *
		 * @type {WeakMap<Camera, Camera>}
		 */
		this.virtualCameras = new WeakMap();

		/**
		 * Weak map for managing render targets.
		 *
		 * @type {WeakMap<Camera, RenderTarget>}
		 */
		this.renderTargets = new WeakMap();

	}

	/**
	 * Updates the resolution of the internal render target.
	 *
	 * @private
	 * @param {RenderTarget} renderTarget - The render target to resize.
	 * @param {Renderer} renderer - The renderer that is used to determine the new size.
	 */
	_updateResolution( renderTarget, renderer ) {

		const resolution = this.resolution;

		renderer.getDrawingBufferSize( _size$2 );

		renderTarget.setSize( Math.round( _size$2.width * resolution ), Math.round( _size$2.height * resolution ) );

	}

	setup( builder ) {

		this._updateResolution( _defaultRT, builder.renderer );

		return super.setup( builder );

	}

	/**
	 * Returns a virtual camera for the given camera. The virtual camera is used to
	 * render the scene from the reflector's view so correct reflections can be produced.
	 *
	 * @param {Camera} camera - The scene's camera.
	 * @return {Camera} The corresponding virtual camera.
	 */
	getVirtualCamera( camera ) {

		let virtualCamera = this.virtualCameras.get( camera );

		if ( virtualCamera === undefined ) {

			virtualCamera = camera.clone();

			this.virtualCameras.set( camera, virtualCamera );

		}

		return virtualCamera;

	}

	/**
	 * Returns a render target for the given camera. The reflections are rendered
	 * into this render target.
	 *
	 * @param {Camera} camera - The scene's camera.
	 * @return {RenderTarget} The render target.
	 */
	getRenderTarget( camera ) {

		let renderTarget = this.renderTargets.get( camera );

		if ( renderTarget === undefined ) {

			renderTarget = new RenderTarget( 0, 0, { type: HalfFloatType } );

			if ( this.generateMipmaps === true ) {

				renderTarget.texture.minFilter = LinearMipMapLinearFilter;
				renderTarget.texture.generateMipmaps = true;

			}

			if ( this.depth === true ) {

				renderTarget.depthTexture = new DepthTexture();

			}

			this.renderTargets.set( camera, renderTarget );

		}

		return renderTarget;

	}

	updateBefore( frame ) {

		if ( this.bounces === false && _inReflector ) return;

		_inReflector = true;

		const { scene, camera, renderer, material } = frame;
		const { target } = this;

		const virtualCamera = this.getVirtualCamera( camera );
		const renderTarget = this.getRenderTarget( virtualCamera );

		renderer.getDrawingBufferSize( _size$2 );

		this._updateResolution( renderTarget, renderer );

		//

		_reflectorWorldPosition.setFromMatrixPosition( target.matrixWorld );
		_cameraWorldPosition.setFromMatrixPosition( camera.matrixWorld );

		_rotationMatrix.extractRotation( target.matrixWorld );

		_normal.set( 0, 0, 1 );
		_normal.applyMatrix4( _rotationMatrix );

		_view.subVectors( _reflectorWorldPosition, _cameraWorldPosition );

		// Avoid rendering when reflector is facing away

		if ( _view.dot( _normal ) > 0 ) return;

		_view.reflect( _normal ).negate();
		_view.add( _reflectorWorldPosition );

		_rotationMatrix.extractRotation( camera.matrixWorld );

		_lookAtPosition.set( 0, 0, - 1 );
		_lookAtPosition.applyMatrix4( _rotationMatrix );
		_lookAtPosition.add( _cameraWorldPosition );

		_target.subVectors( _reflectorWorldPosition, _lookAtPosition );
		_target.reflect( _normal ).negate();
		_target.add( _reflectorWorldPosition );

		//

		virtualCamera.coordinateSystem = camera.coordinateSystem;
		virtualCamera.position.copy( _view );
		virtualCamera.up.set( 0, 1, 0 );
		virtualCamera.up.applyMatrix4( _rotationMatrix );
		virtualCamera.up.reflect( _normal );
		virtualCamera.lookAt( _target );

		virtualCamera.near = camera.near;
		virtualCamera.far = camera.far;

		virtualCamera.updateMatrixWorld();
		virtualCamera.projectionMatrix.copy( camera.projectionMatrix );

		// Now update projection matrix with new clip plane, implementing code from: http://www.terathon.com/code/oblique.html
		// Paper explaining this technique: http://www.terathon.com/lengyel/Lengyel-Oblique.pdf
		_reflectorPlane.setFromNormalAndCoplanarPoint( _normal, _reflectorWorldPosition );
		_reflectorPlane.applyMatrix4( virtualCamera.matrixWorldInverse );

		clipPlane.set( _reflectorPlane.normal.x, _reflectorPlane.normal.y, _reflectorPlane.normal.z, _reflectorPlane.constant );

		const projectionMatrix = virtualCamera.projectionMatrix;

		_q.x = ( Math.sign( clipPlane.x ) + projectionMatrix.elements[ 8 ] ) / projectionMatrix.elements[ 0 ];
		_q.y = ( Math.sign( clipPlane.y ) + projectionMatrix.elements[ 9 ] ) / projectionMatrix.elements[ 5 ];
		_q.z = - 1.0;
		_q.w = ( 1.0 + projectionMatrix.elements[ 10 ] ) / projectionMatrix.elements[ 14 ];

		// Calculate the scaled plane vector
		clipPlane.multiplyScalar( 1.0 / clipPlane.dot( _q ) );

		const clipBias = 0;

		// Replacing the third row of the projection matrix
		projectionMatrix.elements[ 2 ] = clipPlane.x;
		projectionMatrix.elements[ 6 ] = clipPlane.y;
		projectionMatrix.elements[ 10 ] = ( renderer.coordinateSystem === WebGPUCoordinateSystem ) ? ( clipPlane.z - clipBias ) : ( clipPlane.z + 1.0 - clipBias );
		projectionMatrix.elements[ 14 ] = clipPlane.w;

		//

		this.textureNode.value = renderTarget.texture;

		if ( this.depth === true ) {

			this.textureNode.getDepthNode().value = renderTarget.depthTexture;

		}

		material.visible = false;

		const currentRenderTarget = renderer.getRenderTarget();
		const currentMRT = renderer.getMRT();

		renderer.setMRT( null );
		renderer.setRenderTarget( renderTarget );

		renderer.render( scene, virtualCamera );

		renderer.setMRT( currentMRT );
		renderer.setRenderTarget( currentRenderTarget );

		material.visible = true;

		_inReflector = false;

	}

}

/**
 * TSL function for creating a reflector node.
 *
 * @function
 * @param {Object} [parameters={}] - An object holding configuration parameters.
 * @param {Object3D} [parameters.target=new Object3D()] - The 3D object the reflector is linked to.
 * @param {Number} [parameters.resolution=1] - The resolution scale.
 * @param {Boolean} [parameters.generateMipmaps=false] - Whether mipmaps should be generated or not.
 * @param {Boolean} [parameters.bounces=true] - Whether reflectors can render other reflector nodes or not.
 * @param {Boolean} [parameters.depth=false] - Whether depth data should be generated or not.
 * @param {TextureNode} [parameters.defaultTexture] - The default texture node.
 * @param {ReflectorBaseNode} [parameters.reflector] - The reflector base node.
 * @returns {ReflectorNode}
 */
const reflector = ( parameters ) => nodeObject( new ReflectorNode( parameters ) );

// Helper for passes that need to fill the viewport with a single quad.

const _camera = /*@__PURE__*/ new OrthographicCamera( - 1, 1, 1, - 1, 0, 1 );

// https://github.com/mrdoob/three.js/pull/21358

class QuadGeometry extends BufferGeometry {

	constructor( flipY = false ) {

		super();

		const uv = flipY === false ? [ 0, - 1, 0, 1, 2, 1 ] : [ 0, 2, 0, 0, 2, 0 ];

		this.setAttribute( 'position', new Float32BufferAttribute( [ - 1, 3, 0, - 1, - 1, 0, 3, - 1, 0 ], 3 ) );
		this.setAttribute( 'uv', new Float32BufferAttribute( uv, 2 ) );

	}

}

const _geometry = /*@__PURE__*/ new QuadGeometry();

class QuadMesh extends Mesh {

	constructor( material = null ) {

		super( _geometry, material );

		this.camera = _camera;

		this.isQuadMesh = true;

	}

	renderAsync( renderer ) {

		return renderer.renderAsync( this, _camera );

	}

	render( renderer ) {

		renderer.render( this, _camera );

	}

}

/** @module RTTNode **/

const _size$1 = /*@__PURE__*/ new Vector2();

/**
 * `RTTNode` takes another node and uses it with a `QuadMesh` to render into a texture (RTT).
 * This module is especially relevant in context of post processing where certain nodes require
 * texture input for their effects. With the helper function `convertToTexture()` which is based
 * on this module, the node system can automatically ensure texture input if required.
 *
 * @augments module:TextureNode~TextureNode
 */
class RTTNode extends TextureNode {

	static get type() {

		return 'RTTNode';

	}

	/**
	 * Constructs a new RTT node.
	 *
	 * @param {Node} node - The node to render a texture with.
	 * @param {Number?} [width=null] - The width of the internal render target. If not width is applied, the render target is automatically resized.
	 * @param {Number?} [height=null] - The height of the internal render target.
	 * @param {Object} [options={type:HalfFloatType}] - The options for the internal render target.
	 */
	constructor( node, width = null, height = null, options = { type: HalfFloatType } ) {

		const renderTarget = new RenderTarget( width, height, options );

		super( renderTarget.texture, uv() );

		/**
		 * The node to render a texture with.
		 *
		 * @type {Node}
		 */
		this.node = node;

		/**
		 * The width of the internal render target.
		 * If not width is applied, the render target is automatically resized.
		 *
		 * @type {Number?}
		 * @default null
		 */
		this.width = width;

		/**
		 * The height of the internal render target.
		 *
		 * @type {Number?}
		 * @default null
		 */
		this.height = height;

		/**
		 * The pixel ratio
		 *
		 * @type {Number}
		 * @default 1
		 */
		this.pixelRatio = 1;

		/**
		 * The render target
		 *
		 * @type {RenderTarget}
		 */
		this.renderTarget = renderTarget;

		/**
		 * Whether the texture requires an update or not.
		 *
		 * @type {Boolean}
		 * @default true
		 */
		this.textureNeedsUpdate = true;

		/**
		 * Whether the texture should automatically be updated or not.
		 *
		 * @type {Boolean}
		 * @default true
		 */
		this.autoUpdate = true;

		/**
		 * The node which is used with the quad mesh for RTT.
		 *
		 * @private
		 * @type {Node}
		 * @default null
		 */
		this._rttNode = null;

		/**
		 * The internal quad mesh for RTT.
		 *
		 * @private
		 * @type {QuadMesh}
		 */
		this._quadMesh = new QuadMesh( new NodeMaterial() );

		/**
		 * The `updateBeforeType` is set to `NodeUpdateType.RENDER` since the node updates
		 * the texture once per render in its {@link RTTNode#updateBefore} method.
		 *
		 * @type {String}
		 * @default 'render'
		 */
		this.updateBeforeType = NodeUpdateType.RENDER;

	}

	/**
	 * Whether the internal render target should automatically be resized or not.
	 *
	 * @type {Boolean}
	 * @readonly
	 * @default true
	 */
	get autoSize() {

		return this.width === null;

	}

	setup( builder ) {

		this._rttNode = this.node.context( builder.getSharedContext() );
		this._quadMesh.material.name = 'RTT';
		this._quadMesh.material.needsUpdate = true;

		return super.setup( builder );

	}

	/**
	 * Sets the size of the internal render target
	 *
	 * @param {Number} width - The width to set.
	 * @param {Number} height - The width to set.
	 */
	setSize( width, height ) {

		this.width = width;
		this.height = height;

		const effectiveWidth = width * this.pixelRatio;
		const effectiveHeight = height * this.pixelRatio;

		this.renderTarget.setSize( effectiveWidth, effectiveHeight );

		this.textureNeedsUpdate = true;

	}

	/**
	 * Sets the pixel ratio. This will also resize the render target.
	 *
	 * @param {Number} pixelRatio - The pixel ratio to set.
	 */
	setPixelRatio( pixelRatio ) {

		this.pixelRatio = pixelRatio;

		this.setSize( this.width, this.height );

	}

	updateBefore( { renderer } ) {

		if ( this.textureNeedsUpdate === false && this.autoUpdate === false ) return;

		this.textureNeedsUpdate = false;

		//

		if ( this.autoSize === true ) {

			this.pixelRatio = renderer.getPixelRatio();

			const size = renderer.getSize( _size$1 );

			this.setSize( size.width, size.height );

		}

		//

		this._quadMesh.material.fragmentNode = this._rttNode;

		//

		const currentRenderTarget = renderer.getRenderTarget();

		renderer.setRenderTarget( this.renderTarget );

		this._quadMesh.render( renderer );

		renderer.setRenderTarget( currentRenderTarget );

	}

	clone() {

		const newNode = new TextureNode( this.value, this.uvNode, this.levelNode );
		newNode.sampler = this.sampler;
		newNode.referenceNode = this;

		return newNode;

	}

}

/**
 * TSL function for creating a RTT node.
 *
 * @function
 * @param {Node} node - The node to render a texture with.
 * @param {Number?} [width=null] - The width of the internal render target. If not width is applied, the render target is automatically resized.
 * @param {Number?} [height=null] - The height of the internal render target.
 * @param {Object} [options={type:HalfFloatType}] - The options for the internal render target.
 * @returns {RTTNode}
 */
const rtt = ( node, ...params ) => nodeObject( new RTTNode( nodeObject( node ), ...params ) );

/**
 * TSL function for converting nodes to textures nodes.
 *
 * @function
 * @param {Node} node - The node to render a texture with.
 * @param {Number?} [width=null] - The width of the internal render target. If not width is applied, the render target is automatically resized.
 * @param {Number?} [height=null] - The height of the internal render target.
 * @param {Object} [options={type:HalfFloatType}] - The options for the internal render target.
 * @returns {RTTNode}
 */
const convertToTexture = ( node, ...params ) => {

	if ( node.isTextureNode ) return node;
	if ( node.isPassNode ) return node.getTextureNode();

	return rtt( node, ...params );

};

/** @module PostProcessingUtils **/

/**
 * Computes a position in view space based on a fragment's screen position expressed as uv coordinates, the fragments
 * depth value and the camera's inverse projection matrix.
 *
 * @method
 * @param {Node<vec2>} screenPosition - The fragment's screen position expressed as uv coordinates.
 * @param {Node<float>} depth - The fragment's depth value.
 * @param {Node<mat4>} projectionMatrixInverse - The camera's inverse projection matrix.
 * @return {Node<vec3>} The fragments position in view space.
 */
const getViewPosition = /*@__PURE__*/ Fn( ( [ screenPosition, depth, projectionMatrixInverse ], builder ) => {

	let clipSpacePosition;

	if ( builder.renderer.coordinateSystem === WebGPUCoordinateSystem ) {

		screenPosition = vec2( screenPosition.x, screenPosition.y.oneMinus() ).mul( 2.0 ).sub( 1.0 );
		clipSpacePosition = vec4( vec3( screenPosition, depth ), 1.0 );

	} else {

		clipSpacePosition = vec4( vec3( screenPosition.x, screenPosition.y.oneMinus(), depth ).mul( 2.0 ).sub( 1.0 ), 1.0 );

	}

	const viewSpacePosition = vec4( projectionMatrixInverse.mul( clipSpacePosition ) );

	return viewSpacePosition.xyz.div( viewSpacePosition.w );

} );

/**
 * Computes a screen position expressed as uv coordinates based on a fragment's position in view space
 * and the camera's projection matrix
 *
 * @method
 * @param {Node<vec3>} viewPosition - The fragments position in view space.
 * @param {Node<mat4>} projectionMatrix - The camera's projection matrix.
 * @return {Node<vec2>} The fragment's screen position expressed as uv coordinates.
 */
const getScreenPosition = /*@__PURE__*/ Fn( ( [ viewPosition, projectionMatrix ] ) => {

	const sampleClipPos = projectionMatrix.mul( vec4( viewPosition, 1.0 ) );
	const sampleUv = sampleClipPos.xy.div( sampleClipPos.w ).mul( 0.5 ).add( 0.5 ).toVar();
	return vec2( sampleUv.x, sampleUv.y.oneMinus() );

} );

/**
 * Computes a normal vector based on depth data. Can be used as a fallback when no normal render
 * target is available or if flat surface normals are required.
 *
 * @method
 * @param {Node<vec2>} uv - The texture coordinate.
 * @param {DepthTexture} depthTexture - The depth texture.
 * @param {Node<mat4>} projectionMatrixInverse - The camera's inverse projection matrix.
 * @return {Node<vec3>} The computed normal vector.
 */
const getNormalFromDepth = /*@__PURE__*/ Fn( ( [ uv, depthTexture, projectionMatrixInverse ] ) => {

	const size = textureSize( textureLoad( depthTexture ) );
	const p = ivec2( uv.mul( size ) ).toVar();

	const c0 = textureLoad( depthTexture, p ).toVar();

	const l2 = textureLoad( depthTexture, p.sub( ivec2( 2, 0 ) ) ).toVar();
	const l1 = textureLoad( depthTexture, p.sub( ivec2( 1, 0 ) ) ).toVar();
	const r1 = textureLoad( depthTexture, p.add( ivec2( 1, 0 ) ) ).toVar();
	const r2 = textureLoad( depthTexture, p.add( ivec2( 2, 0 ) ) ).toVar();
	const b2 = textureLoad( depthTexture, p.add( ivec2( 0, 2 ) ) ).toVar();
	const b1 = textureLoad( depthTexture, p.add( ivec2( 0, 1 ) ) ).toVar();
	const t1 = textureLoad( depthTexture, p.sub( ivec2( 0, 1 ) ) ).toVar();
	const t2 = textureLoad( depthTexture, p.sub( ivec2( 0, 2 ) ) ).toVar();

	const dl = abs( sub( float( 2 ).mul( l1 ).sub( l2 ), c0 ) ).toVar();
	const dr = abs( sub( float( 2 ).mul( r1 ).sub( r2 ), c0 ) ).toVar();
	const db = abs( sub( float( 2 ).mul( b1 ).sub( b2 ), c0 ) ).toVar();
	const dt = abs( sub( float( 2 ).mul( t1 ).sub( t2 ), c0 ) ).toVar();

	const ce = getViewPosition( uv, c0, projectionMatrixInverse ).toVar();

	const dpdx = dl.lessThan( dr ).select( ce.sub( getViewPosition( uv.sub( vec2( float( 1 ).div( size.x ), 0 ) ), l1, projectionMatrixInverse ) ), ce.negate().add( getViewPosition( uv.add( vec2( float( 1 ).div( size.x ), 0 ) ), r1, projectionMatrixInverse ) ) );
	const dpdy = db.lessThan( dt ).select( ce.sub( getViewPosition( uv.add( vec2( 0, float( 1 ).div( size.y ) ) ), b1, projectionMatrixInverse ) ), ce.negate().add( getViewPosition( uv.sub( vec2( 0, float( 1 ).div( size.y ) ) ), t1, projectionMatrixInverse ) ) );

	return normalize( cross( dpdx, dpdy ) );

} );

class StorageInstancedBufferAttribute extends InstancedBufferAttribute {

	constructor( array, itemSize, typeClass = Float32Array ) {

		if ( ArrayBuffer.isView( array ) === false ) array = new typeClass( array * itemSize );

		super( array, itemSize );

		this.isStorageInstancedBufferAttribute = true;

	}

}

class StorageBufferAttribute extends BufferAttribute {

	constructor( array, itemSize, typeClass = Float32Array ) {

		if ( ArrayBuffer.isView( array ) === false ) array = new typeClass( array * itemSize );

		super( array, itemSize );

		this.isStorageBufferAttribute = true;

	}

}

/** @module StorageArrayElementNode **/

/**
 * This class enables element access on instances of {@link StorageBufferNode}.
 * In most cases, it is indirectly used when accessing elements with the
 * {@link StorageBufferNode#element} method.
 *
 * ```js
 * const position = positionStorage.element( instanceIndex );
 * ```
 *
 * @augments ArrayElementNode
 */
class StorageArrayElementNode extends ArrayElementNode {

	static get type() {

		return 'StorageArrayElementNode';

	}

	/**
	 * Constructs storage buffer element node.
	 *
	 * @param {StorageBufferNode} storageBufferNode - The storage buffer node.
	 * @param {Node} indexNode - The index node that defines the element access.
	 */
	constructor( storageBufferNode, indexNode ) {

		super( storageBufferNode, indexNode );

		/**
		 * This flag can be used for type testing.
		 *
		 * @type {Boolean}
		 * @readonly
		 * @default true
		 */
		this.isStorageArrayElementNode = true;

	}

	/**
	 * The storage buffer node.
	 *
	 * @param {Node} value
	 * @type {StorageBufferNode}
	 */
	set storageBufferNode( value ) {

		this.node = value;

	}

	get storageBufferNode() {

		return this.node;

	}

	setup( builder ) {

		if ( builder.isAvailable( 'storageBuffer' ) === false ) {

			if ( this.node.isPBO === true ) {

				builder.setupPBO( this.node );

			}

		}

		return super.setup( builder );

	}

	generate( builder, output ) {

		let snippet;

		const isAssignContext = builder.context.assign;

		//

		if ( builder.isAvailable( 'storageBuffer' ) === false ) {

			if ( this.node.isPBO === true && isAssignContext !== true && ( this.node.value.isInstancedBufferAttribute || builder.shaderStage !== 'compute' ) ) {

				snippet = builder.generatePBO( this );

			} else {

				snippet = this.node.build( builder );

			}

		} else {

			snippet = super.generate( builder );

		}

		if ( isAssignContext !== true ) {

			const type = this.getNodeType( builder );

			snippet = builder.format( snippet, type, output );

		}

		return snippet;

	}

}

/**
 * TSL function for creating a storage element node.
 *
 * @function
 * @param {StorageBufferNode} storageBufferNode - The storage buffer node.
 * @param {Node} indexNode - The index node that defines the element access.
 * @returns {StorageArrayElementNode}
 */
const storageElement = /*@__PURE__*/ nodeProxy( StorageArrayElementNode );

class StorageBufferNode extends BufferNode {

	static get type() {

		return 'StorageBufferNode';

	}

	constructor( value, bufferType = null, bufferCount = 0 ) {

		if ( bufferType === null && ( value.isStorageBufferAttribute || value.isStorageInstancedBufferAttribute ) ) {

			bufferType = getTypeFromLength( value.itemSize );
			bufferCount = value.count;

		}

		super( value, bufferType, bufferCount );

		this.isStorageBufferNode = true;

		this.access = NodeAccess.READ_WRITE;
		this.isAtomic = false;
		this.isPBO = false;

		this.bufferCount = bufferCount;

		this._attribute = null;
		this._varying = null;

		this.global = true;

		if ( value.isStorageBufferAttribute !== true && value.isStorageInstancedBufferAttribute !== true ) {

			// TODO: Improve it, possibly adding a new property to the BufferAttribute to identify it as a storage buffer read-only attribute in Renderer

			if ( value.isInstancedBufferAttribute ) value.isStorageInstancedBufferAttribute = true;
			else value.isStorageBufferAttribute = true;

		}

	}

	getHash( builder ) {

		if ( this.bufferCount === 0 ) {

			let bufferData = builder.globalCache.getData( this.value );

			if ( bufferData === undefined ) {

				bufferData = {
					node: this
				};

				builder.globalCache.setData( this.value, bufferData );

			}

			return bufferData.node.uuid;

		}

		return this.uuid;

	}

	getInputType( /*builder*/ ) {

		return this.value.isIndirectStorageBufferAttribute ? 'indirectStorageBuffer' : 'storageBuffer';

	}

	element( indexNode ) {

		return storageElement( this, indexNode );

	}

	setPBO( value ) {

		this.isPBO = value;

		return this;

	}

	getPBO() {

		return this.isPBO;

	}

	setAccess( value ) {

		this.access = value;

		return this;

	}

	toReadOnly() {

		return this.setAccess( NodeAccess.READ_ONLY );

	}

	setAtomic( value ) {

		this.isAtomic = value;

		return this;

	}

	toAtomic() {

		return this.setAtomic( true );

	}

	getAttributeData() {

		if ( this._attribute === null ) {

			this._attribute = bufferAttribute( this.value );
			this._varying = varying( this._attribute );

		}

		return {
			attribute: this._attribute,
			varying: this._varying
		};

	}

	getNodeType( builder ) {

		if ( builder.isAvailable( 'storageBuffer' ) || builder.isAvailable( 'indirectStorageBuffer' ) ) {

			return super.getNodeType( builder );

		}

		const { attribute } = this.getAttributeData();

		return attribute.getNodeType( builder );

	}

	generate( builder ) {

		if ( builder.isAvailable( 'storageBuffer' ) || builder.isAvailable( 'indirectStorageBuffer' ) ) {

			return super.generate( builder );

		}

		const { attribute, varying } = this.getAttributeData();

		const output = varying.build( builder );

		builder.registerTransform( output, attribute );

		return output;

	}

}

const storage = ( value, type, count ) => nodeObject( new StorageBufferNode( value, type, count ) );

const storageObject = ( value, type, count ) => { // @deprecated, r171

	console.warn( 'THREE.TSL: "storageObject()" is deprecated. Use "storage().setPBO( true )" instead.' );

	return storage( value, type, count ).setPBO( true );

};

const attributeArray = ( count, type = 'float' ) => {

	const itemSize = getLengthFromType( type );

	const buffer = new StorageBufferAttribute( count, itemSize );
	const node = storage( buffer, type, count );

	return node;

};


const instancedArray = ( count, type = 'float' ) => {

	const itemSize = getLengthFromType( type );

	const buffer = new StorageInstancedBufferAttribute( count, itemSize );
	const node = storage( buffer, type, count );

	return node;

};

/** @module VertexColorNode **/

/**
 * An attribute node for representing vertex colors.
 *
 * @augments module:AttributeNode~AttributeNode
 */
class VertexColorNode extends AttributeNode {

	static get type() {

		return 'VertexColorNode';

	}

	/**
	 * Constructs a new vertex color node.
	 *
	 * @param {Number} [index=0] - The attribute index.
	 */
	constructor( index = 0 ) {

		super( null, 'vec4' );

		/**
		 * This flag can be used for type testing.
		 *
		 * @type {Boolean}
		 * @readonly
		 * @default true
		 */
		this.isVertexColorNode = true;

		/**
		 * The attribute index to enable more than one sets of vertex colors.
		 *
		 * @type {Number}
		 * @default 0
		 */
		this.index = index;

	}

	/**
	 * Overwrites the default implementation by honoring the attribute index.
	 *
	 * @param {NodeBuilder} builder - The current node builder.
	 * @return {String} The attribute name.
	 */
	getAttributeName( /*builder*/ ) {

		const index = this.index;

		return 'color' + ( index > 0 ? index : '' );

	}

	generate( builder ) {

		const attributeName = this.getAttributeName( builder );
		const geometryAttribute = builder.hasGeometryAttribute( attributeName );

		let result;

		if ( geometryAttribute === true ) {

			result = super.generate( builder );

		} else {

			// Vertex color fallback should be white
			result = builder.generateConst( this.nodeType, new Vector4( 1, 1, 1, 1 ) );

		}

		return result;

	}

	serialize( data ) {

		super.serialize( data );

		data.index = this.index;

	}

	deserialize( data ) {

		super.deserialize( data );

		this.index = data.index;

	}

}

/**
 * TSL function for creating a reference node.
 *
 * @function
 * @param {Number} index - The attribute index.
 * @returns {VertexColorNode}
 */
const vertexColor = ( index ) => nodeObject( new VertexColorNode( index ) );

/** @module PointUVNode **/

/**
 * A node for representing the uv coordinates of points.
 *
 * Can only be used with a WebGL backend. In WebGPU, point
 * primitives always have the size of one pixel and can thus
 * can't be used as sprite-like objects that display textures.
 *
 * @augments Node
 */
class PointUVNode extends Node {

	static get type() {

		return 'PointUVNode';

	}

	/**
	 * Constructs a new point uv node.
	 */
	constructor() {

		super( 'vec2' );

		/**
		 * This flag can be used for type testing.
		 *
		 * @type {Boolean}
		 * @readonly
		 * @default true
		 */
		this.isPointUVNode = true;

	}

	generate( /*builder*/ ) {

		return 'vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y )';

	}

}

/**
 * TSL object that represents the uv coordinates of points.
 *
 * @type {PointUVNode}
 */
const pointUV = /*@__PURE__*/ nodeImmutable( PointUVNode );

const _e1 = /*@__PURE__*/ new Euler();
const _m1 = /*@__PURE__*/ new Matrix4();

/** @module SceneNode **/

/**
 * This module allows access to a collection of scene properties. The following predefined TSL objects
 * are available for easier use:
 *
 * - `backgroundBlurriness`: A node that represents the scene's background blurriness.
 * - `backgroundIntensity`: A node that represents the scene's background intensity.
 * - `backgroundRotation`: A node that represents the scene's background rotation.
 *
 * @augments Node
 */
class SceneNode extends Node {

	static get type() {

		return 'SceneNode';

	}

	/**
	 * Constructs a new scene node.
	 *
	 * @param {('backgroundBlurriness'|'backgroundIntensity'|'backgroundRotation')} scope - The scope defines the type of scene property that is accessed.
	 * @param {Scene?} [scene=null] - A reference to the scene.
	 */
	constructor( scope = SceneNode.BACKGROUND_BLURRINESS, scene = null ) {

		super();

		/**
		 * The scope defines the type of scene property that is accessed.
		 *
		 * @type {('backgroundBlurriness'|'backgroundIntensity'|'backgroundRotation')}
		 */
		this.scope = scope;

		/**
		 * A reference to the scene that is going to be accessed.
		 *
		 * @type {Scene?}
		 * @default null
		 */
		this.scene = scene;

	}

	/**
	 * Depending on the scope, the method returns a different type of node that represents
	 * the respective scene property.
	 *
	 * @param {NodeBuilder} builder - The current node builder.
	 * @return {Node} The output node.
	 */
	setup( builder ) {

		const scope = this.scope;
		const scene = this.scene !== null ? this.scene : builder.scene;

		let output;

		if ( scope === SceneNode.BACKGROUND_BLURRINESS ) {

			output = reference( 'backgroundBlurriness', 'float', scene );

		} else if ( scope === SceneNode.BACKGROUND_INTENSITY ) {

			output = reference( 'backgroundIntensity', 'float', scene );

		} else if ( scope === SceneNode.BACKGROUND_ROTATION ) {

			output = uniform( 'mat4' ).label( 'backgroundRotation' ).setGroup( renderGroup ).onRenderUpdate( () => {

				const background = scene.background;

				if ( background !== null && background.isTexture && background.mapping !== UVMapping ) {

					_e1.copy( scene.backgroundRotation );

					// accommodate left-handed frame
					_e1.x *= - 1; _e1.y *= - 1; _e1.z *= - 1;

					_m1.makeRotationFromEuler( _e1 );

				} else {

					_m1.identity();

				}

				return _m1;

			} );

		} else {

			console.error( 'THREE.SceneNode: Unknown scope:', scope );

		}

		return output;

	}

}

SceneNode.BACKGROUND_BLURRINESS = 'backgroundBlurriness';
SceneNode.BACKGROUND_INTENSITY = 'backgroundIntensity';
SceneNode.BACKGROUND_ROTATION = 'backgroundRotation';

/**
 * TSL object that represents the scene's background blurriness.
 *
 * @type {SceneNode}
 */
const backgroundBlurriness = /*@__PURE__*/ nodeImmutable( SceneNode, SceneNode.BACKGROUND_BLURRINESS );

/**
 * TSL object that represents the scene's background intensity.
 *
 * @type {SceneNode}
 */
const backgroundIntensity = /*@__PURE__*/ nodeImmutable( SceneNode, SceneNode.BACKGROUND_INTENSITY );

/**
 * TSL object that represents the scene's background rotation.
 *
 * @type {SceneNode}
 */
const backgroundRotation = /*@__PURE__*/ nodeImmutable( SceneNode, SceneNode.BACKGROUND_ROTATION );

class StorageTextureNode extends TextureNode {

	static get type() {

		return 'StorageTextureNode';

	}

	constructor( value, uvNode, storeNode = null ) {

		super( value, uvNode );

		this.storeNode = storeNode;

		this.isStorageTextureNode = true;

		this.access = NodeAccess.WRITE_ONLY;

	}

	getInputType( /*builder*/ ) {

		return 'storageTexture';

	}

	setup( builder ) {

		super.setup( builder );

		const properties = builder.getNodeProperties( this );
		properties.storeNode = this.storeNode;

	}

	setAccess( value ) {

		this.access = value;
		return this;

	}

	generate( builder, output ) {

		let snippet;

		if ( this.storeNode !== null ) {

			snippet = this.generateStore( builder );

		} else {

			snippet = super.generate( builder, output );

		}

		return snippet;

	}

	toReadWrite() {

		return this.setAccess( NodeAccess.READ_WRITE );

	}

	toReadOnly() {

		return this.setAccess( NodeAccess.READ_ONLY );

	}

	toWriteOnly() {

		return this.setAccess( NodeAccess.WRITE_ONLY );

	}

	generateStore( builder ) {

		const properties = builder.getNodeProperties( this );

		const { uvNode, storeNode } = properties;

		const textureProperty = super.generate( builder, 'property' );
		const uvSnippet = uvNode.build( builder, 'uvec2' );
		const storeSnippet = storeNode.build( builder, 'vec4' );

		const snippet = builder.generateTextureStore( builder, textureProperty, uvSnippet, storeSnippet );

		builder.addLineFlowCode( snippet, this );

	}

}

const storageTexture = /*@__PURE__*/ nodeProxy( StorageTextureNode );

const textureStore = ( value, uvNode, storeNode ) => {

	const node = storageTexture( value, uvNode, storeNode );

	if ( storeNode !== null ) node.append();

	return node;

};

/** @module UserDataNode **/

/**
 * A special type of reference node that allows to link values in
 * `userData` fields to node objects.
 * ```js
 * sprite.userData.rotation = 1; // stores individual rotation per sprite
 *
 * const material = new THREE.SpriteNodeMaterial();
 * material.rotationNode = userData( 'rotation', 'float' );
 * ```
 * Since `UserDataNode` is extended from {@link module:ReferenceNode~ReferenceNode}, the node value
 * will automatically be updated when the `rotation` user data field changes.
 *
 * @augments module:ReferenceNode~ReferenceNode
 */
class UserDataNode extends ReferenceNode {

	static get type() {

		return 'UserDataNode';

	}

	/**
	 * Constructs a new user data node.
	 *
	 * @param {String} property - The property name that should be referenced by the node.
	 * @param {String} inputType - The node data type of the reference.
	 * @param {Object?} [userData=null] - A reference to the `userData` object. If not provided, the `userData` property of the 3D object that uses the node material is evaluated.
	 */
	constructor( property, inputType, userData = null ) {

		super( property, inputType, userData );

		/**
		 * A reference to the `userData` object. If not provided, the `userData`
		 * property of the 3D object that uses the node material is evaluated.
		 *
		 * @type {Object?}
		 * @default null
		 */
		this.userData = userData;

	}

	/**
	 * Overwritten to make sure {@link module:ReferenceNode~ReferenceNode#reference} points to the correct
	 * `userData` field.
	 *
	 * @param {(NodeFrame|NodeBuilder)} state - The current state to evaluate.
	 * @return {Object} A reference to the `userData` field.
	 */
	updateReference( state ) {

		this.reference = this.userData !== null ? this.userData : state.object.userData;

		return this.reference;

	}

}

/**
 * TSL function for creating a user data node.
 *
 * @function
 * @param {String} name - The property name that should be referenced by the node.
 * @param {String} inputType - The node data type of the reference.
 * @param {Object?} userData - A reference to the `userData` object. If not provided, the `userData` property of the 3D object that uses the node material is evaluated.
 * @returns {UserDataNode}
 */
const userData = ( name, inputType, userData ) => nodeObject( new UserDataNode( name, inputType, userData ) );

const _objectData = new WeakMap();

/** @module VelocityNode **/

/**
 * A node for representing motion or velocity vectors. Foundation
 * for advanced post processing effects like motion blur or TRAA.
 *
 * The node keeps track of the model, view and projection matrices
 * of the previous frame and uses them to compute offsets in NDC space.
 * These offsets represent the final velocity.
 *
 * @augments TempNode
 */
class VelocityNode extends TempNode {

	static get type() {

		return 'VelocityNode';

	}

	/**
	 * Constructs a new vertex color node.
	 *
	 * @param {Number} [index=0] - The attribute index.
	 */
	constructor() {

		super( 'vec2' );

		/**
		 * The current projection matrix.
		 *
		 * @type {Matrix4?}
		 * @default null
		 */
		this.projectionMatrix = null;

		/**
		 * Overwritten since velocity nodes are updated per object.
		 *
		 * @type {String}
		 * @default 'object'
		 */
		this.updateType = NodeUpdateType.OBJECT;

		/**
		 * Overwritten since velocity nodes save data after the update.
		 *
		 * @type {String}
		 * @default 'object'
		 */
		this.updateAfterType = NodeUpdateType.OBJECT;

		/**
		 * Uniform node representing the previous model matrix in world space.
		 *
		 * @type {UniformNode<mat4>}
		 * @default null
		 */
		this.previousModelWorldMatrix = uniform( new Matrix4() );

		/**
		 * Uniform node representing the previous projection matrix.
		 *
		 * @type {UniformNode<mat4>}
		 * @default null
		 */
		this.previousProjectionMatrix = uniform( new Matrix4() ).setGroup( renderGroup );

		/**
		 * Uniform node representing the previous view matrix.
		 *
		 * @type {UniformNode<mat4>}
		 * @default null
		 */
		this.previousCameraViewMatrix = uniform( new Matrix4() );

	}

	/**
	 * Sets the given projection matrix.
	 *
	 * @param {Matrix4} projectionMatrix - The projection matrix to set.
	 */
	setProjectionMatrix( projectionMatrix ) {

		this.projectionMatrix = projectionMatrix;

	}

	/**
	 * Updates velocity specific uniforms.
	 *
	 * @param {NodeFrame} frame - A reference to the current node frame.
	 */
	update( { frameId, camera, object } ) {

		const previousModelMatrix = getPreviousMatrix( object );

		this.previousModelWorldMatrix.value.copy( previousModelMatrix );

		//

		const cameraData = getData( camera );

		if ( cameraData.frameId !== frameId ) {

			cameraData.frameId = frameId;

			if ( cameraData.previousProjectionMatrix === undefined ) {

				cameraData.previousProjectionMatrix = new Matrix4();
				cameraData.previousCameraViewMatrix = new Matrix4();

				cameraData.currentProjectionMatrix = new Matrix4();
				cameraData.currentCameraViewMatrix = new Matrix4();

				cameraData.previousProjectionMatrix.copy( this.projectionMatrix || camera.projectionMatrix );
				cameraData.previousCameraViewMatrix.copy( camera.matrixWorldInverse );

			} else {

				cameraData.previousProjectionMatrix.copy( cameraData.currentProjectionMatrix );
				cameraData.previousCameraViewMatrix.copy( cameraData.currentCameraViewMatrix );

			}

			cameraData.currentProjectionMatrix.copy( this.projectionMatrix || camera.projectionMatrix );
			cameraData.currentCameraViewMatrix.copy( camera.matrixWorldInverse );

			this.previousProjectionMatrix.value.copy( cameraData.previousProjectionMatrix );
			this.previousCameraViewMatrix.value.copy( cameraData.previousCameraViewMatrix );

		}

	}

	/**
	 * Overwritten to updated velocity specific uniforms.
	 *
	 * @param {NodeFrame} frame - A reference to the current node frame.
	 */
	updateAfter( { object } ) {

		getPreviousMatrix( object ).copy( object.matrixWorld );

	}

	/**
	 * Implements the velocity computation based on the previous and current vertex data.
	 *
	 * @param {NodeBuilder} builder - A reference to the current node builder.
	 * @return {Node<vec2>} The motion vector.
	 */
	setup( /*builder*/ ) {

		const projectionMatrix = ( this.projectionMatrix === null ) ? cameraProjectionMatrix : uniform( this.projectionMatrix );

		const previousModelViewMatrix = this.previousCameraViewMatrix.mul( this.previousModelWorldMatrix );

		const clipPositionCurrent = projectionMatrix.mul( modelViewMatrix ).mul( positionLocal );
		const clipPositionPrevious = this.previousProjectionMatrix.mul( previousModelViewMatrix ).mul( positionPrevious );

		const ndcPositionCurrent = clipPositionCurrent.xy.div( clipPositionCurrent.w );
		const ndcPositionPrevious = clipPositionPrevious.xy.div( clipPositionPrevious.w );

		const velocity = sub( ndcPositionCurrent, ndcPositionPrevious );

		return velocity;

	}

}

function getData( object ) {

	let objectData = _objectData.get( object );

	if ( objectData === undefined ) {

		objectData = {};
		_objectData.set( object, objectData );

	}

	return objectData;

}

function getPreviousMatrix( object, index = 0 ) {

	const objectData = getData( object );

	let matrix = objectData[ index ];

	if ( matrix === undefined ) {

		objectData[ index ] = matrix = new Matrix4();

	}

	return matrix;

}

/**
 * TSL object that represents the velocity of a render pass.
 *
 * @type {VelocityNode}
 */
const velocity = /*@__PURE__*/ nodeImmutable( VelocityNode );

const blendBurn = /*@__PURE__*/ Fn( ( [ base, blend ] ) => {

	return min$1( 1.0, base.oneMinus().div( blend ) ).oneMinus();

} ).setLayout( {
	name: 'blendBurn',
	type: 'vec3',
	inputs: [
		{ name: 'base', type: 'vec3' },
		{ name: 'blend', type: 'vec3' }
	]
} );

const blendDodge = /*@__PURE__*/ Fn( ( [ base, blend ] ) => {

	return min$1( base.div( blend.oneMinus() ), 1.0 );

} ).setLayout( {
	name: 'blendDodge',
	type: 'vec3',
	inputs: [
		{ name: 'base', type: 'vec3' },
		{ name: 'blend', type: 'vec3' }
	]
} );

const blendScreen = /*@__PURE__*/ Fn( ( [ base, blend ] ) => {

	return base.oneMinus().mul( blend.oneMinus() ).oneMinus();

} ).setLayout( {
	name: 'blendScreen',
	type: 'vec3',
	inputs: [
		{ name: 'base', type: 'vec3' },
		{ name: 'blend', type: 'vec3' }
	]
} );

const blendOverlay = /*@__PURE__*/ Fn( ( [ base, blend ] ) => {

	return mix( base.mul( 2.0 ).mul( blend ), base.oneMinus().mul( 2.0 ).mul( blend.oneMinus() ).oneMinus(), step( 0.5, base ) );

} ).setLayout( {
	name: 'blendOverlay',
	type: 'vec3',
	inputs: [
		{ name: 'base', type: 'vec3' },
		{ name: 'blend', type: 'vec3' }
	]
} );

const blendColor = /*@__PURE__*/ Fn( ( [ base, blend ] ) => {

	const outAlpha = blend.a.add( base.a.mul( blend.a.oneMinus() ) );

	return vec4( blend.rgb.mul( blend.a ).add( base.rgb.mul( base.a ).mul( blend.a.oneMinus() ) ).div( outAlpha ), outAlpha );

} ).setLayout( {
	name: 'blendColor',
	type: 'vec4',
	inputs: [
		{ name: 'base', type: 'vec4' },
		{ name: 'blend', type: 'vec4' }
	]
} );

// deprecated

const burn = ( ...params ) => { // @deprecated, r171

	console.warn( 'THREE.TSL: "burn" has been renamed. Use "blendBurn" instead.' );
	return blendBurn( params );

};

const dodge = ( ...params ) => { // @deprecated, r171

	console.warn( 'THREE.TSL: "dodge" has been renamed. Use "blendDodge" instead.' );
	return blendDodge( params );

};

const screen = ( ...params ) => { // @deprecated, r171

	console.warn( 'THREE.TSL: "screen" has been renamed. Use "blendScreen" instead.' );
	return blendScreen( params );

};

const overlay = ( ...params ) => { // @deprecated, r171

	console.warn( 'THREE.TSL: "overlay" has been renamed. Use "blendOverlay" instead.' );
	return blendOverlay( params );

};

/** @module ColorAdjustment **/

/**
 * Computes a grayscale value for the given RGB color value.
 *
 * @method
 * @param {Node<vec3>} color - The color value to compute the grayscale for.
 * @return {Node<vec3>} The grayscale color.
 */
const grayscale = /*@__PURE__*/ Fn( ( [ color ] ) => {

	return luminance( color.rgb );

} );

/**
 * Super-saturates or desaturates the given RGB color.
 *
 * @method
 * @param {Node<vec3>} color - The input color.
 * @param {Node<float>} [adjustment=1] - Specifies the amount of the conversion. A value under `1` desaturates the color, a value over `1` super-saturates it.
 * @return {Node<vec3>} The saturated color.
 */
const saturation = /*@__PURE__*/ Fn( ( [ color, adjustment = float( 1 ) ] ) => {

	return adjustment.mix( luminance( color.rgb ), color.rgb );

} );

/**
 * Selectively enhance the intensity of less saturated RGB colors. Can result
 * in a more natural and visually appealing image with enhanced color depth
 * compared to {@link ColorAdjustment#saturation}.
 *
 * @method
 * @param {Node<vec3>} color - The input color.
 * @param {Node<float>} [adjustment=1] - Controls the intensity of the vibrance effect.
 * @return {Node<vec3>} The updated color.
 */
const vibrance = /*@__PURE__*/ Fn( ( [ color, adjustment = float( 1 ) ] ) => {

	const average = add( color.r, color.g, color.b ).div( 3.0 );

	const mx = color.r.max( color.g.max( color.b ) );
	const amt = mx.sub( average ).mul( adjustment ).mul( - 3.0 );

	return mix( color.rgb, mx, amt );

} );

/**
 * Updates the hue component of the given RGB color while preserving its luminance and saturation.
 *
 * @method
 * @param {Node<vec3>} color - The input color.
 * @param {Node<float>} [adjustment=1] - Defines the degree of hue rotation in radians. A positive value rotates the hue clockwise, while a negative value rotates it counterclockwise.
 * @return {Node<vec3>} The updated color.
 */
const hue = /*@__PURE__*/ Fn( ( [ color, adjustment = float( 1 ) ] ) => {

	const k = vec3( 0.57735, 0.57735, 0.57735 );

	const cosAngle = adjustment.cos();

	return vec3( color.rgb.mul( cosAngle ).add( k.cross( color.rgb ).mul( adjustment.sin() ).add( k.mul( dot( k, color.rgb ).mul( cosAngle.oneMinus() ) ) ) ) );

} );

/**
 * Computes the luminance for the given RGB color value.
 *
 * @method
 * @param {Node<vec3>} color - The color value to compute the luminance for.
 * @param {Node<vec3>?} luminanceCoefficients - The luminance coefficients. By default predefined values of the current working color space are used.
 * @return {Node<vec3>} The luminance.
 */
const luminance = (
	color,
	luminanceCoefficients = vec3( ColorManagement.getLuminanceCoefficients( new Vector3() ) )
) => dot( color, luminanceCoefficients );

/**
 * Color Decision List (CDL) v1.2
 *
 * Compact representation of color grading information, defined by slope, offset, power, and
 * saturation. The CDL should be typically be given input in a log space (such as LogC, ACEScc,
 * or AgX Log), and will return output in the same space. Output may require clamping >=0.
 *
 * @method
 * @param {Node<vec4>} color Input (-Infinity < input < +Infinity)
 * @param {Node<vec3>} slope Slope (0 ≤ slope < +Infinity)
 * @param {Node<vec3>} offset Offset (-Infinity < offset < +Infinity; typically -1 < offset < 1)
 * @param {Node<vec3>} power Power (0 < power < +Infinity)
 * @param {Node<float>} saturation Saturation (0 ≤ saturation < +Infinity; typically 0 ≤ saturation < 4)
 * @param {Node<vec3>} luminanceCoefficients Luminance coefficients for saturation term, typically Rec. 709
 * @return {Node<vec4>} Output, -Infinity < output < +Infinity
 *
 * References:
 * - ASC CDL v1.2
 * - {@link https://blender.stackexchange.com/a/55239/43930}
 * - {@link https://docs.acescentral.com/specifications/acescc/}
 */
const cdl = /*@__PURE__*/ Fn( ( [
	color,
	slope = vec3( 1 ),
	offset = vec3( 0 ),
	power = vec3( 1 ),
	saturation = float( 1 ),
	// ASC CDL v1.2 explicitly requires Rec. 709 luminance coefficients.
	luminanceCoefficients = vec3( ColorManagement.getLuminanceCoefficients( new Vector3(), LinearSRGBColorSpace ) )
] ) => {

	// NOTE: The ASC CDL v1.2 defines a [0, 1] clamp on the slope+offset term, and another on the
	// saturation term. Per the ACEScc specification and Filament, limits may be omitted to support
	// values outside [0, 1], requiring a workaround for negative values in the power expression.

	const luma = color.rgb.dot( vec3( luminanceCoefficients ) );

	const v = max$1( color.rgb.mul( slope ).add( offset ), 0.0 ).toVar();
	const pv = v.pow( power ).toVar();

	If( v.r.greaterThan( 0.0 ), () => { v.r.assign( pv.r ); } ); // eslint-disable-line
	If( v.g.greaterThan( 0.0 ), () => { v.g.assign( pv.g ); } ); // eslint-disable-line
	If( v.b.greaterThan( 0.0 ), () => { v.b.assign( pv.b ); } ); // eslint-disable-line

	v.assign( luma.add( v.sub( luma ).mul( saturation ) ) );

	return vec4( v.rgb, color.a );

} );

/** @module PosterizeNode **/

/**
 * Represents a posterize effect which reduces the number of colors
 * in an image, resulting in a more blocky and stylized appearance.
 *
 * @augments TempNode
 */
class PosterizeNode extends TempNode {

	static get type() {

		return 'PosterizeNode';

	}

	/**
	 * Constructs a new posterize node.
	 *
	 * @param {Node} sourceNode - The input color.
	 * @param {Node} stepsNode - Controls the intensity of the posterization effect. A lower number results in a more blocky appearance.
	 */
	constructor( sourceNode, stepsNode ) {

		super();

		/**
		 * The input color.
		 *
		 * @type {Node}
		 */
		this.sourceNode = sourceNode;

		/**
		 * Controls the intensity of the posterization effect. A lower number results in a more blocky appearance.
		 *
		 * @type {Node}
		 */
		this.stepsNode = stepsNode;

	}

	setup() {

		const { sourceNode, stepsNode } = this;

		return sourceNode.mul( stepsNode ).floor().div( stepsNode );

	}

}

/**
 * TSL function for creating a posterize node.
 *
 * @function
 * @param {Node} sourceNode - The input color.
 * @param {Node} stepsNode - Controls the intensity of the posterization effect. A lower number results in a more blocky appearance.
 * @returns {PosterizeNode}
 */
const posterize = /*@__PURE__*/ nodeProxy( PosterizeNode );

/** @module PassNode **/

const _size = /*@__PURE__*/ new Vector2();

/**
 * Represents the texture of a pass node.
 *
 * @augments module:TextureNode~TextureNode
 */
class PassTextureNode extends TextureNode {

	static get type() {

		return 'PassTextureNode';

	}

	/**
	 * Constructs a new pass texture node.
	 *
	 * @param {PassNode} passNode - The pass node.
	 * @param {Texture} texture - The output texture.
	 */
	constructor( passNode, texture ) {

		super( texture );

		/**
		 * A reference to the pass node.
		 *
		 * @type {PassNode}
		 */
		this.passNode = passNode;

		this.setUpdateMatrix( false );

	}

	setup( builder ) {

		if ( builder.object.isQuadMesh ) this.passNode.build( builder );

		return super.setup( builder );

	}

	clone() {

		return new this.constructor( this.passNode, this.value );

	}

}

/**
 * An extension of `PassTextureNode` which allows to manage more than one
 * internal texture. Relevant for the `getPreviousTexture()` related API.
 *
 * @augments module:PassTextureNode~PassTextureNode
 */
class PassMultipleTextureNode extends PassTextureNode {

	static get type() {

		return 'PassMultipleTextureNode';

	}

	/**
	 * Constructs a new pass texture node.
	 *
	 * @param {PassNode} passNode - The pass node.
	 * @param {String} textureName - The output texture name.
	 * @param {Boolean} [previousTexture=false] - Whether previous frame data should be used or not.
	 */
	constructor( passNode, textureName, previousTexture = false ) {

		// null is passed to the super call since this class does not
		// use an external texture for rendering pass data into. Instead
		// the texture is managed by the pass node itself

		super( passNode, null );

		/**
		 * The output texture name.
		 *
		 * @type {String}
		 */
		this.textureName = textureName;

		/**
		 * Whether previous frame data should be used or not.
		 *
		 * @type {Boolean}
		 */
		this.previousTexture = previousTexture;

	}

	/**
	 * Updates the texture reference of this node.
	 */
	updateTexture() {

		this.value = this.previousTexture ? this.passNode.getPreviousTexture( this.textureName ) : this.passNode.getTexture( this.textureName );

	}

	setup( builder ) {

		this.updateTexture();

		return super.setup( builder );

	}

	clone() {

		return new this.constructor( this.passNode, this.textureName, this.previousTexture );

	}

}

/**
 * Represents a render pass (sometimes called beauty pass) in context of post processing.
 * This pass produces a render for the given scene and camera and can provide multiple outputs
 * via MRT for further processing.
 *
 * ```js
 * const postProcessing = new PostProcessing( renderer );
 *
 * const scenePass = pass( scene, camera );
 *
 * postProcessing.outputNode = scenePass;
 * ```
 *
 * @augments TempNode
 */
class PassNode extends TempNode {

	static get type() {

		return 'PassNode';

	}

	/**
	 * Constructs a new pass node.
	 *
	 * @param {('color'|'depth')} scope - The scope of the pass. The scope determines whether the node outputs color or depth.
	 * @param {Scene} scene - A reference to the scene.
	 * @param {Camera} camera - A reference to the camera.
	 * @param {Object} options - Options for the internal render target.
	 */
	constructor( scope, scene, camera, options = {} ) {

		super( 'vec4' );

		/**
		 * The scope of the pass. The scope determines whether the node outputs color or depth.
		 *
		 * @type {('color'|'depth')}
		 */
		this.scope = scope;

		/**
		 * A reference to the scene.
		 *
		 * @type {Scene}
		 */
		this.scene = scene;

		/**
		 * A reference to the camera.
		 *
		 * @type {Camera}
		 */
		this.camera = camera;

		/**
		 * Options for the internal render target.
		 *
		 * @type {Object}
		 */
		this.options = options;

		/**
		 * The pass's pixel ratio. Will be kept automatically kept in sync with the renderer's pixel ratio.
		 *
		 * @private
		 * @type {Number}
		 * @default 1
		 */
		this._pixelRatio = 1;

		/**
		 * The pass's pixel width. Will be kept automatically kept in sync with the renderer's width.
		 * @private
		 * @type {Number}
		 * @default 1
		 */
		this._width = 1;

		/**
		 * The pass's pixel height. Will be kept automatically kept in sync with the renderer's height.
		 * @private
		 * @type {Number}
		 * @default 1
		 */
		this._height = 1;

		const depthTexture = new DepthTexture();
		depthTexture.isRenderTargetTexture = true;
		//depthTexture.type = FloatType;
		depthTexture.name = 'depth';

		const renderTarget = new RenderTarget( this._width * this._pixelRatio, this._height * this._pixelRatio, { type: HalfFloatType, ...options, } );
		renderTarget.texture.name = 'output';
		renderTarget.depthTexture = depthTexture;

		/**
		 * The pass's render target.
		 *
		 * @type {RenderTarget}
		 */
		this.renderTarget = renderTarget;

		/**
		 * A dictionary holding the internal result textures.
		 *
		 * @private
		 * @type {Object<String, Texture>}
		 */
		this._textures = {
			output: renderTarget.texture,
			depth: depthTexture
		};

		/**
		 * A dictionary holding the internal texture nodes.
		 *
		 * @private
		 * @type {Object<String, TextureNode>}
		 */
		this._textureNodes = {};

		/**
		 * A dictionary holding the internal depth nodes.
		 *
		 * @private
		 * @type {Object}
		 */
		this._linearDepthNodes = {};

		/**
		 * A dictionary holding the internal viewZ nodes.
		 *
		 * @private
		 * @type {Object}
		 */
		this._viewZNodes = {};

		/**
		 * A dictionary holding the texture data of the previous frame.
		 * Used for computing velocity/motion vectors.
		 *
		 * @private
		 * @type {Object<String, Texture>}
		 */
		this._previousTextures = {};

		/**
		 * A dictionary holding the texture nodes of the previous frame.
		 * Used for computing velocity/motion vectors.
		 *
		 * @private
		 * @type {Object<String, TextureNode>}
		 */
		this._previousTextureNodes = {};

		/**
		 * The `near` property of the camera as a uniform.
		 *
		 * @private
		 * @type {UniformNode}
		 */
		this._cameraNear = uniform( 0 );

		/**
		 * The `far` property of the camera as a uniform.
		 *
		 * @private
		 * @type {UniformNode}
		 */
		this._cameraFar = uniform( 0 );

		/**
		 * A MRT node configuring the MRT settings.
		 *
		 * @private
		 * @type {MRTNode?}
		 * @default null
		 */
		this._mrt = null;

		/**
		 * This flag can be used for type testing.
		 *
		 * @type {Boolean}
		 * @readonly
		 * @default true
		 */
		this.isPassNode = true;

		/**
		 * The `updateBeforeType` is set to `NodeUpdateType.FRAME` since the node renders the
		 * scene once per frame in its {@link PassNode#updateBefore} method.
		 *
		 * @type {String}
		 * @default 'frame'
		 */
		this.updateBeforeType = NodeUpdateType.FRAME;

	}

	/**
	 * Sets the given MRT node to setup MRT for this pass.
	 *
	 * @param {MRTNode} mrt - The MRT object.
	 * @return {PassNode} A reference to this pass.
	 */
	setMRT( mrt ) {

		this._mrt = mrt;

		return this;

	}

	/**
	 * Returns the current MRT node.
	 *
	 * @return {MRTNode} The current MRT node.
	 */
	getMRT() {

		return this._mrt;

	}

	/**
	 * The method is overwritten so it always returns `true`.
	 *
	 * @return {Boolean} Whether this node is global or not.
	 */
	isGlobal() {

		return true;

	}

	/**
	 * Returns the texture for the given output name.
	 *
	 * @param {String} name - The output name to get the texture for.
	 * @return {Texture} The texture.
	 */
	getTexture( name ) {

		let texture = this._textures[ name ];

		if ( texture === undefined ) {

			const refTexture = this.renderTarget.texture;

			texture = refTexture.clone();
			texture.name = name;

			this._textures[ name ] = texture;

			this.renderTarget.textures.push( texture );

		}

		return texture;

	}

	/**
	 * Returns the texture holding the data of the previous frame for the given output name.
	 *
	 * @param {String} name - The output name to get the texture for.
	 * @return {Texture} The texture holding the data of the previous frame.
	 */
	getPreviousTexture( name ) {

		let texture = this._previousTextures[ name ];

		if ( texture === undefined ) {

			texture = this.getTexture( name ).clone();

			this._previousTextures[ name ] = texture;

		}

		return texture;

	}

	/**
	 * Switches current and previous textures for the given output name.
	 *
	 * @param {String} name - The output name.
	 */
	toggleTexture( name ) {

		const prevTexture = this._previousTextures[ name ];

		if ( prevTexture !== undefined ) {

			const texture = this._textures[ name ];

			const index = this.renderTarget.textures.indexOf( texture );
			this.renderTarget.textures[ index ] = prevTexture;

			this._textures[ name ] = prevTexture;
			this._previousTextures[ name ] = texture;

			this._textureNodes[ name ].updateTexture();
			this._previousTextureNodes[ name ].updateTexture();

		}

	}

	/**
	 * Returns the texture node for the given output name.
	 *
	 * @param {String} [name='output'] - The output name to get the texture node for.
	 * @return {TextureNode} The texture node.
	 */
	getTextureNode( name = 'output' ) {

		let textureNode = this._textureNodes[ name ];

		if ( textureNode === undefined ) {

			textureNode = nodeObject( new PassMultipleTextureNode( this, name ) );
			textureNode.updateTexture();
			this._textureNodes[ name ] = textureNode;

		}

		return textureNode;

	}

	/**
	 * Returns the previous texture node for the given output name.
	 *
	 * @param {String} [name='output'] - The output name to get the previous texture node for.
	 * @return {TextureNode} The previous texture node.
	 */
	getPreviousTextureNode( name = 'output' ) {

		let textureNode = this._previousTextureNodes[ name ];

		if ( textureNode === undefined ) {

			if ( this._textureNodes[ name ] === undefined ) this.getTextureNode( name );

			textureNode = nodeObject( new PassMultipleTextureNode( this, name, true ) );
			textureNode.updateTexture();
			this._previousTextureNodes[ name ] = textureNode;

		}

		return textureNode;

	}

	/**
	 * Returns a viewZ node of this pass.
	 *
	 * @param {String} [name='depth'] - The output name to get the viewZ node for. In most cases the default `'depth'` can be used however the parameter exists for custom depth outputs.
	 * @return {Node} The viewZ node.
	 */
	getViewZNode( name = 'depth' ) {

		let viewZNode = this._viewZNodes[ name ];

		if ( viewZNode === undefined ) {

			const cameraNear = this._cameraNear;
			const cameraFar = this._cameraFar;

			this._viewZNodes[ name ] = viewZNode = perspectiveDepthToViewZ( this.getTextureNode( name ), cameraNear, cameraFar );

		}

		return viewZNode;

	}

	/**
	 * Returns a linear depth node of this pass.
	 *
	 * @param {String} [name='depth'] - The output name to get the linear depth node for. In most cases the default `'depth'` can be used however the parameter exists for custom depth outputs.
	 * @return {Node} The linear depth node.
	 */
	getLinearDepthNode( name = 'depth' ) {

		let linearDepthNode = this._linearDepthNodes[ name ];

		if ( linearDepthNode === undefined ) {

			const cameraNear = this._cameraNear;
			const cameraFar = this._cameraFar;
			const viewZNode = this.getViewZNode( name );

			// TODO: just if ( builder.camera.isPerspectiveCamera )

			this._linearDepthNodes[ name ] = linearDepthNode = viewZToOrthographicDepth( viewZNode, cameraNear, cameraFar );

		}

		return linearDepthNode;

	}

	setup( { renderer } ) {

		this.renderTarget.samples = this.options.samples === undefined ? renderer.samples : this.options.samples;

		// Disable MSAA for WebGL backend for now
		if ( renderer.backend.isWebGLBackend === true ) {

			this.renderTarget.samples = 0;

		}

		return this.scope === PassNode.COLOR ? this.getTextureNode() : this.getLinearDepthNode();

	}

	updateBefore( frame ) {

		const { renderer } = frame;
		const { scene, camera } = this;

		this._pixelRatio = renderer.getPixelRatio();

		const size = renderer.getSize( _size );

		this.setSize( size.width, size.height );

		const currentRenderTarget = renderer.getRenderTarget();
		const currentMRT = renderer.getMRT();

		this._cameraNear.value = camera.near;
		this._cameraFar.value = camera.far;

		for ( const name in this._previousTextures ) {

			this.toggleTexture( name );

		}

		renderer.setRenderTarget( this.renderTarget );
		renderer.setMRT( this._mrt );

		renderer.render( scene, camera );

		renderer.setRenderTarget( currentRenderTarget );
		renderer.setMRT( currentMRT );

	}

	/**
	 * Sets the size of the pass's render target. Honors the pixel ratio.
	 *
	 * @param {Number} width - The width to set.
	 * @param {Number} height - The height to set.
	 */
	setSize( width, height ) {

		this._width = width;
		this._height = height;

		const effectiveWidth = this._width * this._pixelRatio;
		const effectiveHeight = this._height * this._pixelRatio;

		this.renderTarget.setSize( effectiveWidth, effectiveHeight );

	}

	/**
	 * Sets the pixel ratio the pass's render target and updates the size.
	 *
	 * @param {Number} pixelRatio - The pixel ratio to set.
	 */
	setPixelRatio( pixelRatio ) {

		this._pixelRatio = pixelRatio;

		this.setSize( this._width, this._height );

	}

	/**
	 * Frees internal resources. Should be called when the node is no longer in use.
	 */
	dispose() {

		this.renderTarget.dispose();

	}


}

PassNode.COLOR = 'color';
PassNode.DEPTH = 'depth';

/**
 * TSL function for creating a pass node.
 *
 * @function
 * @param {Scene} scene - A reference to the scene.
 * @param {Camera} camera - A reference to the camera.
 * @param {Object} options - Options for the internal render target.
 * @returns {PassNode}
 */
const pass = ( scene, camera, options ) => nodeObject( new PassNode( PassNode.COLOR, scene, camera, options ) );

/**
 * TSL function for creating a pass texture node.
 *
 * @function
 * @param {PassNode} pass - The pass node.
 * @param {Texture} texture - The output texture.
 * @returns {PassTextureNode}
 */
const passTexture = ( pass, texture ) => nodeObject( new PassTextureNode( pass, texture ) );

/**
 * TSL function for creating a depth pass node.
 *
 * @function
 * @param {Scene} scene - A reference to the scene.
 * @param {Camera} camera - A reference to the camera.
 * @param {Object} options - Options for the internal render target.
 * @returns {PassNode}
 */
const depthPass = ( scene, camera, options ) => nodeObject( new PassNode( PassNode.DEPTH, scene, camera, options ) );

/** @module ToonOutlinePassNode **/

/**
 * Represents a render pass for producing a toon outline effect on compatible objects.
 * Only 3D objects with materials of type `MeshToonMaterial` and `MeshToonNodeMaterial`
 * will receive the outline.
 *
 * ```js
 * const postProcessing = new PostProcessing( renderer );
 *
 * const scenePass = toonOutlinePass( scene, camera );
 *
 * postProcessing.outputNode = scenePass;
 * ```
 * @augments PassNode
 */
class ToonOutlinePassNode extends PassNode {

	static get type() {

		return 'ToonOutlinePassNode';

	}

	/**
	 * Constructs a new outline pass node.
	 *
	 * @param {Scene} scene - A reference to the scene.
	 * @param {Camera} camera - A reference to the camera.
	 * @param {Node} colorNode - Defines the outline's color.
	 * @param {Node} thicknessNode - Defines the outline's thickness.
	 * @param {Node} alphaNode - Defines the outline's alpha.
	 */
	constructor( scene, camera, colorNode, thicknessNode, alphaNode ) {

		super( PassNode.COLOR, scene, camera );

		/**
		 * Defines the outline's color.
		 *
		 * @type {Node}
		 */
		this.colorNode = colorNode;

		/**
		 * Defines the outline's thickness.
		 *
		 * @type {Node}
		 */
		this.thicknessNode = thicknessNode;

		/**
		 * Defines the outline's alpha.
		 *
		 * @type {Node}
		 */
		this.alphaNode = alphaNode;

		/**
		 * An internal material cache.
		 *
		 * @private
		 * @type {WeakMap<Material, NodeMaterial>}
		 */
		this._materialCache = new WeakMap();

	}

	updateBefore( frame ) {

		const { renderer } = frame;

		const currentRenderObjectFunction = renderer.getRenderObjectFunction();

		renderer.setRenderObjectFunction( ( object, scene, camera, geometry, material, group, lightsNode, clippingContext ) => {

			// only render outline for supported materials

			if ( material.isMeshToonMaterial || material.isMeshToonNodeMaterial ) {

				if ( material.wireframe === false ) {

					const outlineMaterial = this._getOutlineMaterial( material );
					renderer.renderObject( object, scene, camera, geometry, outlineMaterial, group, lightsNode, clippingContext );

				}

			}

			// default

			renderer.renderObject( object, scene, camera, geometry, material, group, lightsNode, clippingContext );

		} );

		super.updateBefore( frame );

		renderer.setRenderObjectFunction( currentRenderObjectFunction );

	}

	/**
	 * Creates the material used for outline rendering.
	 *
	 * @private
	 * @return {NodeMaterial} The outline material.
	 */
	_createMaterial() {

		const material = new NodeMaterial();
		material.isMeshToonOutlineMaterial = true;
		material.name = 'Toon_Outline';
		material.side = BackSide;

		// vertex node

		const outlineNormal = normalLocal.negate();
		const mvp = cameraProjectionMatrix.mul( modelViewMatrix );

		const ratio = float( 1.0 ); // TODO: support outline thickness ratio for each vertex
		const pos = mvp.mul( vec4( positionLocal, 1.0 ) );
		const pos2 = mvp.mul( vec4( positionLocal.add( outlineNormal ), 1.0 ) );
		const norm = normalize( pos.sub( pos2 ) ); // NOTE: subtract pos2 from pos because BackSide objectNormal is negative

		material.vertexNode = pos.add( norm.mul( this.thicknessNode ).mul( pos.w ).mul( ratio ) );

		// color node

		material.colorNode = vec4( this.colorNode, this.alphaNode );

		return material;

	}

	/**
	 * For the given toon material, this method returns a corresponding
	 * outline material.
	 *
	 * @private
	 * @param {(MeshToonMaterial|MeshToonNodeMaterial)} originalMaterial - The toon material.
	 * @return {NodeMaterial} The outline material.
	 */
	_getOutlineMaterial( originalMaterial ) {

		let outlineMaterial = this._materialCache.get( originalMaterial );

		if ( outlineMaterial === undefined ) {

			outlineMaterial = this._createMaterial();

			this._materialCache.set( originalMaterial, outlineMaterial );

		}

		return outlineMaterial;

	}

}

/**
 * TSL function for creating a toon outline pass node.
 *
 * @function
 * @param {Scene} scene - A reference to the scene.
 * @param {Camera} camera - A reference to the camera.
 * @param {Color} color - Defines the outline's color.
 * @param {Number} [thickness=0.003] - Defines the outline's thickness.
 * @param {Number} [alpha=1] - Defines the outline's alpha.
 * @returns {ToonOutlinePassNode}
 */
const toonOutlinePass = ( scene, camera, color = new Color( 0, 0, 0 ), thickness = 0.003, alpha = 1 ) => nodeObject( new ToonOutlinePassNode( scene, camera, nodeObject( color ), nodeObject( thickness ), nodeObject( alpha ) ) );

/** @module ToneMappingFunctions **/

/**
 * Linear tone mapping, exposure only.
 *
 * @method
 * @param {Node<vec3>} color - The color that should be tone mapped.
 * @param {Node<float>} exposure - The exposure.
 * @return {Node<vec3>} The tone mapped color.
 */
const linearToneMapping = /*@__PURE__*/ Fn( ( [ color, exposure ] ) => {

	return color.mul( exposure ).clamp();

} ).setLayout( {
	name: 'linearToneMapping',
	type: 'vec3',
	inputs: [
		{ name: 'color', type: 'vec3' },
		{ name: 'exposure', type: 'float' }
	]
} );

/**
 * Reinhard tone mapping.
 *
 * Reference: {@link https://www.cs.utah.edu/docs/techreports/2002/pdf/UUCS-02-001.pdf}
 *
 * @method
 * @param {Node<vec3>} color - The color that should be tone mapped.
 * @param {Node<float>} exposure - The exposure.
 * @return {Node<vec3>} The tone mapped color.
 */
const reinhardToneMapping = /*@__PURE__*/ Fn( ( [ color, exposure ] ) => {

	color = color.mul( exposure );

	return color.div( color.add( 1.0 ) ).clamp();

} ).setLayout( {
	name: 'reinhardToneMapping',
	type: 'vec3',
	inputs: [
		{ name: 'color', type: 'vec3' },
		{ name: 'exposure', type: 'float' }
	]
} );

/**
 * Cineon tone mapping.
 *
 * Reference: {@link http://filmicworlds.com/blog/filmic-tonemapping-operators/}
 *
 * @method
 * @param {Node<vec3>} color - The color that should be tone mapped.
 * @param {Node<float>} exposure - The exposure.
 * @return {Node<vec3>} The tone mapped color.
 */
const cineonToneMapping = /*@__PURE__*/ Fn( ( [ color, exposure ] ) => {

	// filmic operator by Jim Hejl and Richard Burgess-Dawson
	color = color.mul( exposure );
	color = color.sub( 0.004 ).max( 0.0 );

	const a = color.mul( color.mul( 6.2 ).add( 0.5 ) );
	const b = color.mul( color.mul( 6.2 ).add( 1.7 ) ).add( 0.06 );

	return a.div( b ).pow( 2.2 );

} ).setLayout( {
	name: 'cineonToneMapping',
	type: 'vec3',
	inputs: [
		{ name: 'color', type: 'vec3' },
		{ name: 'exposure', type: 'float' }
	]
} );

// source: https://github.com/selfshadow/ltc_code/blob/master/webgl/shaders/ltc/ltc_blit.fs

const RRTAndODTFit = /*@__PURE__*/ Fn( ( [ color ] ) => {

	const a = color.mul( color.add( 0.0245786 ) ).sub( 0.000090537 );
	const b = color.mul( color.add( 0.4329510 ).mul( 0.983729 ) ).add( 0.238081 );

	return a.div( b );

} );

/**
 * ACESFilmic tone mapping.
 *
 * Reference: {@link https://github.com/selfshadow/ltc_code/blob/master/webgl/shaders/ltc/ltc_blit.fs}
 *
 * @method
 * @param {Node<vec3>} color - The color that should be tone mapped.
 * @param {Node<float>} exposure - The exposure.
 * @return {Node<vec3>} The tone mapped color.
 */
const acesFilmicToneMapping = /*@__PURE__*/ Fn( ( [ color, exposure ] ) => {

	// sRGB => XYZ => D65_2_D60 => AP1 => RRT_SAT
	const ACESInputMat = mat3(
		0.59719, 0.35458, 0.04823,
		0.07600, 0.90834, 0.01566,
		0.02840, 0.13383, 0.83777
	);

	// ODT_SAT => XYZ => D60_2_D65 => sRGB
	const ACESOutputMat = mat3(
		1.60475, - 0.53108, - 0.07367,
		- 0.10208, 1.10813, - 0.00605,
		- 0.00327, - 0.07276, 1.07602
	);

	color = color.mul( exposure ).div( 0.6 );

	color = ACESInputMat.mul( color );

	// Apply RRT and ODT
	color = RRTAndODTFit( color );

	color = ACESOutputMat.mul( color );

	// Clamp to [0, 1]
	return color.clamp();

} ).setLayout( {
	name: 'acesFilmicToneMapping',
	type: 'vec3',
	inputs: [
		{ name: 'color', type: 'vec3' },
		{ name: 'exposure', type: 'float' }
	]
} );

const LINEAR_REC2020_TO_LINEAR_SRGB = /*@__PURE__*/ mat3( vec3( 1.6605, - 0.1246, - 0.0182 ), vec3( - 0.5876, 1.1329, - 0.1006 ), vec3( - 0.0728, - 0.0083, 1.1187 ) );
const LINEAR_SRGB_TO_LINEAR_REC2020 = /*@__PURE__*/ mat3( vec3( 0.6274, 0.0691, 0.0164 ), vec3( 0.3293, 0.9195, 0.0880 ), vec3( 0.0433, 0.0113, 0.8956 ) );

const agxDefaultContrastApprox = /*@__PURE__*/ Fn( ( [ x_immutable ] ) => {

	const x = vec3( x_immutable ).toVar();
	const x2 = vec3( x.mul( x ) ).toVar();
	const x4 = vec3( x2.mul( x2 ) ).toVar();

	return float( 15.5 ).mul( x4.mul( x2 ) ).sub( mul( 40.14, x4.mul( x ) ) ).add( mul( 31.96, x4 ).sub( mul( 6.868, x2.mul( x ) ) ).add( mul( 0.4298, x2 ).add( mul( 0.1191, x ).sub( 0.00232 ) ) ) );

} );

/**
 * AgX tone mapping.
 *
 * @method
 * @param {Node<vec3>} color - The color that should be tone mapped.
 * @param {Node<float>} exposure - The exposure.
 * @return {Node<vec3>} The tone mapped color.
 */
const agxToneMapping = /*@__PURE__*/ Fn( ( [ color, exposure ] ) => {

	const colortone = vec3( color ).toVar();
	const AgXInsetMatrix = mat3( vec3( 0.856627153315983, 0.137318972929847, 0.11189821299995 ), vec3( 0.0951212405381588, 0.761241990602591, 0.0767994186031903 ), vec3( 0.0482516061458583, 0.101439036467562, 0.811302368396859 ) );
	const AgXOutsetMatrix = mat3( vec3( 1.1271005818144368, - 0.1413297634984383, - 0.14132976349843826 ), vec3( - 0.11060664309660323, 1.157823702216272, - 0.11060664309660294 ), vec3( - 0.016493938717834573, - 0.016493938717834257, 1.2519364065950405 ) );
	const AgxMinEv = float( - 12.47393 );
	const AgxMaxEv = float( 4.026069 );
	colortone.mulAssign( exposure );
	colortone.assign( LINEAR_SRGB_TO_LINEAR_REC2020.mul( colortone ) );
	colortone.assign( AgXInsetMatrix.mul( colortone ) );
	colortone.assign( max$1( colortone, 1e-10 ) );
	colortone.assign( log2( colortone ) );
	colortone.assign( colortone.sub( AgxMinEv ).div( AgxMaxEv.sub( AgxMinEv ) ) );
	colortone.assign( clamp( colortone, 0.0, 1.0 ) );
	colortone.assign( agxDefaultContrastApprox( colortone ) );
	colortone.assign( AgXOutsetMatrix.mul( colortone ) );
	colortone.assign( pow( max$1( vec3( 0.0 ), colortone ), vec3( 2.2 ) ) );
	colortone.assign( LINEAR_REC2020_TO_LINEAR_SRGB.mul( colortone ) );
	colortone.assign( clamp( colortone, 0.0, 1.0 ) );

	return colortone;

} ).setLayout( {
	name: 'agxToneMapping',
	type: 'vec3',
	inputs: [
		{ name: 'color', type: 'vec3' },
		{ name: 'exposure', type: 'float' }
	]
} );

/**
 * Neutral tone mapping.
 *
 * Reference: {@link https://modelviewer.dev/examples/tone-mapping}
 *
 * @method
 * @param {Node<vec3>} color - The color that should be tone mapped.
 * @param {Node<float>} exposure - The exposure.
 * @return {Node<vec3>} The tone mapped color.
 */
const neutralToneMapping = /*@__PURE__*/ Fn( ( [ color, exposure ] ) => {

	const StartCompression = float( 0.8 - 0.04 );
	const Desaturation = float( 0.15 );

	color = color.mul( exposure );

	const x = min$1( color.r, min$1( color.g, color.b ) );
	const offset = select( x.lessThan( 0.08 ), x.sub( mul( 6.25, x.mul( x ) ) ), 0.04 );

	color.subAssign( offset );

	const peak = max$1( color.r, max$1( color.g, color.b ) );

	If( peak.lessThan( StartCompression ), () => {

		return color;

	} );

	const d = sub( 1, StartCompression );
	const newPeak = sub( 1, d.mul( d ).div( peak.add( d.sub( StartCompression ) ) ) );
	color.mulAssign( newPeak.div( peak ) );
	const g = sub( 1, div( 1, Desaturation.mul( peak.sub( newPeak ) ).add( 1 ) ) );

	return mix( color, vec3( newPeak ), g );

} ).setLayout( {
	name: 'neutralToneMapping',
	type: 'vec3',
	inputs: [
		{ name: 'color', type: 'vec3' },
		{ name: 'exposure', type: 'float' }
	]
} );

/** @module CodeNode **/

/**
 * This class represents native code sections. It is the base
 * class for modules like {@link FunctionNode} which allows to implement
 * functions with native shader languages.
 *
 * @augments Node
 */
class CodeNode extends Node {

	static get type() {

		return 'CodeNode';

	}

	/**
	 * Constructs a new code node.
	 *
	 * @param {String} [code=''] - The native code.
	 * @param {Array<Node>} [includes=[]] - An array of includes.
	 * @param {('js'|'wgsl'|'glsl')} [language=''] - The used language.
	 */
	constructor( code = '', includes = [], language = '' ) {

		super( 'code' );

		/**
		 * This flag can be used for type testing.
		 *
		 * @type {Boolean}
		 * @readonly
		 * @default true
		 */
		this.isCodeNode = true;

		/**
		 * The native code.
		 *
		 * @type {String}
		 * @default ''
		 */
		this.code = code;

		/**
		 * An array of includes
		 *
		 * @type {Array<Node>}
		 * @default []
		 */
		this.includes = includes;

		/**
		 * The used language.
		 *
		 * @type {('js'|'wgsl'|'glsl')}
		 * @default ''
		 */
		this.language = language;

	}

	/**
	 * The method is overwritten so it always returns `true`.
	 *
	 * @return {Boolean} Whether this node is global or not.
	 */
	isGlobal() {

		return true;

	}

	/**
	 * Sets the includes of this code node.
	 *
	 * @param {Array<Node>} includes - The includes to set.
	 * @return {CodeNode} A reference to this node.
	 */
	setIncludes( includes ) {

		this.includes = includes;

		return this;

	}

	/**
	 * Returns the includes of this code node.
	 *
	 * @param {NodeBuilder} builder - The current node builder.
	 * @return {Array<Node>} The includes.
	 */
	getIncludes( /*builder*/ ) {

		return this.includes;

	}

	generate( builder ) {

		const includes = this.getIncludes( builder );

		for ( const include of includes ) {

			include.build( builder );

		}

		const nodeCode = builder.getCodeFromNode( this, this.getNodeType( builder ) );
		nodeCode.code = this.code;

		return nodeCode.code;

	}

	serialize( data ) {

		super.serialize( data );

		data.code = this.code;
		data.language = this.language;

	}

	deserialize( data ) {

		super.deserialize( data );

		this.code = data.code;
		this.language = data.language;

	}

}

/**
 * TSL function for creating a code node.
 *
 * @function
 * @param {String} [code=''] - The native code.
 * @param {Array<Node>} [includes=[]] - An array of includes.
 * @param {('js'|'wgsl'|'glsl')} [language=''] - The used language.
 * @returns {CodeNode}
 */
const code = /*@__PURE__*/ nodeProxy( CodeNode );

/**
 * TSL function for creating a JS code node.
 *
 * @function
 * @param {String} src - The native code.
 * @param {Array<Node>} includes - An array of includes.
 * @returns {CodeNode}
 */
const js = ( src, includes ) => code( src, includes, 'js' );

/**
 * TSL function for creating a WGSL code node.
 *
 * @function
 * @param {String} src - The native code.
 * @param {Array<Node>} includes - An array of includes.
 * @returns {CodeNode}
 */
const wgsl = ( src, includes ) => code( src, includes, 'wgsl' );

/**
 * TSL function for creating a GLSL code node.
 *
 * @function
 * @param {String} src - The native code.
 * @param {Array<Node>} includes - An array of includes.
 * @returns {CodeNode}
 */
const glsl = ( src, includes ) => code( src, includes, 'glsl' );

/**
 * This class represents a native shader function. It can be used to implement
 * certain aspects of a node material with native shader code. There are two predefined
 * TSL functions for easier usage.
 *
 * - `wgslFn`: Creates a WGSL function node.
 * - `glslFn`: Creates a GLSL function node.
 *
 * A basic example with one include looks like so:
 *
 * ```js
 * const desaturateWGSLFn = wgslFn( `
 *	fn desaturate( color:vec3<f32> ) -> vec3<f32> {
 *		let lum = vec3<f32>( 0.299, 0.587, 0.114 );
 *		return vec3<f32>( dot( lum, color ) );
 *	}`
 *);
 * const someWGSLFn = wgslFn( `
 *	fn someFn( color:vec3<f32> ) -> vec3<f32> {
 * 		return desaturate( color );
 * 	}
 * `, [ desaturateWGSLFn ] );
 * material.colorNode = someWGSLFn( { color: texture( map ) } );
 *```
 * @augments CodeNode
 */
class FunctionNode extends CodeNode {

	static get type() {

		return 'FunctionNode';

	}

	/**
	 * Constructs a new function node.
	 *
	 * @param {String} [code=''] - The native code.
	 * @param {Array<Node>} [includes=[]] - An array of includes.
	 * @param {('js'|'wgsl'|'glsl')} [language=''] - The used language.
	 */
	constructor( code = '', includes = [], language = '' ) {

		super( code, includes, language );

	}

	getNodeType( builder ) {

		return this.getNodeFunction( builder ).type;

	}

	/**
	 * Returns the inputs of this function node.
	 *
	 * @param {NodeBuilder} builder - The current node builder.
	 * @return {Array<NodeFunctionInput>} The inputs.
	 */
	getInputs( builder ) {

		return this.getNodeFunction( builder ).inputs;

	}

	/**
	 * Returns the node function for this function node.
	 *
	 * @param {NodeBuilder} builder - The current node builder.
	 * @return {NodeFunction} The node function.
	 */
	getNodeFunction( builder ) {

		const nodeData = builder.getDataFromNode( this );

		let nodeFunction = nodeData.nodeFunction;

		if ( nodeFunction === undefined ) {

			nodeFunction = builder.parser.parseFunction( this.code );

			nodeData.nodeFunction = nodeFunction;

		}

		return nodeFunction;

	}

	generate( builder, output ) {

		super.generate( builder );

		const nodeFunction = this.getNodeFunction( builder );

		const name = nodeFunction.name;
		const type = nodeFunction.type;

		const nodeCode = builder.getCodeFromNode( this, type );

		if ( name !== '' ) {

			// use a custom property name

			nodeCode.name = name;

		}

		const propertyName = builder.getPropertyName( nodeCode );

		const code = this.getNodeFunction( builder ).getCode( propertyName );

		nodeCode.code = code + '\n';

		if ( output === 'property' ) {

			return propertyName;

		} else {

			return builder.format( `${ propertyName }()`, type, output );

		}

	}

}

const nativeFn = ( code, includes = [], language = '' ) => {

	for ( let i = 0; i < includes.length; i ++ ) {

		const include = includes[ i ];

		// TSL Function: glslFn, wgslFn

		if ( typeof include === 'function' ) {

			includes[ i ] = include.functionNode;

		}

	}

	const functionNode = nodeObject( new FunctionNode( code, includes, language ) );

	const fn = ( ...params ) => functionNode.call( ...params );
	fn.functionNode = functionNode;

	return fn;

};

const glslFn = ( code, includes ) => nativeFn( code, includes, 'glsl' );
const wgslFn = ( code, includes ) => nativeFn( code, includes, 'wgsl' );

class ScriptableValueNode extends Node {

	static get type() {

		return 'ScriptableValueNode';

	}

	constructor( value = null ) {

		super();

		this._value = value;
		this._cache = null;

		this.inputType = null;
		this.outputType = null;

		this.events = new EventDispatcher();

		this.isScriptableValueNode = true;

	}

	get isScriptableOutputNode() {

		return this.outputType !== null;

	}

	set value( val ) {

		if ( this._value === val ) return;

		if ( this._cache && this.inputType === 'URL' && this.value.value instanceof ArrayBuffer ) {

			URL.revokeObjectURL( this._cache );

			this._cache = null;

		}

		this._value = val;

		this.events.dispatchEvent( { type: 'change' } );

		this.refresh();

	}

	get value() {

		return this._value;

	}

	refresh() {

		this.events.dispatchEvent( { type: 'refresh' } );

	}

	getValue() {

		const value = this.value;

		if ( value && this._cache === null && this.inputType === 'URL' && value.value instanceof ArrayBuffer ) {

			this._cache = URL.createObjectURL( new Blob( [ value.value ] ) );

		} else if ( value && value.value !== null && value.value !== undefined && (
			( ( this.inputType === 'URL' || this.inputType === 'String' ) && typeof value.value === 'string' ) ||
			( this.inputType === 'Number' && typeof value.value === 'number' ) ||
			( this.inputType === 'Vector2' && value.value.isVector2 ) ||
			( this.inputType === 'Vector3' && value.value.isVector3 ) ||
			( this.inputType === 'Vector4' && value.value.isVector4 ) ||
			( this.inputType === 'Color' && value.value.isColor ) ||
			( this.inputType === 'Matrix3' && value.value.isMatrix3 ) ||
			( this.inputType === 'Matrix4' && value.value.isMatrix4 )
		) ) {

			return value.value;

		}

		return this._cache || value;

	}

	getNodeType( builder ) {

		return this.value && this.value.isNode ? this.value.getNodeType( builder ) : 'float';

	}

	setup() {

		return this.value && this.value.isNode ? this.value : float();

	}

	serialize( data ) {

		super.serialize( data );

		if ( this.value !== null ) {

			if ( this.inputType === 'ArrayBuffer' ) {

				data.value = arrayBufferToBase64( this.value );

			} else {

				data.value = this.value ? this.value.toJSON( data.meta ).uuid : null;

			}

		} else {

			data.value = null;

		}

		data.inputType = this.inputType;
		data.outputType = this.outputType;

	}

	deserialize( data ) {

		super.deserialize( data );

		let value = null;

		if ( data.value !== null ) {

			if ( data.inputType === 'ArrayBuffer' ) {

				value = base64ToArrayBuffer( data.value );

			} else if ( data.inputType === 'Texture' ) {

				value = data.meta.textures[ data.value ];

			} else {

				value = data.meta.nodes[ data.value ] || null;

			}

		}

		this.value = value;

		this.inputType = data.inputType;
		this.outputType = data.outputType;

	}

}

const scriptableValue = /*@__PURE__*/ nodeProxy( ScriptableValueNode );

class Resources extends Map {

	get( key, callback = null, ...params ) {

		if ( this.has( key ) ) return super.get( key );

		if ( callback !== null ) {

			const value = callback( ...params );
			this.set( key, value );
			return value;

		}

	}

}

class Parameters {

	constructor( scriptableNode ) {

		this.scriptableNode = scriptableNode;

	}

	get parameters() {

		return this.scriptableNode.parameters;

	}

	get layout() {

		return this.scriptableNode.getLayout();

	}

	getInputLayout( id ) {

		return this.scriptableNode.getInputLayout( id );

	}

	get( name ) {

		const param = this.parameters[ name ];
		const value = param ? param.getValue() : null;

		return value;

	}

}

const ScriptableNodeResources = new Resources();

class ScriptableNode extends Node {

	static get type() {

		return 'ScriptableNode';

	}

	constructor( codeNode = null, parameters = {} ) {

		super();

		this.codeNode = codeNode;
		this.parameters = parameters;

		this._local = new Resources();
		this._output = scriptableValue();
		this._outputs = {};
		this._source = this.source;
		this._method = null;
		this._object = null;
		this._value = null;
		this._needsOutputUpdate = true;

		this.onRefresh = this.onRefresh.bind( this );

		this.isScriptableNode = true;

	}

	get source() {

		return this.codeNode ? this.codeNode.code : '';

	}

	setLocal( name, value ) {

		return this._local.set( name, value );

	}

	getLocal( name ) {

		return this._local.get( name );

	}

	onRefresh() {

		this._refresh();

	}

	getInputLayout( id ) {

		for ( const element of this.getLayout() ) {

			if ( element.inputType && ( element.id === id || element.name === id ) ) {

				return element;

			}

		}

	}

	getOutputLayout( id ) {

		for ( const element of this.getLayout() ) {

			if ( element.outputType && ( element.id === id || element.name === id ) ) {

				return element;

			}

		}

	}

	setOutput( name, value ) {

		const outputs = this._outputs;

		if ( outputs[ name ] === undefined ) {

			outputs[ name ] = scriptableValue( value );

		} else {

			outputs[ name ].value = value;

		}

		return this;

	}

	getOutput( name ) {

		return this._outputs[ name ];

	}

	getParameter( name ) {

		return this.parameters[ name ];

	}

	setParameter( name, value ) {

		const parameters = this.parameters;

		if ( value && value.isScriptableNode ) {

			this.deleteParameter( name );

			parameters[ name ] = value;
			parameters[ name ].getDefaultOutput().events.addEventListener( 'refresh', this.onRefresh );

		} else if ( value && value.isScriptableValueNode ) {

			this.deleteParameter( name );

			parameters[ name ] = value;
			parameters[ name ].events.addEventListener( 'refresh', this.onRefresh );

		} else if ( parameters[ name ] === undefined ) {

			parameters[ name ] = scriptableValue( value );
			parameters[ name ].events.addEventListener( 'refresh', this.onRefresh );

		} else {

			parameters[ name ].value = value;

		}

		return this;

	}

	getValue() {

		return this.getDefaultOutput().getValue();

	}

	deleteParameter( name ) {

		let valueNode = this.parameters[ name ];

		if ( valueNode ) {

			if ( valueNode.isScriptableNode ) valueNode = valueNode.getDefaultOutput();

			valueNode.events.removeEventListener( 'refresh', this.onRefresh );

		}

		return this;

	}

	clearParameters() {

		for ( const name of Object.keys( this.parameters ) ) {

			this.deleteParameter( name );

		}

		this.needsUpdate = true;

		return this;

	}

	call( name, ...params ) {

		const object = this.getObject();
		const method = object[ name ];

		if ( typeof method === 'function' ) {

			return method( ...params );

		}

	}

	async callAsync( name, ...params ) {

		const object = this.getObject();
		const method = object[ name ];

		if ( typeof method === 'function' ) {

			return method.constructor.name === 'AsyncFunction' ? await method( ...params ) : method( ...params );

		}

	}

	getNodeType( builder ) {

		return this.getDefaultOutputNode().getNodeType( builder );

	}

	refresh( output = null ) {

		if ( output !== null ) {

			this.getOutput( output ).refresh();

		} else {

			this._refresh();

		}

	}

	getObject() {

		if ( this.needsUpdate ) this.dispose();
		if ( this._object !== null ) return this._object;

		//

		const refresh = () => this.refresh();
		const setOutput = ( id, value ) => this.setOutput( id, value );

		const parameters = new Parameters( this );

		const THREE = ScriptableNodeResources.get( 'THREE' );
		const TSL = ScriptableNodeResources.get( 'TSL' );

		const method = this.getMethod( this.codeNode );
		const params = [ parameters, this._local, ScriptableNodeResources, refresh, setOutput, THREE, TSL ];

		this._object = method( ...params );

		const layout = this._object.layout;

		if ( layout ) {

			if ( layout.cache === false ) {

				this._local.clear();

			}

			// default output
			this._output.outputType = layout.outputType || null;

			if ( Array.isArray( layout.elements ) ) {

				for ( const element of layout.elements ) {

					const id = element.id || element.name;

					if ( element.inputType ) {

						if ( this.getParameter( id ) === undefined ) this.setParameter( id, null );

						this.getParameter( id ).inputType = element.inputType;

					}

					if ( element.outputType ) {

						if ( this.getOutput( id ) === undefined ) this.setOutput( id, null );

						this.getOutput( id ).outputType = element.outputType;

					}

				}

			}

		}

		return this._object;

	}

	deserialize( data ) {

		super.deserialize( data );

		for ( const name in this.parameters ) {

			let valueNode = this.parameters[ name ];

			if ( valueNode.isScriptableNode ) valueNode = valueNode.getDefaultOutput();

			valueNode.events.addEventListener( 'refresh', this.onRefresh );

		}

	}

	getLayout() {

		return this.getObject().layout;

	}

	getDefaultOutputNode() {

		const output = this.getDefaultOutput().value;

		if ( output && output.isNode ) {

			return output;

		}

		return float();

	}

	getDefaultOutput()	{

		return this._exec()._output;

	}

	getMethod() {

		if ( this.needsUpdate ) this.dispose();
		if ( this._method !== null ) return this._method;

		//

		const parametersProps = [ 'parameters', 'local', 'global', 'refresh', 'setOutput', 'THREE', 'TSL' ];
		const interfaceProps = [ 'layout', 'init', 'main', 'dispose' ];

		const properties = interfaceProps.join( ', ' );
		const declarations = 'var ' + properties + '; var output = {};\n';
		const returns = '\nreturn { ...output, ' + properties + ' };';

		const code = declarations + this.codeNode.code + returns;

		//

		this._method = new Function( ...parametersProps, code );

		return this._method;

	}

	dispose() {

		if ( this._method === null ) return;

		if ( this._object && typeof this._object.dispose === 'function' ) {

			this._object.dispose();

		}

		this._method = null;
		this._object = null;
		this._source = null;
		this._value = null;
		this._needsOutputUpdate = true;
		this._output.value = null;
		this._outputs = {};

	}

	setup() {

		return this.getDefaultOutputNode();

	}

	getCacheKey( force ) {

		const values = [ hashString( this.source ), this.getDefaultOutputNode().getCacheKey( force ) ];

		for ( const param in this.parameters ) {

			values.push( this.parameters[ param ].getCacheKey( force ) );

		}

		return hashArray( values );

	}

	set needsUpdate( value ) {

		if ( value === true ) this.dispose();

	}

	get needsUpdate() {

		return this.source !== this._source;

	}

	_exec()	{

		if ( this.codeNode === null ) return this;

		if ( this._needsOutputUpdate === true ) {

			this._value = this.call( 'main' );

			this._needsOutputUpdate = false;

		}

		this._output.value = this._value;

		return this;

	}

	_refresh() {

		this.needsUpdate = true;

		this._exec();

		this._output.refresh();

	}

}

const scriptable = /*@__PURE__*/ nodeProxy( ScriptableNode );

/** @module Fog **/

/**
 * Returns a node that represents the `z` coordinate in view space
 * for the current fragment. It's a different representation of the
 * default depth value.
 *
 * This value can be part of a computation that defines how the fog
 * density increases when moving away from the camera.
 *
 * @param {NodeBuilder} builder - The current node builder.
 * @return {Node} The viewZ node.
 */
function getViewZNode( builder ) {

	let viewZ;

	const getViewZ = builder.context.getViewZ;

	if ( getViewZ !== undefined ) {

		viewZ = getViewZ( this );

	}

	return ( viewZ || positionView.z ).negate();

}

/**
 * Constructs a new range factor node.
 *
 * @param {Node} near - Defines the near value.
 * @param {Node} far - Defines the far value.
 */
const rangeFogFactor = Fn( ( [ near, far ], builder ) => {

	const viewZ = getViewZNode( builder );

	return smoothstep( near, far, viewZ );

} );

/**
 * Represents an exponential squared fog. This type of fog gives
 * a clear view near the camera and a faster than exponentially
 * densening fog farther from the camera.
 *
 * @param {Node} density - Defines the fog density.
 */
const densityFogFactor = Fn( ( [ density ], builder ) => {

	const viewZ = getViewZNode( builder );

	return density.mul( density, viewZ, viewZ ).negate().exp().oneMinus();

} );

/**
 * This class can be used to configure a fog for the scene.
 * Nodes of this type are assigned to `Scene.fogNode`.
 *
 * @param {Node} color - Defines the color of the fog.
 * @param {Node} factor - Defines how the fog is factored in the scene.
 */
const fog = Fn( ( [ color, factor ] ) => {

	return vec4( factor.toFloat().mix( output.rgb, color.toVec3() ), output.a );

} );

// Deprecated

function rangeFog( color, near, far ) { // @deprecated, r171

	console.warn( 'THREE.TSL: "rangeFog( color, near, far )" is deprecated. Use "fog( color, rangeFogFactor( near, far ) )" instead.' );
	return fog( color, rangeFogFactor( near, far ) );

}

function densityFog( color, density ) { // @deprecated, r171

	console.warn( 'THREE.TSL: "densityFog( color, density )" is deprecated. Use "fog( color, densityFogFactor( density ) )" instead.' );
	return fog( color, densityFogFactor( density ) );

}

/** @module RangeNode **/

let min = null;
let max = null;

/**
 * `RangeNode` generates random instanced attribute data in a defined range.
 * An exemplary use case for this utility node is to generate random per-instance
 * colors:
 * ```js
 * const material = new MeshBasicNodeMaterial();
 * material.colorNode = range( new Color( 0x000000 ), new Color( 0xFFFFFF ) );
 * const mesh = new InstancedMesh( geometry, material, count );
 * ```
 * @augments Node
 */
class RangeNode extends Node {

	static get type() {

		return 'RangeNode';

	}

	/**
	 * Constructs a new range node.
	 *
	 * @param {Node<any>} [minNode=float()] - A node defining the lower bound of the range.
	 * @param {Node<any>} [maxNode=float()] - A node defining the upper bound of the range.
	 */
	constructor( minNode = float(), maxNode = float() ) {

		super();

		/**
		 *  A node defining the lower bound of the range.
		 *
		 * @type {Node<any>}
		 * @default float()
		 */
		this.minNode = minNode;

		/**
		 *  A node defining the upper bound of the range.
		 *
		 * @type {Node<any>}
		 * @default float()
		 */
		this.maxNode = maxNode;

	}

	/**
	 * Returns the vector length which is computed based on the range definition.
	 *
	 * @param {NodeBuilder} builder - The current node builder.
	 * @return {Number} The vector length.
	 */
	getVectorLength( builder ) {

		const minLength = builder.getTypeLength( getValueType( this.minNode.value ) );
		const maxLength = builder.getTypeLength( getValueType( this.maxNode.value ) );

		return minLength > maxLength ? minLength : maxLength;

	}

	/**
	 * This method is overwritten since the node type is inferred from range definition.
	 *
	 * @param {NodeBuilder} builder - The current node builder.
	 * @return {String} The node type.
	 */
	getNodeType( builder ) {

		return builder.object.count > 1 ? builder.getTypeFromLength( this.getVectorLength( builder ) ) : 'float';

	}

	setup( builder ) {

		const object = builder.object;

		let output = null;

		if ( object.count > 1 ) {

			const minValue = this.minNode.value;
			const maxValue = this.maxNode.value;

			const minLength = builder.getTypeLength( getValueType( minValue ) );
			const maxLength = builder.getTypeLength( getValueType( maxValue ) );

			min = min || new Vector4();
			max = max || new Vector4();

			min.setScalar( 0 );
			max.setScalar( 0 );

			if ( minLength === 1 ) min.setScalar( minValue );
			else if ( minValue.isColor ) min.set( minValue.r, minValue.g, minValue.b, 1 );
			else min.set( minValue.x, minValue.y, minValue.z || 0, minValue.w || 0 );

			if ( maxLength === 1 ) max.setScalar( maxValue );
			else if ( maxValue.isColor ) max.set( maxValue.r, maxValue.g, maxValue.b, 1 );
			else max.set( maxValue.x, maxValue.y, maxValue.z || 0, maxValue.w || 0 );

			const stride = 4;

			const length = stride * object.count;
			const array = new Float32Array( length );

			for ( let i = 0; i < length; i ++ ) {

				const index = i % stride;

				const minElementValue = min.getComponent( index );
				const maxElementValue = max.getComponent( index );

				array[ i ] = MathUtils.lerp( minElementValue, maxElementValue, Math.random() );

			}

			const nodeType = this.getNodeType( builder );

			if ( object.count <= 4096 ) {

				output = buffer( array, 'vec4', object.count ).element( instanceIndex ).convert( nodeType );

			} else {

				// TODO: Improve anonymous buffer attribute creation removing this part
				const bufferAttribute = new InstancedBufferAttribute( array, 4 );
				builder.geometry.setAttribute( '__range' + this.id, bufferAttribute );

				output = instancedBufferAttribute( bufferAttribute ).convert( nodeType );

			}

		} else {

			output = float( 0 );

		}

		return output;

	}

}

/**
 * TSL function for creating a range node.
 *
 * @function
 * @param {Node<any>} [minNode=float()] - A node defining the lower bound of the range.
 * @param {Node<any>} [maxNode=float()] - A node defining the upper bound of the range.
 * @returns {RangeNode}
 */
const range = /*@__PURE__*/ nodeProxy( RangeNode );

class ComputeBuiltinNode extends Node {

	static get type() {

		return 'ComputeBuiltinNode';

	}

	constructor( builtinName, nodeType ) {

		super( nodeType );

		this._builtinName = builtinName;

	}

	getHash( builder ) {

		return this.getBuiltinName( builder );

	}

	getNodeType( /*builder*/ ) {

		return this.nodeType;

	}

	setBuiltinName( builtinName ) {

		this._builtinName = builtinName;

		return this;

	}

	getBuiltinName( /*builder*/ ) {

		return this._builtinName;

	}

	hasBuiltin( builder ) {

		builder.hasBuiltin( this._builtinName );

	}

	generate( builder, output ) {

		const builtinName = this.getBuiltinName( builder );
		const nodeType = this.getNodeType( builder );

		if ( builder.shaderStage === 'compute' ) {

			return builder.format( builtinName, nodeType, output );

		} else {

			console.warn( `ComputeBuiltinNode: Compute built-in value ${builtinName} can not be accessed in the ${builder.shaderStage} stage` );
			return builder.generateConst( nodeType );

		}

	}

	serialize( data ) {

		super.serialize( data );

		data.global = this.global;
		data._builtinName = this._builtinName;

	}

	deserialize( data ) {

		super.deserialize( data );

		this.global = data.global;
		this._builtinName = data._builtinName;

	}

}

const computeBuiltin = ( name, nodeType ) => nodeObject( new ComputeBuiltinNode( name, nodeType ) );

const numWorkgroups = /*@__PURE__*/ computeBuiltin( 'numWorkgroups', 'uvec3' );
const workgroupId = /*@__PURE__*/ computeBuiltin( 'workgroupId', 'uvec3' );
const localId = /*@__PURE__*/ computeBuiltin( 'localId', 'uvec3' );
const subgroupSize = /*@__PURE__*/ computeBuiltin( 'subgroupSize', 'uint' );

class BarrierNode extends Node {

	constructor( scope ) {

		super();

		this.scope = scope;

	}

	generate( builder ) {

		const { scope } = this;
		const { renderer } = builder;

		if ( renderer.backend.isWebGLBackend === true ) {

			builder.addFlowCode( `\t// ${scope}Barrier \n` );

		} else {

			builder.addLineFlowCode( `${scope}Barrier()`, this );

		}

	}

}

const barrier = nodeProxy( BarrierNode );

const workgroupBarrier = () => barrier( 'workgroup' ).append();
const storageBarrier = () => barrier( 'storage' ).append();
const textureBarrier = () => barrier( 'texture' ).append();

class WorkgroupInfoElementNode extends ArrayElementNode {

	constructor( workgroupInfoNode, indexNode ) {

		super( workgroupInfoNode, indexNode );

		this.isWorkgroupInfoElementNode = true;

	}

	generate( builder, output ) {

		let snippet;

		const isAssignContext = builder.context.assign;
		snippet = super.generate( builder );

		if ( isAssignContext !== true ) {

			const type = this.getNodeType( builder );

			snippet = builder.format( snippet, type, output );

		}

		// TODO: Possibly activate clip distance index on index access rather than from clipping context

		return snippet;

	}

}


class WorkgroupInfoNode extends Node {

	constructor( scope, bufferType, bufferCount = 0 ) {

		super( bufferType );

		this.bufferType = bufferType;
		this.bufferCount = bufferCount;

		this.isWorkgroupInfoNode = true;

		this.scope = scope;

	}

	label( name ) {

		this.name = name;

		return this;

	}

	getHash() {

		return this.uuid;

	}

	setScope( scope ) {

		this.scope = scope;

		return this;

	}

	getInputType( /*builder*/ ) {

		return `${this.scope}Array`;

	}

	element( indexNode ) {

		return nodeObject( new WorkgroupInfoElementNode( this, indexNode ) );

	}

	generate( builder ) {

		return builder.getScopedArray( this.name || `${this.scope}Array_${this.id}`, this.scope.toLowerCase(), this.bufferType, this.bufferCount );

	}

}

const workgroupArray = ( type, count ) => nodeObject( new WorkgroupInfoNode( 'Workgroup', type, count ) );

class AtomicFunctionNode extends TempNode {

	static get type() {

		return 'AtomicFunctionNode';

	}

	constructor( method, pointerNode, valueNode, storeNode = null ) {

		super( 'uint' );

		this.method = method;

		this.pointerNode = pointerNode;
		this.valueNode = valueNode;
		this.storeNode = storeNode;

	}

	getInputType( builder ) {

		return this.pointerNode.getNodeType( builder );

	}

	getNodeType( builder ) {

		return this.getInputType( builder );

	}

	generate( builder ) {

		const method = this.method;

		const type = this.getNodeType( builder );
		const inputType = this.getInputType( builder );

		const a = this.pointerNode;
		const b = this.valueNode;

		const params = [];

		params.push( `&${ a.build( builder, inputType ) }` );
		params.push( b.build( builder, inputType ) );

		const methodSnippet = `${ builder.getMethod( method, type ) }( ${params.join( ', ' )} )`;

		if ( this.storeNode !== null ) {

			const varSnippet = this.storeNode.build( builder, inputType );

			builder.addLineFlowCode( `${varSnippet} = ${methodSnippet}`, this );

		} else {

			builder.addLineFlowCode( methodSnippet, this );

		}

	}

}

AtomicFunctionNode.ATOMIC_LOAD = 'atomicLoad';
AtomicFunctionNode.ATOMIC_STORE = 'atomicStore';
AtomicFunctionNode.ATOMIC_ADD = 'atomicAdd';
AtomicFunctionNode.ATOMIC_SUB = 'atomicSub';
AtomicFunctionNode.ATOMIC_MAX = 'atomicMax';
AtomicFunctionNode.ATOMIC_MIN = 'atomicMin';
AtomicFunctionNode.ATOMIC_AND = 'atomicAnd';
AtomicFunctionNode.ATOMIC_OR = 'atomicOr';
AtomicFunctionNode.ATOMIC_XOR = 'atomicXor';

const atomicNode = nodeProxy( AtomicFunctionNode );

const atomicFunc = ( method, pointerNode, valueNode, storeNode ) => {

	const node = atomicNode( method, pointerNode, valueNode, storeNode );
	node.append();

	return node;

};

const atomicStore = ( pointerNode, valueNode, storeNode = null ) => atomicFunc( AtomicFunctionNode.ATOMIC_STORE, pointerNode, valueNode, storeNode );
const atomicAdd = ( pointerNode, valueNode, storeNode = null ) => atomicFunc( AtomicFunctionNode.ATOMIC_ADD, pointerNode, valueNode, storeNode );
const atomicSub = ( pointerNode, valueNode, storeNode = null ) => atomicFunc( AtomicFunctionNode.ATOMIC_SUB, pointerNode, valueNode, storeNode );
const atomicMax = ( pointerNode, valueNode, storeNode = null ) => atomicFunc( AtomicFunctionNode.ATOMIC_MAX, pointerNode, valueNode, storeNode );
const atomicMin = ( pointerNode, valueNode, storeNode = null ) => atomicFunc( AtomicFunctionNode.ATOMIC_MIN, pointerNode, valueNode, storeNode );
const atomicAnd = ( pointerNode, valueNode, storeNode = null ) => atomicFunc( AtomicFunctionNode.ATOMIC_AND, pointerNode, valueNode, storeNode );
const atomicOr = ( pointerNode, valueNode, storeNode = null ) => atomicFunc( AtomicFunctionNode.ATOMIC_OR, pointerNode, valueNode, storeNode );
const atomicXor = ( pointerNode, valueNode, storeNode = null ) => atomicFunc( AtomicFunctionNode.ATOMIC_XOR, pointerNode, valueNode, storeNode );

let uniformsLib;

function getLightData( light ) {

	uniformsLib = uniformsLib || new WeakMap();

	let uniforms = uniformsLib.get( light );

	if ( uniforms === undefined ) uniformsLib.set( light, uniforms = {} );

	return uniforms;

}

function lightShadowMatrix( light ) {

	const data = getLightData( light );

	return data.shadowMatrix || ( data.shadowMatrix = uniform( 'mat4' ).setGroup( renderGroup ).onRenderUpdate( () => {

		if ( light.castShadow !== true ) {

			light.shadow.updateMatrices( light );

		}

		return light.shadow.matrix;

	} ) );

}

function lightProjectionUV( light ) {

	const data = getLightData( light );

	if ( data.projectionUV === undefined ) {

		const spotLightCoord = lightShadowMatrix( light ).mul( positionWorld );

		data.projectionUV = spotLightCoord.xyz.div( spotLightCoord.w );


	}

	return data.projectionUV;

}

function lightPosition( light ) {

	const data = getLightData( light );

	return data.position || ( data.position = uniform( new Vector3() ).setGroup( renderGroup ).onRenderUpdate( ( _, self ) => self.value.setFromMatrixPosition( light.matrixWorld ) ) );

}

function lightTargetPosition( light ) {

	const data = getLightData( light );

	return data.targetPosition || ( data.targetPosition = uniform( new Vector3() ).setGroup( renderGroup ).onRenderUpdate( ( _, self ) => self.value.setFromMatrixPosition( light.target.matrixWorld ) ) );

}

function lightViewPosition( light ) {

	const data = getLightData( light );

	return data.viewPosition || ( data.viewPosition = uniform( new Vector3() ).setGroup( renderGroup ).onRenderUpdate( ( { camera }, self ) => {

		self.value = self.value || new Vector3();
		self.value.setFromMatrixPosition( light.matrixWorld );

		self.value.applyMatrix4( camera.matrixWorldInverse );

	} ) );

}

const lightTargetDirection = ( light ) => cameraViewMatrix.transformDirection( lightPosition( light ).sub( lightTargetPosition( light ) ) );

/** @module LightsNode **/

const sortLights = ( lights ) => {

	return lights.sort( ( a, b ) => a.id - b.id );

};

const getLightNodeById = ( id, lightNodes ) => {

	for ( const lightNode of lightNodes ) {

		if ( lightNode.isAnalyticLightNode && lightNode.light.id === id ) {

			return lightNode;

		}

	}

	return null;

};

const _lightsNodeRef = /*@__PURE__*/ new WeakMap();

/**
 * This node represents the scene's lighting and manages the lighting model's life cycle
 * for the current build 3D object. It is responsible for computing the total outgoing
 * light in a given lighting context.
 *
 * @augments Node
 */
class LightsNode extends Node {

	static get type() {

		return 'LightsNode';

	}

	/**
	 * Constructs a new lights node.
	 */
	constructor() {

		super( 'vec3' );

		/**
		 * A node representing the total diffuse light.
		 *
		 * @type {Node<vec3>}
		 */
		this.totalDiffuseNode = vec3().toVar( 'totalDiffuse' );

		/**
		 * A node representing the total specular light.
		 *
		 * @type {Node<vec3>}
		 */
		this.totalSpecularNode = vec3().toVar( 'totalSpecular' );

		/**
		 * A node representing the outgoing light.
		 *
		 * @type {Node<vec3>}
		 */
		this.outgoingLightNode = vec3().toVar( 'outgoingLight' );

		/**
		 * An array representing the lights in the scene.
		 *
		 * @private
		 * @type {Array<Light>}
		 */
		this._lights = [];

		/**
		 * For each light in the scene, this node will create a
		 * corresponding light node.
		 *
		 * @private
		 * @type {Array<LightingNode>?}
		 * @default null
		 */
		this._lightNodes = null;

		/**
		 * A hash for identifying the current light nodes setup.
		 *
		 * @private
		 * @type {String?}
		 * @default null
		 */
		this._lightNodesHash = null;

		/**
		 * `LightsNode` sets this property to `true` by default.
		 *
		 * @type {Boolean}
		 * @default true
		 */
		this.global = true;

	}

	/**
	 * Overwrites the default {@link Node#customCacheKey} implementation by including the
	 * light IDs into the cache key.
	 *
	 * @return {Number} The custom cache key.
	 */
	customCacheKey() {

		const lightIDs = [];

		for ( let i = 0; i < lights.length; i ++ ) {

			lightIDs.push( lights[ i ].id );

		}

		return hashArray( lightIDs );

	}

	/**
	 * Computes a hash value for identifying the current light nodes setup.
	 *
	 * @param {NodeBuilder} builder - A reference to the current node builder.
	 * @return {String} The computed hash.
	 */
	getHash( builder ) {

		if ( this._lightNodesHash === null ) {

			if ( this._lightNodes === null ) this.setupLightsNode( builder );

			const hash = [];

			for ( const lightNode of this._lightNodes ) {

				hash.push( lightNode.getSelf().getHash() );

			}

			this._lightNodesHash = 'lights-' + hash.join( ',' );

		}

		return this._lightNodesHash;

	}

	analyze( builder ) {

		const properties = builder.getDataFromNode( this );

		for ( const node of properties.nodes ) {

			node.build( builder );

		}

	}

	/**
	 * Creates lighting nodes for each scene light. This makes it possible to further
	 * process lights in the node system.
	 *
	 * @param {NodeBuilder} builder - A reference to the current node builder.
	 */
	setupLightsNode( builder ) {

		const lightNodes = [];

		const previousLightNodes = this._lightNodes;

		const lights = sortLights( this._lights );
		const nodeLibrary = builder.renderer.library;

		for ( const light of lights ) {

			if ( light.isNode ) {

				lightNodes.push( nodeObject( light ) );

			} else {

				let lightNode = null;

				if ( previousLightNodes !== null ) {

					lightNode = getLightNodeById( light.id, previousLightNodes ); // reuse existing light node

				}

				if ( lightNode === null ) {

					// find the corresponding node type for a given light

					const lightNodeClass = nodeLibrary.getLightNodeClass( light.constructor );

					if ( lightNodeClass === null ) {

						console.warn( `LightsNode.setupNodeLights: Light node not found for ${ light.constructor.name }` );
						continue;

					}

					let lightNode = null;

					if ( ! _lightsNodeRef.has( light ) ) {

						lightNode = nodeObject( new lightNodeClass( light ) );
						_lightsNodeRef.set( light, lightNode );

					} else {

						lightNode = _lightsNodeRef.get( light );

					}

					lightNodes.push( lightNode );

				}

			}

		}

		this._lightNodes = lightNodes;

	}

	/**
	 * Setups the internal lights by building all respective
	 * light nodes.
	 *
	 * @param {NodeBuilder} builder - A reference to the current node builder.
	 * @param {Array<LightingNode>} lightNodes - An array of lighting nodes.
	 */
	setupLights( builder, lightNodes ) {

		for ( const lightNode of lightNodes ) {

			lightNode.build( builder );

		}

	}

	/**
	 * The implementation makes sure that for each light in the scene
	 * there is a corresponding light node. By building the light nodes
	 * and evaluating the lighting model the outgoing light is computed.
	 *
	 * @param {NodeBuilder} builder - A reference to the current node builder.
	 * @return {Node<vec3>} A node representing the outgoing light.
	 */
	setup( builder ) {

		if ( this._lightNodes === null ) this.setupLightsNode( builder );

		const context = builder.context;
		const lightingModel = context.lightingModel;

		let outgoingLightNode = this.outgoingLightNode;

		if ( lightingModel ) {

			const { _lightNodes, totalDiffuseNode, totalSpecularNode } = this;

			context.outgoingLight = outgoingLightNode;

			const stack = builder.addStack();

			//

			const properties = builder.getDataFromNode( this );
			properties.nodes = stack.nodes;

			//

			lightingModel.start( context, stack, builder );

			// lights

			this.setupLights( builder, _lightNodes );

			//

			lightingModel.indirect( context, stack, builder );

			//

			const { backdrop, backdropAlpha } = context;
			const { directDiffuse, directSpecular, indirectDiffuse, indirectSpecular } = context.reflectedLight;

			let totalDiffuse = directDiffuse.add( indirectDiffuse );

			if ( backdrop !== null ) {

				if ( backdropAlpha !== null ) {

					totalDiffuse = vec3( backdropAlpha.mix( totalDiffuse, backdrop ) );

				} else {

					totalDiffuse = vec3( backdrop );

				}

				context.material.transparent = true;

			}

			totalDiffuseNode.assign( totalDiffuse );
			totalSpecularNode.assign( directSpecular.add( indirectSpecular ) );

			outgoingLightNode.assign( totalDiffuseNode.add( totalSpecularNode ) );

			//

			lightingModel.finish( context, stack, builder );

			//

			outgoingLightNode = outgoingLightNode.bypass( builder.removeStack() );

		}

		return outgoingLightNode;

	}

	/**
	 * Configures this node with an array of lights.
	 *
	 * @param {Array<Light>} lights - An array of lights.
	 * @return {LightsNode} A reference to this node.
	 */
	setLights( lights ) {

		this._lights = lights;

		this._lightNodes = null;
		this._lightNodesHash = null;

		return this;

	}

	/**
	 * Returns an array of the scene's lights.
	 *
	 * @return {Array<Light>} The scene's lights.
	 */
	getLights() {

		return this._lights;

	}

	/**
	 * Whether the scene has lights or not.
	 *
	 * @type {Boolean}
	 */
	get hasLights() {

		return this._lights.length > 0;

	}

}

/**
 * TSL function for creating an instance of `LightsNode` and configuring
 * it with the given array of lights.
 *
 * @function
 * @param {Array<Light>} lights - An array of lights.
 * @return {LightsNode} The created lights node.
 */
const lights = ( lights = [] ) => nodeObject( new LightsNode() ).setLights( lights );

/** @module ShadowBaseNode **/

/**
 * Base class for all shadow nodes.
 *
 * Shadow nodes encapsulate shadow related logic and are always coupled to lighting nodes.
 * Lighting nodes might share the same shadow node type or use specific ones depending on
 * their requirements.
 *
 * @augments Node
 */
class ShadowBaseNode extends Node {

	static get type() {

		return 'ShadowBaseNode';

	}

	/**
	 * Constructs a new shadow base node.
	 *
	 * @param {Light} light - The shadow casting light.
	 */
	constructor( light ) {

		super();

		/**
		 * The shadow casting light.
		 *
		 * @type {Light}
		 */
		this.light = light;

		/**
		 * Overwritten since shadows are updated by default per render.
		 *
		 * @type {String}
		 * @default 'render'
		 */
		this.updateBeforeType = NodeUpdateType.RENDER;

		/**
		 * This flag can be used for type testing.
		 *
		 * @type {Boolean}
		 * @readonly
		 * @default true
		 */
		this.isShadowBaseNode = true;

	}

	/**
	 * Setups the shadow position node which is by default the predefined TSL node object `shadowWorldPosition`.
	 *
	 * @param {(NodeBuilder|{Material})} object - A configuration object that must at least hold a material reference.
	 */
	setupShadowPosition( { material } ) {

		// Use assign inside an Fn()

		shadowWorldPosition.assign( material.shadowPositionNode || positionWorld );

	}

	/**
	 * Can be called when the shadow isn't required anymore. That can happen when
	 * a lighting node stops casting shadows by setting {@link Object3D#castShadow}
	 * to `false`.
	 */
	dispose() {

		this.updateBeforeType = NodeUpdateType.NONE;

	}

}

/**
 * TSL object that represents the vertex position in world space during the shadow pass.
 *
 * @type {Node<vec3>}
 */
const shadowWorldPosition = /*@__PURE__*/ vec3().toVar( 'shadowWorldPosition' );

/** @module ShadowNode **/

const shadowMaterialLib = /*@__PURE__*/ new WeakMap();
const linearDistance = /*@__PURE__*/ Fn( ( [ position, cameraNear, cameraFar ] ) => {

	let dist = positionWorld.sub( position ).length();
	dist = dist.sub( cameraNear ).div( cameraFar.sub( cameraNear ) );
	dist = dist.saturate(); // clamp to [ 0, 1 ]

	return dist;

} );

const linearShadowDistance = ( light ) => {

	const camera = light.shadow.camera;

	const nearDistance = reference( 'near', 'float', camera ).setGroup( renderGroup );
	const farDistance = reference( 'far', 'float', camera ).setGroup( renderGroup );

	const referencePosition = objectPosition( light );

	return linearDistance( referencePosition, nearDistance, farDistance );

};

const getShadowMaterial = ( light ) => {

	let material = shadowMaterialLib.get( light );

	if ( material === undefined ) {

		const depthNode = light.isPointLight ? linearShadowDistance( light ) : null;

		material = new NodeMaterial();
		material.colorNode = vec4( 0, 0, 0, 1 );
		material.depthNode = depthNode;
		material.isShadowNodeMaterial = true; // Use to avoid other overrideMaterial override material.colorNode unintentionally when using material.shadowNode
		material.name = 'ShadowMaterial';

		shadowMaterialLib.set( light, material );

	}

	return material;

};

/**
 * A shadow filtering function performing basic filtering. This is in fact an unfiltered version of the shadow map
 * with a binary `[0,1]` result.
 *
 * @method
 * @param {Object} inputs - The input parameter object.
 * @param {DepthTexture} inputs.depthTexture - A reference to the shadow map's texture data.
 * @param {Node<vec3>} inputs.shadowCoord - The shadow coordinates.
 * @return {Node<float>} The filtering result.
 */
const BasicShadowFilter = /*@__PURE__*/ Fn( ( { depthTexture, shadowCoord } ) => {

	return texture( depthTexture, shadowCoord.xy ).compare( shadowCoord.z );

} );

/**
 * A shadow filtering function performing PCF filtering.
 *
 * @method
 * @param {Object} inputs - The input parameter object.
 * @param {DepthTexture} inputs.depthTexture - A reference to the shadow map's texture data.
 * @param {Node<vec3>} inputs.shadowCoord - The shadow coordinates.
 * @param {LightShadow} inputs.shadow - The light shadow.
 * @return {Node<float>} The filtering result.
 */
const PCFShadowFilter = /*@__PURE__*/ Fn( ( { depthTexture, shadowCoord, shadow } ) => {

	const depthCompare = ( uv, compare ) => texture( depthTexture, uv ).compare( compare );

	const mapSize = reference( 'mapSize', 'vec2', shadow ).setGroup( renderGroup );
	const radius = reference( 'radius', 'float', shadow ).setGroup( renderGroup );

	const texelSize = vec2( 1 ).div( mapSize );
	const dx0 = texelSize.x.negate().mul( radius );
	const dy0 = texelSize.y.negate().mul( radius );
	const dx1 = texelSize.x.mul( radius );
	const dy1 = texelSize.y.mul( radius );
	const dx2 = dx0.div( 2 );
	const dy2 = dy0.div( 2 );
	const dx3 = dx1.div( 2 );
	const dy3 = dy1.div( 2 );

	return add(
		depthCompare( shadowCoord.xy.add( vec2( dx0, dy0 ) ), shadowCoord.z ),
		depthCompare( shadowCoord.xy.add( vec2( 0, dy0 ) ), shadowCoord.z ),
		depthCompare( shadowCoord.xy.add( vec2( dx1, dy0 ) ), shadowCoord.z ),
		depthCompare( shadowCoord.xy.add( vec2( dx2, dy2 ) ), shadowCoord.z ),
		depthCompare( shadowCoord.xy.add( vec2( 0, dy2 ) ), shadowCoord.z ),
		depthCompare( shadowCoord.xy.add( vec2( dx3, dy2 ) ), shadowCoord.z ),
		depthCompare( shadowCoord.xy.add( vec2( dx0, 0 ) ), shadowCoord.z ),
		depthCompare( shadowCoord.xy.add( vec2( dx2, 0 ) ), shadowCoord.z ),
		depthCompare( shadowCoord.xy, shadowCoord.z ),
		depthCompare( shadowCoord.xy.add( vec2( dx3, 0 ) ), shadowCoord.z ),
		depthCompare( shadowCoord.xy.add( vec2( dx1, 0 ) ), shadowCoord.z ),
		depthCompare( shadowCoord.xy.add( vec2( dx2, dy3 ) ), shadowCoord.z ),
		depthCompare( shadowCoord.xy.add( vec2( 0, dy3 ) ), shadowCoord.z ),
		depthCompare( shadowCoord.xy.add( vec2( dx3, dy3 ) ), shadowCoord.z ),
		depthCompare( shadowCoord.xy.add( vec2( dx0, dy1 ) ), shadowCoord.z ),
		depthCompare( shadowCoord.xy.add( vec2( 0, dy1 ) ), shadowCoord.z ),
		depthCompare( shadowCoord.xy.add( vec2( dx1, dy1 ) ), shadowCoord.z )
	).mul( 1 / 17 );

} );

/**
 * A shadow filtering function performing PCF soft filtering.
 *
 * @method
 * @param {Object} inputs - The input parameter object.
 * @param {DepthTexture} inputs.depthTexture - A reference to the shadow map's texture data.
 * @param {Node<vec3>} inputs.shadowCoord - The shadow coordinates.
 * @param {LightShadow} inputs.shadow - The light shadow.
 * @return {Node<float>} The filtering result.
 */
const PCFSoftShadowFilter = /*@__PURE__*/ Fn( ( { depthTexture, shadowCoord, shadow } ) => {

	const depthCompare = ( uv, compare ) => texture( depthTexture, uv ).compare( compare );

	const mapSize = reference( 'mapSize', 'vec2', shadow ).setGroup( renderGroup );

	const texelSize = vec2( 1 ).div( mapSize );
	const dx = texelSize.x;
	const dy = texelSize.y;

	const uv = shadowCoord.xy;
	const f = fract( uv.mul( mapSize ).add( 0.5 ) );
	uv.subAssign( f.mul( texelSize ) );

	return add(
		depthCompare( uv, shadowCoord.z ),
		depthCompare( uv.add( vec2( dx, 0 ) ), shadowCoord.z ),
		depthCompare( uv.add( vec2( 0, dy ) ), shadowCoord.z ),
		depthCompare( uv.add( texelSize ), shadowCoord.z ),
		mix(
			depthCompare( uv.add( vec2( dx.negate(), 0 ) ), shadowCoord.z ),
			depthCompare( uv.add( vec2( dx.mul( 2 ), 0 ) ), shadowCoord.z ),
			f.x
		),
		mix(
			depthCompare( uv.add( vec2( dx.negate(), dy ) ), shadowCoord.z ),
			depthCompare( uv.add( vec2( dx.mul( 2 ), dy ) ), shadowCoord.z ),
			f.x
		),
		mix(
			depthCompare( uv.add( vec2( 0, dy.negate() ) ), shadowCoord.z ),
			depthCompare( uv.add( vec2( 0, dy.mul( 2 ) ) ), shadowCoord.z ),
			f.y
		),
		mix(
			depthCompare( uv.add( vec2( dx, dy.negate() ) ), shadowCoord.z ),
			depthCompare( uv.add( vec2( dx, dy.mul( 2 ) ) ), shadowCoord.z ),
			f.y
		),
		mix(
			mix(
				depthCompare( uv.add( vec2( dx.negate(), dy.negate() ) ), shadowCoord.z ),
				depthCompare( uv.add( vec2( dx.mul( 2 ), dy.negate() ) ), shadowCoord.z ),
				f.x
			),
			mix(
				depthCompare( uv.add( vec2( dx.negate(), dy.mul( 2 ) ) ), shadowCoord.z ),
				depthCompare( uv.add( vec2( dx.mul( 2 ), dy.mul( 2 ) ) ), shadowCoord.z ),
				f.x
			),
			f.y
		)
	).mul( 1 / 9 );

} );

/**
 * A shadow filtering function performing VSM filtering.
 *
 * @method
 * @param {Object} inputs - The input parameter object.
 * @param {DepthTexture} inputs.depthTexture - A reference to the shadow map's texture data.
 * @param {Node<vec3>} inputs.shadowCoord - The shadow coordinates.
 * @return {Node<float>} The filtering result.
 */
const VSMShadowFilter = /*@__PURE__*/ Fn( ( { depthTexture, shadowCoord } ) => {

	const occlusion = float( 1 ).toVar();

	const distribution = texture( depthTexture ).sample( shadowCoord.xy ).rg;

	const hardShadow = step( shadowCoord.z, distribution.x );

	If( hardShadow.notEqual( float( 1.0 ) ), () => {

		const distance = shadowCoord.z.sub( distribution.x );
		const variance = max$1( 0, distribution.y.mul( distribution.y ) );
		let softnessProbability = variance.div( variance.add( distance.mul( distance ) ) ); // Chebeyshevs inequality
		softnessProbability = clamp( sub( softnessProbability, 0.3 ).div( 0.95 - 0.3 ) );
		occlusion.assign( clamp( max$1( hardShadow, softnessProbability ) ) );

	} );

	return occlusion;

} );

/**
 * Represents the shader code for the first VSM render pass.
 *
 * @method
 * @param {Object} inputs - The input parameter object.
 * @param {Node<float>} inputs.samples - The number of samples
 * @param {Node<float>} inputs.radius - The radius.
 * @param {Node<float>} inputs.size - The size.
 * @param {TextureNode} inputs.shadowPass - A reference to the render target's depth data.
 * @return {Node<vec2>} The VSM output.
 */
const VSMPassVertical = /*@__PURE__*/ Fn( ( { samples, radius, size, shadowPass } ) => {

	const mean = float( 0 ).toVar();
	const squaredMean = float( 0 ).toVar();

	const uvStride = samples.lessThanEqual( float( 1 ) ).select( float( 0 ), float( 2 ).div( samples.sub( 1 ) ) );
	const uvStart = samples.lessThanEqual( float( 1 ) ).select( float( 0 ), float( - 1 ) );

	Loop( { start: int( 0 ), end: int( samples ), type: 'int', condition: '<' }, ( { i } ) => {

		const uvOffset = uvStart.add( float( i ).mul( uvStride ) );

		const depth = shadowPass.sample( add( screenCoordinate.xy, vec2( 0, uvOffset ).mul( radius ) ).div( size ) ).x;
		mean.addAssign( depth );
		squaredMean.addAssign( depth.mul( depth ) );

	} );

	mean.divAssign( samples );
	squaredMean.divAssign( samples );

	const std_dev = sqrt( squaredMean.sub( mean.mul( mean ) ) );
	return vec2( mean, std_dev );

} );

/**
 * Represents the shader code for the second VSM render pass.
 *
 * @method
 * @param {Object} inputs - The input parameter object.
 * @param {Node<float>} inputs.samples - The number of samples
 * @param {Node<float>} inputs.radius - The radius.
 * @param {Node<float>} inputs.size - The size.
 * @param {TextureNode} inputs.shadowPass - The result of the first VSM render pass.
 * @return {Node<vec2>} The VSM output.
 */
const VSMPassHorizontal = /*@__PURE__*/ Fn( ( { samples, radius, size, shadowPass } ) => {

	const mean = float( 0 ).toVar();
	const squaredMean = float( 0 ).toVar();

	const uvStride = samples.lessThanEqual( float( 1 ) ).select( float( 0 ), float( 2 ).div( samples.sub( 1 ) ) );
	const uvStart = samples.lessThanEqual( float( 1 ) ).select( float( 0 ), float( - 1 ) );

	Loop( { start: int( 0 ), end: int( samples ), type: 'int', condition: '<' }, ( { i } ) => {

		const uvOffset = uvStart.add( float( i ).mul( uvStride ) );

		const distribution = shadowPass.sample( add( screenCoordinate.xy, vec2( uvOffset, 0 ).mul( radius ) ).div( size ) );
		mean.addAssign( distribution.x );
		squaredMean.addAssign( add( distribution.y.mul( distribution.y ), distribution.x.mul( distribution.x ) ) );

	} );

	mean.divAssign( samples );
	squaredMean.divAssign( samples );

	const std_dev = sqrt( squaredMean.sub( mean.mul( mean ) ) );
	return vec2( mean, std_dev );

} );

const _shadowFilterLib = [ BasicShadowFilter, PCFShadowFilter, PCFSoftShadowFilter, VSMShadowFilter ];

//

const _quadMesh$1 = /*@__PURE__*/ new QuadMesh();

/**
 * Represents the default shadow implementation for lighting nodes.
 *
 * @augments module:ShadowBaseNode~ShadowBaseNode
 */
class ShadowNode extends ShadowBaseNode {

	static get type() {

		return 'ShadowNode';

	}

	/**
	 * Constructs a new shadow node.
	 *
	 * @param {Light} light - The shadow casting light.
	 * @param {LightShadow?} [shadow=null] - An optional light shadow.
	 */
	constructor( light, shadow = null ) {

		super( light );

		/**
		 * The light shadow which defines the properties light's
		 * shadow.
		 *
		 * @type {LightShadow?}
		 * @default null
		 */
		this.shadow = shadow || light.shadow;

		/**
		 * A reference to the shadow map which is a render target.
		 *
		 * @type {RenderTarget?}
		 * @default null
		 */
		this.shadowMap = null;

		/**
		 * Only relevant for VSM shadows. Render target for the
		 * first VSM render pass.
		 *
		 * @type {RenderTarget?}
		 * @default null
		 */
		this.vsmShadowMapVertical = null;

		/**
		 * Only relevant for VSM shadows. Render target for the
		 * second VSM render pass.
		 *
		 * @type {RenderTarget?}
		 * @default null
		 */
		this.vsmShadowMapHorizontal = null;

		/**
		 * Only relevant for VSM shadows. Node material which
		 * is used to render the first VSM pass.
		 *
		 * @type {NodeMaterial?}
		 * @default null
		 */
		this.vsmMaterialVertical = null;

		/**
		 * Only relevant for VSM shadows. Node material which
		 * is used to render the second VSM pass.
		 *
		 * @type {NodeMaterial?}
		 * @default null
		 */
		this.vsmMaterialHorizontal = null;

		/**
		 * A reference to the output node which defines the
		 * final result of this shadow node.
		 *
		 * @type {Node?}
		 * @private
		 * @default null
		 */
		this._node = null;

		/**
		 * This flag can be used for type testing.
		 *
		 * @type {Boolean}
		 * @readonly
		 * @default true
		 */
		this.isShadowNode = true;

	}

	/**
	 * Setups the shadow filtering.
	 *
	 * @param {NodeBuilder} builder - A reference to the current node builder.
	 * @param {Object} inputs - A configuration object that defines the shadow filtering.
	 * @param {Function} inputs.filterFn - This function defines the filtering type of the shadow map e.g. PCF.
	 * @param {DepthTexture} inputs.depthTexture - A reference to the shadow map's texture data.
	 * @param {Node<vec3>} inputs.shadowCoord - Shadow coordinates which are used to sample from the shadow map.
	 * @param {LightShadow} inputs.shadow - The light shadow.
	 * @return {Node<float>} The result node of the shadow filtering.
	 */
	setupShadowFilter( builder, { filterFn, depthTexture, shadowCoord, shadow } ) {

		const frustumTest = shadowCoord.x.greaterThanEqual( 0 )
			.and( shadowCoord.x.lessThanEqual( 1 ) )
			.and( shadowCoord.y.greaterThanEqual( 0 ) )
			.and( shadowCoord.y.lessThanEqual( 1 ) )
			.and( shadowCoord.z.lessThanEqual( 1 ) );

		const shadowNode = filterFn( { depthTexture, shadowCoord, shadow } );

		return frustumTest.select( shadowNode, float( 1 ) );

	}

	/**
	 * Setups the shadow coordinates.
	 *
	 * @param {NodeBuilder} builder - A reference to the current node builder.
	 * @param {Node<vec3>} shadowPosition - A node representing the shadow position.
	 * @return {Node<vec3>} The shadow coordinates.
	 */
	setupShadowCoord( builder, shadowPosition ) {

		const { shadow } = this;
		const { renderer } = builder;

		const bias = reference( 'bias', 'float', shadow ).setGroup( renderGroup );

		let shadowCoord = shadowPosition;
		let coordZ;

		if ( shadow.camera.isOrthographicCamera || renderer.logarithmicDepthBuffer !== true ) {

			shadowCoord = shadowCoord.xyz.div( shadowCoord.w );

			coordZ = shadowCoord.z;

			if ( renderer.coordinateSystem === WebGPUCoordinateSystem ) {

				coordZ = coordZ.mul( 2 ).sub( 1 ); // WebGPU: Conversion [ 0, 1 ] to [ - 1, 1 ]

			}

		} else {

			const w = shadowCoord.w;
			shadowCoord = shadowCoord.xy.div( w ); // <-- Only divide X/Y coords since we don't need Z

			// The normally available "cameraNear" and "cameraFar" nodes cannot be used here because they do not get
			// updated to use the shadow camera. So, we have to declare our own "local" ones here.
			// TODO: How do we get the cameraNear/cameraFar nodes to use the shadow camera so we don't have to declare local ones here?
			const cameraNearLocal = reference( 'near', 'float', shadow.camera ).setGroup( renderGroup );
			const cameraFarLocal = reference( 'far', 'float', shadow.camera ).setGroup( renderGroup );

			coordZ = viewZToLogarithmicDepth( w.negate(), cameraNearLocal, cameraFarLocal );

		}

		shadowCoord = vec3(
			shadowCoord.x,
			shadowCoord.y.oneMinus(), // follow webgpu standards
			coordZ.add( bias )
		);

		return shadowCoord;

	}

	/**
	 * Returns the shadow filtering function for the given shadow type.
	 *
	 * @param {Number} type - The shadow type.
	 * @return {Function} The filtering function.
	 */
	getShadowFilterFn( type ) {

		return _shadowFilterLib[ type ];

	}

	/**
	 * Setups the shadow output node.
	 *
	 * @param {NodeBuilder} builder - A reference to the current node builder.
	 * @return {Node<vec3>} The shadow output node.
	 */
	setupShadow( builder ) {

		const { renderer } = builder;

		const { light, shadow } = this;

		const shadowMapType = renderer.shadowMap.type;

		const depthTexture = new DepthTexture( shadow.mapSize.width, shadow.mapSize.height );
		depthTexture.compareFunction = LessCompare;

		const shadowMap = builder.createRenderTarget( shadow.mapSize.width, shadow.mapSize.height );
		shadowMap.depthTexture = depthTexture;

		shadow.camera.updateProjectionMatrix();

		// VSM

		if ( shadowMapType === VSMShadowMap ) {

			depthTexture.compareFunction = null; // VSM does not use textureSampleCompare()/texture2DCompare()

			this.vsmShadowMapVertical = builder.createRenderTarget( shadow.mapSize.width, shadow.mapSize.height, { format: RGFormat, type: HalfFloatType } );
			this.vsmShadowMapHorizontal = builder.createRenderTarget( shadow.mapSize.width, shadow.mapSize.height, { format: RGFormat, type: HalfFloatType } );

			const shadowPassVertical = texture( depthTexture );
			const shadowPassHorizontal = texture( this.vsmShadowMapVertical.texture );

			const samples = reference( 'blurSamples', 'float', shadow ).setGroup( renderGroup );
			const radius = reference( 'radius', 'float', shadow ).setGroup( renderGroup );
			const size = reference( 'mapSize', 'vec2', shadow ).setGroup( renderGroup );

			let material = this.vsmMaterialVertical || ( this.vsmMaterialVertical = new NodeMaterial() );
			material.fragmentNode = VSMPassVertical( { samples, radius, size, shadowPass: shadowPassVertical } ).context( builder.getSharedContext() );
			material.name = 'VSMVertical';

			material = this.vsmMaterialHorizontal || ( this.vsmMaterialHorizontal = new NodeMaterial() );
			material.fragmentNode = VSMPassHorizontal( { samples, radius, size, shadowPass: shadowPassHorizontal } ).context( builder.getSharedContext() );
			material.name = 'VSMHorizontal';

		}

		//

		const shadowIntensity = reference( 'intensity', 'float', shadow ).setGroup( renderGroup );
		const normalBias = reference( 'normalBias', 'float', shadow ).setGroup( renderGroup );

		const shadowPosition = lightShadowMatrix( light ).mul( shadowWorldPosition.add( transformedNormalWorld.mul( normalBias ) ) );
		const shadowCoord = this.setupShadowCoord( builder, shadowPosition );

		//

		const filterFn = shadow.filterNode || this.getShadowFilterFn( renderer.shadowMap.type ) || null;

		if ( filterFn === null ) {

			throw new Error( 'THREE.WebGPURenderer: Shadow map type not supported yet.' );

		}

		const shadowDepthTexture = ( shadowMapType === VSMShadowMap ) ? this.vsmShadowMapHorizontal.texture : depthTexture;

		const shadowNode = this.setupShadowFilter( builder, { filterFn, shadowTexture: shadowMap.texture, depthTexture: shadowDepthTexture, shadowCoord, shadow } );

		const shadowColor = texture( shadowMap.texture, shadowCoord );
		const shadowOutput = mix( 1, shadowNode.rgb.mix( shadowColor, 1 ), shadowIntensity.mul( shadowColor.a ) ).toVar();

		this.shadowMap = shadowMap;
		this.shadow.map = shadowMap;

		return shadowOutput;

	}

	/**
	 * The implementation performs the setup of the output node. An output is only
	 * produces if shadow mapping is globally enabled in the renderer.
	 *
	 * @param {NodeBuilder} builder - A reference to the current node builder.
	 * @return {ShaderCallNodeInternal} The output node.
	 */
	setup( builder ) {

		if ( builder.renderer.shadowMap.enabled === false ) return;

		return Fn( () => {

			let node = this._node;

			this.setupShadowPosition( builder );

			if ( node === null ) {

				this._node = node = this.setupShadow( builder );

			}

			if ( builder.material.shadowNode ) { // @deprecated, r171

				console.warn( 'THREE.NodeMaterial: ".shadowNode" is deprecated. Use ".castShadowNode" instead.' );

			}

			if ( builder.material.receivedShadowNode ) {

				node = builder.material.receivedShadowNode( node );

			}

			return node;

		} )();

	}

	/**
	 * Renders the shadow. The logic of this function could be included
	 * into {@link ShadowNode#updateShadow} however more specialized shadow
	 * nodes might require a custom shadow map rendering. By having a
	 * dedicated method, it's easier to overwrite the default behavior.
	 *
	 * @param {NodeFrame} frame - A reference to the current node frame.
	 */
	renderShadow( frame ) {

		const { shadow, shadowMap, light } = this;
		const { renderer, scene } = frame;

		shadow.updateMatrices( light );

		shadowMap.setSize( shadow.mapSize.width, shadow.mapSize.height );

		renderer.render( scene, shadow.camera );

	}

	/**
	 * Updates the shadow.
	 *
	 * @param {NodeFrme} frame - A reference to the current node frame.
	 */
	updateShadow( frame ) {

		const { shadowMap, light, shadow } = this;
		const { renderer, scene, camera } = frame;

		const shadowType = renderer.shadowMap.type;

		const depthVersion = shadowMap.depthTexture.version;
		this._depthVersionCached = depthVersion;

		const currentOverrideMaterial = scene.overrideMaterial;

		scene.overrideMaterial = getShadowMaterial( light );

		shadow.camera.layers.mask = camera.layers.mask;

		const currentRenderTarget = renderer.getRenderTarget();
		const currentRenderObjectFunction = renderer.getRenderObjectFunction();
		const currentMRT = renderer.getMRT();

		renderer.setMRT( null );

		renderer.setRenderObjectFunction( ( object, scene, _camera, geometry, material, group, ...params ) => {

			if ( object.castShadow === true || ( object.receiveShadow && shadowType === VSMShadowMap ) ) {

				object.onBeforeShadow( renderer, object, camera, shadow.camera, geometry, scene.overrideMaterial, group );

				renderer.renderObject( object, scene, _camera, geometry, material, group, ...params );

				object.onAfterShadow( renderer, object, camera, shadow.camera, geometry, scene.overrideMaterial, group );

			}

		} );

		renderer.setRenderTarget( shadowMap );

		this.renderShadow( frame );

		renderer.setRenderObjectFunction( currentRenderObjectFunction );

		// vsm blur pass

		if ( light.isPointLight !== true && shadowType === VSMShadowMap ) {

			this.vsmPass( renderer );

		}

		renderer.setRenderTarget( currentRenderTarget );

		renderer.setMRT( currentMRT );

		scene.overrideMaterial = currentOverrideMaterial;

	}

	/**
	 * For VSM additional render passes are required.
	 *
	 * @param {Renderer} renderer - A reference to the current renderer.
	 */
	vsmPass( renderer ) {

		const { shadow } = this;

		this.vsmShadowMapVertical.setSize( shadow.mapSize.width, shadow.mapSize.height );
		this.vsmShadowMapHorizontal.setSize( shadow.mapSize.width, shadow.mapSize.height );

		renderer.setRenderTarget( this.vsmShadowMapVertical );
		_quadMesh$1.material = this.vsmMaterialVertical;
		_quadMesh$1.render( renderer );

		renderer.setRenderTarget( this.vsmShadowMapHorizontal );
		_quadMesh$1.material = this.vsmMaterialHorizontal;
		_quadMesh$1.render( renderer );

	}

	/**
	 * Frees the internal resources of this shadow node.
	 */
	dispose() {

		this.shadowMap.dispose();
		this.shadowMap = null;

		if ( this.vsmShadowMapVertical !== null ) {

			this.vsmShadowMapVertical.dispose();
			this.vsmShadowMapVertical = null;

			this.vsmMaterialVertical.dispose();
			this.vsmMaterialVertical = null;

		}

		if ( this.vsmShadowMapHorizontal !== null ) {

			this.vsmShadowMapHorizontal.dispose();
			this.vsmShadowMapHorizontal = null;

			this.vsmMaterialHorizontal.dispose();
			this.vsmMaterialHorizontal = null;

		}

		super.dispose();

	}

	/**
	 * The implementation performs the update of the shadow map if necessary.
	 *
	 * @param {NodeFrame} frame - A reference to the current node frame.
	 */
	updateBefore( frame ) {

		const { shadow } = this;

		const needsUpdate = shadow.needsUpdate || shadow.autoUpdate;

		if ( needsUpdate ) {

			this.updateShadow( frame );

			if ( this.shadowMap.depthTexture.version === this._depthVersionCached ) {

				shadow.needsUpdate = false;

			}

		}

	}

}

/**
 * TSL function for creating an instance of `ShadowNode`.
 *
 * @function
 * @param {Light} light - The shadow casting light.
 * @param {LightShadow} shadow - The light shadow.
 * @return {ShadowNode} The created shadow node.
 */
const shadow = ( light, shadow ) => nodeObject( new ShadowNode( light, shadow ) );

/**
 * Base class for analytic light nodes.
 *
 * @augments LightingNode
 */
class AnalyticLightNode extends LightingNode {

	static get type() {

		return 'AnalyticLightNode';

	}

	/**
	 * Constructs a new analytic light node.
	 *
	 * @param {Light?} [light=null] - The light source.
	 */
	constructor( light = null ) {

		super();

		/**
		 * The light source.
		 *
		 * @type {Light?}
		 * @default null
		 */
		this.light = light;

		/**
		 * The light's color value.
		 *
		 * @type {Color}
		 */
		this.color = new Color();

		/**
		 * The light's color node. Points to `colorNode` of the light source, if set. Otherwise
		 * it creates a uniform node based on {@link AnalyticLightNode#color}.
		 *
		 * @type {Node}
		 */
		this.colorNode = ( light && light.colorNode ) || uniform( this.color ).setGroup( renderGroup );

		/**
		 * This property is used to retain a reference to the original value of {@link AnalyticLightNode#colorNode}.
		 * The final color node is represented by a different node when using shadows.
		 *
		 * @type {Node?}
		 * @default null
		 */
		this.baseColorNode = null;

		/**
		 * Represents the light's shadow.
		 *
		 * @type {ShadowNode?}
   		 * @default null
		 */
		this.shadowNode = null;

		/**
		 * Represents the light's shadow color.
		 *
		 * @type {Node?}
   		 * @default null
		 */
		this.shadowColorNode = null;

		/**
		 * This flag can be used for type testing.
		 *
		 * @type {Boolean}
		 * @readonly
		 * @default true
		 */
		this.isAnalyticLightNode = true;

		/**
		 * Overwritten since analytic light nodes are updated
		 * once per frame.
		 *
		 * @type {String}
		 * @default 'frame'
		 */
		this.updateType = NodeUpdateType.FRAME;

	}

	/**
	 * Overwrites the default {@link Node#customCacheKey} implementation by including the
	 * `light.id` and `light.castShadow` into the cache key.
	 *
	 * @return {Number} The custom cache key.
	 */
	customCacheKey() {

		return hash$1( this.light.id, this.light.castShadow ? 1 : 0 );

	}

	getHash() {

		return this.light.uuid;

	}

	/**
	 * Setups the shadow node for this light. The method exists so concrete light classes
	 * can setup different types of shadow nodes.
	 *
	 * @return {ShadowNode} The created shadow node.
	 */
	setupShadowNode() {

		return shadow( this.light );

	}

	/**
	 * Setups the shadow for this light. This method is only executed if the light
	 * cast shadows and the current build object receives shadows. It incorporates
	 * shadows into the lighting computation.
	 *
	 * @param {NodeBuilder} builder - The current node builder.
	 */
	setupShadow( builder ) {

		const { renderer } = builder;

		if ( renderer.shadowMap.enabled === false ) return;

		let shadowColorNode = this.shadowColorNode;

		if ( shadowColorNode === null ) {

			const customShadowNode = this.light.shadow.shadowNode;

			let shadowNode;

			if ( customShadowNode !== undefined ) {

				shadowNode = nodeObject( customShadowNode );

			} else {

				shadowNode = this.setupShadowNode( builder );

			}

			this.shadowNode = shadowNode;

			this.shadowColorNode = shadowColorNode = this.colorNode.mul( shadowNode );

			this.baseColorNode = this.colorNode;

		}

		//

		this.colorNode = shadowColorNode;

	}

	/**
	 * Unlike most other nodes, lighting nodes do not return a output node in {@link Node#setup}.
	 * The main purpose of lighting nodes is to configure the current {@link LightingModel} and/or
	 * invocate the respective interface methods.
	 *
	 * @param {NodeBuilder} builder - The current node builder.
	 */
	setup( builder ) {

		this.colorNode = this.baseColorNode || this.colorNode;

		if ( this.light.castShadow ) {

			if ( builder.object.receiveShadow ) {

				this.setupShadow( builder );

			}

		} else if ( this.shadowNode !== null ) {

			this.shadowNode.dispose();
			this.shadowNode = null;
			this.shadowColorNode = null;

		}

	}

	/**
	 * The update method is used to update light uniforms per frame.
	 * Potentially overwritten in concrete light nodes to update light
	 * specific uniforms.
	 *
	 * @param {NodeFrame} frame - A reference to the current node frame.
	 */
	update( /*frame*/ ) {

		const { light } = this;

		this.color.copy( light.color ).multiplyScalar( light.intensity );

	}

}

/** @module LightUtils **/

/**
 * Represents a `discard` shader operation in TSL.
 *
 * @method
 * @param {Object} inputs - The input parameter object.
 * @param {Node<float>} inputs.lightDistance - The distance of the light's position to the current fragment position.
 * @param {Node<float>} inputs.cutoffDistance - The light's cutoff distance.
 * @param {Node<float>} inputs.decayExponent - The light's decay exponent.
 * @return {Node<float>} The distance falloff.
 */
const getDistanceAttenuation = /*@__PURE__*/ Fn( ( inputs ) => {

	const { lightDistance, cutoffDistance, decayExponent } = inputs;

	// based upon Frostbite 3 Moving to Physically-based Rendering
	// page 32, equation 26: E[window1]
	// https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
	const distanceFalloff = lightDistance.pow( decayExponent ).max( 0.01 ).reciprocal();

	return cutoffDistance.greaterThan( 0 ).select(
		distanceFalloff.mul( lightDistance.div( cutoffDistance ).pow4().oneMinus().clamp().pow2() ),
		distanceFalloff
	);

} ); // validated

/** @module PointShadowNode **/

const _clearColor$2 = /*@__PURE__*/ new Color();

// cubeToUV() maps a 3D direction vector suitable for cube texture mapping to a 2D
// vector suitable for 2D texture mapping. This code uses the following layout for the
// 2D texture:
//
// xzXZ
//  y Y
//
// Y - Positive y direction
// y - Negative y direction
// X - Positive x direction
// x - Negative x direction
// Z - Positive z direction
// z - Negative z direction
//
// Source and test bed:
// https://gist.github.com/tschw/da10c43c467ce8afd0c4

const cubeToUV = /*@__PURE__*/ Fn( ( [ pos, texelSizeY ] ) => {

	const v = pos.toVar();

	// Number of texels to avoid at the edge of each square

	const absV = abs( v );

	// Intersect unit cube

	const scaleToCube = div( 1.0, max$1( absV.x, max$1( absV.y, absV.z ) ) );
	absV.mulAssign( scaleToCube );

	// Apply scale to avoid seams

	// two texels less per square (one texel will do for NEAREST)
	v.mulAssign( scaleToCube.mul( texelSizeY.mul( 2 ).oneMinus() ) );

	// Unwrap

	// space: -1 ... 1 range for each square
	//
	// #X##		dim    := ( 4 , 2 )
	//  # #		center := ( 1 , 1 )

	const planar = vec2( v.xy ).toVar();

	const almostATexel = texelSizeY.mul( 1.5 );
	const almostOne = almostATexel.oneMinus();

	If( absV.z.greaterThanEqual( almostOne ), () => {

		If( v.z.greaterThan( 0.0 ), () => {

			planar.x.assign( sub( 4.0, v.x ) );

		} );

	} ).ElseIf( absV.x.greaterThanEqual( almostOne ), () => {

		const signX = sign( v.x );
		planar.x.assign( v.z.mul( signX ).add( signX.mul( 2.0 ) ) );

	} ).ElseIf( absV.y.greaterThanEqual( almostOne ), () => {

		const signY = sign( v.y );
		planar.x.assign( v.x.add( signY.mul( 2.0 ) ).add( 2.0 ) );
		planar.y.assign( v.z.mul( signY ).sub( 2.0 ) );

	} );

	// Transform to UV space

	// scale := 0.5 / dim
	// translate := ( center + 0.5 ) / dim
	return vec2( 0.125, 0.25 ).mul( planar ).add( vec2( 0.375, 0.75 ) ).flipY();

} ).setLayout( {
	name: 'cubeToUV',
	type: 'vec2',
	inputs: [
		{ name: 'pos', type: 'vec3' },
		{ name: 'texelSizeY', type: 'float' }
	]
} );

const BasicPointShadowFilter = /*@__PURE__*/ Fn( ( { depthTexture, bd3D, dp, texelSize } ) => {

	return texture( depthTexture, cubeToUV( bd3D, texelSize.y ) ).compare( dp );

} );

const PointShadowFilter = /*@__PURE__*/ Fn( ( { depthTexture, bd3D, dp, texelSize, shadow } ) => {

	const radius = reference( 'radius', 'float', shadow ).setGroup( renderGroup );
	const offset = vec2( - 1.0, 1.0 ).mul( radius ).mul( texelSize.y );

	return texture( depthTexture, cubeToUV( bd3D.add( offset.xyy ), texelSize.y ) ).compare( dp )
		.add( texture( depthTexture, cubeToUV( bd3D.add( offset.yyy ), texelSize.y ) ).compare( dp ) )
		.add( texture( depthTexture, cubeToUV( bd3D.add( offset.xyx ), texelSize.y ) ).compare( dp ) )
		.add( texture( depthTexture, cubeToUV( bd3D.add( offset.yyx ), texelSize.y ) ).compare( dp ) )
		.add( texture( depthTexture, cubeToUV( bd3D, texelSize.y ) ).compare( dp ) )
		.add( texture( depthTexture, cubeToUV( bd3D.add( offset.xxy ), texelSize.y ) ).compare( dp ) )
		.add( texture( depthTexture, cubeToUV( bd3D.add( offset.yxy ), texelSize.y ) ).compare( dp ) )
		.add( texture( depthTexture, cubeToUV( bd3D.add( offset.xxx ), texelSize.y ) ).compare( dp ) )
		.add( texture( depthTexture, cubeToUV( bd3D.add( offset.yxx ), texelSize.y ) ).compare( dp ) )
		.mul( 1.0 / 9.0 );

} );

const pointShadowFilter = /*@__PURE__*/ Fn( ( { filterFn, depthTexture, shadowCoord, shadow } ) => {

	// for point lights, the uniform @vShadowCoord is re-purposed to hold
	// the vector from the light to the world-space position of the fragment.
	const lightToPosition = shadowCoord.xyz.toVar();
	const lightToPositionLength = lightToPosition.length();

	const cameraNearLocal = uniform( 'float' ).setGroup( renderGroup ).onRenderUpdate( () => shadow.camera.near );
	const cameraFarLocal = uniform( 'float' ).setGroup( renderGroup ).onRenderUpdate( () => shadow.camera.far );
	const bias = reference( 'bias', 'float', shadow ).setGroup( renderGroup );
	const mapSize = uniform( shadow.mapSize ).setGroup( renderGroup );

	const result = float( 1.0 ).toVar();

	If( lightToPositionLength.sub( cameraFarLocal ).lessThanEqual( 0.0 ).and( lightToPositionLength.sub( cameraNearLocal ).greaterThanEqual( 0.0 ) ), () => {

		// dp = normalized distance from light to fragment position
		const dp = lightToPositionLength.sub( cameraNearLocal ).div( cameraFarLocal.sub( cameraNearLocal ) ).toVar(); // need to clamp?
		dp.addAssign( bias );

		// bd3D = base direction 3D
		const bd3D = lightToPosition.normalize();
		const texelSize = vec2( 1.0 ).div( mapSize.mul( vec2( 4.0, 2.0 ) ) );

		// percentage-closer filtering
		result.assign( filterFn( { depthTexture, bd3D, dp, texelSize, shadow } ) );

	} );

	return result;

} );

const _viewport = /*@__PURE__*/ new Vector4();
const _viewportSize = /*@__PURE__*/ new Vector2();
const _shadowMapSize = /*@__PURE__*/ new Vector2();


/**
 * Represents the shadow implementation for point light nodes.
 *
 * @augments module:ShadowNode~ShadowNode
 */
class PointShadowNode extends ShadowNode {

	static get type() {

		return 'PointShadowNode';

	}

	/**
	 * Constructs a new point shadow node.
	 *
	 * @param {PointLight} light - The shadow casting point light.
	 * @param {PointLightShadow?} [shadow=null] - An optional point light shadow.
	 */
	constructor( light, shadow = null ) {

		super( light, shadow );

	}

	/**
	 * Overwrites the default implementation to return point light shadow specific
	 * filtering functions.
	 *
	 * @param {Number} type - The shadow type.
	 * @return {Function} The filtering function.
	 */
	getShadowFilterFn( type ) {

		return type === BasicShadowMap ? BasicPointShadowFilter : PointShadowFilter;

	}

	/**
	 * Overwrites the default implementation so the unaltered shadow position is used.
	 *
	 * @param {NodeBuilder} builder - A reference to the current node builder.
	 * @param {Node<vec3>} shadowPosition - A node representing the shadow position.
	 * @return {Node<vec3>} The shadow coordinates.
	 */
	setupShadowCoord( builder, shadowPosition ) {

		return shadowPosition;

	}

	/**
	 * Overwrites the default implementation to only use point light specific
	 * shadow filter functions.
	 *
	 * @param {NodeBuilder} builder - A reference to the current node builder.
	 * @param {Object} inputs - A configuration object that defines the shadow filtering.
	 * @param {Function} inputs.filterFn - This function defines the filtering type of the shadow map e.g. PCF.
	 * @param {Texture} inputs.shadowTexture - A reference to the shadow map's texture.
	 * @param {DepthTexture} inputs.depthTexture - A reference to the shadow map's texture data.
	 * @param {Node<vec3>} inputs.shadowCoord - Shadow coordinates which are used to sample from the shadow map.
	 * @param {LightShadow} inputs.shadow - The light shadow.
	 * @return {Node<float>} The result node of the shadow filtering.
	 */
	setupShadowFilter( builder, { filterFn, shadowTexture, depthTexture, shadowCoord, shadow } ) {

		return pointShadowFilter( { filterFn, shadowTexture, depthTexture, shadowCoord, shadow } );

	}

	/**
	 * Overwrites the default implementation with point light specific
	 * rendering code.
	 *
	 * @param {NodeFrme} frame - A reference to the current node frame.
	 */
	renderShadow( frame ) {

		const { shadow, shadowMap, light } = this;
		const { renderer, scene } = frame;

		const shadowFrameExtents = shadow.getFrameExtents();

		_shadowMapSize.copy( shadow.mapSize );
		_shadowMapSize.multiply( shadowFrameExtents );

		shadowMap.setSize( _shadowMapSize.width, _shadowMapSize.height );

		_viewportSize.copy( shadow.mapSize );

		//

		const previousAutoClear = renderer.autoClear;

		const previousClearColor = renderer.getClearColor( _clearColor$2 );
		const previousClearAlpha = renderer.getClearAlpha();

		renderer.autoClear = false;
		renderer.setClearColor( shadow.clearColor, shadow.clearAlpha );
		renderer.clear();

		const viewportCount = shadow.getViewportCount();

		for ( let vp = 0; vp < viewportCount; vp ++ ) {

			const viewport = shadow.getViewport( vp );

			const x = _viewportSize.x * viewport.x;
			const y = _shadowMapSize.y - _viewportSize.y - ( _viewportSize.y * viewport.y );

			_viewport.set(
				x,
				y,
				_viewportSize.x * viewport.z,
				_viewportSize.y * viewport.w
			);

			shadowMap.viewport.copy( _viewport );

			shadow.updateMatrices( light, vp );

			renderer.render( scene, shadow.camera );

		}

		//

		renderer.autoClear = previousAutoClear;
		renderer.setClearColor( previousClearColor, previousClearAlpha );

	}

}

/**
 * TSL function for creating an instance of `PointShadowNode`.
 *
 * @function
 * @param {PointLight} light - The shadow casting point light.
 * @param {PointLightShadow?} [shadow=null] - An optional point light shadow.
 * @return {PointShadowNode} The created point shadow node.
 */
const pointShadow = ( light, shadow ) => nodeObject( new PointShadowNode( light, shadow ) );

const directPointLight = Fn( ( { color, lightViewPosition, cutoffDistance, decayExponent }, builder ) => {

	const lightingModel = builder.context.lightingModel;

	const lVector = lightViewPosition.sub( positionView ); // @TODO: Add it into LightNode

	const lightDirection = lVector.normalize();
	const lightDistance = lVector.length();

	const lightAttenuation = getDistanceAttenuation( {
		lightDistance,
		cutoffDistance,
		decayExponent
	} );

	const lightColor = color.mul( lightAttenuation );

	const reflectedLight = builder.context.reflectedLight;

	lightingModel.direct( {
		lightDirection,
		lightColor,
		reflectedLight
	}, builder.stack, builder );

} );

/**
 * Module for representing point lights as nodes.
 *
 * @augments AnalyticLightNode
 */
class PointLightNode extends AnalyticLightNode {

	static get type() {

		return 'PointLightNode';

	}

	/**
	 * Constructs a new point light node.
	 *
	 * @param {PointLight?} [light=null] - The point light source.
	 */
	constructor( light = null ) {

		super( light );

		/**
		 * Uniform node representing the cutoff distance.
		 *
		 * @type {UniformNode<float>}
		 */
		this.cutoffDistanceNode = uniform( 0 ).setGroup( renderGroup );

		/**
		 * Uniform node representing the decay exponent.
		 *
		 * @type {UniformNode<float>}
		 */
		this.decayExponentNode = uniform( 2 ).setGroup( renderGroup );

	}

	/**
	 * Overwritten to updated point light specific uniforms.
	 *
	 * @param {NodeFrame} frame - A reference to the current node frame.
	 */
	update( frame ) {

		const { light } = this;

		super.update( frame );

		this.cutoffDistanceNode.value = light.distance;
		this.decayExponentNode.value = light.decay;

	}

	/**
	 * Overwritten to setup point light specific shadow.
	 *
	 * @return {PointShadowNode}
	 */
	setupShadowNode() {

		return pointShadow( this.light );

	}

	setup( builder ) {

		super.setup( builder );

		directPointLight( {
			color: this.colorNode,
			lightViewPosition: lightViewPosition( this.light ),
			cutoffDistance: this.cutoffDistanceNode,
			decayExponent: this.decayExponentNode
		} ).append();

	}

}

/** @module Procedural **/

/**
 * Creates a 2x2 checkerboard pattern that can be used as procedural texture data.
 *
 * @method
 * @param {Node<vec2>} coord - The uv coordinates.
 * @return {Node<float>} The result data.
 */
const checker = /*@__PURE__*/ Fn( ( [ coord = uv() ] ) => {

	const uv = coord.mul( 2.0 );

	const cx = uv.x.floor();
	const cy = uv.y.floor();
	const result = cx.add( cy ).mod( 2.0 );

	return result.sign();

} );

// Three.js Transpiler
// https://raw.githubusercontent.com/AcademySoftwareFoundation/MaterialX/main/libraries/stdlib/genglsl/lib/mx_noise.glsl



const mx_select = /*@__PURE__*/ Fn( ( [ b_immutable, t_immutable, f_immutable ] ) => {

	const f = float( f_immutable ).toVar();
	const t = float( t_immutable ).toVar();
	const b = bool( b_immutable ).toVar();

	return select( b, t, f );

} ).setLayout( {
	name: 'mx_select',
	type: 'float',
	inputs: [
		{ name: 'b', type: 'bool' },
		{ name: 't', type: 'float' },
		{ name: 'f', type: 'float' }
	]
} );

const mx_negate_if = /*@__PURE__*/ Fn( ( [ val_immutable, b_immutable ] ) => {

	const b = bool( b_immutable ).toVar();
	const val = float( val_immutable ).toVar();

	return select( b, val.negate(), val );

} ).setLayout( {
	name: 'mx_negate_if',
	type: 'float',
	inputs: [
		{ name: 'val', type: 'float' },
		{ name: 'b', type: 'bool' }
	]
} );

const mx_floor = /*@__PURE__*/ Fn( ( [ x_immutable ] ) => {

	const x = float( x_immutable ).toVar();

	return int( floor( x ) );

} ).setLayout( {
	name: 'mx_floor',
	type: 'int',
	inputs: [
		{ name: 'x', type: 'float' }
	]
} );

const mx_floorfrac = /*@__PURE__*/ Fn( ( [ x_immutable, i ] ) => {

	const x = float( x_immutable ).toVar();
	i.assign( mx_floor( x ) );

	return x.sub( float( i ) );

} );

const mx_bilerp_0 = /*@__PURE__*/ Fn( ( [ v0_immutable, v1_immutable, v2_immutable, v3_immutable, s_immutable, t_immutable ] ) => {

	const t = float( t_immutable ).toVar();
	const s = float( s_immutable ).toVar();
	const v3 = float( v3_immutable ).toVar();
	const v2 = float( v2_immutable ).toVar();
	const v1 = float( v1_immutable ).toVar();
	const v0 = float( v0_immutable ).toVar();
	const s1 = float( sub( 1.0, s ) ).toVar();

	return sub( 1.0, t ).mul( v0.mul( s1 ).add( v1.mul( s ) ) ).add( t.mul( v2.mul( s1 ).add( v3.mul( s ) ) ) );

} ).setLayout( {
	name: 'mx_bilerp_0',
	type: 'float',
	inputs: [
		{ name: 'v0', type: 'float' },
		{ name: 'v1', type: 'float' },
		{ name: 'v2', type: 'float' },
		{ name: 'v3', type: 'float' },
		{ name: 's', type: 'float' },
		{ name: 't', type: 'float' }
	]
} );

const mx_bilerp_1 = /*@__PURE__*/ Fn( ( [ v0_immutable, v1_immutable, v2_immutable, v3_immutable, s_immutable, t_immutable ] ) => {

	const t = float( t_immutable ).toVar();
	const s = float( s_immutable ).toVar();
	const v3 = vec3( v3_immutable ).toVar();
	const v2 = vec3( v2_immutable ).toVar();
	const v1 = vec3( v1_immutable ).toVar();
	const v0 = vec3( v0_immutable ).toVar();
	const s1 = float( sub( 1.0, s ) ).toVar();

	return sub( 1.0, t ).mul( v0.mul( s1 ).add( v1.mul( s ) ) ).add( t.mul( v2.mul( s1 ).add( v3.mul( s ) ) ) );

} ).setLayout( {
	name: 'mx_bilerp_1',
	type: 'vec3',
	inputs: [
		{ name: 'v0', type: 'vec3' },
		{ name: 'v1', type: 'vec3' },
		{ name: 'v2', type: 'vec3' },
		{ name: 'v3', type: 'vec3' },
		{ name: 's', type: 'float' },
		{ name: 't', type: 'float' }
	]
} );

const mx_bilerp = /*@__PURE__*/ overloadingFn( [ mx_bilerp_0, mx_bilerp_1 ] );

const mx_trilerp_0 = /*@__PURE__*/ Fn( ( [ v0_immutable, v1_immutable, v2_immutable, v3_immutable, v4_immutable, v5_immutable, v6_immutable, v7_immutable, s_immutable, t_immutable, r_immutable ] ) => {

	const r = float( r_immutable ).toVar();
	const t = float( t_immutable ).toVar();
	const s = float( s_immutable ).toVar();
	const v7 = float( v7_immutable ).toVar();
	const v6 = float( v6_immutable ).toVar();
	const v5 = float( v5_immutable ).toVar();
	const v4 = float( v4_immutable ).toVar();
	const v3 = float( v3_immutable ).toVar();
	const v2 = float( v2_immutable ).toVar();
	const v1 = float( v1_immutable ).toVar();
	const v0 = float( v0_immutable ).toVar();
	const s1 = float( sub( 1.0, s ) ).toVar();
	const t1 = float( sub( 1.0, t ) ).toVar();
	const r1 = float( sub( 1.0, r ) ).toVar();

	return r1.mul( t1.mul( v0.mul( s1 ).add( v1.mul( s ) ) ).add( t.mul( v2.mul( s1 ).add( v3.mul( s ) ) ) ) ).add( r.mul( t1.mul( v4.mul( s1 ).add( v5.mul( s ) ) ).add( t.mul( v6.mul( s1 ).add( v7.mul( s ) ) ) ) ) );

} ).setLayout( {
	name: 'mx_trilerp_0',
	type: 'float',
	inputs: [
		{ name: 'v0', type: 'float' },
		{ name: 'v1', type: 'float' },
		{ name: 'v2', type: 'float' },
		{ name: 'v3', type: 'float' },
		{ name: 'v4', type: 'float' },
		{ name: 'v5', type: 'float' },
		{ name: 'v6', type: 'float' },
		{ name: 'v7', type: 'float' },
		{ name: 's', type: 'float' },
		{ name: 't', type: 'float' },
		{ name: 'r', type: 'float' }
	]
} );

const mx_trilerp_1 = /*@__PURE__*/ Fn( ( [ v0_immutable, v1_immutable, v2_immutable, v3_immutable, v4_immutable, v5_immutable, v6_immutable, v7_immutable, s_immutable, t_immutable, r_immutable ] ) => {

	const r = float( r_immutable ).toVar();
	const t = float( t_immutable ).toVar();
	const s = float( s_immutable ).toVar();
	const v7 = vec3( v7_immutable ).toVar();
	const v6 = vec3( v6_immutable ).toVar();
	const v5 = vec3( v5_immutable ).toVar();
	const v4 = vec3( v4_immutable ).toVar();
	const v3 = vec3( v3_immutable ).toVar();
	const v2 = vec3( v2_immutable ).toVar();
	const v1 = vec3( v1_immutable ).toVar();
	const v0 = vec3( v0_immutable ).toVar();
	const s1 = float( sub( 1.0, s ) ).toVar();
	const t1 = float( sub( 1.0, t ) ).toVar();
	const r1 = float( sub( 1.0, r ) ).toVar();

	return r1.mul( t1.mul( v0.mul( s1 ).add( v1.mul( s ) ) ).add( t.mul( v2.mul( s1 ).add( v3.mul( s ) ) ) ) ).add( r.mul( t1.mul( v4.mul( s1 ).add( v5.mul( s ) ) ).add( t.mul( v6.mul( s1 ).add( v7.mul( s ) ) ) ) ) );

} ).setLayout( {
	name: 'mx_trilerp_1',
	type: 'vec3',
	inputs: [
		{ name: 'v0', type: 'vec3' },
		{ name: 'v1', type: 'vec3' },
		{ name: 'v2', type: 'vec3' },
		{ name: 'v3', type: 'vec3' },
		{ name: 'v4', type: 'vec3' },
		{ name: 'v5', type: 'vec3' },
		{ name: 'v6', type: 'vec3' },
		{ name: 'v7', type: 'vec3' },
		{ name: 's', type: 'float' },
		{ name: 't', type: 'float' },
		{ name: 'r', type: 'float' }
	]
} );

const mx_trilerp = /*@__PURE__*/ overloadingFn( [ mx_trilerp_0, mx_trilerp_1 ] );

const mx_gradient_float_0 = /*@__PURE__*/ Fn( ( [ hash_immutable, x_immutable, y_immutable ] ) => {

	const y = float( y_immutable ).toVar();
	const x = float( x_immutable ).toVar();
	const hash = uint( hash_immutable ).toVar();
	const h = uint( hash.bitAnd( uint( 7 ) ) ).toVar();
	const u = float( mx_select( h.lessThan( uint( 4 ) ), x, y ) ).toVar();
	const v = float( mul( 2.0, mx_select( h.lessThan( uint( 4 ) ), y, x ) ) ).toVar();

	return mx_negate_if( u, bool( h.bitAnd( uint( 1 ) ) ) ).add( mx_negate_if( v, bool( h.bitAnd( uint( 2 ) ) ) ) );

} ).setLayout( {
	name: 'mx_gradient_float_0',
	type: 'float',
	inputs: [
		{ name: 'hash', type: 'uint' },
		{ name: 'x', type: 'float' },
		{ name: 'y', type: 'float' }
	]
} );

const mx_gradient_float_1 = /*@__PURE__*/ Fn( ( [ hash_immutable, x_immutable, y_immutable, z_immutable ] ) => {

	const z = float( z_immutable ).toVar();
	const y = float( y_immutable ).toVar();
	const x = float( x_immutable ).toVar();
	const hash = uint( hash_immutable ).toVar();
	const h = uint( hash.bitAnd( uint( 15 ) ) ).toVar();
	const u = float( mx_select( h.lessThan( uint( 8 ) ), x, y ) ).toVar();
	const v = float( mx_select( h.lessThan( uint( 4 ) ), y, mx_select( h.equal( uint( 12 ) ).or( h.equal( uint( 14 ) ) ), x, z ) ) ).toVar();

	return mx_negate_if( u, bool( h.bitAnd( uint( 1 ) ) ) ).add( mx_negate_if( v, bool( h.bitAnd( uint( 2 ) ) ) ) );

} ).setLayout( {
	name: 'mx_gradient_float_1',
	type: 'float',
	inputs: [
		{ name: 'hash', type: 'uint' },
		{ name: 'x', type: 'float' },
		{ name: 'y', type: 'float' },
		{ name: 'z', type: 'float' }
	]
} );

const mx_gradient_float = /*@__PURE__*/ overloadingFn( [ mx_gradient_float_0, mx_gradient_float_1 ] );

const mx_gradient_vec3_0 = /*@__PURE__*/ Fn( ( [ hash_immutable, x_immutable, y_immutable ] ) => {

	const y = float( y_immutable ).toVar();
	const x = float( x_immutable ).toVar();
	const hash = uvec3( hash_immutable ).toVar();

	return vec3( mx_gradient_float( hash.x, x, y ), mx_gradient_float( hash.y, x, y ), mx_gradient_float( hash.z, x, y ) );

} ).setLayout( {
	name: 'mx_gradient_vec3_0',
	type: 'vec3',
	inputs: [
		{ name: 'hash', type: 'uvec3' },
		{ name: 'x', type: 'float' },
		{ name: 'y', type: 'float' }
	]
} );

const mx_gradient_vec3_1 = /*@__PURE__*/ Fn( ( [ hash_immutable, x_immutable, y_immutable, z_immutable ] ) => {

	const z = float( z_immutable ).toVar();
	const y = float( y_immutable ).toVar();
	const x = float( x_immutable ).toVar();
	const hash = uvec3( hash_immutable ).toVar();

	return vec3( mx_gradient_float( hash.x, x, y, z ), mx_gradient_float( hash.y, x, y, z ), mx_gradient_float( hash.z, x, y, z ) );

} ).setLayout( {
	name: 'mx_gradient_vec3_1',
	type: 'vec3',
	inputs: [
		{ name: 'hash', type: 'uvec3' },
		{ name: 'x', type: 'float' },
		{ name: 'y', type: 'float' },
		{ name: 'z', type: 'float' }
	]
} );

const mx_gradient_vec3 = /*@__PURE__*/ overloadingFn( [ mx_gradient_vec3_0, mx_gradient_vec3_1 ] );

const mx_gradient_scale2d_0 = /*@__PURE__*/ Fn( ( [ v_immutable ] ) => {

	const v = float( v_immutable ).toVar();

	return mul( 0.6616, v );

} ).setLayout( {
	name: 'mx_gradient_scale2d_0',
	type: 'float',
	inputs: [
		{ name: 'v', type: 'float' }
	]
} );

const mx_gradient_scale3d_0 = /*@__PURE__*/ Fn( ( [ v_immutable ] ) => {

	const v = float( v_immutable ).toVar();

	return mul( 0.9820, v );

} ).setLayout( {
	name: 'mx_gradient_scale3d_0',
	type: 'float',
	inputs: [
		{ name: 'v', type: 'float' }
	]
} );

const mx_gradient_scale2d_1 = /*@__PURE__*/ Fn( ( [ v_immutable ] ) => {

	const v = vec3( v_immutable ).toVar();

	return mul( 0.6616, v );

} ).setLayout( {
	name: 'mx_gradient_scale2d_1',
	type: 'vec3',
	inputs: [
		{ name: 'v', type: 'vec3' }
	]
} );

const mx_gradient_scale2d = /*@__PURE__*/ overloadingFn( [ mx_gradient_scale2d_0, mx_gradient_scale2d_1 ] );

const mx_gradient_scale3d_1 = /*@__PURE__*/ Fn( ( [ v_immutable ] ) => {

	const v = vec3( v_immutable ).toVar();

	return mul( 0.9820, v );

} ).setLayout( {
	name: 'mx_gradient_scale3d_1',
	type: 'vec3',
	inputs: [
		{ name: 'v', type: 'vec3' }
	]
} );

const mx_gradient_scale3d = /*@__PURE__*/ overloadingFn( [ mx_gradient_scale3d_0, mx_gradient_scale3d_1 ] );

const mx_rotl32 = /*@__PURE__*/ Fn( ( [ x_immutable, k_immutable ] ) => {

	const k = int( k_immutable ).toVar();
	const x = uint( x_immutable ).toVar();

	return x.shiftLeft( k ).bitOr( x.shiftRight( int( 32 ).sub( k ) ) );

} ).setLayout( {
	name: 'mx_rotl32',
	type: 'uint',
	inputs: [
		{ name: 'x', type: 'uint' },
		{ name: 'k', type: 'int' }
	]
} );

const mx_bjmix = /*@__PURE__*/ Fn( ( [ a, b, c ] ) => {

	a.subAssign( c );
	a.bitXorAssign( mx_rotl32( c, int( 4 ) ) );
	c.addAssign( b );
	b.subAssign( a );
	b.bitXorAssign( mx_rotl32( a, int( 6 ) ) );
	a.addAssign( c );
	c.subAssign( b );
	c.bitXorAssign( mx_rotl32( b, int( 8 ) ) );
	b.addAssign( a );
	a.subAssign( c );
	a.bitXorAssign( mx_rotl32( c, int( 16 ) ) );
	c.addAssign( b );
	b.subAssign( a );
	b.bitXorAssign( mx_rotl32( a, int( 19 ) ) );
	a.addAssign( c );
	c.subAssign( b );
	c.bitXorAssign( mx_rotl32( b, int( 4 ) ) );
	b.addAssign( a );

} );

const mx_bjfinal = /*@__PURE__*/ Fn( ( [ a_immutable, b_immutable, c_immutable ] ) => {

	const c = uint( c_immutable ).toVar();
	const b = uint( b_immutable ).toVar();
	const a = uint( a_immutable ).toVar();
	c.bitXorAssign( b );
	c.subAssign( mx_rotl32( b, int( 14 ) ) );
	a.bitXorAssign( c );
	a.subAssign( mx_rotl32( c, int( 11 ) ) );
	b.bitXorAssign( a );
	b.subAssign( mx_rotl32( a, int( 25 ) ) );
	c.bitXorAssign( b );
	c.subAssign( mx_rotl32( b, int( 16 ) ) );
	a.bitXorAssign( c );
	a.subAssign( mx_rotl32( c, int( 4 ) ) );
	b.bitXorAssign( a );
	b.subAssign( mx_rotl32( a, int( 14 ) ) );
	c.bitXorAssign( b );
	c.subAssign( mx_rotl32( b, int( 24 ) ) );

	return c;

} ).setLayout( {
	name: 'mx_bjfinal',
	type: 'uint',
	inputs: [
		{ name: 'a', type: 'uint' },
		{ name: 'b', type: 'uint' },
		{ name: 'c', type: 'uint' }
	]
} );

const mx_bits_to_01 = /*@__PURE__*/ Fn( ( [ bits_immutable ] ) => {

	const bits = uint( bits_immutable ).toVar();

	return float( bits ).div( float( uint( int( 0xffffffff ) ) ) );

} ).setLayout( {
	name: 'mx_bits_to_01',
	type: 'float',
	inputs: [
		{ name: 'bits', type: 'uint' }
	]
} );

const mx_fade = /*@__PURE__*/ Fn( ( [ t_immutable ] ) => {

	const t = float( t_immutable ).toVar();

	return t.mul( t ).mul( t ).mul( t.mul( t.mul( 6.0 ).sub( 15.0 ) ).add( 10.0 ) );

} ).setLayout( {
	name: 'mx_fade',
	type: 'float',
	inputs: [
		{ name: 't', type: 'float' }
	]
} );

const mx_hash_int_0 = /*@__PURE__*/ Fn( ( [ x_immutable ] ) => {

	const x = int( x_immutable ).toVar();
	const len = uint( uint( 1 ) ).toVar();
	const seed = uint( uint( int( 0xdeadbeef ) ).add( len.shiftLeft( uint( 2 ) ) ).add( uint( 13 ) ) ).toVar();

	return mx_bjfinal( seed.add( uint( x ) ), seed, seed );

} ).setLayout( {
	name: 'mx_hash_int_0',
	type: 'uint',
	inputs: [
		{ name: 'x', type: 'int' }
	]
} );

const mx_hash_int_1 = /*@__PURE__*/ Fn( ( [ x_immutable, y_immutable ] ) => {

	const y = int( y_immutable ).toVar();
	const x = int( x_immutable ).toVar();
	const len = uint( uint( 2 ) ).toVar();
	const a = uint().toVar(), b = uint().toVar(), c = uint().toVar();
	a.assign( b.assign( c.assign( uint( int( 0xdeadbeef ) ).add( len.shiftLeft( uint( 2 ) ) ).add( uint( 13 ) ) ) ) );
	a.addAssign( uint( x ) );
	b.addAssign( uint( y ) );

	return mx_bjfinal( a, b, c );

} ).setLayout( {
	name: 'mx_hash_int_1',
	type: 'uint',
	inputs: [
		{ name: 'x', type: 'int' },
		{ name: 'y', type: 'int' }
	]
} );

const mx_hash_int_2 = /*@__PURE__*/ Fn( ( [ x_immutable, y_immutable, z_immutable ] ) => {

	const z = int( z_immutable ).toVar();
	const y = int( y_immutable ).toVar();
	const x = int( x_immutable ).toVar();
	const len = uint( uint( 3 ) ).toVar();
	const a = uint().toVar(), b = uint().toVar(), c = uint().toVar();
	a.assign( b.assign( c.assign( uint( int( 0xdeadbeef ) ).add( len.shiftLeft( uint( 2 ) ) ).add( uint( 13 ) ) ) ) );
	a.addAssign( uint( x ) );
	b.addAssign( uint( y ) );
	c.addAssign( uint( z ) );

	return mx_bjfinal( a, b, c );

} ).setLayout( {
	name: 'mx_hash_int_2',
	type: 'uint',
	inputs: [
		{ name: 'x', type: 'int' },
		{ name: 'y', type: 'int' },
		{ name: 'z', type: 'int' }
	]
} );

const mx_hash_int_3 = /*@__PURE__*/ Fn( ( [ x_immutable, y_immutable, z_immutable, xx_immutable ] ) => {

	const xx = int( xx_immutable ).toVar();
	const z = int( z_immutable ).toVar();
	const y = int( y_immutable ).toVar();
	const x = int( x_immutable ).toVar();
	const len = uint( uint( 4 ) ).toVar();
	const a = uint().toVar(), b = uint().toVar(), c = uint().toVar();
	a.assign( b.assign( c.assign( uint( int( 0xdeadbeef ) ).add( len.shiftLeft( uint( 2 ) ) ).add( uint( 13 ) ) ) ) );
	a.addAssign( uint( x ) );
	b.addAssign( uint( y ) );
	c.addAssign( uint( z ) );
	mx_bjmix( a, b, c );
	a.addAssign( uint( xx ) );

	return mx_bjfinal( a, b, c );

} ).setLayout( {
	name: 'mx_hash_int_3',
	type: 'uint',
	inputs: [
		{ name: 'x', type: 'int' },
		{ name: 'y', type: 'int' },
		{ name: 'z', type: 'int' },
		{ name: 'xx', type: 'int' }
	]
} );

const mx_hash_int_4 = /*@__PURE__*/ Fn( ( [ x_immutable, y_immutable, z_immutable, xx_immutable, yy_immutable ] ) => {

	const yy = int( yy_immutable ).toVar();
	const xx = int( xx_immutable ).toVar();
	const z = int( z_immutable ).toVar();
	const y = int( y_immutable ).toVar();
	const x = int( x_immutable ).toVar();
	const len = uint( uint( 5 ) ).toVar();
	const a = uint().toVar(), b = uint().toVar(), c = uint().toVar();
	a.assign( b.assign( c.assign( uint( int( 0xdeadbeef ) ).add( len.shiftLeft( uint( 2 ) ) ).add( uint( 13 ) ) ) ) );
	a.addAssign( uint( x ) );
	b.addAssign( uint( y ) );
	c.addAssign( uint( z ) );
	mx_bjmix( a, b, c );
	a.addAssign( uint( xx ) );
	b.addAssign( uint( yy ) );

	return mx_bjfinal( a, b, c );

} ).setLayout( {
	name: 'mx_hash_int_4',
	type: 'uint',
	inputs: [
		{ name: 'x', type: 'int' },
		{ name: 'y', type: 'int' },
		{ name: 'z', type: 'int' },
		{ name: 'xx', type: 'int' },
		{ name: 'yy', type: 'int' }
	]
} );

const mx_hash_int = /*@__PURE__*/ overloadingFn( [ mx_hash_int_0, mx_hash_int_1, mx_hash_int_2, mx_hash_int_3, mx_hash_int_4 ] );

const mx_hash_vec3_0 = /*@__PURE__*/ Fn( ( [ x_immutable, y_immutable ] ) => {

	const y = int( y_immutable ).toVar();
	const x = int( x_immutable ).toVar();
	const h = uint( mx_hash_int( x, y ) ).toVar();
	const result = uvec3().toVar();
	result.x.assign( h.bitAnd( int( 0xFF ) ) );
	result.y.assign( h.shiftRight( int( 8 ) ).bitAnd( int( 0xFF ) ) );
	result.z.assign( h.shiftRight( int( 16 ) ).bitAnd( int( 0xFF ) ) );

	return result;

} ).setLayout( {
	name: 'mx_hash_vec3_0',
	type: 'uvec3',
	inputs: [
		{ name: 'x', type: 'int' },
		{ name: 'y', type: 'int' }
	]
} );

const mx_hash_vec3_1 = /*@__PURE__*/ Fn( ( [ x_immutable, y_immutable, z_immutable ] ) => {

	const z = int( z_immutable ).toVar();
	const y = int( y_immutable ).toVar();
	const x = int( x_immutable ).toVar();
	const h = uint( mx_hash_int( x, y, z ) ).toVar();
	const result = uvec3().toVar();
	result.x.assign( h.bitAnd( int( 0xFF ) ) );
	result.y.assign( h.shiftRight( int( 8 ) ).bitAnd( int( 0xFF ) ) );
	result.z.assign( h.shiftRight( int( 16 ) ).bitAnd( int( 0xFF ) ) );

	return result;

} ).setLayout( {
	name: 'mx_hash_vec3_1',
	type: 'uvec3',
	inputs: [
		{ name: 'x', type: 'int' },
		{ name: 'y', type: 'int' },
		{ name: 'z', type: 'int' }
	]
} );

const mx_hash_vec3 = /*@__PURE__*/ overloadingFn( [ mx_hash_vec3_0, mx_hash_vec3_1 ] );

const mx_perlin_noise_float_0 = /*@__PURE__*/ Fn( ( [ p_immutable ] ) => {

	const p = vec2( p_immutable ).toVar();
	const X = int().toVar(), Y = int().toVar();
	const fx = float( mx_floorfrac( p.x, X ) ).toVar();
	const fy = float( mx_floorfrac( p.y, Y ) ).toVar();
	const u = float( mx_fade( fx ) ).toVar();
	const v = float( mx_fade( fy ) ).toVar();
	const result = float( mx_bilerp( mx_gradient_float( mx_hash_int( X, Y ), fx, fy ), mx_gradient_float( mx_hash_int( X.add( int( 1 ) ), Y ), fx.sub( 1.0 ), fy ), mx_gradient_float( mx_hash_int( X, Y.add( int( 1 ) ) ), fx, fy.sub( 1.0 ) ), mx_gradient_float( mx_hash_int( X.add( int( 1 ) ), Y.add( int( 1 ) ) ), fx.sub( 1.0 ), fy.sub( 1.0 ) ), u, v ) ).toVar();

	return mx_gradient_scale2d( result );

} ).setLayout( {
	name: 'mx_perlin_noise_float_0',
	type: 'float',
	inputs: [
		{ name: 'p', type: 'vec2' }
	]
} );

const mx_perlin_noise_float_1 = /*@__PURE__*/ Fn( ( [ p_immutable ] ) => {

	const p = vec3( p_immutable ).toVar();
	const X = int().toVar(), Y = int().toVar(), Z = int().toVar();
	const fx = float( mx_floorfrac( p.x, X ) ).toVar();
	const fy = float( mx_floorfrac( p.y, Y ) ).toVar();
	const fz = float( mx_floorfrac( p.z, Z ) ).toVar();
	const u = float( mx_fade( fx ) ).toVar();
	const v = float( mx_fade( fy ) ).toVar();
	const w = float( mx_fade( fz ) ).toVar();
	const result = float( mx_trilerp( mx_gradient_float( mx_hash_int( X, Y, Z ), fx, fy, fz ), mx_gradient_float( mx_hash_int( X.add( int( 1 ) ), Y, Z ), fx.sub( 1.0 ), fy, fz ), mx_gradient_float( mx_hash_int( X, Y.add( int( 1 ) ), Z ), fx, fy.sub( 1.0 ), fz ), mx_gradient_float( mx_hash_int( X.add( int( 1 ) ), Y.add( int( 1 ) ), Z ), fx.sub( 1.0 ), fy.sub( 1.0 ), fz ), mx_gradient_float( mx_hash_int( X, Y, Z.add( int( 1 ) ) ), fx, fy, fz.sub( 1.0 ) ), mx_gradient_float( mx_hash_int( X.add( int( 1 ) ), Y, Z.add( int( 1 ) ) ), fx.sub( 1.0 ), fy, fz.sub( 1.0 ) ), mx_gradient_float( mx_hash_int( X, Y.add( int( 1 ) ), Z.add( int( 1 ) ) ), fx, fy.sub( 1.0 ), fz.sub( 1.0 ) ), mx_gradient_float( mx_hash_int( X.add( int( 1 ) ), Y.add( int( 1 ) ), Z.add( int( 1 ) ) ), fx.sub( 1.0 ), fy.sub( 1.0 ), fz.sub( 1.0 ) ), u, v, w ) ).toVar();

	return mx_gradient_scale3d( result );

} ).setLayout( {
	name: 'mx_perlin_noise_float_1',
	type: 'float',
	inputs: [
		{ name: 'p', type: 'vec3' }
	]
} );

const mx_perlin_noise_float = /*@__PURE__*/ overloadingFn( [ mx_perlin_noise_float_0, mx_perlin_noise_float_1 ] );

const mx_perlin_noise_vec3_0 = /*@__PURE__*/ Fn( ( [ p_immutable ] ) => {

	const p = vec2( p_immutable ).toVar();
	const X = int().toVar(), Y = int().toVar();
	const fx = float( mx_floorfrac( p.x, X ) ).toVar();
	const fy = float( mx_floorfrac( p.y, Y ) ).toVar();
	const u = float( mx_fade( fx ) ).toVar();
	const v = float( mx_fade( fy ) ).toVar();
	const result = vec3( mx_bilerp( mx_gradient_vec3( mx_hash_vec3( X, Y ), fx, fy ), mx_gradient_vec3( mx_hash_vec3( X.add( int( 1 ) ), Y ), fx.sub( 1.0 ), fy ), mx_gradient_vec3( mx_hash_vec3( X, Y.add( int( 1 ) ) ), fx, fy.sub( 1.0 ) ), mx_gradient_vec3( mx_hash_vec3( X.add( int( 1 ) ), Y.add( int( 1 ) ) ), fx.sub( 1.0 ), fy.sub( 1.0 ) ), u, v ) ).toVar();

	return mx_gradient_scale2d( result );

} ).setLayout( {
	name: 'mx_perlin_noise_vec3_0',
	type: 'vec3',
	inputs: [
		{ name: 'p', type: 'vec2' }
	]
} );

const mx_perlin_noise_vec3_1 = /*@__PURE__*/ Fn( ( [ p_immutable ] ) => {

	const p = vec3( p_immutable ).toVar();
	const X = int().toVar(), Y = int().toVar(), Z = int().toVar();
	const fx = float( mx_floorfrac( p.x, X ) ).toVar();
	const fy = float( mx_floorfrac( p.y, Y ) ).toVar();
	const fz = float( mx_floorfrac( p.z, Z ) ).toVar();
	const u = float( mx_fade( fx ) ).toVar();
	const v = float( mx_fade( fy ) ).toVar();
	const w = float( mx_fade( fz ) ).toVar();
	const result = vec3( mx_trilerp( mx_gradient_vec3( mx_hash_vec3( X, Y, Z ), fx, fy, fz ), mx_gradient_vec3( mx_hash_vec3( X.add( int( 1 ) ), Y, Z ), fx.sub( 1.0 ), fy, fz ), mx_gradient_vec3( mx_hash_vec3( X, Y.add( int( 1 ) ), Z ), fx, fy.sub( 1.0 ), fz ), mx_gradient_vec3( mx_hash_vec3( X.add( int( 1 ) ), Y.add( int( 1 ) ), Z ), fx.sub( 1.0 ), fy.sub( 1.0 ), fz ), mx_gradient_vec3( mx_hash_vec3( X, Y, Z.add( int( 1 ) ) ), fx, fy, fz.sub( 1.0 ) ), mx_gradient_vec3( mx_hash_vec3( X.add( int( 1 ) ), Y, Z.add( int( 1 ) ) ), fx.sub( 1.0 ), fy, fz.sub( 1.0 ) ), mx_gradient_vec3( mx_hash_vec3( X, Y.add( int( 1 ) ), Z.add( int( 1 ) ) ), fx, fy.sub( 1.0 ), fz.sub( 1.0 ) ), mx_gradient_vec3( mx_hash_vec3( X.add( int( 1 ) ), Y.add( int( 1 ) ), Z.add( int( 1 ) ) ), fx.sub( 1.0 ), fy.sub( 1.0 ), fz.sub( 1.0 ) ), u, v, w ) ).toVar();

	return mx_gradient_scale3d( result );

} ).setLayout( {
	name: 'mx_perlin_noise_vec3_1',
	type: 'vec3',
	inputs: [
		{ name: 'p', type: 'vec3' }
	]
} );

const mx_perlin_noise_vec3 = /*@__PURE__*/ overloadingFn( [ mx_perlin_noise_vec3_0, mx_perlin_noise_vec3_1 ] );

const mx_cell_noise_float_0 = /*@__PURE__*/ Fn( ( [ p_immutable ] ) => {

	const p = float( p_immutable ).toVar();
	const ix = int( mx_floor( p ) ).toVar();

	return mx_bits_to_01( mx_hash_int( ix ) );

} ).setLayout( {
	name: 'mx_cell_noise_float_0',
	type: 'float',
	inputs: [
		{ name: 'p', type: 'float' }
	]
} );

const mx_cell_noise_float_1 = /*@__PURE__*/ Fn( ( [ p_immutable ] ) => {

	const p = vec2( p_immutable ).toVar();
	const ix = int( mx_floor( p.x ) ).toVar();
	const iy = int( mx_floor( p.y ) ).toVar();

	return mx_bits_to_01( mx_hash_int( ix, iy ) );

} ).setLayout( {
	name: 'mx_cell_noise_float_1',
	type: 'float',
	inputs: [
		{ name: 'p', type: 'vec2' }
	]
} );

const mx_cell_noise_float_2 = /*@__PURE__*/ Fn( ( [ p_immutable ] ) => {

	const p = vec3( p_immutable ).toVar();
	const ix = int( mx_floor( p.x ) ).toVar();
	const iy = int( mx_floor( p.y ) ).toVar();
	const iz = int( mx_floor( p.z ) ).toVar();

	return mx_bits_to_01( mx_hash_int( ix, iy, iz ) );

} ).setLayout( {
	name: 'mx_cell_noise_float_2',
	type: 'float',
	inputs: [
		{ name: 'p', type: 'vec3' }
	]
} );

const mx_cell_noise_float_3 = /*@__PURE__*/ Fn( ( [ p_immutable ] ) => {

	const p = vec4( p_immutable ).toVar();
	const ix = int( mx_floor( p.x ) ).toVar();
	const iy = int( mx_floor( p.y ) ).toVar();
	const iz = int( mx_floor( p.z ) ).toVar();
	const iw = int( mx_floor( p.w ) ).toVar();

	return mx_bits_to_01( mx_hash_int( ix, iy, iz, iw ) );

} ).setLayout( {
	name: 'mx_cell_noise_float_3',
	type: 'float',
	inputs: [
		{ name: 'p', type: 'vec4' }
	]
} );

const mx_cell_noise_float$1 = /*@__PURE__*/ overloadingFn( [ mx_cell_noise_float_0, mx_cell_noise_float_1, mx_cell_noise_float_2, mx_cell_noise_float_3 ] );

const mx_cell_noise_vec3_0 = /*@__PURE__*/ Fn( ( [ p_immutable ] ) => {

	const p = float( p_immutable ).toVar();
	const ix = int( mx_floor( p ) ).toVar();

	return vec3( mx_bits_to_01( mx_hash_int( ix, int( 0 ) ) ), mx_bits_to_01( mx_hash_int( ix, int( 1 ) ) ), mx_bits_to_01( mx_hash_int( ix, int( 2 ) ) ) );

} ).setLayout( {
	name: 'mx_cell_noise_vec3_0',
	type: 'vec3',
	inputs: [
		{ name: 'p', type: 'float' }
	]
} );

const mx_cell_noise_vec3_1 = /*@__PURE__*/ Fn( ( [ p_immutable ] ) => {

	const p = vec2( p_immutable ).toVar();
	const ix = int( mx_floor( p.x ) ).toVar();
	const iy = int( mx_floor( p.y ) ).toVar();

	return vec3( mx_bits_to_01( mx_hash_int( ix, iy, int( 0 ) ) ), mx_bits_to_01( mx_hash_int( ix, iy, int( 1 ) ) ), mx_bits_to_01( mx_hash_int( ix, iy, int( 2 ) ) ) );

} ).setLayout( {
	name: 'mx_cell_noise_vec3_1',
	type: 'vec3',
	inputs: [
		{ name: 'p', type: 'vec2' }
	]
} );

const mx_cell_noise_vec3_2 = /*@__PURE__*/ Fn( ( [ p_immutable ] ) => {

	const p = vec3( p_immutable ).toVar();
	const ix = int( mx_floor( p.x ) ).toVar();
	const iy = int( mx_floor( p.y ) ).toVar();
	const iz = int( mx_floor( p.z ) ).toVar();

	return vec3( mx_bits_to_01( mx_hash_int( ix, iy, iz, int( 0 ) ) ), mx_bits_to_01( mx_hash_int( ix, iy, iz, int( 1 ) ) ), mx_bits_to_01( mx_hash_int( ix, iy, iz, int( 2 ) ) ) );

} ).setLayout( {
	name: 'mx_cell_noise_vec3_2',
	type: 'vec3',
	inputs: [
		{ name: 'p', type: 'vec3' }
	]
} );

const mx_cell_noise_vec3_3 = /*@__PURE__*/ Fn( ( [ p_immutable ] ) => {

	const p = vec4( p_immutable ).toVar();
	const ix = int( mx_floor( p.x ) ).toVar();
	const iy = int( mx_floor( p.y ) ).toVar();
	const iz = int( mx_floor( p.z ) ).toVar();
	const iw = int( mx_floor( p.w ) ).toVar();

	return vec3( mx_bits_to_01( mx_hash_int( ix, iy, iz, iw, int( 0 ) ) ), mx_bits_to_01( mx_hash_int( ix, iy, iz, iw, int( 1 ) ) ), mx_bits_to_01( mx_hash_int( ix, iy, iz, iw, int( 2 ) ) ) );

} ).setLayout( {
	name: 'mx_cell_noise_vec3_3',
	type: 'vec3',
	inputs: [
		{ name: 'p', type: 'vec4' }
	]
} );

const mx_cell_noise_vec3 = /*@__PURE__*/ overloadingFn( [ mx_cell_noise_vec3_0, mx_cell_noise_vec3_1, mx_cell_noise_vec3_2, mx_cell_noise_vec3_3 ] );

const mx_fractal_noise_float$1 = /*@__PURE__*/ Fn( ( [ p_immutable, octaves_immutable, lacunarity_immutable, diminish_immutable ] ) => {

	const diminish = float( diminish_immutable ).toVar();
	const lacunarity = float( lacunarity_immutable ).toVar();
	const octaves = int( octaves_immutable ).toVar();
	const p = vec3( p_immutable ).toVar();
	const result = float( 0.0 ).toVar();
	const amplitude = float( 1.0 ).toVar();

	Loop( octaves, () => {

		result.addAssign( amplitude.mul( mx_perlin_noise_float( p ) ) );
		amplitude.mulAssign( diminish );
		p.mulAssign( lacunarity );

	} );

	return result;

} ).setLayout( {
	name: 'mx_fractal_noise_float',
	type: 'float',
	inputs: [
		{ name: 'p', type: 'vec3' },
		{ name: 'octaves', type: 'int' },
		{ name: 'lacunarity', type: 'float' },
		{ name: 'diminish', type: 'float' }
	]
} );

const mx_fractal_noise_vec3$1 = /*@__PURE__*/ Fn( ( [ p_immutable, octaves_immutable, lacunarity_immutable, diminish_immutable ] ) => {

	const diminish = float( diminish_immutable ).toVar();
	const lacunarity = float( lacunarity_immutable ).toVar();
	const octaves = int( octaves_immutable ).toVar();
	const p = vec3( p_immutable ).toVar();
	const result = vec3( 0.0 ).toVar();
	const amplitude = float( 1.0 ).toVar();

	Loop( octaves, () => {

		result.addAssign( amplitude.mul( mx_perlin_noise_vec3( p ) ) );
		amplitude.mulAssign( diminish );
		p.mulAssign( lacunarity );

	} );

	return result;

} ).setLayout( {
	name: 'mx_fractal_noise_vec3',
	type: 'vec3',
	inputs: [
		{ name: 'p', type: 'vec3' },
		{ name: 'octaves', type: 'int' },
		{ name: 'lacunarity', type: 'float' },
		{ name: 'diminish', type: 'float' }
	]
} );

const mx_fractal_noise_vec2$1 = /*@__PURE__*/ Fn( ( [ p_immutable, octaves_immutable, lacunarity_immutable, diminish_immutable ] ) => {

	const diminish = float( diminish_immutable ).toVar();
	const lacunarity = float( lacunarity_immutable ).toVar();
	const octaves = int( octaves_immutable ).toVar();
	const p = vec3( p_immutable ).toVar();

	return vec2( mx_fractal_noise_float$1( p, octaves, lacunarity, diminish ), mx_fractal_noise_float$1( p.add( vec3( int( 19 ), int( 193 ), int( 17 ) ) ), octaves, lacunarity, diminish ) );

} ).setLayout( {
	name: 'mx_fractal_noise_vec2',
	type: 'vec2',
	inputs: [
		{ name: 'p', type: 'vec3' },
		{ name: 'octaves', type: 'int' },
		{ name: 'lacunarity', type: 'float' },
		{ name: 'diminish', type: 'float' }
	]
} );

const mx_fractal_noise_vec4$1 = /*@__PURE__*/ Fn( ( [ p_immutable, octaves_immutable, lacunarity_immutable, diminish_immutable ] ) => {

	const diminish = float( diminish_immutable ).toVar();
	const lacunarity = float( lacunarity_immutable ).toVar();
	const octaves = int( octaves_immutable ).toVar();
	const p = vec3( p_immutable ).toVar();
	const c = vec3( mx_fractal_noise_vec3$1( p, octaves, lacunarity, diminish ) ).toVar();
	const f = float( mx_fractal_noise_float$1( p.add( vec3( int( 19 ), int( 193 ), int( 17 ) ) ), octaves, lacunarity, diminish ) ).toVar();

	return vec4( c, f );

} ).setLayout( {
	name: 'mx_fractal_noise_vec4',
	type: 'vec4',
	inputs: [
		{ name: 'p', type: 'vec3' },
		{ name: 'octaves', type: 'int' },
		{ name: 'lacunarity', type: 'float' },
		{ name: 'diminish', type: 'float' }
	]
} );

const mx_worley_distance_0 = /*@__PURE__*/ Fn( ( [ p_immutable, x_immutable, y_immutable, xoff_immutable, yoff_immutable, jitter_immutable, metric_immutable ] ) => {

	const metric = int( metric_immutable ).toVar();
	const jitter = float( jitter_immutable ).toVar();
	const yoff = int( yoff_immutable ).toVar();
	const xoff = int( xoff_immutable ).toVar();
	const y = int( y_immutable ).toVar();
	const x = int( x_immutable ).toVar();
	const p = vec2( p_immutable ).toVar();
	const tmp = vec3( mx_cell_noise_vec3( vec2( x.add( xoff ), y.add( yoff ) ) ) ).toVar();
	const off = vec2( tmp.x, tmp.y ).toVar();
	off.subAssign( 0.5 );
	off.mulAssign( jitter );
	off.addAssign( 0.5 );
	const cellpos = vec2( vec2( float( x ), float( y ) ).add( off ) ).toVar();
	const diff = vec2( cellpos.sub( p ) ).toVar();

	If( metric.equal( int( 2 ) ), () => {

		return abs( diff.x ).add( abs( diff.y ) );

	} );

	If( metric.equal( int( 3 ) ), () => {

		return max$1( abs( diff.x ), abs( diff.y ) );

	} );

	return dot( diff, diff );

} ).setLayout( {
	name: 'mx_worley_distance_0',
	type: 'float',
	inputs: [
		{ name: 'p', type: 'vec2' },
		{ name: 'x', type: 'int' },
		{ name: 'y', type: 'int' },
		{ name: 'xoff', type: 'int' },
		{ name: 'yoff', type: 'int' },
		{ name: 'jitter', type: 'float' },
		{ name: 'metric', type: 'int' }
	]
} );

const mx_worley_distance_1 = /*@__PURE__*/ Fn( ( [ p_immutable, x_immutable, y_immutable, z_immutable, xoff_immutable, yoff_immutable, zoff_immutable, jitter_immutable, metric_immutable ] ) => {

	const metric = int( metric_immutable ).toVar();
	const jitter = float( jitter_immutable ).toVar();
	const zoff = int( zoff_immutable ).toVar();
	const yoff = int( yoff_immutable ).toVar();
	const xoff = int( xoff_immutable ).toVar();
	const z = int( z_immutable ).toVar();
	const y = int( y_immutable ).toVar();
	const x = int( x_immutable ).toVar();
	const p = vec3( p_immutable ).toVar();
	const off = vec3( mx_cell_noise_vec3( vec3( x.add( xoff ), y.add( yoff ), z.add( zoff ) ) ) ).toVar();
	off.subAssign( 0.5 );
	off.mulAssign( jitter );
	off.addAssign( 0.5 );
	const cellpos = vec3( vec3( float( x ), float( y ), float( z ) ).add( off ) ).toVar();
	const diff = vec3( cellpos.sub( p ) ).toVar();

	If( metric.equal( int( 2 ) ), () => {

		return abs( diff.x ).add( abs( diff.y ) ).add( abs( diff.z ) );

	} );

	If( metric.equal( int( 3 ) ), () => {

		return max$1( max$1( abs( diff.x ), abs( diff.y ) ), abs( diff.z ) );

	} );

	return dot( diff, diff );

} ).setLayout( {
	name: 'mx_worley_distance_1',
	type: 'float',
	inputs: [
		{ name: 'p', type: 'vec3' },
		{ name: 'x', type: 'int' },
		{ name: 'y', type: 'int' },
		{ name: 'z', type: 'int' },
		{ name: 'xoff', type: 'int' },
		{ name: 'yoff', type: 'int' },
		{ name: 'zoff', type: 'int' },
		{ name: 'jitter', type: 'float' },
		{ name: 'metric', type: 'int' }
	]
} );

const mx_worley_distance = /*@__PURE__*/ overloadingFn( [ mx_worley_distance_0, mx_worley_distance_1 ] );

const mx_worley_noise_float_0 = /*@__PURE__*/ Fn( ( [ p_immutable, jitter_immutable, metric_immutable ] ) => {

	const metric = int( metric_immutable ).toVar();
	const jitter = float( jitter_immutable ).toVar();
	const p = vec2( p_immutable ).toVar();
	const X = int().toVar(), Y = int().toVar();
	const localpos = vec2( mx_floorfrac( p.x, X ), mx_floorfrac( p.y, Y ) ).toVar();
	const sqdist = float( 1e6 ).toVar();

	Loop( { start: - 1, end: int( 1 ), name: 'x', condition: '<=' }, ( { x } ) => {

		Loop( { start: - 1, end: int( 1 ), name: 'y', condition: '<=' }, ( { y } ) => {

			const dist = float( mx_worley_distance( localpos, x, y, X, Y, jitter, metric ) ).toVar();
			sqdist.assign( min$1( sqdist, dist ) );

		} );

	} );

	If( metric.equal( int( 0 ) ), () => {

		sqdist.assign( sqrt( sqdist ) );

	} );

	return sqdist;

} ).setLayout( {
	name: 'mx_worley_noise_float_0',
	type: 'float',
	inputs: [
		{ name: 'p', type: 'vec2' },
		{ name: 'jitter', type: 'float' },
		{ name: 'metric', type: 'int' }
	]
} );

const mx_worley_noise_vec2_0 = /*@__PURE__*/ Fn( ( [ p_immutable, jitter_immutable, metric_immutable ] ) => {

	const metric = int( metric_immutable ).toVar();
	const jitter = float( jitter_immutable ).toVar();
	const p = vec2( p_immutable ).toVar();
	const X = int().toVar(), Y = int().toVar();
	const localpos = vec2( mx_floorfrac( p.x, X ), mx_floorfrac( p.y, Y ) ).toVar();
	const sqdist = vec2( 1e6, 1e6 ).toVar();

	Loop( { start: - 1, end: int( 1 ), name: 'x', condition: '<=' }, ( { x } ) => {

		Loop( { start: - 1, end: int( 1 ), name: 'y', condition: '<=' }, ( { y } ) => {

			const dist = float( mx_worley_distance( localpos, x, y, X, Y, jitter, metric ) ).toVar();

			If( dist.lessThan( sqdist.x ), () => {

				sqdist.y.assign( sqdist.x );
				sqdist.x.assign( dist );

			} ).ElseIf( dist.lessThan( sqdist.y ), () => {

				sqdist.y.assign( dist );

			} );

		} );

	} );

	If( metric.equal( int( 0 ) ), () => {

		sqdist.assign( sqrt( sqdist ) );

	} );

	return sqdist;

} ).setLayout( {
	name: 'mx_worley_noise_vec2_0',
	type: 'vec2',
	inputs: [
		{ name: 'p', type: 'vec2' },
		{ name: 'jitter', type: 'float' },
		{ name: 'metric', type: 'int' }
	]
} );

const mx_worley_noise_vec3_0 = /*@__PURE__*/ Fn( ( [ p_immutable, jitter_immutable, metric_immutable ] ) => {

	const metric = int( metric_immutable ).toVar();
	const jitter = float( jitter_immutable ).toVar();
	const p = vec2( p_immutable ).toVar();
	const X = int().toVar(), Y = int().toVar();
	const localpos = vec2( mx_floorfrac( p.x, X ), mx_floorfrac( p.y, Y ) ).toVar();
	const sqdist = vec3( 1e6, 1e6, 1e6 ).toVar();

	Loop( { start: - 1, end: int( 1 ), name: 'x', condition: '<=' }, ( { x } ) => {

		Loop( { start: - 1, end: int( 1 ), name: 'y', condition: '<=' }, ( { y } ) => {

			const dist = float( mx_worley_distance( localpos, x, y, X, Y, jitter, metric ) ).toVar();

			If( dist.lessThan( sqdist.x ), () => {

				sqdist.z.assign( sqdist.y );
				sqdist.y.assign( sqdist.x );
				sqdist.x.assign( dist );

			} ).ElseIf( dist.lessThan( sqdist.y ), () => {

				sqdist.z.assign( sqdist.y );
				sqdist.y.assign( dist );

			} ).ElseIf( dist.lessThan( sqdist.z ), () => {

				sqdist.z.assign( dist );

			} );

		} );

	} );

	If( metric.equal( int( 0 ) ), () => {

		sqdist.assign( sqrt( sqdist ) );

	} );

	return sqdist;

} ).setLayout( {
	name: 'mx_worley_noise_vec3_0',
	type: 'vec3',
	inputs: [
		{ name: 'p', type: 'vec2' },
		{ name: 'jitter', type: 'float' },
		{ name: 'metric', type: 'int' }
	]
} );

const mx_worley_noise_float_1 = /*@__PURE__*/ Fn( ( [ p_immutable, jitter_immutable, metric_immutable ] ) => {

	const metric = int( metric_immutable ).toVar();
	const jitter = float( jitter_immutable ).toVar();
	const p = vec3( p_immutable ).toVar();
	const X = int().toVar(), Y = int().toVar(), Z = int().toVar();
	const localpos = vec3( mx_floorfrac( p.x, X ), mx_floorfrac( p.y, Y ), mx_floorfrac( p.z, Z ) ).toVar();
	const sqdist = float( 1e6 ).toVar();

	Loop( { start: - 1, end: int( 1 ), name: 'x', condition: '<=' }, ( { x } ) => {

		Loop( { start: - 1, end: int( 1 ), name: 'y', condition: '<=' }, ( { y } ) => {

			Loop( { start: - 1, end: int( 1 ), name: 'z', condition: '<=' }, ( { z } ) => {

				const dist = float( mx_worley_distance( localpos, x, y, z, X, Y, Z, jitter, metric ) ).toVar();
				sqdist.assign( min$1( sqdist, dist ) );

			} );

		} );

	} );

	If( metric.equal( int( 0 ) ), () => {

		sqdist.assign( sqrt( sqdist ) );

	} );

	return sqdist;

} ).setLayout( {
	name: 'mx_worley_noise_float_1',
	type: 'float',
	inputs: [
		{ name: 'p', type: 'vec3' },
		{ name: 'jitter', type: 'float' },
		{ name: 'metric', type: 'int' }
	]
} );

const mx_worley_noise_float$1 = /*@__PURE__*/ overloadingFn( [ mx_worley_noise_float_0, mx_worley_noise_float_1 ] );

const mx_worley_noise_vec2_1 = /*@__PURE__*/ Fn( ( [ p_immutable, jitter_immutable, metric_immutable ] ) => {

	const metric = int( metric_immutable ).toVar();
	const jitter = float( jitter_immutable ).toVar();
	const p = vec3( p_immutable ).toVar();
	const X = int().toVar(), Y = int().toVar(), Z = int().toVar();
	const localpos = vec3( mx_floorfrac( p.x, X ), mx_floorfrac( p.y, Y ), mx_floorfrac( p.z, Z ) ).toVar();
	const sqdist = vec2( 1e6, 1e6 ).toVar();

	Loop( { start: - 1, end: int( 1 ), name: 'x', condition: '<=' }, ( { x } ) => {

		Loop( { start: - 1, end: int( 1 ), name: 'y', condition: '<=' }, ( { y } ) => {

			Loop( { start: - 1, end: int( 1 ), name: 'z', condition: '<=' }, ( { z } ) => {

				const dist = float( mx_worley_distance( localpos, x, y, z, X, Y, Z, jitter, metric ) ).toVar();

				If( dist.lessThan( sqdist.x ), () => {

					sqdist.y.assign( sqdist.x );
					sqdist.x.assign( dist );

				} ).ElseIf( dist.lessThan( sqdist.y ), () => {

					sqdist.y.assign( dist );

				} );

			} );

		} );

	} );

	If( metric.equal( int( 0 ) ), () => {

		sqdist.assign( sqrt( sqdist ) );

	} );

	return sqdist;

} ).setLayout( {
	name: 'mx_worley_noise_vec2_1',
	type: 'vec2',
	inputs: [
		{ name: 'p', type: 'vec3' },
		{ name: 'jitter', type: 'float' },
		{ name: 'metric', type: 'int' }
	]
} );

const mx_worley_noise_vec2$1 = /*@__PURE__*/ overloadingFn( [ mx_worley_noise_vec2_0, mx_worley_noise_vec2_1 ] );

const mx_worley_noise_vec3_1 = /*@__PURE__*/ Fn( ( [ p_immutable, jitter_immutable, metric_immutable ] ) => {

	const metric = int( metric_immutable ).toVar();
	const jitter = float( jitter_immutable ).toVar();
	const p = vec3( p_immutable ).toVar();
	const X = int().toVar(), Y = int().toVar(), Z = int().toVar();
	const localpos = vec3( mx_floorfrac( p.x, X ), mx_floorfrac( p.y, Y ), mx_floorfrac( p.z, Z ) ).toVar();
	const sqdist = vec3( 1e6, 1e6, 1e6 ).toVar();

	Loop( { start: - 1, end: int( 1 ), name: 'x', condition: '<=' }, ( { x } ) => {

		Loop( { start: - 1, end: int( 1 ), name: 'y', condition: '<=' }, ( { y } ) => {

			Loop( { start: - 1, end: int( 1 ), name: 'z', condition: '<=' }, ( { z } ) => {

				const dist = float( mx_worley_distance( localpos, x, y, z, X, Y, Z, jitter, metric ) ).toVar();

				If( dist.lessThan( sqdist.x ), () => {

					sqdist.z.assign( sqdist.y );
					sqdist.y.assign( sqdist.x );
					sqdist.x.assign( dist );

				} ).ElseIf( dist.lessThan( sqdist.y ), () => {

					sqdist.z.assign( sqdist.y );
					sqdist.y.assign( dist );

				} ).ElseIf( dist.lessThan( sqdist.z ), () => {

					sqdist.z.assign( dist );

				} );

			} );

		} );

	} );

	If( metric.equal( int( 0 ) ), () => {

		sqdist.assign( sqrt( sqdist ) );

	} );

	return sqdist;

} ).setLayout( {
	name: 'mx_worley_noise_vec3_1',
	type: 'vec3',
	inputs: [
		{ name: 'p', type: 'vec3' },
		{ name: 'jitter', type: 'float' },
		{ name: 'metric', type: 'int' }
	]
} );

const mx_worley_noise_vec3$1 = /*@__PURE__*/ overloadingFn( [ mx_worley_noise_vec3_0, mx_worley_noise_vec3_1 ] );

// Three.js Transpiler
// https://github.com/AcademySoftwareFoundation/MaterialX/blob/main/libraries/stdlib/genglsl/lib/mx_hsv.glsl


const mx_hsvtorgb = /*@__PURE__*/ Fn( ( [ hsv ] ) => {

	const s = hsv.y;
	const v = hsv.z;

	const result = vec3().toVar();

	If( s.lessThan( 0.0001 ), () => {

		result.assign( vec3( v, v, v ) );

	} ).Else( () => {

		let h = hsv.x;
		h = h.sub( floor( h ) ).mul( 6.0 ).toVar(); // TODO: check what .toVar() is needed in node system cache
		const hi = int( trunc( h ) );
		const f = h.sub( float( hi ) );
		const p = v.mul( s.oneMinus() );
		const q = v.mul( s.mul( f ).oneMinus() );
		const t = v.mul( s.mul( f.oneMinus() ).oneMinus() );

		If( hi.equal( int( 0 ) ), () => {

			result.assign( vec3( v, t, p ) );

		} ).ElseIf( hi.equal( int( 1 ) ), () => {

			result.assign( vec3( q, v, p ) );

		} ).ElseIf( hi.equal( int( 2 ) ), () => {

			result.assign( vec3( p, v, t ) );

		} ).ElseIf( hi.equal( int( 3 ) ), () => {

			result.assign( vec3( p, q, v ) );

		} ).ElseIf( hi.equal( int( 4 ) ), () => {

			result.assign( vec3( t, p, v ) );

		} ).Else( () => {

			result.assign( vec3( v, p, q ) );

		} );

	} );

	return result;

} ).setLayout( {
	name: 'mx_hsvtorgb',
	type: 'vec3',
	inputs: [
		{ name: 'hsv', type: 'vec3' }
	]
} );

const mx_rgbtohsv = /*@__PURE__*/ Fn( ( [ c_immutable ] ) => {

	const c = vec3( c_immutable ).toVar();
	const r = float( c.x ).toVar();
	const g = float( c.y ).toVar();
	const b = float( c.z ).toVar();
	const mincomp = float( min$1( r, min$1( g, b ) ) ).toVar();
	const maxcomp = float( max$1( r, max$1( g, b ) ) ).toVar();
	const delta = float( maxcomp.sub( mincomp ) ).toVar();
	const h = float().toVar(), s = float().toVar(), v = float().toVar();
	v.assign( maxcomp );

	If( maxcomp.greaterThan( 0.0 ), () => {

		s.assign( delta.div( maxcomp ) );

	} ).Else( () => {

		s.assign( 0.0 );

	} );

	If( s.lessThanEqual( 0.0 ), () => {

		h.assign( 0.0 );

	} ).Else( () => {

		If( r.greaterThanEqual( maxcomp ), () => {

			h.assign( g.sub( b ).div( delta ) );

		} ).ElseIf( g.greaterThanEqual( maxcomp ), () => {

			h.assign( add( 2.0, b.sub( r ).div( delta ) ) );

		} ).Else( () => {

			h.assign( add( 4.0, r.sub( g ).div( delta ) ) );

		} );

		h.mulAssign( 1.0 / 6.0 );

		If( h.lessThan( 0.0 ), () => {

			h.addAssign( 1.0 );

		} );

	} );

	return vec3( h, s, v );

} ).setLayout( {
	name: 'mx_rgbtohsv',
	type: 'vec3',
	inputs: [
		{ name: 'c', type: 'vec3' }
	]
} );

// Three.js Transpiler
// https://github.com/AcademySoftwareFoundation/MaterialX/blob/main/libraries/stdlib/genglsl/lib/mx_transform_color.glsl


const mx_srgb_texture_to_lin_rec709 = /*@__PURE__*/ Fn( ( [ color_immutable ] ) => {

	const color = vec3( color_immutable ).toVar();
	const isAbove = bvec3( greaterThan( color, vec3( 0.04045 ) ) ).toVar();
	const linSeg = vec3( color.div( 12.92 ) ).toVar();
	const powSeg = vec3( pow( max$1( color.add( vec3( 0.055 ) ), vec3( 0.0 ) ).div( 1.055 ), vec3( 2.4 ) ) ).toVar();

	return mix( linSeg, powSeg, isAbove );

} ).setLayout( {
	name: 'mx_srgb_texture_to_lin_rec709',
	type: 'vec3',
	inputs: [
		{ name: 'color', type: 'vec3' }
	]
} );

const mx_aastep = ( threshold, value ) => {

	threshold = float( threshold );
	value = float( value );

	const afwidth = vec2( value.dFdx(), value.dFdy() ).length().mul( 0.70710678118654757 );

	return smoothstep( threshold.sub( afwidth ), threshold.add( afwidth ), value );

};

const _ramp = ( a, b, uv, p ) => mix( a, b, uv[ p ].clamp() );
const mx_ramplr = ( valuel, valuer, texcoord = uv() ) => _ramp( valuel, valuer, texcoord, 'x' );
const mx_ramptb = ( valuet, valueb, texcoord = uv() ) => _ramp( valuet, valueb, texcoord, 'y' );

const _split = ( a, b, center, uv, p ) => mix( a, b, mx_aastep( center, uv[ p ] ) );
const mx_splitlr = ( valuel, valuer, center, texcoord = uv() ) => _split( valuel, valuer, center, texcoord, 'x' );
const mx_splittb = ( valuet, valueb, center, texcoord = uv() ) => _split( valuet, valueb, center, texcoord, 'y' );

const mx_transform_uv = ( uv_scale = 1, uv_offset = 0, uv_geo = uv() ) => uv_geo.mul( uv_scale ).add( uv_offset );

const mx_safepower = ( in1, in2 = 1 ) => {

	in1 = float( in1 );

	return in1.abs().pow( in2 ).mul( in1.sign() );

};

const mx_contrast = ( input, amount = 1, pivot = .5 ) => float( input ).sub( pivot ).mul( amount ).add( pivot );

const mx_noise_float = ( texcoord = uv(), amplitude = 1, pivot = 0 ) => mx_perlin_noise_float( texcoord.convert( 'vec2|vec3' ) ).mul( amplitude ).add( pivot );
//export const mx_noise_vec2 = ( texcoord = uv(), amplitude = 1, pivot = 0 ) => mx_perlin_noise_vec3( texcoord.convert( 'vec2|vec3' ) ).mul( amplitude ).add( pivot );
const mx_noise_vec3 = ( texcoord = uv(), amplitude = 1, pivot = 0 ) => mx_perlin_noise_vec3( texcoord.convert( 'vec2|vec3' ) ).mul( amplitude ).add( pivot );
const mx_noise_vec4 = ( texcoord = uv(), amplitude = 1, pivot = 0 ) => {

	texcoord = texcoord.convert( 'vec2|vec3' ); // overloading type

	const noise_vec4 = vec4( mx_perlin_noise_vec3( texcoord ), mx_perlin_noise_float( texcoord.add( vec2( 19, 73 ) ) ) );

	return noise_vec4.mul( amplitude ).add( pivot );

};

const mx_worley_noise_float = ( texcoord = uv(), jitter = 1 ) => mx_worley_noise_float$1( texcoord.convert( 'vec2|vec3' ), jitter, int( 1 ) );
const mx_worley_noise_vec2 = ( texcoord = uv(), jitter = 1 ) => mx_worley_noise_vec2$1( texcoord.convert( 'vec2|vec3' ), jitter, int( 1 ) );
const mx_worley_noise_vec3 = ( texcoord = uv(), jitter = 1 ) => mx_worley_noise_vec3$1( texcoord.convert( 'vec2|vec3' ), jitter, int( 1 ) );

const mx_cell_noise_float = ( texcoord = uv() ) => mx_cell_noise_float$1( texcoord.convert( 'vec2|vec3' ) );

const mx_fractal_noise_float = ( position = uv(), octaves = 3, lacunarity = 2, diminish = .5, amplitude = 1 ) => mx_fractal_noise_float$1( position, int( octaves ), lacunarity, diminish ).mul( amplitude );
const mx_fractal_noise_vec2 = ( position = uv(), octaves = 3, lacunarity = 2, diminish = .5, amplitude = 1 ) => mx_fractal_noise_vec2$1( position, int( octaves ), lacunarity, diminish ).mul( amplitude );
const mx_fractal_noise_vec3 = ( position = uv(), octaves = 3, lacunarity = 2, diminish = .5, amplitude = 1 ) => mx_fractal_noise_vec3$1( position, int( octaves ), lacunarity, diminish ).mul( amplitude );
const mx_fractal_noise_vec4 = ( position = uv(), octaves = 3, lacunarity = 2, diminish = .5, amplitude = 1 ) => mx_fractal_noise_vec4$1( position, int( octaves ), lacunarity, diminish ).mul( amplitude );

// https://devlog-martinsh.blogspot.com/2011/09/box-projected-cube-environment-mapping.html

const getParallaxCorrectNormal = /*@__PURE__*/ Fn( ( [ normal, cubeSize, cubePos ] ) => {

	const nDir = normalize( normal ).toVar( 'nDir' );
	const rbmax = sub( float( 0.5 ).mul( cubeSize.sub( cubePos ) ), positionWorld ).div( nDir ).toVar( 'rbmax' );
	const rbmin = sub( float( - 0.5 ).mul( cubeSize.sub( cubePos ) ), positionWorld ).div( nDir ).toVar( 'rbmin' );
	const rbminmax = vec3().toVar( 'rbminmax' );
	rbminmax.x = nDir.x.greaterThan( float( 0 ) ).select( rbmax.x, rbmin.x );
	rbminmax.y = nDir.y.greaterThan( float( 0 ) ).select( rbmax.y, rbmin.y );
	rbminmax.z = nDir.z.greaterThan( float( 0 ) ).select( rbmax.z, rbmin.z );

	const correction = min$1( min$1( rbminmax.x, rbminmax.y ), rbminmax.z ).toVar( 'correction' );
	const boxIntersection = positionWorld.add( nDir.mul( correction ) ).toVar( 'boxIntersection' );
	return boxIntersection.sub( cubePos );

} );

const getShIrradianceAt = /*@__PURE__*/ Fn( ( [ normal, shCoefficients ] ) => {

	// normal is assumed to have unit length

	const x = normal.x, y = normal.y, z = normal.z;

	// band 0
	let result = shCoefficients.element( 0 ).mul( 0.886227 );

	// band 1
	result = result.add( shCoefficients.element( 1 ).mul( 2.0 * 0.511664 ).mul( y ) );
	result = result.add( shCoefficients.element( 2 ).mul( 2.0 * 0.511664 ).mul( z ) );
	result = result.add( shCoefficients.element( 3 ).mul( 2.0 * 0.511664 ).mul( x ) );

	// band 2
	result = result.add( shCoefficients.element( 4 ).mul( 2.0 * 0.429043 ).mul( x ).mul( y ) );
	result = result.add( shCoefficients.element( 5 ).mul( 2.0 * 0.429043 ).mul( y ).mul( z ) );
	result = result.add( shCoefficients.element( 6 ).mul( z.mul( z ).mul( 0.743125 ).sub( 0.247708 ) ) );
	result = result.add( shCoefficients.element( 7 ).mul( 2.0 * 0.429043 ).mul( x ).mul( z ) );
	result = result.add( shCoefficients.element( 8 ).mul( 0.429043 ).mul( mul( x, x ).sub( mul( y, y ) ) ) );

	return result;

} );

// constants

var TSL = /*#__PURE__*/Object.freeze({
	__proto__: null,
	BRDF_GGX: BRDF_GGX,
	BRDF_Lambert: BRDF_Lambert,
	BasicShadowFilter: BasicShadowFilter,
	Break: Break,
	Continue: Continue,
	DFGApprox: DFGApprox,
	D_GGX: D_GGX,
	Discard: Discard,
	EPSILON: EPSILON,
	F_Schlick: F_Schlick,
	Fn: Fn,
	INFINITY: INFINITY,
	If: If,
	Loop: Loop,
	NodeAccess: NodeAccess,
	NodeShaderStage: NodeShaderStage,
	NodeType: NodeType,
	NodeUpdateType: NodeUpdateType,
	PCFShadowFilter: PCFShadowFilter,
	PCFSoftShadowFilter: PCFSoftShadowFilter,
	PI: PI,
	PI2: PI2,
	Return: Return,
	Schlick_to_F0: Schlick_to_F0,
	ScriptableNodeResources: ScriptableNodeResources,
	ShaderNode: ShaderNode,
	TBNViewMatrix: TBNViewMatrix,
	VSMShadowFilter: VSMShadowFilter,
	V_GGX_SmithCorrelated: V_GGX_SmithCorrelated,
	abs: abs,
	acesFilmicToneMapping: acesFilmicToneMapping,
	acos: acos,
	add: add,
	addMethodChaining: addMethodChaining,
	addNodeElement: addNodeElement,
	agxToneMapping: agxToneMapping,
	all: all,
	alphaT: alphaT,
	and: and,
	anisotropy: anisotropy,
	anisotropyB: anisotropyB,
	anisotropyT: anisotropyT,
	any: any,
	append: append,
	arrayBuffer: arrayBuffer,
	asin: asin,
	assign: assign,
	atan: atan,
	atan2: atan2,
	atomicAdd: atomicAdd,
	atomicAnd: atomicAnd,
	atomicFunc: atomicFunc,
	atomicMax: atomicMax,
	atomicMin: atomicMin,
	atomicOr: atomicOr,
	atomicStore: atomicStore,
	atomicSub: atomicSub,
	atomicXor: atomicXor,
	attenuationColor: attenuationColor,
	attenuationDistance: attenuationDistance,
	attribute: attribute,
	attributeArray: attributeArray,
	backgroundBlurriness: backgroundBlurriness,
	backgroundIntensity: backgroundIntensity,
	backgroundRotation: backgroundRotation,
	batch: batch,
	billboarding: billboarding,
	bitAnd: bitAnd,
	bitNot: bitNot,
	bitOr: bitOr,
	bitXor: bitXor,
	bitangentGeometry: bitangentGeometry,
	bitangentLocal: bitangentLocal,
	bitangentView: bitangentView,
	bitangentWorld: bitangentWorld,
	bitcast: bitcast,
	blendBurn: blendBurn,
	blendColor: blendColor,
	blendDodge: blendDodge,
	blendOverlay: blendOverlay,
	blendScreen: blendScreen,
	blur: blur,
	bool: bool,
	buffer: buffer,
	bufferAttribute: bufferAttribute,
	bumpMap: bumpMap,
	burn: burn,
	bvec2: bvec2,
	bvec3: bvec3,
	bvec4: bvec4,
	bypass: bypass,
	cache: cache,
	call: call,
	cameraFar: cameraFar,
	cameraNear: cameraNear,
	cameraNormalMatrix: cameraNormalMatrix,
	cameraPosition: cameraPosition,
	cameraProjectionMatrix: cameraProjectionMatrix,
	cameraProjectionMatrixInverse: cameraProjectionMatrixInverse,
	cameraViewMatrix: cameraViewMatrix,
	cameraWorldMatrix: cameraWorldMatrix,
	cbrt: cbrt,
	cdl: cdl,
	ceil: ceil,
	checker: checker,
	cineonToneMapping: cineonToneMapping,
	clamp: clamp,
	clearcoat: clearcoat,
	clearcoatRoughness: clearcoatRoughness,
	code: code,
	color: color,
	colorSpaceToWorking: colorSpaceToWorking,
	colorToDirection: colorToDirection,
	compute: compute,
	cond: cond,
	context: context,
	convert: convert,
	convertColorSpace: convertColorSpace,
	convertToTexture: convertToTexture,
	cos: cos,
	cross: cross,
	cubeTexture: cubeTexture,
	dFdx: dFdx,
	dFdy: dFdy,
	dashSize: dashSize,
	defaultBuildStages: defaultBuildStages,
	defaultShaderStages: defaultShaderStages,
	defined: defined,
	degrees: degrees,
	deltaTime: deltaTime,
	densityFog: densityFog,
	densityFogFactor: densityFogFactor,
	depth: depth,
	depthPass: depthPass,
	difference: difference,
	diffuseColor: diffuseColor,
	directPointLight: directPointLight,
	directionToColor: directionToColor,
	dispersion: dispersion,
	distance: distance,
	div: div,
	dodge: dodge,
	dot: dot,
	drawIndex: drawIndex,
	dynamicBufferAttribute: dynamicBufferAttribute,
	element: element,
	emissive: emissive,
	equal: equal,
	equals: equals,
	equirectUV: equirectUV,
	exp: exp,
	exp2: exp2,
	expression: expression,
	faceDirection: faceDirection,
	faceForward: faceForward,
	float: float,
	floor: floor,
	fog: fog,
	fract: fract,
	frameGroup: frameGroup,
	frameId: frameId,
	frontFacing: frontFacing,
	fwidth: fwidth,
	gain: gain,
	gapSize: gapSize,
	getConstNodeType: getConstNodeType,
	getCurrentStack: getCurrentStack,
	getDirection: getDirection,
	getDistanceAttenuation: getDistanceAttenuation,
	getGeometryRoughness: getGeometryRoughness,
	getNormalFromDepth: getNormalFromDepth,
	getParallaxCorrectNormal: getParallaxCorrectNormal,
	getRoughness: getRoughness,
	getScreenPosition: getScreenPosition,
	getShIrradianceAt: getShIrradianceAt,
	getTextureIndex: getTextureIndex,
	getViewPosition: getViewPosition,
	glsl: glsl,
	glslFn: glslFn,
	grayscale: grayscale,
	greaterThan: greaterThan,
	greaterThanEqual: greaterThanEqual,
	hash: hash,
	highpModelNormalViewMatrix: highpModelNormalViewMatrix,
	highpModelViewMatrix: highpModelViewMatrix,
	hue: hue,
	instance: instance,
	instanceIndex: instanceIndex,
	instancedArray: instancedArray,
	instancedBufferAttribute: instancedBufferAttribute,
	instancedDynamicBufferAttribute: instancedDynamicBufferAttribute,
	instancedMesh: instancedMesh,
	int: int,
	inverseSqrt: inverseSqrt,
	invocationLocalIndex: invocationLocalIndex,
	invocationSubgroupIndex: invocationSubgroupIndex,
	ior: ior,
	iridescence: iridescence,
	iridescenceIOR: iridescenceIOR,
	iridescenceThickness: iridescenceThickness,
	ivec2: ivec2,
	ivec3: ivec3,
	ivec4: ivec4,
	js: js,
	label: label,
	length: length,
	lengthSq: lengthSq,
	lessThan: lessThan,
	lessThanEqual: lessThanEqual,
	lightPosition: lightPosition,
	lightProjectionUV: lightProjectionUV,
	lightShadowMatrix: lightShadowMatrix,
	lightTargetDirection: lightTargetDirection,
	lightTargetPosition: lightTargetPosition,
	lightViewPosition: lightViewPosition,
	lightingContext: lightingContext,
	lights: lights,
	linearDepth: linearDepth,
	linearToneMapping: linearToneMapping,
	localId: localId,
	log: log,
	log2: log2,
	logarithmicDepthToViewZ: logarithmicDepthToViewZ,
	loop: loop,
	luminance: luminance,
	mat2: mat2,
	mat3: mat3,
	mat4: mat4,
	matcapUV: matcapUV,
	materialAOMap: materialAOMap,
	materialAlphaTest: materialAlphaTest,
	materialAnisotropy: materialAnisotropy,
	materialAnisotropyVector: materialAnisotropyVector,
	materialAttenuationColor: materialAttenuationColor,
	materialAttenuationDistance: materialAttenuationDistance,
	materialClearcoat: materialClearcoat,
	materialClearcoatNormal: materialClearcoatNormal,
	materialClearcoatRoughness: materialClearcoatRoughness,
	materialColor: materialColor,
	materialDispersion: materialDispersion,
	materialEmissive: materialEmissive,
	materialIOR: materialIOR,
	materialIridescence: materialIridescence,
	materialIridescenceIOR: materialIridescenceIOR,
	materialIridescenceThickness: materialIridescenceThickness,
	materialLightMap: materialLightMap,
	materialLineDashOffset: materialLineDashOffset,
	materialLineDashSize: materialLineDashSize,
	materialLineGapSize: materialLineGapSize,
	materialLineScale: materialLineScale,
	materialLineWidth: materialLineWidth,
	materialMetalness: materialMetalness,
	materialNormal: materialNormal,
	materialOpacity: materialOpacity,
	materialPointWidth: materialPointWidth,
	materialReference: materialReference,
	materialReflectivity: materialReflectivity,
	materialRefractionRatio: materialRefractionRatio,
	materialRotation: materialRotation,
	materialRoughness: materialRoughness,
	materialSheen: materialSheen,
	materialSheenRoughness: materialSheenRoughness,
	materialShininess: materialShininess,
	materialSpecular: materialSpecular,
	materialSpecularColor: materialSpecularColor,
	materialSpecularIntensity: materialSpecularIntensity,
	materialSpecularStrength: materialSpecularStrength,
	materialThickness: materialThickness,
	materialTransmission: materialTransmission,
	max: max$1,
	maxMipLevel: maxMipLevel,
	mediumpModelViewMatrix: mediumpModelViewMatrix,
	metalness: metalness,
	min: min$1,
	mix: mix,
	mixElement: mixElement,
	mod: mod,
	modInt: modInt,
	modelDirection: modelDirection,
	modelNormalMatrix: modelNormalMatrix,
	modelPosition: modelPosition,
	modelScale: modelScale,
	modelViewMatrix: modelViewMatrix,
	modelViewPosition: modelViewPosition,
	modelViewProjection: modelViewProjection,
	modelWorldMatrix: modelWorldMatrix,
	modelWorldMatrixInverse: modelWorldMatrixInverse,
	morphReference: morphReference,
	mrt: mrt,
	mul: mul,
	mx_aastep: mx_aastep,
	mx_cell_noise_float: mx_cell_noise_float,
	mx_contrast: mx_contrast,
	mx_fractal_noise_float: mx_fractal_noise_float,
	mx_fractal_noise_vec2: mx_fractal_noise_vec2,
	mx_fractal_noise_vec3: mx_fractal_noise_vec3,
	mx_fractal_noise_vec4: mx_fractal_noise_vec4,
	mx_hsvtorgb: mx_hsvtorgb,
	mx_noise_float: mx_noise_float,
	mx_noise_vec3: mx_noise_vec3,
	mx_noise_vec4: mx_noise_vec4,
	mx_ramplr: mx_ramplr,
	mx_ramptb: mx_ramptb,
	mx_rgbtohsv: mx_rgbtohsv,
	mx_safepower: mx_safepower,
	mx_splitlr: mx_splitlr,
	mx_splittb: mx_splittb,
	mx_srgb_texture_to_lin_rec709: mx_srgb_texture_to_lin_rec709,
	mx_transform_uv: mx_transform_uv,
	mx_worley_noise_float: mx_worley_noise_float,
	mx_worley_noise_vec2: mx_worley_noise_vec2,
	mx_worley_noise_vec3: mx_worley_noise_vec3,
	negate: negate,
	neutralToneMapping: neutralToneMapping,
	nodeArray: nodeArray,
	nodeImmutable: nodeImmutable,
	nodeObject: nodeObject,
	nodeObjects: nodeObjects,
	nodeProxy: nodeProxy,
	normalFlat: normalFlat,
	normalGeometry: normalGeometry,
	normalLocal: normalLocal,
	normalMap: normalMap,
	normalView: normalView,
	normalWorld: normalWorld,
	normalize: normalize,
	not: not,
	notEqual: notEqual,
	numWorkgroups: numWorkgroups,
	objectDirection: objectDirection,
	objectGroup: objectGroup,
	objectPosition: objectPosition,
	objectScale: objectScale,
	objectViewPosition: objectViewPosition,
	objectWorldMatrix: objectWorldMatrix,
	oneMinus: oneMinus,
	or: or,
	orthographicDepthToViewZ: orthographicDepthToViewZ,
	oscSawtooth: oscSawtooth,
	oscSine: oscSine,
	oscSquare: oscSquare,
	oscTriangle: oscTriangle,
	output: output,
	outputStruct: outputStruct,
	overlay: overlay,
	overloadingFn: overloadingFn,
	parabola: parabola,
	parallaxDirection: parallaxDirection,
	parallaxUV: parallaxUV,
	parameter: parameter,
	pass: pass,
	passTexture: passTexture,
	pcurve: pcurve,
	perspectiveDepthToViewZ: perspectiveDepthToViewZ,
	pmremTexture: pmremTexture,
	pointUV: pointUV,
	pointWidth: pointWidth,
	positionGeometry: positionGeometry,
	positionLocal: positionLocal,
	positionPrevious: positionPrevious,
	positionView: positionView,
	positionViewDirection: positionViewDirection,
	positionWorld: positionWorld,
	positionWorldDirection: positionWorldDirection,
	posterize: posterize,
	pow: pow,
	pow2: pow2,
	pow3: pow3,
	pow4: pow4,
	property: property,
	radians: radians,
	rand: rand,
	range: range,
	rangeFog: rangeFog,
	rangeFogFactor: rangeFogFactor,
	reciprocal: reciprocal,
	reference: reference,
	referenceBuffer: referenceBuffer,
	reflect: reflect,
	reflectVector: reflectVector,
	reflectView: reflectView,
	reflector: reflector,
	refract: refract,
	refractVector: refractVector,
	refractView: refractView,
	reinhardToneMapping: reinhardToneMapping,
	remainder: remainder,
	remap: remap,
	remapClamp: remapClamp,
	renderGroup: renderGroup,
	renderOutput: renderOutput,
	rendererReference: rendererReference,
	rotate: rotate,
	rotateUV: rotateUV,
	roughness: roughness,
	round: round,
	rtt: rtt,
	sRGBTransferEOTF: sRGBTransferEOTF,
	sRGBTransferOETF: sRGBTransferOETF,
	sampler: sampler,
	saturate: saturate,
	saturation: saturation,
	screen: screen,
	screenCoordinate: screenCoordinate,
	screenSize: screenSize,
	screenUV: screenUV,
	scriptable: scriptable,
	scriptableValue: scriptableValue,
	select: select,
	setCurrentStack: setCurrentStack,
	shaderStages: shaderStages,
	shadow: shadow,
	sharedUniformGroup: sharedUniformGroup,
	sheen: sheen,
	sheenRoughness: sheenRoughness,
	shiftLeft: shiftLeft,
	shiftRight: shiftRight,
	shininess: shininess,
	sign: sign,
	sin: sin,
	sinc: sinc,
	skinning: skinning,
	skinningReference: skinningReference,
	smoothstep: smoothstep,
	smoothstepElement: smoothstepElement,
	specularColor: specularColor,
	specularF90: specularF90,
	spherizeUV: spherizeUV,
	split: split,
	spritesheetUV: spritesheetUV,
	sqrt: sqrt,
	stack: stack,
	step: step,
	storage: storage,
	storageBarrier: storageBarrier,
	storageObject: storageObject,
	storageTexture: storageTexture,
	string: string,
	sub: sub,
	subgroupIndex: subgroupIndex,
	subgroupSize: subgroupSize,
	tan: tan,
	tangentGeometry: tangentGeometry,
	tangentLocal: tangentLocal,
	tangentView: tangentView,
	tangentWorld: tangentWorld,
	temp: temp,
	texture: texture,
	texture3D: texture3D,
	textureBarrier: textureBarrier,
	textureBicubic: textureBicubic,
	textureCubeUV: textureCubeUV,
	textureLoad: textureLoad,
	textureSize: textureSize,
	textureStore: textureStore,
	thickness: thickness,
	time: time,
	timerDelta: timerDelta,
	timerGlobal: timerGlobal,
	timerLocal: timerLocal,
	toOutputColorSpace: toOutputColorSpace,
	toWorkingColorSpace: toWorkingColorSpace,
	toneMapping: toneMapping,
	toneMappingExposure: toneMappingExposure,
	toonOutlinePass: toonOutlinePass,
	transformDirection: transformDirection,
	transformNormal: transformNormal,
	transformNormalToView: transformNormalToView,
	transformedBentNormalView: transformedBentNormalView,
	transformedBitangentView: transformedBitangentView,
	transformedBitangentWorld: transformedBitangentWorld,
	transformedClearcoatNormalView: transformedClearcoatNormalView,
	transformedNormalView: transformedNormalView,
	transformedNormalWorld: transformedNormalWorld,
	transformedTangentView: transformedTangentView,
	transformedTangentWorld: transformedTangentWorld,
	transmission: transmission,
	transpose: transpose,
	triNoise3D: triNoise3D,
	triplanarTexture: triplanarTexture,
	triplanarTextures: triplanarTextures,
	trunc: trunc,
	tslFn: tslFn,
	uint: uint,
	uniform: uniform,
	uniformArray: uniformArray,
	uniformGroup: uniformGroup,
	uniforms: uniforms,
	userData: userData,
	uv: uv,
	uvec2: uvec2,
	uvec3: uvec3,
	uvec4: uvec4,
	varying: varying,
	varyingProperty: varyingProperty,
	vec2: vec2,
	vec3: vec3,
	vec4: vec4,
	vectorComponents: vectorComponents,
	velocity: velocity,
	vertexColor: vertexColor,
	vertexIndex: vertexIndex,
	vibrance: vibrance,
	viewZToLogarithmicDepth: viewZToLogarithmicDepth,
	viewZToOrthographicDepth: viewZToOrthographicDepth,
	viewZToPerspectiveDepth: viewZToPerspectiveDepth,
	viewport: viewport,
	viewportBottomLeft: viewportBottomLeft,
	viewportCoordinate: viewportCoordinate,
	viewportDepthTexture: viewportDepthTexture,
	viewportLinearDepth: viewportLinearDepth,
	viewportMipTexture: viewportMipTexture,
	viewportResolution: viewportResolution,
	viewportSafeUV: viewportSafeUV,
	viewportSharedTexture: viewportSharedTexture,
	viewportSize: viewportSize,
	viewportTexture: viewportTexture,
	viewportTopLeft: viewportTopLeft,
	viewportUV: viewportUV,
	wgsl: wgsl,
	wgslFn: wgslFn,
	workgroupArray: workgroupArray,
	workgroupBarrier: workgroupBarrier,
	workgroupId: workgroupId,
	workingToColorSpace: workingToColorSpace,
	xor: xor
});

const _clearColor$1 = /*@__PURE__*/ new Color4();

class Background extends DataMap {

	constructor( renderer, nodes ) {

		super();

		this.renderer = renderer;
		this.nodes = nodes;

	}

	update( scene, renderList, renderContext ) {

		const renderer = this.renderer;
		const background = this.nodes.getBackgroundNode( scene ) || scene.background;

		let forceClear = false;

		if ( background === null ) {

			// no background settings, use clear color configuration from the renderer

			renderer._clearColor.getRGB( _clearColor$1, LinearSRGBColorSpace );
			_clearColor$1.a = renderer._clearColor.a;

		} else if ( background.isColor === true ) {

			// background is an opaque color

			background.getRGB( _clearColor$1, LinearSRGBColorSpace );
			_clearColor$1.a = 1;

			forceClear = true;

		} else if ( background.isNode === true ) {

			const sceneData = this.get( scene );
			const backgroundNode = background;

			_clearColor$1.copy( renderer._clearColor );

			let backgroundMesh = sceneData.backgroundMesh;

			if ( backgroundMesh === undefined ) {

				const backgroundMeshNode = context( vec4( backgroundNode ).mul( backgroundIntensity ), {
					// @TODO: Add Texture2D support using node context
					getUV: () => backgroundRotation.mul( normalWorld ),
					getTextureLevel: () => backgroundBlurriness
				} );

				let viewProj = modelViewProjection;
				viewProj = viewProj.setZ( viewProj.w );

				const nodeMaterial = new NodeMaterial();
				nodeMaterial.name = 'Background.material';
				nodeMaterial.side = BackSide;
				nodeMaterial.depthTest = false;
				nodeMaterial.depthWrite = false;
				nodeMaterial.fog = false;
				nodeMaterial.lights = false;
				nodeMaterial.vertexNode = viewProj;
				nodeMaterial.colorNode = backgroundMeshNode;

				sceneData.backgroundMeshNode = backgroundMeshNode;
				sceneData.backgroundMesh = backgroundMesh = new Mesh( new SphereGeometry( 1, 32, 32 ), nodeMaterial );
				backgroundMesh.frustumCulled = false;
				backgroundMesh.name = 'Background.mesh';

				backgroundMesh.onBeforeRender = function ( renderer, scene, camera ) {

					this.matrixWorld.copyPosition( camera.matrixWorld );

				};

			}

			const backgroundCacheKey = backgroundNode.getCacheKey();

			if ( sceneData.backgroundCacheKey !== backgroundCacheKey ) {

				sceneData.backgroundMeshNode.node = vec4( backgroundNode ).mul( backgroundIntensity );
				sceneData.backgroundMeshNode.needsUpdate = true;

				backgroundMesh.material.needsUpdate = true;

				sceneData.backgroundCacheKey = backgroundCacheKey;

			}

			renderList.unshift( backgroundMesh, backgroundMesh.geometry, backgroundMesh.material, 0, 0, null, null );

		} else {

			console.error( 'THREE.Renderer: Unsupported background configuration.', background );

		}

		//

		if ( renderer.autoClear === true || forceClear === true ) {

			const clearColorValue = renderContext.clearColorValue;

			clearColorValue.r = _clearColor$1.r;
			clearColorValue.g = _clearColor$1.g;
			clearColorValue.b = _clearColor$1.b;
			clearColorValue.a = _clearColor$1.a;

			// premultiply alpha

			if ( renderer.backend.isWebGLBackend === true || renderer.alpha === true ) {

				clearColorValue.r *= clearColorValue.a;
				clearColorValue.g *= clearColorValue.a;
				clearColorValue.b *= clearColorValue.a;

			}

			//

			renderContext.depthClearValue = renderer._clearDepth;
			renderContext.stencilClearValue = renderer._clearStencil;

			renderContext.clearColor = renderer.autoClearColor === true;
			renderContext.clearDepth = renderer.autoClearDepth === true;
			renderContext.clearStencil = renderer.autoClearStencil === true;

		} else {

			renderContext.clearColor = false;
			renderContext.clearDepth = false;
			renderContext.clearStencil = false;

		}

	}

}

let _id$6 = 0;

class BindGroup {

	constructor( name = '', bindings = [], index = 0, bindingsReference = [] ) {

		this.name = name;
		this.bindings = bindings;
		this.index = index;
		this.bindingsReference = bindingsReference;

		this.id = _id$6 ++;

	}

}

class NodeBuilderState {

	constructor( vertexShader, fragmentShader, computeShader, nodeAttributes, bindings, updateNodes, updateBeforeNodes, updateAfterNodes, monitor, transforms = [] ) {

		this.vertexShader = vertexShader;
		this.fragmentShader = fragmentShader;
		this.computeShader = computeShader;
		this.transforms = transforms;

		this.nodeAttributes = nodeAttributes;
		this.bindings = bindings;

		this.updateNodes = updateNodes;
		this.updateBeforeNodes = updateBeforeNodes;
		this.updateAfterNodes = updateAfterNodes;

		this.monitor = monitor;

		this.usedTimes = 0;

	}

	createBindings() {

		const bindings = [];

		for ( const instanceGroup of this.bindings ) {

			const shared = instanceGroup.bindings[ 0 ].groupNode.shared;

			if ( shared !== true ) {

				const bindingsGroup = new BindGroup( instanceGroup.name, [], instanceGroup.index, instanceGroup );
				bindings.push( bindingsGroup );

				for ( const instanceBinding of instanceGroup.bindings ) {

					bindingsGroup.bindings.push( instanceBinding.clone() );

				}

			} else {

				bindings.push( instanceGroup );

			}

		}

		return bindings;

	}

}

/**
 * {@link NodeBuilder} is going to create instances of this class during the build process
 * of nodes. They represent the final shader attributes that are going to be generated
 * by the builder. Arrays of node attributes is maintained in {@link NodeBuilder#attributes}
 * and {@link NodeBuilder#bufferAttributes} for this purpose.
 */
class NodeAttribute {

	/**
	 * Constructs a new node attribute.
	 *
	 * @param {String} name - The name of the attribute.
	 * @param {String} type - The type of the attribute.
	 * @param {Node?} node - An optional reference to the node.
	 */
	constructor( name, type, node = null ) {

		/**
		 * This flag can be used for type testing.
		 *
		 * @type {Boolean}
		 * @readonly
		 * @default true
		 */
		this.isNodeAttribute = true;

		/**
		 * The name of the attribute.
		 *
		 * @type {String}
		 */
		this.name = name;

		/**
		 * The type of the attribute.
		 *
		 * @type {String}
		 */
		this.type = type;

		/**
		 * An optional reference to the node.
		 *
		 * @type {Node?}
		 * @default null
		 */
		this.node = node;

	}

}

/**
 * {@link NodeBuilder} is going to create instances of this class during the build process
 * of nodes. They represent the final shader uniforms that are going to be generated
 * by the builder. A dictionary of node uniforms is maintained in {@link NodeBuilder#uniforms}
 * for this purpose.
 */
class NodeUniform {

	/**
	 * Constructs a new node uniform.
	 *
	 * @param {String} name - The name of the uniform.
	 * @param {String} type - The type of the uniform.
	 * @param {UniformNode} node - An reference to the node.
	 */
	constructor( name, type, node ) {

		/**
		 * This flag can be used for type testing.
		 *
		 * @type {Boolean}
		 * @readonly
		 * @default true
		 */
		this.isNodeUniform = true;

		/**
		 * The name of the uniform.
		 *
		 * @type {String}
		 */
		this.name = name;

		/**
		 * The type of the uniform.
		 *
		 * @type {String}
		 */
		this.type = type;

		/**
		 * An reference to the node.
		 *
		 * @type {UniformNode}
		 */
		this.node = node.getSelf();

	}

	/**
	 * The value of the uniform node.
	 *
	 * @type {Any}
	 */
	get value() {

		return this.node.value;

	}

	set value( val ) {

		this.node.value = val;

	}

	/**
	 * The id of the uniform node.
	 *
	 * @type {Number}
	 */
	get id() {

		return this.node.id;

	}

	/**
	 * The uniform node's group.
	 *
	 * @type {UniformGroupNode}
	 */
	get groupNode() {

		return this.node.groupNode;

	}

}

/**
 * {@link NodeBuilder} is going to create instances of this class during the build process
 * of nodes. They represent the final shader variables that are going to be generated
 * by the builder. A dictionary of node variables is maintained in {@link NodeBuilder#vars} for
 * this purpose.
 */
class NodeVar {

	/**
	 * Constructs a new node variable.
	 *
	 * @param {String} name - The name of the variable.
	 * @param {String} type - The type of the variable.
	 */
	constructor( name, type ) {

		/**
		 * This flag can be used for type testing.
		 *
		 * @type {Boolean}
		 * @readonly
		 * @default true
		 */
		this.isNodeVar = true;

		/**
		 * The name of the variable.
		 *
		 * @type {String}
		 */
		this.name = name;

		/**
		 * The type of the variable.
		 *
		 * @type {String}
		 */
		this.type = type;

	}

}

/**
 * {@link NodeBuilder} is going to create instances of this class during the build process
 * of nodes. They represent the final shader varyings that are going to be generated
 * by the builder. An array of node varyings is maintained in {@link NodeBuilder#varyings} for
 * this purpose.
 *
 * @augments NodeVar
 */
class NodeVarying extends NodeVar {

	/**
	 * Constructs a new node varying.
	 *
	 * @param {String} name - The name of the varying.
	 * @param {String} type - The type of the varying.
	 */
	constructor( name, type ) {

		super( name, type );

		/**
		 * Whether this varying requires interpolation or not. This property can be used
		 * to check if the varying can be optimized for a variable.
		 *
		 * @type {Boolean}
		 * @default false
		 */
		this.needsInterpolation = false;

		/**
		 * This flag can be used for type testing.
		 *
		 * @type {Boolean}
		 * @readonly
		 * @default true
		 */
		this.isNodeVarying = true;

	}

}

/**
 * {@link NodeBuilder} is going to create instances of this class during the build process
 * of nodes. They represent user-defined, native shader code portions that are going to be
 * injected by the builder. A dictionary of node codes is maintained in {@link NodeBuilder#codes}
 * for this purpose.
 */
class NodeCode {

	/**
	 * Constructs a new code node.
	 *
	 * @param {String} name - The name of the code.
	 * @param {String} type - The node type.
	 * @param {String} [code=''] - The native shader code.
	 */
	constructor( name, type, code = '' ) {

		/**
		 * The name of the code.
		 *
		 * @type {String}
		 */
		this.name = name;

		/**
		 * The node type.
		 *
		 * @type {String}
		 */
		this.type = type;

		/**
		 * The native shader code.
		 *
		 * @type {String}
		 * @default ''
		 */
		this.code = code;

		Object.defineProperty( this, 'isNodeCode', { value: true } );

	}

}

let _id$5 = 0;

/**
 * This utility class is used in {@link NodeBuilder} as an internal
 * cache data structure for node data.
 */
class NodeCache {

	/**
	 * Constructs a new node cache.
	 *
	 * @param {NodeCache?} parent - A reference to a parent cache.
	 */
	constructor( parent = null ) {

		/**
		 * The id of the cache.
		 *
		 * @type {Number}
		 * @readonly
		 */
		this.id = _id$5 ++;

		/**
		 * A weak map for managing node data.
		 *
		 * @type {WeakMap<Node, Object>}
		 */
		this.nodesData = new WeakMap();

		/**
		 * Reference to a parent node cache.
		 *
		 * @type {NodeCache?}
		 * @default null
		 */
		this.parent = parent;

	}

	/**
	 * Returns the data for the given node.
	 *
	 * @param {Node} node - The node.
	 * @return {Object?} The data for the node.
	 */
	getData( node ) {

		let data = this.nodesData.get( node );

		if ( data === undefined && this.parent !== null ) {

			data = this.parent.getData( node );

		}

		return data;

	}

	/**
	 * Sets the data for a given node.
	 *
	 * @param {Node} node - The node.
	 * @param {Object} data - The data that should be cached.
	 */
	setData( node, data ) {

		this.nodesData.set( node, data );

	}

}

/**
 * {@link NodeBuilder} is going to create instances of this class during the build process
 * of nodes. They represent the final shader struct data that are going to be generated
 * by the builder. A dictionary of struct types is maintained in {@link NodeBuilder#structs}
 * for this purpose.
 */
class StructTypeNode extends Node {

	static get type() {

		return 'StructTypeNode';

	}

	/**
	 * Constructs a new struct type node.
	 *
	 * @param {String} name - The name of the struct.
	 * @param {Array<String>} types - An array of types.
	 */
	constructor( name, types ) {

		super();

		/**
		 * The name of the struct.
		 *
		 * @type {String}
		 */
		this.name = name;


		/**
		 * An array of types.
		 *
		 * @type {Array<String>}
		 */
		this.types = types;

		/**
		 * This flag can be used for type testing.
		 *
		 * @type {Boolean}
		 * @readonly
		 * @default true
		 */
		this.isStructTypeNode = true;

	}

	/**
	 * Returns the member types.
	 *
	 * @return {Array<String>} The types.
	 */
	getMemberTypes() {

		return this.types;

	}

}

class Uniform {

	constructor( name, value ) {

		this.name = name;
		this.value = value;

		this.boundary = 0; // used to build the uniform buffer according to the STD140 layout
		this.itemSize = 0;

		this.offset = 0; // this property is set by WebGPUUniformsGroup and marks the start position in the uniform buffer

	}

	setValue( value ) {

		this.value = value;

	}

	getValue() {

		return this.value;

	}

}

class NumberUniform extends Uniform {

	constructor( name, value = 0 ) {

		super( name, value );

		this.isNumberUniform = true;

		this.boundary = 4;
		this.itemSize = 1;

	}

}

class Vector2Uniform extends Uniform {

	constructor( name, value = new Vector2() ) {

		super( name, value );

		this.isVector2Uniform = true;

		this.boundary = 8;
		this.itemSize = 2;

	}

}

class Vector3Uniform extends Uniform {

	constructor( name, value = new Vector3() ) {

		super( name, value );

		this.isVector3Uniform = true;

		this.boundary = 16;
		this.itemSize = 3;

	}

}

class Vector4Uniform extends Uniform {

	constructor( name, value = new Vector4() ) {

		super( name, value );

		this.isVector4Uniform = true;

		this.boundary = 16;
		this.itemSize = 4;

	}

}

class ColorUniform extends Uniform {

	constructor( name, value = new Color() ) {

		super( name, value );

		this.isColorUniform = true;

		this.boundary = 16;
		this.itemSize = 3;

	}

}

class Matrix3Uniform extends Uniform {

	constructor( name, value = new Matrix3() ) {

		super( name, value );

		this.isMatrix3Uniform = true;

		this.boundary = 48;
		this.itemSize = 12;

	}

}

class Matrix4Uniform extends Uniform {

	constructor( name, value = new Matrix4() ) {

		super( name, value );

		this.isMatrix4Uniform = true;

		this.boundary = 64;
		this.itemSize = 16;

	}

}

class NumberNodeUniform extends NumberUniform {

	constructor( nodeUniform ) {

		super( nodeUniform.name, nodeUniform.value );

		this.nodeUniform = nodeUniform;

	}

	getValue() {

		return this.nodeUniform.value;

	}

	getType() {

		return this.nodeUniform.type;

	}

}

class Vector2NodeUniform extends Vector2Uniform {

	constructor( nodeUniform ) {

		super( nodeUniform.name, nodeUniform.value );

		this.nodeUniform = nodeUniform;

	}

	getValue() {

		return this.nodeUniform.value;

	}

	getType() {

		return this.nodeUniform.type;

	}

}

class Vector3NodeUniform extends Vector3Uniform {

	constructor( nodeUniform ) {

		super( nodeUniform.name, nodeUniform.value );

		this.nodeUniform = nodeUniform;

	}

	getValue() {

		return this.nodeUniform.value;

	}

	getType() {

		return this.nodeUniform.type;

	}

}

class Vector4NodeUniform extends Vector4Uniform {

	constructor( nodeUniform ) {

		super( nodeUniform.name, nodeUniform.value );

		this.nodeUniform = nodeUniform;

	}

	getValue() {

		return this.nodeUniform.value;

	}

	getType() {

		return this.nodeUniform.type;

	}

}

class ColorNodeUniform extends ColorUniform {

	constructor( nodeUniform ) {

		super( nodeUniform.name, nodeUniform.value );

		this.nodeUniform = nodeUniform;

	}

	getValue() {

		return this.nodeUniform.value;

	}

	getType() {

		return this.nodeUniform.type;

	}

}

class Matrix3NodeUniform extends Matrix3Uniform {

	constructor( nodeUniform ) {

		super( nodeUniform.name, nodeUniform.value );

		this.nodeUniform = nodeUniform;

	}

	getValue() {

		return this.nodeUniform.value;

	}

	getType() {

		return this.nodeUniform.type;

	}

}

class Matrix4NodeUniform extends Matrix4Uniform {

	constructor( nodeUniform ) {

		super( nodeUniform.name, nodeUniform.value );

		this.nodeUniform = nodeUniform;

	}

	getValue() {

		return this.nodeUniform.value;

	}

	getType() {

		return this.nodeUniform.type;

	}

}

const LOD_MIN = 4;

// The standard deviations (radians) associated with the extra mips. These are
// chosen to approximate a Trowbridge-Reitz distribution function times the
// geometric shadowing function. These sigma values squared must match the
// variance #defines in cube_uv_reflection_fragment.glsl.js.
const EXTRA_LOD_SIGMA = [ 0.125, 0.215, 0.35, 0.446, 0.526, 0.582 ];

// The maximum length of the blur for loop. Smaller sigmas will use fewer
// samples and exit early, but not recompile the shader.
const MAX_SAMPLES = 20;

const _flatCamera = /*@__PURE__*/ new OrthographicCamera( - 1, 1, 1, - 1, 0, 1 );
const _cubeCamera = /*@__PURE__*/ new PerspectiveCamera( 90, 1 );
const _clearColor = /*@__PURE__*/ new Color();
let _oldTarget = null;
let _oldActiveCubeFace = 0;
let _oldActiveMipmapLevel = 0;

// Golden Ratio
const PHI = ( 1 + Math.sqrt( 5 ) ) / 2;
const INV_PHI = 1 / PHI;

// Vertices of a dodecahedron (except the opposites, which represent the
// same axis), used as axis directions evenly spread on a sphere.
const _axisDirections = [
	/*@__PURE__*/ new Vector3( - PHI, INV_PHI, 0 ),
	/*@__PURE__*/ new Vector3( PHI, INV_PHI, 0 ),
	/*@__PURE__*/ new Vector3( - INV_PHI, 0, PHI ),
	/*@__PURE__*/ new Vector3( INV_PHI, 0, PHI ),
	/*@__PURE__*/ new Vector3( 0, PHI, - INV_PHI ),
	/*@__PURE__*/ new Vector3( 0, PHI, INV_PHI ),
	/*@__PURE__*/ new Vector3( - 1, 1, - 1 ),
	/*@__PURE__*/ new Vector3( 1, 1, - 1 ),
	/*@__PURE__*/ new Vector3( - 1, 1, 1 ),
	/*@__PURE__*/ new Vector3( 1, 1, 1 )
];

//

// WebGPU Face indices
const _faceLib = [
	3, 1, 5,
	0, 4, 2
];

const direction = getDirection( uv(), attribute( 'faceIndex' ) ).normalize();
const outputDirection = vec3( direction.x, direction.y, direction.z );

/**
 * This class generates a Prefiltered, Mipmapped Radiance Environment Map
 * (PMREM) from a cubeMap environment texture. This allows different levels of
 * blur to be quickly accessed based on material roughness. It is packed into a
 * special CubeUV format that allows us to perform custom interpolation so that
 * we can support nonlinear formats such as RGBE. Unlike a traditional mipmap
 * chain, it only goes down to the LOD_MIN level (above), and then creates extra
 * even more filtered 'mips' at the same LOD_MIN resolution, associated with
 * higher roughness levels. In this way we maintain resolution to smoothly
 * interpolate diffuse lighting while limiting sampling computation.
 *
 * Paper: Fast, Accurate Image-Based Lighting
 * https://drive.google.com/file/d/15y8r_UpKlU9SvV4ILb0C3qCPecS8pvLz/view
*/

class PMREMGenerator {

	constructor( renderer ) {

		this._renderer = renderer;
		this._pingPongRenderTarget = null;

		this._lodMax = 0;
		this._cubeSize = 0;
		this._lodPlanes = [];
		this._sizeLods = [];
		this._sigmas = [];
		this._lodMeshes = [];

		this._blurMaterial = null;
		this._cubemapMaterial = null;
		this._equirectMaterial = null;
		this._backgroundBox = null;

	}

	get _hasInitialized() {

		return this._renderer.hasInitialized();

	}

	/**
	 * Generates a PMREM from a supplied Scene, which can be faster than using an
	 * image if networking bandwidth is low. Optional sigma specifies a blur radius
	 * in radians to be applied to the scene before PMREM generation. Optional near
	 * and far planes ensure the scene is rendered in its entirety (the cubeCamera
	 * is placed at the origin).
	 *
	 * @param {Scene} scene - The scene to be captured.
	 * @param {Number} [sigma=0] - The blur radius in radians.
	 * @param {Number} [near=0.1] - The near plane distance.
	 * @param {Number} [far=100] - The far plane distance.
	 * @param {RenderTarget?} [renderTarget=null] - The render target to use.
	 * @return {RenderTarget} The resulting PMREM.
	 */
	fromScene( scene, sigma = 0, near = 0.1, far = 100, renderTarget = null ) {

		this._setSize( 256 );

		if ( this._hasInitialized === false ) {

			console.warn( 'THREE.PMREMGenerator: .fromScene() called before the backend is initialized. Try using .fromSceneAsync() instead.' );

			const cubeUVRenderTarget = renderTarget || this._allocateTargets();

			this.fromSceneAsync( scene, sigma, near, far, cubeUVRenderTarget );

			return cubeUVRenderTarget;

		}

		_oldTarget = this._renderer.getRenderTarget();
		_oldActiveCubeFace = this._renderer.getActiveCubeFace();
		_oldActiveMipmapLevel = this._renderer.getActiveMipmapLevel();

		const cubeUVRenderTarget = renderTarget || this._allocateTargets();
		cubeUVRenderTarget.depthBuffer = true;

		this._sceneToCubeUV( scene, near, far, cubeUVRenderTarget );

		if ( sigma > 0 ) {

			this._blur( cubeUVRenderTarget, 0, 0, sigma );

		}

		this._applyPMREM( cubeUVRenderTarget );

		this._cleanup( cubeUVRenderTarget );

		return cubeUVRenderTarget;

	}

	async fromSceneAsync( scene, sigma = 0, near = 0.1, far = 100, renderTarget = null ) {

		if ( this._hasInitialized === false ) await this._renderer.init();

		return this.fromScene( scene, sigma, near, far, renderTarget );

	}

	/**
	 * Generates a PMREM from an equirectangular texture, which can be either LDR
	 * or HDR. The ideal input image size is 1k (1024 x 512),
	 * as this matches best with the 256 x 256 cubemap output.
	 *
	 * @param {Texture} equirectangular - The equirectangular texture to be converted.
	 * @param {RenderTarget?} [renderTarget=null] - The render target to use.
	 * @return {RenderTarget} The resulting PMREM.
	 */
	fromEquirectangular( equirectangular, renderTarget = null ) {

		if ( this._hasInitialized === false ) {

			console.warn( 'THREE.PMREMGenerator: .fromEquirectangular() called before the backend is initialized. Try using .fromEquirectangularAsync() instead.' );

			this._setSizeFromTexture( equirectangular );

			const cubeUVRenderTarget = renderTarget || this._allocateTargets();

			this.fromEquirectangularAsync( equirectangular, cubeUVRenderTarget );

			return cubeUVRenderTarget;

		}

		return this._fromTexture( equirectangular, renderTarget );

	}

	async fromEquirectangularAsync( equirectangular, renderTarget = null ) {

		if ( this._hasInitialized === false ) await this._renderer.init();

		return this._fromTexture( equirectangular, renderTarget );

	}

	/**
	 * Generates a PMREM from an cubemap texture, which can be either LDR
	 * or HDR. The ideal input cube size is 256 x 256,
	 * as this matches best with the 256 x 256 cubemap output.
	 *
	 * @param {Texture} cubemap - The cubemap texture to be converted.
	 * @param {RenderTarget?} [renderTarget=null] - The render target to use.
	 * @return {RenderTarget} The resulting PMREM.
	 */
	fromCubemap( cubemap, renderTarget = null ) {

		if ( this._hasInitialized === false ) {

			console.warn( 'THREE.PMREMGenerator: .fromCubemap() called before the backend is initialized. Try using .fromCubemapAsync() instead.' );

			this._setSizeFromTexture( cubemap );

			const cubeUVRenderTarget = renderTarget || this._allocateTargets();

			this.fromCubemapAsync( cubemap, renderTarget );

			return cubeUVRenderTarget;

		}

		return this._fromTexture( cubemap, renderTarget );

	}

	async fromCubemapAsync( cubemap, renderTarget = null ) {

		if ( this._hasInitialized === false ) await this._renderer.init();

		return this._fromTexture( cubemap, renderTarget );

	}

	/**
	 * Pre-compiles the cubemap shader. You can get faster start-up by invoking this method during
	 * your texture's network fetch for increased concurrency.
	 */
	async compileCubemapShader() {

		if ( this._cubemapMaterial === null ) {

			this._cubemapMaterial = _getCubemapMaterial();
			await this._compileMaterial( this._cubemapMaterial );

		}

	}

	/**
	 * Pre-compiles the equirectangular shader. You can get faster start-up by invoking this method during
	 * your texture's network fetch for increased concurrency.
	 */
	async compileEquirectangularShader() {

		if ( this._equirectMaterial === null ) {

			this._equirectMaterial = _getEquirectMaterial();
			await this._compileMaterial( this._equirectMaterial );

		}

	}

	/**
	 * Disposes of the PMREMGenerator's internal memory. Note that PMREMGenerator is a static class,
	 * so you should not need more than one PMREMGenerator object. If you do, calling dispose() on
	 * one of them will cause any others to also become unusable.
	 */
	dispose() {

		this._dispose();

		if ( this._cubemapMaterial !== null ) this._cubemapMaterial.dispose();
		if ( this._equirectMaterial !== null ) this._equirectMaterial.dispose();
		if ( this._backgroundBox !== null ) {

			this._backgroundBox.geometry.dispose();
			this._backgroundBox.material.dispose();

		}

	}

	// private interface

	_setSizeFromTexture( texture ) {

		if ( texture.mapping === CubeReflectionMapping || texture.mapping === CubeRefractionMapping ) {

			this._setSize( texture.image.length === 0 ? 16 : ( texture.image[ 0 ].width || texture.image[ 0 ].image.width ) );

		} else { // Equirectangular

			this._setSize( texture.image.width / 4 );

		}

	}

	_setSize( cubeSize ) {

		this._lodMax = Math.floor( Math.log2( cubeSize ) );
		this._cubeSize = Math.pow( 2, this._lodMax );

	}

	_dispose() {

		if ( this._blurMaterial !== null ) this._blurMaterial.dispose();

		if ( this._pingPongRenderTarget !== null ) this._pingPongRenderTarget.dispose();

		for ( let i = 0; i < this._lodPlanes.length; i ++ ) {

			this._lodPlanes[ i ].dispose();

		}

	}

	_cleanup( outputTarget ) {

		this._renderer.setRenderTarget( _oldTarget, _oldActiveCubeFace, _oldActiveMipmapLevel );
		outputTarget.scissorTest = false;
		_setViewport( outputTarget, 0, 0, outputTarget.width, outputTarget.height );

	}

	_fromTexture( texture, renderTarget ) {

		this._setSizeFromTexture( texture );

		_oldTarget = this._renderer.getRenderTarget();
		_oldActiveCubeFace = this._renderer.getActiveCubeFace();
		_oldActiveMipmapLevel = this._renderer.getActiveMipmapLevel();

		const cubeUVRenderTarget = renderTarget || this._allocateTargets();
		this._textureToCubeUV( texture, cubeUVRenderTarget );
		this._applyPMREM( cubeUVRenderTarget );
		this._cleanup( cubeUVRenderTarget );

		return cubeUVRenderTarget;

	}

	_allocateTargets() {

		const width = 3 * Math.max( this._cubeSize, 16 * 7 );
		const height = 4 * this._cubeSize;

		const params = {
			magFilter: LinearFilter,
			minFilter: LinearFilter,
			generateMipmaps: false,
			type: HalfFloatType,
			format: RGBAFormat,
			colorSpace: LinearSRGBColorSpace,
			//depthBuffer: false
		};

		const cubeUVRenderTarget = _createRenderTarget( width, height, params );

		if ( this._pingPongRenderTarget === null || this._pingPongRenderTarget.width !== width || this._pingPongRenderTarget.height !== height ) {

			if ( this._pingPongRenderTarget !== null ) {

				this._dispose();

			}

			this._pingPongRenderTarget = _createRenderTarget( width, height, params );

			const { _lodMax } = this;
			( { sizeLods: this._sizeLods, lodPlanes: this._lodPlanes, sigmas: this._sigmas, lodMeshes: this._lodMeshes } = _createPlanes( _lodMax ) );

			this._blurMaterial = _getBlurShader( _lodMax, width, height );

		}

		return cubeUVRenderTarget;

	}

	async _compileMaterial( material ) {

		const tmpMesh = new Mesh( this._lodPlanes[ 0 ], material );
		await this._renderer.compile( tmpMesh, _flatCamera );

	}

	_sceneToCubeUV( scene, near, far, cubeUVRenderTarget ) {

		const cubeCamera = _cubeCamera;
		cubeCamera.near = near;
		cubeCamera.far = far;

		// px, py, pz, nx, ny, nz
		const upSign = [ 1, 1, 1, 1, - 1, 1 ];
		const forwardSign = [ 1, - 1, 1, - 1, 1, - 1 ];

		const renderer = this._renderer;

		const originalAutoClear = renderer.autoClear;

		renderer.getClearColor( _clearColor );

		renderer.autoClear = false;

		let backgroundBox = this._backgroundBox;

		if ( backgroundBox === null ) {

			const backgroundMaterial = new MeshBasicMaterial( {
				name: 'PMREM.Background',
				side: BackSide,
				depthWrite: false,
				depthTest: false
			} );

			backgroundBox = new Mesh( new BoxGeometry(), backgroundMaterial );

		}

		let useSolidColor = false;
		const background = scene.background;

		if ( background ) {

			if ( background.isColor ) {

				backgroundBox.material.color.copy( background );
				scene.background = null;
				useSolidColor = true;

			}

		} else {

			backgroundBox.material.color.copy( _clearColor );
			useSolidColor = true;

		}

		renderer.setRenderTarget( cubeUVRenderTarget );

		renderer.clear();

		if ( useSolidColor ) {

			renderer.render( backgroundBox, cubeCamera );

		}

		for ( let i = 0; i < 6; i ++ ) {

			const col = i % 3;

			if ( col === 0 ) {

				cubeCamera.up.set( 0, upSign[ i ], 0 );
				cubeCamera.lookAt( forwardSign[ i ], 0, 0 );

			} else if ( col === 1 ) {

				cubeCamera.up.set( 0, 0, upSign[ i ] );
				cubeCamera.lookAt( 0, forwardSign[ i ], 0 );

			} else {

				cubeCamera.up.set( 0, upSign[ i ], 0 );
				cubeCamera.lookAt( 0, 0, forwardSign[ i ] );

			}

			const size = this._cubeSize;

			_setViewport( cubeUVRenderTarget, col * size, i > 2 ? size : 0, size, size );

			renderer.render( scene, cubeCamera );

		}

		renderer.autoClear = originalAutoClear;
		scene.background = background;

	}

	_textureToCubeUV( texture, cubeUVRenderTarget ) {

		const renderer = this._renderer;

		const isCubeTexture = ( texture.mapping === CubeReflectionMapping || texture.mapping === CubeRefractionMapping );

		if ( isCubeTexture ) {

			if ( this._cubemapMaterial === null ) {

				this._cubemapMaterial = _getCubemapMaterial( texture );

			}

		} else {

			if ( this._equirectMaterial === null ) {

				this._equirectMaterial = _getEquirectMaterial( texture );

			}

		}

		const material = isCubeTexture ? this._cubemapMaterial : this._equirectMaterial;
		material.fragmentNode.value = texture;

		const mesh = this._lodMeshes[ 0 ];
		mesh.material = material;

		const size = this._cubeSize;

		_setViewport( cubeUVRenderTarget, 0, 0, 3 * size, 2 * size );

		renderer.setRenderTarget( cubeUVRenderTarget );
		renderer.render( mesh, _flatCamera );

	}

	_applyPMREM( cubeUVRenderTarget ) {

		const renderer = this._renderer;
		const autoClear = renderer.autoClear;
		renderer.autoClear = false;
		const n = this._lodPlanes.length;

		for ( let i = 1; i < n; i ++ ) {

			const sigma = Math.sqrt( this._sigmas[ i ] * this._sigmas[ i ] - this._sigmas[ i - 1 ] * this._sigmas[ i - 1 ] );

			const poleAxis = _axisDirections[ ( n - i - 1 ) % _axisDirections.length ];

			this._blur( cubeUVRenderTarget, i - 1, i, sigma, poleAxis );

		}

		renderer.autoClear = autoClear;

	}

	/**
	 * This is a two-pass Gaussian blur for a cubemap. Normally this is done
	 * vertically and horizontally, but this breaks down on a cube. Here we apply
	 * the blur latitudinally (around the poles), and then longitudinally (towards
	 * the poles) to approximate the orthogonally-separable blur. It is least
	 * accurate at the poles, but still does a decent job.
	 *
	 * @param {RenderTarget} cubeUVRenderTarget - The cubemap render target.
	 * @param {Number} lodIn - The input level-of-detail.
	 * @param {Number} lodOut - The output level-of-detail.
	 * @param {Number} sigma - The blur radius in radians.
	 * @param {Vector3} [poleAxis] - The pole axis.
	 */
	_blur( cubeUVRenderTarget, lodIn, lodOut, sigma, poleAxis ) {

		const pingPongRenderTarget = this._pingPongRenderTarget;

		this._halfBlur(
			cubeUVRenderTarget,
			pingPongRenderTarget,
			lodIn,
			lodOut,
			sigma,
			'latitudinal',
			poleAxis );

		this._halfBlur(
			pingPongRenderTarget,
			cubeUVRenderTarget,
			lodOut,
			lodOut,
			sigma,
			'longitudinal',
			poleAxis );

	}

	_halfBlur( targetIn, targetOut, lodIn, lodOut, sigmaRadians, direction, poleAxis ) {

		const renderer = this._renderer;
		const blurMaterial = this._blurMaterial;

		if ( direction !== 'latitudinal' && direction !== 'longitudinal' ) {

			console.error( 'blur direction must be either latitudinal or longitudinal!' );

		}

		// Number of standard deviations at which to cut off the discrete approximation.
		const STANDARD_DEVIATIONS = 3;

		const blurMesh = this._lodMeshes[ lodOut ];
		blurMesh.material = blurMaterial;

		const blurUniforms = blurMaterial.uniforms;

		const pixels = this._sizeLods[ lodIn ] - 1;
		const radiansPerPixel = isFinite( sigmaRadians ) ? Math.PI / ( 2 * pixels ) : 2 * Math.PI / ( 2 * MAX_SAMPLES - 1 );
		const sigmaPixels = sigmaRadians / radiansPerPixel;
		const samples = isFinite( sigmaRadians ) ? 1 + Math.floor( STANDARD_DEVIATIONS * sigmaPixels ) : MAX_SAMPLES;

		if ( samples > MAX_SAMPLES ) {

			console.warn( `sigmaRadians, ${
				sigmaRadians}, is too large and will clip, as it requested ${
				samples} samples when the maximum is set to ${MAX_SAMPLES}` );

		}

		const weights = [];
		let sum = 0;

		for ( let i = 0; i < MAX_SAMPLES; ++ i ) {

			const x = i / sigmaPixels;
			const weight = Math.exp( - x * x / 2 );
			weights.push( weight );

			if ( i === 0 ) {

				sum += weight;

			} else if ( i < samples ) {

				sum += 2 * weight;

			}

		}

		for ( let i = 0; i < weights.length; i ++ ) {

			weights[ i ] = weights[ i ] / sum;

		}

		targetIn.texture.frame = ( targetIn.texture.frame || 0 ) + 1;

		blurUniforms.envMap.value = targetIn.texture;
		blurUniforms.samples.value = samples;
		blurUniforms.weights.array = weights;
		blurUniforms.latitudinal.value = direction === 'latitudinal' ? 1 : 0;

		if ( poleAxis ) {

			blurUniforms.poleAxis.value = poleAxis;

		}

		const { _lodMax } = this;
		blurUniforms.dTheta.value = radiansPerPixel;
		blurUniforms.mipInt.value = _lodMax - lodIn;

		const outputSize = this._sizeLods[ lodOut ];
		const x = 3 * outputSize * ( lodOut > _lodMax - LOD_MIN ? lodOut - _lodMax + LOD_MIN : 0 );
		const y = 4 * ( this._cubeSize - outputSize );

		_setViewport( targetOut, x, y, 3 * outputSize, 2 * outputSize );
		renderer.setRenderTarget( targetOut );
		renderer.render( blurMesh, _flatCamera );

	}

}

function _createPlanes( lodMax ) {

	const lodPlanes = [];
	const sizeLods = [];
	const sigmas = [];
	const lodMeshes = [];

	let lod = lodMax;

	const totalLods = lodMax - LOD_MIN + 1 + EXTRA_LOD_SIGMA.length;

	for ( let i = 0; i < totalLods; i ++ ) {

		const sizeLod = Math.pow( 2, lod );
		sizeLods.push( sizeLod );
		let sigma = 1.0 / sizeLod;

		if ( i > lodMax - LOD_MIN ) {

			sigma = EXTRA_LOD_SIGMA[ i - lodMax + LOD_MIN - 1 ];

		} else if ( i === 0 ) {

			sigma = 0;

		}

		sigmas.push( sigma );

		const texelSize = 1.0 / ( sizeLod - 2 );
		const min = - texelSize;
		const max = 1 + texelSize;
		const uv1 = [ min, min, max, min, max, max, min, min, max, max, min, max ];

		const cubeFaces = 6;
		const vertices = 6;
		const positionSize = 3;
		const uvSize = 2;
		const faceIndexSize = 1;

		const position = new Float32Array( positionSize * vertices * cubeFaces );
		const uv = new Float32Array( uvSize * vertices * cubeFaces );
		const faceIndex = new Float32Array( faceIndexSize * vertices * cubeFaces );

		for ( let face = 0; face < cubeFaces; face ++ ) {

			const x = ( face % 3 ) * 2 / 3 - 1;
			const y = face > 2 ? 0 : - 1;
			const coordinates = [
				x, y, 0,
				x + 2 / 3, y, 0,
				x + 2 / 3, y + 1, 0,
				x, y, 0,
				x + 2 / 3, y + 1, 0,
				x, y + 1, 0
			];

			const faceIdx = _faceLib[ face ];
			position.set( coordinates, positionSize * vertices * faceIdx );
			uv.set( uv1, uvSize * vertices * faceIdx );
			const fill = [ faceIdx, faceIdx, faceIdx, faceIdx, faceIdx, faceIdx ];
			faceIndex.set( fill, faceIndexSize * vertices * faceIdx );

		}

		const planes = new BufferGeometry();
		planes.setAttribute( 'position', new BufferAttribute( position, positionSize ) );
		planes.setAttribute( 'uv', new BufferAttribute( uv, uvSize ) );
		planes.setAttribute( 'faceIndex', new BufferAttribute( faceIndex, faceIndexSize ) );
		lodPlanes.push( planes );
		lodMeshes.push( new Mesh( planes, null ) );

		if ( lod > LOD_MIN ) {

			lod --;

		}

	}

	return { lodPlanes, sizeLods, sigmas, lodMeshes };

}

function _createRenderTarget( width, height, params ) {

	const cubeUVRenderTarget = new RenderTarget( width, height, params );
	cubeUVRenderTarget.texture.mapping = CubeUVReflectionMapping;
	cubeUVRenderTarget.texture.name = 'PMREM.cubeUv';
	cubeUVRenderTarget.texture.isPMREMTexture = true;
	cubeUVRenderTarget.scissorTest = true;
	return cubeUVRenderTarget;

}

function _setViewport( target, x, y, width, height ) {

	target.viewport.set( x, y, width, height );
	target.scissor.set( x, y, width, height );

}

function _getMaterial( type ) {

	const material = new NodeMaterial();
	material.depthTest = false;
	material.depthWrite = false;
	material.blending = NoBlending;
	material.name = `PMREM_${ type }`;

	return material;

}

function _getBlurShader( lodMax, width, height ) {

	const weights = uniformArray( new Array( MAX_SAMPLES ).fill( 0 ) );
	const poleAxis = uniform( new Vector3( 0, 1, 0 ) );
	const dTheta = uniform( 0 );
	const n = float( MAX_SAMPLES );
	const latitudinal = uniform( 0 ); // false, bool
	const samples = uniform( 1 ); // int
	const envMap = texture( null );
	const mipInt = uniform( 0 ); // int
	const CUBEUV_TEXEL_WIDTH = float( 1 / width );
	const CUBEUV_TEXEL_HEIGHT = float( 1 / height );
	const CUBEUV_MAX_MIP = float( lodMax );

	const materialUniforms = {
		n,
		latitudinal,
		weights,
		poleAxis,
		outputDirection,
		dTheta,
		samples,
		envMap,
		mipInt,
		CUBEUV_TEXEL_WIDTH,
		CUBEUV_TEXEL_HEIGHT,
		CUBEUV_MAX_MIP
	};

	const material = _getMaterial( 'blur' );
	material.uniforms = materialUniforms; // TODO: Move to outside of the material
	material.fragmentNode = blur( { ...materialUniforms, latitudinal: latitudinal.equal( 1 ) } );

	return material;

}

function _getCubemapMaterial( envTexture ) {

	const material = _getMaterial( 'cubemap' );
	material.fragmentNode = cubeTexture( envTexture, outputDirection );

	return material;

}

function _getEquirectMaterial( envTexture ) {

	const material = _getMaterial( 'equirect' );
	material.fragmentNode = texture( envTexture, equirectUV( outputDirection ), 0 );

	return material;

}

const rendererCache = new WeakMap();

const typeFromArray = new Map( [
	[ Int8Array, 'int' ],
	[ Int16Array, 'int' ],
	[ Int32Array, 'int' ],
	[ Uint8Array, 'uint' ],
	[ Uint16Array, 'uint' ],
	[ Uint32Array, 'uint' ],
	[ Float32Array, 'float' ]
] );

const toFloat = ( value ) => {

	if ( /e/g.test( value ) ) {

		return String( value ).replace( /\+/g, '' );

	} else {

		value = Number( value );

		return value + ( value % 1 ? '' : '.0' );

	}

};

/**
 * Base class for builders which generate a shader program based
 * on a 3D object and its node material definition.
 */
class NodeBuilder {

	/**
	 * Constructs a new node builder.
	 *
	 * @param {Object3D} object - The 3D object.
	 * @param {Renderer} renderer - The current renderer.
	 * @param {NodeParser} parser - A reference to a node parser.
	 */
	constructor( object, renderer, parser ) {

		/**
		 * The 3D object.
		 *
		 * @type {Object3D}
		 */
		this.object = object;

		/**
		 * The material of the 3D object.
		 *
		 * @type {Material?}
		 */
		this.material = ( object && object.material ) || null;

		/**
		 * The geometry of the 3D object.
		 *
		 * @type {BufferGeometry?}
		 */
		this.geometry = ( object && object.geometry ) || null;

		/**
		 * The current renderer.
		 *
		 * @type {Renderer}
		 */
		this.renderer = renderer;

		/**
		 * A reference to a node parser.
		 *
		 * @type {NodeParser}
		 */
		this.parser = parser;

		/**
		 * The scene the 3D object belongs to.
		 *
		 * @type {Scene?}
		 * @default null
		 */
		this.scene = null;

		/**
		 * The camera the 3D object is rendered with.
		 *
		 * @type {Camera?}
		 * @default null
		 */
		this.camera = null;

		/**
		 * A list of all nodes the builder is processing
		 * for this 3D object.
		 *
		 * @type {Array<Node>}
		 */
		this.nodes = [];

		/**
		 * A list of all sequential nodes.
		 *
		 * @type {Array<Node>}
		 */
		this.sequentialNodes = [];

		/**
		 * A list of all nodes which {@link Node#update} method should be executed.
		 *
		 * @type {Array<Node>}
		 */
		this.updateNodes = [];

		/**
		 * A list of all nodes which {@link Node#updateBefore} method should be executed.
		 *
		 * @type {Array<Node>}
		 */
		this.updateBeforeNodes = [];

		/**
		 * A list of all nodes which {@link Node#updateAfter} method should be executed.
		 *
		 * @type {Array<Node>}
		 */
		this.updateAfterNodes = [];

		/**
		 * A dictionary that assigns each node to a unique hash.
		 *
		 * @type {Object<Number,Node>}
		 */
		this.hashNodes = {};

		/**
		 * A reference to a node material observer.
		 *
		 * @type {NodeMaterialObserver?}
		 * @default null
		 */
		this.monitor = null;

		/**
		 * A reference to the current lights node.
		 *
		 * @type {LightsNode?}
		 * @default null
		 */
		this.lightsNode = null;

		/**
		 * A reference to the current environment node.
		 *
		 * @type {Node?}
		 * @default null
		 */
		this.environmentNode = null;

		/**
		 * A reference to the current fog node.
		 *
		 * @type {FogNode?}
		 * @default null
		 */
		this.fogNode = null;

		/**
		 * The current clipping context.
		 *
		 * @type {ClippingContext?}
		 */
		this.clippingContext = null;

		/**
		 * The generated vertex shader.
		 *
		 * @type {String?}
		 */
		this.vertexShader = null;

		/**
		 * The generated fragment shader.
		 *
		 * @type {String?}
		 */
		this.fragmentShader = null;

		/**
		 * The generated compute shader.
		 *
		 * @type {String?}
		 */
		this.computeShader = null;

		/**
		 * Nodes used in the primary flow of code generation.
		 *
		 * @type {Object<String,Array<Node>>}
		 */
		this.flowNodes = { vertex: [], fragment: [], compute: [] };

		/**
		 * Nodes code from `.flowNodes`.
		 *
		 * @type {Object<String,String>}
		 */
		this.flowCode = { vertex: '', fragment: '', compute: '' };

		/**
		 * This dictionary holds the node uniforms of the builder.
		 * The uniforms are maintained in an array for each shader stage.
		 *
		 * @type {Object}
		 */
		this.uniforms = { vertex: [], fragment: [], compute: [], index: 0 };

		/**
		 * This dictionary holds the output structs of the builder.
		 * The structs are maintained in an array for each shader stage.
		 *
		 * @type {Object}
		 */
		this.structs = { vertex: [], fragment: [], compute: [], index: 0 };

		/**
		 * This dictionary holds the bindings for each shader stage.
		 *
		 * @type {Object}
		 */
		this.bindings = { vertex: {}, fragment: {}, compute: {} };

		/**
		 * This dictionary maintains the binding indices per bind group.
		 *
		 * @type {Object}
		 */
		this.bindingsIndexes = {};

		/**
		 * Reference to the array of bind groups.
		 *
		 * @type {Array<BindGroup>?}
		 */
		this.bindGroups = null;

		/**
		 * This array holds the node attributes of this builder
		 * created via {@link AttributeNode}.
		 *
		 * @type {Array<NodeAttribute>}
		 */
		this.attributes = [];

		/**
		 * This array holds the node attributes of this builder
		 * created via {@link BufferAttributeNode}.
		 *
		 * @type {Array<NodeAttribute>}
		 */
		this.bufferAttributes = [];

		/**
		 * This array holds the node varyings of this builder.
		 *
		 * @type {Array<NodeVarying>}
		 */
		this.varyings = [];

		/**
		 * This dictionary holds the (native) node codes of this builder.
		 * The codes are maintained in an array for each shader stage.
		 *
		 * @type {Object<String,Array<NodeCode>>}
		 */
		this.codes = {};

		/**
		 * This dictionary holds the node variables of this builder.
		 * The variables are maintained in an array for each shader stage.
		 *
		 * @type {Object<String,Array<NodeVar>>}
		 */
		this.vars = {};

		/**
		 * Current code flow.
		 * All code generated in this stack will be stored in `.flow`.
		 *
		 * @type {{code: String}}
		 */
		this.flow = { code: '' };

		/**
		 * A chain of nodes.
		 * Used to check recursive calls in node-graph.
		 *
		 * @type {Array<Node>}
		 */
		this.chaining = [];

		/**
		 * The current stack.
		 * This reflects the current process in the code block hierarchy,
		 * it is useful to know if the current process is inside a conditional for example.
		 *
		 * @type {StackNode}
		 */
		this.stack = stack();

		/**
		 * List of stack nodes.
		 * The current stack hierarchy is stored in an array.
		 *
		 * @type {Array<StackNode>}
		 */
		this.stacks = [];

		/**
		 * A tab value. Used for shader string generation.
		 *
		 * @type {String}
		 * @default '\t'
		 */
		this.tab = '\t';

		/**
		 * Reference to the current function node.
		 *
		 * @type {FunctionNode?}
		 * @default null
		 */
		this.currentFunctionNode = null;

		/**
		 * The builder's context.
		 *
		 * @type {Object}
		 */
		this.context = {
			material: this.material
		};

		/**
		 * The builder's cache.
		 *
		 * @type {NodeCache}
		 */
		this.cache = new NodeCache();

		/**
		 * Since the {@link NodeBuilder#cache} might be temporarily
		 * overwritten by other caches, this member retains the reference
		 * to the builder's own cache.
		 *
		 * @type {NodeCache}
		 * @default this.cache
		 */
		this.globalCache = this.cache;

		this.flowsData = new WeakMap();

		/**
		 * The current shader stage.
		 *
		 * @type {('vertex'|'fragment'|'compute'|'any')?}
		 */
		this.shaderStage = null;

		/**
		 * The current build stage.
		 *
		 * @type {('setup'|'analyze'|'generate')?}
		 */
		this.buildStage = null;

		/**
		 * Whether comparison in shader code are generated with methods or not.
		 *
		 * @type {Boolean}
		 * @default false
		 */
		this.useComparisonMethod = false;

	}

	/**
	 * Returns the bind groups of the current renderer.
	 *
	 * @return {ChainMap} The cache.
	 */
	getBindGroupsCache() {

		let bindGroupsCache = rendererCache.get( this.renderer );

		if ( bindGroupsCache === undefined ) {

			bindGroupsCache = new ChainMap();

			rendererCache.set( this.renderer, bindGroupsCache );

		}

		return bindGroupsCache;

	}

	/**
	 * Factory method for creating an instance of {@link RenderTarget} with the given
	 * dimensions and options.
	 *
	 * @param {Number} width - The width of the render target.
	 * @param {Number} height - The height of the render target.
	 * @param {Object} options - The options of the render target.
	 * @return {RenderTarget} The render target.
	 */
	createRenderTarget( width, height, options ) {

		return new RenderTarget( width, height, options );

	}

	/**
	 * Factory method for creating an instance of {@link CubeRenderTarget} with the given
	 * dimensions and options.
	 *
	 * @param {Number} size - The size of the cube render target.
	 * @param {Object} options - The options of the cube render target.
	 * @return {CubeRenderTarget} The cube render target.
	 */
	createCubeRenderTarget( size, options ) {

		return new CubeRenderTarget( size, options );

	}

	/**
	 * Factory method for creating an instance of {@link PMREMGenerator}.
	 *
	 * @return {PMREMGenerator} The PMREM generator.
	 */
	createPMREMGenerator() {

		// TODO: Move Materials.js to outside of the Nodes.js in order to remove this function and improve tree-shaking support

		return new PMREMGenerator( this.renderer );

	}

	/**
	 * Whether the given node is included in the internal array of nodes or not.
	 *
	 * @param {Node} node - The node to test.
	 * @return {Boolean} Whether the given node is included in the internal array of nodes or not.
	 */
	includes( node ) {

		return this.nodes.includes( node );

	}

	/**
	 * Returns a bind group for the given group name and binding.
	 *
	 * @private
	 * @param {String} groupName - The group name.
	 * @param {Array<NodeUniformsGroup>} bindings - List of bindings.
	 * @return {BindGroup} The bind group
	 */
	_getBindGroup( groupName, bindings ) {

		const bindGroupsCache = this.getBindGroupsCache();

		//

		const bindingsArray = [];

		let sharedGroup = true;

		for ( const binding of bindings ) {

			bindingsArray.push( binding );

			sharedGroup = sharedGroup && binding.groupNode.shared !== true;

		}

		//

		let bindGroup;

		if ( sharedGroup ) {

			bindGroup = bindGroupsCache.get( bindingsArray );

			if ( bindGroup === undefined ) {

				bindGroup = new BindGroup( groupName, bindingsArray, this.bindingsIndexes[ groupName ].group, bindingsArray );

				bindGroupsCache.set( bindingsArray, bindGroup );

			}

		} else {

			bindGroup = new BindGroup( groupName, bindingsArray, this.bindingsIndexes[ groupName ].group, bindingsArray );

		}

		return bindGroup;

	}

	/**
	 * Returns an array of node uniform groups for the given group name and shader stage.
	 *
	 * @param {String} groupName - The group name.
	 * @param {('vertex'|'fragment'|'compute'|'any')} shaderStage - The shader stage.
	 * @return {Array<NodeUniformsGroup>} The array of node uniform groups.
	 */
	getBindGroupArray( groupName, shaderStage ) {

		const bindings = this.bindings[ shaderStage ];

		let bindGroup = bindings[ groupName ];

		if ( bindGroup === undefined ) {

			if ( this.bindingsIndexes[ groupName ] === undefined ) {

				this.bindingsIndexes[ groupName ] = { binding: 0, group: Object.keys( this.bindingsIndexes ).length };

			}

			bindings[ groupName ] = bindGroup = [];

		}

		return bindGroup;

	}

	/**
	 * Returns a list bindings of all shader stages separated by groups.
	 *
	 * @return {Array<BindGroup>} The list of bindings.
	 */
	getBindings() {

		let bindingsGroups = this.bindGroups;

		if ( bindingsGroups === null ) {

			const groups = {};
			const bindings = this.bindings;

			for ( const shaderStage of shaderStages ) {

				for ( const groupName in bindings[ shaderStage ] ) {

					const uniforms = bindings[ shaderStage ][ groupName ];

					const groupUniforms = groups[ groupName ] || ( groups[ groupName ] = [] );
					groupUniforms.push( ...uniforms );

				}

			}

			bindingsGroups = [];

			for ( const groupName in groups ) {

				const group = groups[ groupName ];

				const bindingsGroup = this._getBindGroup( groupName, group );

				bindingsGroups.push( bindingsGroup );

			}

			this.bindGroups = bindingsGroups;

		}

		return bindingsGroups;

	}

	/**
	 * Sorts the bind groups and updates {@link NodeBuilder#bindingsIndexes}.
	 */
	sortBindingGroups() {

		const bindingsGroups = this.getBindings();

		bindingsGroups.sort( ( a, b ) => ( a.bindings[ 0 ].groupNode.order - b.bindings[ 0 ].groupNode.order ) );

		for ( let i = 0; i < bindingsGroups.length; i ++ ) {

			const bindingGroup = bindingsGroups[ i ];
			this.bindingsIndexes[ bindingGroup.name ].group = i;

			bindingGroup.index = i;

		}

	}

	/**
	 * The builder maintains each node in a hash-based dictionary.
	 * This method sets the given node (value) with the given hash (key) into this dictionary.
	 *
	 * @param {Node} node - The node to add.
	 * @param {Number} hash - The hash of the node.
	 */
	setHashNode( node, hash ) {

		this.hashNodes[ hash ] = node;

	}

	/**
	 * Adds a node to this builder.
	 *
	 * @param {Node} node - The node to add.
	 */
	addNode( node ) {

		if ( this.nodes.includes( node ) === false ) {

			this.nodes.push( node );

			this.setHashNode( node, node.getHash( this ) );

		}

	}

	/**
	 * It is used to add Nodes that will be used as FRAME and RENDER events,
	 * and need to follow a certain sequence in the calls to work correctly.
	 *
	 * @param {Node} node - The node to add.
	 */
	addSequentialNode( node ) {

		if ( this.sequentialNodes.includes( node ) === false ) {

			this.sequentialNodes.push( node );

		}

	}

	/**
	 * Checks the update types of nodes
	 */
	buildUpdateNodes() {

		for ( const node of this.nodes ) {

			const updateType = node.getUpdateType();

			if ( updateType !== NodeUpdateType.NONE ) {

				this.updateNodes.push( node.getSelf() );

			}

		}

		for ( const node of this.sequentialNodes ) {

			const updateBeforeType = node.getUpdateBeforeType();
			const updateAfterType = node.getUpdateAfterType();

			if ( updateBeforeType !== NodeUpdateType.NONE ) {

				this.updateBeforeNodes.push( node.getSelf() );

			}

			if ( updateAfterType !== NodeUpdateType.NONE ) {

				this.updateAfterNodes.push( node.getSelf() );

			}

		}

	}

	/**
	 * A reference the current node which is the
	 * last node in the chain of nodes.
	 *
	 * @type {Node}
	 */
	get currentNode() {

		return this.chaining[ this.chaining.length - 1 ];

	}

	/**
	 * Whether the given texture is filtered or not.
	 *
	 * @param {Texture} texture - The texture to check.
	 * @return {Boolean} Whether the given texture is filtered or not.
	 */
	isFilteredTexture( texture ) {

		return ( texture.magFilter === LinearFilter || texture.magFilter === LinearMipmapNearestFilter || texture.magFilter === NearestMipmapLinearFilter || texture.magFilter === LinearMipmapLinearFilter ||
			texture.minFilter === LinearFilter || texture.minFilter === LinearMipmapNearestFilter || texture.minFilter === NearestMipmapLinearFilter || texture.minFilter === LinearMipmapLinearFilter );

	}

	/**
	 * Adds the given node to the internal node chain.
	 * This is used to check recursive calls in node-graph.
	 *
	 * @param {Node} node - The node to add.
	 */
	addChain( node ) {

		/*
		if ( this.chaining.indexOf( node ) !== - 1 ) {

			console.warn( 'Recursive node: ', node );

		}
		*/

		this.chaining.push( node );

	}

	/**
	 * Removes the given node from the internal node chain.
	 *
	 * @param {Node} node - The node to remove.
	 */
	removeChain( node ) {

		const lastChain = this.chaining.pop();

		if ( lastChain !== node ) {

			throw new Error( 'NodeBuilder: Invalid node chaining!' );

		}

	}

	/**
	 * Returns the native shader method name for a given generic name. E.g.
	 * the method name `textureDimensions` matches the WGSL name but must be
	 * resolved to `textureSize` in GLSL.
	 *
	 * @abstract
	 * @param {String} method - The method name to resolve.
	 * @return {String} The resolved method name.
	 */
	getMethod( method ) {

		return method;

	}

	/**
	 * Returns a node for the given hash, see {@link NodeBuilder#setHashNode}.
	 *
	 * @param {Number} hash - The hash of the node.
	 * @return {Node} The found node.
	 */
	getNodeFromHash( hash ) {

		return this.hashNodes[ hash ];

	}

	/**
	 * Adds the Node to a target flow so that it can generate code in the 'generate' process.
	 *
	 * @param {('vertex'|'fragment'|'compute')} shaderStage - The shader stage.
	 * @param {Node} node - The node to add.
	 * @return {Node} The node.
	 */
	addFlow( shaderStage, node ) {

		this.flowNodes[ shaderStage ].push( node );

		return node;

	}

	/**
	 * Sets builder's context.
	 *
	 * @param {Object} context - The context to set.
	 */
	setContext( context ) {

		this.context = context;

	}

	/**
	 * Returns the builder's current context.
	 *
	 * @return {Object} The builder's current context.
	 */
	getContext() {

		return this.context;

	}

	/**
	 * Gets a context used in shader construction that can be shared across different materials.
	 * This is necessary since the renderer cache can reuse shaders generated in one material and use them in another.
	 *
	 * @return {Object} The builder's current context without material.
	 */
	getSharedContext() {

		({ ...this.context });

		return this.context;

	}

	/**
	 * Sets builder's cache.
	 *
	 * @param {NodeCache} cache - The cache to set.
	 */
	setCache( cache ) {

		this.cache = cache;

	}

	/**
	 * Returns the builder's current cache.
	 *
	 * @return {NodeCache} The builder's current cache.
	 */
	getCache() {

		return this.cache;

	}

	/**
	 * Returns a cache for the given node.
	 *
	 * @param {Node} node - The node.
	 * @param {Boolean} [parent=true] - Whether this node refers to a shared parent cache or not.
	 * @return {NodeCache} The cache.
	 */
	getCacheFromNode( node, parent = true ) {

		const data = this.getDataFromNode( node );
		if ( data.cache === undefined ) data.cache = new NodeCache( parent ? this.getCache() : null );

		return data.cache;

	}

	/**
	 * Whether the requested feature is available or not.
	 *
	 * @abstract
	 * @param {String} name - The requested feature.
	 * @return {Boolean} Whether the requested feature is supported or not.
	 */
	isAvailable( /*name*/ ) {

		return false;

	}

	/**
	 * Returns the vertexIndex input variable as a native shader string.
	 *
	 * @abstract
	 * @return {String} The instanceIndex shader string.
	 */
	getVertexIndex() {

		console.warn( 'Abstract function.' );

	}

	/**
	 * Returns the instanceIndex input variable as a native shader string.
	 *
	 * @abstract
	 * @return {String} The instanceIndex shader string.
	 */
	getInstanceIndex() {

		console.warn( 'Abstract function.' );

	}

	/**
	 * Returns the drawIndex input variable as a native shader string.
	 * Only relevant for WebGL and its `WEBGL_multi_draw` extension.
	 *
	 * @abstract
	 * @return {String} The drawIndex shader string.
	 */
	getDrawIndex() {

		console.warn( 'Abstract function.' );

	}

	/**
	 * Returns the frontFacing input variable as a native shader string.
	 *
	 * @abstract
	 * @return {String} The frontFacing shader string.
	 */
	getFrontFacing() {

		console.warn( 'Abstract function.' );

	}

	/**
	 * Returns the fragCoord input variable as a native shader string.
	 *
	 * @abstract
	 * @return {String} The fragCoord shader string.
	 */
	getFragCoord() {

		console.warn( 'Abstract function.' );

	}

	/**
	 * Whether to flip texture data along its vertical axis or not. WebGL needs
	 * this method evaluate to `true`, WebGPU to `false`.
	 *
	 * @abstract
	 * @return {Boolean} Whether to flip texture data along its vertical axis or not.
	 */
	isFlipY() {

		return false;

	}

	/**
	 * Calling this method increases the usage count for the given node by one.
	 *
	 * @param {Node} node - The node to increase the usage count for.
	 * @return {Number} The updated usage count.
	 */
	increaseUsage( node ) {

		const nodeData = this.getDataFromNode( node );
		nodeData.usageCount = nodeData.usageCount === undefined ? 1 : nodeData.usageCount + 1;

		return nodeData.usageCount;

	}

	/**
	 * Generates a texture sample shader string for the given texture data.
	 *
	 * @abstract
	 * @param {Texture} texture - The texture.
	 * @param {String} textureProperty - The texture property name.
	 * @param {String} uvSnippet - Snippet defining the texture coordinates.
	 * @return {String} The generated shader string.
	 */
	generateTexture( /* texture, textureProperty, uvSnippet */ ) {

		console.warn( 'Abstract function.' );

	}

	/**
	 * Generates a texture LOD shader string for the given texture data.
	 *
	 * @abstract
	 * @param {Texture} texture - The texture.
	 * @param {String} textureProperty - The texture property name.
	 * @param {String} uvSnippet - Snippet defining the texture coordinates.
	 * @param {String} levelSnippet - Snippet defining the mip level.
	 * @return {String} The generated shader string.
	 */
	generateTextureLod( /* texture, textureProperty, uvSnippet, levelSnippet */ ) {

		console.warn( 'Abstract function.' );

	}

	/**
	 * Generates the shader string for the given type and value.
	 *
	 * @param {String} type - The type.
	 * @param {Any?} [value=null] - The value.
	 * @return {String} The generated value as a shader string.
	 */
	generateConst( type, value = null ) {

		if ( value === null ) {

			if ( type === 'float' || type === 'int' || type === 'uint' ) value = 0;
			else if ( type === 'bool' ) value = false;
			else if ( type === 'color' ) value = new Color();
			else if ( type === 'vec2' ) value = new Vector2();
			else if ( type === 'vec3' ) value = new Vector3();
			else if ( type === 'vec4' ) value = new Vector4();

		}

		if ( type === 'float' ) return toFloat( value );
		if ( type === 'int' ) return `${ Math.round( value ) }`;
		if ( type === 'uint' ) return value >= 0 ? `${ Math.round( value ) }u` : '0u';
		if ( type === 'bool' ) return value ? 'true' : 'false';
		if ( type === 'color' ) return `${ this.getType( 'vec3' ) }( ${ toFloat( value.r ) }, ${ toFloat( value.g ) }, ${ toFloat( value.b ) } )`;

		const typeLength = this.getTypeLength( type );

		const componentType = this.getComponentType( type );

		const generateConst = value => this.generateConst( componentType, value );

		if ( typeLength === 2 ) {

			return `${ this.getType( type ) }( ${ generateConst( value.x ) }, ${ generateConst( value.y ) } )`;

		} else if ( typeLength === 3 ) {

			return `${ this.getType( type ) }( ${ generateConst( value.x ) }, ${ generateConst( value.y ) }, ${ generateConst( value.z ) } )`;

		} else if ( typeLength === 4 ) {

			return `${ this.getType( type ) }( ${ generateConst( value.x ) }, ${ generateConst( value.y ) }, ${ generateConst( value.z ) }, ${ generateConst( value.w ) } )`;

		} else if ( typeLength > 4 && value && ( value.isMatrix3 || value.isMatrix4 ) ) {

			return `${ this.getType( type ) }( ${ value.elements.map( generateConst ).join( ', ' ) } )`;

		} else if ( typeLength > 4 ) {

			return `${ this.getType( type ) }()`;

		}

		throw new Error( `NodeBuilder: Type '${type}' not found in generate constant attempt.` );

	}

	/**
	 * It might be necessary to convert certain data types to different ones
	 * so this method can be used to hide the conversion.
	 *
	 * @param {String} type - The type.
	 * @return {String} The updated type.
	 */
	getType( type ) {

		if ( type === 'color' ) return 'vec3';

		return type;

	}

	/**
	 * Whether the given attribute name is defined in the geometry or not.
	 *
	 * @param {String} name - The attribute name.
	 * @return {Boolean} Whether the given attribute name is defined in the geometry.
	 */
	hasGeometryAttribute( name ) {

		return this.geometry && this.geometry.getAttribute( name ) !== undefined;

	}

	/**
	 * Returns a node attribute for the given name and type.
	 *
	 * @param {String} name - The attribute's name.
	 * @param {String} type - The attribute's type.
	 * @return {NodeAttribute} The node attribute.
	 */
	getAttribute( name, type ) {

		const attributes = this.attributes;

		// find attribute

		for ( const attribute of attributes ) {

			if ( attribute.name === name ) {

				return attribute;

			}

		}

		// create a new if no exist

		const attribute = new NodeAttribute( name, type );

		attributes.push( attribute );

		return attribute;

	}

	/**
	 * Returns for the given node and shader stage the property name for the shader.
	 *
	 * @param {Node} node - The node.
	 * @param {('vertex'|'fragment'|'compute'|'any')} shaderStage - The shader stage.
	 * @return {String} The property name.
	 */
	getPropertyName( node/*, shaderStage*/ ) {

		return node.name;

	}

	/**
	 * Whether the given type is a vector type or not.
	 *
	 * @param {String} type - The type to check.
	 * @return {Boolean} Whether the given type is a vector type or not.
	 */
	isVector( type ) {

		return /vec\d/.test( type );

	}

	/**
	 * Whether the given type is a matrix type or not.
	 *
	 * @param {String} type - The type to check.
	 * @return {Boolean} Whether the given type is a matrix type or not.
	 */
	isMatrix( type ) {

		return /mat\d/.test( type );

	}

	/**
	 * Whether the given type is a reference type or not.
	 *
	 * @param {String} type - The type to check.
	 * @return {Boolean} Whether the given type is a reference type or not.
	 */
	isReference( type ) {

		return type === 'void' || type === 'property' || type === 'sampler' || type === 'texture' || type === 'cubeTexture' || type === 'storageTexture' || type === 'depthTexture' || type === 'texture3D';

	}

	/**
	 * Whether the given texture needs a conversion to working color space.
	 *
	 * @abstract
	 * @param {Texture} texture - The texture to check.
	 * @return {Boolean} Whether a color space conversion is required or not.
	 */
	needsToWorkingColorSpace( /*texture*/ ) {

		return false;

	}

	/**
	 * Returns the component type of a given texture.
	 *
	 * @param {Texture} texture - The texture.
	 * @return {String} The component type.
	 */
	getComponentTypeFromTexture( texture ) {

		const type = texture.type;

		if ( texture.isDataTexture ) {

			if ( type === IntType ) return 'int';
			if ( type === UnsignedIntType ) return 'uint';

		}

		return 'float';

	}

	/**
	 * Returns the element type for a given type.
	 *
	 * @param {String} type - The type.
	 * @return {String} The element type.
	 */
	getElementType( type ) {

		if ( type === 'mat2' ) return 'vec2';
		if ( type === 'mat3' ) return 'vec3';
		if ( type === 'mat4' ) return 'vec4';

		return this.getComponentType( type );

	}

	/**
	 * Returns the component type for a given type.
	 *
	 * @param {String} type - The type.
	 * @return {String} The component type.
	 */
	getComponentType( type ) {

		type = this.getVectorType( type );

		if ( type === 'float' || type === 'bool' || type === 'int' || type === 'uint' ) return type;

		const componentType = /(b|i|u|)(vec|mat)([2-4])/.exec( type );

		if ( componentType === null ) return null;

		if ( componentType[ 1 ] === 'b' ) return 'bool';
		if ( componentType[ 1 ] === 'i' ) return 'int';
		if ( componentType[ 1 ] === 'u' ) return 'uint';

		return 'float';

	}

	/**
	 * Returns the vector type for a given type.
	 *
	 * @param {String} type - The type.
	 * @return {String} The vector type.
	 */
	getVectorType( type ) {

		if ( type === 'color' ) return 'vec3';
		if ( type === 'texture' || type === 'cubeTexture' || type === 'storageTexture' || type === 'texture3D' ) return 'vec4';

		return type;

	}

	/**
	 * Returns the data type for the given the length and component type.
	 *
	 * @param {Number} length - The length.
	 * @param {String} [componentType='float'] - The component type.
	 * @return {String} The type.
	 */
	getTypeFromLength( length, componentType = 'float' ) {

		if ( length === 1 ) return componentType;

		const baseType = getTypeFromLength( length );
		const prefix = componentType === 'float' ? '' : componentType[ 0 ];

		return prefix + baseType;

	}

	/**
	 * Returns the type for a given typed array.
	 *
	 * @param {TypedArray} array - The typed array.
	 * @return {String} The type.
	 */
	getTypeFromArray( array ) {

		return typeFromArray.get( array.constructor );

	}

	/**
	 * Returns the type for a given buffer attribute.
	 *
	 * @param {BufferAttribute} attribute - The buffer attribute.
	 * @return {String} The type.
	 */
	getTypeFromAttribute( attribute ) {

		let dataAttribute = attribute;

		if ( attribute.isInterleavedBufferAttribute ) dataAttribute = attribute.data;

		const array = dataAttribute.array;
		const itemSize = attribute.itemSize;
		const normalized = attribute.normalized;

		let arrayType;

		if ( ! ( attribute instanceof Float16BufferAttribute ) && normalized !== true ) {

			arrayType = this.getTypeFromArray( array );

		}

		return this.getTypeFromLength( itemSize, arrayType );

	}

	/**
	 * Returns the length for the given data type.
	 *
	 * @param {String} type - The data type.
	 * @return {Number} The length.
	 */
	getTypeLength( type ) {

		const vecType = this.getVectorType( type );
		const vecNum = /vec([2-4])/.exec( vecType );

		if ( vecNum !== null ) return Number( vecNum[ 1 ] );
		if ( vecType === 'float' || vecType === 'bool' || vecType === 'int' || vecType === 'uint' ) return 1;
		if ( /mat2/.test( type ) === true ) return 4;
		if ( /mat3/.test( type ) === true ) return 9;
		if ( /mat4/.test( type ) === true ) return 16;

		return 0;

	}

	/**
	 * Returns the vector type for a given matrix type.
	 *
	 * @param {String} type - The matrix type.
	 * @return {String} The vector type.
	 */
	getVectorFromMatrix( type ) {

		return type.replace( 'mat', 'vec' );

	}

	/**
	 * For a given type this method changes the component type to the
	 * given value. E.g. `vec4` should be changed to the new component type
	 * `uint` which results in `uvec4`.
	 *
	 * @param {String} type - The type.
	 * @param {String} newComponentType - The new component type.
	 * @return {String} The new type.
	 */
	changeComponentType( type, newComponentType ) {

		return this.getTypeFromLength( this.getTypeLength( type ), newComponentType );

	}

	/**
	 * Returns the integer type pendant for the given type.
	 *
	 * @param {String} type - The type.
	 * @return {String} The integer type.
	 */
	getIntegerType( type ) {

		const componentType = this.getComponentType( type );

		if ( componentType === 'int' || componentType === 'uint' ) return type;

		return this.changeComponentType( type, 'int' );

	}

	/**
	 * Adds a stack node to the internal stack.
	 *
	 * @return {StackNode} The added stack node.
	 */
	addStack() {

		this.stack = stack( this.stack );

		this.stacks.push( getCurrentStack() || this.stack );
		setCurrentStack( this.stack );

		return this.stack;

	}

	/**
	 * Removes the last stack node from the internal stack.
	 *
	 * @return {StackNode} The removed stack node.
	 */
	removeStack() {

		const lastStack = this.stack;
		this.stack = lastStack.parent;

		setCurrentStack( this.stacks.pop() );

		return lastStack;

	}

	/**
	 * The builder maintains (cached) data for each node during the building process. This method
	 * can be used to get these data for a specific shader stage and cache.
	 *
	 * @param {Node} node - The node to get the data for.
	 * @param {('vertex'|'fragment'|'compute'|'any')} [shaderStage=this.shaderStage] - The shader stage.
	 * @param {NodeCache?} cache - An optional cache.
	 * @return {Object} The node data.
	 */
	getDataFromNode( node, shaderStage = this.shaderStage, cache = null ) {

		cache = cache === null ? ( node.isGlobal( this ) ? this.globalCache : this.cache ) : cache;

		let nodeData = cache.getData( node );

		if ( nodeData === undefined ) {

			nodeData = {};

			cache.setData( node, nodeData );

		}

		if ( nodeData[ shaderStage ] === undefined ) nodeData[ shaderStage ] = {};

		return nodeData[ shaderStage ];

	}

	/**
	 * Returns the properties for the given node and shader stage.
	 *
	 * @param {Node} node - The node to get the properties for.
	 * @param {('vertex'|'fragment'|'compute'|'any')} [shaderStage='any'] - The shader stage.
	 * @return {Object} The node properties.
	 */
	getNodeProperties( node, shaderStage = 'any' ) {

		const nodeData = this.getDataFromNode( node, shaderStage );

		return nodeData.properties || ( nodeData.properties = { outputNode: null } );

	}

	/**
	 * Returns an instance of {@link NodeAttribute} for the given buffer attribute node.
	 *
	 * @param {BufferAttributeNode} node - The buffer attribute node.
	 * @param {String} type - The node type.
	 * @return {NodeAttribute} The node attribute.
	 */
	getBufferAttributeFromNode( node, type ) {

		const nodeData = this.getDataFromNode( node );

		let bufferAttribute = nodeData.bufferAttribute;

		if ( bufferAttribute === undefined ) {

			const index = this.uniforms.index ++;

			bufferAttribute = new NodeAttribute( 'nodeAttribute' + index, type, node );

			this.bufferAttributes.push( bufferAttribute );

			nodeData.bufferAttribute = bufferAttribute;

		}

		return bufferAttribute;

	}

	/**
	 * Returns an instance of {@link StructTypeNode} for the given output struct node.
	 *
	 * @param {OutputStructNode} node - The output struct node.
	 * @param {Array<String>} types - The output struct types.
	 * @param {('vertex'|'fragment'|'compute'|'any')} [shaderStage=this.shaderStage] - The shader stage.
	 * @return {StructTypeNode} The struct type attribute.
	 */
	getStructTypeFromNode( node, types, shaderStage = this.shaderStage ) {

		const nodeData = this.getDataFromNode( node, shaderStage );

		let structType = nodeData.structType;

		if ( structType === undefined ) {

			const index = this.structs.index ++;

			structType = new StructTypeNode( 'StructType' + index, types );

			this.structs[ shaderStage ].push( structType );

			nodeData.structType = structType;

		}

		return structType;

	}

	/**
	 * Returns an instance of {@link NodeUniform} for the given uniform node.
	 *
	 * @param {UniformNode} node - The uniform node.
	 * @param {String} type - The uniform type.
	 * @param {('vertex'|'fragment'|'compute'|'any')} [shaderStage=this.shaderStage] - The shader stage.
	 * @param {String?} name - The name of the uniform.
	 * @return {NodeUniform} The node uniform.
	 */
	getUniformFromNode( node, type, shaderStage = this.shaderStage, name = null ) {

		const nodeData = this.getDataFromNode( node, shaderStage, this.globalCache );

		let nodeUniform = nodeData.uniform;

		if ( nodeUniform === undefined ) {

			const index = this.uniforms.index ++;

			nodeUniform = new NodeUniform( name || ( 'nodeUniform' + index ), type, node );

			this.uniforms[ shaderStage ].push( nodeUniform );

			nodeData.uniform = nodeUniform;

		}

		return nodeUniform;

	}

	/**
	 * Returns an instance of {@link NodeVar} for the given variable node.
	 *
	 * @param {VarNode} node - The variable node.
	 * @param {String?} name - The variable's name.
	 * @param {String} [type=node.getNodeType( this )] - The variable's type.
	 * @param {('vertex'|'fragment'|'compute'|'any')} [shaderStage=this.shaderStage] - The shader stage.
	 * @return {NodeVar} The node variable.
	 */
	getVarFromNode( node, name = null, type = node.getNodeType( this ), shaderStage = this.shaderStage ) {

		const nodeData = this.getDataFromNode( node, shaderStage );

		let nodeVar = nodeData.variable;

		if ( nodeVar === undefined ) {

			const vars = this.vars[ shaderStage ] || ( this.vars[ shaderStage ] = [] );

			if ( name === null ) name = 'nodeVar' + vars.length;

			nodeVar = new NodeVar( name, type );

			vars.push( nodeVar );

			nodeData.variable = nodeVar;

		}

		return nodeVar;

	}

	/**
	 * Returns an instance of {@link NodeVarying} for the given varying node.
	 *
	 * @param {(VaryingNode|PropertyNode)} node - The varying node.
	 * @param {String?} name - The varying's name.
	 * @param {String} [type=node.getNodeType( this )] - The varying's type.
	 * @return {NodeVar} The node varying.
	 */
	getVaryingFromNode( node, name = null, type = node.getNodeType( this ) ) {

		const nodeData = this.getDataFromNode( node, 'any' );

		let nodeVarying = nodeData.varying;

		if ( nodeVarying === undefined ) {

			const varyings = this.varyings;
			const index = varyings.length;

			if ( name === null ) name = 'nodeVarying' + index;

			nodeVarying = new NodeVarying( name, type );

			varyings.push( nodeVarying );

			nodeData.varying = nodeVarying;

		}

		return nodeVarying;

	}

	/**
	 * Returns an instance of {@link NodeCode} for the given code node.
	 *
	 * @param {CodeNode} node - The code node.
	 * @param {String} type - The node type.
	 * @param {('vertex'|'fragment'|'compute'|'any')} [shaderStage=this.shaderStage] - The shader stage.
	 * @return {NodeCode} The node code.
	 */
	getCodeFromNode( node, type, shaderStage = this.shaderStage ) {

		const nodeData = this.getDataFromNode( node );

		let nodeCode = nodeData.code;

		if ( nodeCode === undefined ) {

			const codes = this.codes[ shaderStage ] || ( this.codes[ shaderStage ] = [] );
			const index = codes.length;

			nodeCode = new NodeCode( 'nodeCode' + index, type );

			codes.push( nodeCode );

			nodeData.code = nodeCode;

		}

		return nodeCode;

	}

	/**
	 * Adds a code flow based on the code-block hierarchy.

	 * This is used so that code-blocks like If,Else create their variables locally if the Node
	 * is only used inside one of these conditionals in the current shader stage.
	 *
	 * @param {Node} node - The node to add.
	 * @param {Node} nodeBlock - Node-based code-block. Usually 'ConditionalNode'.
	 */
	addFlowCodeHierarchy( node, nodeBlock ) {

		const { flowCodes, flowCodeBlock } = this.getDataFromNode( node );

		let needsFlowCode = true;
		let nodeBlockHierarchy = nodeBlock;

		while ( nodeBlockHierarchy ) {

			if ( flowCodeBlock.get( nodeBlockHierarchy ) === true ) {

				needsFlowCode = false;
				break;

			}

			nodeBlockHierarchy = this.getDataFromNode( nodeBlockHierarchy ).parentNodeBlock;

		}

		if ( needsFlowCode ) {

			for ( const flowCode of flowCodes ) {

				this.addLineFlowCode( flowCode );

			}

		}

	}

	/**
	 * Add a inline-code to the current flow code-block.
	 *
	 * @param {Node} node - The node to add.
	 * @param {String} code - The code to add.
	 * @param {Node} nodeBlock - Current ConditionalNode
	 */
	addLineFlowCodeBlock( node, code, nodeBlock ) {

		const nodeData = this.getDataFromNode( node );
		const flowCodes = nodeData.flowCodes || ( nodeData.flowCodes = [] );
		const codeBlock = nodeData.flowCodeBlock || ( nodeData.flowCodeBlock = new WeakMap() );

		flowCodes.push( code );
		codeBlock.set( nodeBlock, true );

	}

	/**
	 * Add a inline-code to the current flow.
	 *
	 * @param {String} code - The code to add.
	 * @param {Node?} [node= null] - Optional Node, can help the system understand if the Node is part of a code-block.
	 * @return {NodeBuilder} A reference to this node builder.
	 */
	addLineFlowCode( code, node = null ) {

		if ( code === '' ) return this;

		if ( node !== null && this.context.nodeBlock ) {

			this.addLineFlowCodeBlock( node, code, this.context.nodeBlock );

		}

		code = this.tab + code;

		if ( ! /;\s*$/.test( code ) ) {

			code = code + ';\n';

		}

		this.flow.code += code;

		return this;

	}

	/**
	 * Adds a code to the current code flow.
	 *
	 * @param {String} code - Shader code.
	 * @return {NodeBuilder} A reference to this node builder.
	 */
	addFlowCode( code ) {

		this.flow.code += code;

		return this;

	}

	/**
	 * Add tab in the code that will be generated so that other snippets respect the current tabulation.
	 * Typically used in codes with If,Else.
	 *
	 * @return {NodeBuilder} A reference to this node builder.
	 */
	addFlowTab() {

		this.tab += '\t';

		return this;

	}

	/**
	 * Removes a tab.
	 *
	 * @return {NodeBuilder} A reference to this node builder.
	 */
	removeFlowTab() {

		this.tab = this.tab.slice( 0, - 1 );

		return this;

	}

	/**
	 * Gets the current flow data based on a Node.
	 *
	 * @param {Node} node - Node that the flow was started.
	 * @param {('vertex'|'fragment'|'compute'|'any')} shaderStage - The shader stage.
	 * @return {Object} The flow data.
	 */
	getFlowData( node/*, shaderStage*/ ) {

		return this.flowsData.get( node );

	}

	/**
	 * Executes the node flow based on a root node to generate the final shader code.
	 *
	 * @param {Node} node - The node to execute.
	 * @return {Object} The code flow.
	 */
	flowNode( node ) {

		const output = node.getNodeType( this );

		const flowData = this.flowChildNode( node, output );

		this.flowsData.set( node, flowData );

		return flowData;

	}

	/**
	 * Returns the native shader operator name for a given generic name.
	 * It is a similar type of method like {@link NodeBuilder#getMethod}.
	 *
	 * @param {ShaderNodeInternal} shaderNode - The shader node to build the function node with.
	 * @return {FunctionNode} The build function node.
	 */
	buildFunctionNode( shaderNode ) {

		const fn = new FunctionNode();

		const previous = this.currentFunctionNode;

		this.currentFunctionNode = fn;

		fn.code = this.buildFunctionCode( shaderNode );

		this.currentFunctionNode = previous;

		return fn;

	}

	/**
	 * Generates a code flow based on a TSL function: Fn().
	 *
	 * @param {ShaderNodeInternal} shaderNode - A function code will be generated based on the input.
	 * @return {Object}
	 */
	flowShaderNode( shaderNode ) {

		const layout = shaderNode.layout;

		const inputs = {
			[ Symbol.iterator ]() {

				let index = 0;
				const values = Object.values( this );
				return {
					next: () => ( {
						value: values[ index ],
						done: index ++ >= values.length
					} )
				};

			}
		};

		for ( const input of layout.inputs ) {

			inputs[ input.name ] = new ParameterNode( input.type, input.name );

		}

		//

		shaderNode.layout = null;

		const callNode = shaderNode.call( inputs );
		const flowData = this.flowStagesNode( callNode, layout.type );

		shaderNode.layout = layout;

		return flowData;

	}

	/**
	 * Runs the node flow through all the steps of creation, 'setup', 'analyze', 'generate'.
	 *
	 * @param {Node} node - The node to execute.
	 * @param {String?} output - Expected output type. For example 'vec3'.
	 * @return {Object}
	 */
	flowStagesNode( node, output = null ) {

		const previousFlow = this.flow;
		const previousVars = this.vars;
		const previousCache = this.cache;
		const previousBuildStage = this.buildStage;
		const previousStack = this.stack;

		const flow = {
			code: ''
		};

		this.flow = flow;
		this.vars = {};
		this.cache = new NodeCache();
		this.stack = stack();

		for ( const buildStage of defaultBuildStages ) {

			this.setBuildStage( buildStage );

			flow.result = node.build( this, output );

		}

		flow.vars = this.getVars( this.shaderStage );

		this.flow = previousFlow;
		this.vars = previousVars;
		this.cache = previousCache;
		this.stack = previousStack;

		this.setBuildStage( previousBuildStage );

		return flow;

	}

	/**
	 * Returns the native shader operator name for a given generic name.
	 * It is a similar type of method like {@link NodeBuilder#getMethod}.
	 *
	 * @abstract
	 * @param {String} op - The operator name to resolve.
	 * @return {String} The resolved operator name.
	 */
	getFunctionOperator( /* op */ ) {

		return null;

	}

	/**
	 * Generates a code flow based on a child Node.
	 *
	 * @param {Node} node - The node to execute.
	 * @param {String?} output - Expected output type. For example 'vec3'.
	 * @return {Object} The code flow.
	 */
	flowChildNode( node, output = null ) {

		const previousFlow = this.flow;

		const flow = {
			code: ''
		};

		this.flow = flow;

		flow.result = node.build( this, output );

		this.flow = previousFlow;

		return flow;

	}

	/**
	 * Executes a flow of code in a different stage.
	 *
	 * Some nodes like `varying()` have the ability to compute code in vertex-stage and
	 * return the value in fragment-stage even if it is being executed in an input fragment.
	 *
	 * @param {('vertex'|'fragment'|'compute'|'any')} shaderStage - The shader stage.
	 * @param {Node} node - The node to execute.
	 * @param {String?} output - Expected output type. For example 'vec3'.
	 * @param {String?} propertyName - The property name to assign the result.
	 * @return {Object}
	 */
	flowNodeFromShaderStage( shaderStage, node, output = null, propertyName = null ) {

		const previousShaderStage = this.shaderStage;

		this.setShaderStage( shaderStage );

		const flowData = this.flowChildNode( node, output );

		if ( propertyName !== null ) {

			flowData.code += `${ this.tab + propertyName } = ${ flowData.result };\n`;

		}

		this.flowCode[ shaderStage ] = this.flowCode[ shaderStage ] + flowData.code;

		this.setShaderStage( previousShaderStage );

		return flowData;

	}

	/**
	 * Returns an array holding all node attributes of this node builder.
	 *
	 * @return {Array<NodeAttribute>} The node attributes of this builder.
	 */
	getAttributesArray() {

		return this.attributes.concat( this.bufferAttributes );

	}

	/**
	 * Returns the attribute definitions as a shader string for the given shader stage.
	 *
	 * @abstract
	 * @param {('vertex'|'fragment'|'compute'|'any')} shaderStage - The shader stage.
	 * @return {String} The attribute code section.
	 */
	getAttributes( /*shaderStage*/ ) {

		console.warn( 'Abstract function.' );

	}

	/**
	 * Returns the varying definitions as a shader string for the given shader stage.
	 *
	 * @abstract
	 * @param {('vertex'|'fragment'|'compute'|'any')} shaderStage - The shader stage.
	 * @return {String} The varying code section.
	 */
	getVaryings( /*shaderStage*/ ) {

		console.warn( 'Abstract function.' );

	}

	/**
	 * Returns a single variable definition as a shader string for the given variable type and name.
	 *
	 * @param {String} type - The variable's type.
	 * @param {String} name - The variable's name.
	 * @return {String} The shader string.
	 */
	getVar( type, name ) {

		return `${ this.getType( type ) } ${ name }`;

	}

	/**
	 * Returns the variable definitions as a shader string for the given shader stage.
	 *
	 * @param {('vertex'|'fragment'|'compute'|'any')} shaderStage - The shader stage.
	 * @return {String} The variable code section.
	 */
	getVars( shaderStage ) {

		let snippet = '';

		const vars = this.vars[ shaderStage ];

		if ( vars !== undefined ) {

			for ( const variable of vars ) {

				snippet += `${ this.getVar( variable.type, variable.name ) }; `;

			}

		}

		return snippet;

	}

	/**
	 * Returns the uniform definitions as a shader string for the given shader stage.
	 *
	 * @abstract
	 * @param {('vertex'|'fragment'|'compute'|'any')} shaderStage - The shader stage.
	 * @return {String} The uniform code section.
	 */
	getUniforms( /*shaderStage*/ ) {

		console.warn( 'Abstract function.' );

	}

	/**
	 * Returns the native code definitions as a shader string for the given shader stage.
	 *
	 * @param {('vertex'|'fragment'|'compute'|'any')} shaderStage - The shader stage.
	 * @return {String} The native code section.
	 */
	getCodes( shaderStage ) {

		const codes = this.codes[ shaderStage ];

		let code = '';

		if ( codes !== undefined ) {

			for ( const nodeCode of codes ) {

				code += nodeCode.code + '\n';

			}

		}

		return code;

	}

	/**
	 * Returns the hash of this node builder.
	 *
	 * @return {String} The hash.
	 */
	getHash() {

		return this.vertexShader + this.fragmentShader + this.computeShader;

	}

	/**
	 * Sets the current shader stage.
	 *
	 * @param {('vertex'|'fragment'|'compute'|'any')?} shaderStage - The shader stage to set.
	 */
	setShaderStage( shaderStage ) {

		this.shaderStage = shaderStage;

	}

	/**
	 * Returns the current shader stage.
	 *
	 * @return {('vertex'|'fragment'|'compute'|'any')?} The current shader stage.
	 */
	getShaderStage() {

		return this.shaderStage;

	}

	/**
	 * Sets the current build stage.
	 *
	 * @param {('setup'|'analyze'|'generate')?} buildStage - The build stage to set.
	 */
	setBuildStage( buildStage ) {

		this.buildStage = buildStage;

	}

	/**
	 * Returns the current build stage.
	 *
	 * @return {('setup'|'analyze'|'generate')?} The current build stage.
	 */
	getBuildStage() {

		return this.buildStage;

	}

	/**
	 * Controls the code build of the shader stages.
	 *
	 * @abstract
	 */
	buildCode() {

		console.warn( 'Abstract function.' );

	}

	/**
	 * Central build method which controls the build for the given object.
	 *
	 * @return {NodeBuilder} A reference to this node builder.
	 */
	build() {

		const { object, material, renderer } = this;

		if ( material !== null ) {

			let nodeMaterial = renderer.library.fromMaterial( material );

			if ( nodeMaterial === null ) {

				console.error( `NodeMaterial: Material "${ material.type }" is not compatible.` );

				nodeMaterial = new NodeMaterial();

			}

			nodeMaterial.build( this );

		} else {

			this.addFlow( 'compute', object );

		}

		// setup() -> stage 1: create possible new nodes and returns an output reference node
		// analyze()   -> stage 2: analyze nodes to possible optimization and validation
		// generate()  -> stage 3: generate shader

		for ( const buildStage of defaultBuildStages ) {

			this.setBuildStage( buildStage );

			if ( this.context.vertex && this.context.vertex.isNode ) {

				this.flowNodeFromShaderStage( 'vertex', this.context.vertex );

			}

			for ( const shaderStage of shaderStages ) {

				this.setShaderStage( shaderStage );

				const flowNodes = this.flowNodes[ shaderStage ];

				for ( const node of flowNodes ) {

					if ( buildStage === 'generate' ) {

						this.flowNode( node );

					} else {

						node.build( this );

					}

				}

			}

		}

		this.setBuildStage( null );
		this.setShaderStage( null );

		// stage 4: build code for a specific output

		this.buildCode();
		this.buildUpdateNodes();

		return this;

	}

	/**
	 * Returns a uniform representation which is later used for UBO generation and rendering.
	 *
	 * @param {NodeUniform} uniformNode - The uniform node.
	 * @param {String} type - The requested type.
	 * @return {Uniform} The uniform.
	 */
	getNodeUniform( uniformNode, type ) {

		if ( type === 'float' || type === 'int' || type === 'uint' ) return new NumberNodeUniform( uniformNode );
		if ( type === 'vec2' || type === 'ivec2' || type === 'uvec2' ) return new Vector2NodeUniform( uniformNode );
		if ( type === 'vec3' || type === 'ivec3' || type === 'uvec3' ) return new Vector3NodeUniform( uniformNode );
		if ( type === 'vec4' || type === 'ivec4' || type === 'uvec4' ) return new Vector4NodeUniform( uniformNode );
		if ( type === 'color' ) return new ColorNodeUniform( uniformNode );
		if ( type === 'mat3' ) return new Matrix3NodeUniform( uniformNode );
		if ( type === 'mat4' ) return new Matrix4NodeUniform( uniformNode );

		throw new Error( `Uniform "${type}" not declared.` );

	}

	/**
	 * Formats the given shader snippet from a given type into another one. E.g.
	 * this method might be used to convert a simple float string `"1.0"` into a
	 * `vec3` representation: `"vec3<f32>( 1.0 )"`.
	 *
	 * @param {String} snippet - The shader snippet.
	 * @param {String} fromType - The source type.
	 * @param {String} toType - The target type.
	 * @return {String} The updated shader string.
	 */
	format( snippet, fromType, toType ) {

		fromType = this.getVectorType( fromType );
		toType = this.getVectorType( toType );

		if ( fromType === toType || toType === null || this.isReference( toType ) ) {

			return snippet;

		}

		const fromTypeLength = this.getTypeLength( fromType );
		const toTypeLength = this.getTypeLength( toType );

		if ( fromTypeLength === 16 && toTypeLength === 9 ) {

			return `${ this.getType( toType ) }(${ snippet }[0].xyz, ${ snippet }[1].xyz, ${ snippet }[2].xyz)`;

		}

		if ( fromTypeLength === 9 && toTypeLength === 4 ) {

			return `${ this.getType( toType ) }(${ snippet }[0].xy, ${ snippet }[1].xy)`;

		}


		if ( fromTypeLength > 4 ) { // fromType is matrix-like

			// @TODO: ignore for now

			return snippet;

		}

		if ( toTypeLength > 4 || toTypeLength === 0 ) { // toType is matrix-like or unknown

			// @TODO: ignore for now

			return snippet;

		}

		if ( fromTypeLength === toTypeLength ) {

			return `${ this.getType( toType ) }( ${ snippet } )`;

		}

		if ( fromTypeLength > toTypeLength ) {

			return this.format( `${ snippet }.${ 'xyz'.slice( 0, toTypeLength ) }`, this.getTypeFromLength( toTypeLength, this.getComponentType( fromType ) ), toType );

		}

		if ( toTypeLength === 4 && fromTypeLength > 1 ) { // toType is vec4-like

			return `${ this.getType( toType ) }( ${ this.format( snippet, fromType, 'vec3' ) }, 1.0 )`;

		}

		if ( fromTypeLength === 2 ) { // fromType is vec2-like and toType is vec3-like

			return `${ this.getType( toType ) }( ${ this.format( snippet, fromType, 'vec2' ) }, 0.0 )`;

		}

		if ( fromTypeLength === 1 && toTypeLength > 1 && fromType !== this.getComponentType( toType ) ) { // fromType is float-like

			// convert a number value to vector type, e.g:
			// vec3( 1u ) -> vec3( float( 1u ) )

			snippet = `${ this.getType( this.getComponentType( toType ) ) }( ${ snippet } )`;

		}

		return `${ this.getType( toType ) }( ${ snippet } )`; // fromType is float-like

	}

	/**
	 * Returns a signature with the engine's current revision.
	 *
	 * @return {String} The signature.
	 */
	getSignature() {

		return `// Three.js r${ REVISION } - Node System\n`;

	}

	// deprecated

	createNodeMaterial( type = 'NodeMaterial' ) { // @deprecated, r168

		throw new Error( `THREE.NodeBuilder: createNodeMaterial() was deprecated. Use new ${ type }() instead.` );

	}

}

/**
 * Management class for updating nodes. The module tracks metrics like
 * the elapsed time, delta time, the render and frame ID to correctly
 * call the node update methods {@link Node#updateBefore}, {@link Node#update}
 * and {@link Node#updateAfter} depending on the node's configuration.
 */
class NodeFrame {

	/**
	 * Constructs a new node fame.
	 */
	constructor() {

		/**
		 * The elapsed time in seconds.
		 *
		 * @type {Number}
		 * @default 0
		 */
		this.time = 0;

		/**
		 * The delta time in seconds.
		 *
		 * @type {Number}
		 * @default 0
		 */
		this.deltaTime = 0;

		/**
		 * The frame ID.
		 *
		 * @type {Number}
		 * @default 0
		 */
		this.frameId = 0;

		/**
		 * The render ID.
		 *
		 * @type {Number}
		 * @default 0
		 */
		this.renderId = 0;

		/**
		 * Used to control the {@link Node#update} call.
		 *
		 * @type {WeakMap<Node, Object>}
		 */
		this.updateMap = new WeakMap();

		/**
		 * Used to control the {@link Node#updateBefore} call.
		 *
		 * @type {WeakMap<Node, Object>}
		 */
		this.updateBeforeMap = new WeakMap();

		/**
		 * Used to control the {@link Node#updateAfter} call.
		 *
		 * @type {WeakMap<Node, Object>}
		 */
		this.updateAfterMap = new WeakMap();

		/**
		 * A reference to the current renderer.
		 *
		 * @type {Renderer?}
		 * @default null
		 */
		this.renderer = null;

		/**
		 * A reference to the current material.
		 *
		 * @type {Material?}
		 * @default null
		 */
		this.material = null;

		/**
		 * A reference to the current camera.
		 *
		 * @type {Camera?}
		 * @default null
		 */
		this.camera = null;

		/**
		 * A reference to the current 3D object.
		 *
		 * @type {Object3D?}
		 * @default null
		 */
		this.object = null;

		/**
		 * A reference to the current scene.
		 *
		 * @type {Scene?}
		 * @default null
		 */
		this.scene = null;

	}

	/**
	 * Returns a dictionary for a given node and update map which
	 * is used to correctly call node update methods per frame or render.
	 *
	 * @private
	 * @param {WeakMap<Node, Object>} referenceMap - The reference weak map.
	 * @param {Node} nodeRef - The reference to the current node.
	 * @return {Object<String,WeakMap>} The dictionary.
	 */
	_getMaps( referenceMap, nodeRef ) {

		let maps = referenceMap.get( nodeRef );

		if ( maps === undefined ) {

			maps = {
				renderMap: new WeakMap(),
				frameMap: new WeakMap()
			};

			referenceMap.set( nodeRef, maps );

		}

		return maps;

	}

	/**
	 * This method executes the {@link Node#updateBefore} for the given node.
	 * It makes sure {@link Node#updateBeforeType} is honored meaning the update
	 * is only executed once per frame, render or object depending on the update
	 * type.
	 *
	 * @param {Node} node - The node that should be updated.
	 */
	updateBeforeNode( node ) {

		const updateType = node.getUpdateBeforeType();
		const reference = node.updateReference( this );

		if ( updateType === NodeUpdateType.FRAME ) {

			const { frameMap } = this._getMaps( this.updateBeforeMap, reference );

			if ( frameMap.get( reference ) !== this.frameId ) {

				if ( node.updateBefore( this ) !== false ) {

					frameMap.set( reference, this.frameId );

				}

			}

		} else if ( updateType === NodeUpdateType.RENDER ) {

			const { renderMap } = this._getMaps( this.updateBeforeMap, reference );

			if ( renderMap.get( reference ) !== this.renderId ) {

				if ( node.updateBefore( this ) !== false ) {

					renderMap.set( reference, this.renderId );

				}

			}

		} else if ( updateType === NodeUpdateType.OBJECT ) {

			node.updateBefore( this );

		}

	}

	/**
	 * This method executes the {@link Node#updateAfter} for the given node.
	 * It makes sure {@link Node#updateAfterType} is honored meaning the update
	 * is only executed once per frame, render or object depending on the update
	 * type.
	 *
	 * @param {Node} node - The node that should be updated.
	 */
	updateAfterNode( node ) {

		const updateType = node.getUpdateAfterType();
		const reference = node.updateReference( this );

		if ( updateType === NodeUpdateType.FRAME ) {

			const { frameMap } = this._getMaps( this.updateAfterMap, reference );

			if ( frameMap.get( reference ) !== this.frameId ) {

				if ( node.updateAfter( this ) !== false ) {

					frameMap.set( reference, this.frameId );

				}

			}

		} else if ( updateType === NodeUpdateType.RENDER ) {

			const { renderMap } = this._getMaps( this.updateAfterMap, reference );

			if ( renderMap.get( reference ) !== this.renderId ) {

				if ( node.updateAfter( this ) !== false ) {

					renderMap.set( reference, this.renderId );

				}

			}

		} else if ( updateType === NodeUpdateType.OBJECT ) {

			node.updateAfter( this );

		}

	}

	/**
	 * This method executes the {@link Node#update} for the given node.
	 * It makes sure {@link Node#updateType} is honored meaning the update
	 * is only executed once per frame, render or object depending on the update
	 * type.
	 *
	 * @param {Node} node - The node that should be updated.
	 */
	updateNode( node ) {

		const updateType = node.getUpdateType();
		const reference = node.updateReference( this );

		if ( updateType === NodeUpdateType.FRAME ) {

			const { frameMap } = this._getMaps( this.updateMap, reference );

			if ( frameMap.get( reference ) !== this.frameId ) {

				if ( node.update( this ) !== false ) {

					frameMap.set( reference, this.frameId );

				}

			}

		} else if ( updateType === NodeUpdateType.RENDER ) {

			const { renderMap } = this._getMaps( this.updateMap, reference );

			if ( renderMap.get( reference ) !== this.renderId ) {

				if ( node.update( this ) !== false ) {

					renderMap.set( reference, this.renderId );

				}

			}

		} else if ( updateType === NodeUpdateType.OBJECT ) {

			node.update( this );

		}

	}

	/**
	 * Updates the internal state of the node frame. This method is
	 * called by the renderer in its internal animation loop.
	 */
	update() {

		this.frameId ++;

		if ( this.lastTime === undefined ) this.lastTime = performance.now();

		this.deltaTime = ( performance.now() - this.lastTime ) / 1000;

		this.lastTime = performance.now();

		this.time += this.deltaTime;

	}

}

/**
 * Describes the input of a {@link NodeFunction}.
 */
class NodeFunctionInput {

	/**
	 * Constructs a new node function input.
	 *
	 * @param {String} type - The input type.
	 * @param {String} name - The input name.
	 * @param {Number?} [count=null] - If the input is an Array, count will be the length.
	 * @param {('in'|'out'|'inout')} [qualifier=''] - The parameter qualifier (only relevant for GLSL).
	 * @param {Boolean} [isConst=false] - Whether the input uses a const qualifier or not (only relevant for GLSL).
	 */
	constructor( type, name, count = null, qualifier = '', isConst = false ) {

		/**
		 *  The input type.
		 *
		 * @type {String}
		 */
		this.type = type;

		/**
		 * The input name.
		 *
		 * @type {String}
		 */
		this.name = name;

		/**
		 * If the input is an Array, count will be the length.
		 *
		 * @type {Number?}
		 * @default null
		 */
		this.count = count;

		/**
		 *The parameter qualifier (only relevant for GLSL).
		 *
		 * @type {('in'|'out'|'inout')}
		 * @default ''
		 */
		this.qualifier = qualifier;

		/**
		 * Whether the input uses a const qualifier or not (only relevant for GLSL).
		 *
		 * @type {Boolean}
		 * @default false
		 */
		this.isConst = isConst;

	}

}

NodeFunctionInput.isNodeFunctionInput = true;

/**
 * Module for representing directional lights as nodes.
 *
 * @augments AnalyticLightNode
 */
class DirectionalLightNode extends AnalyticLightNode {

	static get type() {

		return 'DirectionalLightNode';

	}

	/**
	 * Constructs a new directional light node.
	 *
	 * @param {DirectionalLight?} [light=null] - The directional light source.
	 */
	constructor( light = null ) {

		super( light );

	}

	setup( builder ) {

		super.setup( builder );

		const lightingModel = builder.context.lightingModel;

		const lightColor = this.colorNode;
		const lightDirection = lightTargetDirection( this.light );
		const reflectedLight = builder.context.reflectedLight;

		lightingModel.direct( {
			lightDirection,
			lightColor,
			reflectedLight
		}, builder.stack, builder );

	}

}

const _matrix41 = /*@__PURE__*/ new Matrix4();
const _matrix42 = /*@__PURE__*/ new Matrix4();

let _ltcLib = null;

/**
 * Module for representing rect area lights as nodes.
 *
 * @augments AnalyticLightNode
 */
class RectAreaLightNode extends AnalyticLightNode {

	static get type() {

		return 'RectAreaLightNode';

	}

	/**
	 * Constructs a new rect area light node.
	 *
	 * @param {RectAreaLight?} [light=null] - The rect area light source.
	 */
	constructor( light = null ) {

		super( light );

		/**
		 * Uniform node representing the half height of the are light.
		 *
		 * @type {UniformNode<vec3>}
		 */
		this.halfHeight = uniform( new Vector3() ).setGroup( renderGroup );

		/**
		 * Uniform node representing the half width of the are light.
		 *
		 * @type {UniformNode<vec3>}
		 */
		this.halfWidth = uniform( new Vector3() ).setGroup( renderGroup );

		/**
		 * The `updateType` is set to `NodeUpdateType.RENDER` since the light
		 * relies on `viewMatrix` which might vary per render call.
		 *
		 * @type {String}
		 * @default 'render'
		 */
		this.updateType = NodeUpdateType.RENDER;

	}

	/**
	 * Overwritten to updated rect area light specific uniforms.
	 *
	 * @param {NodeFrame} frame - A reference to the current node frame.
	 */
	update( frame ) {

		super.update( frame );

		const { light } = this;

		const viewMatrix = frame.camera.matrixWorldInverse;

		_matrix42.identity();
		_matrix41.copy( light.matrixWorld );
		_matrix41.premultiply( viewMatrix );
		_matrix42.extractRotation( _matrix41 );

		this.halfWidth.value.set( light.width * 0.5, 0.0, 0.0 );
		this.halfHeight.value.set( 0.0, light.height * 0.5, 0.0 );

		this.halfWidth.value.applyMatrix4( _matrix42 );
		this.halfHeight.value.applyMatrix4( _matrix42 );

	}

	setup( builder ) {

		super.setup( builder );

		let ltc_1, ltc_2;

		if ( builder.isAvailable( 'float32Filterable' ) ) {

			ltc_1 = texture( _ltcLib.LTC_FLOAT_1 );
			ltc_2 = texture( _ltcLib.LTC_FLOAT_2 );

		} else {

			ltc_1 = texture( _ltcLib.LTC_HALF_1 );
			ltc_2 = texture( _ltcLib.LTC_HALF_2 );

		}

		const { colorNode, light } = this;
		const lightingModel = builder.context.lightingModel;

		const lightPosition = lightViewPosition( light );
		const reflectedLight = builder.context.reflectedLight;

		lightingModel.directRectArea( {
			lightColor: colorNode,
			lightPosition,
			halfWidth: this.halfWidth,
			halfHeight: this.halfHeight,
			reflectedLight,
			ltc_1,
			ltc_2
		}, builder.stack, builder );

	}

	/**
	 * Used to configure the internal BRDF approximation texture data.
	 *
	 * @param {RectAreaLightTexturesLib} ltc - The BRDF approximation texture data.
	 */
	static setLTC( ltc ) {

		_ltcLib = ltc;

	}

}

/**
 * Module for representing spot lights as nodes.
 *
 * @augments AnalyticLightNode
 */
class SpotLightNode extends AnalyticLightNode {

	static get type() {

		return 'SpotLightNode';

	}

	/**
	 * Constructs a new spot light node.
	 *
	 * @param {SpotLight?} [light=null] - The spot light source.
	 */
	constructor( light = null ) {

		super( light );

		/**
		 * Uniform node representing the cone cosinus.
		 *
		 * @type {UniformNode<float>}
		 */
		this.coneCosNode = uniform( 0 ).setGroup( renderGroup );

		/**
		 * Uniform node representing the penumbra cosinus.
		 *
		 * @type {UniformNode<float>}
		 */
		this.penumbraCosNode = uniform( 0 ).setGroup( renderGroup );

		/**
		 * Uniform node representing the cutoff distance.
		 *
		 * @type {UniformNode<float>}
		 */
		this.cutoffDistanceNode = uniform( 0 ).setGroup( renderGroup );

		/**
		 * Uniform node representing the decay exponent.
		 *
		 * @type {UniformNode<float>}
		 */
		this.decayExponentNode = uniform( 0 ).setGroup( renderGroup );

	}

	/**
	 * Overwritten to updated spot light specific uniforms.
	 *
	 * @param {NodeFrame} frame - A reference to the current node frame.
	 */
	update( frame ) {

		super.update( frame );

		const { light } = this;

		this.coneCosNode.value = Math.cos( light.angle );
		this.penumbraCosNode.value = Math.cos( light.angle * ( 1 - light.penumbra ) );

		this.cutoffDistanceNode.value = light.distance;
		this.decayExponentNode.value = light.decay;

	}

	/**
	 * Computes the spot attenuation for the given angle.
	 *
	 * @param {Node<float>} angleCosine - The angle to compute the spot attenuation for.
	 * @return {Node<float>} The spot attenuation.
	 */
	getSpotAttenuation( angleCosine ) {

		const { coneCosNode, penumbraCosNode } = this;

		return smoothstep( coneCosNode, penumbraCosNode, angleCosine );

	}

	setup( builder ) {

		super.setup( builder );

		const lightingModel = builder.context.lightingModel;

		const { colorNode, cutoffDistanceNode, decayExponentNode, light } = this;

		const lVector = lightViewPosition( light ).sub( positionView ); // @TODO: Add it into LightNode

		const lightDirection = lVector.normalize();
		const angleCos = lightDirection.dot( lightTargetDirection( light ) );
		const spotAttenuation = this.getSpotAttenuation( angleCos );

		const lightDistance = lVector.length();

		const lightAttenuation = getDistanceAttenuation( {
			lightDistance,
			cutoffDistance: cutoffDistanceNode,
			decayExponent: decayExponentNode
		} );

		let lightColor = colorNode.mul( spotAttenuation ).mul( lightAttenuation );

		if ( light.map ) {

			const spotLightCoord = lightProjectionUV( light );
			const projectedTexture = texture( light.map, spotLightCoord.xy ).onRenderUpdate( () => light.map );

			const inSpotLightMap = spotLightCoord.mul( 2. ).sub( 1. ).abs().lessThan( 1. ).all();

			lightColor = inSpotLightMap.select( lightColor.mul( projectedTexture ), lightColor );

		}

		const reflectedLight = builder.context.reflectedLight;

		lightingModel.direct( {
			lightDirection,
			lightColor,
			reflectedLight
		}, builder.stack, builder );

	}

}

/**
 * An IES version of the default spot light node.
 *
 * @augments SpotLightNode
 */
class IESSpotLightNode extends SpotLightNode {

	static get type() {

		return 'IESSpotLightNode';

	}

	/**
	 * Overwrites the default implementation to compute an IES conform spot attenuation.
	 *
	 * @param {Node<float>} angleCosine - The angle to compute the spot attenuation for.
	 * @return {Node<float>} The spot attenuation.
	 */
	getSpotAttenuation( angleCosine ) {

		const iesMap = this.light.iesMap;

		let spotAttenuation = null;

		if ( iesMap && iesMap.isTexture === true ) {

			const angle = angleCosine.acos().mul( 1.0 / Math.PI );

			spotAttenuation = texture( iesMap, vec2( angle, 0 ), 0 ).r;

		} else {

			spotAttenuation = super.getSpotAttenuation( angleCosine );

		}

		return spotAttenuation;

	}

}

/**
 * Module for representing ambient lights as nodes.
 *
 * @augments AnalyticLightNode
 */
class AmbientLightNode extends AnalyticLightNode {

	static get type() {

		return 'AmbientLightNode';

	}

	/**
	 * Constructs a new ambient light node.
	 *
	 * @param {AmbientLight?} [light=null] - The ambient light source.
	 */
	constructor( light = null ) {

		super( light );

	}

	setup( { context } ) {

		context.irradiance.addAssign( this.colorNode );

	}

}

/**
 * Module for representing hemisphere lights as nodes.
 *
 * @augments AnalyticLightNode
 */
class HemisphereLightNode extends AnalyticLightNode {

	static get type() {

		return 'HemisphereLightNode';

	}

	/**
	 * Constructs a new hemisphere light node.
	 *
	 * @param {HemisphereLight?} [light=null] - The hemisphere light source.
	 */
	constructor( light = null ) {

		super( light );

		/**
		 * Uniform node representing the light's position.
		 *
		 * @type {UniformNode<vec3>}
		 */
		this.lightPositionNode = lightPosition( light );

		/**
		 * A node representing the light's direction.
		 *
		 * @type {Node<vec3>}
		 */
		this.lightDirectionNode = this.lightPositionNode.normalize();

		/**
		 * Uniform node representing the light's ground color.
		 *
		 * @type {UniformNode<vec3>}
		 */
		this.groundColorNode = uniform( new Color() ).setGroup( renderGroup );

	}

	/**
	 * Overwritten to updated hemisphere light specific uniforms.
	 *
	 * @param {NodeFrame} frame - A reference to the current node frame.
	 */
	update( frame ) {

		const { light } = this;

		super.update( frame );

		this.lightPositionNode.object3d = light;

		this.groundColorNode.value.copy( light.groundColor ).multiplyScalar( light.intensity );

	}

	setup( builder ) {

		const { colorNode, groundColorNode, lightDirectionNode } = this;

		const dotNL = normalView.dot( lightDirectionNode );
		const hemiDiffuseWeight = dotNL.mul( 0.5 ).add( 0.5 );

		const irradiance = mix( groundColorNode, colorNode, hemiDiffuseWeight );

		builder.context.irradiance.addAssign( irradiance );

	}

}

/**
 * Module for representing light probes as nodes.
 *
 * @augments AnalyticLightNode
 */
class LightProbeNode extends AnalyticLightNode {

	static get type() {

		return 'LightProbeNode';

	}

	/**
	 * Constructs a new light probe node.
	 *
	 * @param {LightProbe?} [light=null] - The light probe.
	 */
	constructor( light = null ) {

		super( light );

		const array = [];

		for ( let i = 0; i < 9; i ++ ) array.push( new Vector3() );

		/**
		 * Light probe represented as a uniform of spherical harmonics.
		 *
		 * @type {UniformArrayNode}
		 */
		this.lightProbe = uniformArray( array );

	}

	/**
	 * Overwritten to updated light probe specific uniforms.
	 *
	 * @param {NodeFrame} frame - A reference to the current node frame.
	 */
	update( frame ) {

		const { light } = this;

		super.update( frame );

		//

		for ( let i = 0; i < 9; i ++ ) {

			this.lightProbe.array[ i ].copy( light.sh.coefficients[ i ] ).multiplyScalar( light.intensity );

		}

	}

	setup( builder ) {

		const irradiance = getShIrradianceAt( normalWorld, this.lightProbe );

		builder.context.irradiance.addAssign( irradiance );

	}

}

/**
 * Base class for node parsers. A derived parser must be implemented
 * for each supported native shader language.
 */
class NodeParser {

	/**
	 * The method parses the given native code an returns a node function.
	 *
	 * @abstract
	 * @param {String} source - The native shader code.
	 * @return {NodeFunction} A node function.
	 */
	parseFunction( /*source*/ ) {

		console.warn( 'Abstract function.' );

	}

}

/**
 * Base class for node functions. A derived module must be implemented
 * for each supported native shader language. Similar to other `Node*` modules,
 * this class is only relevant during the building process and not used
 * in user-level code.
 */
class NodeFunction {

	/**
	 * Constructs a new node function.
	 *
	 * @param {String} type - The node type. This type is the return type of the node function.
	 * @param {Array<NodeFunctionInput>} inputs - The function's inputs.
	 * @param {String} [name=''] - The function's name.
	 * @param {String} [precision=''] - The precision qualifier.
	 */
	constructor( type, inputs, name = '', precision = '' ) {

		/**
		 * The node type. This type is the return type of the node function.
		 *
		 * @type {String}
		 */
		this.type = type;

		/**
		 * The function's inputs.
		 *
		 * @type {Array<NodeFunctionInput>}
		 */
		this.inputs = inputs;

		/**
		 * The name of the uniform.
		 *
		 * @type {String}
		 * @default ''
		 */
		this.name = name;

		/**
		 * The precision qualifier.
		 *
		 * @type {String}
		 * @default ''
		 */
		this.precision = precision;

	}

	/**
	 * This method returns the native code of the node function.
	 *
	 * @abstract
	 * @param {String} name - The function's name.
	 * @return {String} A shader code.
	 */
	getCode( /*name = this.name*/ ) {

		console.warn( 'Abstract function.' );

	}

}

NodeFunction.isNodeFunction = true;

const declarationRegexp$1 = /^\s*(highp|mediump|lowp)?\s*([a-z_0-9]+)\s*([a-z_0-9]+)?\s*\(([\s\S]*?)\)/i;
const propertiesRegexp$1 = /[a-z_0-9]+/ig;

const pragmaMain = '#pragma main';

const parse$1 = ( source ) => {

	source = source.trim();

	const pragmaMainIndex = source.indexOf( pragmaMain );

	const mainCode = pragmaMainIndex !== - 1 ? source.slice( pragmaMainIndex + pragmaMain.length ) : source;

	const declaration = mainCode.match( declarationRegexp$1 );

	if ( declaration !== null && declaration.length === 5 ) {

		// tokenizer

		const inputsCode = declaration[ 4 ];
		const propsMatches = [];

		let nameMatch = null;

		while ( ( nameMatch = propertiesRegexp$1.exec( inputsCode ) ) !== null ) {

			propsMatches.push( nameMatch );

		}

		// parser

		const inputs = [];

		let i = 0;

		while ( i < propsMatches.length ) {

			const isConst = propsMatches[ i ][ 0 ] === 'const';

			if ( isConst === true ) {

				i ++;

			}

			let qualifier = propsMatches[ i ][ 0 ];

			if ( qualifier === 'in' || qualifier === 'out' || qualifier === 'inout' ) {

				i ++;

			} else {

				qualifier = '';

			}

			const type = propsMatches[ i ++ ][ 0 ];

			let count = Number.parseInt( propsMatches[ i ][ 0 ] );

			if ( Number.isNaN( count ) === false ) i ++;
			else count = null;

			const name = propsMatches[ i ++ ][ 0 ];

			inputs.push( new NodeFunctionInput( type, name, count, qualifier, isConst ) );

		}

		//

		const blockCode = mainCode.substring( declaration[ 0 ].length );

		const name = declaration[ 3 ] !== undefined ? declaration[ 3 ] : '';
		const type = declaration[ 2 ];

		const precision = declaration[ 1 ] !== undefined ? declaration[ 1 ] : '';

		const headerCode = pragmaMainIndex !== - 1 ? source.slice( 0, pragmaMainIndex ) : '';

		return {
			type,
			inputs,
			name,
			precision,
			inputsCode,
			blockCode,
			headerCode
		};

	} else {

		throw new Error( 'FunctionNode: Function is not a GLSL code.' );

	}

};

/**
 * This class represents a GLSL node function.
 *
 * @augments NodeFunction
 */
class GLSLNodeFunction extends NodeFunction {

	/**
	 * Constructs a new GLSL node function.
	 *
	 * @param {String} source - The GLSL source.
	 */
	constructor( source ) {

		const { type, inputs, name, precision, inputsCode, blockCode, headerCode } = parse$1( source );

		super( type, inputs, name, precision );

		this.inputsCode = inputsCode;
		this.blockCode = blockCode;
		this.headerCode = headerCode;

	}

	/**
	 * This method returns the GLSL code of the node function.
	 *
	 * @param {String} [name=this.name] - The function's name.
	 * @return {String} The shader code.
	 */
	getCode( name = this.name ) {

		let code;

		const blockCode = this.blockCode;

		if ( blockCode !== '' ) {

			const { type, inputsCode, headerCode, precision } = this;

			let declarationCode = `${ type } ${ name } ( ${ inputsCode.trim() } )`;

			if ( precision !== '' ) {

				declarationCode = `${ precision } ${ declarationCode }`;

			}

			code = headerCode + declarationCode + blockCode;

		} else {

			// interface function

			code = '';

		}

		return code;

	}

}

/**
 * A GLSL node parser.
 *
 * @augments NodeParser
 */
class GLSLNodeParser extends NodeParser {

	/**
	 * The method parses the given GLSL code an returns a node function.
	 *
	 * @param {String} source - The GLSL code.
	 * @return {GLSLNodeFunction} A node function.
	 */
	parseFunction( source ) {

		return new GLSLNodeFunction( source );

	}

}

const outputNodeMap = new WeakMap();

class Nodes extends DataMap {

	constructor( renderer, backend ) {

		super();

		this.renderer = renderer;
		this.backend = backend;
		this.nodeFrame = new NodeFrame();
		this.nodeBuilderCache = new Map();
		this.callHashCache = new ChainMap();
		this.groupsData = new ChainMap();

	}

	updateGroup( nodeUniformsGroup ) {

		const groupNode = nodeUniformsGroup.groupNode;
		const name = groupNode.name;

		// objectGroup is every updated

		if ( name === objectGroup.name ) return true;

		// renderGroup is updated once per render/compute call

		if ( name === renderGroup.name ) {

			const uniformsGroupData = this.get( nodeUniformsGroup );
			const renderId = this.nodeFrame.renderId;

			if ( uniformsGroupData.renderId !== renderId ) {

				uniformsGroupData.renderId = renderId;

				return true;

			}

			return false;

		}

		// frameGroup is updated once per frame

		if ( name === frameGroup.name ) {

			const uniformsGroupData = this.get( nodeUniformsGroup );
			const frameId = this.nodeFrame.frameId;

			if ( uniformsGroupData.frameId !== frameId ) {

				uniformsGroupData.frameId = frameId;

				return true;

			}

			return false;

		}

		// other groups are updated just when groupNode.needsUpdate is true

		const groupChain = [ groupNode, nodeUniformsGroup ];

		let groupData = this.groupsData.get( groupChain );
		if ( groupData === undefined ) this.groupsData.set( groupChain, groupData = {} );

		if ( groupData.version !== groupNode.version ) {

			groupData.version = groupNode.version;

			return true;

		}

		return false;

	}

	getForRenderCacheKey( renderObject ) {

		return renderObject.initialCacheKey;

	}

	getForRender( renderObject ) {

		const renderObjectData = this.get( renderObject );

		let nodeBuilderState = renderObjectData.nodeBuilderState;

		if ( nodeBuilderState === undefined ) {

			const { nodeBuilderCache } = this;

			const cacheKey = this.getForRenderCacheKey( renderObject );

			nodeBuilderState = nodeBuilderCache.get( cacheKey );

			if ( nodeBuilderState === undefined ) {

				const nodeBuilder = this.backend.createNodeBuilder( renderObject.object, this.renderer );
				nodeBuilder.scene = renderObject.scene;
				nodeBuilder.material = renderObject.material;
				nodeBuilder.camera = renderObject.camera;
				nodeBuilder.context.material = renderObject.material;
				nodeBuilder.lightsNode = renderObject.lightsNode;
				nodeBuilder.environmentNode = this.getEnvironmentNode( renderObject.scene );
				nodeBuilder.fogNode = this.getFogNode( renderObject.scene );
				nodeBuilder.clippingContext = renderObject.clippingContext;
				nodeBuilder.build();

				nodeBuilderState = this._createNodeBuilderState( nodeBuilder );

				nodeBuilderCache.set( cacheKey, nodeBuilderState );

			}

			nodeBuilderState.usedTimes ++;

			renderObjectData.nodeBuilderState = nodeBuilderState;

		}

		return nodeBuilderState;

	}

	delete( object ) {

		if ( object.isRenderObject ) {

			const nodeBuilderState = this.get( object ).nodeBuilderState;
			nodeBuilderState.usedTimes --;

			if ( nodeBuilderState.usedTimes === 0 ) {

				this.nodeBuilderCache.delete( this.getForRenderCacheKey( object ) );

			}

		}

		return super.delete( object );

	}

	getForCompute( computeNode ) {

		const computeData = this.get( computeNode );

		let nodeBuilderState = computeData.nodeBuilderState;

		if ( nodeBuilderState === undefined ) {

			const nodeBuilder = this.backend.createNodeBuilder( computeNode, this.renderer );
			nodeBuilder.build();

			nodeBuilderState = this._createNodeBuilderState( nodeBuilder );

			computeData.nodeBuilderState = nodeBuilderState;

		}

		return nodeBuilderState;

	}

	_createNodeBuilderState( nodeBuilder ) {

		return new NodeBuilderState(
			nodeBuilder.vertexShader,
			nodeBuilder.fragmentShader,
			nodeBuilder.computeShader,
			nodeBuilder.getAttributesArray(),
			nodeBuilder.getBindings(),
			nodeBuilder.updateNodes,
			nodeBuilder.updateBeforeNodes,
			nodeBuilder.updateAfterNodes,
			nodeBuilder.monitor,
			nodeBuilder.transforms
		);

	}

	getEnvironmentNode( scene ) {

		return scene.environmentNode || this.get( scene ).environmentNode || null;

	}

	getBackgroundNode( scene ) {

		return scene.backgroundNode || this.get( scene ).backgroundNode || null;

	}

	getFogNode( scene ) {

		return scene.fogNode || this.get( scene ).fogNode || null;

	}

	getCacheKey( scene, lightsNode ) {

		const chain = [ scene, lightsNode ];
		const callId = this.renderer.info.calls;

		let cacheKeyData = this.callHashCache.get( chain );

		if ( cacheKeyData === undefined || cacheKeyData.callId !== callId ) {

			const environmentNode = this.getEnvironmentNode( scene );
			const fogNode = this.getFogNode( scene );

			const values = [];

			if ( lightsNode ) values.push( lightsNode.getCacheKey( true ) );
			if ( environmentNode ) values.push( environmentNode.getCacheKey() );
			if ( fogNode ) values.push( fogNode.getCacheKey() );

			values.push( this.renderer.shadowMap.enabled ? 1 : 0 );

			cacheKeyData = {
				callId,
				cacheKey: hashArray( values )
			};

			this.callHashCache.set( chain, cacheKeyData );

		}

		return cacheKeyData.cacheKey;

	}

	updateScene( scene ) {

		this.updateEnvironment( scene );
		this.updateFog( scene );
		this.updateBackground( scene );

	}

	get isToneMappingState() {

		return this.renderer.getRenderTarget() ? false : true;

	}

	updateBackground( scene ) {

		const sceneData = this.get( scene );
		const background = scene.background;

		if ( background ) {

			const forceUpdate = ( scene.backgroundBlurriness === 0 && sceneData.backgroundBlurriness > 0 ) || ( scene.backgroundBlurriness > 0 && sceneData.backgroundBlurriness === 0 );

			if ( sceneData.background !== background || forceUpdate ) {

				let backgroundNode = null;

				if ( background.isCubeTexture === true || ( background.mapping === EquirectangularReflectionMapping || background.mapping === EquirectangularRefractionMapping || background.mapping === CubeUVReflectionMapping ) ) {

					if ( scene.backgroundBlurriness > 0 || background.mapping === CubeUVReflectionMapping ) {

						backgroundNode = pmremTexture( background );

					} else {

						let envMap;

						if ( background.isCubeTexture === true ) {

							envMap = cubeTexture( background );

						} else {

							envMap = texture( background );

						}

						backgroundNode = cubeMapNode( envMap );

					}

				} else if ( background.isTexture === true ) {

					backgroundNode = texture( background, screenUV.flipY() ).setUpdateMatrix( true );

				} else if ( background.isColor !== true ) {

					console.error( 'WebGPUNodes: Unsupported background configuration.', background );

				}

				sceneData.backgroundNode = backgroundNode;
				sceneData.background = background;
				sceneData.backgroundBlurriness = scene.backgroundBlurriness;

			}

		} else if ( sceneData.backgroundNode ) {

			delete sceneData.backgroundNode;
			delete sceneData.background;

		}

	}

	updateFog( scene ) {

		const sceneData = this.get( scene );
		const sceneFog = scene.fog;

		if ( sceneFog ) {

			if ( sceneData.fog !== sceneFog ) {

				let fogNode = null;

				if ( sceneFog.isFogExp2 ) {

					const color = reference( 'color', 'color', sceneFog ).setGroup( renderGroup );
					const density = reference( 'density', 'float', sceneFog ).setGroup( renderGroup );

					fogNode = fog( color, densityFogFactor( density ) );

				} else if ( sceneFog.isFog ) {

					const color = reference( 'color', 'color', sceneFog ).setGroup( renderGroup );
					const near = reference( 'near', 'float', sceneFog ).setGroup( renderGroup );
					const far = reference( 'far', 'float', sceneFog ).setGroup( renderGroup );

					fogNode = fog( color, rangeFogFactor( near, far ) );

				} else {

					console.error( 'WebGPUNodes: Unsupported fog configuration.', sceneFog );

				}

				sceneData.fogNode = fogNode;
				sceneData.fog = sceneFog;

			}

		} else {

			delete sceneData.fogNode;
			delete sceneData.fog;

		}

	}

	updateEnvironment( scene ) {

		const sceneData = this.get( scene );
		const environment = scene.environment;

		if ( environment ) {

			if ( sceneData.environment !== environment ) {

				let environmentNode = null;

				if ( environment.isCubeTexture === true ) {

					environmentNode = cubeTexture( environment );

				} else if ( environment.isTexture === true ) {

					environmentNode = texture( environment );

				} else {

					console.error( 'Nodes: Unsupported environment configuration.', environment );

				}

				sceneData.environmentNode = environmentNode;
				sceneData.environment = environment;

			}

		} else if ( sceneData.environmentNode ) {

			delete sceneData.environmentNode;
			delete sceneData.environment;

		}

	}

	getNodeFrame( renderer = this.renderer, scene = null, object = null, camera = null, material = null ) {

		const nodeFrame = this.nodeFrame;
		nodeFrame.renderer = renderer;
		nodeFrame.scene = scene;
		nodeFrame.object = object;
		nodeFrame.camera = camera;
		nodeFrame.material = material;

		return nodeFrame;

	}

	getNodeFrameForRender( renderObject ) {

		return this.getNodeFrame( renderObject.renderer, renderObject.scene, renderObject.object, renderObject.camera, renderObject.material );

	}

	getOutputCacheKey() {

		const renderer = this.renderer;

		return renderer.toneMapping + ',' + renderer.currentColorSpace;

	}

	hasOutputChange( outputTarget ) {

		const cacheKey = outputNodeMap.get( outputTarget );

		return cacheKey !== this.getOutputCacheKey();

	}

	getOutputNode( outputTexture ) {

		const renderer = this.renderer;
		const cacheKey = this.getOutputCacheKey();

		const output = texture( outputTexture, screenUV ).renderOutput( renderer.toneMapping, renderer.currentColorSpace );

		outputNodeMap.set( outputTexture, cacheKey );

		return output;

	}

	updateBefore( renderObject ) {

		const nodeBuilder = renderObject.getNodeBuilderState();

		for ( const node of nodeBuilder.updateBeforeNodes ) {

			// update frame state for each node

			this.getNodeFrameForRender( renderObject ).updateBeforeNode( node );

		}

	}

	updateAfter( renderObject ) {

		const nodeBuilder = renderObject.getNodeBuilderState();

		for ( const node of nodeBuilder.updateAfterNodes ) {

			// update frame state for each node

			this.getNodeFrameForRender( renderObject ).updateAfterNode( node );

		}

	}

	updateForCompute( computeNode ) {

		const nodeFrame = this.getNodeFrame();
		const nodeBuilder = this.getForCompute( computeNode );

		for ( const node of nodeBuilder.updateNodes ) {

			nodeFrame.updateNode( node );

		}

	}

	updateForRender( renderObject ) {

		const nodeFrame = this.getNodeFrameForRender( renderObject );
		const nodeBuilder = renderObject.getNodeBuilderState();

		for ( const node of nodeBuilder.updateNodes ) {

			nodeFrame.updateNode( node );

		}

	}

	needsRefresh( renderObject ) {

		const nodeFrame = this.getNodeFrameForRender( renderObject );
		const monitor = renderObject.getMonitor();

		return monitor.needsRefresh( renderObject, nodeFrame );

	}

	dispose() {

		super.dispose();

		this.nodeFrame = new NodeFrame();
		this.nodeBuilderCache = new Map();

	}

}

const _plane = /*@__PURE__*/ new Plane();

class ClippingContext {

	constructor( parentContext = null ) {

		this.version = 0;

		this.clipIntersection = null;
		this.cacheKey = '';


		if ( parentContext === null ) {

			this.intersectionPlanes = [];
			this.unionPlanes = [];

			this.viewNormalMatrix = new Matrix3();
			this.clippingGroupContexts = new WeakMap();

			this.shadowPass = false;

		} else {

			this.viewNormalMatrix = parentContext.viewNormalMatrix;
			this.clippingGroupContexts = parentContext.clippingGroupContexts;

			this.shadowPass = parentContext.shadowPass;

			this.viewMatrix = parentContext.viewMatrix;

		}

		this.parentVersion = null;

	}

	projectPlanes( source, destination, offset ) {

		const l = source.length;

		for ( let i = 0; i < l; i ++ ) {

			_plane.copy( source[ i ] ).applyMatrix4( this.viewMatrix, this.viewNormalMatrix );

			const v = destination[ offset + i ];
			const normal = _plane.normal;

			v.x = - normal.x;
			v.y = - normal.y;
			v.z = - normal.z;
			v.w = _plane.constant;

		}

	}

	updateGlobal( scene, camera ) {

		this.shadowPass = ( scene.overrideMaterial !== null && scene.overrideMaterial.isShadowNodeMaterial );
		this.viewMatrix = camera.matrixWorldInverse;

		this.viewNormalMatrix.getNormalMatrix( this.viewMatrix );

	}

	update( parentContext, clippingGroup ) {

		let update = false;

		if ( parentContext.version !== this.parentVersion ) {

			this.intersectionPlanes = Array.from( parentContext.intersectionPlanes );
			this.unionPlanes = Array.from( parentContext.unionPlanes );
			this.parentVersion = parentContext.version;

		}

		if ( this.clipIntersection !== clippingGroup.clipIntersection ) {

			this.clipIntersection = clippingGroup.clipIntersection;

			if ( this.clipIntersection ) {

				this.unionPlanes.length = parentContext.unionPlanes.length;

			} else {

				this.intersectionPlanes.length = parentContext.intersectionPlanes.length;

			}

		}

		const srcClippingPlanes = clippingGroup.clippingPlanes;
		const l = srcClippingPlanes.length;

		let dstClippingPlanes;
		let offset;

		if ( this.clipIntersection ) {

			dstClippingPlanes = this.intersectionPlanes;
			offset = parentContext.intersectionPlanes.length;

		} else {

			dstClippingPlanes = this.unionPlanes;
			offset = parentContext.unionPlanes.length;

		}

		if ( dstClippingPlanes.length !== offset + l ) {

			dstClippingPlanes.length = offset + l;

			for ( let i = 0; i < l; i ++ ) {

				dstClippingPlanes[ offset + i ] = new Vector4();

			}

			update = true;

		}

		this.projectPlanes( srcClippingPlanes, dstClippingPlanes, offset );

		if ( update ) {

			this.version ++;
			this.cacheKey = `${ this.intersectionPlanes.length }:${ this.unionPlanes.length }`;

		}

	}

	getGroupContext( clippingGroup ) {

		if ( this.shadowPass && ! clippingGroup.clipShadows ) return this;

		let context = this.clippingGroupContexts.get( clippingGroup );

		if ( context === undefined ) {

			context = new ClippingContext( this );
			this.clippingGroupContexts.set( clippingGroup, context );

		}

		context.update( this, clippingGroup );

		return context;

	}

	get unionClippingCount() {

		return this.unionPlanes.length;

	}

}

class RenderBundle {

	constructor( scene, camera ) {

		this.scene = scene;
		this.camera = camera;

	}

	clone() {

		return Object.assign( new this.constructor(), this );

	}

}

class RenderBundles {

	constructor() {

		this.lists = new ChainMap();

	}

	get( scene, camera ) {

		const lists = this.lists;
		const keys = [ scene, camera ];

		let list = lists.get( keys );

		if ( list === undefined ) {

			list = new RenderBundle( scene, camera );
			lists.set( keys, list );

		}

		return list;

	}

	dispose() {

		this.lists = new ChainMap();

	}

}

class NodeLibrary {

	constructor() {

		this.lightNodes = new WeakMap();
		this.materialNodes = new Map();
		this.toneMappingNodes = new Map();

	}

	fromMaterial( material ) {

		if ( material.isNodeMaterial ) return material;

		let nodeMaterial = null;

		const nodeMaterialClass = this.getMaterialNodeClass( material.type );

		if ( nodeMaterialClass !== null ) {

			nodeMaterial = new nodeMaterialClass();

			for ( const key in material ) {

				nodeMaterial[ key ] = material[ key ];

			}

		}

		return nodeMaterial;

	}

	addToneMapping( toneMappingNode, toneMapping ) {

		this.addType( toneMappingNode, toneMapping, this.toneMappingNodes );

	}

	getToneMappingFunction( toneMapping ) {

		return this.toneMappingNodes.get( toneMapping ) || null;

	}

	getMaterialNodeClass( materialType ) {

		return this.materialNodes.get( materialType ) || null;

	}

	addMaterial( materialNodeClass, materialClassType ) {

		this.addType( materialNodeClass, materialClassType, this.materialNodes );

	}

	getLightNodeClass( light ) {

		return this.lightNodes.get( light ) || null;

	}

	addLight( lightNodeClass, lightClass ) {

		this.addClass( lightNodeClass, lightClass, this.lightNodes );

	}

	addType( nodeClass, type, library ) {

		if ( library.has( type ) ) {

			console.warn( `Redefinition of node ${ type }` );
			return;

		}

		if ( typeof nodeClass !== 'function' ) throw new Error( `Node class ${ nodeClass.name } is not a class.` );
		if ( typeof type === 'function' || typeof type === 'object' ) throw new Error( `Base class ${ type } is not a class.` );

		library.set( type, nodeClass );

	}

	addClass( nodeClass, baseClass, library ) {

		if ( library.has( baseClass ) ) {

			console.warn( `Redefinition of node ${ baseClass.name }` );
			return;

		}

		if ( typeof nodeClass !== 'function' ) throw new Error( `Node class ${ nodeClass.name } is not a class.` );
		if ( typeof baseClass !== 'function' ) throw new Error( `Base class ${ baseClass.name } is not a class.` );

		library.set( baseClass, nodeClass );

	}

}

const _defaultLights = /*@__PURE__*/ new LightsNode();

class Lighting extends ChainMap {

	constructor() {

		super();

	}

	createNode( lights = [] ) {

		return new LightsNode().setLights( lights );

	}

	getNode( scene, camera ) {

		// ignore post-processing

		if ( scene.isQuadMesh ) return _defaultLights;

		// tiled lighting

		const keys = [ scene, camera ];

		let node = this.get( keys );

		if ( node === undefined ) {

			node = this.createNode();
			this.set( keys, node );

		}

		return node;

	}

}

const _scene = /*@__PURE__*/ new Scene();
const _drawingBufferSize = /*@__PURE__*/ new Vector2();
const _screen = /*@__PURE__*/ new Vector4();
const _frustum = /*@__PURE__*/ new Frustum();
const _projScreenMatrix = /*@__PURE__*/ new Matrix4();
const _vector4 = /*@__PURE__*/ new Vector4();

class Renderer {

	constructor( backend, parameters = {} ) {

		this.isRenderer = true;

		//

		const {
			logarithmicDepthBuffer = false,
			alpha = true,
			depth = true,
			stencil = false,
			antialias = false,
			samples = 0,
			getFallback = null
		} = parameters;

		// public
		this.domElement = backend.getDomElement();

		this.backend = backend;

		this.samples = samples || ( antialias === true ) ? 4 : 0;

		this.autoClear = true;
		this.autoClearColor = true;
		this.autoClearDepth = true;
		this.autoClearStencil = true;

		this.alpha = alpha;

		this.logarithmicDepthBuffer = logarithmicDepthBuffer;

		this.outputColorSpace = SRGBColorSpace;

		this.toneMapping = NoToneMapping;
		this.toneMappingExposure = 1.0;

		this.sortObjects = true;

		this.depth = depth;
		this.stencil = stencil;

		this.info = new Info();

		this.nodes = {
			modelViewMatrix: null,
			modelNormalViewMatrix: null
		};

		this.library = new NodeLibrary();
		this.lighting = new Lighting();

		// internals

		this._getFallback = getFallback;

		this._pixelRatio = 1;
		this._width = this.domElement.width;
		this._height = this.domElement.height;

		this._viewport = new Vector4( 0, 0, this._width, this._height );
		this._scissor = new Vector4( 0, 0, this._width, this._height );
		this._scissorTest = false;

		this._attributes = null;
		this._geometries = null;
		this._nodes = null;
		this._animation = null;
		this._bindings = null;
		this._objects = null;
		this._pipelines = null;
		this._bundles = null;
		this._renderLists = null;
		this._renderContexts = null;
		this._textures = null;
		this._background = null;

		this._quad = new QuadMesh( new NodeMaterial() );
		this._quad.material.type = 'Renderer_output';

		this._currentRenderContext = null;

		this._opaqueSort = null;
		this._transparentSort = null;

		this._frameBufferTarget = null;

		const alphaClear = this.alpha === true ? 0 : 1;

		this._clearColor = new Color4( 0, 0, 0, alphaClear );
		this._clearDepth = 1;
		this._clearStencil = 0;

		this._renderTarget = null;
		this._activeCubeFace = 0;
		this._activeMipmapLevel = 0;

		this._mrt = null;

		this._renderObjectFunction = null;
		this._currentRenderObjectFunction = null;
		this._currentRenderBundle = null;

		this._handleObjectFunction = this._renderObjectDirect;

		this._isDeviceLost = false;
		this.onDeviceLost = this._onDeviceLost;

		this._initialized = false;
		this._initPromise = null;

		this._compilationPromises = null;

		this.transparent = true;
		this.opaque = true;

		this.shadowMap = {
			enabled: false,
			type: PCFShadowMap
		};

		this.xr = {
			enabled: false
		};

		this.debug = {
			checkShaderErrors: true,
			onShaderError: null,
			getShaderAsync: async ( scene, camera, object ) => {

				await this.compileAsync( scene, camera );

				const renderList = this._renderLists.get( scene, camera );
				const renderContext = this._renderContexts.get( scene, camera, this._renderTarget );

				const material = scene.overrideMaterial || object.material;

				const renderObject = this._objects.get( object, material, scene, camera, renderList.lightsNode, renderContext, renderContext.clippingContext );

				const { fragmentShader, vertexShader } = renderObject.getNodeBuilderState();

				return { fragmentShader, vertexShader };

			}
		};

	}

	async init() {

		if ( this._initialized ) {

			throw new Error( 'Renderer: Backend has already been initialized.' );

		}

		if ( this._initPromise !== null ) {

			return this._initPromise;

		}

		this._initPromise = new Promise( async ( resolve, reject ) => {

			let backend = this.backend;

			try {

				await backend.init( this );

			} catch ( error ) {

				if ( this._getFallback !== null ) {

					// try the fallback

					try {

						this.backend = backend = this._getFallback( error );
						await backend.init( this );

					} catch ( error ) {

						reject( error );
						return;

					}

				} else {

					reject( error );
					return;

				}

			}

			this._nodes = new Nodes( this, backend );
			this._animation = new Animation( this._nodes, this.info );
			this._attributes = new Attributes( backend );
			this._background = new Background( this, this._nodes );
			this._geometries = new Geometries( this._attributes, this.info );
			this._textures = new Textures( this, backend, this.info );
			this._pipelines = new Pipelines( backend, this._nodes );
			this._bindings = new Bindings( backend, this._nodes, this._textures, this._attributes, this._pipelines, this.info );
			this._objects = new RenderObjects( this, this._nodes, this._geometries, this._pipelines, this._bindings, this.info );
			this._renderLists = new RenderLists( this.lighting );
			this._bundles = new RenderBundles();
			this._renderContexts = new RenderContexts();

			//

			this._animation.start();
			this._initialized = true;

			resolve();

		} );

		return this._initPromise;

	}

	get coordinateSystem() {

		return this.backend.coordinateSystem;

	}

	async compileAsync( scene, camera, targetScene = null ) {

		if ( this._isDeviceLost === true ) return;

		if ( this._initialized === false ) await this.init();

		// preserve render tree

		const nodeFrame = this._nodes.nodeFrame;

		const previousRenderId = nodeFrame.renderId;
		const previousRenderContext = this._currentRenderContext;
		const previousRenderObjectFunction = this._currentRenderObjectFunction;
		const previousCompilationPromises = this._compilationPromises;

		//

		const sceneRef = ( scene.isScene === true ) ? scene : _scene;

		if ( targetScene === null ) targetScene = scene;

		const renderTarget = this._renderTarget;
		const renderContext = this._renderContexts.get( targetScene, camera, renderTarget );
		const activeMipmapLevel = this._activeMipmapLevel;

		const compilationPromises = [];

		this._currentRenderContext = renderContext;
		this._currentRenderObjectFunction = this.renderObject;

		this._handleObjectFunction = this._createObjectPipeline;

		this._compilationPromises = compilationPromises;

		nodeFrame.renderId ++;

		//

		nodeFrame.update();

		//

		renderContext.depth = this.depth;
		renderContext.stencil = this.stencil;

		if ( ! renderContext.clippingContext ) renderContext.clippingContext = new ClippingContext();
		renderContext.clippingContext.updateGlobal( sceneRef, camera );

		//

		sceneRef.onBeforeRender( this, scene, camera, renderTarget );

		//

		const renderList = this._renderLists.get( scene, camera );
		renderList.begin();

		this._projectObject( scene, camera, 0, renderList, renderContext.clippingContext );

		// include lights from target scene
		if ( targetScene !== scene ) {

			targetScene.traverseVisible( function ( object ) {

				if ( object.isLight && object.layers.test( camera.layers ) ) {

					renderList.pushLight( object );

				}

			} );

		}

		renderList.finish();

		//

		if ( renderTarget !== null ) {

			this._textures.updateRenderTarget( renderTarget, activeMipmapLevel );

			const renderTargetData = this._textures.get( renderTarget );

			renderContext.textures = renderTargetData.textures;
			renderContext.depthTexture = renderTargetData.depthTexture;

		} else {

			renderContext.textures = null;
			renderContext.depthTexture = null;

		}

		//

		this._nodes.updateScene( sceneRef );

		//

		this._background.update( sceneRef, renderList, renderContext );

		// process render lists

		const opaqueObjects = renderList.opaque;
		const transparentObjects = renderList.transparent;
		const transparentDoublePassObjects = renderList.transparentDoublePass;
		const lightsNode = renderList.lightsNode;

		if ( this.opaque === true && opaqueObjects.length > 0 ) this._renderObjects( opaqueObjects, camera, sceneRef, lightsNode );
		if ( this.transparent === true && transparentObjects.length > 0 ) this._renderTransparents( transparentObjects, transparentDoublePassObjects, camera, sceneRef, lightsNode );

		// restore render tree

		nodeFrame.renderId = previousRenderId;

		this._currentRenderContext = previousRenderContext;
		this._currentRenderObjectFunction = previousRenderObjectFunction;
		this._compilationPromises = previousCompilationPromises;

		this._handleObjectFunction = this._renderObjectDirect;

		// wait for all promises setup by backends awaiting compilation/linking/pipeline creation to complete

		await Promise.all( compilationPromises );

	}

	async renderAsync( scene, camera ) {

		if ( this._initialized === false ) await this.init();

		const renderContext = this._renderScene( scene, camera );

		await this.backend.resolveTimestampAsync( renderContext, 'render' );

	}

	async waitForGPU() {

		await this.backend.waitForGPU();

	}

	setMRT( mrt ) {

		this._mrt = mrt;

		return this;

	}

	getMRT() {

		return this._mrt;

	}

	_onDeviceLost( info ) {

		let errorMessage = `THREE.WebGPURenderer: ${info.api} Device Lost:\n\nMessage: ${info.message}`;

		if ( info.reason ) {

			errorMessage += `\nReason: ${info.reason}`;

		}

		console.error( errorMessage );

		this._isDeviceLost = true;

	}


	_renderBundle( bundle, sceneRef, lightsNode ) {

		const { bundleGroup, camera, renderList } = bundle;

		const renderContext = this._currentRenderContext;

		//

		const renderBundle = this._bundles.get( bundleGroup, camera );
		const renderBundleData = this.backend.get( renderBundle );

		if ( renderBundleData.renderContexts === undefined ) renderBundleData.renderContexts = new Set();

		//

		const needsUpdate = bundleGroup.version !== renderBundleData.version;
		const renderBundleNeedsUpdate = renderBundleData.renderContexts.has( renderContext ) === false || needsUpdate;

		renderBundleData.renderContexts.add( renderContext );

		if ( renderBundleNeedsUpdate ) {

			this.backend.beginBundle( renderContext );

			if ( renderBundleData.renderObjects === undefined || needsUpdate ) {

				renderBundleData.renderObjects = [];

			}

			this._currentRenderBundle = renderBundle;

			const opaqueObjects = renderList.opaque;

			if ( this.opaque === true && opaqueObjects.length > 0 ) this._renderObjects( opaqueObjects, camera, sceneRef, lightsNode );

			this._currentRenderBundle = null;

			//

			this.backend.finishBundle( renderContext, renderBundle );

			renderBundleData.version = bundleGroup.version;

		} else {

			const { renderObjects } = renderBundleData;

			for ( let i = 0, l = renderObjects.length; i < l; i ++ ) {

				const renderObject = renderObjects[ i ];

				if ( this._nodes.needsRefresh( renderObject ) ) {

					this._nodes.updateBefore( renderObject );

					this._nodes.updateForRender( renderObject );
					this._bindings.updateForRender( renderObject );

					this._nodes.updateAfter( renderObject );

				}

			}

		}

		this.backend.addBundle( renderContext, renderBundle );

	}

	render( scene, camera ) {

		if ( this._initialized === false ) {

			console.warn( 'THREE.Renderer: .render() called before the backend is initialized. Try using .renderAsync() instead.' );

			return this.renderAsync( scene, camera );

		}

		this._renderScene( scene, camera );

	}

	_getFrameBufferTarget() {

		const { currentToneMapping, currentColorSpace } = this;

		const useToneMapping = currentToneMapping !== NoToneMapping;
		const useColorSpace = currentColorSpace !== LinearSRGBColorSpace;

		if ( useToneMapping === false && useColorSpace === false ) return null;

		const { width, height } = this.getDrawingBufferSize( _drawingBufferSize );
		const { depth, stencil } = this;

		let frameBufferTarget = this._frameBufferTarget;

		if ( frameBufferTarget === null ) {

			frameBufferTarget = new RenderTarget( width, height, {
				depthBuffer: depth,
				stencilBuffer: stencil,
				type: HalfFloatType, // FloatType
				format: RGBAFormat,
				colorSpace: LinearSRGBColorSpace,
				generateMipmaps: false,
				minFilter: LinearFilter,
				magFilter: LinearFilter,
				samples: this.samples
			} );

			frameBufferTarget.isPostProcessingRenderTarget = true;

			this._frameBufferTarget = frameBufferTarget;

		}

		frameBufferTarget.depthBuffer = depth;
		frameBufferTarget.stencilBuffer = stencil;
		frameBufferTarget.setSize( width, height );
		frameBufferTarget.viewport.copy( this._viewport );
		frameBufferTarget.scissor.copy( this._scissor );
		frameBufferTarget.viewport.multiplyScalar( this._pixelRatio );
		frameBufferTarget.scissor.multiplyScalar( this._pixelRatio );
		frameBufferTarget.scissorTest = this._scissorTest;

		return frameBufferTarget;

	}

	_renderScene( scene, camera, useFrameBufferTarget = true ) {

		if ( this._isDeviceLost === true ) return;

		const frameBufferTarget = useFrameBufferTarget ? this._getFrameBufferTarget() : null;

		// preserve render tree

		const nodeFrame = this._nodes.nodeFrame;

		const previousRenderId = nodeFrame.renderId;
		const previousRenderContext = this._currentRenderContext;
		const previousRenderObjectFunction = this._currentRenderObjectFunction;

		//

		const sceneRef = ( scene.isScene === true ) ? scene : _scene;

		const outputRenderTarget = this._renderTarget;

		const activeCubeFace = this._activeCubeFace;
		const activeMipmapLevel = this._activeMipmapLevel;

		//

		let renderTarget;

		if ( frameBufferTarget !== null ) {

			renderTarget = frameBufferTarget;

			this.setRenderTarget( renderTarget );

		} else {

			renderTarget = outputRenderTarget;

		}

		//

		const renderContext = this._renderContexts.get( scene, camera, renderTarget );

		this._currentRenderContext = renderContext;
		this._currentRenderObjectFunction = this._renderObjectFunction || this.renderObject;

		//

		this.info.calls ++;
		this.info.render.calls ++;
		this.info.render.frameCalls ++;

		nodeFrame.renderId = this.info.calls;

		//

		const coordinateSystem = this.coordinateSystem;

		if ( camera.coordinateSystem !== coordinateSystem ) {

			camera.coordinateSystem = coordinateSystem;

			camera.updateProjectionMatrix();

		}

		//

		if ( scene.matrixWorldAutoUpdate === true ) scene.updateMatrixWorld();

		if ( camera.parent === null && camera.matrixWorldAutoUpdate === true ) camera.updateMatrixWorld();

		//

		let viewport = this._viewport;
		let scissor = this._scissor;
		let pixelRatio = this._pixelRatio;

		if ( renderTarget !== null ) {

			viewport = renderTarget.viewport;
			scissor = renderTarget.scissor;
			pixelRatio = 1;

		}

		this.getDrawingBufferSize( _drawingBufferSize );

		_screen.set( 0, 0, _drawingBufferSize.width, _drawingBufferSize.height );

		const minDepth = ( viewport.minDepth === undefined ) ? 0 : viewport.minDepth;
		const maxDepth = ( viewport.maxDepth === undefined ) ? 1 : viewport.maxDepth;

		renderContext.viewportValue.copy( viewport ).multiplyScalar( pixelRatio ).floor();
		renderContext.viewportValue.width >>= activeMipmapLevel;
		renderContext.viewportValue.height >>= activeMipmapLevel;
		renderContext.viewportValue.minDepth = minDepth;
		renderContext.viewportValue.maxDepth = maxDepth;
		renderContext.viewport = renderContext.viewportValue.equals( _screen ) === false;

		renderContext.scissorValue.copy( scissor ).multiplyScalar( pixelRatio ).floor();
		renderContext.scissor = this._scissorTest && renderContext.scissorValue.equals( _screen ) === false;
		renderContext.scissorValue.width >>= activeMipmapLevel;
		renderContext.scissorValue.height >>= activeMipmapLevel;

		if ( ! renderContext.clippingContext ) renderContext.clippingContext = new ClippingContext();
		renderContext.clippingContext.updateGlobal( sceneRef, camera );

		//

		sceneRef.onBeforeRender( this, scene, camera, renderTarget );

		//

		_projScreenMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );
		_frustum.setFromProjectionMatrix( _projScreenMatrix, coordinateSystem );

		const renderList = this._renderLists.get( scene, camera );
		renderList.begin();

		this._projectObject( scene, camera, 0, renderList, renderContext.clippingContext );

		renderList.finish();

		if ( this.sortObjects === true ) {

			renderList.sort( this._opaqueSort, this._transparentSort );

		}

		//

		if ( renderTarget !== null ) {

			this._textures.updateRenderTarget( renderTarget, activeMipmapLevel );

			const renderTargetData = this._textures.get( renderTarget );

			renderContext.textures = renderTargetData.textures;
			renderContext.depthTexture = renderTargetData.depthTexture;
			renderContext.width = renderTargetData.width;
			renderContext.height = renderTargetData.height;
			renderContext.renderTarget = renderTarget;
			renderContext.depth = renderTarget.depthBuffer;
			renderContext.stencil = renderTarget.stencilBuffer;

		} else {

			renderContext.textures = null;
			renderContext.depthTexture = null;
			renderContext.width = this.domElement.width;
			renderContext.height = this.domElement.height;
			renderContext.depth = this.depth;
			renderContext.stencil = this.stencil;

		}

		renderContext.width >>= activeMipmapLevel;
		renderContext.height >>= activeMipmapLevel;
		renderContext.activeCubeFace = activeCubeFace;
		renderContext.activeMipmapLevel = activeMipmapLevel;
		renderContext.occlusionQueryCount = renderList.occlusionQueryCount;

		//

		this._nodes.updateScene( sceneRef );

		//

		this._background.update( sceneRef, renderList, renderContext );

		//

		this.backend.beginRender( renderContext );

		// process render lists

		const {
			bundles,
			lightsNode,
			transparentDoublePass: transparentDoublePassObjects,
			transparent: transparentObjects,
			opaque: opaqueObjects
		} = renderList;

		if ( bundles.length > 0 ) this._renderBundles( bundles, sceneRef, lightsNode );
		if ( this.opaque === true && opaqueObjects.length > 0 ) this._renderObjects( opaqueObjects, camera, sceneRef, lightsNode );
		if ( this.transparent === true && transparentObjects.length > 0 ) this._renderTransparents( transparentObjects, transparentDoublePassObjects, camera, sceneRef, lightsNode );

		// finish render pass

		this.backend.finishRender( renderContext );

		// restore render tree

		nodeFrame.renderId = previousRenderId;

		this._currentRenderContext = previousRenderContext;
		this._currentRenderObjectFunction = previousRenderObjectFunction;

		//

		if ( frameBufferTarget !== null ) {

			this.setRenderTarget( outputRenderTarget, activeCubeFace, activeMipmapLevel );

			const quad = this._quad;

			if ( this._nodes.hasOutputChange( renderTarget.texture ) ) {

				quad.material.fragmentNode = this._nodes.getOutputNode( renderTarget.texture );
				quad.material.needsUpdate = true;

			}

			this._renderScene( quad, quad.camera, false );

		}

		//

		sceneRef.onAfterRender( this, scene, camera, renderTarget );

		//

		return renderContext;

	}

	getMaxAnisotropy() {

		return this.backend.getMaxAnisotropy();

	}

	getActiveCubeFace() {

		return this._activeCubeFace;

	}

	getActiveMipmapLevel() {

		return this._activeMipmapLevel;

	}

	async setAnimationLoop( callback ) {

		if ( this._initialized === false ) await this.init();

		this._animation.setAnimationLoop( callback );

	}

	async getArrayBufferAsync( attribute ) {

		return await this.backend.getArrayBufferAsync( attribute );

	}

	getContext() {

		return this.backend.getContext();

	}

	getPixelRatio() {

		return this._pixelRatio;

	}

	getDrawingBufferSize( target ) {

		return target.set( this._width * this._pixelRatio, this._height * this._pixelRatio ).floor();

	}

	getSize( target ) {

		return target.set( this._width, this._height );

	}

	setPixelRatio( value = 1 ) {

		if ( this._pixelRatio === value ) return;

		this._pixelRatio = value;

		this.setSize( this._width, this._height, false );

	}

	setDrawingBufferSize( width, height, pixelRatio ) {

		this._width = width;
		this._height = height;

		this._pixelRatio = pixelRatio;

		this.domElement.width = Math.floor( width * pixelRatio );
		this.domElement.height = Math.floor( height * pixelRatio );

		this.setViewport( 0, 0, width, height );

		if ( this._initialized ) this.backend.updateSize();

	}

	setSize( width, height, updateStyle = true ) {

		this._width = width;
		this._height = height;

		this.domElement.width = Math.floor( width * this._pixelRatio );
		this.domElement.height = Math.floor( height * this._pixelRatio );

		if ( updateStyle === true ) {

			this.domElement.style.width = width + 'px';
			this.domElement.style.height = height + 'px';

		}

		this.setViewport( 0, 0, width, height );

		if ( this._initialized ) this.backend.updateSize();

	}

	setOpaqueSort( method ) {

		this._opaqueSort = method;

	}

	setTransparentSort( method ) {

		this._transparentSort = method;

	}

	getScissor( target ) {

		const scissor = this._scissor;

		target.x = scissor.x;
		target.y = scissor.y;
		target.width = scissor.width;
		target.height = scissor.height;

		return target;

	}

	setScissor( x, y, width, height ) {

		const scissor = this._scissor;

		if ( x.isVector4 ) {

			scissor.copy( x );

		} else {

			scissor.set( x, y, width, height );

		}

	}

	getScissorTest() {

		return this._scissorTest;

	}

	setScissorTest( boolean ) {

		this._scissorTest = boolean;

		this.backend.setScissorTest( boolean );

	}

	getViewport( target ) {

		return target.copy( this._viewport );

	}

	setViewport( x, y, width, height, minDepth = 0, maxDepth = 1 ) {

		const viewport = this._viewport;

		if ( x.isVector4 ) {

			viewport.copy( x );

		} else {

			viewport.set( x, y, width, height );

		}

		viewport.minDepth = minDepth;
		viewport.maxDepth = maxDepth;

	}

	getClearColor( target ) {

		return target.copy( this._clearColor );

	}

	setClearColor( color, alpha = 1 ) {

		this._clearColor.set( color );
		this._clearColor.a = alpha;

	}

	getClearAlpha() {

		return this._clearColor.a;

	}

	setClearAlpha( alpha ) {

		this._clearColor.a = alpha;

	}

	getClearDepth() {

		return this._clearDepth;

	}

	setClearDepth( depth ) {

		this._clearDepth = depth;

	}

	getClearStencil() {

		return this._clearStencil;

	}

	setClearStencil( stencil ) {

		this._clearStencil = stencil;

	}

	isOccluded( object ) {

		const renderContext = this._currentRenderContext;

		return renderContext && this.backend.isOccluded( renderContext, object );

	}

	clear( color = true, depth = true, stencil = true ) {

		if ( this._initialized === false ) {

			console.warn( 'THREE.Renderer: .clear() called before the backend is initialized. Try using .clearAsync() instead.' );

			return this.clearAsync( color, depth, stencil );

		}

		const renderTarget = this._renderTarget || this._getFrameBufferTarget();

		let renderTargetData = null;

		if ( renderTarget !== null ) {

			this._textures.updateRenderTarget( renderTarget );

			renderTargetData = this._textures.get( renderTarget );

		}

		this.backend.clear( color, depth, stencil, renderTargetData );

		if ( renderTarget !== null && this._renderTarget === null ) {

			// If a color space transform or tone mapping is required,
			// the clear operation clears the intermediate renderTarget texture, but does not update the screen canvas.

			const quad = this._quad;

			if ( this._nodes.hasOutputChange( renderTarget.texture ) ) {

				quad.material.fragmentNode = this._nodes.getOutputNode( renderTarget.texture );
				quad.material.needsUpdate = true;

			}

			this._renderScene( quad, quad.camera, false );

		}

	}

	clearColor() {

		return this.clear( true, false, false );

	}

	clearDepth() {

		return this.clear( false, true, false );

	}

	clearStencil() {

		return this.clear( false, false, true );

	}

	async clearAsync( color = true, depth = true, stencil = true ) {

		if ( this._initialized === false ) await this.init();

		this.clear( color, depth, stencil );

	}

	clearColorAsync() {

		return this.clearAsync( true, false, false );

	}

	clearDepthAsync() {

		return this.clearAsync( false, true, false );

	}

	clearStencilAsync() {

		return this.clearAsync( false, false, true );

	}

	get currentToneMapping() {

		return this._renderTarget !== null ? NoToneMapping : this.toneMapping;

	}

	get currentColorSpace() {

		return this._renderTarget !== null ? LinearSRGBColorSpace : this.outputColorSpace;

	}

	dispose() {

		this.info.dispose();
		this.backend.dispose();

		this._animation.dispose();
		this._objects.dispose();
		this._pipelines.dispose();
		this._nodes.dispose();
		this._bindings.dispose();
		this._renderLists.dispose();
		this._renderContexts.dispose();
		this._textures.dispose();

		this.setRenderTarget( null );
		this.setAnimationLoop( null );

	}

	setRenderTarget( renderTarget, activeCubeFace = 0, activeMipmapLevel = 0 ) {

		this._renderTarget = renderTarget;
		this._activeCubeFace = activeCubeFace;
		this._activeMipmapLevel = activeMipmapLevel;

	}

	getRenderTarget() {

		return this._renderTarget;

	}

	setRenderObjectFunction( renderObjectFunction ) {

		this._renderObjectFunction = renderObjectFunction;

	}

	getRenderObjectFunction() {

		return this._renderObjectFunction;

	}

	compute( computeNodes ) {

		if ( this.isDeviceLost === true ) return;

		if ( this._initialized === false ) {

			console.warn( 'THREE.Renderer: .compute() called before the backend is initialized. Try using .computeAsync() instead.' );

			return this.computeAsync( computeNodes );

		}

		//

		const nodeFrame = this._nodes.nodeFrame;

		const previousRenderId = nodeFrame.renderId;

		//

		this.info.calls ++;
		this.info.compute.calls ++;
		this.info.compute.frameCalls ++;

		nodeFrame.renderId = this.info.calls;

		//

		const backend = this.backend;
		const pipelines = this._pipelines;
		const bindings = this._bindings;
		const nodes = this._nodes;

		const computeList = Array.isArray( computeNodes ) ? computeNodes : [ computeNodes ];

		if ( computeList[ 0 ] === undefined || computeList[ 0 ].isComputeNode !== true ) {

			throw new Error( 'THREE.Renderer: .compute() expects a ComputeNode.' );

		}

		backend.beginCompute( computeNodes );

		for ( const computeNode of computeList ) {

			// onInit

			if ( pipelines.has( computeNode ) === false ) {

				const dispose = () => {

					computeNode.removeEventListener( 'dispose', dispose );

					pipelines.delete( computeNode );
					bindings.delete( computeNode );
					nodes.delete( computeNode );

				};

				computeNode.addEventListener( 'dispose', dispose );

				//

				const onInitFn = computeNode.onInitFunction;

				if ( onInitFn !== null ) {

					onInitFn.call( computeNode, { renderer: this } );

				}

			}

			nodes.updateForCompute( computeNode );
			bindings.updateForCompute( computeNode );

			const computeBindings = bindings.getForCompute( computeNode );
			const computePipeline = pipelines.getForCompute( computeNode, computeBindings );

			backend.compute( computeNodes, computeNode, computeBindings, computePipeline );

		}

		backend.finishCompute( computeNodes );

		//

		nodeFrame.renderId = previousRenderId;

	}

	async computeAsync( computeNodes ) {

		if ( this._initialized === false ) await this.init();

		this.compute( computeNodes );

		await this.backend.resolveTimestampAsync( computeNodes, 'compute' );

	}

	async hasFeatureAsync( name ) {

		if ( this._initialized === false ) await this.init();

		return this.backend.hasFeature( name );

	}

	hasFeature( name ) {

		if ( this._initialized === false ) {

			console.warn( 'THREE.Renderer: .hasFeature() called before the backend is initialized. Try using .hasFeatureAsync() instead.' );

			return false;

		}

		return this.backend.hasFeature( name );

	}

	hasInitialized() {

		return this._initialized;

	}

	async initTextureAsync( texture ) {

		if ( this._initialized === false ) await this.init();

		this._textures.updateTexture( texture );

	}

	initTexture( texture ) {

		if ( this._initialized === false ) {

			console.warn( 'THREE.Renderer: .initTexture() called before the backend is initialized. Try using .initTextureAsync() instead.' );

			return false;

		}

		this._textures.updateTexture( texture );

	}

	copyFramebufferToTexture( framebufferTexture, rectangle = null ) {

		if ( rectangle !== null ) {

			if ( rectangle.isVector2 ) {

				rectangle = _vector4.set( rectangle.x, rectangle.y, framebufferTexture.image.width, framebufferTexture.image.height ).floor();

			} else if ( rectangle.isVector4 ) {

				rectangle = _vector4.copy( rectangle ).floor();

			} else {

				console.error( 'THREE.Renderer.copyFramebufferToTexture: Invalid rectangle.' );

				return;

			}

		} else {

			rectangle = _vector4.set( 0, 0, framebufferTexture.image.width, framebufferTexture.image.height );

		}

		//

		let renderContext = this._currentRenderContext;
		let renderTarget;

		if ( renderContext !== null ) {

			renderTarget = renderContext.renderTarget;

		} else {

			renderTarget = this._renderTarget || this._getFrameBufferTarget();

			if ( renderTarget !== null ) {

				this._textures.updateRenderTarget( renderTarget );

				renderContext = this._textures.get( renderTarget );

			}

		}

		//

		this._textures.updateTexture( framebufferTexture, { renderTarget } );

		this.backend.copyFramebufferToTexture( framebufferTexture, renderContext, rectangle );

	}

	copyTextureToTexture( srcTexture, dstTexture, srcRegion = null, dstPosition = null, level = 0 ) {

		this._textures.updateTexture( srcTexture );
		this._textures.updateTexture( dstTexture );

		this.backend.copyTextureToTexture( srcTexture, dstTexture, srcRegion, dstPosition, level );

	}

	readRenderTargetPixelsAsync( renderTarget, x, y, width, height, index = 0, faceIndex = 0 ) {

		return this.backend.copyTextureToBuffer( renderTarget.textures[ index ], x, y, width, height, faceIndex );

	}

	_projectObject( object, camera, groupOrder, renderList, clippingContext ) {

		if ( object.visible === false ) return;

		const visible = object.layers.test( camera.layers );

		if ( visible ) {

			if ( object.isGroup ) {

				groupOrder = object.renderOrder;

				if ( object.isClippingGroup && object.enabled ) clippingContext = clippingContext.getGroupContext( object );

			} else if ( object.isLOD ) {

				if ( object.autoUpdate === true ) object.update( camera );

			} else if ( object.isLight ) {

				renderList.pushLight( object );

			} else if ( object.isSprite ) {

				if ( ! object.frustumCulled || _frustum.intersectsSprite( object ) ) {

					if ( this.sortObjects === true ) {

						_vector4.setFromMatrixPosition( object.matrixWorld ).applyMatrix4( _projScreenMatrix );

					}

					const { geometry, material } = object;

					if ( material.visible ) {

						renderList.push( object, geometry, material, groupOrder, _vector4.z, null, clippingContext );

					}

				}

			} else if ( object.isLineLoop ) {

				console.error( 'THREE.Renderer: Objects of type THREE.LineLoop are not supported. Please use THREE.Line or THREE.LineSegments.' );

			} else if ( object.isMesh || object.isLine || object.isPoints ) {

				if ( ! object.frustumCulled || _frustum.intersectsObject( object ) ) {

					const { geometry, material } = object;

					if ( this.sortObjects === true ) {

						if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

						_vector4
							.copy( geometry.boundingSphere.center )
							.applyMatrix4( object.matrixWorld )
							.applyMatrix4( _projScreenMatrix );

					}

					if ( Array.isArray( material ) ) {

						const groups = geometry.groups;

						for ( let i = 0, l = groups.length; i < l; i ++ ) {

							const group = groups[ i ];
							const groupMaterial = material[ group.materialIndex ];

							if ( groupMaterial && groupMaterial.visible ) {

								renderList.push( object, geometry, groupMaterial, groupOrder, _vector4.z, group, clippingContext );

							}

						}

					} else if ( material.visible ) {

						renderList.push( object, geometry, material, groupOrder, _vector4.z, null, clippingContext );

					}

				}

			}

		}

		if ( object.isBundleGroup === true && this.backend.beginBundle !== undefined ) {

			const baseRenderList = renderList;

			// replace render list
			renderList = this._renderLists.get( object, camera );

			renderList.begin();

			baseRenderList.pushBundle( {
				bundleGroup: object,
				camera,
				renderList,
			} );

			renderList.finish();

		}

		const children = object.children;

		for ( let i = 0, l = children.length; i < l; i ++ ) {

			this._projectObject( children[ i ], camera, groupOrder, renderList, clippingContext );

		}

	}

	_renderBundles( bundles, sceneRef, lightsNode ) {

		for ( const bundle of bundles ) {

			this._renderBundle( bundle, sceneRef, lightsNode );

		}

	}

	_renderTransparents( renderList, doublePassList, camera, scene, lightsNode ) {

		if ( doublePassList.length > 0 ) {

			// render back side

			for ( const { material } of doublePassList ) {

				material.side = BackSide;

			}

			this._renderObjects( doublePassList, camera, scene, lightsNode, 'backSide' );

			// render front side

			for ( const { material } of doublePassList ) {

				material.side = FrontSide;

			}

			this._renderObjects( renderList, camera, scene, lightsNode );

			// restore

			for ( const { material } of doublePassList ) {

				material.side = DoubleSide;

			}

		} else {

			this._renderObjects( renderList, camera, scene, lightsNode );

		}

	}

	_renderObjects( renderList, camera, scene, lightsNode, passId = null ) {

		// process renderable objects

		for ( let i = 0, il = renderList.length; i < il; i ++ ) {

			const renderItem = renderList[ i ];

			// @TODO: Add support for multiple materials per object. This will require to extract
			// the material from the renderItem object and pass it with its group data to renderObject().

			const { object, geometry, material, group, clippingContext } = renderItem;

			if ( camera.isArrayCamera ) {

				const cameras = camera.cameras;

				for ( let j = 0, jl = cameras.length; j < jl; j ++ ) {

					const camera2 = cameras[ j ];

					if ( object.layers.test( camera2.layers ) ) {

						const vp = camera2.viewport;
						const minDepth = ( vp.minDepth === undefined ) ? 0 : vp.minDepth;
						const maxDepth = ( vp.maxDepth === undefined ) ? 1 : vp.maxDepth;

						const viewportValue = this._currentRenderContext.viewportValue;
						viewportValue.copy( vp ).multiplyScalar( this._pixelRatio ).floor();
						viewportValue.minDepth = minDepth;
						viewportValue.maxDepth = maxDepth;

						this.backend.updateViewport( this._currentRenderContext );

						this._currentRenderObjectFunction( object, scene, camera2, geometry, material, group, lightsNode, clippingContext, passId );

					}

				}

			} else {

				this._currentRenderObjectFunction( object, scene, camera, geometry, material, group, lightsNode, clippingContext, passId );

			}

		}

	}

	renderObject( object, scene, camera, geometry, material, group, lightsNode, clippingContext = null, passId = null ) {

		let overridePositionNode;
		let overrideColorNode;
		let overrideDepthNode;

		//

		object.onBeforeRender( this, scene, camera, geometry, material, group );

		//

		if ( scene.overrideMaterial !== null ) {

			const overrideMaterial = scene.overrideMaterial;

			if ( material.positionNode && material.positionNode.isNode ) {

				overridePositionNode = overrideMaterial.positionNode;
				overrideMaterial.positionNode = material.positionNode;

			}

			overrideMaterial.alphaTest = material.alphaTest;
			overrideMaterial.alphaMap = material.alphaMap;
			overrideMaterial.transparent = material.transparent || material.transmission > 0;

			if ( overrideMaterial.isShadowNodeMaterial ) {

				overrideMaterial.side = material.shadowSide === null ? material.side : material.shadowSide;

				if ( material.depthNode && material.depthNode.isNode ) {

					overrideDepthNode = overrideMaterial.depthNode;
					overrideMaterial.depthNode = material.depthNode;

				}

				if ( material.castShadowNode && material.castShadowNode.isNode ) {

					overrideColorNode = overrideMaterial.colorNode;
					overrideMaterial.colorNode = material.castShadowNode;

				}

			}

			material = overrideMaterial;

		}

		//

		if ( material.transparent === true && material.side === DoubleSide && material.forceSinglePass === false ) {

			material.side = BackSide;
			this._handleObjectFunction( object, material, scene, camera, lightsNode, group, clippingContext, 'backSide' ); // create backSide pass id

			material.side = FrontSide;
			this._handleObjectFunction( object, material, scene, camera, lightsNode, group, clippingContext, passId ); // use default pass id

			material.side = DoubleSide;

		} else {

			this._handleObjectFunction( object, material, scene, camera, lightsNode, group, clippingContext, passId );

		}

		//

		if ( overridePositionNode !== undefined ) {

			scene.overrideMaterial.positionNode = overridePositionNode;

		}

		if ( overrideDepthNode !== undefined ) {

			scene.overrideMaterial.depthNode = overrideDepthNode;

		}

		if ( overrideColorNode !== undefined ) {

			scene.overrideMaterial.colorNode = overrideColorNode;

		}

		//

		object.onAfterRender( this, scene, camera, geometry, material, group );

	}

	_renderObjectDirect( object, material, scene, camera, lightsNode, group, clippingContext, passId ) {

		const renderObject = this._objects.get( object, material, scene, camera, lightsNode, this._currentRenderContext, clippingContext, passId );
		renderObject.drawRange = object.geometry.drawRange;
		renderObject.group = group;

		//

		const needsRefresh = this._nodes.needsRefresh( renderObject );

		if ( needsRefresh ) {

			this._nodes.updateBefore( renderObject );

			this._geometries.updateForRender( renderObject );

			this._nodes.updateForRender( renderObject );
			this._bindings.updateForRender( renderObject );

		}

		this._pipelines.updateForRender( renderObject );

		//

		if ( this._currentRenderBundle !== null ) {

			const renderBundleData = this.backend.get( this._currentRenderBundle );

			renderBundleData.renderObjects.push( renderObject );

			renderObject.bundle = this._currentRenderBundle.scene;

		}

		this.backend.draw( renderObject, this.info );

		if ( needsRefresh ) this._nodes.updateAfter( renderObject );

	}

	_createObjectPipeline( object, material, scene, camera, lightsNode, group, clippingContext, passId ) {

		const renderObject = this._objects.get( object, material, scene, camera, lightsNode, this._currentRenderContext, clippingContext, passId );
		renderObject.drawRange = object.geometry.drawRange;
		renderObject.group = group;

		//

		this._nodes.updateBefore( renderObject );

		this._geometries.updateForRender( renderObject );

		this._nodes.updateForRender( renderObject );
		this._bindings.updateForRender( renderObject );

		this._pipelines.getForRender( renderObject, this._compilationPromises );

		this._nodes.updateAfter( renderObject );

	}

	get compile() {

		return this.compileAsync;

	}

}

class Binding {

	constructor( name = '' ) {

		this.name = name;

		this.visibility = 0;

	}

	setVisibility( visibility ) {

		this.visibility |= visibility;

	}

	clone() {

		return Object.assign( new this.constructor(), this );

	}

}

function getFloatLength( floatLength ) {

	// ensure chunk size alignment (STD140 layout)

	return floatLength + ( ( GPU_CHUNK_BYTES - ( floatLength % GPU_CHUNK_BYTES ) ) % GPU_CHUNK_BYTES );

}

class Buffer extends Binding {

	constructor( name, buffer = null ) {

		super( name );

		this.isBuffer = true;

		this.bytesPerElement = Float32Array.BYTES_PER_ELEMENT;

		this._buffer = buffer;

	}

	get byteLength() {

		return getFloatLength( this._buffer.byteLength );

	}

	get buffer() {

		return this._buffer;

	}

	update() {

		return true;

	}

}

class UniformBuffer extends Buffer {

	constructor( name, buffer = null ) {

		super( name, buffer );

		this.isUniformBuffer = true;

	}

}

let _id$4 = 0;

class NodeUniformBuffer extends UniformBuffer {

	constructor( nodeUniform, groupNode ) {

		super( 'UniformBuffer_' + _id$4 ++, nodeUniform ? nodeUniform.value : null );

		this.nodeUniform = nodeUniform;
		this.groupNode = groupNode;

	}

	get buffer() {

		return this.nodeUniform.value;

	}

}

class UniformsGroup extends UniformBuffer {

	constructor( name ) {

		super( name );

		this.isUniformsGroup = true;

		this._values = null;

		// the order of uniforms in this array must match the order of uniforms in the shader

		this.uniforms = [];

	}

	addUniform( uniform ) {

		this.uniforms.push( uniform );

		return this;

	}

	removeUniform( uniform ) {

		const index = this.uniforms.indexOf( uniform );

		if ( index !== - 1 ) {

			this.uniforms.splice( index, 1 );

		}

		return this;

	}

	get values() {

		if ( this._values === null ) {

			this._values = Array.from( this.buffer );

		}

		return this._values;

	}

	get buffer() {

		let buffer = this._buffer;

		if ( buffer === null ) {

			const byteLength = this.byteLength;

			buffer = new Float32Array( new ArrayBuffer( byteLength ) );

			this._buffer = buffer;

		}

		return buffer;

	}

	get byteLength() {

		let offset = 0; // global buffer offset in bytes

		for ( let i = 0, l = this.uniforms.length; i < l; i ++ ) {

			const uniform = this.uniforms[ i ];

			const { boundary, itemSize } = uniform;

			// offset within a single chunk in bytes

			const chunkOffset = offset % GPU_CHUNK_BYTES;
			const remainingSizeInChunk = GPU_CHUNK_BYTES - chunkOffset;

			// conformance tests

			if ( chunkOffset !== 0 && ( remainingSizeInChunk - boundary ) < 0 ) {

				// check for chunk overflow

				offset += ( GPU_CHUNK_BYTES - chunkOffset );

			} else if ( chunkOffset % boundary !== 0 ) {

				// check for correct alignment

				offset += ( chunkOffset % boundary );

			}

			uniform.offset = ( offset / this.bytesPerElement );

			offset += ( itemSize * this.bytesPerElement );

		}

		return Math.ceil( offset / GPU_CHUNK_BYTES ) * GPU_CHUNK_BYTES;

	}

	update() {

		let updated = false;

		for ( const uniform of this.uniforms ) {

			if ( this.updateByType( uniform ) === true ) {

				updated = true;

			}

		}

		return updated;

	}

	updateByType( uniform ) {

		if ( uniform.isNumberUniform ) return this.updateNumber( uniform );
		if ( uniform.isVector2Uniform ) return this.updateVector2( uniform );
		if ( uniform.isVector3Uniform ) return this.updateVector3( uniform );
		if ( uniform.isVector4Uniform ) return this.updateVector4( uniform );
		if ( uniform.isColorUniform ) return this.updateColor( uniform );
		if ( uniform.isMatrix3Uniform ) return this.updateMatrix3( uniform );
		if ( uniform.isMatrix4Uniform ) return this.updateMatrix4( uniform );

		console.error( 'THREE.WebGPUUniformsGroup: Unsupported uniform type.', uniform );

	}

	updateNumber( uniform ) {

		let updated = false;

		const a = this.values;
		const v = uniform.getValue();
		const offset = uniform.offset;
		const type = uniform.getType();

		if ( a[ offset ] !== v ) {

			const b = this._getBufferForType( type );

			b[ offset ] = a[ offset ] = v;
			updated = true;

		}

		return updated;

	}

	updateVector2( uniform ) {

		let updated = false;

		const a = this.values;
		const v = uniform.getValue();
		const offset = uniform.offset;
		const type = uniform.getType();

		if ( a[ offset + 0 ] !== v.x || a[ offset + 1 ] !== v.y ) {

			const b = this._getBufferForType( type );

			b[ offset + 0 ] = a[ offset + 0 ] = v.x;
			b[ offset + 1 ] = a[ offset + 1 ] = v.y;

			updated = true;

		}

		return updated;

	}

	updateVector3( uniform ) {

		let updated = false;

		const a = this.values;
		const v = uniform.getValue();
		const offset = uniform.offset;
		const type = uniform.getType();

		if ( a[ offset + 0 ] !== v.x || a[ offset + 1 ] !== v.y || a[ offset + 2 ] !== v.z ) {

			const b = this._getBufferForType( type );

			b[ offset + 0 ] = a[ offset + 0 ] = v.x;
			b[ offset + 1 ] = a[ offset + 1 ] = v.y;
			b[ offset + 2 ] = a[ offset + 2 ] = v.z;

			updated = true;

		}

		return updated;

	}

	updateVector4( uniform ) {

		let updated = false;

		const a = this.values;
		const v = uniform.getValue();
		const offset = uniform.offset;
		const type = uniform.getType();

		if ( a[ offset + 0 ] !== v.x || a[ offset + 1 ] !== v.y || a[ offset + 2 ] !== v.z || a[ offset + 4 ] !== v.w ) {

			const b = this._getBufferForType( type );

			b[ offset + 0 ] = a[ offset + 0 ] = v.x;
			b[ offset + 1 ] = a[ offset + 1 ] = v.y;
			b[ offset + 2 ] = a[ offset + 2 ] = v.z;
			b[ offset + 3 ] = a[ offset + 3 ] = v.w;

			updated = true;

		}

		return updated;

	}

	updateColor( uniform ) {

		let updated = false;

		const a = this.values;
		const c = uniform.getValue();
		const offset = uniform.offset;

		if ( a[ offset + 0 ] !== c.r || a[ offset + 1 ] !== c.g || a[ offset + 2 ] !== c.b ) {

			const b = this.buffer;

			b[ offset + 0 ] = a[ offset + 0 ] = c.r;
			b[ offset + 1 ] = a[ offset + 1 ] = c.g;
			b[ offset + 2 ] = a[ offset + 2 ] = c.b;

			updated = true;

		}

		return updated;

	}

	updateMatrix3( uniform ) {

		let updated = false;

		const a = this.values;
		const e = uniform.getValue().elements;
		const offset = uniform.offset;

		if ( a[ offset + 0 ] !== e[ 0 ] || a[ offset + 1 ] !== e[ 1 ] || a[ offset + 2 ] !== e[ 2 ] ||
			a[ offset + 4 ] !== e[ 3 ] || a[ offset + 5 ] !== e[ 4 ] || a[ offset + 6 ] !== e[ 5 ] ||
			a[ offset + 8 ] !== e[ 6 ] || a[ offset + 9 ] !== e[ 7 ] || a[ offset + 10 ] !== e[ 8 ] ) {

			const b = this.buffer;

			b[ offset + 0 ] = a[ offset + 0 ] = e[ 0 ];
			b[ offset + 1 ] = a[ offset + 1 ] = e[ 1 ];
			b[ offset + 2 ] = a[ offset + 2 ] = e[ 2 ];
			b[ offset + 4 ] = a[ offset + 4 ] = e[ 3 ];
			b[ offset + 5 ] = a[ offset + 5 ] = e[ 4 ];
			b[ offset + 6 ] = a[ offset + 6 ] = e[ 5 ];
			b[ offset + 8 ] = a[ offset + 8 ] = e[ 6 ];
			b[ offset + 9 ] = a[ offset + 9 ] = e[ 7 ];
			b[ offset + 10 ] = a[ offset + 10 ] = e[ 8 ];

			updated = true;

		}

		return updated;

	}

	updateMatrix4( uniform ) {

		let updated = false;

		const a = this.values;
		const e = uniform.getValue().elements;
		const offset = uniform.offset;

		if ( arraysEqual( a, e, offset ) === false ) {

			const b = this.buffer;
			b.set( e, offset );
			setArray( a, e, offset );
			updated = true;

		}

		return updated;

	}

	_getBufferForType( type ) {

		if ( type === 'int' || type === 'ivec2' || type === 'ivec3' || type === 'ivec4' ) return new Int32Array( this.buffer.buffer );
		if ( type === 'uint' || type === 'uvec2' || type === 'uvec3' || type === 'uvec4' ) return new Uint32Array( this.buffer.buffer );
		return this.buffer;

	}

}

function setArray( a, b, offset ) {

	for ( let i = 0, l = b.length; i < l; i ++ ) {

		a[ offset + i ] = b[ i ];

	}

}

function arraysEqual( a, b, offset ) {

	for ( let i = 0, l = b.length; i < l; i ++ ) {

		if ( a[ offset + i ] !== b[ i ] ) return false;

	}

	return true;

}

let _id$3 = 0;

class NodeUniformsGroup extends UniformsGroup {

	constructor( name, groupNode ) {

		super( name );

		this.id = _id$3 ++;
		this.groupNode = groupNode;

		this.isNodeUniformsGroup = true;

	}

	getNodes() {

		const nodes = [];

		for ( const uniform of this.uniforms ) {

			const node = uniform.nodeUniform.node;

			if ( ! node ) throw new Error( 'NodeUniformsGroup: Uniform has no node.' );

			nodes.push( node );

		}

		return nodes;

	}

}

let _id$2 = 0;

class SampledTexture extends Binding {

	constructor( name, texture ) {

		super( name );

		this.id = _id$2 ++;

		this.texture = texture;
		this.version = texture ? texture.version : 0;
		this.store = false;
		this.generation = null;

		this.isSampledTexture = true;

	}

	needsBindingsUpdate( generation ) {

		const { texture } = this;

		if ( generation !== this.generation ) {

			this.generation = generation;

			return true;

		}

		return texture.isVideoTexture;

	}

	update() {

		const { texture, version } = this;

		if ( version !== texture.version ) {

			this.version = texture.version;

			return true;

		}

		return false;

	}

}

class NodeSampledTexture extends SampledTexture {

	constructor( name, textureNode, groupNode, access = null ) {

		super( name, textureNode ? textureNode.value : null );

		this.textureNode = textureNode;
		this.groupNode = groupNode;

		this.access = access;

	}

	needsBindingsUpdate( generation ) {

		return this.textureNode.value !== this.texture || super.needsBindingsUpdate( generation );

	}

	update() {

		const { textureNode } = this;

		if ( this.texture !== textureNode.value ) {

			this.texture = textureNode.value;

			return true;

		}

		return super.update();

	}

}

class NodeSampledCubeTexture extends NodeSampledTexture {

	constructor( name, textureNode, groupNode, access ) {

		super( name, textureNode, groupNode, access );

		this.isSampledCubeTexture = true;

	}

}

class NodeSampledTexture3D extends NodeSampledTexture {

	constructor( name, textureNode, groupNode, access ) {

		super( name, textureNode, groupNode, access );

		this.isSampledTexture3D = true;

	}

}

const glslMethods = {
	atan2: 'atan',
	textureDimensions: 'textureSize',
	equals: 'equal'
};

const precisionLib = {
	low: 'lowp',
	medium: 'mediump',
	high: 'highp'
};

const supports$1 = {
	swizzleAssign: true,
	storageBuffer: false
};

const defaultPrecisions = `
precision highp float;
precision highp int;
precision highp sampler2D;
precision highp sampler3D;
precision highp samplerCube;
precision highp sampler2DArray;

precision highp usampler2D;
precision highp usampler3D;
precision highp usamplerCube;
precision highp usampler2DArray;

precision highp isampler2D;
precision highp isampler3D;
precision highp isamplerCube;
precision highp isampler2DArray;

precision lowp sampler2DShadow;
`;

class GLSLNodeBuilder extends NodeBuilder {

	constructor( object, renderer ) {

		super( object, renderer, new GLSLNodeParser() );

		this.uniformGroups = {};
		this.transforms = [];
		this.extensions = {};
		this.builtins = { vertex: [], fragment: [], compute: [] };

		this.useComparisonMethod = true;

	}

	needsToWorkingColorSpace( texture ) {

		return texture.isVideoTexture === true && texture.colorSpace !== NoColorSpace;

	}

	getMethod( method ) {

		return glslMethods[ method ] || method;

	}

	getOutputStructName() {

		return '';

	}

	buildFunctionCode( shaderNode ) {

		const layout = shaderNode.layout;
		const flowData = this.flowShaderNode( shaderNode );

		const parameters = [];

		for ( const input of layout.inputs ) {

			parameters.push( this.getType( input.type ) + ' ' + input.name );

		}

		//

		const code = `${ this.getType( layout.type ) } ${ layout.name }( ${ parameters.join( ', ' ) } ) {

	${ flowData.vars }

${ flowData.code }
	return ${ flowData.result };

}`;

		//

		return code;

	}

	setupPBO( storageBufferNode ) {

		const attribute = storageBufferNode.value;

		if ( attribute.pbo === undefined ) {

			const originalArray = attribute.array;
			const numElements = attribute.count * attribute.itemSize;

			const { itemSize } = attribute;

			const isInteger = attribute.array.constructor.name.toLowerCase().includes( 'int' );

			let format = isInteger ? RedIntegerFormat : RedFormat;

			if ( itemSize === 2 ) {

				format = isInteger ? RGIntegerFormat : RGFormat;

			} else if ( itemSize === 3 ) {

				format = isInteger ? RGBIntegerFormat : RGBFormat;

			} else if ( itemSize === 4 ) {

				format = isInteger ? RGBAIntegerFormat : RGBAFormat;

			}

			const typeMap = {
				Float32Array: FloatType,
				Uint8Array: UnsignedByteType,
				Uint16Array: UnsignedShortType,
				Uint32Array: UnsignedIntType,
				Int8Array: ByteType,
				Int16Array: ShortType,
				Int32Array: IntType,
				Uint8ClampedArray: UnsignedByteType,
			};

			const width = Math.pow( 2, Math.ceil( Math.log2( Math.sqrt( numElements / itemSize ) ) ) );
			let height = Math.ceil( ( numElements / itemSize ) / width );
			if ( width * height * itemSize < numElements ) height ++; // Ensure enough space

			const newSize = width * height * itemSize;

			const newArray = new originalArray.constructor( newSize );

			newArray.set( originalArray, 0 );

			attribute.array = newArray;

			const pboTexture = new DataTexture( attribute.array, width, height, format, typeMap[ attribute.array.constructor.name ] || FloatType );
			pboTexture.needsUpdate = true;
			pboTexture.isPBOTexture = true;

			const pbo = new TextureNode( pboTexture, null, null );
			pbo.setPrecision( 'high' );

			attribute.pboNode = pbo;
			attribute.pbo = pbo.value;

			this.getUniformFromNode( attribute.pboNode, 'texture', this.shaderStage, this.context.label );

		}

	}

	getPropertyName( node, shaderStage = this.shaderStage ) {

		if ( node.isNodeUniform && node.node.isTextureNode !== true && node.node.isBufferNode !== true ) {

			return shaderStage.charAt( 0 ) + '_' + node.name;

		}

		return super.getPropertyName( node, shaderStage );

	}

	generatePBO( storageArrayElementNode ) {

		const { node, indexNode } = storageArrayElementNode;
		const attribute = node.value;

		if ( this.renderer.backend.has( attribute ) ) {

			const attributeData = this.renderer.backend.get( attribute );
			attributeData.pbo = attribute.pbo;

		}

		const nodeUniform = this.getUniformFromNode( attribute.pboNode, 'texture', this.shaderStage, this.context.label );
		const textureName = this.getPropertyName( nodeUniform );

		this.increaseUsage( indexNode ); // force cache generate to be used as index in x,y
		const indexSnippet = indexNode.build( this, 'uint' );

		const elementNodeData = this.getDataFromNode( storageArrayElementNode );

		let propertyName = elementNodeData.propertyName;

		if ( propertyName === undefined ) {

			// property element

			const nodeVar = this.getVarFromNode( storageArrayElementNode );

			propertyName = this.getPropertyName( nodeVar );

			// property size

			const bufferNodeData = this.getDataFromNode( node );

			let propertySizeName = bufferNodeData.propertySizeName;

			if ( propertySizeName === undefined ) {

				propertySizeName = propertyName + 'Size';

				this.getVarFromNode( node, propertySizeName, 'uint' );

				this.addLineFlowCode( `${ propertySizeName } = uint( textureSize( ${ textureName }, 0 ).x )`, storageArrayElementNode );

				bufferNodeData.propertySizeName = propertySizeName;

			}

			//

			const { itemSize } = attribute;

			const channel = '.' + vectorComponents.join( '' ).slice( 0, itemSize );
			const uvSnippet = `ivec2(${indexSnippet} % ${ propertySizeName }, ${indexSnippet} / ${ propertySizeName })`;

			const snippet = this.generateTextureLoad( null, textureName, uvSnippet, null, '0' );

			//


			let prefix = 'vec4';

			if ( attribute.pbo.type === UnsignedIntType ) {

				prefix = 'uvec4';

			} else if ( attribute.pbo.type === IntType ) {

				prefix = 'ivec4';

			}

			this.addLineFlowCode( `${ propertyName } = ${prefix}(${ snippet })${channel}`, storageArrayElementNode );

			elementNodeData.propertyName = propertyName;

		}

		return propertyName;

	}

	generateTextureLoad( texture, textureProperty, uvIndexSnippet, depthSnippet, levelSnippet = '0' ) {

		if ( depthSnippet ) {

			return `texelFetch( ${ textureProperty }, ivec3( ${ uvIndexSnippet }, ${ depthSnippet } ), ${ levelSnippet } )`;

		} else {

			return `texelFetch( ${ textureProperty }, ${ uvIndexSnippet }, ${ levelSnippet } )`;

		}

	}

	generateTexture( texture, textureProperty, uvSnippet, depthSnippet ) {

		if ( texture.isDepthTexture ) {

			return `texture( ${ textureProperty }, ${ uvSnippet } ).x`;

		} else {

			if ( depthSnippet ) uvSnippet = `vec3( ${ uvSnippet }, ${ depthSnippet } )`;

			return `texture( ${ textureProperty }, ${ uvSnippet } )`;

		}

	}

	generateTextureLevel( texture, textureProperty, uvSnippet, levelSnippet ) {

		return `textureLod( ${ textureProperty }, ${ uvSnippet }, ${ levelSnippet } )`;

	}

	generateTextureBias( texture, textureProperty, uvSnippet, biasSnippet ) {

		return `texture( ${ textureProperty }, ${ uvSnippet }, ${ biasSnippet } )`;

	}

	generateTextureGrad( texture, textureProperty, uvSnippet, gradSnippet ) {

		return `textureGrad( ${ textureProperty }, ${ uvSnippet }, ${ gradSnippet[ 0 ] }, ${ gradSnippet[ 1 ] } )`;

	}

	generateTextureCompare( texture, textureProperty, uvSnippet, compareSnippet, depthSnippet, shaderStage = this.shaderStage ) {

		if ( shaderStage === 'fragment' ) {

			return `texture( ${ textureProperty }, vec3( ${ uvSnippet }, ${ compareSnippet } ) )`;

		} else {

			console.error( `WebGPURenderer: THREE.DepthTexture.compareFunction() does not support ${ shaderStage } shader.` );

		}

	}

	getVars( shaderStage ) {

		const snippets = [];

		const vars = this.vars[ shaderStage ];

		if ( vars !== undefined ) {

			for ( const variable of vars ) {

				snippets.push( `${ this.getVar( variable.type, variable.name ) };` );

			}

		}

		return snippets.join( '\n\t' );

	}

	getUniforms( shaderStage ) {

		const uniforms = this.uniforms[ shaderStage ];

		const bindingSnippets = [];
		const uniformGroups = {};

		for ( const uniform of uniforms ) {

			let snippet = null;
			let group = false;

			if ( uniform.type === 'texture' ) {

				const texture = uniform.node.value;

				let typePrefix = '';

				if ( texture.isDataTexture === true ) {


					if ( texture.type === UnsignedIntType ) {

						typePrefix = 'u';

					} else if ( texture.type === IntType ) {

						typePrefix = 'i';

					}

				}

				if ( texture.compareFunction ) {

					snippet = `sampler2DShadow ${ uniform.name };`;

				} else if ( texture.isDataArrayTexture === true || texture.isCompressedArrayTexture === true ) {

					snippet = `${typePrefix}sampler2DArray ${ uniform.name };`;

				} else {

					snippet = `${typePrefix}sampler2D ${ uniform.name };`;

				}

			} else if ( uniform.type === 'cubeTexture' ) {

				snippet = `samplerCube ${ uniform.name };`;

			} else if ( uniform.type === 'texture3D' ) {

				snippet = `sampler3D ${ uniform.name };`;

			} else if ( uniform.type === 'buffer' ) {

				const bufferNode = uniform.node;
				const bufferType = this.getType( bufferNode.bufferType );
				const bufferCount = bufferNode.bufferCount;

				const bufferCountSnippet = bufferCount > 0 ? bufferCount : '';
				snippet = `${bufferNode.name} {\n\t${ bufferType } ${ uniform.name }[${ bufferCountSnippet }];\n};\n`;

			} else {

				const vectorType = this.getVectorType( uniform.type );

				snippet = `${ vectorType } ${ this.getPropertyName( uniform, shaderStage ) };`;

				group = true;

			}

			const precision = uniform.node.precision;

			if ( precision !== null ) {

				snippet = precisionLib[ precision ] + ' ' + snippet;

			}

			if ( group ) {

				snippet = '\t' + snippet;

				const groupName = uniform.groupNode.name;
				const groupSnippets = uniformGroups[ groupName ] || ( uniformGroups[ groupName ] = [] );

				groupSnippets.push( snippet );

			} else {

				snippet = 'uniform ' + snippet;

				bindingSnippets.push( snippet );

			}

		}

		let output = '';

		for ( const name in uniformGroups ) {

			const groupSnippets = uniformGroups[ name ];

			output += this._getGLSLUniformStruct( shaderStage + '_' + name, groupSnippets.join( '\n' ) ) + '\n';

		}

		output += bindingSnippets.join( '\n' );

		return output;

	}

	getTypeFromAttribute( attribute ) {

		let nodeType = super.getTypeFromAttribute( attribute );

		if ( /^[iu]/.test( nodeType ) && attribute.gpuType !== IntType ) {

			let dataAttribute = attribute;

			if ( attribute.isInterleavedBufferAttribute ) dataAttribute = attribute.data;

			const array = dataAttribute.array;

			if ( ( array instanceof Uint32Array || array instanceof Int32Array ) === false ) {

				nodeType = nodeType.slice( 1 );

			}

		}

		return nodeType;

	}

	getAttributes( shaderStage ) {

		let snippet = '';

		if ( shaderStage === 'vertex' || shaderStage === 'compute' ) {

			const attributes = this.getAttributesArray();

			let location = 0;

			for ( const attribute of attributes ) {

				snippet += `layout( location = ${ location ++ } ) in ${ attribute.type } ${ attribute.name };\n`;

			}

		}

		return snippet;

	}

	getStructMembers( struct ) {

		const snippets = [];
		const members = struct.getMemberTypes();

		for ( let i = 0; i < members.length; i ++ ) {

			const member = members[ i ];
			snippets.push( `layout( location = ${i} ) out ${ member} m${i};` );

		}

		return snippets.join( '\n' );

	}

	getStructs( shaderStage ) {

		const snippets = [];
		const structs = this.structs[ shaderStage ];

		if ( structs.length === 0 ) {

			return 'layout( location = 0 ) out vec4 fragColor;\n';

		}

		for ( let index = 0, length = structs.length; index < length; index ++ ) {

			const struct = structs[ index ];

			let snippet = '\n';
			snippet += this.getStructMembers( struct );
			snippet += '\n';

			snippets.push( snippet );

		}

		return snippets.join( '\n\n' );

	}

	getVaryings( shaderStage ) {

		let snippet = '';

		const varyings = this.varyings;

		if ( shaderStage === 'vertex' || shaderStage === 'compute' ) {

			for ( const varying of varyings ) {

				if ( shaderStage === 'compute' ) varying.needsInterpolation = true;
				const type = this.getType( varying.type );
				const flat = type.includes( 'int' ) || type.includes( 'uv' ) || type.includes( 'iv' ) ? 'flat ' : '';

				snippet += `${flat}${varying.needsInterpolation ? 'out' : '/*out*/'} ${type} ${varying.name};\n`;

			}

		} else if ( shaderStage === 'fragment' ) {

			for ( const varying of varyings ) {

				if ( varying.needsInterpolation ) {

					const type = this.getType( varying.type );
					const flat = type.includes( 'int' ) || type.includes( 'uv' ) || type.includes( 'iv' ) ? 'flat ' : '';

					snippet += `${flat}in ${type} ${varying.name};\n`;

				}

			}

		}

		for ( const builtin of this.builtins[ shaderStage ] ) {

			snippet += `${builtin};\n`;

		}

		return snippet;

	}

	getVertexIndex() {

		return 'uint( gl_VertexID )';

	}

	getInstanceIndex() {

		return 'uint( gl_InstanceID )';

	}

	getInvocationLocalIndex() {

		const workgroupSize = this.object.workgroupSize;

		const size = workgroupSize.reduce( ( acc, curr ) => acc * curr, 1 );

		return `uint( gl_InstanceID ) % ${size}u`;

	}

	getDrawIndex() {

		const extensions = this.renderer.backend.extensions;

		if ( extensions.has( 'WEBGL_multi_draw' ) ) {

			return 'uint( gl_DrawID )';

		}

		return null;

	}

	getFrontFacing() {

		return 'gl_FrontFacing';

	}

	getFragCoord() {

		return 'gl_FragCoord.xy';

	}

	getFragDepth() {

		return 'gl_FragDepth';

	}

	enableExtension( name, behavior, shaderStage = this.shaderStage ) {

		const map = this.extensions[ shaderStage ] || ( this.extensions[ shaderStage ] = new Map() );

		if ( map.has( name ) === false ) {

			map.set( name, {
				name,
				behavior
			} );

		}

	}

	getExtensions( shaderStage ) {

		const snippets = [];

		if ( shaderStage === 'vertex' ) {

			const ext = this.renderer.backend.extensions;
			const isBatchedMesh = this.object.isBatchedMesh;

			if ( isBatchedMesh && ext.has( 'WEBGL_multi_draw' ) ) {

				this.enableExtension( 'GL_ANGLE_multi_draw', 'require', shaderStage );

			}

		}

		const extensions = this.extensions[ shaderStage ];

		if ( extensions !== undefined ) {

			for ( const { name, behavior } of extensions.values() ) {

				snippets.push( `#extension ${name} : ${behavior}` );

			}

		}

		return snippets.join( '\n' );

	}

	getClipDistance() {

		return 'gl_ClipDistance';

	}

	isAvailable( name ) {

		let result = supports$1[ name ];

		if ( result === undefined ) {

			let extensionName;

			result = false;

			switch ( name ) {

				case 'float32Filterable':
					extensionName = 'OES_texture_float_linear';
					break;

				case 'clipDistance':
					extensionName = 'WEBGL_clip_cull_distance';
					break;

			}

			if ( extensionName !== undefined ) {

				const extensions = this.renderer.backend.extensions;

				if ( extensions.has( extensionName ) ) {

					extensions.get( extensionName );
					result = true;

				}

			}

			supports$1[ name ] = result;

		}

		return result;

	}

	isFlipY() {

		return true;

	}

	enableHardwareClipping( planeCount ) {

		this.enableExtension( 'GL_ANGLE_clip_cull_distance', 'require' );

		this.builtins[ 'vertex' ].push( `out float gl_ClipDistance[ ${ planeCount } ]` );

	}

	registerTransform( varyingName, attributeNode ) {

		this.transforms.push( { varyingName, attributeNode } );

	}

	getTransforms( /* shaderStage  */ ) {

		const transforms = this.transforms;

		let snippet = '';

		for ( let i = 0; i < transforms.length; i ++ ) {

			const transform = transforms[ i ];

			const attributeName = this.getPropertyName( transform.attributeNode );

			snippet += `${ transform.varyingName } = ${ attributeName };\n\t`;

		}

		return snippet;

	}

	_getGLSLUniformStruct( name, vars ) {

		return `
layout( std140 ) uniform ${name} {
${vars}
};`;

	}

	_getGLSLVertexCode( shaderData ) {

		return `#version 300 es

${ this.getSignature() }

// extensions 
${shaderData.extensions}

// precision
${ defaultPrecisions }

// uniforms
${shaderData.uniforms}

// varyings
${shaderData.varyings}

// attributes
${shaderData.attributes}

// codes
${shaderData.codes}

void main() {

	// vars
	${shaderData.vars}

	// transforms
	${shaderData.transforms}

	// flow
	${shaderData.flow}

	gl_PointSize = 1.0;

}
`;

	}

	_getGLSLFragmentCode( shaderData ) {

		return `#version 300 es

${ this.getSignature() }

// precision
${ defaultPrecisions }

// uniforms
${shaderData.uniforms}

// varyings
${shaderData.varyings}

// codes
${shaderData.codes}

${shaderData.structs}

void main() {

	// vars
	${shaderData.vars}

	// flow
	${shaderData.flow}

}
`;

	}

	buildCode() {

		const shadersData = this.material !== null ? { fragment: {}, vertex: {} } : { compute: {} };

		this.sortBindingGroups();

		for ( const shaderStage in shadersData ) {

			let flow = '// code\n\n';
			flow += this.flowCode[ shaderStage ];

			const flowNodes = this.flowNodes[ shaderStage ];
			const mainNode = flowNodes[ flowNodes.length - 1 ];

			for ( const node of flowNodes ) {

				const flowSlotData = this.getFlowData( node/*, shaderStage*/ );
				const slotName = node.name;

				if ( slotName ) {

					if ( flow.length > 0 ) flow += '\n';

					flow += `\t// flow -> ${ slotName }\n\t`;

				}

				flow += `${ flowSlotData.code }\n\t`;

				if ( node === mainNode && shaderStage !== 'compute' ) {

					flow += '// result\n\t';

					if ( shaderStage === 'vertex' ) {

						flow += 'gl_Position = ';
						flow += `${ flowSlotData.result };`;

					} else if ( shaderStage === 'fragment' ) {

						if ( ! node.outputNode.isOutputStructNode ) {

							flow += 'fragColor = ';
							flow += `${ flowSlotData.result };`;

						}

					}

				}

			}

			const stageData = shadersData[ shaderStage ];

			stageData.extensions = this.getExtensions( shaderStage );
			stageData.uniforms = this.getUniforms( shaderStage );
			stageData.attributes = this.getAttributes( shaderStage );
			stageData.varyings = this.getVaryings( shaderStage );
			stageData.vars = this.getVars( shaderStage );
			stageData.structs = this.getStructs( shaderStage );
			stageData.codes = this.getCodes( shaderStage );
			stageData.transforms = this.getTransforms( shaderStage );
			stageData.flow = flow;

		}

		if ( this.material !== null ) {

			this.vertexShader = this._getGLSLVertexCode( shadersData.vertex );
			this.fragmentShader = this._getGLSLFragmentCode( shadersData.fragment );

		} else {

			this.computeShader = this._getGLSLVertexCode( shadersData.compute );

		}

	}

	getUniformFromNode( node, type, shaderStage, name = null ) {

		const uniformNode = super.getUniformFromNode( node, type, shaderStage, name );
		const nodeData = this.getDataFromNode( node, shaderStage, this.globalCache );

		let uniformGPU = nodeData.uniformGPU;

		if ( uniformGPU === undefined ) {

			const group = node.groupNode;
			const groupName = group.name;

			const bindings = this.getBindGroupArray( groupName, shaderStage );

			if ( type === 'texture' ) {

				uniformGPU = new NodeSampledTexture( uniformNode.name, uniformNode.node, group );
				bindings.push( uniformGPU );

			} else if ( type === 'cubeTexture' ) {

				uniformGPU = new NodeSampledCubeTexture( uniformNode.name, uniformNode.node, group );
				bindings.push( uniformGPU );

			} else if ( type === 'texture3D' ) {

				uniformGPU = new NodeSampledTexture3D( uniformNode.name, uniformNode.node, group );
				bindings.push( uniformGPU );

			} else if ( type === 'buffer' ) {

				node.name = `NodeBuffer_${ node.id }`;
				uniformNode.name = `buffer${ node.id }`;

				const buffer = new NodeUniformBuffer( node, group );
				buffer.name = node.name;

				bindings.push( buffer );

				uniformGPU = buffer;

			} else {

				const uniformsStage = this.uniformGroups[ shaderStage ] || ( this.uniformGroups[ shaderStage ] = {} );

				let uniformsGroup = uniformsStage[ groupName ];

				if ( uniformsGroup === undefined ) {

					uniformsGroup = new NodeUniformsGroup( shaderStage + '_' + groupName, group );
					//uniformsGroup.setVisibility( gpuShaderStageLib[ shaderStage ] );

					uniformsStage[ groupName ] = uniformsGroup;

					bindings.push( uniformsGroup );

				}

				uniformGPU = this.getNodeUniform( uniformNode, type );

				uniformsGroup.addUniform( uniformGPU );

			}

			nodeData.uniformGPU = uniformGPU;

		}

		return uniformNode;

	}

}

let vector2 = null;
let vector4 = null;
let color4 = null;

class Backend {

	constructor( parameters = {} ) {

		this.parameters = Object.assign( {}, parameters );
		this.data = new WeakMap();
		this.renderer = null;
		this.domElement = null;

	}

	async init( renderer ) {

		this.renderer = renderer;

	}

	// render context

	begin( /*renderContext*/ ) { }

	finish( /*renderContext*/ ) { }

	// render object

	draw( /*renderObject, info*/ ) { }

	// program

	createProgram( /*program*/ ) { }

	destroyProgram( /*program*/ ) { }

	// bindings

	createBindings( /*bingGroup, bindings*/ ) { }

	updateBindings( /*bingGroup, bindings*/ ) { }

	// pipeline

	createRenderPipeline( /*renderObject*/ ) { }

	createComputePipeline( /*computeNode, pipeline*/ ) { }

	destroyPipeline( /*pipeline*/ ) { }

	// cache key

	needsRenderUpdate( /*renderObject*/ ) { } // return Boolean ( fast test )

	getRenderCacheKey( /*renderObject*/ ) { } // return String

	// node builder

	createNodeBuilder( /*renderObject*/ ) { } // return NodeBuilder (ADD IT)

	// textures

	createSampler( /*texture*/ ) { }

	createDefaultTexture( /*texture*/ ) { }

	createTexture( /*texture*/ ) { }

	copyTextureToBuffer( /*texture, x, y, width, height*/ ) {}

	// attributes

	createAttribute( /*attribute*/ ) { }

	createIndexAttribute( /*attribute*/ ) { }

	updateAttribute( /*attribute*/ ) { }

	destroyAttribute( /*attribute*/ ) { }

	// canvas

	getContext() { }

	updateSize() { }

	// utils

	resolveTimestampAsync( /*renderContext, type*/ ) { }

	hasFeatureAsync( /*name*/ ) { } // return Boolean

	hasFeature( /*name*/ ) { } // return Boolean

	getInstanceCount( renderObject ) {

		const { object, geometry } = renderObject;

		return geometry.isInstancedBufferGeometry ? geometry.instanceCount : ( object.count > 1 ? object.count : 1 );

	}

	getDrawingBufferSize() {

		vector2 = vector2 || new Vector2();

		return this.renderer.getDrawingBufferSize( vector2 );

	}

	getScissor() {

		vector4 = vector4 || new Vector4();

		return this.renderer.getScissor( vector4 );

	}

	setScissorTest( /*boolean*/ ) { }

	getClearColor() {

		const renderer = this.renderer;

		color4 = color4 || new Color4();

		renderer.getClearColor( color4 );

		color4.getRGB( color4, this.renderer.currentColorSpace );

		return color4;

	}

	getDomElement() {

		let domElement = this.domElement;

		if ( domElement === null ) {

			domElement = ( this.parameters.canvas !== undefined ) ? this.parameters.canvas : createCanvasElement();

			// OffscreenCanvas does not have setAttribute, see #22811
			if ( 'setAttribute' in domElement ) domElement.setAttribute( 'data-engine', `three.js r${REVISION} webgpu` );

			this.domElement = domElement;

		}

		return domElement;

	}

	// resource properties

	set( object, value ) {

		this.data.set( object, value );

	}

	get( object ) {

		let map = this.data.get( object );

		if ( map === undefined ) {

			map = {};
			this.data.set( object, map );

		}

		return map;

	}

	has( object ) {

		return this.data.has( object );

	}

	delete( object ) {

		this.data.delete( object );

	}

	dispose() { }

}

let _id$1 = 0;

class DualAttributeData {

	constructor( attributeData, dualBuffer ) {

		this.buffers = [ attributeData.bufferGPU, dualBuffer ];
		this.type = attributeData.type;
		this.bufferType = attributeData.bufferType;
		this.pbo = attributeData.pbo;
		this.byteLength = attributeData.byteLength;
		this.bytesPerElement = attributeData.BYTES_PER_ELEMENT;
		this.version = attributeData.version;
		this.isInteger = attributeData.isInteger;
		this.activeBufferIndex = 0;
		this.baseId = attributeData.id;

	}


	get id() {

		return `${ this.baseId }|${ this.activeBufferIndex }`;

	}

	get bufferGPU() {

		return this.buffers[ this.activeBufferIndex ];

	}

	get transformBuffer() {

		return this.buffers[ this.activeBufferIndex ^ 1 ];

	}

	switchBuffers() {

		this.activeBufferIndex ^= 1;

	}

}

class WebGLAttributeUtils {

	constructor( backend ) {

		this.backend = backend;

	}

	createAttribute( attribute, bufferType ) {

		const backend = this.backend;
		const { gl } = backend;

		const array = attribute.array;
		const usage = attribute.usage || gl.STATIC_DRAW;

		const bufferAttribute = attribute.isInterleavedBufferAttribute ? attribute.data : attribute;
		const bufferData = backend.get( bufferAttribute );

		let bufferGPU = bufferData.bufferGPU;

		if ( bufferGPU === undefined ) {

			bufferGPU = this._createBuffer( gl, bufferType, array, usage );

			bufferData.bufferGPU = bufferGPU;
			bufferData.bufferType = bufferType;
			bufferData.version = bufferAttribute.version;

		}

		//attribute.onUploadCallback();

		let type;

		if ( array instanceof Float32Array ) {

			type = gl.FLOAT;

		} else if ( array instanceof Uint16Array ) {

			if ( attribute.isFloat16BufferAttribute ) {

				type = gl.HALF_FLOAT;

			} else {

				type = gl.UNSIGNED_SHORT;

			}

		} else if ( array instanceof Int16Array ) {

			type = gl.SHORT;

		} else if ( array instanceof Uint32Array ) {

			type = gl.UNSIGNED_INT;

		} else if ( array instanceof Int32Array ) {

			type = gl.INT;

		} else if ( array instanceof Int8Array ) {

			type = gl.BYTE;

		} else if ( array instanceof Uint8Array ) {

			type = gl.UNSIGNED_BYTE;

		} else if ( array instanceof Uint8ClampedArray ) {

			type = gl.UNSIGNED_BYTE;

		} else {

			throw new Error( 'THREE.WebGLBackend: Unsupported buffer data format: ' + array );

		}

		let attributeData = {
			bufferGPU,
			bufferType,
			type,
			byteLength: array.byteLength,
			bytesPerElement: array.BYTES_PER_ELEMENT,
			version: attribute.version,
			pbo: attribute.pbo,
			isInteger: type === gl.INT || type === gl.UNSIGNED_INT || attribute.gpuType === IntType,
			id: _id$1 ++
		};

		if ( attribute.isStorageBufferAttribute || attribute.isStorageInstancedBufferAttribute ) {

			// create buffer for tranform feedback use
			const bufferGPUDual = this._createBuffer( gl, bufferType, array, usage );
			attributeData = new DualAttributeData( attributeData, bufferGPUDual );

		}

		backend.set( attribute, attributeData );

	}

	updateAttribute( attribute ) {

		const backend = this.backend;
		const { gl } = backend;

		const array = attribute.array;
		const bufferAttribute = attribute.isInterleavedBufferAttribute ? attribute.data : attribute;
		const bufferData = backend.get( bufferAttribute );
		const bufferType = bufferData.bufferType;
		const updateRanges = attribute.isInterleavedBufferAttribute ? attribute.data.updateRanges : attribute.updateRanges;

		gl.bindBuffer( bufferType, bufferData.bufferGPU );

		if ( updateRanges.length === 0 ) {

			// Not using update ranges

			gl.bufferSubData( bufferType, 0, array );

		} else {

			for ( let i = 0, l = updateRanges.length; i < l; i ++ ) {

				const range = updateRanges[ i ];
				gl.bufferSubData( bufferType, range.start * array.BYTES_PER_ELEMENT,
					array, range.start, range.count );

			}

			bufferAttribute.clearUpdateRanges();

		}

		gl.bindBuffer( bufferType, null );

		bufferData.version = bufferAttribute.version;

	}

	destroyAttribute( attribute ) {

		const backend = this.backend;
		const { gl } = backend;

		if ( attribute.isInterleavedBufferAttribute ) {

			backend.delete( attribute.data );

		}

		const attributeData = backend.get( attribute );

		gl.deleteBuffer( attributeData.bufferGPU );

		backend.delete( attribute );

	}

	async getArrayBufferAsync( attribute ) {

		const backend = this.backend;
		const { gl } = backend;

		const bufferAttribute = attribute.isInterleavedBufferAttribute ? attribute.data : attribute;
		const { bufferGPU } = backend.get( bufferAttribute );

		const array = attribute.array;
		const byteLength = array.byteLength;

		gl.bindBuffer( gl.COPY_READ_BUFFER, bufferGPU );

		const writeBuffer = gl.createBuffer();

		gl.bindBuffer( gl.COPY_WRITE_BUFFER, writeBuffer );
		gl.bufferData( gl.COPY_WRITE_BUFFER, byteLength, gl.STREAM_READ );

		gl.copyBufferSubData( gl.COPY_READ_BUFFER, gl.COPY_WRITE_BUFFER, 0, 0, byteLength );

		await backend.utils._clientWaitAsync();

		const dstBuffer = new attribute.array.constructor( array.length );

		// Ensure the buffer is bound before reading
		gl.bindBuffer( gl.COPY_WRITE_BUFFER, writeBuffer );

		gl.getBufferSubData( gl.COPY_WRITE_BUFFER, 0, dstBuffer );

		gl.deleteBuffer( writeBuffer );

		gl.bindBuffer( gl.COPY_READ_BUFFER, null );
		gl.bindBuffer( gl.COPY_WRITE_BUFFER, null );

		return dstBuffer.buffer;

	}

	_createBuffer( gl, bufferType, array, usage ) {

		const bufferGPU = gl.createBuffer();

		gl.bindBuffer( bufferType, bufferGPU );
		gl.bufferData( bufferType, array, usage );
		gl.bindBuffer( bufferType, null );

		return bufferGPU;

	}

}

let initialized$1 = false, equationToGL, factorToGL;

class WebGLState {

	constructor( backend ) {

		this.backend = backend;

		this.gl = this.backend.gl;

		this.enabled = {};
		this.currentFlipSided = null;
		this.currentCullFace = null;
		this.currentProgram = null;
		this.currentBlendingEnabled = false;
		this.currentBlending = null;
		this.currentBlendSrc = null;
		this.currentBlendDst = null;
		this.currentBlendSrcAlpha = null;
		this.currentBlendDstAlpha = null;
		this.currentPremultipledAlpha = null;
		this.currentPolygonOffsetFactor = null;
		this.currentPolygonOffsetUnits = null;
		this.currentColorMask = null;
		this.currentDepthFunc = null;
		this.currentDepthMask = null;
		this.currentStencilFunc = null;
		this.currentStencilRef = null;
		this.currentStencilFuncMask = null;
		this.currentStencilFail = null;
		this.currentStencilZFail = null;
		this.currentStencilZPass = null;
		this.currentStencilMask = null;
		this.currentLineWidth = null;
		this.currentClippingPlanes = 0;

		this.currentBoundFramebuffers = {};
		this.currentDrawbuffers = new WeakMap();

		this.maxTextures = this.gl.getParameter( this.gl.MAX_TEXTURE_IMAGE_UNITS );
		this.currentTextureSlot = null;
		this.currentBoundTextures = {};
		this.currentBoundBufferBases = {};

		if ( initialized$1 === false ) {

			this._init( this.gl );

			initialized$1 = true;

		}

	}

	_init( gl ) {

		// Store only WebGL constants here.

		equationToGL = {
			[ AddEquation ]: gl.FUNC_ADD,
			[ SubtractEquation ]: gl.FUNC_SUBTRACT,
			[ ReverseSubtractEquation ]: gl.FUNC_REVERSE_SUBTRACT
		};

		factorToGL = {
			[ ZeroFactor ]: gl.ZERO,
			[ OneFactor ]: gl.ONE,
			[ SrcColorFactor ]: gl.SRC_COLOR,
			[ SrcAlphaFactor ]: gl.SRC_ALPHA,
			[ SrcAlphaSaturateFactor ]: gl.SRC_ALPHA_SATURATE,
			[ DstColorFactor ]: gl.DST_COLOR,
			[ DstAlphaFactor ]: gl.DST_ALPHA,
			[ OneMinusSrcColorFactor ]: gl.ONE_MINUS_SRC_COLOR,
			[ OneMinusSrcAlphaFactor ]: gl.ONE_MINUS_SRC_ALPHA,
			[ OneMinusDstColorFactor ]: gl.ONE_MINUS_DST_COLOR,
			[ OneMinusDstAlphaFactor ]: gl.ONE_MINUS_DST_ALPHA
		};

	}

	enable( id ) {

		const { enabled } = this;

		if ( enabled[ id ] !== true ) {

			this.gl.enable( id );
			enabled[ id ] = true;

		}

	}

	disable( id ) {

		const { enabled } = this;

		if ( enabled[ id ] !== false ) {

			this.gl.disable( id );
			enabled[ id ] = false;

		}

	}

	setFlipSided( flipSided ) {

		if ( this.currentFlipSided !== flipSided ) {

			const { gl } = this;

			if ( flipSided ) {

				gl.frontFace( gl.CW );

			} else {

				gl.frontFace( gl.CCW );

			}

			this.currentFlipSided = flipSided;

		}

	}

	setCullFace( cullFace ) {

		const { gl } = this;

		if ( cullFace !== CullFaceNone ) {

			this.enable( gl.CULL_FACE );

			if ( cullFace !== this.currentCullFace ) {

				if ( cullFace === CullFaceBack ) {

					gl.cullFace( gl.BACK );

				} else if ( cullFace === CullFaceFront ) {

					gl.cullFace( gl.FRONT );

				} else {

					gl.cullFace( gl.FRONT_AND_BACK );

				}

			}

		} else {

			this.disable( gl.CULL_FACE );

		}

		this.currentCullFace = cullFace;

	}

	setLineWidth( width ) {

		const { currentLineWidth, gl } = this;

		if ( width !== currentLineWidth ) {

			gl.lineWidth( width );

			this.currentLineWidth = width;

		}

	}


	setBlending( blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, premultipliedAlpha ) {

		const { gl } = this;

		if ( blending === NoBlending ) {

			if ( this.currentBlendingEnabled === true ) {

				this.disable( gl.BLEND );
				this.currentBlendingEnabled = false;

			}

			return;

		}

		if ( this.currentBlendingEnabled === false ) {

			this.enable( gl.BLEND );
			this.currentBlendingEnabled = true;

		}

		if ( blending !== CustomBlending ) {

			if ( blending !== this.currentBlending || premultipliedAlpha !== this.currentPremultipledAlpha ) {

				if ( this.currentBlendEquation !== AddEquation || this.currentBlendEquationAlpha !== AddEquation ) {

					gl.blendEquation( gl.FUNC_ADD );

					this.currentBlendEquation = AddEquation;
					this.currentBlendEquationAlpha = AddEquation;

				}

				if ( premultipliedAlpha ) {

					switch ( blending ) {

						case NormalBlending:
							gl.blendFuncSeparate( gl.ONE, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA );
							break;

						case AdditiveBlending:
							gl.blendFunc( gl.ONE, gl.ONE );
							break;

						case SubtractiveBlending:
							gl.blendFuncSeparate( gl.ZERO, gl.ONE_MINUS_SRC_COLOR, gl.ZERO, gl.ONE );
							break;

						case MultiplyBlending:
							gl.blendFuncSeparate( gl.ZERO, gl.SRC_COLOR, gl.ZERO, gl.SRC_ALPHA );
							break;

						default:
							console.error( 'THREE.WebGLState: Invalid blending: ', blending );
							break;

					}

				} else {

					switch ( blending ) {

						case NormalBlending:
							gl.blendFuncSeparate( gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA );
							break;

						case AdditiveBlending:
							gl.blendFunc( gl.SRC_ALPHA, gl.ONE );
							break;

						case SubtractiveBlending:
							gl.blendFuncSeparate( gl.ZERO, gl.ONE_MINUS_SRC_COLOR, gl.ZERO, gl.ONE );
							break;

						case MultiplyBlending:
							gl.blendFunc( gl.ZERO, gl.SRC_COLOR );
							break;

						default:
							console.error( 'THREE.WebGLState: Invalid blending: ', blending );
							break;

					}

				}

				this.currentBlendSrc = null;
				this.currentBlendDst = null;
				this.currentBlendSrcAlpha = null;
				this.currentBlendDstAlpha = null;

				this.currentBlending = blending;
				this.currentPremultipledAlpha = premultipliedAlpha;

			}

			return;

		}

		// custom blending

		blendEquationAlpha = blendEquationAlpha || blendEquation;
		blendSrcAlpha = blendSrcAlpha || blendSrc;
		blendDstAlpha = blendDstAlpha || blendDst;

		if ( blendEquation !== this.currentBlendEquation || blendEquationAlpha !== this.currentBlendEquationAlpha ) {

			gl.blendEquationSeparate( equationToGL[ blendEquation ], equationToGL[ blendEquationAlpha ] );

			this.currentBlendEquation = blendEquation;
			this.currentBlendEquationAlpha = blendEquationAlpha;

		}

		if ( blendSrc !== this.currentBlendSrc || blendDst !== this.currentBlendDst || blendSrcAlpha !== this.currentBlendSrcAlpha || blendDstAlpha !== this.currentBlendDstAlpha ) {

			gl.blendFuncSeparate( factorToGL[ blendSrc ], factorToGL[ blendDst ], factorToGL[ blendSrcAlpha ], factorToGL[ blendDstAlpha ] );

			this.currentBlendSrc = blendSrc;
			this.currentBlendDst = blendDst;
			this.currentBlendSrcAlpha = blendSrcAlpha;
			this.currentBlendDstAlpha = blendDstAlpha;

		}

		this.currentBlending = blending;
		this.currentPremultipledAlpha = false;

	}

	setColorMask( colorMask ) {

		if ( this.currentColorMask !== colorMask ) {

			this.gl.colorMask( colorMask, colorMask, colorMask, colorMask );
			this.currentColorMask = colorMask;

		}

	}

	setDepthTest( depthTest ) {

		const { gl } = this;

		if ( depthTest ) {

			this.enable( gl.DEPTH_TEST );

		} else {

			this.disable( gl.DEPTH_TEST );

		}

	}

	setDepthMask( depthMask ) {

		if ( this.currentDepthMask !== depthMask ) {

			this.gl.depthMask( depthMask );
			this.currentDepthMask = depthMask;

		}

	}

	setDepthFunc( depthFunc ) {

		if ( this.currentDepthFunc !== depthFunc ) {

			const { gl } = this;

			switch ( depthFunc ) {

				case NeverDepth:

					gl.depthFunc( gl.NEVER );
					break;

				case AlwaysDepth:

					gl.depthFunc( gl.ALWAYS );
					break;

				case LessDepth:

					gl.depthFunc( gl.LESS );
					break;

				case LessEqualDepth:

					gl.depthFunc( gl.LEQUAL );
					break;

				case EqualDepth:

					gl.depthFunc( gl.EQUAL );
					break;

				case GreaterEqualDepth:

					gl.depthFunc( gl.GEQUAL );
					break;

				case GreaterDepth:

					gl.depthFunc( gl.GREATER );
					break;

				case NotEqualDepth:

					gl.depthFunc( gl.NOTEQUAL );
					break;

				default:

					gl.depthFunc( gl.LEQUAL );

			}

			this.currentDepthFunc = depthFunc;

		}

	}

	setStencilTest( stencilTest ) {

		const { gl } = this;

		if ( stencilTest ) {

			this.enable( gl.STENCIL_TEST );

		} else {

			this.disable( gl.STENCIL_TEST );

		}

	}

	setStencilMask( stencilMask ) {

		if ( this.currentStencilMask !== stencilMask ) {

			this.gl.stencilMask( stencilMask );
			this.currentStencilMask = stencilMask;

		}

	}

	setStencilFunc( stencilFunc, stencilRef, stencilMask ) {

		if ( this.currentStencilFunc !== stencilFunc ||
			 this.currentStencilRef !== stencilRef ||
			 this.currentStencilFuncMask !== stencilMask ) {

			this.gl.stencilFunc( stencilFunc, stencilRef, stencilMask );

			this.currentStencilFunc = stencilFunc;
			this.currentStencilRef = stencilRef;
			this.currentStencilFuncMask = stencilMask;

		}

	}

	setStencilOp( stencilFail, stencilZFail, stencilZPass ) {

		if ( this.currentStencilFail !== stencilFail ||
			 this.currentStencilZFail !== stencilZFail ||
			 this.currentStencilZPass !== stencilZPass ) {

			this.gl.stencilOp( stencilFail, stencilZFail, stencilZPass );

			this.currentStencilFail = stencilFail;
			this.currentStencilZFail = stencilZFail;
			this.currentStencilZPass = stencilZPass;

		}

	}

	setMaterial( material, frontFaceCW, hardwareClippingPlanes ) {

		const { gl } = this;

		material.side === DoubleSide
			? this.disable( gl.CULL_FACE )
			: this.enable( gl.CULL_FACE );

		let flipSided = ( material.side === BackSide );
		if ( frontFaceCW ) flipSided = ! flipSided;

		this.setFlipSided( flipSided );

		( material.blending === NormalBlending && material.transparent === false )
			? this.setBlending( NoBlending )
			: this.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha );

		this.setDepthFunc( material.depthFunc );
		this.setDepthTest( material.depthTest );
		this.setDepthMask( material.depthWrite );
		this.setColorMask( material.colorWrite );

		const stencilWrite = material.stencilWrite;
		this.setStencilTest( stencilWrite );
		if ( stencilWrite ) {

			this.setStencilMask( material.stencilWriteMask );
			this.setStencilFunc( material.stencilFunc, material.stencilRef, material.stencilFuncMask );
			this.setStencilOp( material.stencilFail, material.stencilZFail, material.stencilZPass );

		}

		this.setPolygonOffset( material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits );

		material.alphaToCoverage === true && this.backend.renderer.samples > 1
			? this.enable( gl.SAMPLE_ALPHA_TO_COVERAGE )
			: this.disable( gl.SAMPLE_ALPHA_TO_COVERAGE );

		if ( hardwareClippingPlanes > 0 ) {

			if ( this.currentClippingPlanes !== hardwareClippingPlanes ) {

				const CLIP_DISTANCE0_WEBGL = 0x3000;

				for ( let i = 0; i < 8; i ++ ) {

					if ( i < hardwareClippingPlanes ) {

						this.enable( CLIP_DISTANCE0_WEBGL + i );

					} else {

						this.disable( CLIP_DISTANCE0_WEBGL + i );

					}

				}

			}

		}

	}

	setPolygonOffset( polygonOffset, factor, units ) {

		const { gl } = this;

		if ( polygonOffset ) {

			this.enable( gl.POLYGON_OFFSET_FILL );

			if ( this.currentPolygonOffsetFactor !== factor || this.currentPolygonOffsetUnits !== units ) {

				gl.polygonOffset( factor, units );

				this.currentPolygonOffsetFactor = factor;
				this.currentPolygonOffsetUnits = units;

			}

		} else {

			this.disable( gl.POLYGON_OFFSET_FILL );

		}

	}

	useProgram( program ) {

		if ( this.currentProgram !== program ) {

			this.gl.useProgram( program );

			this.currentProgram = program;

			return true;

		}

		return false;

	}

	// framebuffer


	bindFramebuffer( target, framebuffer ) {

		const { gl, currentBoundFramebuffers } = this;

		if ( currentBoundFramebuffers[ target ] !== framebuffer ) {

			gl.bindFramebuffer( target, framebuffer );

			currentBoundFramebuffers[ target ] = framebuffer;

			// gl.DRAW_FRAMEBUFFER is equivalent to gl.FRAMEBUFFER

			if ( target === gl.DRAW_FRAMEBUFFER ) {

				currentBoundFramebuffers[ gl.FRAMEBUFFER ] = framebuffer;

			}

			if ( target === gl.FRAMEBUFFER ) {

				currentBoundFramebuffers[ gl.DRAW_FRAMEBUFFER ] = framebuffer;

			}

			return true;

		}

		return false;

	}

	drawBuffers( renderContext, framebuffer ) {

		const { gl } = this;

		let drawBuffers = [];

		let needsUpdate = false;

		if ( renderContext.textures !== null ) {

			drawBuffers = this.currentDrawbuffers.get( framebuffer );

			if ( drawBuffers === undefined ) {

				drawBuffers = [];
				this.currentDrawbuffers.set( framebuffer, drawBuffers );

			}


			const textures = renderContext.textures;

			if ( drawBuffers.length !== textures.length || drawBuffers[ 0 ] !== gl.COLOR_ATTACHMENT0 ) {

				for ( let i = 0, il = textures.length; i < il; i ++ ) {

					drawBuffers[ i ] = gl.COLOR_ATTACHMENT0 + i;

				}

				drawBuffers.length = textures.length;

				needsUpdate = true;

			}


		} else {

			if ( drawBuffers[ 0 ] !== gl.BACK ) {

				drawBuffers[ 0 ] = gl.BACK;

				needsUpdate = true;

			}

		}

		if ( needsUpdate ) {

			gl.drawBuffers( drawBuffers );

		}

	}


	// texture

	activeTexture( webglSlot ) {

		const { gl, currentTextureSlot, maxTextures } = this;

		if ( webglSlot === undefined ) webglSlot = gl.TEXTURE0 + maxTextures - 1;

		if ( currentTextureSlot !== webglSlot ) {

			gl.activeTexture( webglSlot );
			this.currentTextureSlot = webglSlot;

		}

	}

	bindTexture( webglType, webglTexture, webglSlot ) {

		const { gl, currentTextureSlot, currentBoundTextures, maxTextures } = this;

		if ( webglSlot === undefined ) {

			if ( currentTextureSlot === null ) {

				webglSlot = gl.TEXTURE0 + maxTextures - 1;

			} else {

				webglSlot = currentTextureSlot;

			}

		}

		let boundTexture = currentBoundTextures[ webglSlot ];

		if ( boundTexture === undefined ) {

			boundTexture = { type: undefined, texture: undefined };
			currentBoundTextures[ webglSlot ] = boundTexture;

		}

		if ( boundTexture.type !== webglType || boundTexture.texture !== webglTexture ) {

			if ( currentTextureSlot !== webglSlot ) {

				gl.activeTexture( webglSlot );
				this.currentTextureSlot = webglSlot;

			}

			gl.bindTexture( webglType, webglTexture );

			boundTexture.type = webglType;
			boundTexture.texture = webglTexture;

		}

	}

	bindBufferBase( target, index, buffer ) {

		const { gl } = this;

		const key = `${target}-${index}`;

		if ( this.currentBoundBufferBases[ key ] !== buffer ) {

			gl.bindBufferBase( target, index, buffer );
			this.currentBoundBufferBases[ key ] = buffer;

			return true;

		}

		return false;

	}


	unbindTexture() {

		const { gl, currentTextureSlot, currentBoundTextures } = this;

		const boundTexture = currentBoundTextures[ currentTextureSlot ];

		if ( boundTexture !== undefined && boundTexture.type !== undefined ) {

			gl.bindTexture( boundTexture.type, null );

			boundTexture.type = undefined;
			boundTexture.texture = undefined;

		}

	}

}

class WebGLUtils {

	constructor( backend ) {

		this.backend = backend;

		this.gl = this.backend.gl;
		this.extensions = backend.extensions;

	}

	convert( p, colorSpace = NoColorSpace ) {

		const { gl, extensions } = this;

		let extension;

		if ( p === UnsignedByteType ) return gl.UNSIGNED_BYTE;
		if ( p === UnsignedShort4444Type ) return gl.UNSIGNED_SHORT_4_4_4_4;
		if ( p === UnsignedShort5551Type ) return gl.UNSIGNED_SHORT_5_5_5_1;
		if ( p === UnsignedInt5999Type ) return gl.UNSIGNED_INT_5_9_9_9_REV;

		if ( p === ByteType ) return gl.BYTE;
		if ( p === ShortType ) return gl.SHORT;
		if ( p === UnsignedShortType ) return gl.UNSIGNED_SHORT;
		if ( p === IntType ) return gl.INT;
		if ( p === UnsignedIntType ) return gl.UNSIGNED_INT;
		if ( p === FloatType ) return gl.FLOAT;

		if ( p === HalfFloatType ) {

			return gl.HALF_FLOAT;

		}

		if ( p === AlphaFormat ) return gl.ALPHA;
		if ( p === RGBFormat ) return gl.RGB;
		if ( p === RGBAFormat ) return gl.RGBA;
		if ( p === LuminanceFormat ) return gl.LUMINANCE;
		if ( p === LuminanceAlphaFormat ) return gl.LUMINANCE_ALPHA;
		if ( p === DepthFormat ) return gl.DEPTH_COMPONENT;
		if ( p === DepthStencilFormat ) return gl.DEPTH_STENCIL;

		// WebGL2 formats.

		if ( p === RedFormat ) return gl.RED;
		if ( p === RedIntegerFormat ) return gl.RED_INTEGER;
		if ( p === RGFormat ) return gl.RG;
		if ( p === RGIntegerFormat ) return gl.RG_INTEGER;
		if ( p === RGBAIntegerFormat ) return gl.RGBA_INTEGER;

		// S3TC

		if ( p === RGB_S3TC_DXT1_Format || p === RGBA_S3TC_DXT1_Format || p === RGBA_S3TC_DXT3_Format || p === RGBA_S3TC_DXT5_Format ) {

			if ( colorSpace === SRGBColorSpace ) {

				extension = extensions.get( 'WEBGL_compressed_texture_s3tc_srgb' );

				if ( extension !== null ) {

					if ( p === RGB_S3TC_DXT1_Format ) return extension.COMPRESSED_SRGB_S3TC_DXT1_EXT;
					if ( p === RGBA_S3TC_DXT1_Format ) return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
					if ( p === RGBA_S3TC_DXT3_Format ) return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
					if ( p === RGBA_S3TC_DXT5_Format ) return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;

				} else {

					return null;

				}

			} else {

				extension = extensions.get( 'WEBGL_compressed_texture_s3tc' );

				if ( extension !== null ) {

					if ( p === RGB_S3TC_DXT1_Format ) return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;
					if ( p === RGBA_S3TC_DXT1_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;
					if ( p === RGBA_S3TC_DXT3_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;
					if ( p === RGBA_S3TC_DXT5_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;

				} else {

					return null;

				}

			}

		}

		// PVRTC

		if ( p === RGB_PVRTC_4BPPV1_Format || p === RGB_PVRTC_2BPPV1_Format || p === RGBA_PVRTC_4BPPV1_Format || p === RGBA_PVRTC_2BPPV1_Format ) {

			extension = extensions.get( 'WEBGL_compressed_texture_pvrtc' );

			if ( extension !== null ) {

				if ( p === RGB_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
				if ( p === RGB_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
				if ( p === RGBA_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
				if ( p === RGBA_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;

			} else {

				return null;

			}

		}

		// ETC

		if ( p === RGB_ETC1_Format || p === RGB_ETC2_Format || p === RGBA_ETC2_EAC_Format ) {

			extension = extensions.get( 'WEBGL_compressed_texture_etc' );

			if ( extension !== null ) {

				if ( p === RGB_ETC1_Format || p === RGB_ETC2_Format ) return ( colorSpace === SRGBColorSpace ) ? extension.COMPRESSED_SRGB8_ETC2 : extension.COMPRESSED_RGB8_ETC2;
				if ( p === RGBA_ETC2_EAC_Format ) return ( colorSpace === SRGBColorSpace ) ? extension.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : extension.COMPRESSED_RGBA8_ETC2_EAC;

			} else {

				return null;

			}

		}

		// ASTC

		if ( p === RGBA_ASTC_4x4_Format || p === RGBA_ASTC_5x4_Format || p === RGBA_ASTC_5x5_Format ||
			p === RGBA_ASTC_6x5_Format || p === RGBA_ASTC_6x6_Format || p === RGBA_ASTC_8x5_Format ||
			p === RGBA_ASTC_8x6_Format || p === RGBA_ASTC_8x8_Format || p === RGBA_ASTC_10x5_Format ||
			p === RGBA_ASTC_10x6_Format || p === RGBA_ASTC_10x8_Format || p === RGBA_ASTC_10x10_Format ||
			p === RGBA_ASTC_12x10_Format || p === RGBA_ASTC_12x12_Format ) {

			extension = extensions.get( 'WEBGL_compressed_texture_astc' );

			if ( extension !== null ) {

				if ( p === RGBA_ASTC_4x4_Format ) return ( colorSpace === SRGBColorSpace ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : extension.COMPRESSED_RGBA_ASTC_4x4_KHR;
				if ( p === RGBA_ASTC_5x4_Format ) return ( colorSpace === SRGBColorSpace ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : extension.COMPRESSED_RGBA_ASTC_5x4_KHR;
				if ( p === RGBA_ASTC_5x5_Format ) return ( colorSpace === SRGBColorSpace ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : extension.COMPRESSED_RGBA_ASTC_5x5_KHR;
				if ( p === RGBA_ASTC_6x5_Format ) return ( colorSpace === SRGBColorSpace ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : extension.COMPRESSED_RGBA_ASTC_6x5_KHR;
				if ( p === RGBA_ASTC_6x6_Format ) return ( colorSpace === SRGBColorSpace ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : extension.COMPRESSED_RGBA_ASTC_6x6_KHR;
				if ( p === RGBA_ASTC_8x5_Format ) return ( colorSpace === SRGBColorSpace ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : extension.COMPRESSED_RGBA_ASTC_8x5_KHR;
				if ( p === RGBA_ASTC_8x6_Format ) return ( colorSpace === SRGBColorSpace ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : extension.COMPRESSED_RGBA_ASTC_8x6_KHR;
				if ( p === RGBA_ASTC_8x8_Format ) return ( colorSpace === SRGBColorSpace ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : extension.COMPRESSED_RGBA_ASTC_8x8_KHR;
				if ( p === RGBA_ASTC_10x5_Format ) return ( colorSpace === SRGBColorSpace ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : extension.COMPRESSED_RGBA_ASTC_10x5_KHR;
				if ( p === RGBA_ASTC_10x6_Format ) return ( colorSpace === SRGBColorSpace ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : extension.COMPRESSED_RGBA_ASTC_10x6_KHR;
				if ( p === RGBA_ASTC_10x8_Format ) return ( colorSpace === SRGBColorSpace ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : extension.COMPRESSED_RGBA_ASTC_10x8_KHR;
				if ( p === RGBA_ASTC_10x10_Format ) return ( colorSpace === SRGBColorSpace ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : extension.COMPRESSED_RGBA_ASTC_10x10_KHR;
				if ( p === RGBA_ASTC_12x10_Format ) return ( colorSpace === SRGBColorSpace ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : extension.COMPRESSED_RGBA_ASTC_12x10_KHR;
				if ( p === RGBA_ASTC_12x12_Format ) return ( colorSpace === SRGBColorSpace ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : extension.COMPRESSED_RGBA_ASTC_12x12_KHR;

			} else {

				return null;

			}

		}

		// BPTC

		if ( p === RGBA_BPTC_Format ) {

			extension = extensions.get( 'EXT_texture_compression_bptc' );

			if ( extension !== null ) {

				if ( p === RGBA_BPTC_Format ) return ( colorSpace === SRGBColorSpace ) ? extension.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : extension.COMPRESSED_RGBA_BPTC_UNORM_EXT;

			} else {

				return null;

			}

		}

		// RGTC

		if ( p === RED_RGTC1_Format || p === SIGNED_RED_RGTC1_Format || p === RED_GREEN_RGTC2_Format || p === SIGNED_RED_GREEN_RGTC2_Format ) {

			extension = extensions.get( 'EXT_texture_compression_rgtc' );

			if ( extension !== null ) {

				if ( p === RGBA_BPTC_Format ) return extension.COMPRESSED_RED_RGTC1_EXT;
				if ( p === SIGNED_RED_RGTC1_Format ) return extension.COMPRESSED_SIGNED_RED_RGTC1_EXT;
				if ( p === RED_GREEN_RGTC2_Format ) return extension.COMPRESSED_RED_GREEN_RGTC2_EXT;
				if ( p === SIGNED_RED_GREEN_RGTC2_Format ) return extension.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT;

			} else {

				return null;

			}

		}

		//

		if ( p === UnsignedInt248Type ) {

			return gl.UNSIGNED_INT_24_8;

		}

		// if "p" can't be resolved, assume the user defines a WebGL constant as a string (fallback/workaround for packed RGB formats)

		return ( gl[ p ] !== undefined ) ? gl[ p ] : null;

	}

	_clientWaitAsync() {

		const { gl } = this;

		const sync = gl.fenceSync( gl.SYNC_GPU_COMMANDS_COMPLETE, 0 );

		gl.flush();

		return new Promise( ( resolve, reject ) => {

			function test() {

				const res = gl.clientWaitSync( sync, gl.SYNC_FLUSH_COMMANDS_BIT, 0 );

				if ( res === gl.WAIT_FAILED ) {

					gl.deleteSync( sync );

					reject();
					return;

				}

				if ( res === gl.TIMEOUT_EXPIRED ) {

					requestAnimationFrame( test );
					return;

				}

				gl.deleteSync( sync );

				resolve();

			}

			test();

		} );

	}

}

let initialized = false, wrappingToGL, filterToGL, compareToGL;

class WebGLTextureUtils {

	constructor( backend ) {

		this.backend = backend;

		this.gl = backend.gl;
		this.extensions = backend.extensions;
		this.defaultTextures = {};

		if ( initialized === false ) {

			this._init( this.gl );

			initialized = true;

		}

	}

	_init( gl ) {

		// Store only WebGL constants here.

		wrappingToGL = {
			[ RepeatWrapping ]: gl.REPEAT,
			[ ClampToEdgeWrapping ]: gl.CLAMP_TO_EDGE,
			[ MirroredRepeatWrapping ]: gl.MIRRORED_REPEAT
		};

		filterToGL = {
			[ NearestFilter ]: gl.NEAREST,
			[ NearestMipmapNearestFilter ]: gl.NEAREST_MIPMAP_NEAREST,
			[ NearestMipmapLinearFilter ]: gl.NEAREST_MIPMAP_LINEAR,

			[ LinearFilter ]: gl.LINEAR,
			[ LinearMipmapNearestFilter ]: gl.LINEAR_MIPMAP_NEAREST,
			[ LinearMipmapLinearFilter ]: gl.LINEAR_MIPMAP_LINEAR
		};

		compareToGL = {
			[ NeverCompare ]: gl.NEVER,
			[ AlwaysCompare ]: gl.ALWAYS,
			[ LessCompare ]: gl.LESS,
			[ LessEqualCompare ]: gl.LEQUAL,
			[ EqualCompare ]: gl.EQUAL,
			[ GreaterEqualCompare ]: gl.GEQUAL,
			[ GreaterCompare ]: gl.GREATER,
			[ NotEqualCompare ]: gl.NOTEQUAL
		};

	}

	filterFallback( f ) {

		const { gl } = this;

		if ( f === NearestFilter || f === NearestMipmapNearestFilter || f === NearestMipmapLinearFilter ) {

			return gl.NEAREST;

		}

		return gl.LINEAR;

	}

	getGLTextureType( texture ) {

		const { gl } = this;

		let glTextureType;

		if ( texture.isCubeTexture === true ) {

			glTextureType = gl.TEXTURE_CUBE_MAP;

		} else if ( texture.isDataArrayTexture === true || texture.isCompressedArrayTexture === true ) {

			glTextureType = gl.TEXTURE_2D_ARRAY;

		} else if ( texture.isData3DTexture === true ) { // TODO: isCompressed3DTexture, wait for #26642

			glTextureType = gl.TEXTURE_3D;

		} else {

			glTextureType = gl.TEXTURE_2D;


		}

		return glTextureType;

	}

	getInternalFormat( internalFormatName, glFormat, glType, colorSpace, forceLinearTransfer = false ) {

		const { gl, extensions } = this;

		if ( internalFormatName !== null ) {

			if ( gl[ internalFormatName ] !== undefined ) return gl[ internalFormatName ];

			console.warn( 'THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format \'' + internalFormatName + '\'' );

		}

		let internalFormat = glFormat;

		if ( glFormat === gl.RED ) {

			if ( glType === gl.FLOAT ) internalFormat = gl.R32F;
			if ( glType === gl.HALF_FLOAT ) internalFormat = gl.R16F;
			if ( glType === gl.UNSIGNED_BYTE ) internalFormat = gl.R8;
			if ( glType === gl.UNSIGNED_SHORT ) internalFormat = gl.R16;
			if ( glType === gl.UNSIGNED_INT ) internalFormat = gl.R32UI;
			if ( glType === gl.BYTE ) internalFormat = gl.R8I;
			if ( glType === gl.SHORT ) internalFormat = gl.R16I;
			if ( glType === gl.INT ) internalFormat = gl.R32I;

		}

		if ( glFormat === gl.RED_INTEGER ) {

			if ( glType === gl.UNSIGNED_BYTE ) internalFormat = gl.R8UI;
			if ( glType === gl.UNSIGNED_SHORT ) internalFormat = gl.R16UI;
			if ( glType === gl.UNSIGNED_INT ) internalFormat = gl.R32UI;
			if ( glType === gl.BYTE ) internalFormat = gl.R8I;
			if ( glType === gl.SHORT ) internalFormat = gl.R16I;
			if ( glType === gl.INT ) internalFormat = gl.R32I;

		}

		if ( glFormat === gl.RG ) {

			if ( glType === gl.FLOAT ) internalFormat = gl.RG32F;
			if ( glType === gl.HALF_FLOAT ) internalFormat = gl.RG16F;
			if ( glType === gl.UNSIGNED_BYTE ) internalFormat = gl.RG8;
			if ( glType === gl.UNSIGNED_SHORT ) internalFormat = gl.RG16;
			if ( glType === gl.UNSIGNED_INT ) internalFormat = gl.RG32UI;
			if ( glType === gl.BYTE ) internalFormat = gl.RG8I;
			if ( glType === gl.SHORT ) internalFormat = gl.RG16I;
			if ( glType === gl.INT ) internalFormat = gl.RG32I;

		}

		if ( glFormat === gl.RG_INTEGER ) {

			if ( glType === gl.UNSIGNED_BYTE ) internalFormat = gl.RG8UI;
			if ( glType === gl.UNSIGNED_SHORT ) internalFormat = gl.RG16UI;
			if ( glType === gl.UNSIGNED_INT ) internalFormat = gl.RG32UI;
			if ( glType === gl.BYTE ) internalFormat = gl.RG8I;
			if ( glType === gl.SHORT ) internalFormat = gl.RG16I;
			if ( glType === gl.INT ) internalFormat = gl.RG32I;

		}

		if ( glFormat === gl.RGB ) {

			if ( glType === gl.FLOAT ) internalFormat = gl.RGB32F;
			if ( glType === gl.HALF_FLOAT ) internalFormat = gl.RGB16F;
			if ( glType === gl.UNSIGNED_BYTE ) internalFormat = gl.RGB8;
			if ( glType === gl.UNSIGNED_SHORT ) internalFormat = gl.RGB16;
			if ( glType === gl.UNSIGNED_INT ) internalFormat = gl.RGB32UI;
			if ( glType === gl.BYTE ) internalFormat = gl.RGB8I;
			if ( glType === gl.SHORT ) internalFormat = gl.RGB16I;
			if ( glType === gl.INT ) internalFormat = gl.RGB32I;
			if ( glType === gl.UNSIGNED_BYTE ) internalFormat = ( colorSpace === SRGBColorSpace && forceLinearTransfer === false ) ? gl.SRGB8 : gl.RGB8;
			if ( glType === gl.UNSIGNED_SHORT_5_6_5 ) internalFormat = gl.RGB565;
			if ( glType === gl.UNSIGNED_SHORT_5_5_5_1 ) internalFormat = gl.RGB5_A1;
			if ( glType === gl.UNSIGNED_SHORT_4_4_4_4 ) internalFormat = gl.RGB4;
			if ( glType === gl.UNSIGNED_INT_5_9_9_9_REV ) internalFormat = gl.RGB9_E5;

		}

		if ( glFormat === gl.RGB_INTEGER ) {

			if ( glType === gl.UNSIGNED_BYTE ) internalFormat = gl.RGB8UI;
			if ( glType === gl.UNSIGNED_SHORT ) internalFormat = gl.RGB16UI;
			if ( glType === gl.UNSIGNED_INT ) internalFormat = gl.RGB32UI;
			if ( glType === gl.BYTE ) internalFormat = gl.RGB8I;
			if ( glType === gl.SHORT ) internalFormat = gl.RGB16I;
			if ( glType === gl.INT ) internalFormat = gl.RGB32I;

		}

		if ( glFormat === gl.RGBA ) {

			if ( glType === gl.FLOAT ) internalFormat = gl.RGBA32F;
			if ( glType === gl.HALF_FLOAT ) internalFormat = gl.RGBA16F;
			if ( glType === gl.UNSIGNED_BYTE ) internalFormat = gl.RGBA8;
			if ( glType === gl.UNSIGNED_SHORT ) internalFormat = gl.RGBA16;
			if ( glType === gl.UNSIGNED_INT ) internalFormat = gl.RGBA32UI;
			if ( glType === gl.BYTE ) internalFormat = gl.RGBA8I;
			if ( glType === gl.SHORT ) internalFormat = gl.RGBA16I;
			if ( glType === gl.INT ) internalFormat = gl.RGBA32I;
			if ( glType === gl.UNSIGNED_BYTE ) internalFormat = ( colorSpace === SRGBColorSpace && forceLinearTransfer === false ) ? gl.SRGB8_ALPHA8 : gl.RGBA8;
			if ( glType === gl.UNSIGNED_SHORT_4_4_4_4 ) internalFormat = gl.RGBA4;
			if ( glType === gl.UNSIGNED_SHORT_5_5_5_1 ) internalFormat = gl.RGB5_A1;

		}

		if ( glFormat === gl.RGBA_INTEGER ) {

			if ( glType === gl.UNSIGNED_BYTE ) internalFormat = gl.RGBA8UI;
			if ( glType === gl.UNSIGNED_SHORT ) internalFormat = gl.RGBA16UI;
			if ( glType === gl.UNSIGNED_INT ) internalFormat = gl.RGBA32UI;
			if ( glType === gl.BYTE ) internalFormat = gl.RGBA8I;
			if ( glType === gl.SHORT ) internalFormat = gl.RGBA16I;
			if ( glType === gl.INT ) internalFormat = gl.RGBA32I;

		}

		if ( glFormat === gl.DEPTH_COMPONENT ) {

			if ( glType === gl.UNSIGNED_INT ) internalFormat = gl.DEPTH24_STENCIL8;
			if ( glType === gl.FLOAT ) internalFormat = gl.DEPTH_COMPONENT32F;

		}

		if ( glFormat === gl.DEPTH_STENCIL ) {

			if ( glType === gl.UNSIGNED_INT_24_8 ) internalFormat = gl.DEPTH24_STENCIL8;

		}

		if ( internalFormat === gl.R16F || internalFormat === gl.R32F ||
			internalFormat === gl.RG16F || internalFormat === gl.RG32F ||
			internalFormat === gl.RGBA16F || internalFormat === gl.RGBA32F ) {

			extensions.get( 'EXT_color_buffer_float' );

		}

		return internalFormat;

	}

	setTextureParameters( textureType, texture ) {

		const { gl, extensions, backend } = this;


		gl.pixelStorei( gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );
		gl.pixelStorei( gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha );
		gl.pixelStorei( gl.UNPACK_ALIGNMENT, texture.unpackAlignment );
		gl.pixelStorei( gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, gl.NONE );

		gl.texParameteri( textureType, gl.TEXTURE_WRAP_S, wrappingToGL[ texture.wrapS ] );
		gl.texParameteri( textureType, gl.TEXTURE_WRAP_T, wrappingToGL[ texture.wrapT ] );

		if ( textureType === gl.TEXTURE_3D || textureType === gl.TEXTURE_2D_ARRAY ) {

			gl.texParameteri( textureType, gl.TEXTURE_WRAP_R, wrappingToGL[ texture.wrapR ] );

		}

		gl.texParameteri( textureType, gl.TEXTURE_MAG_FILTER, filterToGL[ texture.magFilter ] );


		const hasMipmaps = texture.mipmaps !== undefined && texture.mipmaps.length > 0;

		// follow WebGPU backend mapping for texture filtering
		const minFilter = texture.minFilter === LinearFilter && hasMipmaps ? LinearMipmapLinearFilter : texture.minFilter;

		gl.texParameteri( textureType, gl.TEXTURE_MIN_FILTER, filterToGL[ minFilter ] );

		if ( texture.compareFunction ) {

			gl.texParameteri( textureType, gl.TEXTURE_COMPARE_MODE, gl.COMPARE_REF_TO_TEXTURE );
			gl.texParameteri( textureType, gl.TEXTURE_COMPARE_FUNC, compareToGL[ texture.compareFunction ] );

		}

		if ( extensions.has( 'EXT_texture_filter_anisotropic' ) === true ) {

			if ( texture.magFilter === NearestFilter ) return;
			if ( texture.minFilter !== NearestMipmapLinearFilter && texture.minFilter !== LinearMipmapLinearFilter ) return;
			if ( texture.type === FloatType && extensions.has( 'OES_texture_float_linear' ) === false ) return; // verify extension for WebGL 1 and WebGL 2

			if ( texture.anisotropy > 1 ) {

				const extension = extensions.get( 'EXT_texture_filter_anisotropic' );
				gl.texParameterf( textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min( texture.anisotropy, backend.getMaxAnisotropy() ) );

			}

		}

	}

	createDefaultTexture( texture ) {

		const { gl, backend, defaultTextures } = this;


		const glTextureType = this.getGLTextureType( texture );

		let textureGPU = defaultTextures[ glTextureType ];

		if ( textureGPU === undefined ) {

			textureGPU = gl.createTexture();

			backend.state.bindTexture( glTextureType, textureGPU );
			gl.texParameteri( glTextureType, gl.TEXTURE_MIN_FILTER, gl.NEAREST );
			gl.texParameteri( glTextureType, gl.TEXTURE_MAG_FILTER, gl.NEAREST );

			// gl.texImage2D( glTextureType, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, data );

			defaultTextures[ glTextureType ] = textureGPU;

		}

		backend.set( texture, {
			textureGPU,
			glTextureType,
			isDefault: true
		} );

	}

	createTexture( texture, options ) {

		const { gl, backend } = this;
		const { levels, width, height, depth } = options;

		const glFormat = backend.utils.convert( texture.format, texture.colorSpace );
		const glType = backend.utils.convert( texture.type );
		const glInternalFormat = this.getInternalFormat( texture.internalFormat, glFormat, glType, texture.colorSpace, texture.isVideoTexture );

		const textureGPU = gl.createTexture();
		const glTextureType = this.getGLTextureType( texture );

		backend.state.bindTexture( glTextureType, textureGPU );

		this.setTextureParameters( glTextureType, texture );

		if ( texture.isDataArrayTexture || texture.isCompressedArrayTexture ) {

			gl.texStorage3D( gl.TEXTURE_2D_ARRAY, levels, glInternalFormat, width, height, depth );

		} else if ( texture.isData3DTexture ) {

			gl.texStorage3D( gl.TEXTURE_3D, levels, glInternalFormat, width, height, depth );

		} else if ( ! texture.isVideoTexture ) {

			gl.texStorage2D( glTextureType, levels, glInternalFormat, width, height );

		}

		backend.set( texture, {
			textureGPU,
			glTextureType,
			glFormat,
			glType,
			glInternalFormat
		} );

	}

	copyBufferToTexture( buffer, texture ) {

		const { gl, backend } = this;

		const { textureGPU, glTextureType, glFormat, glType } = backend.get( texture );

		const { width, height } = texture.source.data;

		gl.bindBuffer( gl.PIXEL_UNPACK_BUFFER, buffer );

		backend.state.bindTexture( glTextureType, textureGPU );

		gl.pixelStorei( gl.UNPACK_FLIP_Y_WEBGL, false );
		gl.pixelStorei( gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false );
		gl.texSubImage2D( glTextureType, 0, 0, 0, width, height, glFormat, glType, 0 );

		gl.bindBuffer( gl.PIXEL_UNPACK_BUFFER, null );

		backend.state.unbindTexture();
		// debug
		// const framebuffer = gl.createFramebuffer();
		// gl.bindFramebuffer( gl.FRAMEBUFFER, framebuffer );
		// gl.framebufferTexture2D( gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, glTextureType, textureGPU, 0 );

		// const readout = new Float32Array( width * height * 4 );

		// const altFormat = gl.getParameter( gl.IMPLEMENTATION_COLOR_READ_FORMAT );
		// const altType = gl.getParameter( gl.IMPLEMENTATION_COLOR_READ_TYPE );

		// gl.readPixels( 0, 0, width, height, altFormat, altType, readout );
		// gl.bindFramebuffer( gl.FRAMEBUFFER, null );
		// console.log( readout );

	}

	updateTexture( texture, options ) {

		const { gl } = this;
		const { width, height } = options;
		const { textureGPU, glTextureType, glFormat, glType, glInternalFormat } = this.backend.get( texture );

		if ( texture.isRenderTargetTexture || ( textureGPU === undefined /* unsupported texture format */ ) )
			return;

		const getImage = ( source ) => {

			if ( source.isDataTexture ) {

				return source.image.data;

			} else if ( ( typeof HTMLImageElement !== 'undefined' && source instanceof HTMLImageElement ) ||
				( typeof HTMLCanvasElement !== 'undefined' && source instanceof HTMLCanvasElement ) ||
				( typeof ImageBitmap !== 'undefined' && source instanceof ImageBitmap ) ||
				source instanceof OffscreenCanvas ) {

				return source;

			}

			return source.data;

		};

		this.backend.state.bindTexture( glTextureType, textureGPU );

		this.setTextureParameters( glTextureType, texture );

		if ( texture.isCompressedTexture ) {

			const mipmaps = texture.mipmaps;
			const image = options.image;

			for ( let i = 0; i < mipmaps.length; i ++ ) {

				const mipmap = mipmaps[ i ];

				if ( texture.isCompressedArrayTexture ) {


					if ( texture.format !== gl.RGBA ) {

						if ( glFormat !== null ) {

							gl.compressedTexSubImage3D( gl.TEXTURE_2D_ARRAY, i, 0, 0, 0, mipmap.width, mipmap.height, image.depth, glFormat, mipmap.data );

						} else {

							console.warn( 'THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()' );

						}

					} else {

						gl.texSubImage3D( gl.TEXTURE_2D_ARRAY, i, 0, 0, 0, mipmap.width, mipmap.height, image.depth, glFormat, glType, mipmap.data );

					}

				} else {

					if ( glFormat !== null ) {

						gl.compressedTexSubImage2D( gl.TEXTURE_2D, i, 0, 0, mipmap.width, mipmap.height, glFormat, mipmap.data );

					} else {

						console.warn( 'Unsupported compressed texture format' );

					}

				}

			}


		} else if ( texture.isCubeTexture ) {

			const images = options.images;

			for ( let i = 0; i < 6; i ++ ) {

				const image = getImage( images[ i ] );

				gl.texSubImage2D( gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, 0, 0, width, height, glFormat, glType, image );

			}

		} else if ( texture.isDataArrayTexture ) {

			const image = options.image;

			gl.texSubImage3D( gl.TEXTURE_2D_ARRAY, 0, 0, 0, 0, image.width, image.height, image.depth, glFormat, glType, image.data );

		} else if ( texture.isData3DTexture ) {

			const image = options.image;

			gl.texSubImage3D( gl.TEXTURE_3D, 0, 0, 0, 0, image.width, image.height, image.depth, glFormat, glType, image.data );

		} else if ( texture.isVideoTexture ) {

			texture.update();

			gl.texImage2D( glTextureType, 0, glInternalFormat, glFormat, glType, options.image );


		} else {

			const image = getImage( options.image );

			gl.texSubImage2D( glTextureType, 0, 0, 0, width, height, glFormat, glType, image );

		}

	}

	generateMipmaps( texture ) {

		const { gl, backend } = this;
		const { textureGPU, glTextureType } = backend.get( texture );

		backend.state.bindTexture( glTextureType, textureGPU );
		gl.generateMipmap( glTextureType );

	}

	deallocateRenderBuffers( renderTarget ) {

		const { gl, backend } = this;

		// remove framebuffer reference
		if ( renderTarget ) {

			const renderContextData = backend.get( renderTarget );

			renderContextData.renderBufferStorageSetup = undefined;

			if ( renderContextData.framebuffers ) {

				for ( const cacheKey in renderContextData.framebuffers ) {

					gl.deleteFramebuffer( renderContextData.framebuffers[ cacheKey ] );

				}

				delete renderContextData.framebuffers;

			}

			if ( renderContextData.depthRenderbuffer ) {

				gl.deleteRenderbuffer( renderContextData.depthRenderbuffer );
				delete renderContextData.depthRenderbuffer;

			}

			if ( renderContextData.stencilRenderbuffer ) {

				gl.deleteRenderbuffer( renderContextData.stencilRenderbuffer );
				delete renderContextData.stencilRenderbuffer;

			}

			if ( renderContextData.msaaFrameBuffer ) {

				gl.deleteFramebuffer( renderContextData.msaaFrameBuffer );
				delete renderContextData.msaaFrameBuffer;

			}

			if ( renderContextData.msaaRenderbuffers ) {

				for ( let i = 0; i < renderContextData.msaaRenderbuffers.length; i ++ ) {

					gl.deleteRenderbuffer( renderContextData.msaaRenderbuffers[ i ] );

				}

				delete renderContextData.msaaRenderbuffers;

			}

		}

	}

	destroyTexture( texture ) {

		const { gl, backend } = this;
		const { textureGPU, renderTarget } = backend.get( texture );

		this.deallocateRenderBuffers( renderTarget );
		gl.deleteTexture( textureGPU );

		backend.delete( texture );

	}

	copyTextureToTexture( srcTexture, dstTexture, srcRegion = null, dstPosition = null, level = 0 ) {

		const { gl, backend } = this;
		const { state } = this.backend;

		const { textureGPU: dstTextureGPU, glTextureType, glType, glFormat } = backend.get( dstTexture );

		let width, height, minX, minY;
		let dstX, dstY;

		if ( srcRegion !== null ) {

			width = srcRegion.max.x - srcRegion.min.x;
			height = srcRegion.max.y - srcRegion.min.y;
			minX = srcRegion.min.x;
			minY = srcRegion.min.y;

		} else {

			width = srcTexture.image.width;
			height = srcTexture.image.height;
			minX = 0;
			minY = 0;

		}

		if ( dstPosition !== null ) {

			dstX = dstPosition.x;
			dstY = dstPosition.y;

		} else {

			dstX = 0;
			dstY = 0;

		}

		state.bindTexture( glTextureType, dstTextureGPU );

		// As another texture upload may have changed pixelStorei
		// parameters, make sure they are correct for the dstTexture
		gl.pixelStorei( gl.UNPACK_ALIGNMENT, dstTexture.unpackAlignment );
		gl.pixelStorei( gl.UNPACK_FLIP_Y_WEBGL, dstTexture.flipY );
		gl.pixelStorei( gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, dstTexture.premultiplyAlpha );
		gl.pixelStorei( gl.UNPACK_ALIGNMENT, dstTexture.unpackAlignment );

		const currentUnpackRowLen = gl.getParameter( gl.UNPACK_ROW_LENGTH );
		const currentUnpackImageHeight = gl.getParameter( gl.UNPACK_IMAGE_HEIGHT );
		const currentUnpackSkipPixels = gl.getParameter( gl.UNPACK_SKIP_PIXELS );
		const currentUnpackSkipRows = gl.getParameter( gl.UNPACK_SKIP_ROWS );
		const currentUnpackSkipImages = gl.getParameter( gl.UNPACK_SKIP_IMAGES );

		const image = srcTexture.isCompressedTexture ? srcTexture.mipmaps[ level ] : srcTexture.image;

		gl.pixelStorei( gl.UNPACK_ROW_LENGTH, image.width );
		gl.pixelStorei( gl.UNPACK_IMAGE_HEIGHT, image.height );
		gl.pixelStorei( gl.UNPACK_SKIP_PIXELS, minX );
		gl.pixelStorei( gl.UNPACK_SKIP_ROWS, minY );

		if ( srcTexture.isRenderTargetTexture || srcTexture.isDepthTexture ) {

			const srcTextureData = backend.get( srcTexture );
			const dstTextureData = backend.get( dstTexture );

			const srcRenderContextData = backend.get( srcTextureData.renderTarget );
			const dstRenderContextData = backend.get( dstTextureData.renderTarget );

			const srcFramebuffer = srcRenderContextData.framebuffers[ srcTextureData.cacheKey ];
			const dstFramebuffer = dstRenderContextData.framebuffers[ dstTextureData.cacheKey ];

			state.bindFramebuffer( gl.READ_FRAMEBUFFER, srcFramebuffer );
			state.bindFramebuffer( gl.DRAW_FRAMEBUFFER, dstFramebuffer );

			let mask = gl.COLOR_BUFFER_BIT;

			if ( srcTexture.isDepthTexture ) mask = gl.DEPTH_BUFFER_BIT;

			gl.blitFramebuffer( minX, minY, width, height, dstX, dstY, width, height, mask, gl.NEAREST );

			state.bindFramebuffer( gl.READ_FRAMEBUFFER, null );
			state.bindFramebuffer( gl.DRAW_FRAMEBUFFER, null );

		} else {

			if ( srcTexture.isDataTexture ) {

				gl.texSubImage2D( gl.TEXTURE_2D, level, dstX, dstY, width, height, glFormat, glType, image.data );

			} else {

				if ( srcTexture.isCompressedTexture ) {

					gl.compressedTexSubImage2D( gl.TEXTURE_2D, level, dstX, dstY, image.width, image.height, glFormat, image.data );

				} else {

					gl.texSubImage2D( gl.TEXTURE_2D, level, dstX, dstY, width, height, glFormat, glType, image );

				}

			}

		}

		gl.pixelStorei( gl.UNPACK_ROW_LENGTH, currentUnpackRowLen );
		gl.pixelStorei( gl.UNPACK_IMAGE_HEIGHT, currentUnpackImageHeight );
		gl.pixelStorei( gl.UNPACK_SKIP_PIXELS, currentUnpackSkipPixels );
		gl.pixelStorei( gl.UNPACK_SKIP_ROWS, currentUnpackSkipRows );
		gl.pixelStorei( gl.UNPACK_SKIP_IMAGES, currentUnpackSkipImages );

		// Generate mipmaps only when copying level 0
		if ( level === 0 && dstTexture.generateMipmaps ) gl.generateMipmap( gl.TEXTURE_2D );

		state.unbindTexture();

	}

	copyFramebufferToTexture( texture, renderContext, rectangle ) {

		const { gl } = this;
		const { state } = this.backend;

		const { textureGPU } = this.backend.get( texture );

		const { x, y, z: width, w: height } = rectangle;

		const requireDrawFrameBuffer = texture.isDepthTexture === true || ( renderContext.renderTarget && renderContext.renderTarget.samples > 0 );

		const srcHeight = renderContext.renderTarget ? renderContext.renderTarget.height : this.backend.gerDrawingBufferSize().y;

		if ( requireDrawFrameBuffer ) {

			const partial = ( x !== 0 || y !== 0 );
			let mask;
			let attachment;

			if ( texture.isDepthTexture === true ) {

				mask = gl.DEPTH_BUFFER_BIT;
				attachment = gl.DEPTH_ATTACHMENT;

				if ( renderContext.stencil ) {

					mask |= gl.STENCIL_BUFFER_BIT;

				}

			} else {

				mask = gl.COLOR_BUFFER_BIT;
				attachment = gl.COLOR_ATTACHMENT0;

			}

			if ( partial ) {

				const renderTargetContextData = this.backend.get( renderContext.renderTarget );

				const fb = renderTargetContextData.framebuffers[ renderContext.getCacheKey() ];
				const msaaFrameBuffer = renderTargetContextData.msaaFrameBuffer;

				state.bindFramebuffer( gl.DRAW_FRAMEBUFFER, fb );
				state.bindFramebuffer( gl.READ_FRAMEBUFFER, msaaFrameBuffer );

				const flippedY = srcHeight - y - height;

				gl.blitFramebuffer( x, flippedY, x + width, flippedY + height, x, flippedY, x + width, flippedY + height, mask, gl.NEAREST );

				state.bindFramebuffer( gl.READ_FRAMEBUFFER, fb );

				state.bindTexture( gl.TEXTURE_2D, textureGPU );

				gl.copyTexSubImage2D( gl.TEXTURE_2D, 0, 0, 0, x, flippedY, width, height );

				state.unbindTexture();

			} else {

				const fb = gl.createFramebuffer();

				state.bindFramebuffer( gl.DRAW_FRAMEBUFFER, fb );

				gl.framebufferTexture2D( gl.DRAW_FRAMEBUFFER, attachment, gl.TEXTURE_2D, textureGPU, 0 );
				gl.blitFramebuffer( 0, 0, width, height, 0, 0, width, height, mask, gl.NEAREST );

				gl.deleteFramebuffer( fb );

			}

		} else {

			state.bindTexture( gl.TEXTURE_2D, textureGPU );
			gl.copyTexSubImage2D( gl.TEXTURE_2D, 0, 0, 0, x, srcHeight - height - y, width, height );

			state.unbindTexture();

		}

		if ( texture.generateMipmaps ) this.generateMipmaps( texture );

		this.backend._setFramebuffer( renderContext );

	}

	// Setup storage for internal depth/stencil buffers and bind to correct framebuffer
	setupRenderBufferStorage( renderbuffer, renderContext ) {

		const { gl } = this;
		const renderTarget = renderContext.renderTarget;

		const { samples, depthTexture, depthBuffer, stencilBuffer, width, height } = renderTarget;

		gl.bindRenderbuffer( gl.RENDERBUFFER, renderbuffer );

		if ( depthBuffer && ! stencilBuffer ) {

			let glInternalFormat = gl.DEPTH_COMPONENT24;

			if ( samples > 0 ) {

				if ( depthTexture && depthTexture.isDepthTexture ) {

					if ( depthTexture.type === gl.FLOAT ) {

						glInternalFormat = gl.DEPTH_COMPONENT32F;

					}

				}

				gl.renderbufferStorageMultisample( gl.RENDERBUFFER, samples, glInternalFormat, width, height );

			} else {

				gl.renderbufferStorage( gl.RENDERBUFFER, glInternalFormat, width, height );

			}

			gl.framebufferRenderbuffer( gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, renderbuffer );

		} else if ( depthBuffer && stencilBuffer ) {

			if ( samples > 0 ) {

				gl.renderbufferStorageMultisample( gl.RENDERBUFFER, samples, gl.DEPTH24_STENCIL8, width, height );

			} else {

				gl.renderbufferStorage( gl.RENDERBUFFER, gl.DEPTH_STENCIL, width, height );

			}


			gl.framebufferRenderbuffer( gl.FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, gl.RENDERBUFFER, renderbuffer );

		}

	}

	async copyTextureToBuffer( texture, x, y, width, height, faceIndex ) {

		const { backend, gl } = this;

		const { textureGPU, glFormat, glType } = this.backend.get( texture );

		const fb = gl.createFramebuffer();

		gl.bindFramebuffer( gl.READ_FRAMEBUFFER, fb );

		const target = texture.isCubeTexture ? gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex : gl.TEXTURE_2D;

		gl.framebufferTexture2D( gl.READ_FRAMEBUFFER, gl.COLOR_ATTACHMENT0, target, textureGPU, 0 );

		const typedArrayType = this._getTypedArrayType( glType );
		const bytesPerTexel = this._getBytesPerTexel( glType, glFormat );

		const elementCount = width * height;
		const byteLength = elementCount * bytesPerTexel;

		const buffer = gl.createBuffer();

		gl.bindBuffer( gl.PIXEL_PACK_BUFFER, buffer );
		gl.bufferData( gl.PIXEL_PACK_BUFFER, byteLength, gl.STREAM_READ );
		gl.readPixels( x, y, width, height, glFormat, glType, 0 );
		gl.bindBuffer( gl.PIXEL_PACK_BUFFER, null );

		await backend.utils._clientWaitAsync();

		const dstBuffer = new typedArrayType( byteLength / typedArrayType.BYTES_PER_ELEMENT );

		gl.bindBuffer( gl.PIXEL_PACK_BUFFER, buffer );
		gl.getBufferSubData( gl.PIXEL_PACK_BUFFER, 0, dstBuffer );
		gl.bindBuffer( gl.PIXEL_PACK_BUFFER, null );

		gl.deleteFramebuffer( fb );

		return dstBuffer;

	}

	_getTypedArrayType( glType ) {

		const { gl } = this;

		if ( glType === gl.UNSIGNED_BYTE ) return Uint8Array;

		if ( glType === gl.UNSIGNED_SHORT_4_4_4_4 ) return Uint16Array;
		if ( glType === gl.UNSIGNED_SHORT_5_5_5_1 ) return Uint16Array;
		if ( glType === gl.UNSIGNED_SHORT_5_6_5 ) return Uint16Array;
		if ( glType === gl.UNSIGNED_SHORT ) return Uint16Array;
		if ( glType === gl.UNSIGNED_INT ) return Uint32Array;

		if ( glType === gl.HALF_FLOAT ) return Uint16Array;
		if ( glType === gl.FLOAT ) return Float32Array;

		throw new Error( `Unsupported WebGL type: ${glType}` );

	}

	_getBytesPerTexel( glType, glFormat ) {

		const { gl } = this;

		let bytesPerComponent = 0;

		if ( glType === gl.UNSIGNED_BYTE ) bytesPerComponent = 1;

		if ( glType === gl.UNSIGNED_SHORT_4_4_4_4 ||
			glType === gl.UNSIGNED_SHORT_5_5_5_1 ||
			glType === gl.UNSIGNED_SHORT_5_6_5 ||
			glType === gl.UNSIGNED_SHORT ||
			glType === gl.HALF_FLOAT ) bytesPerComponent = 2;

		if ( glType === gl.UNSIGNED_INT ||
			glType === gl.FLOAT ) bytesPerComponent = 4;

		if ( glFormat === gl.RGBA ) return bytesPerComponent * 4;
		if ( glFormat === gl.RGB ) return bytesPerComponent * 3;
		if ( glFormat === gl.ALPHA ) return bytesPerComponent;

	}

}

class WebGLExtensions {

	constructor( backend ) {

		this.backend = backend;

		this.gl = this.backend.gl;
		this.availableExtensions = this.gl.getSupportedExtensions();

		this.extensions = {};

	}

	get( name ) {

		let extension = this.extensions[ name ];

		if ( extension === undefined ) {

			extension = this.gl.getExtension( name );

			this.extensions[ name ] = extension;

		}

		return extension;

	}

	has( name ) {

		return this.availableExtensions.includes( name );

	}

}

class WebGLCapabilities {

	constructor( backend ) {

		this.backend = backend;

		this.maxAnisotropy = null;

	}

	getMaxAnisotropy() {

		if ( this.maxAnisotropy !== null ) return this.maxAnisotropy;

		const gl = this.backend.gl;
		const extensions = this.backend.extensions;

		if ( extensions.has( 'EXT_texture_filter_anisotropic' ) === true ) {

			const extension = extensions.get( 'EXT_texture_filter_anisotropic' );

			this.maxAnisotropy = gl.getParameter( extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT );

		} else {

			this.maxAnisotropy = 0;

		}

		return this.maxAnisotropy;

	}

}

const GLFeatureName = {

	'WEBGL_multi_draw': 'WEBGL_multi_draw',
	'WEBGL_compressed_texture_astc': 'texture-compression-astc',
	'WEBGL_compressed_texture_etc': 'texture-compression-etc2',
	'WEBGL_compressed_texture_etc1': 'texture-compression-etc1',
	'WEBGL_compressed_texture_pvrtc': 'texture-compression-pvrtc',
	'WEBKIT_WEBGL_compressed_texture_pvrtc': 'texture-compression-pvrtc',
	'WEBGL_compressed_texture_s3tc': 'texture-compression-bc',
	'EXT_texture_compression_bptc': 'texture-compression-bptc',
	'EXT_disjoint_timer_query_webgl2': 'timestamp-query',

};

class WebGLBufferRenderer {

	constructor( backend ) {

		this.gl = backend.gl;
		this.extensions = backend.extensions;
		this.info = backend.renderer.info;
		this.mode = null;
		this.index = 0;
		this.type = null;
		this.object = null;

	}

	render( start, count ) {

		const { gl, mode, object, type, info, index } = this;

		if ( index !== 0 ) {

			gl.drawElements( mode, count, type, start );

		} else {

			gl.drawArrays( mode, start, count );

		}

		info.update( object, count, mode, 1 );

	}

	renderInstances( start, count, primcount ) {

		const { gl, mode, type, index, object, info } = this;

		if ( primcount === 0 ) return;

		if ( index !== 0 ) {

			gl.drawElementsInstanced( mode, count, type, start, primcount );

		} else {

			gl.drawArraysInstanced( mode, start, count, primcount );

		}

		info.update( object, count, mode, primcount );

	}

	renderMultiDraw( starts, counts, drawCount ) {

		const { extensions, mode, object, info } = this;

		if ( drawCount === 0 ) return;

		const extension = extensions.get( 'WEBGL_multi_draw' );

		if ( extension === null ) {

			for ( let i = 0; i < drawCount; i ++ ) {

				this.render( starts[ i ], counts[ i ] );

			}

		} else {

			if ( this.index !== 0 ) {

				extension.multiDrawElementsWEBGL( mode, counts, 0, this.type, starts, 0, drawCount );

			} else {

				extension.multiDrawArraysWEBGL( mode, starts, 0, counts, 0, drawCount );

			}

			let elementCount = 0;
			for ( let i = 0; i < drawCount; i ++ ) {

				elementCount += counts[ i ];

			}

			info.update( object, elementCount, mode, 1 );

		}

	}

	renderMultiDrawInstances( starts, counts, drawCount, primcount ) {

		const { extensions, mode, object, info } = this;

		if ( drawCount === 0 ) return;

		const extension = extensions.get( 'WEBGL_multi_draw' );

		if ( extension === null ) {

			for ( let i = 0; i < drawCount; i ++ ) {

				this.renderInstances( starts[ i ], counts[ i ], primcount[ i ] );

			}

		} else {

			if ( this.index !== 0 ) {

				extension.multiDrawElementsInstancedWEBGL( mode, counts, 0, this.type, starts, 0, primcount, 0, drawCount );

			} else {

				extension.multiDrawArraysInstancedWEBGL( mode, starts, 0, counts, 0, primcount, 0, drawCount );

			}

			let elementCount = 0;
			for ( let i = 0; i < drawCount; i ++ ) {

				elementCount += counts[ i ] * primcount[ i ];

			}

			info.update( object, elementCount, mode, 1 );

		}

	}

	//

}

//

class WebGLBackend extends Backend {

	constructor( parameters = {} ) {

		super( parameters );

		this.isWebGLBackend = true;

	}

	init( renderer ) {

		super.init( renderer );

		//

		const parameters = this.parameters;

		const glContext = ( parameters.context !== undefined ) ? parameters.context : renderer.domElement.getContext( 'webgl2' );

	 	function onContextLost( event ) {

			event.preventDefault();

			const contextLossInfo = {
				api: 'WebGL',
				message: event.statusMessage || 'Unknown reason',
				reason: null,
				originalEvent: event
			};

			renderer.onDeviceLost( contextLossInfo );

		}

		this._onContextLost = onContextLost;

		renderer.domElement.addEventListener( 'webglcontextlost', onContextLost, false );

		this.gl = glContext;

		this.extensions = new WebGLExtensions( this );
		this.capabilities = new WebGLCapabilities( this );
		this.attributeUtils = new WebGLAttributeUtils( this );
		this.textureUtils = new WebGLTextureUtils( this );
		this.bufferRenderer = new WebGLBufferRenderer( this );

		this.state = new WebGLState( this );
		this.utils = new WebGLUtils( this );

		this.vaoCache = {};
		this.transformFeedbackCache = {};
		this.discard = false;
		this.trackTimestamp = ( parameters.trackTimestamp === true );

		this.extensions.get( 'EXT_color_buffer_float' );
		this.extensions.get( 'WEBGL_clip_cull_distance' );
		this.extensions.get( 'OES_texture_float_linear' );
		this.extensions.get( 'EXT_color_buffer_half_float' );
		this.extensions.get( 'WEBGL_multisampled_render_to_texture' );
		this.extensions.get( 'WEBGL_render_shared_exponent' );
		this.extensions.get( 'WEBGL_multi_draw' );

		this.disjoint = this.extensions.get( 'EXT_disjoint_timer_query_webgl2' );
		this.parallel = this.extensions.get( 'KHR_parallel_shader_compile' );

		this._knownBindings = new WeakSet();

		this._currentContext = null;

	}

	get coordinateSystem() {

		return WebGLCoordinateSystem;

	}

	async getArrayBufferAsync( attribute ) {

		return await this.attributeUtils.getArrayBufferAsync( attribute );

	}

	async waitForGPU() {

		await this.utils._clientWaitAsync();

	}

	initTimestampQuery( renderContext ) {

		if ( ! this.disjoint || ! this.trackTimestamp ) return;

		const renderContextData = this.get( renderContext );

		if ( this.queryRunning ) {

		  if ( ! renderContextData.queryQueue ) renderContextData.queryQueue = [];
		  renderContextData.queryQueue.push( renderContext );
		  return;

		}

		if ( renderContextData.activeQuery ) {

		  this.gl.endQuery( this.disjoint.TIME_ELAPSED_EXT );
		  renderContextData.activeQuery = null;

		}

		renderContextData.activeQuery = this.gl.createQuery();

		if ( renderContextData.activeQuery !== null ) {

		  this.gl.beginQuery( this.disjoint.TIME_ELAPSED_EXT, renderContextData.activeQuery );
		  this.queryRunning = true;

		}

	}

	// timestamp utils

	prepareTimestampBuffer( renderContext ) {

		if ( ! this.disjoint || ! this.trackTimestamp ) return;

		const renderContextData = this.get( renderContext );

		if ( renderContextData.activeQuery ) {

		  this.gl.endQuery( this.disjoint.TIME_ELAPSED_EXT );

		  if ( ! renderContextData.gpuQueries ) renderContextData.gpuQueries = [];
		  renderContextData.gpuQueries.push( { query: renderContextData.activeQuery } );
		  renderContextData.activeQuery = null;
		  this.queryRunning = false;

		  if ( renderContextData.queryQueue && renderContextData.queryQueue.length > 0 ) {

				const nextRenderContext = renderContextData.queryQueue.shift();
				this.initTimestampQuery( nextRenderContext );

			}

		}

	}

	async resolveTimestampAsync( renderContext, type = 'render' ) {

		if ( ! this.disjoint || ! this.trackTimestamp ) return;

		const renderContextData = this.get( renderContext );

		if ( ! renderContextData.gpuQueries ) renderContextData.gpuQueries = [];

		for ( let i = 0; i < renderContextData.gpuQueries.length; i ++ ) {

		  const queryInfo = renderContextData.gpuQueries[ i ];
		  const available = this.gl.getQueryParameter( queryInfo.query, this.gl.QUERY_RESULT_AVAILABLE );
		  const disjoint = this.gl.getParameter( this.disjoint.GPU_DISJOINT_EXT );

		  if ( available && ! disjoint ) {

				const elapsed = this.gl.getQueryParameter( queryInfo.query, this.gl.QUERY_RESULT );
				const duration = Number( elapsed ) / 1000000; // Convert nanoseconds to milliseconds
				this.gl.deleteQuery( queryInfo.query );
				renderContextData.gpuQueries.splice( i, 1 ); // Remove the processed query
				i --;
				this.renderer.info.updateTimestamp( type, duration );

			}

		}

	}

	getContext() {

		return this.gl;

	}

	beginRender( renderContext ) {

		const { gl } = this;
		const renderContextData = this.get( renderContext );

		//

		//

		this.initTimestampQuery( renderContext );

		renderContextData.previousContext = this._currentContext;
		this._currentContext = renderContext;

		this._setFramebuffer( renderContext );

		this.clear( renderContext.clearColor, renderContext.clearDepth, renderContext.clearStencil, renderContext, false );

		//
		if ( renderContext.viewport ) {

			this.updateViewport( renderContext );

		} else {

			gl.viewport( 0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight );

		}

		if ( renderContext.scissor ) {

			const { x, y, width, height } = renderContext.scissorValue;

			gl.scissor( x, renderContext.height - height - y, width, height );

		}

		const occlusionQueryCount = renderContext.occlusionQueryCount;

		if ( occlusionQueryCount > 0 ) {

			// Get a reference to the array of objects with queries. The renderContextData property
			// can be changed by another render pass before the async reading of all previous queries complete
			renderContextData.currentOcclusionQueries = renderContextData.occlusionQueries;
			renderContextData.currentOcclusionQueryObjects = renderContextData.occlusionQueryObjects;

			renderContextData.lastOcclusionObject = null;
			renderContextData.occlusionQueries = new Array( occlusionQueryCount );
			renderContextData.occlusionQueryObjects = new Array( occlusionQueryCount );
			renderContextData.occlusionQueryIndex = 0;

		}

	}

	finishRender( renderContext ) {

		const { gl, state } = this;
		const renderContextData = this.get( renderContext );
		const previousContext = renderContextData.previousContext;

		const occlusionQueryCount = renderContext.occlusionQueryCount;

		if ( occlusionQueryCount > 0 ) {

			if ( occlusionQueryCount > renderContextData.occlusionQueryIndex ) {

				gl.endQuery( gl.ANY_SAMPLES_PASSED );

			}

			this.resolveOccludedAsync( renderContext );

		}

		const textures = renderContext.textures;

		if ( textures !== null ) {

			for ( let i = 0; i < textures.length; i ++ ) {

				const texture = textures[ i ];

				if ( texture.generateMipmaps ) {

					this.generateMipmaps( texture );

				}

			}

		}

		this._currentContext = previousContext;

		if ( renderContext.textures !== null && renderContext.renderTarget ) {

			const renderTargetContextData = this.get( renderContext.renderTarget );

			const { samples } = renderContext.renderTarget;

			if ( samples > 0 ) {

				const fb = renderTargetContextData.framebuffers[ renderContext.getCacheKey() ];

				const mask = gl.COLOR_BUFFER_BIT;

				const msaaFrameBuffer = renderTargetContextData.msaaFrameBuffer;

				const textures = renderContext.textures;

				state.bindFramebuffer( gl.READ_FRAMEBUFFER, msaaFrameBuffer );
				state.bindFramebuffer( gl.DRAW_FRAMEBUFFER, fb );

				for ( let i = 0; i < textures.length; i ++ ) {

					// TODO Add support for MRT

					if ( renderContext.scissor ) {

						const { x, y, width, height } = renderContext.scissorValue;

						const viewY = renderContext.height - height - y;

						gl.blitFramebuffer( x, viewY, x + width, viewY + height, x, viewY, x + width, viewY + height, mask, gl.NEAREST );
						gl.invalidateSubFramebuffer( gl.READ_FRAMEBUFFER, renderTargetContextData.invalidationArray, x, viewY, width, height );

					} else {

						gl.blitFramebuffer( 0, 0, renderContext.width, renderContext.height, 0, 0, renderContext.width, renderContext.height, mask, gl.NEAREST );
						gl.invalidateFramebuffer( gl.READ_FRAMEBUFFER, renderTargetContextData.invalidationArray );

					}

				}

			}


		}

		if ( previousContext !== null ) {

			this._setFramebuffer( previousContext );

			if ( previousContext.viewport ) {

				this.updateViewport( previousContext );

			} else {

				gl.viewport( 0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight );

			}

		}

		this.prepareTimestampBuffer( renderContext );

	}

	resolveOccludedAsync( renderContext ) {

		const renderContextData = this.get( renderContext );

		// handle occlusion query results

		const { currentOcclusionQueries, currentOcclusionQueryObjects } = renderContextData;

		if ( currentOcclusionQueries && currentOcclusionQueryObjects ) {

			const occluded = new WeakSet();
			const { gl } = this;

			renderContextData.currentOcclusionQueryObjects = null;
			renderContextData.currentOcclusionQueries = null;

			const check = () => {

				let completed = 0;

				// check all queries and requeue as appropriate
				for ( let i = 0; i < currentOcclusionQueries.length; i ++ ) {

					const query = currentOcclusionQueries[ i ];

					if ( query === null ) continue;

					if ( gl.getQueryParameter( query, gl.QUERY_RESULT_AVAILABLE ) ) {

						if ( gl.getQueryParameter( query, gl.QUERY_RESULT ) > 0 ) occluded.add( currentOcclusionQueryObjects[ i ] );

						currentOcclusionQueries[ i ] = null;
						gl.deleteQuery( query );

						completed ++;

					}

				}

				if ( completed < currentOcclusionQueries.length ) {

					requestAnimationFrame( check );

				} else {

					renderContextData.occluded = occluded;

				}

			};

			check();

		}

	}

	isOccluded( renderContext, object ) {

		const renderContextData = this.get( renderContext );

		return renderContextData.occluded && renderContextData.occluded.has( object );

	}

	updateViewport( renderContext ) {

		const gl = this.gl;
		const { x, y, width, height } = renderContext.viewportValue;

		gl.viewport( x, renderContext.height - height - y, width, height );

	}

	setScissorTest( boolean ) {

		const gl = this.gl;

		if ( boolean ) {

			gl.enable( gl.SCISSOR_TEST );

		} else {

			gl.disable( gl.SCISSOR_TEST );

		}

	}

	clear( color, depth, stencil, descriptor = null, setFrameBuffer = true ) {

		const { gl } = this;

		if ( descriptor === null ) {

			const clearColor = this.getClearColor();

			// premultiply alpha

			clearColor.r *= clearColor.a;
			clearColor.g *= clearColor.a;
			clearColor.b *= clearColor.a;

			descriptor = {
				textures: null,
				clearColorValue: clearColor
			};

		}

		//

		let clear = 0;

		if ( color ) clear |= gl.COLOR_BUFFER_BIT;
		if ( depth ) clear |= gl.DEPTH_BUFFER_BIT;
		if ( stencil ) clear |= gl.STENCIL_BUFFER_BIT;

		if ( clear !== 0 ) {

			let clearColor;

			if ( descriptor.clearColorValue ) {

				clearColor = descriptor.clearColorValue;

			} else {

				clearColor = this.getClearColor();

				// premultiply alpha

				clearColor.r *= clearColor.a;
				clearColor.g *= clearColor.a;
				clearColor.b *= clearColor.a;

			}

			if ( depth ) this.state.setDepthMask( true );

			if ( descriptor.textures === null ) {

				gl.clearColor( clearColor.r, clearColor.g, clearColor.b, clearColor.a );
				gl.clear( clear );

			} else {

				if ( setFrameBuffer ) this._setFramebuffer( descriptor );

				if ( color ) {

					for ( let i = 0; i < descriptor.textures.length; i ++ ) {

						gl.clearBufferfv( gl.COLOR, i, [ clearColor.r, clearColor.g, clearColor.b, clearColor.a ] );

					}

				}

				if ( depth && stencil ) {

					gl.clearBufferfi( gl.DEPTH_STENCIL, 0, 1, 0 );

				} else if ( depth ) {

					gl.clearBufferfv( gl.DEPTH, 0, [ 1.0 ] );

				} else if ( stencil ) {

					gl.clearBufferiv( gl.STENCIL, 0, [ 0 ] );

				}

			}

		}

	}

	beginCompute( computeGroup ) {

		const { state, gl } = this;

		state.bindFramebuffer( gl.FRAMEBUFFER, null );
		this.initTimestampQuery( computeGroup );

	}

	compute( computeGroup, computeNode, bindings, pipeline ) {

		const { state, gl } = this;

		if ( ! this.discard ) {

			// required here to handle async behaviour of render.compute()
			gl.enable( gl.RASTERIZER_DISCARD );
			this.discard = true;

		}

		const { programGPU, transformBuffers, attributes } = this.get( pipeline );

		const vaoKey = this._getVaoKey( null, attributes );

		const vaoGPU = this.vaoCache[ vaoKey ];

		if ( vaoGPU === undefined ) {

			this._createVao( null, attributes );

		} else {

			gl.bindVertexArray( vaoGPU );

		}

		state.useProgram( programGPU );

		this._bindUniforms( bindings );

		const transformFeedbackGPU = this._getTransformFeedback( transformBuffers );

		gl.bindTransformFeedback( gl.TRANSFORM_FEEDBACK, transformFeedbackGPU );
		gl.beginTransformFeedback( gl.POINTS );

		if ( attributes[ 0 ].isStorageInstancedBufferAttribute ) {

			gl.drawArraysInstanced( gl.POINTS, 0, 1, computeNode.count );

		} else {

			gl.drawArrays( gl.POINTS, 0, computeNode.count );

		}

		gl.endTransformFeedback();
		gl.bindTransformFeedback( gl.TRANSFORM_FEEDBACK, null );

		// switch active buffers

		for ( let i = 0; i < transformBuffers.length; i ++ ) {

			const dualAttributeData = transformBuffers[ i ];

			if ( dualAttributeData.pbo ) {

				this.textureUtils.copyBufferToTexture( dualAttributeData.transformBuffer, dualAttributeData.pbo );

			}

			dualAttributeData.switchBuffers();


		}

	}

	finishCompute( computeGroup ) {

		const gl = this.gl;

		this.discard = false;

		gl.disable( gl.RASTERIZER_DISCARD );

		this.prepareTimestampBuffer( computeGroup );

		if ( this._currentContext ) {

			this._setFramebuffer( this._currentContext );

		}

	}

	draw( renderObject/*, info*/ ) {

		const { object, pipeline, material, context, hardwareClippingPlanes } = renderObject;
		const { programGPU } = this.get( pipeline );

		const { gl, state } = this;

		const contextData = this.get( context );

		const drawParams = renderObject.getDrawParameters();

		if ( drawParams === null ) return;

		//

		this._bindUniforms( renderObject.getBindings() );

		const frontFaceCW = ( object.isMesh && object.matrixWorld.determinant() < 0 );

		state.setMaterial( material, frontFaceCW, hardwareClippingPlanes );

		state.useProgram( programGPU );

		//

		const renderObjectData = this.get( renderObject );

		let vaoGPU = renderObjectData.staticVao;

		if ( vaoGPU === undefined || renderObjectData.geometryId !== renderObject.geometry.id ) {

			const vaoKey = this._getVaoKey( renderObject.getIndex(), renderObject.getAttributes() );

			vaoGPU = this.vaoCache[ vaoKey ];

			if ( vaoGPU === undefined ) {

				let staticVao;

				( { vaoGPU, staticVao } = this._createVao( renderObject.getIndex(), renderObject.getAttributes() ) );

				if ( staticVao ) {

					renderObjectData.staticVao = vaoGPU;
					renderObjectData.geometryId = renderObject.geometry.id;

				}

			}

		}

		gl.bindVertexArray( vaoGPU );

		//

		const index = renderObject.getIndex();

		//

		const lastObject = contextData.lastOcclusionObject;

		if ( lastObject !== object && lastObject !== undefined ) {

			if ( lastObject !== null && lastObject.occlusionTest === true ) {

				gl.endQuery( gl.ANY_SAMPLES_PASSED );

				contextData.occlusionQueryIndex ++;

			}

			if ( object.occlusionTest === true ) {

				const query = gl.createQuery();

				gl.beginQuery( gl.ANY_SAMPLES_PASSED, query );

				contextData.occlusionQueries[ contextData.occlusionQueryIndex ] = query;
				contextData.occlusionQueryObjects[ contextData.occlusionQueryIndex ] = object;

			}

			contextData.lastOcclusionObject = object;

		}

		//
		const renderer = this.bufferRenderer;

		if ( object.isPoints ) renderer.mode = gl.POINTS;
		else if ( object.isLineSegments ) renderer.mode = gl.LINES;
		else if ( object.isLine ) renderer.mode = gl.LINE_STRIP;
		else if ( object.isLineLoop ) renderer.mode = gl.LINE_LOOP;
		else {

			if ( material.wireframe === true ) {

				state.setLineWidth( material.wireframeLinewidth * this.renderer.getPixelRatio() );
				renderer.mode = gl.LINES;

			} else {

				renderer.mode = gl.TRIANGLES;

			}

		}

		//

		const { vertexCount, instanceCount } = drawParams;
		let { firstVertex } = drawParams;

		renderer.object = object;

		if ( index !== null ) {

			firstVertex *= index.array.BYTES_PER_ELEMENT;

			const indexData = this.get( index );

			renderer.index = index.count;
			renderer.type = indexData.type;

		} else {

			renderer.index = 0;

		}

		if ( object.isBatchedMesh ) {

			if ( object._multiDrawInstances !== null ) {

				renderer.renderMultiDrawInstances( object._multiDrawStarts, object._multiDrawCounts, object._multiDrawCount, object._multiDrawInstances );

			} else if ( ! this.hasFeature( 'WEBGL_multi_draw' ) ) {

				warnOnce( 'THREE.WebGLRenderer: WEBGL_multi_draw not supported.' );

			} else {

				renderer.renderMultiDraw( object._multiDrawStarts, object._multiDrawCounts, object._multiDrawCount );

			}

		} else if ( instanceCount > 1 ) {

			renderer.renderInstances( firstVertex, vertexCount, instanceCount );

		} else {

			renderer.render( firstVertex, vertexCount );

		}
		//

		gl.bindVertexArray( null );

	}

	needsRenderUpdate( /*renderObject*/ ) {

		return false;

	}

	getRenderCacheKey( /*renderObject*/ ) {

		return '';

	}

	// textures

	createDefaultTexture( texture ) {

		this.textureUtils.createDefaultTexture( texture );

	}

	createTexture( texture, options ) {

		this.textureUtils.createTexture( texture, options );

	}

	updateTexture( texture, options ) {

		this.textureUtils.updateTexture( texture, options );

	}

	generateMipmaps( texture ) {

		this.textureUtils.generateMipmaps( texture );

	}


	destroyTexture( texture ) {

		this.textureUtils.destroyTexture( texture );

	}

	copyTextureToBuffer( texture, x, y, width, height, faceIndex ) {

		return this.textureUtils.copyTextureToBuffer( texture, x, y, width, height, faceIndex );

	}

	createSampler( /*texture*/ ) {

		//console.warn( 'Abstract class.' );

	}

	destroySampler() {}

	// node builder

	createNodeBuilder( object, renderer ) {

		return new GLSLNodeBuilder( object, renderer );

	}

	// program

	createProgram( program ) {

		const gl = this.gl;
		const { stage, code } = program;

		const shader = stage === 'fragment' ? gl.createShader( gl.FRAGMENT_SHADER ) : gl.createShader( gl.VERTEX_SHADER );

		gl.shaderSource( shader, code );
		gl.compileShader( shader );

		this.set( program, {
			shaderGPU: shader
		} );

	}

	destroyProgram( /*program*/ ) {

		console.warn( 'Abstract class.' );

	}

	createRenderPipeline( renderObject, promises ) {

		const gl = this.gl;
		const pipeline = renderObject.pipeline;

		// Program

		const { fragmentProgram, vertexProgram } = pipeline;

		const programGPU = gl.createProgram();

		const fragmentShader = this.get( fragmentProgram ).shaderGPU;
		const vertexShader = this.get( vertexProgram ).shaderGPU;

		gl.attachShader( programGPU, fragmentShader );
		gl.attachShader( programGPU, vertexShader );
		gl.linkProgram( programGPU );

		this.set( pipeline, {
			programGPU,
			fragmentShader,
			vertexShader
		} );

		if ( promises !== null && this.parallel ) {

			const p = new Promise( ( resolve /*, reject*/ ) => {

				const parallel = this.parallel;
				const checkStatus = () => {

					if ( gl.getProgramParameter( programGPU, parallel.COMPLETION_STATUS_KHR ) ) {

						this._completeCompile( renderObject, pipeline );
						resolve();

					} else {

						requestAnimationFrame( checkStatus );

					}

				};

				checkStatus();

			} );

			promises.push( p );

			return;

		}

		this._completeCompile( renderObject, pipeline );

	}

	_handleSource( string, errorLine ) {

		const lines = string.split( '\n' );
		const lines2 = [];

		const from = Math.max( errorLine - 6, 0 );
		const to = Math.min( errorLine + 6, lines.length );

		for ( let i = from; i < to; i ++ ) {

			const line = i + 1;
			lines2.push( `${line === errorLine ? '>' : ' '} ${line}: ${lines[ i ]}` );

		}

		return lines2.join( '\n' );

	}

	_getShaderErrors( gl, shader, type ) {

		const status = gl.getShaderParameter( shader, gl.COMPILE_STATUS );
		const errors = gl.getShaderInfoLog( shader ).trim();

		if ( status && errors === '' ) return '';

		const errorMatches = /ERROR: 0:(\d+)/.exec( errors );
		if ( errorMatches ) {

			const errorLine = parseInt( errorMatches[ 1 ] );
			return type.toUpperCase() + '\n\n' + errors + '\n\n' + this._handleSource( gl.getShaderSource( shader ), errorLine );

		} else {

			return errors;

		}

	}

	_logProgramError( programGPU, glFragmentShader, glVertexShader ) {

		if ( this.renderer.debug.checkShaderErrors ) {

			const gl = this.gl;

			const programLog = gl.getProgramInfoLog( programGPU ).trim();

			if ( gl.getProgramParameter( programGPU, gl.LINK_STATUS ) === false ) {


				if ( typeof this.renderer.debug.onShaderError === 'function' ) {

					this.renderer.debug.onShaderError( gl, programGPU, glVertexShader, glFragmentShader );

				} else {

					// default error reporting

					const vertexErrors = this._getShaderErrors( gl, glVertexShader, 'vertex' );
					const fragmentErrors = this._getShaderErrors( gl, glFragmentShader, 'fragment' );

					console.error(
						'THREE.WebGLProgram: Shader Error ' + gl.getError() + ' - ' +
						'VALIDATE_STATUS ' + gl.getProgramParameter( programGPU, gl.VALIDATE_STATUS ) + '\n\n' +
						'Program Info Log: ' + programLog + '\n' +
						vertexErrors + '\n' +
						fragmentErrors
					);

				}

			} else if ( programLog !== '' ) {

				console.warn( 'THREE.WebGLProgram: Program Info Log:', programLog );

			}

		}

	}

	_completeCompile( renderObject, pipeline ) {

		const { state, gl } = this;
		const pipelineData = this.get( pipeline );
		const { programGPU, fragmentShader, vertexShader } = pipelineData;

		if ( gl.getProgramParameter( programGPU, gl.LINK_STATUS ) === false ) {

			this._logProgramError( programGPU, fragmentShader, vertexShader );

		}

		state.useProgram( programGPU );

		// Bindings

		const bindings = renderObject.getBindings();

		this._setupBindings( bindings, programGPU );

		//

		this.set( pipeline, {
			programGPU
		} );

	}

	createComputePipeline( computePipeline, bindings ) {

		const { state, gl } = this;

		// Program

		const fragmentProgram = {
			stage: 'fragment',
			code: '#version 300 es\nprecision highp float;\nvoid main() {}'
		};

		this.createProgram( fragmentProgram );

		const { computeProgram } = computePipeline;

		const programGPU = gl.createProgram();

		const fragmentShader = this.get( fragmentProgram ).shaderGPU;
		const vertexShader = this.get( computeProgram ).shaderGPU;

		const transforms = computeProgram.transforms;

		const transformVaryingNames = [];
		const transformAttributeNodes = [];

		for ( let i = 0; i < transforms.length; i ++ ) {

			const transform = transforms[ i ];

			transformVaryingNames.push( transform.varyingName );
			transformAttributeNodes.push( transform.attributeNode );

		}

		gl.attachShader( programGPU, fragmentShader );
		gl.attachShader( programGPU, vertexShader );

		gl.transformFeedbackVaryings(
			programGPU,
			transformVaryingNames,
			gl.SEPARATE_ATTRIBS
		);

		gl.linkProgram( programGPU );

		if ( gl.getProgramParameter( programGPU, gl.LINK_STATUS ) === false ) {

			this._logProgramError( programGPU, fragmentShader, vertexShader );


		}

		state.useProgram( programGPU );

		// Bindings

		this._setupBindings( bindings, programGPU );

		const attributeNodes = computeProgram.attributes;
		const attributes = [];
		const transformBuffers = [];

		for ( let i = 0; i < attributeNodes.length; i ++ ) {

			const attribute = attributeNodes[ i ].node.attribute;

			attributes.push( attribute );

			if ( ! this.has( attribute ) ) this.attributeUtils.createAttribute( attribute, gl.ARRAY_BUFFER );

		}

		for ( let i = 0; i < transformAttributeNodes.length; i ++ ) {

			const attribute = transformAttributeNodes[ i ].attribute;

			if ( ! this.has( attribute ) ) this.attributeUtils.createAttribute( attribute, gl.ARRAY_BUFFER );

			const attributeData = this.get( attribute );

			transformBuffers.push( attributeData );

		}

		//

		this.set( computePipeline, {
			programGPU,
			transformBuffers,
			attributes
		} );

	}

	createBindings( bindGroup, bindings ) {

		if ( this._knownBindings.has( bindings ) === false ) {

			this._knownBindings.add( bindings );

			let uniformBuffers = 0;
			let textures = 0;

			for ( const bindGroup of bindings ) {

				this.set( bindGroup, {
					textures: textures,
					uniformBuffers: uniformBuffers
				} );

				for ( const binding of bindGroup.bindings ) {

					if ( binding.isUniformBuffer ) uniformBuffers ++;
					if ( binding.isSampledTexture ) textures ++;

				}

			}

		}

		this.updateBindings( bindGroup, bindings );

	}

	updateBindings( bindGroup /*, bindings*/ ) {

		const { gl } = this;

		const bindGroupData = this.get( bindGroup );

		let i = bindGroupData.uniformBuffers;
		let t = bindGroupData.textures;

		for ( const binding of bindGroup.bindings ) {

			if ( binding.isUniformsGroup || binding.isUniformBuffer ) {

				const data = binding.buffer;
				const bufferGPU = gl.createBuffer();

				gl.bindBuffer( gl.UNIFORM_BUFFER, bufferGPU );
				gl.bufferData( gl.UNIFORM_BUFFER, data, gl.DYNAMIC_DRAW );

				this.set( binding, {
					index: i ++,
					bufferGPU
				} );

			} else if ( binding.isSampledTexture ) {

				const { textureGPU, glTextureType } = this.get( binding.texture );

				this.set( binding, {
					index: t ++,
					textureGPU,
					glTextureType
				} );

			}

		}

	}

	updateBinding( binding ) {

		const gl = this.gl;

		if ( binding.isUniformsGroup || binding.isUniformBuffer ) {

			const bindingData = this.get( binding );
			const bufferGPU = bindingData.bufferGPU;
			const data = binding.buffer;

			gl.bindBuffer( gl.UNIFORM_BUFFER, bufferGPU );
			gl.bufferData( gl.UNIFORM_BUFFER, data, gl.DYNAMIC_DRAW );

		}

	}

	// attributes

	createIndexAttribute( attribute ) {

		const gl = this.gl;

		this.attributeUtils.createAttribute( attribute, gl.ELEMENT_ARRAY_BUFFER );

	}

	createAttribute( attribute ) {

		if ( this.has( attribute ) ) return;

		const gl = this.gl;

		this.attributeUtils.createAttribute( attribute, gl.ARRAY_BUFFER );

	}

	createStorageAttribute( attribute ) {

		if ( this.has( attribute ) ) return;

		const gl = this.gl;

		this.attributeUtils.createAttribute( attribute, gl.ARRAY_BUFFER );

	}

	updateAttribute( attribute ) {

		this.attributeUtils.updateAttribute( attribute );

	}

	destroyAttribute( attribute ) {

		this.attributeUtils.destroyAttribute( attribute );

	}

	updateSize() {

		//console.warn( 'Abstract class.' );

	}

	hasFeature( name ) {

		const keysMatching = Object.keys( GLFeatureName ).filter( key => GLFeatureName[ key ] === name );

		const extensions = this.extensions;

		for ( let i = 0; i < keysMatching.length; i ++ ) {

			if ( extensions.has( keysMatching[ i ] ) ) return true;

		}

		return false;

	}

	getMaxAnisotropy() {

		return this.capabilities.getMaxAnisotropy();

	}

	copyTextureToTexture( srcTexture, dstTexture, srcRegion, dstPosition, level ) {

		this.textureUtils.copyTextureToTexture( srcTexture, dstTexture, srcRegion, dstPosition, level );

	}

	copyFramebufferToTexture( texture, renderContext, rectangle ) {

		this.textureUtils.copyFramebufferToTexture( texture, renderContext, rectangle );

	}

	_setFramebuffer( descriptor ) {

		const { gl, state } = this;

		let currentFrameBuffer = null;

		if ( descriptor.textures !== null ) {

			const renderTarget = descriptor.renderTarget;
			const renderTargetContextData = this.get( renderTarget );
			const { samples, depthBuffer, stencilBuffer } = renderTarget;

			const isCube = renderTarget.isWebGLCubeRenderTarget === true;

			let msaaFb = renderTargetContextData.msaaFrameBuffer;
			let depthRenderbuffer = renderTargetContextData.depthRenderbuffer;

			const cacheKey = getCacheKey( descriptor );

			let fb;

			if ( isCube ) {

				renderTargetContextData.cubeFramebuffers || ( renderTargetContextData.cubeFramebuffers = {} );

				fb = renderTargetContextData.cubeFramebuffers[ cacheKey ];

			} else {

				renderTargetContextData.framebuffers || ( renderTargetContextData.framebuffers = {} );

				fb = renderTargetContextData.framebuffers[ cacheKey ];

			}

			if ( fb === undefined ) {

				fb = gl.createFramebuffer();

				state.bindFramebuffer( gl.FRAMEBUFFER, fb );

				const textures = descriptor.textures;

				if ( isCube ) {

					renderTargetContextData.cubeFramebuffers[ cacheKey ] = fb;

					const { textureGPU } = this.get( textures[ 0 ] );

					const cubeFace = this.renderer._activeCubeFace;

					gl.framebufferTexture2D( gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_CUBE_MAP_POSITIVE_X + cubeFace, textureGPU, 0 );

				} else {

					renderTargetContextData.framebuffers[ cacheKey ] = fb;

					for ( let i = 0; i < textures.length; i ++ ) {

						const texture = textures[ i ];
						const textureData = this.get( texture );
						textureData.renderTarget = descriptor.renderTarget;
						textureData.cacheKey = cacheKey; // required for copyTextureToTexture()

						const attachment = gl.COLOR_ATTACHMENT0 + i;

						gl.framebufferTexture2D( gl.FRAMEBUFFER, attachment, gl.TEXTURE_2D, textureData.textureGPU, 0 );

					}

					state.drawBuffers( descriptor, fb );

				}

				if ( descriptor.depthTexture !== null ) {

					const textureData = this.get( descriptor.depthTexture );
					const depthStyle = stencilBuffer ? gl.DEPTH_STENCIL_ATTACHMENT : gl.DEPTH_ATTACHMENT;
					textureData.renderTarget = descriptor.renderTarget;
					textureData.cacheKey = cacheKey; // required for copyTextureToTexture()

					gl.framebufferTexture2D( gl.FRAMEBUFFER, depthStyle, gl.TEXTURE_2D, textureData.textureGPU, 0 );

				}

			}

			if ( samples > 0 ) {

				if ( msaaFb === undefined ) {

					const invalidationArray = [];

					msaaFb = gl.createFramebuffer();

					state.bindFramebuffer( gl.FRAMEBUFFER, msaaFb );

					const msaaRenderbuffers = [];

					const textures = descriptor.textures;

					for ( let i = 0; i < textures.length; i ++ ) {

						msaaRenderbuffers[ i ] = gl.createRenderbuffer();

						gl.bindRenderbuffer( gl.RENDERBUFFER, msaaRenderbuffers[ i ] );

						invalidationArray.push( gl.COLOR_ATTACHMENT0 + i );

						if ( depthBuffer ) {

							const depthStyle = stencilBuffer ? gl.DEPTH_STENCIL_ATTACHMENT : gl.DEPTH_ATTACHMENT;
							invalidationArray.push( depthStyle );

						}

						const texture = descriptor.textures[ i ];
						const textureData = this.get( texture );

						gl.renderbufferStorageMultisample( gl.RENDERBUFFER, samples, textureData.glInternalFormat, descriptor.width, descriptor.height );
						gl.framebufferRenderbuffer( gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + i, gl.RENDERBUFFER, msaaRenderbuffers[ i ] );


					}

					renderTargetContextData.msaaFrameBuffer = msaaFb;
					renderTargetContextData.msaaRenderbuffers = msaaRenderbuffers;

					if ( depthRenderbuffer === undefined ) {

						depthRenderbuffer = gl.createRenderbuffer();
						this.textureUtils.setupRenderBufferStorage( depthRenderbuffer, descriptor );

						renderTargetContextData.depthRenderbuffer = depthRenderbuffer;

						const depthStyle = stencilBuffer ? gl.DEPTH_STENCIL_ATTACHMENT : gl.DEPTH_ATTACHMENT;
						invalidationArray.push( depthStyle );

					}

					renderTargetContextData.invalidationArray = invalidationArray;

				}

				currentFrameBuffer = renderTargetContextData.msaaFrameBuffer;

			} else {

				currentFrameBuffer = fb;

			}

		}

		state.bindFramebuffer( gl.FRAMEBUFFER, currentFrameBuffer );

	}


	_getVaoKey( index, attributes ) {

		let key = [];

		if ( index !== null ) {

			const indexData = this.get( index );

			key += ':' + indexData.id;

		}

		for ( let i = 0; i < attributes.length; i ++ ) {

			const attributeData = this.get( attributes[ i ] );

			key += ':' + attributeData.id;

		}

		return key;

	}

	_createVao( index, attributes ) {

		const { gl } = this;

		const vaoGPU = gl.createVertexArray();
		let key = '';

		let staticVao = true;

		gl.bindVertexArray( vaoGPU );

		if ( index !== null ) {

			const indexData = this.get( index );

			gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, indexData.bufferGPU );

			key += ':' + indexData.id;

		}

		for ( let i = 0; i < attributes.length; i ++ ) {

			const attribute = attributes[ i ];
			const attributeData = this.get( attribute );

			key += ':' + attributeData.id;

			gl.bindBuffer( gl.ARRAY_BUFFER, attributeData.bufferGPU );
			gl.enableVertexAttribArray( i );

			if ( attribute.isStorageBufferAttribute || attribute.isStorageInstancedBufferAttribute ) staticVao = false;

			let stride, offset;

			if ( attribute.isInterleavedBufferAttribute === true ) {

				stride = attribute.data.stride * attributeData.bytesPerElement;
				offset = attribute.offset * attributeData.bytesPerElement;

			} else {

				stride = 0;
				offset = 0;

			}

			if ( attributeData.isInteger ) {

				gl.vertexAttribIPointer( i, attribute.itemSize, attributeData.type, stride, offset );

			} else {

				gl.vertexAttribPointer( i, attribute.itemSize, attributeData.type, attribute.normalized, stride, offset );

			}

			if ( attribute.isInstancedBufferAttribute && ! attribute.isInterleavedBufferAttribute ) {

				gl.vertexAttribDivisor( i, attribute.meshPerAttribute );

			} else if ( attribute.isInterleavedBufferAttribute && attribute.data.isInstancedInterleavedBuffer ) {

				gl.vertexAttribDivisor( i, attribute.data.meshPerAttribute );

			}

		}

		gl.bindBuffer( gl.ARRAY_BUFFER, null );

		this.vaoCache[ key ] = vaoGPU;

		return { vaoGPU, staticVao };

	}

	_getTransformFeedback( transformBuffers ) {

		let key = '';

		for ( let i = 0; i < transformBuffers.length; i ++ ) {

			key += ':' + transformBuffers[ i ].id;

		}

		let transformFeedbackGPU = this.transformFeedbackCache[ key ];

		if ( transformFeedbackGPU !== undefined ) {

			return transformFeedbackGPU;

		}

		const { gl } = this;

		transformFeedbackGPU = gl.createTransformFeedback();

		gl.bindTransformFeedback( gl.TRANSFORM_FEEDBACK, transformFeedbackGPU );

		for ( let i = 0; i < transformBuffers.length; i ++ ) {

			const attributeData = transformBuffers[ i ];

			gl.bindBufferBase( gl.TRANSFORM_FEEDBACK_BUFFER, i, attributeData.transformBuffer );

		}

		gl.bindTransformFeedback( gl.TRANSFORM_FEEDBACK, null );

		this.transformFeedbackCache[ key ] = transformFeedbackGPU;

		return transformFeedbackGPU;

	}


	_setupBindings( bindings, programGPU ) {

		const gl = this.gl;

		for ( const bindGroup of bindings ) {

			for ( const binding of bindGroup.bindings ) {

				const bindingData = this.get( binding );
				const index = bindingData.index;

				if ( binding.isUniformsGroup || binding.isUniformBuffer ) {

					const location = gl.getUniformBlockIndex( programGPU, binding.name );
					gl.uniformBlockBinding( programGPU, location, index );

				} else if ( binding.isSampledTexture ) {

					const location = gl.getUniformLocation( programGPU, binding.name );
					gl.uniform1i( location, index );

				}

			}

		}

	}

	_bindUniforms( bindings ) {

		const { gl, state } = this;

		for ( const bindGroup of bindings ) {

			for ( const binding of bindGroup.bindings ) {

				const bindingData = this.get( binding );
				const index = bindingData.index;

				if ( binding.isUniformsGroup || binding.isUniformBuffer ) {

					// TODO USE bindBufferRange to group multiple uniform buffers
					state.bindBufferBase( gl.UNIFORM_BUFFER, index, bindingData.bufferGPU );

				} else if ( binding.isSampledTexture ) {

					state.bindTexture( bindingData.glTextureType, bindingData.textureGPU, gl.TEXTURE0 + index );

				}

			}

		}

	}

	dispose() {

		this.renderer.domElement.removeEventListener( 'webglcontextlost', this._onContextLost );

	}

}

const GPUPrimitiveTopology = {
	PointList: 'point-list',
	LineList: 'line-list',
	LineStrip: 'line-strip',
	TriangleList: 'triangle-list',
	TriangleStrip: 'triangle-strip',
};

const GPUCompareFunction = {
	Never: 'never',
	Less: 'less',
	Equal: 'equal',
	LessEqual: 'less-equal',
	Greater: 'greater',
	NotEqual: 'not-equal',
	GreaterEqual: 'greater-equal',
	Always: 'always'
};

const GPUStoreOp = {
	Store: 'store',
	Discard: 'discard'
};

const GPULoadOp = {
	Load: 'load',
	Clear: 'clear'
};

const GPUFrontFace = {
	CCW: 'ccw',
	CW: 'cw'
};

const GPUCullMode = {
	None: 'none',
	Front: 'front',
	Back: 'back'
};

const GPUIndexFormat = {
	Uint16: 'uint16',
	Uint32: 'uint32'
};

const GPUTextureFormat = {

	// 8-bit formats

	R8Unorm: 'r8unorm',
	R8Snorm: 'r8snorm',
	R8Uint: 'r8uint',
	R8Sint: 'r8sint',

	// 16-bit formats

	R16Uint: 'r16uint',
	R16Sint: 'r16sint',
	R16Float: 'r16float',
	RG8Unorm: 'rg8unorm',
	RG8Snorm: 'rg8snorm',
	RG8Uint: 'rg8uint',
	RG8Sint: 'rg8sint',

	// 32-bit formats

	R32Uint: 'r32uint',
	R32Sint: 'r32sint',
	R32Float: 'r32float',
	RG16Uint: 'rg16uint',
	RG16Sint: 'rg16sint',
	RG16Float: 'rg16float',
	RGBA8Unorm: 'rgba8unorm',
	RGBA8UnormSRGB: 'rgba8unorm-srgb',
	RGBA8Snorm: 'rgba8snorm',
	RGBA8Uint: 'rgba8uint',
	RGBA8Sint: 'rgba8sint',
	BGRA8Unorm: 'bgra8unorm',
	BGRA8UnormSRGB: 'bgra8unorm-srgb',
	// Packed 32-bit formats
	RGB9E5UFloat: 'rgb9e5ufloat',
	RGB10A2Unorm: 'rgb10a2unorm',
	RG11B10uFloat: 'rgb10a2unorm',

	// 64-bit formats

	RG32Uint: 'rg32uint',
	RG32Sint: 'rg32sint',
	RG32Float: 'rg32float',
	RGBA16Uint: 'rgba16uint',
	RGBA16Sint: 'rgba16sint',
	RGBA16Float: 'rgba16float',

	// 128-bit formats

	RGBA32Uint: 'rgba32uint',
	RGBA32Sint: 'rgba32sint',
	RGBA32Float: 'rgba32float',

	// Depth and stencil formats

	Stencil8: 'stencil8',
	Depth16Unorm: 'depth16unorm',
	Depth24Plus: 'depth24plus',
	Depth24PlusStencil8: 'depth24plus-stencil8',
	Depth32Float: 'depth32float',

	// 'depth32float-stencil8' extension

	Depth32FloatStencil8: 'depth32float-stencil8',

	// BC compressed formats usable if 'texture-compression-bc' is both
	// supported by the device/user agent and enabled in requestDevice.

	BC1RGBAUnorm: 'bc1-rgba-unorm',
	BC1RGBAUnormSRGB: 'bc1-rgba-unorm-srgb',
	BC2RGBAUnorm: 'bc2-rgba-unorm',
	BC2RGBAUnormSRGB: 'bc2-rgba-unorm-srgb',
	BC3RGBAUnorm: 'bc3-rgba-unorm',
	BC3RGBAUnormSRGB: 'bc3-rgba-unorm-srgb',
	BC4RUnorm: 'bc4-r-unorm',
	BC4RSnorm: 'bc4-r-snorm',
	BC5RGUnorm: 'bc5-rg-unorm',
	BC5RGSnorm: 'bc5-rg-snorm',
	BC6HRGBUFloat: 'bc6h-rgb-ufloat',
	BC6HRGBFloat: 'bc6h-rgb-float',
	BC7RGBAUnorm: 'bc7-rgba-unorm',
	BC7RGBAUnormSRGB: 'bc7-rgba-srgb',

	// ETC2 compressed formats usable if 'texture-compression-etc2' is both
	// supported by the device/user agent and enabled in requestDevice.

	ETC2RGB8Unorm: 'etc2-rgb8unorm',
	ETC2RGB8UnormSRGB: 'etc2-rgb8unorm-srgb',
	ETC2RGB8A1Unorm: 'etc2-rgb8a1unorm',
	ETC2RGB8A1UnormSRGB: 'etc2-rgb8a1unorm-srgb',
	ETC2RGBA8Unorm: 'etc2-rgba8unorm',
	ETC2RGBA8UnormSRGB: 'etc2-rgba8unorm-srgb',
	EACR11Unorm: 'eac-r11unorm',
	EACR11Snorm: 'eac-r11snorm',
	EACRG11Unorm: 'eac-rg11unorm',
	EACRG11Snorm: 'eac-rg11snorm',

	// ASTC compressed formats usable if 'texture-compression-astc' is both
	// supported by the device/user agent and enabled in requestDevice.

	ASTC4x4Unorm: 'astc-4x4-unorm',
	ASTC4x4UnormSRGB: 'astc-4x4-unorm-srgb',
	ASTC5x4Unorm: 'astc-5x4-unorm',
	ASTC5x4UnormSRGB: 'astc-5x4-unorm-srgb',
	ASTC5x5Unorm: 'astc-5x5-unorm',
	ASTC5x5UnormSRGB: 'astc-5x5-unorm-srgb',
	ASTC6x5Unorm: 'astc-6x5-unorm',
	ASTC6x5UnormSRGB: 'astc-6x5-unorm-srgb',
	ASTC6x6Unorm: 'astc-6x6-unorm',
	ASTC6x6UnormSRGB: 'astc-6x6-unorm-srgb',
	ASTC8x5Unorm: 'astc-8x5-unorm',
	ASTC8x5UnormSRGB: 'astc-8x5-unorm-srgb',
	ASTC8x6Unorm: 'astc-8x6-unorm',
	ASTC8x6UnormSRGB: 'astc-8x6-unorm-srgb',
	ASTC8x8Unorm: 'astc-8x8-unorm',
	ASTC8x8UnormSRGB: 'astc-8x8-unorm-srgb',
	ASTC10x5Unorm: 'astc-10x5-unorm',
	ASTC10x5UnormSRGB: 'astc-10x5-unorm-srgb',
	ASTC10x6Unorm: 'astc-10x6-unorm',
	ASTC10x6UnormSRGB: 'astc-10x6-unorm-srgb',
	ASTC10x8Unorm: 'astc-10x8-unorm',
	ASTC10x8UnormSRGB: 'astc-10x8-unorm-srgb',
	ASTC10x10Unorm: 'astc-10x10-unorm',
	ASTC10x10UnormSRGB: 'astc-10x10-unorm-srgb',
	ASTC12x10Unorm: 'astc-12x10-unorm',
	ASTC12x10UnormSRGB: 'astc-12x10-unorm-srgb',
	ASTC12x12Unorm: 'astc-12x12-unorm',
	ASTC12x12UnormSRGB: 'astc-12x12-unorm-srgb',

};

const GPUAddressMode = {
	ClampToEdge: 'clamp-to-edge',
	Repeat: 'repeat',
	MirrorRepeat: 'mirror-repeat'
};

const GPUFilterMode = {
	Linear: 'linear',
	Nearest: 'nearest'
};

const GPUBlendFactor = {
	Zero: 'zero',
	One: 'one',
	Src: 'src',
	OneMinusSrc: 'one-minus-src',
	SrcAlpha: 'src-alpha',
	OneMinusSrcAlpha: 'one-minus-src-alpha',
	Dst: 'dst',
	OneMinusDstColor: 'one-minus-dst',
	DstAlpha: 'dst-alpha',
	OneMinusDstAlpha: 'one-minus-dst-alpha',
	SrcAlphaSaturated: 'src-alpha-saturated',
	Constant: 'constant',
	OneMinusConstant: 'one-minus-constant'
};

const GPUBlendOperation = {
	Add: 'add',
	Subtract: 'subtract',
	ReverseSubtract: 'reverse-subtract',
	Min: 'min',
	Max: 'max'
};

const GPUColorWriteFlags = {
	None: 0,
	Red: 0x1,
	Green: 0x2,
	Blue: 0x4,
	Alpha: 0x8,
	All: 0xF
};

const GPUStencilOperation = {
	Keep: 'keep',
	Zero: 'zero',
	Replace: 'replace',
	Invert: 'invert',
	IncrementClamp: 'increment-clamp',
	DecrementClamp: 'decrement-clamp',
	IncrementWrap: 'increment-wrap',
	DecrementWrap: 'decrement-wrap'
};

const GPUBufferBindingType = {
	Uniform: 'uniform',
	Storage: 'storage',
	ReadOnlyStorage: 'read-only-storage'
};

const GPUStorageTextureAccess = {
	WriteOnly: 'write-only',
	ReadOnly: 'read-only',
	ReadWrite: 'read-write',
};

const GPUTextureSampleType = {
	Float: 'float',
	UnfilterableFloat: 'unfilterable-float',
	Depth: 'depth',
	SInt: 'sint',
	UInt: 'uint'
};

const GPUTextureDimension = {
	OneD: '1d',
	TwoD: '2d',
	ThreeD: '3d'
};

const GPUTextureViewDimension = {
	OneD: '1d',
	TwoD: '2d',
	TwoDArray: '2d-array',
	Cube: 'cube',
	CubeArray: 'cube-array',
	ThreeD: '3d'
};

const GPUTextureAspect = {
	All: 'all',
	StencilOnly: 'stencil-only',
	DepthOnly: 'depth-only'
};

const GPUInputStepMode = {
	Vertex: 'vertex',
	Instance: 'instance'
};

const GPUFeatureName = {
	DepthClipControl: 'depth-clip-control',
	Depth32FloatStencil8: 'depth32float-stencil8',
	TextureCompressionBC: 'texture-compression-bc',
	TextureCompressionETC2: 'texture-compression-etc2',
	TextureCompressionASTC: 'texture-compression-astc',
	TimestampQuery: 'timestamp-query',
	IndirectFirstInstance: 'indirect-first-instance',
	ShaderF16: 'shader-f16',
	RG11B10UFloat: 'rg11b10ufloat-renderable',
	BGRA8UNormStorage: 'bgra8unorm-storage',
	Float32Filterable: 'float32-filterable',
	ClipDistances: 'clip-distances',
	DualSourceBlending: 'dual-source-blending',
	Subgroups: 'subgroups'
};

class Sampler extends Binding {

	constructor( name, texture ) {

		super( name );

		this.texture = texture;
		this.version = texture ? texture.version : 0;

		this.isSampler = true;

	}

}

class NodeSampler extends Sampler {

	constructor( name, textureNode, groupNode ) {

		super( name, textureNode ? textureNode.value : null );

		this.textureNode = textureNode;
		this.groupNode = groupNode;

	}

	update() {

		this.texture = this.textureNode.value;

	}

}

class StorageBuffer extends Buffer {

	constructor( name, attribute ) {

		super( name, attribute ? attribute.array : null );

		this.attribute = attribute;

		this.isStorageBuffer = true;

	}

}

let _id = 0;

class NodeStorageBuffer extends StorageBuffer {

	constructor( nodeUniform, groupNode ) {

		super( 'StorageBuffer_' + _id ++, nodeUniform ? nodeUniform.value : null );

		this.nodeUniform = nodeUniform;
		this.access = nodeUniform ? nodeUniform.access : NodeAccess.READ_WRITE;
		this.groupNode = groupNode;

	}

	get buffer() {

		return this.nodeUniform.value;

	}

}

class WebGPUTexturePassUtils extends DataMap {

	constructor( device ) {

		super();

		this.device = device;

		const mipmapVertexSource = `
struct VarysStruct {
	@builtin( position ) Position: vec4<f32>,
	@location( 0 ) vTex : vec2<f32>
};

@vertex
fn main( @builtin( vertex_index ) vertexIndex : u32 ) -> VarysStruct {

	var Varys : VarysStruct;

	var pos = array< vec2<f32>, 4 >(
		vec2<f32>( -1.0,  1.0 ),
		vec2<f32>(  1.0,  1.0 ),
		vec2<f32>( -1.0, -1.0 ),
		vec2<f32>(  1.0, -1.0 )
	);

	var tex = array< vec2<f32>, 4 >(
		vec2<f32>( 0.0, 0.0 ),
		vec2<f32>( 1.0, 0.0 ),
		vec2<f32>( 0.0, 1.0 ),
		vec2<f32>( 1.0, 1.0 )
	);

	Varys.vTex = tex[ vertexIndex ];
	Varys.Position = vec4<f32>( pos[ vertexIndex ], 0.0, 1.0 );

	return Varys;

}
`;

		const mipmapFragmentSource = `
@group( 0 ) @binding( 0 )
var imgSampler : sampler;

@group( 0 ) @binding( 1 )
var img : texture_2d<f32>;

@fragment
fn main( @location( 0 ) vTex : vec2<f32> ) -> @location( 0 ) vec4<f32> {

	return textureSample( img, imgSampler, vTex );

}
`;

		const flipYFragmentSource = `
@group( 0 ) @binding( 0 )
var imgSampler : sampler;

@group( 0 ) @binding( 1 )
var img : texture_2d<f32>;

@fragment
fn main( @location( 0 ) vTex : vec2<f32> ) -> @location( 0 ) vec4<f32> {

	return textureSample( img, imgSampler, vec2( vTex.x, 1.0 - vTex.y ) );

}
`;
		this.mipmapSampler = device.createSampler( { minFilter: GPUFilterMode.Linear } );
		this.flipYSampler = device.createSampler( { minFilter: GPUFilterMode.Nearest } ); //@TODO?: Consider using textureLoad()

		// We'll need a new pipeline for every texture format used.
		this.transferPipelines = {};
		this.flipYPipelines = {};

		this.mipmapVertexShaderModule = device.createShaderModule( {
			label: 'mipmapVertex',
			code: mipmapVertexSource
		} );

		this.mipmapFragmentShaderModule = device.createShaderModule( {
			label: 'mipmapFragment',
			code: mipmapFragmentSource
		} );

		this.flipYFragmentShaderModule = device.createShaderModule( {
			label: 'flipYFragment',
			code: flipYFragmentSource
		} );

	}

	getTransferPipeline( format ) {

		let pipeline = this.transferPipelines[ format ];

		if ( pipeline === undefined ) {

			pipeline = this.device.createRenderPipeline( {
				label: `mipmap-${ format }`,
				vertex: {
					module: this.mipmapVertexShaderModule,
					entryPoint: 'main'
				},
				fragment: {
					module: this.mipmapFragmentShaderModule,
					entryPoint: 'main',
					targets: [ { format } ]
				},
				primitive: {
					topology: GPUPrimitiveTopology.TriangleStrip,
					stripIndexFormat: GPUIndexFormat.Uint32
				},
				layout: 'auto'
			} );

			this.transferPipelines[ format ] = pipeline;

		}

		return pipeline;

	}

	getFlipYPipeline( format ) {

		let pipeline = this.flipYPipelines[ format ];

		if ( pipeline === undefined ) {

			pipeline = this.device.createRenderPipeline( {
				label: `flipY-${ format }`,
				vertex: {
					module: this.mipmapVertexShaderModule,
					entryPoint: 'main'
				},
				fragment: {
					module: this.flipYFragmentShaderModule,
					entryPoint: 'main',
					targets: [ { format } ]
				},
				primitive: {
					topology: GPUPrimitiveTopology.TriangleStrip,
					stripIndexFormat: GPUIndexFormat.Uint32
				},
				layout: 'auto'
			} );

			this.flipYPipelines[ format ] = pipeline;

		}

		return pipeline;

	}

	flipY( textureGPU, textureGPUDescriptor, baseArrayLayer = 0 ) {

		const format = textureGPUDescriptor.format;
		const { width, height } = textureGPUDescriptor.size;

		const transferPipeline = this.getTransferPipeline( format );
		const flipYPipeline = this.getFlipYPipeline( format );

		const tempTexture = this.device.createTexture( {
			size: { width, height, depthOrArrayLayers: 1 },
			format,
			usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.TEXTURE_BINDING
		} );

		const srcView = textureGPU.createView( {
			baseMipLevel: 0,
			mipLevelCount: 1,
			dimension: GPUTextureViewDimension.TwoD,
			baseArrayLayer
		} );

		const dstView = tempTexture.createView( {
			baseMipLevel: 0,
			mipLevelCount: 1,
			dimension: GPUTextureViewDimension.TwoD,
			baseArrayLayer: 0
		} );

		const commandEncoder = this.device.createCommandEncoder( {} );

		const pass = ( pipeline, sourceView, destinationView ) => {

			const bindGroupLayout = pipeline.getBindGroupLayout( 0 ); // @TODO: Consider making this static.

			const bindGroup = this.device.createBindGroup( {
				layout: bindGroupLayout,
				entries: [ {
					binding: 0,
					resource: this.flipYSampler
				}, {
					binding: 1,
					resource: sourceView
				} ]
			} );

			const passEncoder = commandEncoder.beginRenderPass( {
				colorAttachments: [ {
					view: destinationView,
					loadOp: GPULoadOp.Clear,
					storeOp: GPUStoreOp.Store,
					clearValue: [ 0, 0, 0, 0 ]
				} ]
			} );

			passEncoder.setPipeline( pipeline );
			passEncoder.setBindGroup( 0, bindGroup );
			passEncoder.draw( 4, 1, 0, 0 );
			passEncoder.end();

		};

		pass( transferPipeline, srcView, dstView );
		pass( flipYPipeline, dstView, srcView );

		this.device.queue.submit( [ commandEncoder.finish() ] );

		tempTexture.destroy();

	}

	generateMipmaps( textureGPU, textureGPUDescriptor, baseArrayLayer = 0 ) {

		const textureData = this.get( textureGPU );

		if ( textureData.useCount === undefined ) {

			textureData.useCount = 0;
			textureData.layers = [];

		}

		const passes = textureData.layers[ baseArrayLayer ] || this._mipmapCreateBundles( textureGPU, textureGPUDescriptor, baseArrayLayer );

		const commandEncoder = this.device.createCommandEncoder( {} );

		this._mipmapRunBundles( commandEncoder, passes );

		this.device.queue.submit( [ commandEncoder.finish() ] );

		if ( textureData.useCount !== 0 ) textureData.layers[ baseArrayLayer ] = passes;

		textureData.useCount ++;

	}

	_mipmapCreateBundles( textureGPU, textureGPUDescriptor, baseArrayLayer ) {

		const pipeline = this.getTransferPipeline( textureGPUDescriptor.format );

		const bindGroupLayout = pipeline.getBindGroupLayout( 0 ); // @TODO: Consider making this static.

		let srcView = textureGPU.createView( {
			baseMipLevel: 0,
			mipLevelCount: 1,
			dimension: GPUTextureViewDimension.TwoD,
			baseArrayLayer
		} );

		const passes = [];

		for ( let i = 1; i < textureGPUDescriptor.mipLevelCount; i ++ ) {

			const bindGroup = this.device.createBindGroup( {
				layout: bindGroupLayout,
				entries: [ {
					binding: 0,
					resource: this.mipmapSampler
				}, {
					binding: 1,
					resource: srcView
				} ]
			} );

			const dstView = textureGPU.createView( {
				baseMipLevel: i,
				mipLevelCount: 1,
				dimension: GPUTextureViewDimension.TwoD,
				baseArrayLayer
			} );

			const passDescriptor = {
				colorAttachments: [ {
					view: dstView,
					loadOp: GPULoadOp.Clear,
					storeOp: GPUStoreOp.Store,
					clearValue: [ 0, 0, 0, 0 ]
				} ]
			};

			const passEncoder = this.device.createRenderBundleEncoder( {
				colorFormats: [ textureGPUDescriptor.format ]
			} );

			passEncoder.setPipeline( pipeline );
			passEncoder.setBindGroup( 0, bindGroup );
			passEncoder.draw( 4, 1, 0, 0 );

			passes.push( {
				renderBundles: [ passEncoder.finish() ],
				passDescriptor
			} );

			srcView = dstView;

		}

		return passes;

	}

	_mipmapRunBundles( commandEncoder, passes ) {

		const levels = passes.length;

		for ( let i = 0; i < levels; i ++ ) {

			const pass = passes[ i ];

			const passEncoder = commandEncoder.beginRenderPass( pass.passDescriptor );

			passEncoder.executeBundles( pass.renderBundles );

			passEncoder.end();

		}

	}

}

const _compareToWebGPU = {
	[ NeverCompare ]: 'never',
	[ LessCompare ]: 'less',
	[ EqualCompare ]: 'equal',
	[ LessEqualCompare ]: 'less-equal',
	[ GreaterCompare ]: 'greater',
	[ GreaterEqualCompare ]: 'greater-equal',
	[ AlwaysCompare ]: 'always',
	[ NotEqualCompare ]: 'not-equal'
};

const _flipMap = [ 0, 1, 3, 2, 4, 5 ];

class WebGPUTextureUtils {

	constructor( backend ) {

		this.backend = backend;

		this._passUtils = null;

		this.defaultTexture = {};
		this.defaultCubeTexture = {};
		this.defaultVideoFrame = null;

		this.colorBuffer = null;

		this.depthTexture = new DepthTexture();
		this.depthTexture.name = 'depthBuffer';

	}

	createSampler( texture ) {

		const backend = this.backend;
		const device = backend.device;

		const textureGPU = backend.get( texture );

		const samplerDescriptorGPU = {
			addressModeU: this._convertAddressMode( texture.wrapS ),
			addressModeV: this._convertAddressMode( texture.wrapT ),
			addressModeW: this._convertAddressMode( texture.wrapR ),
			magFilter: this._convertFilterMode( texture.magFilter ),
			minFilter: this._convertFilterMode( texture.minFilter ),
			mipmapFilter: this._convertFilterMode( texture.minFilter ),
			maxAnisotropy: 1
		};

		// anisotropy can only be used when all filter modes are set to linear.

		if ( samplerDescriptorGPU.magFilter === GPUFilterMode.Linear && samplerDescriptorGPU.minFilter === GPUFilterMode.Linear && samplerDescriptorGPU.mipmapFilter === GPUFilterMode.Linear ) {

			samplerDescriptorGPU.maxAnisotropy = texture.anisotropy;

		}

		if ( texture.isDepthTexture && texture.compareFunction !== null ) {

			samplerDescriptorGPU.compare = _compareToWebGPU[ texture.compareFunction ];

		}

		textureGPU.sampler = device.createSampler( samplerDescriptorGPU );

	}

	createDefaultTexture( texture ) {

		let textureGPU;

		const format = getFormat( texture );

		if ( texture.isCubeTexture ) {

			textureGPU = this._getDefaultCubeTextureGPU( format );

		} else if ( texture.isVideoTexture ) {

			this.backend.get( texture ).externalTexture = this._getDefaultVideoFrame();

		} else {

			textureGPU = this._getDefaultTextureGPU( format );

		}

		this.backend.get( texture ).texture = textureGPU;

	}

	createTexture( texture, options = {} ) {

		const backend = this.backend;
		const textureData = backend.get( texture );

		if ( textureData.initialized ) {

			throw new Error( 'WebGPUTextureUtils: Texture already initialized.' );

		}

		if ( options.needsMipmaps === undefined ) options.needsMipmaps = false;
		if ( options.levels === undefined ) options.levels = 1;
		if ( options.depth === undefined ) options.depth = 1;

		const { width, height, depth, levels } = options;

		if ( texture.isFramebufferTexture ) {

			if ( options.renderTarget ) {

				options.format = this.backend.utils.getCurrentColorFormat( options.renderTarget );

			} else {

				options.format = this.backend.utils.getPreferredCanvasFormat();

			}

		}

		const dimension = this._getDimension( texture );
		const format = texture.internalFormat || options.format || getFormat( texture, backend.device );

		textureData.format = format;

		const { samples, primarySamples, isMSAA } = backend.utils.getTextureSampleData( texture );

		let usage = GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.COPY_SRC;

		if ( texture.isStorageTexture === true ) {

			usage |= GPUTextureUsage.STORAGE_BINDING;

		}

		if ( texture.isCompressedTexture !== true && texture.isCompressedArrayTexture !== true ) {

			usage |= GPUTextureUsage.RENDER_ATTACHMENT;

		}

		const textureDescriptorGPU = {
			label: texture.name,
			size: {
				width: width,
				height: height,
				depthOrArrayLayers: depth,
			},
			mipLevelCount: levels,
			sampleCount: primarySamples,
			dimension: dimension,
			format: format,
			usage: usage
		};

		// texture creation

		if ( texture.isVideoTexture ) {

			const video = texture.source.data;
			const videoFrame = new VideoFrame( video );

			textureDescriptorGPU.size.width = videoFrame.displayWidth;
			textureDescriptorGPU.size.height = videoFrame.displayHeight;

			videoFrame.close();

			textureData.externalTexture = video;

		} else {

			if ( format === undefined ) {

				console.warn( 'WebGPURenderer: Texture format not supported.' );

				return this.createDefaultTexture( texture );

			}

			textureData.texture = backend.device.createTexture( textureDescriptorGPU );

		}

		if ( isMSAA ) {

			const msaaTextureDescriptorGPU = Object.assign( {}, textureDescriptorGPU );

			msaaTextureDescriptorGPU.label = msaaTextureDescriptorGPU.label + '-msaa';
			msaaTextureDescriptorGPU.sampleCount = samples;

			textureData.msaaTexture = backend.device.createTexture( msaaTextureDescriptorGPU );

		}

		textureData.initialized = true;

		textureData.textureDescriptorGPU = textureDescriptorGPU;

	}

	destroyTexture( texture ) {

		const backend = this.backend;
		const textureData = backend.get( texture );

		if ( textureData.texture !== undefined ) textureData.texture.destroy();

		if ( textureData.msaaTexture !== undefined ) textureData.msaaTexture.destroy();

		backend.delete( texture );

	}

	destroySampler( texture ) {

		const backend = this.backend;
		const textureData = backend.get( texture );

		delete textureData.sampler;

	}

	generateMipmaps( texture ) {

		const textureData = this.backend.get( texture );

		if ( texture.isCubeTexture ) {

			for ( let i = 0; i < 6; i ++ ) {

				this._generateMipmaps( textureData.texture, textureData.textureDescriptorGPU, i );

			}

		} else {

			const depth = texture.image.depth || 1;

			for ( let i = 0; i < depth; i ++ ) {

				this._generateMipmaps( textureData.texture, textureData.textureDescriptorGPU, i );

			}

		}

	}

	getColorBuffer() {

		if ( this.colorBuffer ) this.colorBuffer.destroy();

		const backend = this.backend;
		const { width, height } = backend.getDrawingBufferSize();

		this.colorBuffer = backend.device.createTexture( {
			label: 'colorBuffer',
			size: {
				width: width,
				height: height,
				depthOrArrayLayers: 1
			},
			sampleCount: backend.utils.getSampleCount( backend.renderer.samples ),
			format: backend.utils.getPreferredCanvasFormat(),
			usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC
		} );

		return this.colorBuffer;

	}

	getDepthBuffer( depth = true, stencil = false ) {

		const backend = this.backend;
		const { width, height } = backend.getDrawingBufferSize();

		const depthTexture = this.depthTexture;
		const depthTextureGPU = backend.get( depthTexture ).texture;

		let format, type;

		if ( stencil ) {

			format = DepthStencilFormat;
			type = UnsignedInt248Type;

		} else if ( depth ) {

			format = DepthFormat;
			type = UnsignedIntType;

		}

		if ( depthTextureGPU !== undefined ) {

			if ( depthTexture.image.width === width && depthTexture.image.height === height && depthTexture.format === format && depthTexture.type === type ) {

				return depthTextureGPU;

			}

			this.destroyTexture( depthTexture );

		}

		depthTexture.name = 'depthBuffer';
		depthTexture.format = format;
		depthTexture.type = type;
		depthTexture.image.width = width;
		depthTexture.image.height = height;

		this.createTexture( depthTexture, { width, height } );

		return backend.get( depthTexture ).texture;

	}

	updateTexture( texture, options ) {

		const textureData = this.backend.get( texture );

		const { textureDescriptorGPU } = textureData;

		if ( texture.isRenderTargetTexture || ( textureDescriptorGPU === undefined /* unsupported texture format */ ) )
			return;

		// transfer texture data

		if ( texture.isDataTexture ) {

			this._copyBufferToTexture( options.image, textureData.texture, textureDescriptorGPU, 0, texture.flipY );

		} else if ( texture.isDataArrayTexture || texture.isData3DTexture ) {

			for ( let i = 0; i < options.image.depth; i ++ ) {

				this._copyBufferToTexture( options.image, textureData.texture, textureDescriptorGPU, i, texture.flipY, i );

			}

		} else if ( texture.isCompressedTexture || texture.isCompressedArrayTexture ) {

			this._copyCompressedBufferToTexture( texture.mipmaps, textureData.texture, textureDescriptorGPU );

		} else if ( texture.isCubeTexture ) {

			this._copyCubeMapToTexture( options.images, textureData.texture, textureDescriptorGPU, texture.flipY );

		} else if ( texture.isVideoTexture ) {

			const video = texture.source.data;

			textureData.externalTexture = video;

		} else {

			this._copyImageToTexture( options.image, textureData.texture, textureDescriptorGPU, 0, texture.flipY );

		}

		//

		textureData.version = texture.version;

		if ( texture.onUpdate ) texture.onUpdate( texture );

	}

	async copyTextureToBuffer( texture, x, y, width, height, faceIndex ) {

		const device = this.backend.device;

		const textureData = this.backend.get( texture );
		const textureGPU = textureData.texture;
		const format = textureData.textureDescriptorGPU.format;
		const bytesPerTexel = this._getBytesPerTexel( format );

		let bytesPerRow = width * bytesPerTexel;
		bytesPerRow = Math.ceil( bytesPerRow / 256 ) * 256; // Align to 256 bytes

		const readBuffer = device.createBuffer(
			{
				size: width * height * bytesPerTexel,
				usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ
			}
		);

		const encoder = device.createCommandEncoder();

		encoder.copyTextureToBuffer(
			{
				texture: textureGPU,
				origin: { x, y, z: faceIndex },
			},
			{
				buffer: readBuffer,
				bytesPerRow: bytesPerRow
			},
			{
				width: width,
				height: height
			}

		);

		const typedArrayType = this._getTypedArrayType( format );

		device.queue.submit( [ encoder.finish() ] );

		await readBuffer.mapAsync( GPUMapMode.READ );

		const buffer = readBuffer.getMappedRange();

		return new typedArrayType( buffer );

	}

	_isEnvironmentTexture( texture ) {

		const mapping = texture.mapping;

		return ( mapping === EquirectangularReflectionMapping || mapping === EquirectangularRefractionMapping ) || ( mapping === CubeReflectionMapping || mapping === CubeRefractionMapping );

	}

	_getDefaultTextureGPU( format ) {

		let defaultTexture = this.defaultTexture[ format ];

		if ( defaultTexture === undefined ) {

			const texture = new Texture();
			texture.minFilter = NearestFilter;
			texture.magFilter = NearestFilter;

			this.createTexture( texture, { width: 1, height: 1, format } );

			this.defaultTexture[ format ] = defaultTexture = texture;

		}

		return this.backend.get( defaultTexture ).texture;

	}

	_getDefaultCubeTextureGPU( format ) {

		let defaultCubeTexture = this.defaultTexture[ format ];

		if ( defaultCubeTexture === undefined ) {

			const texture = new CubeTexture();
			texture.minFilter = NearestFilter;
			texture.magFilter = NearestFilter;

			this.createTexture( texture, { width: 1, height: 1, depth: 6 } );

			this.defaultCubeTexture[ format ] = defaultCubeTexture = texture;

		}

		return this.backend.get( defaultCubeTexture ).texture;

	}

	_getDefaultVideoFrame() {

		let defaultVideoFrame = this.defaultVideoFrame;

		if ( defaultVideoFrame === null ) {

			const init = {
				timestamp: 0,
				codedWidth: 1,
				codedHeight: 1,
				format: 'RGBA',
			};

			this.defaultVideoFrame = defaultVideoFrame = new VideoFrame( new Uint8Array( [ 0, 0, 0, 0xff ] ), init );

		}

		return defaultVideoFrame;

	}

	_copyCubeMapToTexture( images, textureGPU, textureDescriptorGPU, flipY ) {

		for ( let i = 0; i < 6; i ++ ) {

			const image = images[ i ];

			const flipIndex = flipY === true ? _flipMap[ i ] : i;

			if ( image.isDataTexture ) {

				this._copyBufferToTexture( image.image, textureGPU, textureDescriptorGPU, flipIndex, flipY );

			} else {

				this._copyImageToTexture( image, textureGPU, textureDescriptorGPU, flipIndex, flipY );

			}

		}

	}

	_copyImageToTexture( image, textureGPU, textureDescriptorGPU, originDepth, flipY ) {

		const device = this.backend.device;

		device.queue.copyExternalImageToTexture(
			{
				source: image
			}, {
				texture: textureGPU,
				mipLevel: 0,
				origin: { x: 0, y: 0, z: originDepth }
			}, {
				width: image.width,
				height: image.height,
				depthOrArrayLayers: 1
			}
		);

		if ( flipY === true ) {

			this._flipY( textureGPU, textureDescriptorGPU, originDepth );

		}

	}

	_getPassUtils() {

		let passUtils = this._passUtils;

		if ( passUtils === null ) {

			this._passUtils = passUtils = new WebGPUTexturePassUtils( this.backend.device );

		}

		return passUtils;

	}

	_generateMipmaps( textureGPU, textureDescriptorGPU, baseArrayLayer = 0 ) {

		this._getPassUtils().generateMipmaps( textureGPU, textureDescriptorGPU, baseArrayLayer );

	}

	_flipY( textureGPU, textureDescriptorGPU, originDepth = 0 ) {

		this._getPassUtils().flipY( textureGPU, textureDescriptorGPU, originDepth );

	}

	_copyBufferToTexture( image, textureGPU, textureDescriptorGPU, originDepth, flipY, depth = 0 ) {

		// @TODO: Consider to use GPUCommandEncoder.copyBufferToTexture()
		// @TODO: Consider to support valid buffer layouts with other formats like RGB

		const device = this.backend.device;

		const data = image.data;

		const bytesPerTexel = this._getBytesPerTexel( textureDescriptorGPU.format );
		const bytesPerRow = image.width * bytesPerTexel;

		device.queue.writeTexture(
			{
				texture: textureGPU,
				mipLevel: 0,
				origin: { x: 0, y: 0, z: originDepth }
			},
			data,
			{
				offset: image.width * image.height * bytesPerTexel * depth,
				bytesPerRow
			},
			{
				width: image.width,
				height: image.height,
				depthOrArrayLayers: 1
			} );

		if ( flipY === true ) {

			this._flipY( textureGPU, textureDescriptorGPU, originDepth );

		}

	}

	_copyCompressedBufferToTexture( mipmaps, textureGPU, textureDescriptorGPU ) {

		// @TODO: Consider to use GPUCommandEncoder.copyBufferToTexture()

		const device = this.backend.device;

		const blockData = this._getBlockData( textureDescriptorGPU.format );
		const isTextureArray = textureDescriptorGPU.size.depthOrArrayLayers > 1;

		for ( let i = 0; i < mipmaps.length; i ++ ) {

			const mipmap = mipmaps[ i ];

			const width = mipmap.width;
			const height = mipmap.height;
			const depth = isTextureArray ? textureDescriptorGPU.size.depthOrArrayLayers : 1;

			const bytesPerRow = Math.ceil( width / blockData.width ) * blockData.byteLength;
			const bytesPerImage = bytesPerRow * Math.ceil( height / blockData.height );

			for ( let j = 0; j < depth; j ++ ) {

				device.queue.writeTexture(
					{
						texture: textureGPU,
						mipLevel: i,
						origin: { x: 0, y: 0, z: j }
					},
					mipmap.data,
					{
						offset: j * bytesPerImage,
						bytesPerRow,
						rowsPerImage: Math.ceil( height / blockData.height )
					},
					{
						width: Math.ceil( width / blockData.width ) * blockData.width,
						height: Math.ceil( height / blockData.height ) * blockData.height,
						depthOrArrayLayers: 1
					}
				);

			}

		}

	}

	_getBlockData( format ) {

		// this method is only relevant for compressed texture formats

		if ( format === GPUTextureFormat.BC1RGBAUnorm || format === GPUTextureFormat.BC1RGBAUnormSRGB ) return { byteLength: 8, width: 4, height: 4 }; // DXT1
		if ( format === GPUTextureFormat.BC2RGBAUnorm || format === GPUTextureFormat.BC2RGBAUnormSRGB ) return { byteLength: 16, width: 4, height: 4 }; // DXT3
		if ( format === GPUTextureFormat.BC3RGBAUnorm || format === GPUTextureFormat.BC3RGBAUnormSRGB ) return { byteLength: 16, width: 4, height: 4 }; // DXT5
		if ( format === GPUTextureFormat.BC4RUnorm || format === GPUTextureFormat.BC4RSNorm ) return { byteLength: 8, width: 4, height: 4 }; // RGTC1
		if ( format === GPUTextureFormat.BC5RGUnorm || format === GPUTextureFormat.BC5RGSnorm ) return { byteLength: 16, width: 4, height: 4 }; // RGTC2
		if ( format === GPUTextureFormat.BC6HRGBUFloat || format === GPUTextureFormat.BC6HRGBFloat ) return { byteLength: 16, width: 4, height: 4 }; // BPTC (float)
		if ( format === GPUTextureFormat.BC7RGBAUnorm || format === GPUTextureFormat.BC7RGBAUnormSRGB ) return { byteLength: 16, width: 4, height: 4 }; // BPTC (unorm)

		if ( format === GPUTextureFormat.ETC2RGB8Unorm || format === GPUTextureFormat.ETC2RGB8UnormSRGB ) return { byteLength: 8, width: 4, height: 4 };
		if ( format === GPUTextureFormat.ETC2RGB8A1Unorm || format === GPUTextureFormat.ETC2RGB8A1UnormSRGB ) return { byteLength: 8, width: 4, height: 4 };
		if ( format === GPUTextureFormat.ETC2RGBA8Unorm || format === GPUTextureFormat.ETC2RGBA8UnormSRGB ) return { byteLength: 16, width: 4, height: 4 };
		if ( format === GPUTextureFormat.EACR11Unorm ) return { byteLength: 8, width: 4, height: 4 };
		if ( format === GPUTextureFormat.EACR11Snorm ) return { byteLength: 8, width: 4, height: 4 };
		if ( format === GPUTextureFormat.EACRG11Unorm ) return { byteLength: 16, width: 4, height: 4 };
		if ( format === GPUTextureFormat.EACRG11Snorm ) return { byteLength: 16, width: 4, height: 4 };

		if ( format === GPUTextureFormat.ASTC4x4Unorm || format === GPUTextureFormat.ASTC4x4UnormSRGB ) return { byteLength: 16, width: 4, height: 4 };
		if ( format === GPUTextureFormat.ASTC5x4Unorm || format === GPUTextureFormat.ASTC5x4UnormSRGB ) return { byteLength: 16, width: 5, height: 4 };
		if ( format === GPUTextureFormat.ASTC5x5Unorm || format === GPUTextureFormat.ASTC5x5UnormSRGB ) return { byteLength: 16, width: 5, height: 5 };
		if ( format === GPUTextureFormat.ASTC6x5Unorm || format === GPUTextureFormat.ASTC6x5UnormSRGB ) return { byteLength: 16, width: 6, height: 5 };
		if ( format === GPUTextureFormat.ASTC6x6Unorm || format === GPUTextureFormat.ASTC6x6UnormSRGB ) return { byteLength: 16, width: 6, height: 6 };
		if ( format === GPUTextureFormat.ASTC8x5Unorm || format === GPUTextureFormat.ASTC8x5UnormSRGB ) return { byteLength: 16, width: 8, height: 5 };
		if ( format === GPUTextureFormat.ASTC8x6Unorm || format === GPUTextureFormat.ASTC8x6UnormSRGB ) return { byteLength: 16, width: 8, height: 6 };
		if ( format === GPUTextureFormat.ASTC8x8Unorm || format === GPUTextureFormat.ASTC8x8UnormSRGB ) return { byteLength: 16, width: 8, height: 8 };
		if ( format === GPUTextureFormat.ASTC10x5Unorm || format === GPUTextureFormat.ASTC10x5UnormSRGB ) return { byteLength: 16, width: 10, height: 5 };
		if ( format === GPUTextureFormat.ASTC10x6Unorm || format === GPUTextureFormat.ASTC10x6UnormSRGB ) return { byteLength: 16, width: 10, height: 6 };
		if ( format === GPUTextureFormat.ASTC10x8Unorm || format === GPUTextureFormat.ASTC10x8UnormSRGB ) return { byteLength: 16, width: 10, height: 8 };
		if ( format === GPUTextureFormat.ASTC10x10Unorm || format === GPUTextureFormat.ASTC10x10UnormSRGB ) return { byteLength: 16, width: 10, height: 10 };
		if ( format === GPUTextureFormat.ASTC12x10Unorm || format === GPUTextureFormat.ASTC12x10UnormSRGB ) return { byteLength: 16, width: 12, height: 10 };
		if ( format === GPUTextureFormat.ASTC12x12Unorm || format === GPUTextureFormat.ASTC12x12UnormSRGB ) return { byteLength: 16, width: 12, height: 12 };

	}

	_convertAddressMode( value ) {

		let addressMode = GPUAddressMode.ClampToEdge;

		if ( value === RepeatWrapping ) {

			addressMode = GPUAddressMode.Repeat;

		} else if ( value === MirroredRepeatWrapping ) {

			addressMode = GPUAddressMode.MirrorRepeat;

		}

		return addressMode;

	}

	_convertFilterMode( value ) {

		let filterMode = GPUFilterMode.Linear;

		if ( value === NearestFilter || value === NearestMipmapNearestFilter || value === NearestMipmapLinearFilter ) {

			filterMode = GPUFilterMode.Nearest;

		}

		return filterMode;

	}

	_getBytesPerTexel( format ) {

		// 8-bit formats
		if ( format === GPUTextureFormat.R8Unorm ||
			format === GPUTextureFormat.R8Snorm ||
			format === GPUTextureFormat.R8Uint ||
			format === GPUTextureFormat.R8Sint ) return 1;

		// 16-bit formats
		if ( format === GPUTextureFormat.R16Uint ||
			format === GPUTextureFormat.R16Sint ||
			format === GPUTextureFormat.R16Float ||
			format === GPUTextureFormat.RG8Unorm ||
			format === GPUTextureFormat.RG8Snorm ||
			format === GPUTextureFormat.RG8Uint ||
			format === GPUTextureFormat.RG8Sint ) return 2;

		// 32-bit formats
		if ( format === GPUTextureFormat.R32Uint ||
			format === GPUTextureFormat.R32Sint ||
			format === GPUTextureFormat.R32Float ||
			format === GPUTextureFormat.RG16Uint ||
			format === GPUTextureFormat.RG16Sint ||
			format === GPUTextureFormat.RG16Float ||
			format === GPUTextureFormat.RGBA8Unorm ||
			format === GPUTextureFormat.RGBA8UnormSRGB ||
			format === GPUTextureFormat.RGBA8Snorm ||
			format === GPUTextureFormat.RGBA8Uint ||
			format === GPUTextureFormat.RGBA8Sint ||
			format === GPUTextureFormat.BGRA8Unorm ||
			format === GPUTextureFormat.BGRA8UnormSRGB ||
			// Packed 32-bit formats
			format === GPUTextureFormat.RGB9E5UFloat ||
			format === GPUTextureFormat.RGB10A2Unorm ||
			format === GPUTextureFormat.RG11B10UFloat ||
			format === GPUTextureFormat.Depth32Float ||
			format === GPUTextureFormat.Depth24Plus ||
			format === GPUTextureFormat.Depth24PlusStencil8 ||
			format === GPUTextureFormat.Depth32FloatStencil8 ) return 4;

		// 64-bit formats
		if ( format === GPUTextureFormat.RG32Uint ||
			format === GPUTextureFormat.RG32Sint ||
			format === GPUTextureFormat.RG32Float ||
			format === GPUTextureFormat.RGBA16Uint ||
			format === GPUTextureFormat.RGBA16Sint ||
			format === GPUTextureFormat.RGBA16Float ) return 8;

		// 128-bit formats
		if ( format === GPUTextureFormat.RGBA32Uint ||
			format === GPUTextureFormat.RGBA32Sint ||
			format === GPUTextureFormat.RGBA32Float ) return 16;


	}

	_getTypedArrayType( format ) {

		if ( format === GPUTextureFormat.R8Uint ) return Uint8Array;
		if ( format === GPUTextureFormat.R8Sint ) return Int8Array;
		if ( format === GPUTextureFormat.R8Unorm ) return Uint8Array;
		if ( format === GPUTextureFormat.R8Snorm ) return Int8Array;
		if ( format === GPUTextureFormat.RG8Uint ) return Uint8Array;
		if ( format === GPUTextureFormat.RG8Sint ) return Int8Array;
		if ( format === GPUTextureFormat.RG8Unorm ) return Uint8Array;
		if ( format === GPUTextureFormat.RG8Snorm ) return Int8Array;
		if ( format === GPUTextureFormat.RGBA8Uint ) return Uint8Array;
		if ( format === GPUTextureFormat.RGBA8Sint ) return Int8Array;
		if ( format === GPUTextureFormat.RGBA8Unorm ) return Uint8Array;
		if ( format === GPUTextureFormat.RGBA8Snorm ) return Int8Array;


		if ( format === GPUTextureFormat.R16Uint ) return Uint16Array;
		if ( format === GPUTextureFormat.R16Sint ) return Int16Array;
		if ( format === GPUTextureFormat.RG16Uint ) return Uint16Array;
		if ( format === GPUTextureFormat.RG16Sint ) return Int16Array;
		if ( format === GPUTextureFormat.RGBA16Uint ) return Uint16Array;
		if ( format === GPUTextureFormat.RGBA16Sint ) return Int16Array;
		if ( format === GPUTextureFormat.R16Float ) return Uint16Array;
		if ( format === GPUTextureFormat.RG16Float ) return Uint16Array;
		if ( format === GPUTextureFormat.RGBA16Float ) return Uint16Array;


		if ( format === GPUTextureFormat.R32Uint ) return Uint32Array;
		if ( format === GPUTextureFormat.R32Sint ) return Int32Array;
		if ( format === GPUTextureFormat.R32Float ) return Float32Array;
		if ( format === GPUTextureFormat.RG32Uint ) return Uint32Array;
		if ( format === GPUTextureFormat.RG32Sint ) return Int32Array;
		if ( format === GPUTextureFormat.RG32Float ) return Float32Array;
		if ( format === GPUTextureFormat.RGBA32Uint ) return Uint32Array;
		if ( format === GPUTextureFormat.RGBA32Sint ) return Int32Array;
		if ( format === GPUTextureFormat.RGBA32Float ) return Float32Array;

		if ( format === GPUTextureFormat.BGRA8Unorm ) return Uint8Array;
		if ( format === GPUTextureFormat.BGRA8UnormSRGB ) return Uint8Array;
		if ( format === GPUTextureFormat.RGB10A2Unorm ) return Uint32Array;
		if ( format === GPUTextureFormat.RGB9E5UFloat ) return Uint32Array;
		if ( format === GPUTextureFormat.RG11B10UFloat ) return Uint32Array;

		if ( format === GPUTextureFormat.Depth32Float ) return Float32Array;
		if ( format === GPUTextureFormat.Depth24Plus ) return Uint32Array;
		if ( format === GPUTextureFormat.Depth24PlusStencil8 ) return Uint32Array;
		if ( format === GPUTextureFormat.Depth32FloatStencil8 ) return Float32Array;

	}

	_getDimension( texture ) {

		let dimension;

		if ( texture.isData3DTexture ) {

			dimension = GPUTextureDimension.ThreeD;

		} else {

			dimension = GPUTextureDimension.TwoD;

		}

		return dimension;

	}

}

function getFormat( texture, device = null ) {

	const format = texture.format;
	const type = texture.type;
	const colorSpace = texture.colorSpace;

	let formatGPU;

	if ( texture.isCompressedTexture === true || texture.isCompressedArrayTexture === true ) {

		switch ( format ) {

			case RGBA_S3TC_DXT1_Format:
				formatGPU = ( colorSpace === SRGBColorSpace ) ? GPUTextureFormat.BC1RGBAUnormSRGB : GPUTextureFormat.BC1RGBAUnorm;
				break;

			case RGBA_S3TC_DXT3_Format:
				formatGPU = ( colorSpace === SRGBColorSpace ) ? GPUTextureFormat.BC2RGBAUnormSRGB : GPUTextureFormat.BC2RGBAUnorm;
				break;

			case RGBA_S3TC_DXT5_Format:
				formatGPU = ( colorSpace === SRGBColorSpace ) ? GPUTextureFormat.BC3RGBAUnormSRGB : GPUTextureFormat.BC3RGBAUnorm;
				break;

			case RGB_ETC2_Format:
				formatGPU = ( colorSpace === SRGBColorSpace ) ? GPUTextureFormat.ETC2RGB8UnormSRGB : GPUTextureFormat.ETC2RGB8Unorm;
				break;

			case RGBA_ETC2_EAC_Format:
				formatGPU = ( colorSpace === SRGBColorSpace ) ? GPUTextureFormat.ETC2RGBA8UnormSRGB : GPUTextureFormat.ETC2RGBA8Unorm;
				break;

			case RGBA_ASTC_4x4_Format:
				formatGPU = ( colorSpace === SRGBColorSpace ) ? GPUTextureFormat.ASTC4x4UnormSRGB : GPUTextureFormat.ASTC4x4Unorm;
				break;

			case RGBA_ASTC_5x4_Format:
				formatGPU = ( colorSpace === SRGBColorSpace ) ? GPUTextureFormat.ASTC5x4UnormSRGB : GPUTextureFormat.ASTC5x4Unorm;
				break;

			case RGBA_ASTC_5x5_Format:
				formatGPU = ( colorSpace === SRGBColorSpace ) ? GPUTextureFormat.ASTC5x5UnormSRGB : GPUTextureFormat.ASTC5x5Unorm;
				break;

			case RGBA_ASTC_6x5_Format:
				formatGPU = ( colorSpace === SRGBColorSpace ) ? GPUTextureFormat.ASTC6x5UnormSRGB : GPUTextureFormat.ASTC6x5Unorm;
				break;

			case RGBA_ASTC_6x6_Format:
				formatGPU = ( colorSpace === SRGBColorSpace ) ? GPUTextureFormat.ASTC6x6UnormSRGB : GPUTextureFormat.ASTC6x6Unorm;
				break;

			case RGBA_ASTC_8x5_Format:
				formatGPU = ( colorSpace === SRGBColorSpace ) ? GPUTextureFormat.ASTC8x5UnormSRGB : GPUTextureFormat.ASTC8x5Unorm;
				break;

			case RGBA_ASTC_8x6_Format:
				formatGPU = ( colorSpace === SRGBColorSpace ) ? GPUTextureFormat.ASTC8x6UnormSRGB : GPUTextureFormat.ASTC8x6Unorm;
				break;

			case RGBA_ASTC_8x8_Format:
				formatGPU = ( colorSpace === SRGBColorSpace ) ? GPUTextureFormat.ASTC8x8UnormSRGB : GPUTextureFormat.ASTC8x8Unorm;
				break;

			case RGBA_ASTC_10x5_Format:
				formatGPU = ( colorSpace === SRGBColorSpace ) ? GPUTextureFormat.ASTC10x5UnormSRGB : GPUTextureFormat.ASTC10x5Unorm;
				break;

			case RGBA_ASTC_10x6_Format:
				formatGPU = ( colorSpace === SRGBColorSpace ) ? GPUTextureFormat.ASTC10x6UnormSRGB : GPUTextureFormat.ASTC10x6Unorm;
				break;

			case RGBA_ASTC_10x8_Format:
				formatGPU = ( colorSpace === SRGBColorSpace ) ? GPUTextureFormat.ASTC10x8UnormSRGB : GPUTextureFormat.ASTC10x8Unorm;
				break;

			case RGBA_ASTC_10x10_Format:
				formatGPU = ( colorSpace === SRGBColorSpace ) ? GPUTextureFormat.ASTC10x10UnormSRGB : GPUTextureFormat.ASTC10x10Unorm;
				break;

			case RGBA_ASTC_12x10_Format:
				formatGPU = ( colorSpace === SRGBColorSpace ) ? GPUTextureFormat.ASTC12x10UnormSRGB : GPUTextureFormat.ASTC12x10Unorm;
				break;

			case RGBA_ASTC_12x12_Format:
				formatGPU = ( colorSpace === SRGBColorSpace ) ? GPUTextureFormat.ASTC12x12UnormSRGB : GPUTextureFormat.ASTC12x12Unorm;
				break;

			case RGBAFormat:
				formatGPU = ( colorSpace === SRGBColorSpace ) ? GPUTextureFormat.RGBA8UnormSRGB : GPUTextureFormat.RGBA8Unorm;
				break;

			default:
				console.error( 'WebGPURenderer: Unsupported texture format.', format );

		}

	} else {

		switch ( format ) {

			case RGBAFormat:

				switch ( type ) {

					case ByteType:
						formatGPU = GPUTextureFormat.RGBA8Snorm;
						break;

					case ShortType:
						formatGPU = GPUTextureFormat.RGBA16Sint;
						break;

					case UnsignedShortType:
						formatGPU = GPUTextureFormat.RGBA16Uint;
						break;
					case UnsignedIntType:
						formatGPU = GPUTextureFormat.RGBA32Uint;
						break;

					case IntType:
						formatGPU = GPUTextureFormat.RGBA32Sint;
						break;

					case UnsignedByteType:
						formatGPU = ( colorSpace === SRGBColorSpace ) ? GPUTextureFormat.RGBA8UnormSRGB : GPUTextureFormat.RGBA8Unorm;
						break;

					case HalfFloatType:
						formatGPU = GPUTextureFormat.RGBA16Float;
						break;

					case FloatType:
						formatGPU = GPUTextureFormat.RGBA32Float;
						break;

					default:
						console.error( 'WebGPURenderer: Unsupported texture type with RGBAFormat.', type );

				}

				break;

			case RGBFormat:

				switch ( type ) {

					case UnsignedInt5999Type:
						formatGPU = GPUTextureFormat.RGB9E5UFloat;
						break;

					default:
						console.error( 'WebGPURenderer: Unsupported texture type with RGBFormat.', type );

				}

				break;

			case RedFormat:

				switch ( type ) {

					case ByteType:
						formatGPU = GPUTextureFormat.R8Snorm;
						break;

					case ShortType:
						formatGPU = GPUTextureFormat.R16Sint;
						break;

					case UnsignedShortType:
						formatGPU = GPUTextureFormat.R16Uint;
						break;

					case UnsignedIntType:
						formatGPU = GPUTextureFormat.R32Uint;
						break;

					case IntType:
						formatGPU = GPUTextureFormat.R32Sint;
						break;

					case UnsignedByteType:
						formatGPU = GPUTextureFormat.R8Unorm;
						break;

					case HalfFloatType:
						formatGPU = GPUTextureFormat.R16Float;
						break;

					case FloatType:
						formatGPU = GPUTextureFormat.R32Float;
						break;

					default:
						console.error( 'WebGPURenderer: Unsupported texture type with RedFormat.', type );

				}

				break;

			case RGFormat:

				switch ( type ) {

					case ByteType:
						formatGPU = GPUTextureFormat.RG8Snorm;
						break;

					case ShortType:
						formatGPU = GPUTextureFormat.RG16Sint;
						break;

					case UnsignedShortType:
						formatGPU = GPUTextureFormat.RG16Uint;
						break;

					case UnsignedIntType:
						formatGPU = GPUTextureFormat.RG32Uint;
						break;

					case IntType:
						formatGPU = GPUTextureFormat.RG32Sint;
						break;

					case UnsignedByteType:
						formatGPU = GPUTextureFormat.RG8Unorm;
						break;

					case HalfFloatType:
						formatGPU = GPUTextureFormat.RG16Float;
						break;

					case FloatType:
						formatGPU = GPUTextureFormat.RG32Float;
						break;

					default:
						console.error( 'WebGPURenderer: Unsupported texture type with RGFormat.', type );

				}

				break;

			case DepthFormat:

				switch ( type ) {

					case UnsignedShortType:
						formatGPU = GPUTextureFormat.Depth16Unorm;
						break;

					case UnsignedIntType:
						formatGPU = GPUTextureFormat.Depth24Plus;
						break;

					case FloatType:
						formatGPU = GPUTextureFormat.Depth32Float;
						break;

					default:
						console.error( 'WebGPURenderer: Unsupported texture type with DepthFormat.', type );

				}

				break;

			case DepthStencilFormat:

				switch ( type ) {

					case UnsignedInt248Type:
						formatGPU = GPUTextureFormat.Depth24PlusStencil8;
						break;

					case FloatType:

						if ( device && device.features.has( GPUFeatureName.Depth32FloatStencil8 ) === false ) {

							console.error( 'WebGPURenderer: Depth textures with DepthStencilFormat + FloatType can only be used with the "depth32float-stencil8" GPU feature.' );

						}

						formatGPU = GPUTextureFormat.Depth32FloatStencil8;

						break;

					default:
						console.error( 'WebGPURenderer: Unsupported texture type with DepthStencilFormat.', type );

				}

				break;

			case RedIntegerFormat:

				switch ( type ) {

					case IntType:
						formatGPU = GPUTextureFormat.R32Sint;
						break;

					case UnsignedIntType:
						formatGPU = GPUTextureFormat.R32Uint;
						break;

					default:
						console.error( 'WebGPURenderer: Unsupported texture type with RedIntegerFormat.', type );

				}

				break;

			case RGIntegerFormat:

				switch ( type ) {

					case IntType:
						formatGPU = GPUTextureFormat.RG32Sint;
						break;

					case UnsignedIntType:
						formatGPU = GPUTextureFormat.RG32Uint;
						break;

					default:
						console.error( 'WebGPURenderer: Unsupported texture type with RGIntegerFormat.', type );

				}

				break;

			case RGBAIntegerFormat:

				switch ( type ) {

					case IntType:
						formatGPU = GPUTextureFormat.RGBA32Sint;
						break;

					case UnsignedIntType:
						formatGPU = GPUTextureFormat.RGBA32Uint;
						break;

					default:
						console.error( 'WebGPURenderer: Unsupported texture type with RGBAIntegerFormat.', type );

				}

				break;

			default:
				console.error( 'WebGPURenderer: Unsupported texture format.', format );

		}

	}

	return formatGPU;

}

const declarationRegexp = /^[fn]*\s*([a-z_0-9]+)?\s*\(([\s\S]*?)\)\s*[\-\>]*\s*([a-z_0-9]+(?:<[\s\S]+?>)?)/i;
const propertiesRegexp = /([a-z_0-9]+)\s*:\s*([a-z_0-9]+(?:<[\s\S]+?>)?)/ig;

const wgslTypeLib$1 = {
	'f32': 'float',
	'i32': 'int',
	'u32': 'uint',
	'bool': 'bool',

	'vec2<f32>': 'vec2',
 	'vec2<i32>': 'ivec2',
 	'vec2<u32>': 'uvec2',
 	'vec2<bool>': 'bvec2',

	'vec2f': 'vec2',
	'vec2i': 'ivec2',
	'vec2u': 'uvec2',
	'vec2b': 'bvec2',

	'vec3<f32>': 'vec3',
	'vec3<i32>': 'ivec3',
	'vec3<u32>': 'uvec3',
	'vec3<bool>': 'bvec3',

	'vec3f': 'vec3',
	'vec3i': 'ivec3',
	'vec3u': 'uvec3',
	'vec3b': 'bvec3',

	'vec4<f32>': 'vec4',
	'vec4<i32>': 'ivec4',
	'vec4<u32>': 'uvec4',
	'vec4<bool>': 'bvec4',

	'vec4f': 'vec4',
	'vec4i': 'ivec4',
	'vec4u': 'uvec4',
	'vec4b': 'bvec4',

	'mat2x2<f32>': 'mat2',
	'mat2x2f': 'mat2',

	'mat3x3<f32>': 'mat3',
	'mat3x3f': 'mat3',

	'mat4x4<f32>': 'mat4',
	'mat4x4f': 'mat4',

	'sampler': 'sampler',

	'texture_1d': 'texture',

	'texture_2d': 'texture',
	'texture_2d_array': 'texture',
	'texture_multisampled_2d': 'cubeTexture',

	'texture_depth_2d': 'depthTexture',
	'texture_depth_multisampled_2d': 'depthTexture',

	'texture_3d': 'texture3D',

	'texture_cube': 'cubeTexture',
	'texture_cube_array': 'cubeTexture',

	'texture_storage_1d': 'storageTexture',
	'texture_storage_2d': 'storageTexture',
	'texture_storage_2d_array': 'storageTexture',
	'texture_storage_3d': 'storageTexture'

};

const parse = ( source ) => {

	source = source.trim();

	const declaration = source.match( declarationRegexp );

	if ( declaration !== null && declaration.length === 4 ) {

		const inputsCode = declaration[ 2 ];
		const propsMatches = [];
		let match = null;

		while ( ( match = propertiesRegexp.exec( inputsCode ) ) !== null ) {

			propsMatches.push( { name: match[ 1 ], type: match[ 2 ] } );

		}

		// Process matches to correctly pair names and types
		const inputs = [];
		for ( let i = 0; i < propsMatches.length; i ++ ) {

			const { name, type } = propsMatches[ i ];

			let resolvedType = type;

			if ( resolvedType.startsWith( 'ptr' ) ) {

				resolvedType = 'pointer';

			} else {

				if ( resolvedType.startsWith( 'texture' ) ) {

					resolvedType = type.split( '<' )[ 0 ];

				}

				resolvedType = wgslTypeLib$1[ resolvedType ];

			}

			inputs.push( new NodeFunctionInput( resolvedType, name ) );

		}

		const blockCode = source.substring( declaration[ 0 ].length );
		const outputType = declaration[ 3 ] || 'void';

		const name = declaration[ 1 ] !== undefined ? declaration[ 1 ] : '';
		const type = wgslTypeLib$1[ outputType ] || outputType;

		return {
			type,
			inputs,
			name,
			inputsCode,
			blockCode,
			outputType
		};

	} else {

		throw new Error( 'FunctionNode: Function is not a WGSL code.' );

	}

};

/**
 * This class represents a WSL node function.
 *
 * @augments NodeFunction
 */
class WGSLNodeFunction extends NodeFunction {

	/**
	 * Constructs a new WGSL node function.
	 *
	 * @param {String} source - The WGSL source.
	 */
	constructor( source ) {

		const { type, inputs, name, inputsCode, blockCode, outputType } = parse( source );

		super( type, inputs, name );

		this.inputsCode = inputsCode;
		this.blockCode = blockCode;
		this.outputType = outputType;

	}

	/**
	 * This method returns the WGSL code of the node function.
	 *
	 * @param {String} [name=this.name] - The function's name.
	 * @return {String} The shader code.
	 */
	getCode( name = this.name ) {

		const outputType = this.outputType !== 'void' ? '-> ' + this.outputType : '';

		return `fn ${ name } ( ${ this.inputsCode.trim() } ) ${ outputType }` + this.blockCode;

	}

}

/**
 * A WGSL node parser.
 *
 * @augments NodeParser
 */
class WGSLNodeParser extends NodeParser {

	/**
	 * The method parses the given WGSL code an returns a node function.
	 *
	 * @param {String} source - The WGSL code.
	 * @return {WGSLNodeFunction} A node function.
	 */
	parseFunction( source ) {

		return new WGSLNodeFunction( source );

	}

}

// GPUShaderStage is not defined in browsers not supporting WebGPU
const GPUShaderStage = ( typeof self !== 'undefined' ) ? self.GPUShaderStage : { VERTEX: 1, FRAGMENT: 2, COMPUTE: 4 };

const accessNames = {
	[ NodeAccess.READ_ONLY ]: 'read',
	[ NodeAccess.WRITE_ONLY ]: 'write',
	[ NodeAccess.READ_WRITE ]: 'read_write'
};

const wrapNames = {
	[ RepeatWrapping ]: 'repeat',
	[ ClampToEdgeWrapping ]: 'clamp',
	[ MirroredRepeatWrapping ]: 'mirror'
};

const gpuShaderStageLib = {
	'vertex': GPUShaderStage ? GPUShaderStage.VERTEX : 1,
	'fragment': GPUShaderStage ? GPUShaderStage.FRAGMENT : 2,
	'compute': GPUShaderStage ? GPUShaderStage.COMPUTE : 4
};

const supports = {
	instance: true,
	swizzleAssign: false,
	storageBuffer: true
};

const wgslFnOpLib = {
	'^^': 'tsl_xor'
};

const wgslTypeLib = {
	float: 'f32',
	int: 'i32',
	uint: 'u32',
	bool: 'bool',
	color: 'vec3<f32>',

	vec2: 'vec2<f32>',
	ivec2: 'vec2<i32>',
	uvec2: 'vec2<u32>',
	bvec2: 'vec2<bool>',

	vec3: 'vec3<f32>',
	ivec3: 'vec3<i32>',
	uvec3: 'vec3<u32>',
	bvec3: 'vec3<bool>',

	vec4: 'vec4<f32>',
	ivec4: 'vec4<i32>',
	uvec4: 'vec4<u32>',
	bvec4: 'vec4<bool>',

	mat2: 'mat2x2<f32>',
	mat3: 'mat3x3<f32>',
	mat4: 'mat4x4<f32>'
};

const wgslCodeCache = {};

const wgslPolyfill = {
	tsl_xor: new CodeNode( 'fn tsl_xor( a : bool, b : bool ) -> bool { return ( a || b ) && !( a && b ); }' ),
	mod_float: new CodeNode( 'fn tsl_mod_float( x : f32, y : f32 ) -> f32 { return x - y * floor( x / y ); }' ),
	mod_vec2: new CodeNode( 'fn tsl_mod_vec2( x : vec2f, y : vec2f ) -> vec2f { return x - y * floor( x / y ); }' ),
	mod_vec3: new CodeNode( 'fn tsl_mod_vec3( x : vec3f, y : vec3f ) -> vec3f { return x - y * floor( x / y ); }' ),
	mod_vec4: new CodeNode( 'fn tsl_mod_vec4( x : vec4f, y : vec4f ) -> vec4f { return x - y * floor( x / y ); }' ),
	equals_bool: new CodeNode( 'fn tsl_equals_bool( a : bool, b : bool ) -> bool { return a == b; }' ),
	equals_bvec2: new CodeNode( 'fn tsl_equals_bvec2( a : vec2f, b : vec2f ) -> vec2<bool> { return vec2<bool>( a.x == b.x, a.y == b.y ); }' ),
	equals_bvec3: new CodeNode( 'fn tsl_equals_bvec3( a : vec3f, b : vec3f ) -> vec3<bool> { return vec3<bool>( a.x == b.x, a.y == b.y, a.z == b.z ); }' ),
	equals_bvec4: new CodeNode( 'fn tsl_equals_bvec4( a : vec4f, b : vec4f ) -> vec4<bool> { return vec4<bool>( a.x == b.x, a.y == b.y, a.z == b.z, a.w == b.w ); }' ),
	repeatWrapping_float: new CodeNode( 'fn tsl_repeatWrapping_float( coord: f32 ) -> f32 { return fract( coord ); }' ),
	mirrorWrapping_float: new CodeNode( 'fn tsl_mirrorWrapping_float( coord: f32 ) -> f32 { let mirrored = fract( coord * 0.5 ) * 2.0; return 1.0 - abs( 1.0 - mirrored ); }' ),
	clampWrapping_float: new CodeNode( 'fn tsl_clampWrapping_float( coord: f32 ) -> f32 { return clamp( coord, 0.0, 1.0 ); }' ),
	biquadraticTexture: new CodeNode( /* wgsl */`
fn tsl_biquadraticTexture( map : texture_2d<f32>, coord : vec2f, iRes : vec2u, level : u32 ) -> vec4f {

	let res = vec2f( iRes );

	let uvScaled = coord * res;
	let uvWrapping = ( ( uvScaled % res ) + res ) % res;

	// https://www.shadertoy.com/view/WtyXRy

	let uv = uvWrapping - 0.5;
	let iuv = floor( uv );
	let f = fract( uv );

	let rg1 = textureLoad( map, vec2u( iuv + vec2( 0.5, 0.5 ) ) % iRes, level );
	let rg2 = textureLoad( map, vec2u( iuv + vec2( 1.5, 0.5 ) ) % iRes, level );
	let rg3 = textureLoad( map, vec2u( iuv + vec2( 0.5, 1.5 ) ) % iRes, level );
	let rg4 = textureLoad( map, vec2u( iuv + vec2( 1.5, 1.5 ) ) % iRes, level );

	return mix( mix( rg1, rg2, f.x ), mix( rg3, rg4, f.x ), f.y );

}
` )
};

const wgslMethods = {
	dFdx: 'dpdx',
	dFdy: '- dpdy',
	mod_float: 'tsl_mod_float',
	mod_vec2: 'tsl_mod_vec2',
	mod_vec3: 'tsl_mod_vec3',
	mod_vec4: 'tsl_mod_vec4',
	equals_bool: 'tsl_equals_bool',
	equals_bvec2: 'tsl_equals_bvec2',
	equals_bvec3: 'tsl_equals_bvec3',
	equals_bvec4: 'tsl_equals_bvec4',
	inversesqrt: 'inverseSqrt',
	bitcast: 'bitcast<f32>'
};

// WebGPU issue: does not support pow() with negative base on Windows

if ( typeof navigator !== 'undefined' && /Windows/g.test( navigator.userAgent ) ) {

	wgslPolyfill.pow_float = new CodeNode( 'fn tsl_pow_float( a : f32, b : f32 ) -> f32 { return select( -pow( -a, b ), pow( a, b ), a > 0.0 ); }' );
	wgslPolyfill.pow_vec2 = new CodeNode( 'fn tsl_pow_vec2( a : vec2f, b : vec2f ) -> vec2f { return vec2f( tsl_pow_float( a.x, b.x ), tsl_pow_float( a.y, b.y ) ); }', [ wgslPolyfill.pow_float ] );
	wgslPolyfill.pow_vec3 = new CodeNode( 'fn tsl_pow_vec3( a : vec3f, b : vec3f ) -> vec3f { return vec3f( tsl_pow_float( a.x, b.x ), tsl_pow_float( a.y, b.y ), tsl_pow_float( a.z, b.z ) ); }', [ wgslPolyfill.pow_float ] );
	wgslPolyfill.pow_vec4 = new CodeNode( 'fn tsl_pow_vec4( a : vec4f, b : vec4f ) -> vec4f { return vec4f( tsl_pow_float( a.x, b.x ), tsl_pow_float( a.y, b.y ), tsl_pow_float( a.z, b.z ), tsl_pow_float( a.w, b.w ) ); }', [ wgslPolyfill.pow_float ] );

	wgslMethods.pow_float = 'tsl_pow_float';
	wgslMethods.pow_vec2 = 'tsl_pow_vec2';
	wgslMethods.pow_vec3 = 'tsl_pow_vec3';
	wgslMethods.pow_vec4 = 'tsl_pow_vec4';

}

//

let diagnostics = '';

if ( ( typeof navigator !== 'undefined' && /Firefox|Deno/g.test( navigator.userAgent ) ) !== true ) {

	diagnostics += 'diagnostic( off, derivative_uniformity );\n';

}

//

class WGSLNodeBuilder extends NodeBuilder {

	constructor( object, renderer ) {

		super( object, renderer, new WGSLNodeParser() );

		this.uniformGroups = {};

		this.builtins = {};

		this.directives = {};

		this.scopedArrays = new Map();

	}

	needsToWorkingColorSpace( texture ) {

		return texture.isVideoTexture === true && texture.colorSpace !== NoColorSpace;

	}

	_generateTextureSample( texture, textureProperty, uvSnippet, depthSnippet, shaderStage = this.shaderStage ) {

		if ( shaderStage === 'fragment' ) {

			if ( depthSnippet ) {

				return `textureSample( ${ textureProperty }, ${ textureProperty }_sampler, ${ uvSnippet }, ${ depthSnippet } )`;

			} else {

				return `textureSample( ${ textureProperty }, ${ textureProperty }_sampler, ${ uvSnippet } )`;

			}

		} else if ( this.isFilteredTexture( texture ) ) {

			return this.generateFilteredTexture( texture, textureProperty, uvSnippet );

		} else {

			return this.generateTextureLod( texture, textureProperty, uvSnippet, depthSnippet, '0' );

		}

	}

	_generateVideoSample( textureProperty, uvSnippet, shaderStage = this.shaderStage ) {

		if ( shaderStage === 'fragment' ) {

			return `textureSampleBaseClampToEdge( ${ textureProperty }, ${ textureProperty }_sampler, vec2<f32>( ${ uvSnippet }.x, 1.0 - ${ uvSnippet }.y ) )`;

		} else {

			console.error( `WebGPURenderer: THREE.VideoTexture does not support ${ shaderStage } shader.` );

		}

	}

	_generateTextureSampleLevel( texture, textureProperty, uvSnippet, levelSnippet, depthSnippet, shaderStage = this.shaderStage ) {

		if ( ( shaderStage === 'fragment' || shaderStage === 'compute' ) && this.isUnfilterable( texture ) === false ) {

			return `textureSampleLevel( ${ textureProperty }, ${ textureProperty }_sampler, ${ uvSnippet }, ${ levelSnippet } )`;

		} else if ( this.isFilteredTexture( texture ) ) {

			return this.generateFilteredTexture( texture, textureProperty, uvSnippet, levelSnippet );

		} else {

			return this.generateTextureLod( texture, textureProperty, uvSnippet, depthSnippet, levelSnippet );

		}

	}

	generateWrapFunction( texture ) {

		const functionName = `tsl_coord_${ wrapNames[ texture.wrapS ] }S_${ wrapNames[ texture.wrapT ] }T`;

		let nodeCode = wgslCodeCache[ functionName ];

		if ( nodeCode === undefined ) {

			const includes = [];

			let code = `fn ${ functionName }( coord : vec2f ) -> vec2f {\n\n\treturn vec2f(\n`;

			const addWrapSnippet = ( wrap, axis ) => {

				if ( wrap === RepeatWrapping ) {

					includes.push( wgslPolyfill.repeatWrapping_float );

					code += `\t\ttsl_repeatWrapping_float( coord.${ axis } )`;

				} else if ( wrap === ClampToEdgeWrapping ) {

					includes.push( wgslPolyfill.clampWrapping_float );

					code += `\t\ttsl_clampWrapping_float( coord.${ axis } )`;

				} else if ( wrap === MirroredRepeatWrapping ) {

					includes.push( wgslPolyfill.mirrorWrapping_float );

					code += `\t\ttsl_mirrorWrapping_float( coord.${ axis } )`;

				} else {

					code += `\t\tcoord.${ axis }`;

					console.warn( `WebGPURenderer: Unsupported texture wrap type "${ wrap }" for vertex shader.` );

				}

			};

			addWrapSnippet( texture.wrapS, 'x' );

			code += ',\n';

			addWrapSnippet( texture.wrapT, 'y' );

			code += '\n\t);\n\n}\n';

			wgslCodeCache[ functionName ] = nodeCode = new CodeNode( code, includes );

		}

		nodeCode.build( this );

		return functionName;

	}

	generateTextureDimension( texture, textureProperty, levelSnippet ) {

		const textureData = this.getDataFromNode( texture, this.shaderStage, this.globalCache );

		if ( textureData.dimensionsSnippet === undefined ) textureData.dimensionsSnippet = {};

		let textureDimensionNode = textureData.dimensionsSnippet[ levelSnippet ];

		if ( textureData.dimensionsSnippet[ levelSnippet ] === undefined ) {

			let textureDimensionsParams;

			const { primarySamples } = this.renderer.backend.utils.getTextureSampleData( texture );

			if ( primarySamples > 1 ) {

				textureDimensionsParams = textureProperty;

			} else {

				textureDimensionsParams = `${ textureProperty }, u32( ${ levelSnippet } )`;

			}

			textureDimensionNode = new VarNode( new ExpressionNode( `textureDimensions( ${ textureDimensionsParams } )`, 'uvec2' ) );

			textureData.dimensionsSnippet[ levelSnippet ] = textureDimensionNode;

		}

		return textureDimensionNode.build( this );

	}

	generateFilteredTexture( texture, textureProperty, uvSnippet, levelSnippet = '0u' ) {

		this._include( 'biquadraticTexture' );

		const wrapFunction = this.generateWrapFunction( texture );
		const textureDimension = this.generateTextureDimension( texture, textureProperty, levelSnippet );

		return `tsl_biquadraticTexture( ${ textureProperty }, ${ wrapFunction }( ${ uvSnippet } ), ${ textureDimension }, u32( ${ levelSnippet } ) )`;

	}

	generateTextureLod( texture, textureProperty, uvSnippet, depthSnippet, levelSnippet = '0u' ) {

		const wrapFunction = this.generateWrapFunction( texture );
		const textureDimension = this.generateTextureDimension( texture, textureProperty, levelSnippet );

		const coordSnippet = `vec2u( ${ wrapFunction }( ${ uvSnippet } ) * vec2f( ${ textureDimension } ) )`;

		return this.generateTextureLoad( texture, textureProperty, coordSnippet, depthSnippet, levelSnippet );

	}

	generateTextureLoad( texture, textureProperty, uvIndexSnippet, depthSnippet, levelSnippet = '0u' ) {

		if ( texture.isVideoTexture === true || texture.isStorageTexture === true ) {

			return `textureLoad( ${ textureProperty }, ${ uvIndexSnippet } )`;

		} else if ( depthSnippet ) {

			return `textureLoad( ${ textureProperty }, ${ uvIndexSnippet }, ${ depthSnippet }, u32( ${ levelSnippet } ) )`;

		} else {

			return `textureLoad( ${ textureProperty }, ${ uvIndexSnippet }, u32( ${ levelSnippet } ) )`;

		}

	}

	generateTextureStore( texture, textureProperty, uvIndexSnippet, valueSnippet ) {

		return `textureStore( ${ textureProperty }, ${ uvIndexSnippet }, ${ valueSnippet } )`;

	}

	isSampleCompare( texture ) {

		return texture.isDepthTexture === true && texture.compareFunction !== null;

	}

	isUnfilterable( texture ) {

		return this.getComponentTypeFromTexture( texture ) !== 'float' ||
			( ! this.isAvailable( 'float32Filterable' ) && texture.isDataTexture === true && texture.type === FloatType ) ||
			( this.isSampleCompare( texture ) === false && texture.minFilter === NearestFilter && texture.magFilter === NearestFilter ) ||
			this.renderer.backend.utils.getTextureSampleData( texture ).primarySamples > 1;

	}

	generateTexture( texture, textureProperty, uvSnippet, depthSnippet, shaderStage = this.shaderStage ) {

		let snippet = null;

		if ( texture.isVideoTexture === true ) {

			snippet = this._generateVideoSample( textureProperty, uvSnippet, shaderStage );

		} else if ( this.isUnfilterable( texture ) ) {

			snippet = this.generateTextureLod( texture, textureProperty, uvSnippet, depthSnippet, '0', shaderStage );

		} else {

			snippet = this._generateTextureSample( texture, textureProperty, uvSnippet, depthSnippet, shaderStage );

		}

		return snippet;

	}

	generateTextureGrad( texture, textureProperty, uvSnippet, gradSnippet, depthSnippet, shaderStage = this.shaderStage ) {

		if ( shaderStage === 'fragment' ) {

			// TODO handle i32 or u32 --> uvSnippet, array_index: A, ddx, ddy
			return `textureSampleGrad( ${ textureProperty }, ${ textureProperty }_sampler, ${ uvSnippet },  ${ gradSnippet[ 0 ] }, ${ gradSnippet[ 1 ] } )`;

		} else {

			console.error( `WebGPURenderer: THREE.TextureNode.gradient() does not support ${ shaderStage } shader.` );

		}

	}

	generateTextureCompare( texture, textureProperty, uvSnippet, compareSnippet, depthSnippet, shaderStage = this.shaderStage ) {

		if ( shaderStage === 'fragment' ) {

			return `textureSampleCompare( ${ textureProperty }, ${ textureProperty }_sampler, ${ uvSnippet }, ${ compareSnippet } )`;

		} else {

			console.error( `WebGPURenderer: THREE.DepthTexture.compareFunction() does not support ${ shaderStage } shader.` );

		}

	}

	generateTextureLevel( texture, textureProperty, uvSnippet, levelSnippet, depthSnippet, shaderStage = this.shaderStage ) {

		let snippet = null;

		if ( texture.isVideoTexture === true ) {

			snippet = this._generateVideoSample( textureProperty, uvSnippet, shaderStage );

		} else {

			snippet = this._generateTextureSampleLevel( texture, textureProperty, uvSnippet, levelSnippet, depthSnippet, shaderStage );

		}

		return snippet;

	}

	generateTextureBias( texture, textureProperty, uvSnippet, biasSnippet, depthSnippet, shaderStage = this.shaderStage ) {

		if ( shaderStage === 'fragment' ) {

			return `textureSampleBias( ${ textureProperty }, ${ textureProperty }_sampler, ${ uvSnippet }, ${ biasSnippet } )`;

		} else {

			console.error( `WebGPURenderer: THREE.TextureNode.biasNode does not support ${ shaderStage } shader.` );

		}

	}

	getPropertyName( node, shaderStage = this.shaderStage ) {

		if ( node.isNodeVarying === true && node.needsInterpolation === true ) {

			if ( shaderStage === 'vertex' ) {

				return `varyings.${ node.name }`;

			}

		} else if ( node.isNodeUniform === true ) {

			const name = node.name;
			const type = node.type;

			if ( type === 'texture' || type === 'cubeTexture' || type === 'storageTexture' || type === 'texture3D' ) {

				return name;

			} else if ( type === 'buffer' || type === 'storageBuffer' || type === 'indirectStorageBuffer' ) {

				return `NodeBuffer_${ node.id }.${name}`;

			} else {

				return node.groupNode.name + '.' + name;

			}

		}

		return super.getPropertyName( node );

	}

	getOutputStructName() {

		return 'output';

	}

	_getUniformGroupCount( shaderStage ) {

		return Object.keys( this.uniforms[ shaderStage ] ).length;

	}

	getFunctionOperator( op ) {

		const fnOp = wgslFnOpLib[ op ];

		if ( fnOp !== undefined ) {

			this._include( fnOp );

			return fnOp;

		}

		return null;

	}

	getNodeAccess( node, shaderStage ) {

		if ( shaderStage !== 'compute' )
			return NodeAccess.READ_ONLY;

		return node.access;

	}

	getStorageAccess( node, shaderStage ) {

		return accessNames[ this.getNodeAccess( node, shaderStage ) ];

	}

	getUniformFromNode( node, type, shaderStage, name = null ) {

		const uniformNode = super.getUniformFromNode( node, type, shaderStage, name );
		const nodeData = this.getDataFromNode( node, shaderStage, this.globalCache );

		if ( nodeData.uniformGPU === undefined ) {

			let uniformGPU;

			const group = node.groupNode;
			const groupName = group.name;

			const bindings = this.getBindGroupArray( groupName, shaderStage );

			if ( type === 'texture' || type === 'cubeTexture' || type === 'storageTexture' || type === 'texture3D' ) {

				let texture = null;

				const access = this.getNodeAccess( node, shaderStage );

				if ( type === 'texture' || type === 'storageTexture' ) {

					texture = new NodeSampledTexture( uniformNode.name, uniformNode.node, group, access );

				} else if ( type === 'cubeTexture' ) {

					texture = new NodeSampledCubeTexture( uniformNode.name, uniformNode.node, group, access );

				} else if ( type === 'texture3D' ) {

					texture = new NodeSampledTexture3D( uniformNode.name, uniformNode.node, group, access );

				}

				texture.store = node.isStorageTextureNode === true;
				texture.setVisibility( gpuShaderStageLib[ shaderStage ] );

				if ( ( shaderStage === 'fragment' || shaderStage === 'compute' ) && this.isUnfilterable( node.value ) === false && texture.store === false ) {

					const sampler = new NodeSampler( `${uniformNode.name}_sampler`, uniformNode.node, group );
					sampler.setVisibility( gpuShaderStageLib[ shaderStage ] );

					bindings.push( sampler, texture );

					uniformGPU = [ sampler, texture ];

				} else {

					bindings.push( texture );

					uniformGPU = [ texture ];

				}

			} else if ( type === 'buffer' || type === 'storageBuffer' || type === 'indirectStorageBuffer' ) {

				const bufferClass = type === 'buffer' ? NodeUniformBuffer : NodeStorageBuffer;

				const buffer = new bufferClass( node, group );
				buffer.setVisibility( gpuShaderStageLib[ shaderStage ] );

				bindings.push( buffer );

				uniformGPU = buffer;

			} else {

				const uniformsStage = this.uniformGroups[ shaderStage ] || ( this.uniformGroups[ shaderStage ] = {} );

				let uniformsGroup = uniformsStage[ groupName ];

				if ( uniformsGroup === undefined ) {

					uniformsGroup = new NodeUniformsGroup( groupName, group );
					uniformsGroup.setVisibility( gpuShaderStageLib[ shaderStage ] );

					uniformsStage[ groupName ] = uniformsGroup;

					bindings.push( uniformsGroup );

				}

				uniformGPU = this.getNodeUniform( uniformNode, type );

				uniformsGroup.addUniform( uniformGPU );

			}

			nodeData.uniformGPU = uniformGPU;

		}

		return uniformNode;

	}

	getBuiltin( name, property, type, shaderStage = this.shaderStage ) {

		const map = this.builtins[ shaderStage ] || ( this.builtins[ shaderStage ] = new Map() );

		if ( map.has( name ) === false ) {

			map.set( name, {
				name,
				property,
				type
			} );

		}

		return property;

	}

	hasBuiltin( name, shaderStage = this.shaderStage ) {

		return ( this.builtins[ shaderStage ] !== undefined && this.builtins[ shaderStage ].has( name ) );

	}

	getVertexIndex() {

		if ( this.shaderStage === 'vertex' ) {

			return this.getBuiltin( 'vertex_index', 'vertexIndex', 'u32', 'attribute' );

		}

		return 'vertexIndex';

	}

	buildFunctionCode( shaderNode ) {

		const layout = shaderNode.layout;
		const flowData = this.flowShaderNode( shaderNode );

		const parameters = [];

		for ( const input of layout.inputs ) {

			parameters.push( input.name + ' : ' + this.getType( input.type ) );

		}

		//

		let code = `fn ${ layout.name }( ${ parameters.join( ', ' ) } ) -> ${ this.getType( layout.type ) } {
${ flowData.vars }
${ flowData.code }
`;

		if ( flowData.result ) {

			code += `\treturn ${ flowData.result };\n`;

		}

		code += '\n}\n';

		//

		return code;

	}

	getInstanceIndex() {

		if ( this.shaderStage === 'vertex' ) {

			return this.getBuiltin( 'instance_index', 'instanceIndex', 'u32', 'attribute' );

		}

		return 'instanceIndex';

	}

	getInvocationLocalIndex() {

		return this.getBuiltin( 'local_invocation_index', 'invocationLocalIndex', 'u32', 'attribute' );

	}

	getSubgroupSize() {

		this.enableSubGroups();

		return this.getBuiltin( 'subgroup_size', 'subgroupSize', 'u32', 'attribute' );

	}

	getInvocationSubgroupIndex() {

		this.enableSubGroups();

		return this.getBuiltin( 'subgroup_invocation_id', 'invocationSubgroupIndex', 'u32', 'attribute' );

	}

	getSubgroupIndex() {

		this.enableSubGroups();

		return this.getBuiltin( 'subgroup_id', 'subgroupIndex', 'u32', 'attribute' );

	}

	getDrawIndex() {

		return null;

	}

	getFrontFacing() {

		return this.getBuiltin( 'front_facing', 'isFront', 'bool' );

	}

	getFragCoord() {

		return this.getBuiltin( 'position', 'fragCoord', 'vec4<f32>' ) + '.xy';

	}

	getFragDepth() {

		return 'output.' + this.getBuiltin( 'frag_depth', 'depth', 'f32', 'output' );

	}

	getClipDistance() {

		return 'varyings.hw_clip_distances';

	}

	isFlipY() {

		return false;

	}

	enableDirective( name, shaderStage = this.shaderStage ) {

		const stage = this.directives[ shaderStage ] || ( this.directives[ shaderStage ] = new Set() );
		stage.add( name );

	}

	getDirectives( shaderStage ) {

		const snippets = [];
		const directives = this.directives[ shaderStage ];

		if ( directives !== undefined ) {

			for ( const directive of directives ) {

				snippets.push( `enable ${directive};` );

			}

		}

		return snippets.join( '\n' );

	}

	enableSubGroups() {

		this.enableDirective( 'subgroups' );

	}

	enableSubgroupsF16() {

		this.enableDirective( 'subgroups-f16' );

	}

	enableClipDistances() {

		this.enableDirective( 'clip_distances' );

	}

	enableShaderF16() {

		this.enableDirective( 'f16' );

	}

	enableDualSourceBlending() {

		this.enableDirective( 'dual_source_blending' );

	}

	enableHardwareClipping( planeCount ) {

		this.enableClipDistances();
		this.getBuiltin( 'clip_distances', 'hw_clip_distances', `array<f32, ${ planeCount } >`, 'vertex' );

	}

	getBuiltins( shaderStage ) {

		const snippets = [];
		const builtins = this.builtins[ shaderStage ];

		if ( builtins !== undefined ) {

			for ( const { name, property, type } of builtins.values() ) {

				snippets.push( `@builtin( ${name} ) ${property} : ${type}` );

			}

		}

		return snippets.join( ',\n\t' );

	}

	getScopedArray( name, scope, bufferType, bufferCount ) {

		if ( this.scopedArrays.has( name ) === false ) {

			this.scopedArrays.set( name, {
				name,
				scope,
				bufferType,
				bufferCount
			} );

		}

		return name;

	}

	getScopedArrays( shaderStage ) {

		if ( shaderStage !== 'compute' ) {

			return;

		}

		const snippets = [];

		for ( const { name, scope, bufferType, bufferCount } of this.scopedArrays.values() ) {

			const type = this.getType( bufferType );

			snippets.push( `var<${scope}> ${name}: array< ${type}, ${bufferCount} >;` );

		}

		return snippets.join( '\n' );

	}

	getAttributes( shaderStage ) {

		const snippets = [];

		if ( shaderStage === 'compute' ) {

			this.getBuiltin( 'global_invocation_id', 'id', 'vec3<u32>', 'attribute' );
			this.getBuiltin( 'workgroup_id', 'workgroupId', 'vec3<u32>', 'attribute' );
			this.getBuiltin( 'local_invocation_id', 'localId', 'vec3<u32>', 'attribute' );
			this.getBuiltin( 'num_workgroups', 'numWorkgroups', 'vec3<u32>', 'attribute' );

			if ( this.renderer.hasFeature( 'subgroups' ) ) {

				this.enableDirective( 'subgroups', shaderStage );
				this.getBuiltin( 'subgroup_size', 'subgroupSize', 'u32', 'attribute' );

			}

		}

		if ( shaderStage === 'vertex' || shaderStage === 'compute' ) {

			const builtins = this.getBuiltins( 'attribute' );

			if ( builtins ) snippets.push( builtins );

			const attributes = this.getAttributesArray();

			for ( let index = 0, length = attributes.length; index < length; index ++ ) {

				const attribute = attributes[ index ];
				const name = attribute.name;
				const type = this.getType( attribute.type );

				snippets.push( `@location( ${index} ) ${ name } : ${ type }` );

			}

		}

		return snippets.join( ',\n\t' );

	}

	getStructMembers( struct ) {

		const snippets = [];
		const members = struct.getMemberTypes();

		for ( let i = 0; i < members.length; i ++ ) {

			const member = members[ i ];
			snippets.push( `\t@location( ${i} ) m${i} : ${ member }<f32>` );

		}

		const builtins = this.getBuiltins( 'output' );

		if ( builtins ) snippets.push( '\t' + builtins );

		return snippets.join( ',\n' );

	}

	getStructs( shaderStage ) {

		const snippets = [];
		const structs = this.structs[ shaderStage ];

		for ( let index = 0, length = structs.length; index < length; index ++ ) {

			const struct = structs[ index ];
			const name = struct.name;

			let snippet = `\struct ${ name } {\n`;
			snippet += this.getStructMembers( struct );
			snippet += '\n}';


			snippets.push( snippet );

			snippets.push( `\nvar<private> output : ${ name };\n\n` );

		}

		return snippets.join( '\n\n' );

	}

	getVar( type, name ) {

		return `var ${ name } : ${ this.getType( type ) }`;

	}

	getVars( shaderStage ) {

		const snippets = [];
		const vars = this.vars[ shaderStage ];

		if ( vars !== undefined ) {

			for ( const variable of vars ) {

				snippets.push( `\t${ this.getVar( variable.type, variable.name ) };` );

			}

		}

		return `\n${ snippets.join( '\n' ) }\n`;

	}

	getVaryings( shaderStage ) {

		const snippets = [];

		if ( shaderStage === 'vertex' ) {

			this.getBuiltin( 'position', 'Vertex', 'vec4<f32>', 'vertex' );

		}

		if ( shaderStage === 'vertex' || shaderStage === 'fragment' ) {

			const varyings = this.varyings;
			const vars = this.vars[ shaderStage ];

			for ( let index = 0; index < varyings.length; index ++ ) {

				const varying = varyings[ index ];

				if ( varying.needsInterpolation ) {

					let attributesSnippet = `@location( ${index} )`;

					if ( /^(int|uint|ivec|uvec)/.test( varying.type ) ) {

						attributesSnippet += ' @interpolate( flat )';


					}

					snippets.push( `${ attributesSnippet } ${ varying.name } : ${ this.getType( varying.type ) }` );

				} else if ( shaderStage === 'vertex' && vars.includes( varying ) === false ) {

					vars.push( varying );

				}

			}

		}

		const builtins = this.getBuiltins( shaderStage );

		if ( builtins ) snippets.push( builtins );

		const code = snippets.join( ',\n\t' );

		return shaderStage === 'vertex' ? this._getWGSLStruct( 'VaryingsStruct', '\t' + code ) : code;

	}

	getUniforms( shaderStage ) {

		const uniforms = this.uniforms[ shaderStage ];

		const bindingSnippets = [];
		const bufferSnippets = [];
		const structSnippets = [];
		const uniformGroups = {};

		for ( const uniform of uniforms ) {

			const groupName = uniform.groupNode.name;
			const uniformIndexes = this.bindingsIndexes[ groupName ];

			if ( uniform.type === 'texture' || uniform.type === 'cubeTexture' || uniform.type === 'storageTexture' || uniform.type === 'texture3D' ) {

				const texture = uniform.node.value;

				if ( ( shaderStage === 'fragment' || shaderStage === 'compute' ) && this.isUnfilterable( texture ) === false && uniform.node.isStorageTextureNode !== true ) {

					if ( this.isSampleCompare( texture ) ) {

						bindingSnippets.push( `@binding( ${ uniformIndexes.binding ++ } ) @group( ${ uniformIndexes.group } ) var ${ uniform.name }_sampler : sampler_comparison;` );

					} else {

						bindingSnippets.push( `@binding( ${ uniformIndexes.binding ++ } ) @group( ${ uniformIndexes.group } ) var ${ uniform.name }_sampler : sampler;` );

					}

				}

				let textureType;

				let multisampled = '';

				const { primarySamples } = this.renderer.backend.utils.getTextureSampleData( texture );

				if ( primarySamples > 1 ) {

					multisampled = '_multisampled';

				}

				if ( texture.isCubeTexture === true ) {

					textureType = 'texture_cube<f32>';

				} else if ( texture.isDataArrayTexture === true || texture.isCompressedArrayTexture === true ) {

					textureType = 'texture_2d_array<f32>';

				} else if ( texture.isDepthTexture === true ) {

					textureType = `texture_depth${multisampled}_2d`;

				} else if ( texture.isVideoTexture === true ) {

					textureType = 'texture_external';

				} else if ( texture.isData3DTexture === true ) {

					textureType = 'texture_3d<f32>';

				} else if ( uniform.node.isStorageTextureNode === true ) {

					const format = getFormat( texture );
					const access = this.getStorageAccess( uniform.node, shaderStage );

					textureType = `texture_storage_2d<${ format }, ${ access }>`;

				} else {

					const componentPrefix = this.getComponentTypeFromTexture( texture ).charAt( 0 );

					textureType = `texture${multisampled}_2d<${ componentPrefix }32>`;

				}

				bindingSnippets.push( `@binding( ${ uniformIndexes.binding ++ } ) @group( ${ uniformIndexes.group } ) var ${ uniform.name } : ${ textureType };` );

			} else if ( uniform.type === 'buffer' || uniform.type === 'storageBuffer' || uniform.type === 'indirectStorageBuffer' ) {

				const bufferNode = uniform.node;
				const bufferType = this.getType( bufferNode.bufferType );
				const bufferCount = bufferNode.bufferCount;

				const bufferCountSnippet = bufferCount > 0 && uniform.type === 'buffer' ? ', ' + bufferCount : '';
				const bufferTypeSnippet = bufferNode.isAtomic ? `atomic<${bufferType}>` : `${bufferType}`;
				const bufferSnippet = `\t${ uniform.name } : array< ${ bufferTypeSnippet }${ bufferCountSnippet } >\n`;
				const bufferAccessMode = bufferNode.isStorageBufferNode ? `storage, ${ this.getStorageAccess( bufferNode, shaderStage ) }` : 'uniform';

				bufferSnippets.push( this._getWGSLStructBinding( 'NodeBuffer_' + bufferNode.id, bufferSnippet, bufferAccessMode, uniformIndexes.binding ++, uniformIndexes.group ) );

			} else {

				const vectorType = this.getType( this.getVectorType( uniform.type ) );
				const groupName = uniform.groupNode.name;

				const group = uniformGroups[ groupName ] || ( uniformGroups[ groupName ] = {
					index: uniformIndexes.binding ++,
					id: uniformIndexes.group,
					snippets: []
				} );

				group.snippets.push( `\t${ uniform.name } : ${ vectorType }` );

			}

		}

		for ( const name in uniformGroups ) {

			const group = uniformGroups[ name ];

			structSnippets.push( this._getWGSLStructBinding( name, group.snippets.join( ',\n' ), 'uniform', group.index, group.id ) );

		}

		let code = bindingSnippets.join( '\n' );
		code += bufferSnippets.join( '\n' );
		code += structSnippets.join( '\n' );

		return code;

	}

	buildCode() {

		const shadersData = this.material !== null ? { fragment: {}, vertex: {} } : { compute: {} };

		this.sortBindingGroups();

		for ( const shaderStage in shadersData ) {

			const stageData = shadersData[ shaderStage ];
			stageData.uniforms = this.getUniforms( shaderStage );
			stageData.attributes = this.getAttributes( shaderStage );
			stageData.varyings = this.getVaryings( shaderStage );
			stageData.structs = this.getStructs( shaderStage );
			stageData.vars = this.getVars( shaderStage );
			stageData.codes = this.getCodes( shaderStage );
			stageData.directives = this.getDirectives( shaderStage );
			stageData.scopedArrays = this.getScopedArrays( shaderStage );

			//

			let flow = '// code\n\n';
			flow += this.flowCode[ shaderStage ];

			const flowNodes = this.flowNodes[ shaderStage ];
			const mainNode = flowNodes[ flowNodes.length - 1 ];

			const outputNode = mainNode.outputNode;
			const isOutputStruct = ( outputNode !== undefined && outputNode.isOutputStructNode === true );

			for ( const node of flowNodes ) {

				const flowSlotData = this.getFlowData( node/*, shaderStage*/ );
				const slotName = node.name;

				if ( slotName ) {

					if ( flow.length > 0 ) flow += '\n';

					flow += `\t// flow -> ${ slotName }\n\t`;

				}

				flow += `${ flowSlotData.code }\n\t`;

				if ( node === mainNode && shaderStage !== 'compute' ) {

					flow += '// result\n\n\t';

					if ( shaderStage === 'vertex' ) {

						flow += `varyings.Vertex = ${ flowSlotData.result };`;

					} else if ( shaderStage === 'fragment' ) {

						if ( isOutputStruct ) {

							stageData.returnType = outputNode.nodeType;

							flow += `return ${ flowSlotData.result };`;

						} else {

							let structSnippet = '\t@location(0) color: vec4<f32>';

							const builtins = this.getBuiltins( 'output' );

							if ( builtins ) structSnippet += ',\n\t' + builtins;

							stageData.returnType = 'OutputStruct';
							stageData.structs += this._getWGSLStruct( 'OutputStruct', structSnippet );
							stageData.structs += '\nvar<private> output : OutputStruct;\n\n';

							flow += `output.color = ${ flowSlotData.result };\n\n\treturn output;`;

						}

					}

				}

			}

			stageData.flow = flow;


		}

		if ( this.material !== null ) {

			this.vertexShader = this._getWGSLVertexCode( shadersData.vertex );
			this.fragmentShader = this._getWGSLFragmentCode( shadersData.fragment );

		} else {

			this.computeShader = this._getWGSLComputeCode( shadersData.compute, ( this.object.workgroupSize || [ 64 ] ).join( ', ' ) );

		}

	}

	getMethod( method, output = null ) {

		let wgslMethod;

		if ( output !== null ) {

			wgslMethod = this._getWGSLMethod( method + '_' + output );

		}

		if ( wgslMethod === undefined ) {

			wgslMethod = this._getWGSLMethod( method );

		}

		return wgslMethod || method;

	}

	getType( type ) {

		return wgslTypeLib[ type ] || type;

	}

	isAvailable( name ) {

		let result = supports[ name ];

		if ( result === undefined ) {

			if ( name === 'float32Filterable' ) {

				result = this.renderer.hasFeature( 'float32-filterable' );

			} else if ( name === 'clipDistance' ) {

				result = this.renderer.hasFeature( 'clip-distances' );

			}

			supports[ name ] = result;

		}

		return result;

	}

	_getWGSLMethod( method ) {

		if ( wgslPolyfill[ method ] !== undefined ) {

			this._include( method );

		}

		return wgslMethods[ method ];

	}

	_include( name ) {

		const codeNode = wgslPolyfill[ name ];
		codeNode.build( this );

		if ( this.currentFunctionNode !== null ) {

			this.currentFunctionNode.includes.push( codeNode );

		}

		return codeNode;

	}

	_getWGSLVertexCode( shaderData ) {

		return `${ this.getSignature() }
// directives
${shaderData.directives}

// uniforms
${shaderData.uniforms}

// varyings
${shaderData.varyings}
var<private> varyings : VaryingsStruct;

// codes
${shaderData.codes}

@vertex
fn main( ${shaderData.attributes} ) -> VaryingsStruct {

	// vars
	${shaderData.vars}

	// flow
	${shaderData.flow}

	return varyings;

}
`;

	}

	_getWGSLFragmentCode( shaderData ) {

		return `${ this.getSignature() }
// global
${ diagnostics }

// uniforms
${shaderData.uniforms}

// structs
${shaderData.structs}

// codes
${shaderData.codes}

@fragment
fn main( ${shaderData.varyings} ) -> ${shaderData.returnType} {

	// vars
	${shaderData.vars}

	// flow
	${shaderData.flow}

}
`;

	}

	_getWGSLComputeCode( shaderData, workgroupSize ) {

		return `${ this.getSignature() }
// directives
${shaderData.directives}

// system
var<private> instanceIndex : u32;

// locals
${shaderData.scopedArrays}

// uniforms
${shaderData.uniforms}

// codes
${shaderData.codes}

@compute @workgroup_size( ${workgroupSize} )
fn main( ${shaderData.attributes} ) {

	// system
	instanceIndex = id.x + id.y * numWorkgroups.x * u32(${workgroupSize}) + id.z * numWorkgroups.x * numWorkgroups.y * u32(${workgroupSize});

	// vars
	${shaderData.vars}

	// flow
	${shaderData.flow}

}
`;

	}

	_getWGSLStruct( name, vars ) {

		return `
struct ${name} {
${vars}
};`;

	}

	_getWGSLStructBinding( name, vars, access, binding = 0, group = 0 ) {

		const structName = name + 'Struct';
		const structSnippet = this._getWGSLStruct( structName, vars );

		return `${structSnippet}
@binding( ${binding} ) @group( ${group} )
var<${access}> ${name} : ${structName};`;

	}

}

class WebGPUUtils {

	constructor( backend ) {

		this.backend = backend;

	}

	getCurrentDepthStencilFormat( renderContext ) {

		let format;

		if ( renderContext.depthTexture !== null ) {

			format = this.getTextureFormatGPU( renderContext.depthTexture );

		} else if ( renderContext.depth && renderContext.stencil ) {

			format = GPUTextureFormat.Depth24PlusStencil8;

		} else if ( renderContext.depth ) {

			format = GPUTextureFormat.Depth24Plus;

		}

		return format;

	}

	getTextureFormatGPU( texture ) {

		return this.backend.get( texture ).format;

	}

	getTextureSampleData( texture ) {

		let samples;

		if ( texture.isFramebufferTexture ) {

			samples = 1;

		} else if ( texture.isDepthTexture && ! texture.renderTarget ) {

			const renderer = this.backend.renderer;
			const renderTarget = renderer.getRenderTarget();

			samples = renderTarget ? renderTarget.samples : renderer.samples;

		} else if ( texture.renderTarget ) {

			samples = texture.renderTarget.samples;

		}

		samples = samples || 1;

		const isMSAA = samples > 1 && texture.renderTarget !== null && ( texture.isDepthTexture !== true && texture.isFramebufferTexture !== true );
		const primarySamples = isMSAA ? 1 : samples;

		return { samples, primarySamples, isMSAA };

	}

	getCurrentColorFormat( renderContext ) {

		let format;

		if ( renderContext.textures !== null ) {

			format = this.getTextureFormatGPU( renderContext.textures[ 0 ] );

		} else {

			format = this.getPreferredCanvasFormat(); // default context format

		}

		return format;

	}

	getCurrentColorSpace( renderContext ) {

		if ( renderContext.textures !== null ) {

			return renderContext.textures[ 0 ].colorSpace;

		}

		return this.backend.renderer.outputColorSpace;

	}

	getPrimitiveTopology( object, material ) {

		if ( object.isPoints ) return GPUPrimitiveTopology.PointList;
		else if ( object.isLineSegments || ( object.isMesh && material.wireframe === true ) ) return GPUPrimitiveTopology.LineList;
		else if ( object.isLine ) return GPUPrimitiveTopology.LineStrip;
		else if ( object.isMesh ) return GPUPrimitiveTopology.TriangleList;

	}

	getSampleCount( sampleCount ) {

		let count = 1;

		if ( sampleCount > 1 ) {

			// WebGPU only supports power-of-two sample counts and 2 is not a valid value
			count = Math.pow( 2, Math.floor( Math.log2( sampleCount ) ) );

			if ( count === 2 ) {

				count = 4;

			}

		}

		return count;

	}

	getSampleCountRenderContext( renderContext ) {

		if ( renderContext.textures !== null ) {

			return this.getSampleCount( renderContext.sampleCount );

		}

		return this.getSampleCount( this.backend.renderer.samples );

	}

	getPreferredCanvasFormat() {

		// TODO: Remove this check when Quest 34.5 is out
		// https://github.com/mrdoob/three.js/pull/29221/files#r1731833949

		if ( navigator.userAgent.includes( 'Quest' ) ) {

			return GPUTextureFormat.BGRA8Unorm;

		} else {

			return navigator.gpu.getPreferredCanvasFormat();

		}

	}

}

const typedArraysToVertexFormatPrefix = new Map( [
	[ Int8Array, [ 'sint8', 'snorm8' ]],
	[ Uint8Array, [ 'uint8', 'unorm8' ]],
	[ Int16Array, [ 'sint16', 'snorm16' ]],
	[ Uint16Array, [ 'uint16', 'unorm16' ]],
	[ Int32Array, [ 'sint32', 'snorm32' ]],
	[ Uint32Array, [ 'uint32', 'unorm32' ]],
	[ Float32Array, [ 'float32', ]],
] );

const typedAttributeToVertexFormatPrefix = new Map( [
	[ Float16BufferAttribute, [ 'float16', ]],
] );

const typeArraysToVertexFormatPrefixForItemSize1 = new Map( [
	[ Int32Array, 'sint32' ],
	[ Int16Array, 'sint32' ], // patch for INT16
	[ Uint32Array, 'uint32' ],
	[ Uint16Array, 'uint32' ], // patch for UINT16
	[ Float32Array, 'float32' ]
] );

class WebGPUAttributeUtils {

	constructor( backend ) {

		this.backend = backend;

	}

	createAttribute( attribute, usage ) {

		const bufferAttribute = this._getBufferAttribute( attribute );

		const backend = this.backend;
		const bufferData = backend.get( bufferAttribute );

		let buffer = bufferData.buffer;

		if ( buffer === undefined ) {

			const device = backend.device;

			let array = bufferAttribute.array;

			// patch for INT16 and UINT16
			if ( attribute.normalized === false && ( array.constructor === Int16Array || array.constructor === Uint16Array ) ) {

				const tempArray = new Uint32Array( array.length );
				for ( let i = 0; i < array.length; i ++ ) {

					tempArray[ i ] = array[ i ];

				}

				array = tempArray;

			}

			bufferAttribute.array = array;

			if ( ( bufferAttribute.isStorageBufferAttribute || bufferAttribute.isStorageInstancedBufferAttribute ) && bufferAttribute.itemSize === 3 ) {

				array = new array.constructor( bufferAttribute.count * 4 );

				for ( let i = 0; i < bufferAttribute.count; i ++ ) {

					array.set( bufferAttribute.array.subarray( i * 3, i * 3 + 3 ), i * 4 );

				}

				// Update BufferAttribute
				bufferAttribute.itemSize = 4;
				bufferAttribute.array = array;

			}

			const size = array.byteLength + ( ( 4 - ( array.byteLength % 4 ) ) % 4 ); // ensure 4 byte alignment, see #20441

			buffer = device.createBuffer( {
				label: bufferAttribute.name,
				size: size,
				usage: usage,
				mappedAtCreation: true
			} );

			new array.constructor( buffer.getMappedRange() ).set( array );

			buffer.unmap();

			bufferData.buffer = buffer;

		}

	}

	updateAttribute( attribute ) {

		const bufferAttribute = this._getBufferAttribute( attribute );

		const backend = this.backend;
		const device = backend.device;

		const buffer = backend.get( bufferAttribute ).buffer;

		const array = bufferAttribute.array;
		const isTypedArray = this._isTypedArray( array );
		const updateRanges = bufferAttribute.updateRanges;

		if ( updateRanges.length === 0 ) {

			// Not using update ranges

			device.queue.writeBuffer(
				buffer,
				0,
				array,
				0
			);

		} else {

			const byteOffsetFactor = isTypedArray ? 1 : array.BYTES_PER_ELEMENT;

			for ( let i = 0, l = updateRanges.length; i < l; i ++ ) {

				const range = updateRanges[ i ];

				const dataOffset = range.start * byteOffsetFactor;
				const size = range.count * byteOffsetFactor;

				device.queue.writeBuffer(
					buffer,
					0,
					array,
					dataOffset,
					size
				);

			}

			bufferAttribute.clearUpdateRanges();

		}

	}

	createShaderVertexBuffers( renderObject ) {

		const attributes = renderObject.getAttributes();
		const vertexBuffers = new Map();

		for ( let slot = 0; slot < attributes.length; slot ++ ) {

			const geometryAttribute = attributes[ slot ];
			const bytesPerElement = geometryAttribute.array.BYTES_PER_ELEMENT;
			const bufferAttribute = this._getBufferAttribute( geometryAttribute );

			let vertexBufferLayout = vertexBuffers.get( bufferAttribute );

			if ( vertexBufferLayout === undefined ) {

				let arrayStride, stepMode;

				if ( geometryAttribute.isInterleavedBufferAttribute === true ) {

					arrayStride = geometryAttribute.data.stride * bytesPerElement;
					stepMode = geometryAttribute.data.isInstancedInterleavedBuffer ? GPUInputStepMode.Instance : GPUInputStepMode.Vertex;

				} else {

					arrayStride = geometryAttribute.itemSize * bytesPerElement;
					stepMode = geometryAttribute.isInstancedBufferAttribute ? GPUInputStepMode.Instance : GPUInputStepMode.Vertex;

				}

				// patch for INT16 and UINT16
				if ( geometryAttribute.normalized === false && ( geometryAttribute.array.constructor === Int16Array || geometryAttribute.array.constructor === Uint16Array ) ) {

					arrayStride = 4;

				}

				vertexBufferLayout = {
					arrayStride,
					attributes: [],
					stepMode
				};

				vertexBuffers.set( bufferAttribute, vertexBufferLayout );

			}

			const format = this._getVertexFormat( geometryAttribute );
			const offset = ( geometryAttribute.isInterleavedBufferAttribute === true ) ? geometryAttribute.offset * bytesPerElement : 0;

			vertexBufferLayout.attributes.push( {
				shaderLocation: slot,
				offset,
				format
			} );

		}

		return Array.from( vertexBuffers.values() );

	}

	destroyAttribute( attribute ) {

		const backend = this.backend;
		const data = backend.get( this._getBufferAttribute( attribute ) );

		data.buffer.destroy();

		backend.delete( attribute );

	}

	async getArrayBufferAsync( attribute ) {

		const backend = this.backend;
		const device = backend.device;

		const data = backend.get( this._getBufferAttribute( attribute ) );

		const bufferGPU = data.buffer;
		const size = bufferGPU.size;

		const readBufferGPU = device.createBuffer( {
			label: attribute.name,
			size,
			usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ
		} );


		const cmdEncoder = device.createCommandEncoder( {} );

		cmdEncoder.copyBufferToBuffer(
			bufferGPU,
			0,
			readBufferGPU,
			0,
			size
		);

		readBufferGPU.unmap();

		const gpuCommands = cmdEncoder.finish();
		device.queue.submit( [ gpuCommands ] );

		await readBufferGPU.mapAsync( GPUMapMode.READ );

		const arrayBuffer = readBufferGPU.getMappedRange();

		return arrayBuffer;

	}

	_getVertexFormat( geometryAttribute ) {

		const { itemSize, normalized } = geometryAttribute;
		const ArrayType = geometryAttribute.array.constructor;
		const AttributeType = geometryAttribute.constructor;

		let format;

		if ( itemSize === 1 ) {

			format = typeArraysToVertexFormatPrefixForItemSize1.get( ArrayType );

		} else {

			const prefixOptions = typedAttributeToVertexFormatPrefix.get( AttributeType ) || typedArraysToVertexFormatPrefix.get( ArrayType );
			const prefix = prefixOptions[ normalized ? 1 : 0 ];

			if ( prefix ) {

				const bytesPerUnit = ArrayType.BYTES_PER_ELEMENT * itemSize;
				const paddedBytesPerUnit = Math.floor( ( bytesPerUnit + 3 ) / 4 ) * 4;
				const paddedItemSize = paddedBytesPerUnit / ArrayType.BYTES_PER_ELEMENT;

				if ( paddedItemSize % 1 ) {

					throw new Error( 'THREE.WebGPUAttributeUtils: Bad vertex format item size.' );

				}

				format = `${prefix}x${paddedItemSize}`;

			}

		}

		if ( ! format ) {

			console.error( 'THREE.WebGPUAttributeUtils: Vertex format not supported yet.' );

		}

		return format;

	}

	_isTypedArray( array ) {

		return ArrayBuffer.isView( array ) && ! ( array instanceof DataView );

	}

	_getBufferAttribute( attribute ) {

		if ( attribute.isInterleavedBufferAttribute ) attribute = attribute.data;

		return attribute;

	}

}

class WebGPUBindingUtils {

	constructor( backend ) {

		this.backend = backend;
		this.bindGroupLayoutCache = new WeakMap();

	}

	createBindingsLayout( bindGroup ) {

		const backend = this.backend;
		const device = backend.device;

		const entries = [];

		let index = 0;

		for ( const binding of bindGroup.bindings ) {

			const bindingGPU = {
				binding: index ++,
				visibility: binding.visibility
			};

			if ( binding.isUniformBuffer || binding.isStorageBuffer ) {

				const buffer = {}; // GPUBufferBindingLayout

				if ( binding.isStorageBuffer ) {

					if ( binding.visibility & 4 ) {

						// compute

						if ( binding.access === NodeAccess.READ_WRITE || binding.access === NodeAccess.WRITE_ONLY ) {

							buffer.type = GPUBufferBindingType.Storage;

						} else {

							buffer.type = GPUBufferBindingType.ReadOnlyStorage;

						}

					} else {

						buffer.type = GPUBufferBindingType.ReadOnlyStorage;

					}

				}

				bindingGPU.buffer = buffer;

			} else if ( binding.isSampler ) {

				const sampler = {}; // GPUSamplerBindingLayout

				if ( binding.texture.isDepthTexture ) {

					if ( binding.texture.compareFunction !== null ) {

						sampler.type = 'comparison';

					}

				}

				bindingGPU.sampler = sampler;

			} else if ( binding.isSampledTexture && binding.texture.isVideoTexture ) {

				bindingGPU.externalTexture = {}; // GPUExternalTextureBindingLayout

			} else if ( binding.isSampledTexture && binding.store ) {

				const storageTexture = {}; // GPUStorageTextureBindingLayout
				storageTexture.format = this.backend.get( binding.texture ).texture.format;

				const access = binding.access;

				if ( access === NodeAccess.READ_WRITE ) {

					storageTexture.access = GPUStorageTextureAccess.ReadWrite;

				} else if ( access === NodeAccess.WRITE_ONLY ) {

					storageTexture.access = GPUStorageTextureAccess.WriteOnly;

				} else {

					storageTexture.access = GPUStorageTextureAccess.ReadOnly;

				}

				bindingGPU.storageTexture = storageTexture;

			} else if ( binding.isSampledTexture ) {

				const texture = {}; // GPUTextureBindingLayout

				const { primarySamples } = backend.utils.getTextureSampleData( binding.texture );

				if ( primarySamples > 1 ) {

					texture.multisampled = true;

					if ( ! binding.texture.isDepthTexture ) {

						texture.sampleType = GPUTextureSampleType.UnfilterableFloat;

					}

				}

				if ( binding.texture.isDepthTexture ) {

					texture.sampleType = GPUTextureSampleType.Depth;

				} else if ( binding.texture.isDataTexture || binding.texture.isDataArrayTexture || binding.texture.isData3DTexture ) {

					const type = binding.texture.type;

					if ( type === IntType ) {

						texture.sampleType = GPUTextureSampleType.SInt;

					} else if ( type === UnsignedIntType ) {

						texture.sampleType = GPUTextureSampleType.UInt;

					} else if ( type === FloatType ) {

						if ( this.backend.hasFeature( 'float32-filterable' ) ) {

							texture.sampleType = GPUTextureSampleType.Float;

						} else {

							texture.sampleType = GPUTextureSampleType.UnfilterableFloat;

						}

					}

				}

				if ( binding.isSampledCubeTexture ) {

					texture.viewDimension = GPUTextureViewDimension.Cube;

				} else if ( binding.texture.isDataArrayTexture || binding.texture.isCompressedArrayTexture ) {

					texture.viewDimension = GPUTextureViewDimension.TwoDArray;

				} else if ( binding.isSampledTexture3D ) {

					texture.viewDimension = GPUTextureViewDimension.ThreeD;

				}

				bindingGPU.texture = texture;

			} else {

				console.error( `WebGPUBindingUtils: Unsupported binding "${ binding }".` );

			}

			entries.push( bindingGPU );

		}

		return device.createBindGroupLayout( { entries } );

	}

	createBindings( bindGroup, bindings, cacheIndex, version = 0 ) {

		const { backend, bindGroupLayoutCache } = this;
		const bindingsData = backend.get( bindGroup );

		// setup (static) binding layout and (dynamic) binding group

		let bindLayoutGPU = bindGroupLayoutCache.get( bindGroup.bindingsReference );

		if ( bindLayoutGPU === undefined ) {

			bindLayoutGPU = this.createBindingsLayout( bindGroup );
			bindGroupLayoutCache.set( bindGroup.bindingsReference, bindLayoutGPU );

		}

		let bindGroupGPU;

		if ( cacheIndex > 0 ) {

			if ( bindingsData.groups === undefined ) {

				bindingsData.groups = [];
				bindingsData.versions = [];

			}

			if ( bindingsData.versions[ cacheIndex ] === version ) {

				bindGroupGPU = bindingsData.groups[ cacheIndex ];

			}

		}

		if ( bindGroupGPU === undefined ) {

			bindGroupGPU = this.createBindGroup( bindGroup, bindLayoutGPU );

			if ( cacheIndex > 0 ) {

				bindingsData.groups[ cacheIndex ] = bindGroupGPU;
				bindingsData.versions[ cacheIndex ] = version;

			}

		}

		bindingsData.group = bindGroupGPU;
		bindingsData.layout = bindLayoutGPU;

	}

	updateBinding( binding ) {

		const backend = this.backend;
		const device = backend.device;

		const buffer = binding.buffer;
		const bufferGPU = backend.get( binding ).buffer;

		device.queue.writeBuffer( bufferGPU, 0, buffer, 0 );

	}

	createBindGroup( bindGroup, layoutGPU ) {

		const backend = this.backend;
		const device = backend.device;

		let bindingPoint = 0;
		const entriesGPU = [];

		for ( const binding of bindGroup.bindings ) {

			if ( binding.isUniformBuffer ) {

				const bindingData = backend.get( binding );

				if ( bindingData.buffer === undefined ) {

					const byteLength = binding.byteLength;

					const usage = GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST;

					const bufferGPU = device.createBuffer( {
						label: 'bindingBuffer_' + binding.name,
						size: byteLength,
						usage: usage
					} );

					bindingData.buffer = bufferGPU;

				}

				entriesGPU.push( { binding: bindingPoint, resource: { buffer: bindingData.buffer } } );

			} else if ( binding.isStorageBuffer ) {

				const bindingData = backend.get( binding );

				if ( bindingData.buffer === undefined ) {

					const attribute = binding.attribute;
					//const usage = GPUBufferUsage.STORAGE | GPUBufferUsage.VERTEX | /*GPUBufferUsage.COPY_SRC |*/ GPUBufferUsage.COPY_DST;

					//backend.attributeUtils.createAttribute( attribute, usage ); // @TODO: Move it to universal renderer

					bindingData.buffer = backend.get( attribute ).buffer;

				}

				entriesGPU.push( { binding: bindingPoint, resource: { buffer: bindingData.buffer } } );

			} else if ( binding.isSampler ) {

				const textureGPU = backend.get( binding.texture );

				entriesGPU.push( { binding: bindingPoint, resource: textureGPU.sampler } );

			} else if ( binding.isSampledTexture ) {

				const textureData = backend.get( binding.texture );

				let resourceGPU;

				if ( textureData.externalTexture !== undefined ) {

					resourceGPU = device.importExternalTexture( { source: textureData.externalTexture } );

				} else {

					const mipLevelCount = binding.store ? 1 : textureData.texture.mipLevelCount;
					const propertyName = `view-${ textureData.texture.width }-${ textureData.texture.height }-${ mipLevelCount }`;

					resourceGPU = textureData[ propertyName ];

					if ( resourceGPU === undefined ) {

						const aspectGPU = GPUTextureAspect.All;

						let dimensionViewGPU;

						if ( binding.isSampledCubeTexture ) {

							dimensionViewGPU = GPUTextureViewDimension.Cube;

						} else if ( binding.isSampledTexture3D ) {

							dimensionViewGPU = GPUTextureViewDimension.ThreeD;

						} else if ( binding.texture.isDataArrayTexture || binding.texture.isCompressedArrayTexture ) {

							dimensionViewGPU = GPUTextureViewDimension.TwoDArray;

						} else {

							dimensionViewGPU = GPUTextureViewDimension.TwoD;

						}

						resourceGPU = textureData[ propertyName ] = textureData.texture.createView( { aspect: aspectGPU, dimension: dimensionViewGPU, mipLevelCount } );

					}

				}

				entriesGPU.push( { binding: bindingPoint, resource: resourceGPU } );

			}

			bindingPoint ++;

		}

		return device.createBindGroup( {
			label: 'bindGroup_' + bindGroup.name,
			layout: layoutGPU,
			entries: entriesGPU
		} );

	}

}

class WebGPUPipelineUtils {

	constructor( backend ) {

		this.backend = backend;

	}

	_getSampleCount( renderObjectContext ) {

		return this.backend.utils.getSampleCountRenderContext( renderObjectContext );

	}

	createRenderPipeline( renderObject, promises ) {

		const { object, material, geometry, pipeline } = renderObject;
		const { vertexProgram, fragmentProgram } = pipeline;

		const backend = this.backend;
		const device = backend.device;
		const utils = backend.utils;

		const pipelineData = backend.get( pipeline );

		// bind group layouts

		const bindGroupLayouts = [];

		for ( const bindGroup of renderObject.getBindings() ) {

			const bindingsData = backend.get( bindGroup );

			bindGroupLayouts.push( bindingsData.layout );

		}

		// vertex buffers

		const vertexBuffers = backend.attributeUtils.createShaderVertexBuffers( renderObject );

		// blending

		let blending;

		if ( material.transparent === true && material.blending !== NoBlending ) {

			blending = this._getBlending( material );

		}

		// stencil

		let stencilFront = {};

		if ( material.stencilWrite === true ) {

			stencilFront = {
				compare: this._getStencilCompare( material ),
				failOp: this._getStencilOperation( material.stencilFail ),
				depthFailOp: this._getStencilOperation( material.stencilZFail ),
				passOp: this._getStencilOperation( material.stencilZPass )
			};

		}

		const colorWriteMask = this._getColorWriteMask( material );

		const targets = [];

		if ( renderObject.context.textures !== null ) {

			const textures = renderObject.context.textures;

			for ( let i = 0; i < textures.length; i ++ ) {

				const colorFormat = utils.getTextureFormatGPU( textures[ i ] );

				targets.push( {
					format: colorFormat,
					blend: blending,
					writeMask: colorWriteMask
				} );

			}

		} else {

			const colorFormat = utils.getCurrentColorFormat( renderObject.context );

			targets.push( {
				format: colorFormat,
				blend: blending,
				writeMask: colorWriteMask
			} );

		}

		const vertexModule = backend.get( vertexProgram ).module;
		const fragmentModule = backend.get( fragmentProgram ).module;

		const primitiveState = this._getPrimitiveState( object, geometry, material );
		const depthCompare = this._getDepthCompare( material );
		const depthStencilFormat = utils.getCurrentDepthStencilFormat( renderObject.context );

		const sampleCount = this._getSampleCount( renderObject.context );

		const pipelineDescriptor = {
			label: `renderPipeline_${ material.name || material.type }_${ material.id }`,
			vertex: Object.assign( {}, vertexModule, { buffers: vertexBuffers } ),
			fragment: Object.assign( {}, fragmentModule, { targets } ),
			primitive: primitiveState,
			multisample: {
				count: sampleCount,
				alphaToCoverageEnabled: material.alphaToCoverage && sampleCount > 1
			},
			layout: device.createPipelineLayout( {
				bindGroupLayouts
			} )
		};


		const depthStencil = {};
		const renderDepth = renderObject.context.depth;
		const renderStencil = renderObject.context.stencil;

		if ( renderDepth === true || renderStencil === true ) {

			if ( renderDepth === true ) {

				depthStencil.format = depthStencilFormat;
				depthStencil.depthWriteEnabled = material.depthWrite;
				depthStencil.depthCompare = depthCompare;

			}

			if ( renderStencil === true ) {

				depthStencil.stencilFront = stencilFront;
				depthStencil.stencilBack = {}; // three.js does not provide an API to configure the back function (gl.stencilFuncSeparate() was never used)
				depthStencil.stencilReadMask = material.stencilFuncMask;
				depthStencil.stencilWriteMask = material.stencilWriteMask;

			}

			pipelineDescriptor.depthStencil = depthStencil;

		}


		if ( promises === null ) {

			pipelineData.pipeline = device.createRenderPipeline( pipelineDescriptor );

		} else {

			const p = new Promise( ( resolve /*, reject*/ ) => {

				device.createRenderPipelineAsync( pipelineDescriptor ).then( pipeline => {

					pipelineData.pipeline = pipeline;
					resolve();

				} );

			} );

			promises.push( p );

		}

	}

	createBundleEncoder( renderContext ) {

		const backend = this.backend;
		const { utils, device } = backend;

		const depthStencilFormat = utils.getCurrentDepthStencilFormat( renderContext );
		const colorFormat = utils.getCurrentColorFormat( renderContext );
		const sampleCount = this._getSampleCount( renderContext );

		const descriptor = {
			label: 'renderBundleEncoder',
			colorFormats: [ colorFormat ],
			depthStencilFormat,
			sampleCount
		};

		return device.createRenderBundleEncoder( descriptor );

	}

	createComputePipeline( pipeline, bindings ) {

		const backend = this.backend;
		const device = backend.device;

		const computeProgram = backend.get( pipeline.computeProgram ).module;

		const pipelineGPU = backend.get( pipeline );

		// bind group layouts

		const bindGroupLayouts = [];

		for ( const bindingsGroup of bindings ) {

			const bindingsData = backend.get( bindingsGroup );

			bindGroupLayouts.push( bindingsData.layout );

		}

		pipelineGPU.pipeline = device.createComputePipeline( {
			compute: computeProgram,
			layout: device.createPipelineLayout( {
				bindGroupLayouts
			} )
		} );

	}

	_getBlending( material ) {

		let color, alpha;

		const blending = material.blending;
		const blendSrc = material.blendSrc;
		const blendDst = material.blendDst;
		const blendEquation = material.blendEquation;


		if ( blending === CustomBlending ) {

			const blendSrcAlpha = material.blendSrcAlpha !== null ? material.blendSrcAlpha : blendSrc;
			const blendDstAlpha = material.blendDstAlpha !== null ? material.blendDstAlpha : blendDst;
			const blendEquationAlpha = material.blendEquationAlpha !== null ? material.blendEquationAlpha : blendEquation;

			color = {
				srcFactor: this._getBlendFactor( blendSrc ),
				dstFactor: this._getBlendFactor( blendDst ),
				operation: this._getBlendOperation( blendEquation )
			};

			alpha = {
				srcFactor: this._getBlendFactor( blendSrcAlpha ),
				dstFactor: this._getBlendFactor( blendDstAlpha ),
				operation: this._getBlendOperation( blendEquationAlpha )
			};

		} else {

			const premultipliedAlpha = material.premultipliedAlpha;

			const setBlend = ( srcRGB, dstRGB, srcAlpha, dstAlpha ) => {

				color = {
					srcFactor: srcRGB,
					dstFactor: dstRGB,
					operation: GPUBlendOperation.Add
				};

				alpha = {
					srcFactor: srcAlpha,
					dstFactor: dstAlpha,
					operation: GPUBlendOperation.Add
				};

			};

			if ( premultipliedAlpha ) {

				switch ( blending ) {

					case NormalBlending:
						setBlend( GPUBlendFactor.One, GPUBlendFactor.OneMinusSrcAlpha, GPUBlendFactor.One, GPUBlendFactor.OneMinusSrcAlpha );
						break;

					case AdditiveBlending:
						setBlend( GPUBlendFactor.One, GPUBlendFactor.One, GPUBlendFactor.One, GPUBlendFactor.One );
						break;

					case SubtractiveBlending:
						setBlend( GPUBlendFactor.Zero, GPUBlendFactor.OneMinusSrc, GPUBlendFactor.Zero, GPUBlendFactor.One );
						break;

					case MultiplyBlending:
						setBlend( GPUBlendFactor.Zero, GPUBlendFactor.Src, GPUBlendFactor.Zero, GPUBlendFactor.SrcAlpha );
						break;

				}

			} else {

				switch ( blending ) {

					case NormalBlending:
						setBlend( GPUBlendFactor.SrcAlpha, GPUBlendFactor.OneMinusSrcAlpha, GPUBlendFactor.One, GPUBlendFactor.OneMinusSrcAlpha );
						break;

					case AdditiveBlending:
						setBlend( GPUBlendFactor.SrcAlpha, GPUBlendFactor.One, GPUBlendFactor.SrcAlpha, GPUBlendFactor.One );
						break;

					case SubtractiveBlending:
						setBlend( GPUBlendFactor.Zero, GPUBlendFactor.OneMinusSrc, GPUBlendFactor.Zero, GPUBlendFactor.One );
						break;

					case MultiplyBlending:
						setBlend( GPUBlendFactor.Zero, GPUBlendFactor.Src, GPUBlendFactor.Zero, GPUBlendFactor.Src );
						break;

				}

			}

		}

		if ( color !== undefined && alpha !== undefined ) {

			return { color, alpha };

		} else {

			console.error( 'THREE.WebGPURenderer: Invalid blending: ', blending );

		}

	}

	_getBlendFactor( blend ) {

		let blendFactor;

		switch ( blend ) {

			case ZeroFactor:
				blendFactor = GPUBlendFactor.Zero;
				break;

			case OneFactor:
				blendFactor = GPUBlendFactor.One;
				break;

			case SrcColorFactor:
				blendFactor = GPUBlendFactor.Src;
				break;

			case OneMinusSrcColorFactor:
				blendFactor = GPUBlendFactor.OneMinusSrc;
				break;

			case SrcAlphaFactor:
				blendFactor = GPUBlendFactor.SrcAlpha;
				break;

			case OneMinusSrcAlphaFactor:
				blendFactor = GPUBlendFactor.OneMinusSrcAlpha;
				break;

			case DstColorFactor:
				blendFactor = GPUBlendFactor.Dst;
				break;

			case OneMinusDstColorFactor:
				blendFactor = GPUBlendFactor.OneMinusDstColor;
				break;

			case DstAlphaFactor:
				blendFactor = GPUBlendFactor.DstAlpha;
				break;

			case OneMinusDstAlphaFactor:
				blendFactor = GPUBlendFactor.OneMinusDstAlpha;
				break;

			case SrcAlphaSaturateFactor:
				blendFactor = GPUBlendFactor.SrcAlphaSaturated;
				break;

			case BlendColorFactor:
				blendFactor = GPUBlendFactor.Constant;
				break;

			case OneMinusBlendColorFactor:
				blendFactor = GPUBlendFactor.OneMinusConstant;
				break;

			default:
				console.error( 'THREE.WebGPURenderer: Blend factor not supported.', blend );

		}

		return blendFactor;

	}

	_getStencilCompare( material ) {

		let stencilCompare;

		const stencilFunc = material.stencilFunc;

		switch ( stencilFunc ) {

			case NeverStencilFunc:
				stencilCompare = GPUCompareFunction.Never;
				break;

			case AlwaysStencilFunc:
				stencilCompare = GPUCompareFunction.Always;
				break;

			case LessStencilFunc:
				stencilCompare = GPUCompareFunction.Less;
				break;

			case LessEqualStencilFunc:
				stencilCompare = GPUCompareFunction.LessEqual;
				break;

			case EqualStencilFunc:
				stencilCompare = GPUCompareFunction.Equal;
				break;

			case GreaterEqualStencilFunc:
				stencilCompare = GPUCompareFunction.GreaterEqual;
				break;

			case GreaterStencilFunc:
				stencilCompare = GPUCompareFunction.Greater;
				break;

			case NotEqualStencilFunc:
				stencilCompare = GPUCompareFunction.NotEqual;
				break;

			default:
				console.error( 'THREE.WebGPURenderer: Invalid stencil function.', stencilFunc );

		}

		return stencilCompare;

	}

	_getStencilOperation( op ) {

		let stencilOperation;

		switch ( op ) {

			case KeepStencilOp:
				stencilOperation = GPUStencilOperation.Keep;
				break;

			case ZeroStencilOp:
				stencilOperation = GPUStencilOperation.Zero;
				break;

			case ReplaceStencilOp:
				stencilOperation = GPUStencilOperation.Replace;
				break;

			case InvertStencilOp:
				stencilOperation = GPUStencilOperation.Invert;
				break;

			case IncrementStencilOp:
				stencilOperation = GPUStencilOperation.IncrementClamp;
				break;

			case DecrementStencilOp:
				stencilOperation = GPUStencilOperation.DecrementClamp;
				break;

			case IncrementWrapStencilOp:
				stencilOperation = GPUStencilOperation.IncrementWrap;
				break;

			case DecrementWrapStencilOp:
				stencilOperation = GPUStencilOperation.DecrementWrap;
				break;

			default:
				console.error( 'THREE.WebGPURenderer: Invalid stencil operation.', stencilOperation );

		}

		return stencilOperation;

	}

	_getBlendOperation( blendEquation ) {

		let blendOperation;

		switch ( blendEquation ) {

			case AddEquation:
				blendOperation = GPUBlendOperation.Add;
				break;

			case SubtractEquation:
				blendOperation = GPUBlendOperation.Subtract;
				break;

			case ReverseSubtractEquation:
				blendOperation = GPUBlendOperation.ReverseSubtract;
				break;

			case MinEquation:
				blendOperation = GPUBlendOperation.Min;
				break;

			case MaxEquation:
				blendOperation = GPUBlendOperation.Max;
				break;

			default:
				console.error( 'THREE.WebGPUPipelineUtils: Blend equation not supported.', blendEquation );

		}

		return blendOperation;

	}

	_getPrimitiveState( object, geometry, material ) {

		const descriptor = {};
		const utils = this.backend.utils;

		descriptor.topology = utils.getPrimitiveTopology( object, material );

		if ( geometry.index !== null && object.isLine === true && object.isLineSegments !== true ) {

			descriptor.stripIndexFormat = ( geometry.index.array instanceof Uint16Array ) ? GPUIndexFormat.Uint16 : GPUIndexFormat.Uint32;

		}

		switch ( material.side ) {

			case FrontSide:
				descriptor.frontFace = GPUFrontFace.CCW;
				descriptor.cullMode = GPUCullMode.Back;
				break;

			case BackSide:
				descriptor.frontFace = GPUFrontFace.CCW;
				descriptor.cullMode = GPUCullMode.Front;
				break;

			case DoubleSide:
				descriptor.frontFace = GPUFrontFace.CCW;
				descriptor.cullMode = GPUCullMode.None;
				break;

			default:
				console.error( 'THREE.WebGPUPipelineUtils: Unknown material.side value.', material.side );
				break;

		}

		return descriptor;

	}

	_getColorWriteMask( material ) {

		return ( material.colorWrite === true ) ? GPUColorWriteFlags.All : GPUColorWriteFlags.None;

	}

	_getDepthCompare( material ) {

		let depthCompare;

		if ( material.depthTest === false ) {

			depthCompare = GPUCompareFunction.Always;

		} else {

			const depthFunc = material.depthFunc;

			switch ( depthFunc ) {

				case NeverDepth:
					depthCompare = GPUCompareFunction.Never;
					break;

				case AlwaysDepth:
					depthCompare = GPUCompareFunction.Always;
					break;

				case LessDepth:
					depthCompare = GPUCompareFunction.Less;
					break;

				case LessEqualDepth:
					depthCompare = GPUCompareFunction.LessEqual;
					break;

				case EqualDepth:
					depthCompare = GPUCompareFunction.Equal;
					break;

				case GreaterEqualDepth:
					depthCompare = GPUCompareFunction.GreaterEqual;
					break;

				case GreaterDepth:
					depthCompare = GPUCompareFunction.Greater;
					break;

				case NotEqualDepth:
					depthCompare = GPUCompareFunction.NotEqual;
					break;

				default:
					console.error( 'THREE.WebGPUPipelineUtils: Invalid depth function.', depthFunc );

			}

		}

		return depthCompare;

	}

}

/*// debugger tools
import 'https://greggman.github.io/webgpu-avoid-redundant-state-setting/webgpu-check-redundant-state-setting.js';
//*/


//

class WebGPUBackend extends Backend {

	constructor( parameters = {} ) {

		super( parameters );

		this.isWebGPUBackend = true;

		// some parameters require default values other than "undefined"
		this.parameters.alpha = ( parameters.alpha === undefined ) ? true : parameters.alpha;

		this.parameters.requiredLimits = ( parameters.requiredLimits === undefined ) ? {} : parameters.requiredLimits;

		this.trackTimestamp = ( parameters.trackTimestamp === true );

		this.device = null;
		this.context = null;
		this.colorBuffer = null;
		this.defaultRenderPassdescriptor = null;

		this.utils = new WebGPUUtils( this );
		this.attributeUtils = new WebGPUAttributeUtils( this );
		this.bindingUtils = new WebGPUBindingUtils( this );
		this.pipelineUtils = new WebGPUPipelineUtils( this );
		this.textureUtils = new WebGPUTextureUtils( this );
		this.occludedResolveCache = new Map();

	}

	async init( renderer ) {

		await super.init( renderer );

		//

		const parameters = this.parameters;

		// create the device if it is not passed with parameters

		let device;

		if ( parameters.device === undefined ) {

			const adapterOptions = {
				powerPreference: parameters.powerPreference
			};

			const adapter = ( typeof navigator !== 'undefined' ) ? await navigator.gpu.requestAdapter( adapterOptions ) : null;

			if ( adapter === null ) {

				throw new Error( 'WebGPUBackend: Unable to create WebGPU adapter.' );

			}

			// feature support

			const features = Object.values( GPUFeatureName );

			const supportedFeatures = [];

			for ( const name of features ) {

				if ( adapter.features.has( name ) ) {

					supportedFeatures.push( name );

				}

			}

			const deviceDescriptor = {
				requiredFeatures: supportedFeatures,
				requiredLimits: parameters.requiredLimits
			};

			device = await adapter.requestDevice( deviceDescriptor );

		} else {

			device = parameters.device;

		}

		device.lost.then( ( info ) => {

			const deviceLossInfo = {
				api: 'WebGPU',
				message: info.message || 'Unknown reason',
				reason: info.reason || null,
				originalEvent: info
			};

			renderer.onDeviceLost( deviceLossInfo );

		} );

		const context = ( parameters.context !== undefined ) ? parameters.context : renderer.domElement.getContext( 'webgpu' );

		this.device = device;
		this.context = context;

		const alphaMode = parameters.alpha ? 'premultiplied' : 'opaque';

		this.trackTimestamp = this.trackTimestamp && this.hasFeature( GPUFeatureName.TimestampQuery );

		this.context.configure( {
			device: this.device,
			format: this.utils.getPreferredCanvasFormat(),
			usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC,
			alphaMode: alphaMode
		} );

		this.updateSize();

	}

	get coordinateSystem() {

		return WebGPUCoordinateSystem;

	}

	async getArrayBufferAsync( attribute ) {

		return await this.attributeUtils.getArrayBufferAsync( attribute );

	}

	getContext() {

		return this.context;

	}

	_getDefaultRenderPassDescriptor() {

		let descriptor = this.defaultRenderPassdescriptor;

		if ( descriptor === null ) {

			const renderer = this.renderer;

			descriptor = {
				colorAttachments: [ {
					view: null
				} ],
			};

			if ( this.renderer.depth === true || this.renderer.stencil === true ) {

				descriptor.depthStencilAttachment = {
					view: this.textureUtils.getDepthBuffer( renderer.depth, renderer.stencil ).createView()
				};

			}

			const colorAttachment = descriptor.colorAttachments[ 0 ];

			if ( this.renderer.samples > 0 ) {

				colorAttachment.view = this.colorBuffer.createView();

			} else {

				colorAttachment.resolveTarget = undefined;

			}

			this.defaultRenderPassdescriptor = descriptor;

		}

		const colorAttachment = descriptor.colorAttachments[ 0 ];

		if ( this.renderer.samples > 0 ) {

			colorAttachment.resolveTarget = this.context.getCurrentTexture().createView();

		} else {

			colorAttachment.view = this.context.getCurrentTexture().createView();

		}

		return descriptor;

	}

	_getRenderPassDescriptor( renderContext ) {

		const renderTarget = renderContext.renderTarget;
		const renderTargetData = this.get( renderTarget );

		let descriptors = renderTargetData.descriptors;

		if ( descriptors === undefined ||
			renderTargetData.width !== renderTarget.width ||
			renderTargetData.height !== renderTarget.height ||
			renderTargetData.activeMipmapLevel !== renderTarget.activeMipmapLevel ||
			renderTargetData.samples !== renderTarget.samples
		) {

			descriptors = {};

			renderTargetData.descriptors = descriptors;

			// dispose

			const onDispose = () => {

				renderTarget.removeEventListener( 'dispose', onDispose );

				this.delete( renderTarget );

			};

			renderTarget.addEventListener( 'dispose', onDispose );

		}

		const cacheKey = renderContext.getCacheKey();

		let descriptor = descriptors[ cacheKey ];

		if ( descriptor === undefined ) {

			const textures = renderContext.textures;
			const colorAttachments = [];

			for ( let i = 0; i < textures.length; i ++ ) {

				const textureData = this.get( textures[ i ] );

				const textureView = textureData.texture.createView( {
					baseMipLevel: renderContext.activeMipmapLevel,
					mipLevelCount: 1,
					baseArrayLayer: renderContext.activeCubeFace,
					dimension: GPUTextureViewDimension.TwoD
				} );

				let view, resolveTarget;

				if ( textureData.msaaTexture !== undefined ) {

					view = textureData.msaaTexture.createView();
					resolveTarget = textureView;

				} else {

					view = textureView;
					resolveTarget = undefined;

				}

				colorAttachments.push( {
					view,
					resolveTarget,
					loadOp: GPULoadOp.Load,
					storeOp: GPUStoreOp.Store
				} );

			}


			descriptor = {
				colorAttachments,
			};

			if ( renderContext.depth ) {

				const depthTextureData = this.get( renderContext.depthTexture );

				const depthStencilAttachment = {
					view: depthTextureData.texture.createView()
				};
				descriptor.depthStencilAttachment = depthStencilAttachment;

			}

			descriptors[ cacheKey ] = descriptor;

			renderTargetData.width = renderTarget.width;
			renderTargetData.height = renderTarget.height;
			renderTargetData.samples = renderTarget.samples;
			renderTargetData.activeMipmapLevel = renderTarget.activeMipmapLevel;

		}

		return descriptor;

	}

	beginRender( renderContext ) {

		const renderContextData = this.get( renderContext );

		const device = this.device;
		const occlusionQueryCount = renderContext.occlusionQueryCount;

		let occlusionQuerySet;

		if ( occlusionQueryCount > 0 ) {

			if ( renderContextData.currentOcclusionQuerySet ) renderContextData.currentOcclusionQuerySet.destroy();
			if ( renderContextData.currentOcclusionQueryBuffer ) renderContextData.currentOcclusionQueryBuffer.destroy();

			// Get a reference to the array of objects with queries. The renderContextData property
			// can be changed by another render pass before the buffer.mapAsyc() completes.
			renderContextData.currentOcclusionQuerySet = renderContextData.occlusionQuerySet;
			renderContextData.currentOcclusionQueryBuffer = renderContextData.occlusionQueryBuffer;
			renderContextData.currentOcclusionQueryObjects = renderContextData.occlusionQueryObjects;

			//

			occlusionQuerySet = device.createQuerySet( { type: 'occlusion', count: occlusionQueryCount, label: `occlusionQuerySet_${ renderContext.id }` } );

			renderContextData.occlusionQuerySet = occlusionQuerySet;
			renderContextData.occlusionQueryIndex = 0;
			renderContextData.occlusionQueryObjects = new Array( occlusionQueryCount );

			renderContextData.lastOcclusionObject = null;

		}

		let descriptor;

		if ( renderContext.textures === null ) {

			descriptor = this._getDefaultRenderPassDescriptor();

		} else {

			descriptor = this._getRenderPassDescriptor( renderContext );

		}

		this.initTimestampQuery( renderContext, descriptor );

		descriptor.occlusionQuerySet = occlusionQuerySet;

		const depthStencilAttachment = descriptor.depthStencilAttachment;

		if ( renderContext.textures !== null ) {

			const colorAttachments = descriptor.colorAttachments;

			for ( let i = 0; i < colorAttachments.length; i ++ ) {

				const colorAttachment = colorAttachments[ i ];

				if ( renderContext.clearColor ) {

					colorAttachment.clearValue = i === 0 ? renderContext.clearColorValue : { r: 0, g: 0, b: 0, a: 1 };
					colorAttachment.loadOp = GPULoadOp.Clear;
					colorAttachment.storeOp = GPUStoreOp.Store;

				} else {

					colorAttachment.loadOp = GPULoadOp.Load;
					colorAttachment.storeOp = GPUStoreOp.Store;

				}

			}

		} else {

			const colorAttachment = descriptor.colorAttachments[ 0 ];

			if ( renderContext.clearColor ) {

				colorAttachment.clearValue = renderContext.clearColorValue;
				colorAttachment.loadOp = GPULoadOp.Clear;
				colorAttachment.storeOp = GPUStoreOp.Store;

			} else {

				colorAttachment.loadOp = GPULoadOp.Load;
				colorAttachment.storeOp = GPUStoreOp.Store;

			}

		}

		//

		if ( renderContext.depth ) {

			if ( renderContext.clearDepth ) {

				depthStencilAttachment.depthClearValue = renderContext.clearDepthValue;
				depthStencilAttachment.depthLoadOp = GPULoadOp.Clear;
				depthStencilAttachment.depthStoreOp = GPUStoreOp.Store;

			} else {

				depthStencilAttachment.depthLoadOp = GPULoadOp.Load;
				depthStencilAttachment.depthStoreOp = GPUStoreOp.Store;

			}

		}

		if ( renderContext.stencil ) {

			if ( renderContext.clearStencil ) {

				depthStencilAttachment.stencilClearValue = renderContext.clearStencilValue;
				depthStencilAttachment.stencilLoadOp = GPULoadOp.Clear;
				depthStencilAttachment.stencilStoreOp = GPUStoreOp.Store;

			} else {

				depthStencilAttachment.stencilLoadOp = GPULoadOp.Load;
				depthStencilAttachment.stencilStoreOp = GPUStoreOp.Store;

			}

		}

		//

		const encoder = device.createCommandEncoder( { label: 'renderContext_' + renderContext.id } );
		const currentPass = encoder.beginRenderPass( descriptor );

		//

		renderContextData.descriptor = descriptor;
		renderContextData.encoder = encoder;
		renderContextData.currentPass = currentPass;
		renderContextData.currentSets = { attributes: {}, bindingGroups: [], pipeline: null, index: null };
		renderContextData.renderBundles = [];

		//

		if ( renderContext.viewport ) {

			this.updateViewport( renderContext );

		}

		if ( renderContext.scissor ) {

			const { x, y, width, height } = renderContext.scissorValue;

			currentPass.setScissorRect( x, y, width, height );

		}

	}

	finishRender( renderContext ) {

		const renderContextData = this.get( renderContext );
		const occlusionQueryCount = renderContext.occlusionQueryCount;

		if ( renderContextData.renderBundles.length > 0 ) {

			renderContextData.currentPass.executeBundles( renderContextData.renderBundles );

		}

		if ( occlusionQueryCount > renderContextData.occlusionQueryIndex ) {

			renderContextData.currentPass.endOcclusionQuery();

		}

		renderContextData.currentPass.end();

		if ( occlusionQueryCount > 0 ) {

			const bufferSize = occlusionQueryCount * 8; // 8 byte entries for query results

			//

			let queryResolveBuffer = this.occludedResolveCache.get( bufferSize );

			if ( queryResolveBuffer === undefined ) {

				queryResolveBuffer = this.device.createBuffer(
					{
						size: bufferSize,
						usage: GPUBufferUsage.QUERY_RESOLVE | GPUBufferUsage.COPY_SRC
					}
				);

				this.occludedResolveCache.set( bufferSize, queryResolveBuffer );

			}

			//

			const readBuffer = this.device.createBuffer(
				{
					size: bufferSize,
					usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ
				}
			);

			// two buffers required here - WebGPU doesn't allow usage of QUERY_RESOLVE & MAP_READ to be combined
			renderContextData.encoder.resolveQuerySet( renderContextData.occlusionQuerySet, 0, occlusionQueryCount, queryResolveBuffer, 0 );
			renderContextData.encoder.copyBufferToBuffer( queryResolveBuffer, 0, readBuffer, 0, bufferSize );

			renderContextData.occlusionQueryBuffer = readBuffer;

			//

			this.resolveOccludedAsync( renderContext );

		}

		this.prepareTimestampBuffer( renderContext, renderContextData.encoder );

		this.device.queue.submit( [ renderContextData.encoder.finish() ] );


		//

		if ( renderContext.textures !== null ) {

			const textures = renderContext.textures;

			for ( let i = 0; i < textures.length; i ++ ) {

				const texture = textures[ i ];

				if ( texture.generateMipmaps === true ) {

					this.textureUtils.generateMipmaps( texture );

				}

			}

		}

	}

	isOccluded( renderContext, object ) {

		const renderContextData = this.get( renderContext );

		return renderContextData.occluded && renderContextData.occluded.has( object );

	}

	async resolveOccludedAsync( renderContext ) {

		const renderContextData = this.get( renderContext );

		// handle occlusion query results

		const { currentOcclusionQueryBuffer, currentOcclusionQueryObjects } = renderContextData;

		if ( currentOcclusionQueryBuffer && currentOcclusionQueryObjects ) {

			const occluded = new WeakSet();

			renderContextData.currentOcclusionQueryObjects = null;
			renderContextData.currentOcclusionQueryBuffer = null;

			await currentOcclusionQueryBuffer.mapAsync( GPUMapMode.READ );

			const buffer = currentOcclusionQueryBuffer.getMappedRange();
			const results = new BigUint64Array( buffer );

			for ( let i = 0; i < currentOcclusionQueryObjects.length; i ++ ) {

				if ( results[ i ] !== BigInt( 0 ) ) {

					occluded.add( currentOcclusionQueryObjects[ i ] );

				}

			}

			currentOcclusionQueryBuffer.destroy();

			renderContextData.occluded = occluded;

		}

	}

	updateViewport( renderContext ) {

		const { currentPass } = this.get( renderContext );
		const { x, y, width, height, minDepth, maxDepth } = renderContext.viewportValue;

		currentPass.setViewport( x, y, width, height, minDepth, maxDepth );

	}

	clear( color, depth, stencil, renderTargetData = null ) {

		const device = this.device;
		const renderer = this.renderer;

		let colorAttachments = [];

		let depthStencilAttachment;
		let clearValue;

		let supportsDepth;
		let supportsStencil;

		if ( color ) {

			const clearColor = this.getClearColor();

			if ( this.renderer.alpha === true ) {

				// premultiply alpha

				const a = clearColor.a;

				clearValue = { r: clearColor.r * a, g: clearColor.g * a, b: clearColor.b * a, a: a };

			} else {

				clearValue = { r: clearColor.r, g: clearColor.g, b: clearColor.b, a: clearColor.a };

			}

		}

		if ( renderTargetData === null ) {

			supportsDepth = renderer.depth;
			supportsStencil = renderer.stencil;

			const descriptor = this._getDefaultRenderPassDescriptor();

			if ( color ) {

				colorAttachments = descriptor.colorAttachments;

				const colorAttachment = colorAttachments[ 0 ];

				colorAttachment.clearValue = clearValue;
				colorAttachment.loadOp = GPULoadOp.Clear;
				colorAttachment.storeOp = GPUStoreOp.Store;

			}

			if ( supportsDepth || supportsStencil ) {

				depthStencilAttachment = descriptor.depthStencilAttachment;

			}

		} else {

			supportsDepth = renderTargetData.depth;
			supportsStencil = renderTargetData.stencil;

			if ( color ) {

				for ( const texture of renderTargetData.textures ) {

					const textureData = this.get( texture );
					const textureView = textureData.texture.createView();

					let view, resolveTarget;

					if ( textureData.msaaTexture !== undefined ) {

						view = textureData.msaaTexture.createView();
						resolveTarget = textureView;

					} else {

						view = textureView;
						resolveTarget = undefined;

					}

					colorAttachments.push( {
						view,
						resolveTarget,
						clearValue,
						loadOp: GPULoadOp.Clear,
						storeOp: GPUStoreOp.Store
					} );

				}

			}

			if ( supportsDepth || supportsStencil ) {

				const depthTextureData = this.get( renderTargetData.depthTexture );

				depthStencilAttachment = {
					view: depthTextureData.texture.createView()
				};

			}

		}

		//

		if ( supportsDepth ) {

			if ( depth ) {

				depthStencilAttachment.depthLoadOp = GPULoadOp.Clear;
				depthStencilAttachment.depthClearValue = renderer.getClearDepth();
				depthStencilAttachment.depthStoreOp = GPUStoreOp.Store;

			} else {

				depthStencilAttachment.depthLoadOp = GPULoadOp.Load;
				depthStencilAttachment.depthStoreOp = GPUStoreOp.Store;

			}

		}

		//

		if ( supportsStencil ) {

			if ( stencil ) {

				depthStencilAttachment.stencilLoadOp = GPULoadOp.Clear;
				depthStencilAttachment.stencilClearValue = renderer.getClearStencil();
				depthStencilAttachment.stencilStoreOp = GPUStoreOp.Store;

			} else {

				depthStencilAttachment.stencilLoadOp = GPULoadOp.Load;
				depthStencilAttachment.stencilStoreOp = GPUStoreOp.Store;

			}

		}

		//

		const encoder = device.createCommandEncoder( {} );
		const currentPass = encoder.beginRenderPass( {
			colorAttachments,
			depthStencilAttachment
		} );

		currentPass.end();

		device.queue.submit( [ encoder.finish() ] );

	}

	// compute

	beginCompute( computeGroup ) {

		const groupGPU = this.get( computeGroup );


		const descriptor = {};

		this.initTimestampQuery( computeGroup, descriptor );

		groupGPU.cmdEncoderGPU = this.device.createCommandEncoder();

		groupGPU.passEncoderGPU = groupGPU.cmdEncoderGPU.beginComputePass( descriptor );

	}

	compute( computeGroup, computeNode, bindings, pipeline ) {

		const { passEncoderGPU } = this.get( computeGroup );

		// pipeline

		const pipelineGPU = this.get( pipeline ).pipeline;
		passEncoderGPU.setPipeline( pipelineGPU );

		// bind groups

		for ( let i = 0, l = bindings.length; i < l; i ++ ) {

			const bindGroup = bindings[ i ];
			const bindingsData = this.get( bindGroup );

			passEncoderGPU.setBindGroup( i, bindingsData.group );

		}

		const maxComputeWorkgroupsPerDimension = this.device.limits.maxComputeWorkgroupsPerDimension;

		const computeNodeData = this.get( computeNode );

		if ( computeNodeData.dispatchSize === undefined ) computeNodeData.dispatchSize = { x: 0, y: 1, z: 1 };

		const { dispatchSize } = computeNodeData;

		if ( computeNode.dispatchCount > maxComputeWorkgroupsPerDimension ) {

			dispatchSize.x = Math.min( computeNode.dispatchCount, maxComputeWorkgroupsPerDimension );
			dispatchSize.y = Math.ceil( computeNode.dispatchCount / maxComputeWorkgroupsPerDimension );

		} else {

			dispatchSize.x = computeNode.dispatchCount;

		}

		passEncoderGPU.dispatchWorkgroups(
			dispatchSize.x,
			dispatchSize.y,
			dispatchSize.z
		);

	}

	finishCompute( computeGroup ) {

		const groupData = this.get( computeGroup );

		groupData.passEncoderGPU.end();

		this.prepareTimestampBuffer( computeGroup, groupData.cmdEncoderGPU );

		this.device.queue.submit( [ groupData.cmdEncoderGPU.finish() ] );

	}

	async waitForGPU() {

		await this.device.queue.onSubmittedWorkDone();

	}

	// render object

	draw( renderObject, info ) {

		const { object, context, pipeline } = renderObject;
		const bindings = renderObject.getBindings();
		const renderContextData = this.get( context );
		const pipelineGPU = this.get( pipeline ).pipeline;
		const currentSets = renderContextData.currentSets;
		const passEncoderGPU = renderContextData.currentPass;

		const drawParams = renderObject.getDrawParameters();

		if ( drawParams === null ) return;

		// pipeline

		if ( currentSets.pipeline !== pipelineGPU ) {

			passEncoderGPU.setPipeline( pipelineGPU );

			currentSets.pipeline = pipelineGPU;

		}

		// bind groups

		const currentBindingGroups = currentSets.bindingGroups;

		for ( let i = 0, l = bindings.length; i < l; i ++ ) {

			const bindGroup = bindings[ i ];
			const bindingsData = this.get( bindGroup );

			if ( currentBindingGroups[ bindGroup.index ] !== bindGroup.id ) {

				passEncoderGPU.setBindGroup( bindGroup.index, bindingsData.group );
				currentBindingGroups[ bindGroup.index ] = bindGroup.id;

			}

		}

		// attributes

		const index = renderObject.getIndex();

		const hasIndex = ( index !== null );

		// index

		if ( hasIndex === true ) {

			if ( currentSets.index !== index ) {

				const buffer = this.get( index ).buffer;
				const indexFormat = ( index.array instanceof Uint16Array ) ? GPUIndexFormat.Uint16 : GPUIndexFormat.Uint32;

				passEncoderGPU.setIndexBuffer( buffer, indexFormat );

				currentSets.index = index;

			}

		}

		// vertex buffers

		const vertexBuffers = renderObject.getVertexBuffers();

		for ( let i = 0, l = vertexBuffers.length; i < l; i ++ ) {

			const vertexBuffer = vertexBuffers[ i ];

			if ( currentSets.attributes[ i ] !== vertexBuffer ) {

				const buffer = this.get( vertexBuffer ).buffer;
				passEncoderGPU.setVertexBuffer( i, buffer );

				currentSets.attributes[ i ] = vertexBuffer;

			}

		}

		// occlusion queries - handle multiple consecutive draw calls for an object

		if ( renderContextData.occlusionQuerySet !== undefined ) {

			const lastObject = renderContextData.lastOcclusionObject;

			if ( lastObject !== object ) {

				if ( lastObject !== null && lastObject.occlusionTest === true ) {

					passEncoderGPU.endOcclusionQuery();
					renderContextData.occlusionQueryIndex ++;

				}

				if ( object.occlusionTest === true ) {

					passEncoderGPU.beginOcclusionQuery( renderContextData.occlusionQueryIndex );
					renderContextData.occlusionQueryObjects[ renderContextData.occlusionQueryIndex ] = object;

				}

				renderContextData.lastOcclusionObject = object;

			}

		}

		// draw

		if ( object.isBatchedMesh === true ) {

			const starts = object._multiDrawStarts;
			const counts = object._multiDrawCounts;
			const drawCount = object._multiDrawCount;
			const drawInstances = object._multiDrawInstances;

			for ( let i = 0; i < drawCount; i ++ ) {

				const count = drawInstances ? drawInstances[ i ] : 1;
				const firstInstance = count > 1 ? 0 : i;

				if ( hasIndex === true ) {

					passEncoderGPU.drawIndexed( counts[ i ], count, starts[ i ] / index.array.BYTES_PER_ELEMENT, 0, firstInstance );

				} else {

					passEncoderGPU.draw( counts[ i ], count, starts[ i ], firstInstance );

				}

			}

		} else if ( hasIndex === true ) {

			const { vertexCount: indexCount, instanceCount, firstVertex: firstIndex } = drawParams;

			const indirect = renderObject.getIndirect();

			if ( indirect !== null ) {

				const buffer = this.get( indirect ).buffer;

				passEncoderGPU.drawIndexedIndirect( buffer, 0 );

			} else {

				passEncoderGPU.drawIndexed( indexCount, instanceCount, firstIndex, 0, 0 );

			}

			info.update( object, indexCount, instanceCount );

		} else {

			const { vertexCount, instanceCount, firstVertex } = drawParams;

			const indirect = renderObject.getIndirect();

			if ( indirect !== null ) {

				const buffer = this.get( indirect ).buffer;

				passEncoderGPU.drawIndirect( buffer, 0 );

			} else {

				passEncoderGPU.draw( vertexCount, instanceCount, firstVertex, 0 );

			}

			info.update( object, vertexCount, instanceCount );

		}

	}

	// cache key

	needsRenderUpdate( renderObject ) {

		const data = this.get( renderObject );

		const { object, material } = renderObject;

		const utils = this.utils;

		const sampleCount = utils.getSampleCountRenderContext( renderObject.context );
		const colorSpace = utils.getCurrentColorSpace( renderObject.context );
		const colorFormat = utils.getCurrentColorFormat( renderObject.context );
		const depthStencilFormat = utils.getCurrentDepthStencilFormat( renderObject.context );
		const primitiveTopology = utils.getPrimitiveTopology( object, material );

		let needsUpdate = false;

		if ( data.material !== material || data.materialVersion !== material.version ||
			data.transparent !== material.transparent || data.blending !== material.blending || data.premultipliedAlpha !== material.premultipliedAlpha ||
			data.blendSrc !== material.blendSrc || data.blendDst !== material.blendDst || data.blendEquation !== material.blendEquation ||
			data.blendSrcAlpha !== material.blendSrcAlpha || data.blendDstAlpha !== material.blendDstAlpha || data.blendEquationAlpha !== material.blendEquationAlpha ||
			data.colorWrite !== material.colorWrite || data.depthWrite !== material.depthWrite || data.depthTest !== material.depthTest || data.depthFunc !== material.depthFunc ||
			data.stencilWrite !== material.stencilWrite || data.stencilFunc !== material.stencilFunc ||
			data.stencilFail !== material.stencilFail || data.stencilZFail !== material.stencilZFail || data.stencilZPass !== material.stencilZPass ||
			data.stencilFuncMask !== material.stencilFuncMask || data.stencilWriteMask !== material.stencilWriteMask ||
			data.side !== material.side || data.alphaToCoverage !== material.alphaToCoverage ||
			data.sampleCount !== sampleCount || data.colorSpace !== colorSpace ||
			data.colorFormat !== colorFormat || data.depthStencilFormat !== depthStencilFormat ||
			data.primitiveTopology !== primitiveTopology ||
			data.clippingContextCacheKey !== renderObject.clippingContextCacheKey
		) {

			data.material = material; data.materialVersion = material.version;
			data.transparent = material.transparent; data.blending = material.blending; data.premultipliedAlpha = material.premultipliedAlpha;
			data.blendSrc = material.blendSrc; data.blendDst = material.blendDst; data.blendEquation = material.blendEquation;
			data.blendSrcAlpha = material.blendSrcAlpha; data.blendDstAlpha = material.blendDstAlpha; data.blendEquationAlpha = material.blendEquationAlpha;
			data.colorWrite = material.colorWrite;
			data.depthWrite = material.depthWrite; data.depthTest = material.depthTest; data.depthFunc = material.depthFunc;
			data.stencilWrite = material.stencilWrite; data.stencilFunc = material.stencilFunc;
			data.stencilFail = material.stencilFail; data.stencilZFail = material.stencilZFail; data.stencilZPass = material.stencilZPass;
			data.stencilFuncMask = material.stencilFuncMask; data.stencilWriteMask = material.stencilWriteMask;
			data.side = material.side; data.alphaToCoverage = material.alphaToCoverage;
			data.sampleCount = sampleCount;
			data.colorSpace = colorSpace;
			data.colorFormat = colorFormat;
			data.depthStencilFormat = depthStencilFormat;
			data.primitiveTopology = primitiveTopology;
			data.clippingContextCacheKey = renderObject.clippingContextCacheKey;

			needsUpdate = true;

		}

		return needsUpdate;

	}

	getRenderCacheKey( renderObject ) {

		const { object, material } = renderObject;

		const utils = this.utils;
		const renderContext = renderObject.context;

		return [
			material.transparent, material.blending, material.premultipliedAlpha,
			material.blendSrc, material.blendDst, material.blendEquation,
			material.blendSrcAlpha, material.blendDstAlpha, material.blendEquationAlpha,
			material.colorWrite,
			material.depthWrite, material.depthTest, material.depthFunc,
			material.stencilWrite, material.stencilFunc,
			material.stencilFail, material.stencilZFail, material.stencilZPass,
			material.stencilFuncMask, material.stencilWriteMask,
			material.side,
			utils.getSampleCountRenderContext( renderContext ),
			utils.getCurrentColorSpace( renderContext ), utils.getCurrentColorFormat( renderContext ), utils.getCurrentDepthStencilFormat( renderContext ),
			utils.getPrimitiveTopology( object, material ),
			renderObject.getGeometryCacheKey(),
			renderObject.clippingContextCacheKey
		].join();

	}

	// textures

	createSampler( texture ) {

		this.textureUtils.createSampler( texture );

	}

	destroySampler( texture ) {

		this.textureUtils.destroySampler( texture );

	}

	createDefaultTexture( texture ) {

		this.textureUtils.createDefaultTexture( texture );

	}

	createTexture( texture, options ) {

		this.textureUtils.createTexture( texture, options );

	}

	updateTexture( texture, options ) {

		this.textureUtils.updateTexture( texture, options );

	}

	generateMipmaps( texture ) {

		this.textureUtils.generateMipmaps( texture );

	}

	destroyTexture( texture ) {

		this.textureUtils.destroyTexture( texture );

	}

	copyTextureToBuffer( texture, x, y, width, height, faceIndex ) {

		return this.textureUtils.copyTextureToBuffer( texture, x, y, width, height, faceIndex );

	}


	initTimestampQuery( renderContext, descriptor ) {

		if ( ! this.trackTimestamp ) return;

		const renderContextData = this.get( renderContext );

		if ( ! renderContextData.timeStampQuerySet ) {


			const type = renderContext.isComputeNode ? 'compute' : 'render';
			const timeStampQuerySet = this.device.createQuerySet( { type: 'timestamp', count: 2, label: `timestamp_${type}_${renderContext.id}` } );

			const timestampWrites = {
				querySet: timeStampQuerySet,
				beginningOfPassWriteIndex: 0, // Write timestamp in index 0 when pass begins.
				endOfPassWriteIndex: 1, // Write timestamp in index 1 when pass ends.
			};

			Object.assign( descriptor, { timestampWrites } );

			renderContextData.timeStampQuerySet = timeStampQuerySet;

		}

	}

	// timestamp utils

	prepareTimestampBuffer( renderContext, encoder ) {

		if ( ! this.trackTimestamp ) return;

		const renderContextData = this.get( renderContext );


		const size = 2 * BigInt64Array.BYTES_PER_ELEMENT;

		if ( renderContextData.currentTimestampQueryBuffers === undefined ) {

			renderContextData.currentTimestampQueryBuffers = {
				resolveBuffer: this.device.createBuffer( {
					label: 'timestamp resolve buffer',
					size: size,
					usage: GPUBufferUsage.QUERY_RESOLVE | GPUBufferUsage.COPY_SRC,
				} ),
				resultBuffer: this.device.createBuffer( {
					label: 'timestamp result buffer',
					size: size,
					usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ,
				} )
			};

		}

		const { resolveBuffer, resultBuffer } = renderContextData.currentTimestampQueryBuffers;


		encoder.resolveQuerySet( renderContextData.timeStampQuerySet, 0, 2, resolveBuffer, 0 );

		if ( resultBuffer.mapState === 'unmapped' ) {

			encoder.copyBufferToBuffer( resolveBuffer, 0, resultBuffer, 0, size );

		}

	}

	async resolveTimestampAsync( renderContext, type = 'render' ) {

		if ( ! this.trackTimestamp ) return;

		const renderContextData = this.get( renderContext );

		if ( renderContextData.currentTimestampQueryBuffers === undefined ) return;

		const { resultBuffer } = renderContextData.currentTimestampQueryBuffers;

		if ( resultBuffer.mapState === 'unmapped' ) {

			resultBuffer.mapAsync( GPUMapMode.READ ).then( () => {

				const times = new BigUint64Array( resultBuffer.getMappedRange() );
				const duration = Number( times[ 1 ] - times[ 0 ] ) / 1000000;


				this.renderer.info.updateTimestamp( type, duration );

				resultBuffer.unmap();


			} );

		}

	}

	// node builder

	createNodeBuilder( object, renderer ) {

		return new WGSLNodeBuilder( object, renderer );

	}

	// program

	createProgram( program ) {

		const programGPU = this.get( program );

		programGPU.module = {
			module: this.device.createShaderModule( { code: program.code, label: program.stage } ),
			entryPoint: 'main'
		};

	}

	destroyProgram( program ) {

		this.delete( program );

	}

	// pipelines

	createRenderPipeline( renderObject, promises ) {

		this.pipelineUtils.createRenderPipeline( renderObject, promises );

	}

	createComputePipeline( computePipeline, bindings ) {

		this.pipelineUtils.createComputePipeline( computePipeline, bindings );

	}

	beginBundle( renderContext ) {

		const renderContextData = this.get( renderContext );

		renderContextData._currentPass = renderContextData.currentPass;
		renderContextData._currentSets = renderContextData.currentSets;

		renderContextData.currentSets = { attributes: {}, bindingGroups: [], pipeline: null, index: null };
		renderContextData.currentPass = this.pipelineUtils.createBundleEncoder( renderContext );

	}

	finishBundle( renderContext, bundle ) {

		const renderContextData = this.get( renderContext );

		const bundleEncoder = renderContextData.currentPass;
		const bundleGPU = bundleEncoder.finish();

		this.get( bundle ).bundleGPU = bundleGPU;

		// restore render pass state

		renderContextData.currentSets = renderContextData._currentSets;
		renderContextData.currentPass = renderContextData._currentPass;

	}

	addBundle( renderContext, bundle ) {

		const renderContextData = this.get( renderContext );

		renderContextData.renderBundles.push( this.get( bundle ).bundleGPU );

	}

	// bindings

	createBindings( bindGroup, bindings, cacheIndex, version ) {

		this.bindingUtils.createBindings( bindGroup, bindings, cacheIndex, version );

	}

	updateBindings( bindGroup, bindings, cacheIndex, version ) {

		this.bindingUtils.createBindings( bindGroup, bindings, cacheIndex, version );

	}

	updateBinding( binding ) {

		this.bindingUtils.updateBinding( binding );

	}

	// attributes

	createIndexAttribute( attribute ) {

		this.attributeUtils.createAttribute( attribute, GPUBufferUsage.INDEX | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST );

	}

	createAttribute( attribute ) {

		this.attributeUtils.createAttribute( attribute, GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST );

	}

	createStorageAttribute( attribute ) {

		this.attributeUtils.createAttribute( attribute, GPUBufferUsage.STORAGE | GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST );

	}

	createIndirectStorageAttribute( attribute ) {

		this.attributeUtils.createAttribute( attribute, GPUBufferUsage.STORAGE | GPUBufferUsage.INDIRECT | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST );

	}

	updateAttribute( attribute ) {

		this.attributeUtils.updateAttribute( attribute );

	}

	destroyAttribute( attribute ) {

		this.attributeUtils.destroyAttribute( attribute );

	}

	// canvas

	updateSize() {

		this.colorBuffer = this.textureUtils.getColorBuffer();
		this.defaultRenderPassdescriptor = null;

	}

	// utils public

	getMaxAnisotropy() {

		return 16;

	}

	hasFeature( name ) {

		return this.device.features.has( name );

	}

	copyTextureToTexture( srcTexture, dstTexture, srcRegion = null, dstPosition = null, level = 0 ) {

		let dstX = 0;
		let dstY = 0;
		let dstLayer = 0;

		let srcX = 0;
		let srcY = 0;
		let srcLayer = 0;

		let srcWidth = srcTexture.image.width;
		let srcHeight = srcTexture.image.height;

		if ( srcRegion !== null ) {

			srcX = srcRegion.x;
			srcY = srcRegion.y;
			srcLayer = srcRegion.z || 0;
			srcWidth = srcRegion.width;
			srcHeight = srcRegion.height;

		}

		if ( dstPosition !== null ) {

			dstX = dstPosition.x;
			dstY = dstPosition.y;
			dstLayer = dstPosition.z || 0;

		}

		const encoder = this.device.createCommandEncoder( { label: 'copyTextureToTexture_' + srcTexture.id + '_' + dstTexture.id } );

		const sourceGPU = this.get( srcTexture ).texture;
		const destinationGPU = this.get( dstTexture ).texture;

		encoder.copyTextureToTexture(
			{
				texture: sourceGPU,
				mipLevel: level,
				origin: { x: srcX, y: srcY, z: srcLayer }
			},
			{
				texture: destinationGPU,
				mipLevel: level,
				origin: { x: dstX, y: dstY, z: dstLayer }
			},
			[
				srcWidth,
				srcHeight,
				1
			]
		);

		this.device.queue.submit( [ encoder.finish() ] );

	}

	copyFramebufferToTexture( texture, renderContext, rectangle ) {

		const renderContextData = this.get( renderContext );

		let sourceGPU = null;

		if ( renderContext.renderTarget ) {

			if ( texture.isDepthTexture ) {

				sourceGPU = this.get( renderContext.depthTexture ).texture;

			} else {

				sourceGPU = this.get( renderContext.textures[ 0 ] ).texture;

			}

		} else {

			if ( texture.isDepthTexture ) {

				sourceGPU = this.textureUtils.getDepthBuffer( renderContext.depth, renderContext.stencil );

			} else {

				sourceGPU = this.context.getCurrentTexture();

			}

		}

		const destinationGPU = this.get( texture ).texture;

		if ( sourceGPU.format !== destinationGPU.format ) {

			console.error( 'WebGPUBackend: copyFramebufferToTexture: Source and destination formats do not match.', sourceGPU.format, destinationGPU.format );

			return;

		}

		let encoder;

		if ( renderContextData.currentPass ) {

			renderContextData.currentPass.end();

			encoder = renderContextData.encoder;

		} else {

			encoder = this.device.createCommandEncoder( { label: 'copyFramebufferToTexture_' + texture.id } );

		}

		encoder.copyTextureToTexture(
			{
				texture: sourceGPU,
				origin: [ rectangle.x, rectangle.y, 0 ],
			},
			{
				texture: destinationGPU
			},
			[
				rectangle.z,
				rectangle.w
			]
		);

		if ( texture.generateMipmaps ) this.textureUtils.generateMipmaps( texture );

		if ( renderContextData.currentPass ) {

			const { descriptor } = renderContextData;

			for ( let i = 0; i < descriptor.colorAttachments.length; i ++ ) {

				descriptor.colorAttachments[ i ].loadOp = GPULoadOp.Load;

			}

			if ( renderContext.depth ) descriptor.depthStencilAttachment.depthLoadOp = GPULoadOp.Load;
			if ( renderContext.stencil ) descriptor.depthStencilAttachment.stencilLoadOp = GPULoadOp.Load;

			renderContextData.currentPass = encoder.beginRenderPass( descriptor );
			renderContextData.currentSets = { attributes: {}, bindingGroups: [], pipeline: null, index: null };

			if ( renderContext.viewport ) {

				this.updateViewport( renderContext );

			}

			if ( renderContext.scissor ) {

				const { x, y, width, height } = renderContext.scissorValue;

				renderContextData.currentPass.setScissorRect( x, y, width, height );

			}

		} else {

			this.device.queue.submit( [ encoder.finish() ] );

		}

	}

}

class IESSpotLight extends SpotLight {

	constructor( color, intensity, distance, angle, penumbra, decay ) {

		super( color, intensity, distance, angle, penumbra, decay );

		this.iesMap = null;

	}

	copy( source, recursive ) {

		super.copy( source, recursive );

		this.iesMap = source.iesMap;

		return this;

	}

}

class BasicNodeLibrary extends NodeLibrary {

	constructor() {

		super();

		this.addLight( PointLightNode, PointLight );
		this.addLight( DirectionalLightNode, DirectionalLight );
		this.addLight( RectAreaLightNode, RectAreaLight );
		this.addLight( SpotLightNode, SpotLight );
		this.addLight( AmbientLightNode, AmbientLight );
		this.addLight( HemisphereLightNode, HemisphereLight );
		this.addLight( LightProbeNode, LightProbe );
		this.addLight( IESSpotLightNode, IESSpotLight );

		this.addToneMapping( linearToneMapping, LinearToneMapping );
		this.addToneMapping( reinhardToneMapping, ReinhardToneMapping );
		this.addToneMapping( cineonToneMapping, CineonToneMapping );
		this.addToneMapping( acesFilmicToneMapping, ACESFilmicToneMapping );
		this.addToneMapping( agxToneMapping, AgXToneMapping );
		this.addToneMapping( neutralToneMapping, NeutralToneMapping );

	}

}

class WebGPURenderer extends Renderer {

	constructor( parameters = {} ) {

		let BackendClass;

		if ( parameters.forceWebGL ) {

			BackendClass = WebGLBackend;

		} else {

			BackendClass = WebGPUBackend;

			parameters.getFallback = () => {

				console.warn( 'THREE.WebGPURenderer: WebGPU is not available, running under WebGL2 backend.' );

				return new WebGLBackend( parameters );

			};

		}

		const backend = new BackendClass( parameters );

		super( backend, parameters );

		this.library = new BasicNodeLibrary();

		this.isWebGPURenderer = true;

	}

}

class BundleGroup extends Group {

	constructor() {

		super();

		this.isBundleGroup = true;

		this.type = 'BundleGroup';

		this.static = true;
		this.version = 0;

	}

	set needsUpdate( value ) {

		if ( value === true ) this.version ++;

	}

}

const _material = /*@__PURE__*/ new NodeMaterial();
const _quadMesh = /*@__PURE__*/ new QuadMesh( _material );

class PostProcessing {

	constructor( renderer, outputNode = vec4( 0, 0, 1, 1 ) ) {

		this.renderer = renderer;
		this.outputNode = outputNode;

		this.outputColorTransform = true;

		this.needsUpdate = true;

		_material.name = 'PostProcessing';

	}

	render() {

		this.update();

		const renderer = this.renderer;

		const toneMapping = renderer.toneMapping;
		const outputColorSpace = renderer.outputColorSpace;

		renderer.toneMapping = NoToneMapping;
		renderer.outputColorSpace = LinearSRGBColorSpace;

		//

		_quadMesh.render( renderer );

		//

		renderer.toneMapping = toneMapping;
		renderer.outputColorSpace = outputColorSpace;

	}

	update() {

		if ( this.needsUpdate === true ) {

			const renderer = this.renderer;

			const toneMapping = renderer.toneMapping;
			const outputColorSpace = renderer.outputColorSpace;

			_quadMesh.material.fragmentNode = this.outputColorTransform === true ? renderOutput( this.outputNode, toneMapping, outputColorSpace ) : this.outputNode.context( { toneMapping, outputColorSpace } );
			_quadMesh.material.needsUpdate = true;

			this.needsUpdate = false;

		}

	}

	async renderAsync() {

		this.update();

		const renderer = this.renderer;

		const toneMapping = renderer.toneMapping;
		const outputColorSpace = renderer.outputColorSpace;

		renderer.toneMapping = NoToneMapping;
		renderer.outputColorSpace = LinearSRGBColorSpace;

		//

		await _quadMesh.renderAsync( renderer );

		//

		renderer.toneMapping = toneMapping;
		renderer.outputColorSpace = outputColorSpace;

	}

}

// renderer state

function saveRendererState( renderer, state = {} ) {

	state.toneMapping = renderer.toneMapping;
	state.toneMappingExposure = renderer.toneMappingExposure;
	state.outputColorSpace = renderer.outputColorSpace;
	state.renderTarget = renderer.getRenderTarget();
	state.activeCubeFace = renderer.getActiveCubeFace();
	state.activeMipmapLevel = renderer.getActiveMipmapLevel();
	state.renderObjectFunction = renderer.getRenderObjectFunction();
	state.pixelRatio = renderer.getPixelRatio();
	state.mrt = renderer.getMRT();
	state.clearColor = renderer.getClearColor( state.clearColor || new Color() );
	state.clearAlpha = renderer.getClearAlpha();
	state.autoClear = renderer.autoClear;
	state.scissorTest = renderer.getScissorTest();

	return state;

}

function resetRendererState( renderer, state ) {

	state = saveRendererState( renderer, state );

	renderer.setMRT( null );
	renderer.setRenderObjectFunction( null );
	renderer.setClearColor( 0x000000, 1 );
	renderer.autoClear = true;

	return state;

}

function restoreRendererState( renderer, state ) {

	renderer.toneMapping = state.toneMapping;
	renderer.toneMappingExposure = state.toneMappingExposure;
	renderer.outputColorSpace = state.outputColorSpace;
	renderer.setRenderTarget( state.renderTarget, state.activeCubeFace, state.activeMipmapLevel );
	renderer.setRenderObjectFunction( state.renderObjectFunction );
	renderer.setPixelRatio( state.pixelRatio );
	renderer.setMRT( state.mrt );
	renderer.setClearColor( state.clearColor, state.clearAlpha );
	renderer.autoClear = state.autoClear;
	renderer.setScissorTest( state.scissorTest );

}

// renderer and scene state

function saveRendererAndSceneState( renderer, scene, state = {} ) {

	state = saveRendererState( renderer, state );
	state.background = scene.background;
	state.backgroundNode = scene.backgroundNode;
	state.overrideMaterial = scene.overrideMaterial;

	return state;

}

function resetRendererAndSceneState( renderer, scene, state ) {

	state = saveRendererAndSceneState( renderer, scene, state );

	scene.background = null;
	scene.backgroundNode = null;
	scene.overrideMaterial = null;

	return state;

}

function restoreRendererAndSceneState( renderer, scene, state ) {

	restoreRendererState( renderer, state );

	scene.background = state.background;
	scene.backgroundNode = state.backgroundNode;
	scene.overrideMaterial = state.overrideMaterial;

}

var PostProcessingUtils = /*#__PURE__*/Object.freeze({
	__proto__: null,
	resetRendererAndSceneState: resetRendererAndSceneState,
	resetRendererState: resetRendererState,
	restoreRendererAndSceneState: restoreRendererAndSceneState,
	restoreRendererState: restoreRendererState,
	saveRendererAndSceneState: saveRendererAndSceneState,
	saveRendererState: saveRendererState
});

class StorageTexture extends Texture {

	constructor( width = 1, height = 1 ) {

		super();

		this.image = { width, height };

		this.magFilter = LinearFilter;
		this.minFilter = LinearFilter;

		this.isStorageTexture = true;

	}

}

class IndirectStorageBufferAttribute extends StorageBufferAttribute {

	constructor( array, itemSize ) {

		super( array, itemSize, Uint32Array );

		this.isIndirectStorageBufferAttribute = true;

	}

}

class NodeLoader extends Loader {

	constructor( manager ) {

		super( manager );

		this.textures = {};
		this.nodes = {};

	}

	load( url, onLoad, onProgress, onError ) {

		const loader = new FileLoader( this.manager );
		loader.setPath( this.path );
		loader.setRequestHeader( this.requestHeader );
		loader.setWithCredentials( this.withCredentials );
		loader.load( url, ( text ) => {

			try {

				onLoad( this.parse( JSON.parse( text ) ) );

			} catch ( e ) {

				if ( onError ) {

					onError( e );

				} else {

					console.error( e );

				}

				this.manager.itemError( url );

			}

		}, onProgress, onError );

	}

	parseNodes( json ) {

		const nodes = {};

		if ( json !== undefined ) {

			for ( const nodeJSON of json ) {

				const { uuid, type } = nodeJSON;

				nodes[ uuid ] = this.createNodeFromType( type );
				nodes[ uuid ].uuid = uuid;

			}

			const meta = { nodes, textures: this.textures };

			for ( const nodeJSON of json ) {

				nodeJSON.meta = meta;

				const node = nodes[ nodeJSON.uuid ];
				node.deserialize( nodeJSON );

				delete nodeJSON.meta;

			}

		}

		return nodes;

	}

	parse( json ) {

		const node = this.createNodeFromType( json.type );
		node.uuid = json.uuid;

		const nodes = this.parseNodes( json.nodes );
		const meta = { nodes, textures: this.textures };

		json.meta = meta;

		node.deserialize( json );

		delete json.meta;

		return node;

	}

	setTextures( value ) {

		this.textures = value;
		return this;

	}

	setNodes( value ) {

		this.nodes = value;
		return this;

	}

	createNodeFromType( type ) {

		if ( this.nodes[ type ] === undefined ) {

			console.error( 'THREE.NodeLoader: Node type not found:', type );
			return float();

		}

		return nodeObject( new this.nodes[ type ]() );

	}

}

class NodeMaterialLoader extends MaterialLoader {

	constructor( manager ) {

		super( manager );

		this.nodes = {};
		this.nodeMaterials = {};

	}

	parse( json ) {

		const material = super.parse( json );

		const nodes = this.nodes;
		const inputNodes = json.inputNodes;

		for ( const property in inputNodes ) {

			const uuid = inputNodes[ property ];

			material[ property ] = nodes[ uuid ];

		}

		return material;

	}

	setNodes( value ) {

		this.nodes = value;
		return this;

	}

	setNodeMaterials( value ) {

		this.nodeMaterials = value;
		return this;

	}

	createMaterialFromType( type ) {

		const materialClass = this.nodeMaterials[ type ];

		if ( materialClass !== undefined ) {

			return new materialClass();

		}

		return super.createMaterialFromType( type );

	}

}

class NodeObjectLoader extends ObjectLoader {

	constructor( manager ) {

		super( manager );

		this.nodes = {};
		this.nodeMaterials = {};

		this._nodesJSON = null;

	}

	setNodes( value ) {

		this.nodes = value;
		return this;

	}

	setNodeMaterials( value ) {

		this.nodeMaterials = value;
		return this;

	}

	parse( json, onLoad ) {

		this._nodesJSON = json.nodes;

		const data = super.parse( json, onLoad );

		this._nodesJSON = null; // dispose

		return data;

	}

	parseNodes( json, textures ) {

		if ( json !== undefined ) {

			const loader = new NodeLoader();
			loader.setNodes( this.nodes );
			loader.setTextures( textures );

			return loader.parseNodes( json );

		}

		return {};

	}

	parseMaterials( json, textures ) {

		const materials = {};

		if ( json !== undefined ) {

			const nodes = this.parseNodes( this._nodesJSON, textures );

			const loader = new NodeMaterialLoader();
			loader.setTextures( textures );
			loader.setNodes( nodes );
			loader.setNodeMaterials( this.nodeMaterials );

			for ( let i = 0, l = json.length; i < l; i ++ ) {

				const data = json[ i ];

				materials[ data.uuid ] = loader.parse( data );

			}

		}

		return materials;

	}

}

class ClippingGroup extends Group {

	constructor() {

		super();

		this.isClippingGroup = true;
		this.clippingPlanes = [];
		this.enabled = true;
		this.clipIntersection = false;
		this.clipShadows = false;

	}

}

export { ACESFilmicToneMapping, AONode, AddEquation, AddOperation, AdditiveBlending, AgXToneMapping, AlphaFormat, AlwaysCompare, AlwaysDepth, AlwaysStencilFunc, AmbientLight, AmbientLightNode, AnalyticLightNode, ArrayElementNode, AssignNode, AttributeNode, BackSide, BasicEnvironmentNode, BasicShadowMap, BatchNode, BoxGeometry, BufferAttribute, BufferAttributeNode, BufferGeometry, BufferNode, BumpMapNode, BundleGroup, BypassNode, ByteType, CacheNode, CineonToneMapping, ClampToEdgeWrapping, ClippingGroup, CodeNode, Color, ColorManagement, ColorSpaceNode, ComputeNode, ConstNode, ContextNode, ConvertNode, CubeCamera, CubeReflectionMapping, CubeRefractionMapping, CubeTexture, CubeTextureNode, CubeUVReflectionMapping, CullFaceBack, CullFaceFront, CullFaceNone, CustomBlending, DataArrayTexture, DataTexture, DecrementStencilOp, DecrementWrapStencilOp, DepthFormat, DepthStencilFormat, DepthTexture, DirectionalLight, DirectionalLightNode, DoubleSide, DstAlphaFactor, DstColorFactor, DynamicDrawUsage, EnvironmentNode, EqualCompare, EqualDepth, EqualStencilFunc, EquirectUVNode, EquirectangularReflectionMapping, EquirectangularRefractionMapping, Euler, EventDispatcher, ExpressionNode, FileLoader, Float16BufferAttribute, Float32BufferAttribute, FloatType, FramebufferTexture, FrontFacingNode, FrontSide, Frustum, FunctionCallNode, FunctionNode, FunctionOverloadingNode, GLSLNodeParser, GreaterCompare, GreaterDepth, GreaterEqualCompare, GreaterEqualDepth, GreaterEqualStencilFunc, GreaterStencilFunc, Group, HalfFloatType, HemisphereLight, HemisphereLightNode, IESSpotLight, IESSpotLightNode, IncrementStencilOp, IncrementWrapStencilOp, IndexNode, IndirectStorageBufferAttribute, InstanceNode, InstancedBufferAttribute, InstancedInterleavedBuffer, InstancedMeshNode, InstancedPointsNodeMaterial, IntType, InterleavedBuffer, InterleavedBufferAttribute, InvertStencilOp, IrradianceNode, JoinNode, KeepStencilOp, LessCompare, LessDepth, LessEqualCompare, LessEqualDepth, LessEqualStencilFunc, LessStencilFunc, LightProbe, LightProbeNode, Lighting, LightingContextNode, LightingModel, LightingNode, LightsNode, Line2NodeMaterial, LineBasicMaterial, LineBasicNodeMaterial, LineDashedMaterial, LineDashedNodeMaterial, LinearFilter, LinearMipMapLinearFilter, LinearMipmapLinearFilter, LinearMipmapNearestFilter, LinearSRGBColorSpace, LinearToneMapping, Loader, LoopNode, LuminanceAlphaFormat, LuminanceFormat, MRTNode, MatcapUVNode, Material, MaterialLoader, MaterialNode, MaterialReferenceNode, MathUtils, Matrix3, Matrix4, MaxEquation, MaxMipLevelNode, Mesh, MeshBasicMaterial, MeshBasicNodeMaterial, MeshLambertMaterial, MeshLambertNodeMaterial, MeshMatcapMaterial, MeshMatcapNodeMaterial, MeshNormalMaterial, MeshNormalNodeMaterial, MeshPhongMaterial, MeshPhongNodeMaterial, MeshPhysicalMaterial, MeshPhysicalNodeMaterial, MeshSSSNodeMaterial, MeshStandardMaterial, MeshStandardNodeMaterial, MeshToonMaterial, MeshToonNodeMaterial, MinEquation, MirroredRepeatWrapping, MixOperation, ModelNode, MorphNode, MultiplyBlending, MultiplyOperation, NearestFilter, NearestMipmapLinearFilter, NearestMipmapNearestFilter, NeutralToneMapping, NeverCompare, NeverDepth, NeverStencilFunc, NoBlending, NoColorSpace, NoToneMapping, Node, NodeAccess, NodeAttribute, NodeBuilder, NodeCache, NodeCode, NodeFrame, NodeFunctionInput, NodeLoader, NodeMaterial, NodeMaterialLoader, NodeMaterialObserver, NodeObjectLoader, NodeShaderStage, NodeType, NodeUniform, NodeUpdateType, NodeUtils, NodeVar, NodeVarying, NormalBlending, NormalMapNode, NotEqualCompare, NotEqualDepth, NotEqualStencilFunc, Object3D, Object3DNode, ObjectLoader, ObjectSpaceNormalMap, OneFactor, OneMinusDstAlphaFactor, OneMinusDstColorFactor, OneMinusSrcAlphaFactor, OneMinusSrcColorFactor, OrthographicCamera, OutputStructNode, PCFShadowMap, PMREMGenerator, PMREMNode, ParameterNode, PassNode, PerspectiveCamera, PhongLightingModel, PhysicalLightingModel, Plane, PointLight, PointLightNode, PointUVNode, PointsMaterial, PointsNodeMaterial, PostProcessing, PostProcessingUtils, PosterizeNode, PropertyNode, QuadMesh, RED_GREEN_RGTC2_Format, RED_RGTC1_Format, REVISION, RGBAFormat, RGBAIntegerFormat, RGBA_ASTC_10x10_Format, RGBA_ASTC_10x5_Format, RGBA_ASTC_10x6_Format, RGBA_ASTC_10x8_Format, RGBA_ASTC_12x10_Format, RGBA_ASTC_12x12_Format, RGBA_ASTC_4x4_Format, RGBA_ASTC_5x4_Format, RGBA_ASTC_5x5_Format, RGBA_ASTC_6x5_Format, RGBA_ASTC_6x6_Format, RGBA_ASTC_8x5_Format, RGBA_ASTC_8x6_Format, RGBA_ASTC_8x8_Format, RGBA_BPTC_Format, RGBA_ETC2_EAC_Format, RGBA_PVRTC_2BPPV1_Format, RGBA_PVRTC_4BPPV1_Format, RGBA_S3TC_DXT1_Format, RGBA_S3TC_DXT3_Format, RGBA_S3TC_DXT5_Format, RGBFormat, RGBIntegerFormat, RGB_ETC1_Format, RGB_ETC2_Format, RGB_PVRTC_2BPPV1_Format, RGB_PVRTC_4BPPV1_Format, RGB_S3TC_DXT1_Format, RGFormat, RGIntegerFormat, RTTNode, RangeNode, RectAreaLight, RectAreaLightNode, RedFormat, RedIntegerFormat, ReferenceNode, ReflectorNode, ReinhardToneMapping, RemapNode, RenderOutputNode, RenderTarget, RendererReferenceNode, RepeatWrapping, ReplaceStencilOp, ReverseSubtractEquation, RotateNode, SIGNED_RED_GREEN_RGTC2_Format, SIGNED_RED_RGTC1_Format, SRGBColorSpace, SRGBTransfer, Scene, SceneNode, ScreenNode, ScriptableNode, ScriptableValueNode, SetNode, ShadowBaseNode, ShadowMaterial, ShadowNode, ShadowNodeMaterial, ShortType, SkinningNode, SphereGeometry, SplitNode, SpotLight, SpotLightNode, SpriteMaterial, SpriteNodeMaterial, SpriteSheetUVNode, SrcAlphaFactor, SrcAlphaSaturateFactor, SrcColorFactor, StackNode, StaticDrawUsage, StorageArrayElementNode, StorageBufferAttribute, StorageBufferNode, StorageInstancedBufferAttribute, StorageTexture, StorageTextureNode, SubtractEquation, SubtractiveBlending, TSL, TangentSpaceNormalMap, TempNode, Texture, Texture3DNode, TextureNode, TextureSizeNode, ToneMappingNode, ToonOutlinePassNode, TriplanarTexturesNode, UVMapping, Uint16BufferAttribute, Uint32BufferAttribute, UniformArrayNode, UniformGroupNode, UniformNode, UnsignedByteType, UnsignedInt248Type, UnsignedInt5999Type, UnsignedIntType, UnsignedShort4444Type, UnsignedShort5551Type, UnsignedShortType, UserDataNode, VSMShadowMap, VarNode, VaryingNode, Vector2, Vector3, Vector4, VertexColorNode, ViewportDepthNode, ViewportDepthTextureNode, ViewportSharedTextureNode, ViewportTextureNode, VolumeNodeMaterial, WebGLCoordinateSystem, WebGLCubeRenderTarget, WebGPUCoordinateSystem, WebGPURenderer, ZeroFactor, ZeroStencilOp, createCanvasElement, defaultBuildStages, defaultShaderStages, shaderStages, vectorComponents };
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGhyZWUud2ViZ3B1Lm5vZGVzLmpzIiwic291cmNlcyI6WyIuLi9zcmMvbWF0ZXJpYWxzL25vZGVzL21hbmFnZXIvTm9kZU1hdGVyaWFsT2JzZXJ2ZXIuanMiLCIuLi9zcmMvbm9kZXMvY29yZS9Ob2RlVXRpbHMuanMiLCIuLi9zcmMvbm9kZXMvY29yZS9jb25zdGFudHMuanMiLCIuLi9zcmMvbm9kZXMvY29yZS9Ob2RlLmpzIiwiLi4vc3JjL25vZGVzL3V0aWxzL0FycmF5RWxlbWVudE5vZGUuanMiLCIuLi9zcmMvbm9kZXMvdXRpbHMvQ29udmVydE5vZGUuanMiLCIuLi9zcmMvbm9kZXMvY29yZS9UZW1wTm9kZS5qcyIsIi4uL3NyYy9ub2Rlcy91dGlscy9Kb2luTm9kZS5qcyIsIi4uL3NyYy9ub2Rlcy91dGlscy9TcGxpdE5vZGUuanMiLCIuLi9zcmMvbm9kZXMvdXRpbHMvU2V0Tm9kZS5qcyIsIi4uL3NyYy9ub2Rlcy91dGlscy9GbGlwTm9kZS5qcyIsIi4uL3NyYy9ub2Rlcy9jb3JlL0lucHV0Tm9kZS5qcyIsIi4uL3NyYy9ub2Rlcy9jb3JlL0NvbnN0Tm9kZS5qcyIsIi4uL3NyYy9ub2Rlcy90c2wvVFNMQ29yZS5qcyIsIi4uL3NyYy9ub2Rlcy9jb3JlL1VuaWZvcm1Hcm91cE5vZGUuanMiLCIuLi9zcmMvbm9kZXMvY29yZS9Vbmlmb3JtTm9kZS5qcyIsIi4uL3NyYy9ub2Rlcy9jb3JlL1Byb3BlcnR5Tm9kZS5qcyIsIi4uL3NyYy9ub2Rlcy9jb3JlL0Fzc2lnbk5vZGUuanMiLCIuLi9zcmMvbm9kZXMvY29kZS9GdW5jdGlvbkNhbGxOb2RlLmpzIiwiLi4vc3JjL25vZGVzL21hdGgvT3BlcmF0b3JOb2RlLmpzIiwiLi4vc3JjL25vZGVzL21hdGgvTWF0aE5vZGUuanMiLCIuLi9zcmMvbm9kZXMvbWF0aC9Db25kaXRpb25hbE5vZGUuanMiLCIuLi9zcmMvbm9kZXMvY29yZS9Db250ZXh0Tm9kZS5qcyIsIi4uL3NyYy9ub2Rlcy9jb3JlL1Zhck5vZGUuanMiLCIuLi9zcmMvbm9kZXMvY29yZS9WYXJ5aW5nTm9kZS5qcyIsIi4uL3NyYy9ub2Rlcy9kaXNwbGF5L0NvbG9yU3BhY2VGdW5jdGlvbnMuanMiLCIuLi9zcmMvbm9kZXMvZGlzcGxheS9Db2xvclNwYWNlTm9kZS5qcyIsIi4uL3NyYy9ub2Rlcy9hY2Nlc3NvcnMvUmVmZXJlbmNlQmFzZU5vZGUuanMiLCIuLi9zcmMvbm9kZXMvYWNjZXNzb3JzL1JlbmRlcmVyUmVmZXJlbmNlTm9kZS5qcyIsIi4uL3NyYy9ub2Rlcy9kaXNwbGF5L1RvbmVNYXBwaW5nTm9kZS5qcyIsIi4uL3NyYy9ub2Rlcy9hY2Nlc3NvcnMvQnVmZmVyQXR0cmlidXRlTm9kZS5qcyIsIi4uL3NyYy9ub2Rlcy9ncGdwdS9Db21wdXRlTm9kZS5qcyIsIi4uL3NyYy9ub2Rlcy9jb3JlL0NhY2hlTm9kZS5qcyIsIi4uL3NyYy9ub2Rlcy9jb3JlL0J5cGFzc05vZGUuanMiLCIuLi9zcmMvbm9kZXMvdXRpbHMvUmVtYXBOb2RlLmpzIiwiLi4vc3JjL25vZGVzL2NvZGUvRXhwcmVzc2lvbk5vZGUuanMiLCIuLi9zcmMvbm9kZXMvdXRpbHMvRGlzY2FyZC5qcyIsIi4uL3NyYy9ub2Rlcy9kaXNwbGF5L1JlbmRlck91dHB1dE5vZGUuanMiLCIuLi9zcmMvbm9kZXMvdHNsL1RTTEJhc2UuanMiLCIuLi9zcmMvbm9kZXMvY29yZS9BdHRyaWJ1dGVOb2RlLmpzIiwiLi4vc3JjL25vZGVzL2FjY2Vzc29ycy9VVi5qcyIsIi4uL3NyYy9ub2Rlcy9hY2Nlc3NvcnMvVGV4dHVyZVNpemVOb2RlLmpzIiwiLi4vc3JjL25vZGVzL3V0aWxzL01heE1pcExldmVsTm9kZS5qcyIsIi4uL3NyYy9ub2Rlcy9hY2Nlc3NvcnMvVGV4dHVyZU5vZGUuanMiLCIuLi9zcmMvbm9kZXMvYWNjZXNzb3JzL0NhbWVyYS5qcyIsIi4uL3NyYy9ub2Rlcy9hY2Nlc3NvcnMvT2JqZWN0M0ROb2RlLmpzIiwiLi4vc3JjL25vZGVzL2FjY2Vzc29ycy9Nb2RlbE5vZGUuanMiLCIuLi9zcmMvbm9kZXMvYWNjZXNzb3JzL1Bvc2l0aW9uLmpzIiwiLi4vc3JjL25vZGVzL2Rpc3BsYXkvRnJvbnRGYWNpbmdOb2RlLmpzIiwiLi4vc3JjL25vZGVzL2FjY2Vzc29ycy9Ob3JtYWwuanMiLCIuLi9zcmMvbm9kZXMvYWNjZXNzb3JzL01hdGVyaWFsUHJvcGVydGllcy5qcyIsIi4uL3NyYy9ub2Rlcy9hY2Nlc3NvcnMvUmVmbGVjdFZlY3Rvci5qcyIsIi4uL3NyYy9ub2Rlcy9hY2Nlc3NvcnMvQ3ViZVRleHR1cmVOb2RlLmpzIiwiLi4vc3JjL25vZGVzL2FjY2Vzc29ycy9CdWZmZXJOb2RlLmpzIiwiLi4vc3JjL25vZGVzL2FjY2Vzc29ycy9Vbmlmb3JtQXJyYXlOb2RlLmpzIiwiLi4vc3JjL25vZGVzL2FjY2Vzc29ycy9SZWZlcmVuY2VOb2RlLmpzIiwiLi4vc3JjL25vZGVzL2FjY2Vzc29ycy9NYXRlcmlhbFJlZmVyZW5jZU5vZGUuanMiLCIuLi9zcmMvbm9kZXMvYWNjZXNzb3JzL1RhbmdlbnQuanMiLCIuLi9zcmMvbm9kZXMvYWNjZXNzb3JzL0JpdGFuZ2VudC5qcyIsIi4uL3NyYy9ub2Rlcy9hY2Nlc3NvcnMvQWNjZXNzb3JzVXRpbHMuanMiLCIuLi9zcmMvbm9kZXMvZGlzcGxheS9Ob3JtYWxNYXBOb2RlLmpzIiwiLi4vc3JjL25vZGVzL2Rpc3BsYXkvQnVtcE1hcE5vZGUuanMiLCIuLi9zcmMvbm9kZXMvYWNjZXNzb3JzL01hdGVyaWFsTm9kZS5qcyIsIi4uL3NyYy9ub2Rlcy9hY2Nlc3NvcnMvTW9kZWxWaWV3UHJvamVjdGlvbk5vZGUuanMiLCIuLi9zcmMvbm9kZXMvY29yZS9JbmRleE5vZGUuanMiLCIuLi9zcmMvbm9kZXMvYWNjZXNzb3JzL0luc3RhbmNlTm9kZS5qcyIsIi4uL3NyYy9ub2Rlcy9hY2Nlc3NvcnMvSW5zdGFuY2VkTWVzaE5vZGUuanMiLCIuLi9zcmMvbm9kZXMvYWNjZXNzb3JzL0JhdGNoTm9kZS5qcyIsIi4uL3NyYy9ub2Rlcy9hY2Nlc3NvcnMvU2tpbm5pbmdOb2RlLmpzIiwiLi4vc3JjL25vZGVzL3V0aWxzL0xvb3BOb2RlLmpzIiwiLi4vc3JjL25vZGVzL2FjY2Vzc29ycy9Nb3JwaE5vZGUuanMiLCIuLi9zcmMvbm9kZXMvbGlnaHRpbmcvTGlnaHRpbmdOb2RlLmpzIiwiLi4vc3JjL25vZGVzL2xpZ2h0aW5nL0FPTm9kZS5qcyIsIi4uL3NyYy9ub2Rlcy9saWdodGluZy9MaWdodGluZ0NvbnRleHROb2RlLmpzIiwiLi4vc3JjL25vZGVzL2xpZ2h0aW5nL0lycmFkaWFuY2VOb2RlLmpzIiwiLi4vc3JjL25vZGVzL2Rpc3BsYXkvU2NyZWVuTm9kZS5qcyIsIi4uL3NyYy9ub2Rlcy9kaXNwbGF5L1ZpZXdwb3J0VGV4dHVyZU5vZGUuanMiLCIuLi9zcmMvbm9kZXMvZGlzcGxheS9WaWV3cG9ydERlcHRoVGV4dHVyZU5vZGUuanMiLCIuLi9zcmMvbm9kZXMvZGlzcGxheS9WaWV3cG9ydERlcHRoTm9kZS5qcyIsIi4uL3NyYy9ub2Rlcy9hY2Nlc3NvcnMvQnVpbHRpbk5vZGUuanMiLCIuLi9zcmMvbm9kZXMvYWNjZXNzb3JzL0NsaXBwaW5nTm9kZS5qcyIsIi4uL3NyYy9ub2Rlcy9mdW5jdGlvbnMvbWF0ZXJpYWwvZ2V0QWxwaGFIYXNoVGhyZXNob2xkLmpzIiwiLi4vc3JjL21hdGVyaWFscy9ub2Rlcy9Ob2RlTWF0ZXJpYWwuanMiLCIuLi9zcmMvbWF0ZXJpYWxzL25vZGVzL0luc3RhbmNlZFBvaW50c05vZGVNYXRlcmlhbC5qcyIsIi4uL3NyYy9tYXRlcmlhbHMvbm9kZXMvTGluZUJhc2ljTm9kZU1hdGVyaWFsLmpzIiwiLi4vc3JjL21hdGVyaWFscy9ub2Rlcy9MaW5lRGFzaGVkTm9kZU1hdGVyaWFsLmpzIiwiLi4vc3JjL25vZGVzL2Rpc3BsYXkvVmlld3BvcnRTaGFyZWRUZXh0dXJlTm9kZS5qcyIsIi4uL3NyYy9tYXRlcmlhbHMvbm9kZXMvTGluZTJOb2RlTWF0ZXJpYWwuanMiLCIuLi9zcmMvbm9kZXMvdXRpbHMvUGFja2luZy5qcyIsIi4uL3NyYy9tYXRlcmlhbHMvbm9kZXMvTWVzaE5vcm1hbE5vZGVNYXRlcmlhbC5qcyIsIi4uL3NyYy9ub2Rlcy91dGlscy9FcXVpcmVjdFVWTm9kZS5qcyIsIi4uL3NyYy9yZW5kZXJlcnMvY29tbW9uL0N1YmVSZW5kZXJUYXJnZXQuanMiLCIuLi9zcmMvbm9kZXMvdXRpbHMvQ3ViZU1hcE5vZGUuanMiLCIuLi9zcmMvbm9kZXMvbGlnaHRpbmcvQmFzaWNFbnZpcm9ubWVudE5vZGUuanMiLCIuLi9zcmMvbm9kZXMvbGlnaHRpbmcvQmFzaWNMaWdodE1hcE5vZGUuanMiLCIuLi9zcmMvbm9kZXMvY29yZS9MaWdodGluZ01vZGVsLmpzIiwiLi4vc3JjL25vZGVzL2Z1bmN0aW9ucy9CYXNpY0xpZ2h0aW5nTW9kZWwuanMiLCIuLi9zcmMvbWF0ZXJpYWxzL25vZGVzL01lc2hCYXNpY05vZGVNYXRlcmlhbC5qcyIsIi4uL3NyYy9ub2Rlcy9mdW5jdGlvbnMvQlNERi9GX1NjaGxpY2suanMiLCIuLi9zcmMvbm9kZXMvZnVuY3Rpb25zL0JTREYvQlJERl9MYW1iZXJ0LmpzIiwiLi4vc3JjL25vZGVzL2Z1bmN0aW9ucy9QaG9uZ0xpZ2h0aW5nTW9kZWwuanMiLCIuLi9zcmMvbWF0ZXJpYWxzL25vZGVzL01lc2hMYW1iZXJ0Tm9kZU1hdGVyaWFsLmpzIiwiLi4vc3JjL21hdGVyaWFscy9ub2Rlcy9NZXNoUGhvbmdOb2RlTWF0ZXJpYWwuanMiLCIuLi9zcmMvbm9kZXMvZnVuY3Rpb25zL21hdGVyaWFsL2dldEdlb21ldHJ5Um91Z2huZXNzLmpzIiwiLi4vc3JjL25vZGVzL2Z1bmN0aW9ucy9tYXRlcmlhbC9nZXRSb3VnaG5lc3MuanMiLCIuLi9zcmMvbm9kZXMvZnVuY3Rpb25zL0JTREYvVl9HR1hfU21pdGhDb3JyZWxhdGVkLmpzIiwiLi4vc3JjL25vZGVzL2Z1bmN0aW9ucy9CU0RGL1ZfR0dYX1NtaXRoQ29ycmVsYXRlZF9Bbmlzb3Ryb3BpYy5qcyIsIi4uL3NyYy9ub2Rlcy9mdW5jdGlvbnMvQlNERi9EX0dHWC5qcyIsIi4uL3NyYy9ub2Rlcy9mdW5jdGlvbnMvQlNERi9EX0dHWF9Bbmlzb3Ryb3BpYy5qcyIsIi4uL3NyYy9ub2Rlcy9mdW5jdGlvbnMvQlNERi9CUkRGX0dHWC5qcyIsIi4uL3NyYy9ub2Rlcy9mdW5jdGlvbnMvQlNERi9ERkdBcHByb3guanMiLCIuLi9zcmMvbm9kZXMvZnVuY3Rpb25zL0JTREYvRW52aXJvbm1lbnRCUkRGLmpzIiwiLi4vc3JjL25vZGVzL2Z1bmN0aW9ucy9CU0RGL1NjaGxpY2tfdG9fRjAuanMiLCIuLi9zcmMvbm9kZXMvZnVuY3Rpb25zL0JTREYvQlJERl9TaGVlbi5qcyIsIi4uL3NyYy9ub2Rlcy9mdW5jdGlvbnMvQlNERi9MVEMuanMiLCIuLi9zcmMvbm9kZXMvYWNjZXNzb3JzL1RleHR1cmVCaWN1YmljLmpzIiwiLi4vc3JjL25vZGVzL2Z1bmN0aW9ucy9QaHlzaWNhbExpZ2h0aW5nTW9kZWwuanMiLCIuLi9zcmMvbm9kZXMvcG1yZW0vUE1SRU1VdGlscy5qcyIsIi4uL3NyYy9ub2Rlcy9wbXJlbS9QTVJFTU5vZGUuanMiLCIuLi9zcmMvbm9kZXMvbGlnaHRpbmcvRW52aXJvbm1lbnROb2RlLmpzIiwiLi4vc3JjL21hdGVyaWFscy9ub2Rlcy9NZXNoU3RhbmRhcmROb2RlTWF0ZXJpYWwuanMiLCIuLi9zcmMvbWF0ZXJpYWxzL25vZGVzL01lc2hQaHlzaWNhbE5vZGVNYXRlcmlhbC5qcyIsIi4uL3NyYy9tYXRlcmlhbHMvbm9kZXMvTWVzaFNTU05vZGVNYXRlcmlhbC5qcyIsIi4uL3NyYy9ub2Rlcy9mdW5jdGlvbnMvVG9vbkxpZ2h0aW5nTW9kZWwuanMiLCIuLi9zcmMvbWF0ZXJpYWxzL25vZGVzL01lc2hUb29uTm9kZU1hdGVyaWFsLmpzIiwiLi4vc3JjL25vZGVzL3V0aWxzL01hdGNhcFVWTm9kZS5qcyIsIi4uL3NyYy9tYXRlcmlhbHMvbm9kZXMvTWVzaE1hdGNhcE5vZGVNYXRlcmlhbC5qcyIsIi4uL3NyYy9tYXRlcmlhbHMvbm9kZXMvUG9pbnRzTm9kZU1hdGVyaWFsLmpzIiwiLi4vc3JjL25vZGVzL3V0aWxzL1JvdGF0ZU5vZGUuanMiLCIuLi9zcmMvbWF0ZXJpYWxzL25vZGVzL1Nwcml0ZU5vZGVNYXRlcmlhbC5qcyIsIi4uL3NyYy9ub2Rlcy9mdW5jdGlvbnMvU2hhZG93TWFza01vZGVsLmpzIiwiLi4vc3JjL21hdGVyaWFscy9ub2Rlcy9TaGFkb3dOb2RlTWF0ZXJpYWwuanMiLCIuLi9zcmMvbm9kZXMvYWNjZXNzb3JzL1RleHR1cmUzRE5vZGUuanMiLCIuLi9zcmMvbWF0ZXJpYWxzL25vZGVzL1ZvbHVtZU5vZGVNYXRlcmlhbC5qcyIsIi4uL3NyYy9yZW5kZXJlcnMvY29tbW9uL0FuaW1hdGlvbi5qcyIsIi4uL3NyYy9yZW5kZXJlcnMvY29tbW9uL0NoYWluTWFwLmpzIiwiLi4vc3JjL3JlbmRlcmVycy9jb21tb24vUmVuZGVyT2JqZWN0LmpzIiwiLi4vc3JjL3JlbmRlcmVycy9jb21tb24vUmVuZGVyT2JqZWN0cy5qcyIsIi4uL3NyYy9yZW5kZXJlcnMvY29tbW9uL0RhdGFNYXAuanMiLCIuLi9zcmMvcmVuZGVyZXJzL2NvbW1vbi9Db25zdGFudHMuanMiLCIuLi9zcmMvcmVuZGVyZXJzL2NvbW1vbi9BdHRyaWJ1dGVzLmpzIiwiLi4vc3JjL3JlbmRlcmVycy9jb21tb24vR2VvbWV0cmllcy5qcyIsIi4uL3NyYy9yZW5kZXJlcnMvY29tbW9uL0luZm8uanMiLCIuLi9zcmMvcmVuZGVyZXJzL2NvbW1vbi9QaXBlbGluZS5qcyIsIi4uL3NyYy9yZW5kZXJlcnMvY29tbW9uL1JlbmRlclBpcGVsaW5lLmpzIiwiLi4vc3JjL3JlbmRlcmVycy9jb21tb24vQ29tcHV0ZVBpcGVsaW5lLmpzIiwiLi4vc3JjL3JlbmRlcmVycy9jb21tb24vUHJvZ3JhbW1hYmxlU3RhZ2UuanMiLCIuLi9zcmMvcmVuZGVyZXJzL2NvbW1vbi9QaXBlbGluZXMuanMiLCIuLi9zcmMvcmVuZGVyZXJzL2NvbW1vbi9CaW5kaW5ncy5qcyIsIi4uL3NyYy9yZW5kZXJlcnMvY29tbW9uL1JlbmRlckxpc3QuanMiLCIuLi9zcmMvcmVuZGVyZXJzL2NvbW1vbi9SZW5kZXJMaXN0cy5qcyIsIi4uL3NyYy9yZW5kZXJlcnMvY29tbW9uL1JlbmRlckNvbnRleHQuanMiLCIuLi9zcmMvcmVuZGVyZXJzL2NvbW1vbi9SZW5kZXJDb250ZXh0cy5qcyIsIi4uL3NyYy9yZW5kZXJlcnMvY29tbW9uL1RleHR1cmVzLmpzIiwiLi4vc3JjL3JlbmRlcmVycy9jb21tb24vQ29sb3I0LmpzIiwiLi4vc3JjL25vZGVzL2NvcmUvUGFyYW1ldGVyTm9kZS5qcyIsIi4uL3NyYy9ub2Rlcy9jb3JlL1N0YWNrTm9kZS5qcyIsIi4uL3NyYy9ub2Rlcy9jb3JlL091dHB1dFN0cnVjdE5vZGUuanMiLCIuLi9zcmMvbm9kZXMvY29yZS9NUlROb2RlLmpzIiwiLi4vc3JjL25vZGVzL21hdGgvSGFzaC5qcyIsIi4uL3NyYy9ub2Rlcy9tYXRoL01hdGhVdGlscy5qcyIsIi4uL3NyYy9ub2Rlcy9tYXRoL1RyaU5vaXNlM0QuanMiLCIuLi9zcmMvbm9kZXMvdXRpbHMvRnVuY3Rpb25PdmVybG9hZGluZ05vZGUuanMiLCIuLi9zcmMvbm9kZXMvdXRpbHMvVGltZXIuanMiLCIuLi9zcmMvbm9kZXMvdXRpbHMvT3NjaWxsYXRvcnMuanMiLCIuLi9zcmMvbm9kZXMvdXRpbHMvVVZVdGlscy5qcyIsIi4uL3NyYy9ub2Rlcy91dGlscy9TcHJpdGVVdGlscy5qcyIsIi4uL3NyYy9ub2Rlcy91dGlscy9WaWV3cG9ydFV0aWxzLmpzIiwiLi4vc3JjL25vZGVzL3V0aWxzL1Nwcml0ZVNoZWV0VVZOb2RlLmpzIiwiLi4vc3JjL25vZGVzL3V0aWxzL1RyaXBsYW5hclRleHR1cmVzTm9kZS5qcyIsIi4uL3NyYy9ub2Rlcy91dGlscy9SZWZsZWN0b3JOb2RlLmpzIiwiLi4vc3JjL3JlbmRlcmVycy9jb21tb24vUXVhZE1lc2guanMiLCIuLi9zcmMvbm9kZXMvdXRpbHMvUlRUTm9kZS5qcyIsIi4uL3NyYy9ub2Rlcy91dGlscy9Qb3N0UHJvY2Vzc2luZ1V0aWxzLmpzIiwiLi4vc3JjL3JlbmRlcmVycy9jb21tb24vU3RvcmFnZUluc3RhbmNlZEJ1ZmZlckF0dHJpYnV0ZS5qcyIsIi4uL3NyYy9yZW5kZXJlcnMvY29tbW9uL1N0b3JhZ2VCdWZmZXJBdHRyaWJ1dGUuanMiLCIuLi9zcmMvbm9kZXMvdXRpbHMvU3RvcmFnZUFycmF5RWxlbWVudE5vZGUuanMiLCIuLi9zcmMvbm9kZXMvYWNjZXNzb3JzL1N0b3JhZ2VCdWZmZXJOb2RlLmpzIiwiLi4vc3JjL25vZGVzL2FjY2Vzc29ycy9BcnJheXMuanMiLCIuLi9zcmMvbm9kZXMvYWNjZXNzb3JzL1ZlcnRleENvbG9yTm9kZS5qcyIsIi4uL3NyYy9ub2Rlcy9hY2Nlc3NvcnMvUG9pbnRVVk5vZGUuanMiLCIuLi9zcmMvbm9kZXMvYWNjZXNzb3JzL1NjZW5lTm9kZS5qcyIsIi4uL3NyYy9ub2Rlcy9hY2Nlc3NvcnMvU3RvcmFnZVRleHR1cmVOb2RlLmpzIiwiLi4vc3JjL25vZGVzL2FjY2Vzc29ycy9Vc2VyRGF0YU5vZGUuanMiLCIuLi9zcmMvbm9kZXMvYWNjZXNzb3JzL1ZlbG9jaXR5Tm9kZS5qcyIsIi4uL3NyYy9ub2Rlcy9kaXNwbGF5L0JsZW5kTW9kZXMuanMiLCIuLi9zcmMvbm9kZXMvZGlzcGxheS9Db2xvckFkanVzdG1lbnQuanMiLCIuLi9zcmMvbm9kZXMvZGlzcGxheS9Qb3N0ZXJpemVOb2RlLmpzIiwiLi4vc3JjL25vZGVzL2Rpc3BsYXkvUGFzc05vZGUuanMiLCIuLi9zcmMvbm9kZXMvZGlzcGxheS9Ub29uT3V0bGluZVBhc3NOb2RlLmpzIiwiLi4vc3JjL25vZGVzL2Rpc3BsYXkvVG9uZU1hcHBpbmdGdW5jdGlvbnMuanMiLCIuLi9zcmMvbm9kZXMvY29kZS9Db2RlTm9kZS5qcyIsIi4uL3NyYy9ub2Rlcy9jb2RlL0Z1bmN0aW9uTm9kZS5qcyIsIi4uL3NyYy9ub2Rlcy9jb2RlL1NjcmlwdGFibGVWYWx1ZU5vZGUuanMiLCIuLi9zcmMvbm9kZXMvY29kZS9TY3JpcHRhYmxlTm9kZS5qcyIsIi4uL3NyYy9ub2Rlcy9mb2cvRm9nLmpzIiwiLi4vc3JjL25vZGVzL2dlb21ldHJ5L1JhbmdlTm9kZS5qcyIsIi4uL3NyYy9ub2Rlcy9ncGdwdS9Db21wdXRlQnVpbHRpbk5vZGUuanMiLCIuLi9zcmMvbm9kZXMvZ3BncHUvQmFycmllck5vZGUuanMiLCIuLi9zcmMvbm9kZXMvZ3BncHUvV29ya2dyb3VwSW5mb05vZGUuanMiLCIuLi9zcmMvbm9kZXMvZ3BncHUvQXRvbWljRnVuY3Rpb25Ob2RlLmpzIiwiLi4vc3JjL25vZGVzL2FjY2Vzc29ycy9MaWdodHMuanMiLCIuLi9zcmMvbm9kZXMvbGlnaHRpbmcvTGlnaHRzTm9kZS5qcyIsIi4uL3NyYy9ub2Rlcy9saWdodGluZy9TaGFkb3dCYXNlTm9kZS5qcyIsIi4uL3NyYy9ub2Rlcy9saWdodGluZy9TaGFkb3dOb2RlLmpzIiwiLi4vc3JjL25vZGVzL2xpZ2h0aW5nL0FuYWx5dGljTGlnaHROb2RlLmpzIiwiLi4vc3JjL25vZGVzL2xpZ2h0aW5nL0xpZ2h0VXRpbHMuanMiLCIuLi9zcmMvbm9kZXMvbGlnaHRpbmcvUG9pbnRTaGFkb3dOb2RlLmpzIiwiLi4vc3JjL25vZGVzL2xpZ2h0aW5nL1BvaW50TGlnaHROb2RlLmpzIiwiLi4vc3JjL25vZGVzL3Byb2NlZHVyYWwvQ2hlY2tlci5qcyIsIi4uL3NyYy9ub2Rlcy9tYXRlcmlhbHgvbGliL214X25vaXNlLmpzIiwiLi4vc3JjL25vZGVzL21hdGVyaWFseC9saWIvbXhfaHN2LmpzIiwiLi4vc3JjL25vZGVzL21hdGVyaWFseC9saWIvbXhfdHJhbnNmb3JtX2NvbG9yLmpzIiwiLi4vc3JjL25vZGVzL21hdGVyaWFseC9NYXRlcmlhbFhOb2Rlcy5qcyIsIi4uL3NyYy9ub2Rlcy9mdW5jdGlvbnMvbWF0ZXJpYWwvZ2V0UGFyYWxsYXhDb3JyZWN0Tm9ybWFsLmpzIiwiLi4vc3JjL25vZGVzL2Z1bmN0aW9ucy9tYXRlcmlhbC9nZXRTaElycmFkaWFuY2VBdC5qcyIsIi4uL3NyYy9ub2Rlcy9UU0wuanMiLCIuLi9zcmMvcmVuZGVyZXJzL2NvbW1vbi9CYWNrZ3JvdW5kLmpzIiwiLi4vc3JjL3JlbmRlcmVycy9jb21tb24vQmluZEdyb3VwLmpzIiwiLi4vc3JjL3JlbmRlcmVycy9jb21tb24vbm9kZXMvTm9kZUJ1aWxkZXJTdGF0ZS5qcyIsIi4uL3NyYy9ub2Rlcy9jb3JlL05vZGVBdHRyaWJ1dGUuanMiLCIuLi9zcmMvbm9kZXMvY29yZS9Ob2RlVW5pZm9ybS5qcyIsIi4uL3NyYy9ub2Rlcy9jb3JlL05vZGVWYXIuanMiLCIuLi9zcmMvbm9kZXMvY29yZS9Ob2RlVmFyeWluZy5qcyIsIi4uL3NyYy9ub2Rlcy9jb3JlL05vZGVDb2RlLmpzIiwiLi4vc3JjL25vZGVzL2NvcmUvTm9kZUNhY2hlLmpzIiwiLi4vc3JjL25vZGVzL2NvcmUvU3RydWN0VHlwZU5vZGUuanMiLCIuLi9zcmMvcmVuZGVyZXJzL2NvbW1vbi9Vbmlmb3JtLmpzIiwiLi4vc3JjL3JlbmRlcmVycy9jb21tb24vbm9kZXMvTm9kZVVuaWZvcm0uanMiLCIuLi9zcmMvcmVuZGVyZXJzL2NvbW1vbi9leHRyYXMvUE1SRU1HZW5lcmF0b3IuanMiLCIuLi9zcmMvbm9kZXMvY29yZS9Ob2RlQnVpbGRlci5qcyIsIi4uL3NyYy9ub2Rlcy9jb3JlL05vZGVGcmFtZS5qcyIsIi4uL3NyYy9ub2Rlcy9jb3JlL05vZGVGdW5jdGlvbklucHV0LmpzIiwiLi4vc3JjL25vZGVzL2xpZ2h0aW5nL0RpcmVjdGlvbmFsTGlnaHROb2RlLmpzIiwiLi4vc3JjL25vZGVzL2xpZ2h0aW5nL1JlY3RBcmVhTGlnaHROb2RlLmpzIiwiLi4vc3JjL25vZGVzL2xpZ2h0aW5nL1Nwb3RMaWdodE5vZGUuanMiLCIuLi9zcmMvbm9kZXMvbGlnaHRpbmcvSUVTU3BvdExpZ2h0Tm9kZS5qcyIsIi4uL3NyYy9ub2Rlcy9saWdodGluZy9BbWJpZW50TGlnaHROb2RlLmpzIiwiLi4vc3JjL25vZGVzL2xpZ2h0aW5nL0hlbWlzcGhlcmVMaWdodE5vZGUuanMiLCIuLi9zcmMvbm9kZXMvbGlnaHRpbmcvTGlnaHRQcm9iZU5vZGUuanMiLCIuLi9zcmMvbm9kZXMvY29yZS9Ob2RlUGFyc2VyLmpzIiwiLi4vc3JjL25vZGVzL2NvcmUvTm9kZUZ1bmN0aW9uLmpzIiwiLi4vc3JjL25vZGVzL3BhcnNlcnMvR0xTTE5vZGVGdW5jdGlvbi5qcyIsIi4uL3NyYy9ub2Rlcy9wYXJzZXJzL0dMU0xOb2RlUGFyc2VyLmpzIiwiLi4vc3JjL3JlbmRlcmVycy9jb21tb24vbm9kZXMvTm9kZXMuanMiLCIuLi9zcmMvcmVuZGVyZXJzL2NvbW1vbi9DbGlwcGluZ0NvbnRleHQuanMiLCIuLi9zcmMvcmVuZGVyZXJzL2NvbW1vbi9SZW5kZXJCdW5kbGUuanMiLCIuLi9zcmMvcmVuZGVyZXJzL2NvbW1vbi9SZW5kZXJCdW5kbGVzLmpzIiwiLi4vc3JjL3JlbmRlcmVycy9jb21tb24vbm9kZXMvTm9kZUxpYnJhcnkuanMiLCIuLi9zcmMvcmVuZGVyZXJzL2NvbW1vbi9MaWdodGluZy5qcyIsIi4uL3NyYy9yZW5kZXJlcnMvY29tbW9uL1JlbmRlcmVyLmpzIiwiLi4vc3JjL3JlbmRlcmVycy9jb21tb24vQmluZGluZy5qcyIsIi4uL3NyYy9yZW5kZXJlcnMvY29tbW9uL0J1ZmZlclV0aWxzLmpzIiwiLi4vc3JjL3JlbmRlcmVycy9jb21tb24vQnVmZmVyLmpzIiwiLi4vc3JjL3JlbmRlcmVycy9jb21tb24vVW5pZm9ybUJ1ZmZlci5qcyIsIi4uL3NyYy9yZW5kZXJlcnMvY29tbW9uL25vZGVzL05vZGVVbmlmb3JtQnVmZmVyLmpzIiwiLi4vc3JjL3JlbmRlcmVycy9jb21tb24vVW5pZm9ybXNHcm91cC5qcyIsIi4uL3NyYy9yZW5kZXJlcnMvY29tbW9uL25vZGVzL05vZGVVbmlmb3Jtc0dyb3VwLmpzIiwiLi4vc3JjL3JlbmRlcmVycy9jb21tb24vU2FtcGxlZFRleHR1cmUuanMiLCIuLi9zcmMvcmVuZGVyZXJzL2NvbW1vbi9ub2Rlcy9Ob2RlU2FtcGxlZFRleHR1cmUuanMiLCIuLi9zcmMvcmVuZGVyZXJzL3dlYmdsLWZhbGxiYWNrL25vZGVzL0dMU0xOb2RlQnVpbGRlci5qcyIsIi4uL3NyYy9yZW5kZXJlcnMvY29tbW9uL0JhY2tlbmQuanMiLCIuLi9zcmMvcmVuZGVyZXJzL3dlYmdsLWZhbGxiYWNrL3V0aWxzL1dlYkdMQXR0cmlidXRlVXRpbHMuanMiLCIuLi9zcmMvcmVuZGVyZXJzL3dlYmdsLWZhbGxiYWNrL3V0aWxzL1dlYkdMU3RhdGUuanMiLCIuLi9zcmMvcmVuZGVyZXJzL3dlYmdsLWZhbGxiYWNrL3V0aWxzL1dlYkdMVXRpbHMuanMiLCIuLi9zcmMvcmVuZGVyZXJzL3dlYmdsLWZhbGxiYWNrL3V0aWxzL1dlYkdMVGV4dHVyZVV0aWxzLmpzIiwiLi4vc3JjL3JlbmRlcmVycy93ZWJnbC1mYWxsYmFjay91dGlscy9XZWJHTEV4dGVuc2lvbnMuanMiLCIuLi9zcmMvcmVuZGVyZXJzL3dlYmdsLWZhbGxiYWNrL3V0aWxzL1dlYkdMQ2FwYWJpbGl0aWVzLmpzIiwiLi4vc3JjL3JlbmRlcmVycy93ZWJnbC1mYWxsYmFjay91dGlscy9XZWJHTENvbnN0YW50cy5qcyIsIi4uL3NyYy9yZW5kZXJlcnMvd2ViZ2wtZmFsbGJhY2svV2ViR0xCdWZmZXJSZW5kZXJlci5qcyIsIi4uL3NyYy9yZW5kZXJlcnMvd2ViZ2wtZmFsbGJhY2svV2ViR0xCYWNrZW5kLmpzIiwiLi4vc3JjL3JlbmRlcmVycy93ZWJncHUvdXRpbHMvV2ViR1BVQ29uc3RhbnRzLmpzIiwiLi4vc3JjL3JlbmRlcmVycy9jb21tb24vU2FtcGxlci5qcyIsIi4uL3NyYy9yZW5kZXJlcnMvY29tbW9uL25vZGVzL05vZGVTYW1wbGVyLmpzIiwiLi4vc3JjL3JlbmRlcmVycy9jb21tb24vU3RvcmFnZUJ1ZmZlci5qcyIsIi4uL3NyYy9yZW5kZXJlcnMvY29tbW9uL25vZGVzL05vZGVTdG9yYWdlQnVmZmVyLmpzIiwiLi4vc3JjL3JlbmRlcmVycy93ZWJncHUvdXRpbHMvV2ViR1BVVGV4dHVyZVBhc3NVdGlscy5qcyIsIi4uL3NyYy9yZW5kZXJlcnMvd2ViZ3B1L3V0aWxzL1dlYkdQVVRleHR1cmVVdGlscy5qcyIsIi4uL3NyYy9yZW5kZXJlcnMvd2ViZ3B1L25vZGVzL1dHU0xOb2RlRnVuY3Rpb24uanMiLCIuLi9zcmMvcmVuZGVyZXJzL3dlYmdwdS9ub2Rlcy9XR1NMTm9kZVBhcnNlci5qcyIsIi4uL3NyYy9yZW5kZXJlcnMvd2ViZ3B1L25vZGVzL1dHU0xOb2RlQnVpbGRlci5qcyIsIi4uL3NyYy9yZW5kZXJlcnMvd2ViZ3B1L3V0aWxzL1dlYkdQVVV0aWxzLmpzIiwiLi4vc3JjL3JlbmRlcmVycy93ZWJncHUvdXRpbHMvV2ViR1BVQXR0cmlidXRlVXRpbHMuanMiLCIuLi9zcmMvcmVuZGVyZXJzL3dlYmdwdS91dGlscy9XZWJHUFVCaW5kaW5nVXRpbHMuanMiLCIuLi9zcmMvcmVuZGVyZXJzL3dlYmdwdS91dGlscy9XZWJHUFVQaXBlbGluZVV0aWxzLmpzIiwiLi4vc3JjL3JlbmRlcmVycy93ZWJncHUvV2ViR1BVQmFja2VuZC5qcyIsIi4uL3NyYy9saWdodHMvd2ViZ3B1L0lFU1Nwb3RMaWdodC5qcyIsIi4uL3NyYy9yZW5kZXJlcnMvd2ViZ3B1L25vZGVzL0Jhc2ljTm9kZUxpYnJhcnkuanMiLCIuLi9zcmMvcmVuZGVyZXJzL3dlYmdwdS9XZWJHUFVSZW5kZXJlci5Ob2Rlcy5qcyIsIi4uL3NyYy9yZW5kZXJlcnMvY29tbW9uL0J1bmRsZUdyb3VwLmpzIiwiLi4vc3JjL3JlbmRlcmVycy9jb21tb24vUG9zdFByb2Nlc3NpbmcuanMiLCIuLi9zcmMvcmVuZGVyZXJzL2NvbW1vbi9Qb3N0UHJvY2Vzc2luZ1V0aWxzLmpzIiwiLi4vc3JjL3JlbmRlcmVycy9jb21tb24vU3RvcmFnZVRleHR1cmUuanMiLCIuLi9zcmMvcmVuZGVyZXJzL2NvbW1vbi9JbmRpcmVjdFN0b3JhZ2VCdWZmZXJBdHRyaWJ1dGUuanMiLCIuLi9zcmMvbG9hZGVycy9ub2Rlcy9Ob2RlTG9hZGVyLmpzIiwiLi4vc3JjL2xvYWRlcnMvbm9kZXMvTm9kZU1hdGVyaWFsTG9hZGVyLmpzIiwiLi4vc3JjL2xvYWRlcnMvbm9kZXMvTm9kZU9iamVjdExvYWRlci5qcyIsIi4uL3NyYy9vYmplY3RzL0NsaXBwaW5nR3JvdXAuanMiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgcmVmcmVzaFVuaWZvcm1zID0gW1xyXG5cdCdhbHBoYU1hcCcsXHJcblx0J2FscGhhVGVzdCcsXHJcblx0J2FuaXNvdHJvcHknLFxyXG5cdCdhbmlzb3Ryb3B5TWFwJyxcclxuXHQnYW5pc290cm9weVJvdGF0aW9uJyxcclxuXHQnYW9NYXAnLFxyXG5cdCdhdHRlbnVhdGlvbkNvbG9yJyxcclxuXHQnYXR0ZW51YXRpb25EaXN0YW5jZScsXHJcblx0J2J1bXBNYXAnLFxyXG5cdCdjbGVhcmNvYXQnLFxyXG5cdCdjbGVhcmNvYXRNYXAnLFxyXG5cdCdjbGVhcmNvYXROb3JtYWxNYXAnLFxyXG5cdCdjbGVhcmNvYXROb3JtYWxTY2FsZScsXHJcblx0J2NsZWFyY29hdFJvdWdobmVzcycsXHJcblx0J2NvbG9yJyxcclxuXHQnZGlzcGVyc2lvbicsXHJcblx0J2Rpc3BsYWNlbWVudE1hcCcsXHJcblx0J2VtaXNzaXZlJyxcclxuXHQnZW1pc3NpdmVNYXAnLFxyXG5cdCdlbnZNYXAnLFxyXG5cdCdncmFkaWVudE1hcCcsXHJcblx0J2lvcicsXHJcblx0J2lyaWRlc2NlbmNlJyxcclxuXHQnaXJpZGVzY2VuY2VJT1InLFxyXG5cdCdpcmlkZXNjZW5jZU1hcCcsXHJcblx0J2lyaWRlc2NlbmNlVGhpY2tuZXNzTWFwJyxcclxuXHQnbGlnaHRNYXAnLFxyXG5cdCdtYXAnLFxyXG5cdCdtYXRjYXAnLFxyXG5cdCdtZXRhbG5lc3MnLFxyXG5cdCdtZXRhbG5lc3NNYXAnLFxyXG5cdCdub3JtYWxNYXAnLFxyXG5cdCdub3JtYWxTY2FsZScsXHJcblx0J29wYWNpdHknLFxyXG5cdCdyb3VnaG5lc3MnLFxyXG5cdCdyb3VnaG5lc3NNYXAnLFxyXG5cdCdzaGVlbicsXHJcblx0J3NoZWVuQ29sb3InLFxyXG5cdCdzaGVlbkNvbG9yTWFwJyxcclxuXHQnc2hlZW5Sb3VnaG5lc3NNYXAnLFxyXG5cdCdzaGluaW5lc3MnLFxyXG5cdCdzcGVjdWxhcicsXHJcblx0J3NwZWN1bGFyQ29sb3InLFxyXG5cdCdzcGVjdWxhckNvbG9yTWFwJyxcclxuXHQnc3BlY3VsYXJJbnRlbnNpdHknLFxyXG5cdCdzcGVjdWxhckludGVuc2l0eU1hcCcsXHJcblx0J3NwZWN1bGFyTWFwJyxcclxuXHQndGhpY2tuZXNzJyxcclxuXHQndHJhbnNtaXNzaW9uJyxcclxuXHQndHJhbnNtaXNzaW9uTWFwJ1xyXG5dO1xyXG5cclxuY2xhc3MgTm9kZU1hdGVyaWFsT2JzZXJ2ZXIge1xyXG5cclxuXHRjb25zdHJ1Y3RvciggYnVpbGRlciApIHtcclxuXHJcblx0XHR0aGlzLnJlbmRlck9iamVjdHMgPSBuZXcgV2Vha01hcCgpO1xyXG5cdFx0dGhpcy5oYXNOb2RlID0gdGhpcy5jb250YWluc05vZGUoIGJ1aWxkZXIgKTtcclxuXHRcdHRoaXMuaGFzQW5pbWF0aW9uID0gYnVpbGRlci5vYmplY3QuaXNTa2lubmVkTWVzaCA9PT0gdHJ1ZTtcclxuXHRcdHRoaXMucmVmcmVzaFVuaWZvcm1zID0gcmVmcmVzaFVuaWZvcm1zO1xyXG5cdFx0dGhpcy5yZW5kZXJJZCA9IDA7XHJcblxyXG5cdH1cclxuXHJcblx0Zmlyc3RJbml0aWFsaXphdGlvbiggcmVuZGVyT2JqZWN0ICkge1xyXG5cclxuXHRcdGNvbnN0IGhhc0luaXRpYWxpemVkID0gdGhpcy5yZW5kZXJPYmplY3RzLmhhcyggcmVuZGVyT2JqZWN0ICk7XHJcblxyXG5cdFx0aWYgKCBoYXNJbml0aWFsaXplZCA9PT0gZmFsc2UgKSB7XHJcblxyXG5cdFx0XHR0aGlzLmdldFJlbmRlck9iamVjdERhdGEoIHJlbmRlck9iamVjdCApO1xyXG5cclxuXHRcdFx0cmV0dXJuIHRydWU7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBmYWxzZTtcclxuXHJcblx0fVxyXG5cclxuXHRnZXRSZW5kZXJPYmplY3REYXRhKCByZW5kZXJPYmplY3QgKSB7XHJcblxyXG5cdFx0bGV0IGRhdGEgPSB0aGlzLnJlbmRlck9iamVjdHMuZ2V0KCByZW5kZXJPYmplY3QgKTtcclxuXHJcblx0XHRpZiAoIGRhdGEgPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdGNvbnN0IHsgZ2VvbWV0cnksIG1hdGVyaWFsLCBvYmplY3QgfSA9IHJlbmRlck9iamVjdDtcclxuXHJcblx0XHRcdGRhdGEgPSB7XHJcblx0XHRcdFx0bWF0ZXJpYWw6IHRoaXMuZ2V0TWF0ZXJpYWxEYXRhKCBtYXRlcmlhbCApLFxyXG5cdFx0XHRcdGdlb21ldHJ5OiB7XHJcblx0XHRcdFx0XHRhdHRyaWJ1dGVzOiB0aGlzLmdldEF0dHJpYnV0ZXNEYXRhKCBnZW9tZXRyeS5hdHRyaWJ1dGVzICksXHJcblx0XHRcdFx0XHRpbmRleFZlcnNpb246IGdlb21ldHJ5LmluZGV4ID8gZ2VvbWV0cnkuaW5kZXgudmVyc2lvbiA6IG51bGwsXHJcblx0XHRcdFx0XHRkcmF3UmFuZ2U6IHsgc3RhcnQ6IGdlb21ldHJ5LmRyYXdSYW5nZS5zdGFydCwgY291bnQ6IGdlb21ldHJ5LmRyYXdSYW5nZS5jb3VudCB9XHJcblx0XHRcdFx0fSxcclxuXHRcdFx0XHR3b3JsZE1hdHJpeDogb2JqZWN0Lm1hdHJpeFdvcmxkLmNsb25lKClcclxuXHRcdFx0fTtcclxuXHJcblx0XHRcdGlmICggb2JqZWN0LmNlbnRlciApIHtcclxuXHJcblx0XHRcdFx0ZGF0YS5jZW50ZXIgPSBvYmplY3QuY2VudGVyLmNsb25lKCk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoIG9iamVjdC5tb3JwaFRhcmdldEluZmx1ZW5jZXMgKSB7XHJcblxyXG5cdFx0XHRcdGRhdGEubW9ycGhUYXJnZXRJbmZsdWVuY2VzID0gb2JqZWN0Lm1vcnBoVGFyZ2V0SW5mbHVlbmNlcy5zbGljZSgpO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKCByZW5kZXJPYmplY3QuYnVuZGxlICE9PSBudWxsICkge1xyXG5cclxuXHRcdFx0XHRkYXRhLnZlcnNpb24gPSByZW5kZXJPYmplY3QuYnVuZGxlLnZlcnNpb247XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoIGRhdGEubWF0ZXJpYWwudHJhbnNtaXNzaW9uID4gMCApIHtcclxuXHJcblx0XHRcdFx0Y29uc3QgeyB3aWR0aCwgaGVpZ2h0IH0gPSByZW5kZXJPYmplY3QuY29udGV4dDtcclxuXHJcblx0XHRcdFx0ZGF0YS5idWZmZXJXaWR0aCA9IHdpZHRoO1xyXG5cdFx0XHRcdGRhdGEuYnVmZmVySGVpZ2h0ID0gaGVpZ2h0O1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dGhpcy5yZW5kZXJPYmplY3RzLnNldCggcmVuZGVyT2JqZWN0LCBkYXRhICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBkYXRhO1xyXG5cclxuXHR9XHJcblxyXG5cdGdldEF0dHJpYnV0ZXNEYXRhKCBhdHRyaWJ1dGVzICkge1xyXG5cclxuXHRcdGNvbnN0IGF0dHJpYnV0ZXNEYXRhID0ge307XHJcblxyXG5cdFx0Zm9yICggY29uc3QgbmFtZSBpbiBhdHRyaWJ1dGVzICkge1xyXG5cclxuXHRcdFx0Y29uc3QgYXR0cmlidXRlID0gYXR0cmlidXRlc1sgbmFtZSBdO1xyXG5cclxuXHRcdFx0YXR0cmlidXRlc0RhdGFbIG5hbWUgXSA9IHtcclxuXHRcdFx0XHR2ZXJzaW9uOiBhdHRyaWJ1dGUudmVyc2lvblxyXG5cdFx0XHR9O1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gYXR0cmlidXRlc0RhdGE7XHJcblxyXG5cdH1cclxuXHJcblx0Y29udGFpbnNOb2RlKCBidWlsZGVyICkge1xyXG5cclxuXHRcdGNvbnN0IG1hdGVyaWFsID0gYnVpbGRlci5tYXRlcmlhbDtcclxuXHJcblx0XHRmb3IgKCBjb25zdCBwcm9wZXJ0eSBpbiBtYXRlcmlhbCApIHtcclxuXHJcblx0XHRcdGlmICggbWF0ZXJpYWxbIHByb3BlcnR5IF0gJiYgbWF0ZXJpYWxbIHByb3BlcnR5IF0uaXNOb2RlIClcclxuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBidWlsZGVyLnJlbmRlcmVyLm5vZGVzLm1vZGVsVmlld01hdHJpeCAhPT0gbnVsbCB8fCBidWlsZGVyLnJlbmRlcmVyLm5vZGVzLm1vZGVsTm9ybWFsVmlld01hdHJpeCAhPT0gbnVsbCApXHJcblx0XHRcdHJldHVybiB0cnVlO1xyXG5cclxuXHRcdHJldHVybiBmYWxzZTtcclxuXHJcblx0fVxyXG5cclxuXHRnZXRNYXRlcmlhbERhdGEoIG1hdGVyaWFsICkge1xyXG5cclxuXHRcdGNvbnN0IGRhdGEgPSB7fTtcclxuXHJcblx0XHRmb3IgKCBjb25zdCBwcm9wZXJ0eSBvZiB0aGlzLnJlZnJlc2hVbmlmb3JtcyApIHtcclxuXHJcblx0XHRcdGNvbnN0IHZhbHVlID0gbWF0ZXJpYWxbIHByb3BlcnR5IF07XHJcblxyXG5cdFx0XHRpZiAoIHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWQgKSBjb250aW51ZTtcclxuXHJcblx0XHRcdGlmICggdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZS5jbG9uZSAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRpZiAoIHZhbHVlLmlzVGV4dHVyZSA9PT0gdHJ1ZSApIHtcclxuXHJcblx0XHRcdFx0XHRkYXRhWyBwcm9wZXJ0eSBdID0geyBpZDogdmFsdWUuaWQsIHZlcnNpb246IHZhbHVlLnZlcnNpb24gfTtcclxuXHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHRkYXRhWyBwcm9wZXJ0eSBdID0gdmFsdWUuY2xvbmUoKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0ZGF0YVsgcHJvcGVydHkgXSA9IHZhbHVlO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gZGF0YTtcclxuXHJcblx0fVxyXG5cclxuXHRlcXVhbHMoIHJlbmRlck9iamVjdCApIHtcclxuXHJcblx0XHRjb25zdCB7IG9iamVjdCwgbWF0ZXJpYWwsIGdlb21ldHJ5IH0gPSByZW5kZXJPYmplY3Q7XHJcblxyXG5cdFx0Y29uc3QgcmVuZGVyT2JqZWN0RGF0YSA9IHRoaXMuZ2V0UmVuZGVyT2JqZWN0RGF0YSggcmVuZGVyT2JqZWN0ICk7XHJcblxyXG5cdFx0Ly8gd29ybGQgbWF0cml4XHJcblxyXG5cdFx0aWYgKCByZW5kZXJPYmplY3REYXRhLndvcmxkTWF0cml4LmVxdWFscyggb2JqZWN0Lm1hdHJpeFdvcmxkICkgIT09IHRydWUgKSB7XHJcblxyXG5cdFx0XHRyZW5kZXJPYmplY3REYXRhLndvcmxkTWF0cml4LmNvcHkoIG9iamVjdC5tYXRyaXhXb3JsZCApO1xyXG5cclxuXHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvLyBtYXRlcmlhbFxyXG5cclxuXHRcdGNvbnN0IG1hdGVyaWFsRGF0YSA9IHJlbmRlck9iamVjdERhdGEubWF0ZXJpYWw7XHJcblxyXG5cdFx0Zm9yICggY29uc3QgcHJvcGVydHkgaW4gbWF0ZXJpYWxEYXRhICkge1xyXG5cclxuXHRcdFx0Y29uc3QgdmFsdWUgPSBtYXRlcmlhbERhdGFbIHByb3BlcnR5IF07XHJcblx0XHRcdGNvbnN0IG10bFZhbHVlID0gbWF0ZXJpYWxbIHByb3BlcnR5IF07XHJcblxyXG5cdFx0XHRpZiAoIHZhbHVlLmVxdWFscyAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRpZiAoIHZhbHVlLmVxdWFscyggbXRsVmFsdWUgKSA9PT0gZmFsc2UgKSB7XHJcblxyXG5cdFx0XHRcdFx0dmFsdWUuY29weSggbXRsVmFsdWUgKTtcclxuXHJcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH0gZWxzZSBpZiAoIG10bFZhbHVlLmlzVGV4dHVyZSA9PT0gdHJ1ZSApIHtcclxuXHJcblx0XHRcdFx0aWYgKCB2YWx1ZS5pZCAhPT0gbXRsVmFsdWUuaWQgfHwgdmFsdWUudmVyc2lvbiAhPT0gbXRsVmFsdWUudmVyc2lvbiApIHtcclxuXHJcblx0XHRcdFx0XHR2YWx1ZS5pZCA9IG10bFZhbHVlLmlkO1xyXG5cdFx0XHRcdFx0dmFsdWUudmVyc2lvbiA9IG10bFZhbHVlLnZlcnNpb247XHJcblxyXG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9IGVsc2UgaWYgKCB2YWx1ZSAhPT0gbXRsVmFsdWUgKSB7XHJcblxyXG5cdFx0XHRcdG1hdGVyaWFsRGF0YVsgcHJvcGVydHkgXSA9IG10bFZhbHVlO1xyXG5cclxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggbWF0ZXJpYWxEYXRhLnRyYW5zbWlzc2lvbiA+IDAgKSB7XHJcblxyXG5cdFx0XHRjb25zdCB7IHdpZHRoLCBoZWlnaHQgfSA9IHJlbmRlck9iamVjdC5jb250ZXh0O1xyXG5cclxuXHRcdFx0aWYgKCByZW5kZXJPYmplY3REYXRhLmJ1ZmZlcldpZHRoICE9PSB3aWR0aCB8fCByZW5kZXJPYmplY3REYXRhLmJ1ZmZlckhlaWdodCAhPT0gaGVpZ2h0ICkge1xyXG5cclxuXHRcdFx0XHRyZW5kZXJPYmplY3REYXRhLmJ1ZmZlcldpZHRoID0gd2lkdGg7XHJcblx0XHRcdFx0cmVuZGVyT2JqZWN0RGF0YS5idWZmZXJIZWlnaHQgPSBoZWlnaHQ7XHJcblxyXG5cdFx0XHRcdHJldHVybiBmYWxzZTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gZ2VvbWV0cnlcclxuXHJcblx0XHRjb25zdCBzdG9yZWRHZW9tZXRyeURhdGEgPSByZW5kZXJPYmplY3REYXRhLmdlb21ldHJ5O1xyXG5cdFx0Y29uc3QgYXR0cmlidXRlcyA9IGdlb21ldHJ5LmF0dHJpYnV0ZXM7XHJcblx0XHRjb25zdCBzdG9yZWRBdHRyaWJ1dGVzID0gc3RvcmVkR2VvbWV0cnlEYXRhLmF0dHJpYnV0ZXM7XHJcblxyXG5cdFx0Y29uc3Qgc3RvcmVkQXR0cmlidXRlTmFtZXMgPSBPYmplY3Qua2V5cyggc3RvcmVkQXR0cmlidXRlcyApO1xyXG5cdFx0Y29uc3QgY3VycmVudEF0dHJpYnV0ZU5hbWVzID0gT2JqZWN0LmtleXMoIGF0dHJpYnV0ZXMgKTtcclxuXHJcblx0XHRpZiAoIHN0b3JlZEF0dHJpYnV0ZU5hbWVzLmxlbmd0aCAhPT0gY3VycmVudEF0dHJpYnV0ZU5hbWVzLmxlbmd0aCApIHtcclxuXHJcblx0XHRcdHJlbmRlck9iamVjdERhdGEuZ2VvbWV0cnkuYXR0cmlidXRlcyA9IHRoaXMuZ2V0QXR0cmlidXRlc0RhdGEoIGF0dHJpYnV0ZXMgKTtcclxuXHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvLyBjb21wYXJlIGVhY2ggYXR0cmlidXRlXHJcblxyXG5cdFx0Zm9yICggY29uc3QgbmFtZSBvZiBzdG9yZWRBdHRyaWJ1dGVOYW1lcyApIHtcclxuXHJcblx0XHRcdGNvbnN0IHN0b3JlZEF0dHJpYnV0ZURhdGEgPSBzdG9yZWRBdHRyaWJ1dGVzWyBuYW1lIF07XHJcblx0XHRcdGNvbnN0IGF0dHJpYnV0ZSA9IGF0dHJpYnV0ZXNbIG5hbWUgXTtcclxuXHJcblx0XHRcdGlmICggYXR0cmlidXRlID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdC8vIGF0dHJpYnV0ZSB3YXMgcmVtb3ZlZFxyXG5cdFx0XHRcdGRlbGV0ZSBzdG9yZWRBdHRyaWJ1dGVzWyBuYW1lIF07XHJcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKCBzdG9yZWRBdHRyaWJ1dGVEYXRhLnZlcnNpb24gIT09IGF0dHJpYnV0ZS52ZXJzaW9uICkge1xyXG5cclxuXHRcdFx0XHRzdG9yZWRBdHRyaWJ1dGVEYXRhLnZlcnNpb24gPSBhdHRyaWJ1dGUudmVyc2lvbjtcclxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIGNoZWNrIGluZGV4XHJcblxyXG5cdFx0Y29uc3QgaW5kZXggPSBnZW9tZXRyeS5pbmRleDtcclxuXHRcdGNvbnN0IHN0b3JlZEluZGV4VmVyc2lvbiA9IHN0b3JlZEdlb21ldHJ5RGF0YS5pbmRleFZlcnNpb247XHJcblx0XHRjb25zdCBjdXJyZW50SW5kZXhWZXJzaW9uID0gaW5kZXggPyBpbmRleC52ZXJzaW9uIDogbnVsbDtcclxuXHJcblx0XHRpZiAoIHN0b3JlZEluZGV4VmVyc2lvbiAhPT0gY3VycmVudEluZGV4VmVyc2lvbiApIHtcclxuXHJcblx0XHRcdHN0b3JlZEdlb21ldHJ5RGF0YS5pbmRleFZlcnNpb24gPSBjdXJyZW50SW5kZXhWZXJzaW9uO1xyXG5cdFx0XHRyZXR1cm4gZmFsc2U7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIGNoZWNrIGRyYXdSYW5nZVxyXG5cclxuXHRcdGlmICggc3RvcmVkR2VvbWV0cnlEYXRhLmRyYXdSYW5nZS5zdGFydCAhPT0gZ2VvbWV0cnkuZHJhd1JhbmdlLnN0YXJ0IHx8IHN0b3JlZEdlb21ldHJ5RGF0YS5kcmF3UmFuZ2UuY291bnQgIT09IGdlb21ldHJ5LmRyYXdSYW5nZS5jb3VudCApIHtcclxuXHJcblx0XHRcdHN0b3JlZEdlb21ldHJ5RGF0YS5kcmF3UmFuZ2Uuc3RhcnQgPSBnZW9tZXRyeS5kcmF3UmFuZ2Uuc3RhcnQ7XHJcblx0XHRcdHN0b3JlZEdlb21ldHJ5RGF0YS5kcmF3UmFuZ2UuY291bnQgPSBnZW9tZXRyeS5kcmF3UmFuZ2UuY291bnQ7XHJcblx0XHRcdHJldHVybiBmYWxzZTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gbW9ycGggdGFyZ2V0c1xyXG5cclxuXHRcdGlmICggcmVuZGVyT2JqZWN0RGF0YS5tb3JwaFRhcmdldEluZmx1ZW5jZXMgKSB7XHJcblxyXG5cdFx0XHRsZXQgbW9ycGhDaGFuZ2VkID0gZmFsc2U7XHJcblxyXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCByZW5kZXJPYmplY3REYXRhLm1vcnBoVGFyZ2V0SW5mbHVlbmNlcy5sZW5ndGg7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdGlmICggcmVuZGVyT2JqZWN0RGF0YS5tb3JwaFRhcmdldEluZmx1ZW5jZXNbIGkgXSAhPT0gb2JqZWN0Lm1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgaSBdICkge1xyXG5cclxuXHRcdFx0XHRcdG1vcnBoQ2hhbmdlZCA9IHRydWU7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICggbW9ycGhDaGFuZ2VkICkgcmV0dXJuIHRydWU7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIGNlbnRlclxyXG5cclxuXHRcdGlmICggcmVuZGVyT2JqZWN0RGF0YS5jZW50ZXIgKSB7XHJcblxyXG5cdFx0XHRpZiAoIHJlbmRlck9iamVjdERhdGEuY2VudGVyLmVxdWFscyggb2JqZWN0LmNlbnRlciApID09PSBmYWxzZSApIHtcclxuXHJcblx0XHRcdFx0cmVuZGVyT2JqZWN0RGF0YS5jZW50ZXIuY29weSggb2JqZWN0LmNlbnRlciApO1xyXG5cclxuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gYnVuZGxlXHJcblxyXG5cdFx0aWYgKCByZW5kZXJPYmplY3QuYnVuZGxlICE9PSBudWxsICkge1xyXG5cclxuXHRcdFx0cmVuZGVyT2JqZWN0RGF0YS52ZXJzaW9uID0gcmVuZGVyT2JqZWN0LmJ1bmRsZS52ZXJzaW9uO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdHJ1ZTtcclxuXHJcblx0fVxyXG5cclxuXHRuZWVkc1JlZnJlc2goIHJlbmRlck9iamVjdCwgbm9kZUZyYW1lICkge1xyXG5cclxuXHRcdGlmICggdGhpcy5oYXNOb2RlIHx8IHRoaXMuaGFzQW5pbWF0aW9uIHx8IHRoaXMuZmlyc3RJbml0aWFsaXphdGlvbiggcmVuZGVyT2JqZWN0ICkgKVxyXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcclxuXHJcblx0XHRjb25zdCB7IHJlbmRlcklkIH0gPSBub2RlRnJhbWU7XHJcblxyXG5cdFx0aWYgKCB0aGlzLnJlbmRlcklkICE9PSByZW5kZXJJZCApIHtcclxuXHJcblx0XHRcdHRoaXMucmVuZGVySWQgPSByZW5kZXJJZDtcclxuXHJcblx0XHRcdHJldHVybiB0cnVlO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRjb25zdCBpc1N0YXRpYyA9IHJlbmRlck9iamVjdC5vYmplY3Quc3RhdGljID09PSB0cnVlO1xyXG5cdFx0Y29uc3QgaXNCdW5kbGUgPSByZW5kZXJPYmplY3QuYnVuZGxlICE9PSBudWxsICYmIHJlbmRlck9iamVjdC5idW5kbGUuc3RhdGljID09PSB0cnVlICYmIHRoaXMuZ2V0UmVuZGVyT2JqZWN0RGF0YSggcmVuZGVyT2JqZWN0ICkudmVyc2lvbiA9PT0gcmVuZGVyT2JqZWN0LmJ1bmRsZS52ZXJzaW9uO1xyXG5cclxuXHRcdGlmICggaXNTdGF0aWMgfHwgaXNCdW5kbGUgKVxyXG5cdFx0XHRyZXR1cm4gZmFsc2U7XHJcblxyXG5cdFx0Y29uc3Qgbm90RXF1YWwgPSB0aGlzLmVxdWFscyggcmVuZGVyT2JqZWN0ICkgIT09IHRydWU7XHJcblxyXG5cdFx0cmV0dXJuIG5vdEVxdWFsO1xyXG5cclxuXHR9XHJcblxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBOb2RlTWF0ZXJpYWxPYnNlcnZlcjtcclxuIiwiaW1wb3J0IHsgQ29sb3IgfSBmcm9tICcuLi8uLi9tYXRoL0NvbG9yLmpzJztcclxuaW1wb3J0IHsgTWF0cml4MyB9IGZyb20gJy4uLy4uL21hdGgvTWF0cml4My5qcyc7XHJcbmltcG9ydCB7IE1hdHJpeDQgfSBmcm9tICcuLi8uLi9tYXRoL01hdHJpeDQuanMnO1xyXG5pbXBvcnQgeyBWZWN0b3IyIH0gZnJvbSAnLi4vLi4vbWF0aC9WZWN0b3IyLmpzJztcclxuaW1wb3J0IHsgVmVjdG9yMyB9IGZyb20gJy4uLy4uL21hdGgvVmVjdG9yMy5qcyc7XHJcbmltcG9ydCB7IFZlY3RvcjQgfSBmcm9tICcuLi8uLi9tYXRoL1ZlY3RvcjQuanMnO1xyXG5cclxuLyoqIEBtb2R1bGUgTm9kZVV0aWxzICoqL1xyXG5cclxuLy8gY3lyYjUzIChjKSAyMDE4IGJyeWMgKGdpdGh1Yi5jb20vYnJ5YykuIExpY2Vuc2U6IFB1YmxpYyBkb21haW4uIEF0dHJpYnV0aW9uIGFwcHJlY2lhdGVkLlxyXG4vLyBBIGZhc3QgYW5kIHNpbXBsZSA2NC1iaXQgKG9yIDUzLWJpdCkgc3RyaW5nIGhhc2ggZnVuY3Rpb24gd2l0aCBkZWNlbnQgY29sbGlzaW9uIHJlc2lzdGFuY2UuXHJcbi8vIExhcmdlbHkgaW5zcGlyZWQgYnkgTXVybXVySGFzaDIvMywgYnV0IHdpdGggYSBmb2N1cyBvbiBzcGVlZC9zaW1wbGljaXR5LlxyXG4vLyBTZWUgaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNzYxNjQ2MS9nZW5lcmF0ZS1hLWhhc2gtZnJvbS1zdHJpbmctaW4tamF2YXNjcmlwdC81MjE3MTQ4MCM1MjE3MTQ4MFxyXG4vLyBodHRwczovL2dpdGh1Yi5jb20vYnJ5Yy9jb2RlL2Jsb2IvbWFzdGVyL2pzaGFzaC9leHBlcmltZW50YWwvY3lyYjUzLmpzXHJcbmZ1bmN0aW9uIGN5cmI1MyggdmFsdWUsIHNlZWQgPSAwICkge1xyXG5cclxuXHRsZXQgaDEgPSAweGRlYWRiZWVmIF4gc2VlZCwgaDIgPSAweDQxYzZjZTU3IF4gc2VlZDtcclxuXHJcblx0aWYgKCB2YWx1ZSBpbnN0YW5jZW9mIEFycmF5ICkge1xyXG5cclxuXHRcdGZvciAoIGxldCBpID0gMCwgdmFsOyBpIDwgdmFsdWUubGVuZ3RoOyBpICsrICkge1xyXG5cclxuXHRcdFx0dmFsID0gdmFsdWVbIGkgXTtcclxuXHRcdFx0aDEgPSBNYXRoLmltdWwoIGgxIF4gdmFsLCAyNjU0NDM1NzYxICk7XHJcblx0XHRcdGgyID0gTWF0aC5pbXVsKCBoMiBeIHZhbCwgMTU5NzMzNDY3NyApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fSBlbHNlIHtcclxuXHJcblx0XHRmb3IgKCBsZXQgaSA9IDAsIGNoOyBpIDwgdmFsdWUubGVuZ3RoOyBpICsrICkge1xyXG5cclxuXHRcdFx0Y2ggPSB2YWx1ZS5jaGFyQ29kZUF0KCBpICk7XHJcblx0XHRcdGgxID0gTWF0aC5pbXVsKCBoMSBeIGNoLCAyNjU0NDM1NzYxICk7XHJcblx0XHRcdGgyID0gTWF0aC5pbXVsKCBoMiBeIGNoLCAxNTk3MzM0Njc3ICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdGgxID0gTWF0aC5pbXVsKCBoMSBeICggaDEgPj4+IDE2ICksIDIyNDY4MjI1MDcgKTtcclxuXHRoMSBePSBNYXRoLmltdWwoIGgyIF4gKCBoMiA+Pj4gMTMgKSwgMzI2NjQ4OTkwOSApO1xyXG5cdGgyID0gTWF0aC5pbXVsKCBoMiBeICggaDIgPj4+IDE2ICksIDIyNDY4MjI1MDcgKTtcclxuXHRoMiBePSBNYXRoLmltdWwoIGgxIF4gKCBoMSA+Pj4gMTMgKSwgMzI2NjQ4OTkwOSApO1xyXG5cclxuXHRyZXR1cm4gNDI5NDk2NzI5NiAqICggMjA5NzE1MSAmIGgyICkgKyAoIGgxID4+PiAwICk7XHJcblxyXG59XHJcblxyXG4vKipcclxuICogQ29tcHV0ZXMgYSBoYXNoIGZvciB0aGUgZ2l2ZW4gc3RyaW5nLlxyXG4gKlxyXG4gKiBAbWV0aG9kXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgLSBUaGUgc3RyaW5nIHRvIGJlIGhhc2hlZC5cclxuICogQHJldHVybiB7TnVtYmVyfSBUaGUgaGFzaC5cclxuICovXHJcbmV4cG9ydCBjb25zdCBoYXNoU3RyaW5nID0gKCBzdHIgKSA9PiBjeXJiNTMoIHN0ciApO1xyXG5cclxuLyoqXHJcbiAqIENvbXB1dGVzIGEgaGFzaCBmb3IgdGhlIGdpdmVuIGFycmF5LlxyXG4gKlxyXG4gKiBAbWV0aG9kXHJcbiAqIEBwYXJhbSB7QXJyYXk8TnVtYmVyPn0gYXJyYXkgLSBUaGUgYXJyYXkgdG8gYmUgaGFzaGVkLlxyXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSBoYXNoLlxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IGhhc2hBcnJheSA9ICggYXJyYXkgKSA9PiBjeXJiNTMoIGFycmF5ICk7XHJcblxyXG4vKipcclxuICogQ29tcHV0ZXMgYSBoYXNoIGZvciB0aGUgZ2l2ZW4gbGlzdCBvZiBwYXJhbWV0ZXJzLlxyXG4gKlxyXG4gKiBAbWV0aG9kXHJcbiAqIEBwYXJhbSB7Li4uTnVtYmVyfSBwYXJhbXMgLSBBIGxpc3Qgb2YgcGFyYW1ldGVycy5cclxuICogQHJldHVybiB7TnVtYmVyfSBUaGUgaGFzaC5cclxuICovXHJcbmV4cG9ydCBjb25zdCBoYXNoID0gKCAuLi5wYXJhbXMgKSA9PiBjeXJiNTMoIHBhcmFtcyApO1xyXG5cclxuLyoqXHJcbiAqIENvbXB1dGVzIGEgY2FjaGUga2V5IGZvciB0aGUgZ2l2ZW4gbm9kZS5cclxuICpcclxuICogQG1ldGhvZFxyXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IC0gVGhlIG9iamVjdCB0byBiZSBoYXNoZWQuXHJcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW2ZvcmNlPWZhbHNlXSAtIFdoZXRoZXIgdG8gZm9yY2UgYSBjYWNoZSBrZXkgY29tcHV0YXRpb24gb3Igbm90LlxyXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSBoYXNoLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGdldENhY2hlS2V5KCBvYmplY3QsIGZvcmNlID0gZmFsc2UgKSB7XHJcblxyXG5cdGNvbnN0IHZhbHVlcyA9IFtdO1xyXG5cclxuXHRpZiAoIG9iamVjdC5pc05vZGUgPT09IHRydWUgKSB7XHJcblxyXG5cdFx0dmFsdWVzLnB1c2goIG9iamVjdC5pZCApO1xyXG5cdFx0b2JqZWN0ID0gb2JqZWN0LmdldFNlbGYoKTtcclxuXHJcblx0fVxyXG5cclxuXHRmb3IgKCBjb25zdCB7IHByb3BlcnR5LCBjaGlsZE5vZGUgfSBvZiBnZXROb2RlQ2hpbGRyZW4oIG9iamVjdCApICkge1xyXG5cclxuXHRcdHZhbHVlcy5wdXNoKCB2YWx1ZXMsIGN5cmI1MyggcHJvcGVydHkuc2xpY2UoIDAsIC0gNCApICksIGNoaWxkTm9kZS5nZXRDYWNoZUtleSggZm9yY2UgKSApO1xyXG5cclxuXHR9XHJcblxyXG5cdHJldHVybiBjeXJiNTMoIHZhbHVlcyApO1xyXG5cclxufVxyXG5cclxuLyoqXHJcbiAqIFRoaXMgZ2VuZXJhdG9yIGZ1bmN0aW9uIGNhbiBiZSB1c2VkIHRvIGl0ZXJhdGUgb3ZlciB0aGUgbm9kZSBjaGlsZHJlblxyXG4gKiBvZiB0aGUgZ2l2ZW4gb2JqZWN0LlxyXG4gKlxyXG4gKiBAZ2VuZXJhdG9yXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBub2RlIC0gVGhlIG9iamVjdCB0byBiZSBoYXNoZWQuXHJcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW3RvSlNPTj1mYWxzZV0gLSBXaGV0aGVyIHRvIHJldHVybiBKU09OIG9yIG5vdC5cclxuICogQHlpZWxkcyB7T2JqZWN0fSBBIHJlc3VsdCBub2RlIGhvbGRpbmcgdGhlIHByb3BlcnR5LCBpbmRleCAoaWYgYXZhaWxhYmxlKSBhbmQgdGhlIGNoaWxkIG5vZGUuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24qIGdldE5vZGVDaGlsZHJlbiggbm9kZSwgdG9KU09OID0gZmFsc2UgKSB7XHJcblxyXG5cdGZvciAoIGNvbnN0IHByb3BlcnR5IGluIG5vZGUgKSB7XHJcblxyXG5cdFx0Ly8gSWdub3JlIHByaXZhdGUgcHJvcGVydGllcy5cclxuXHRcdGlmICggcHJvcGVydHkuc3RhcnRzV2l0aCggJ18nICkgPT09IHRydWUgKSBjb250aW51ZTtcclxuXHJcblx0XHRjb25zdCBvYmplY3QgPSBub2RlWyBwcm9wZXJ0eSBdO1xyXG5cclxuXHRcdGlmICggQXJyYXkuaXNBcnJheSggb2JqZWN0ICkgPT09IHRydWUgKSB7XHJcblxyXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCBvYmplY3QubGVuZ3RoOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHRjb25zdCBjaGlsZCA9IG9iamVjdFsgaSBdO1xyXG5cclxuXHRcdFx0XHRpZiAoIGNoaWxkICYmICggY2hpbGQuaXNOb2RlID09PSB0cnVlIHx8IHRvSlNPTiAmJiB0eXBlb2YgY2hpbGQudG9KU09OID09PSAnZnVuY3Rpb24nICkgKSB7XHJcblxyXG5cdFx0XHRcdFx0eWllbGQgeyBwcm9wZXJ0eSwgaW5kZXg6IGksIGNoaWxkTm9kZTogY2hpbGQgfTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH0gZWxzZSBpZiAoIG9iamVjdCAmJiBvYmplY3QuaXNOb2RlID09PSB0cnVlICkge1xyXG5cclxuXHRcdFx0eWllbGQgeyBwcm9wZXJ0eSwgY2hpbGROb2RlOiBvYmplY3QgfTtcclxuXHJcblx0XHR9IGVsc2UgaWYgKCB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyApIHtcclxuXHJcblx0XHRcdGZvciAoIGNvbnN0IHN1YlByb3BlcnR5IGluIG9iamVjdCApIHtcclxuXHJcblx0XHRcdFx0Y29uc3QgY2hpbGQgPSBvYmplY3RbIHN1YlByb3BlcnR5IF07XHJcblxyXG5cdFx0XHRcdGlmICggY2hpbGQgJiYgKCBjaGlsZC5pc05vZGUgPT09IHRydWUgfHwgdG9KU09OICYmIHR5cGVvZiBjaGlsZC50b0pTT04gPT09ICdmdW5jdGlvbicgKSApIHtcclxuXHJcblx0XHRcdFx0XHR5aWVsZCB7IHByb3BlcnR5LCBpbmRleDogc3ViUHJvcGVydHksIGNoaWxkTm9kZTogY2hpbGQgfTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxufVxyXG5cclxuY29uc3QgdHlwZUZyb21MZW5ndGggPSAvKkBfX1BVUkVfXyovIG5ldyBNYXAoIFtcclxuXHRbIDEsICdmbG9hdCcgXSxcclxuXHRbIDIsICd2ZWMyJyBdLFxyXG5cdFsgMywgJ3ZlYzMnIF0sXHJcblx0WyA0LCAndmVjNCcgXSxcclxuXHRbIDksICdtYXQzJyBdLFxyXG5cdFsgMTYsICdtYXQ0JyBdXHJcbl0gKTtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBkYXRhIHR5cGUgZm9yIHRoZSBnaXZlbiB0aGUgbGVuZ3RoLlxyXG4gKlxyXG4gKiBAbWV0aG9kXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBsZW5ndGggLSBUaGUgbGVuZ3RoLlxyXG4gKiBAcmV0dXJuIHtTdHJpbmd9IFRoZSBkYXRhIHR5cGUuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZ2V0VHlwZUZyb21MZW5ndGgoIGxlbmd0aCApIHtcclxuXHJcblx0cmV0dXJuIHR5cGVGcm9tTGVuZ3RoLmdldCggbGVuZ3RoICk7XHJcblxyXG59XHJcblxyXG4vKipcclxuICogUmV0dXJucyB0aGUgbGVuZ3RoIGZvciB0aGUgZ2l2ZW4gZGF0YSB0eXBlLlxyXG4gKlxyXG4gKiBAbWV0aG9kXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIC0gVGhlIGRhdGEgdHlwZS5cclxuICogQHJldHVybiB7TnVtYmVyfSBUaGUgbGVuZ3RoLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGdldExlbmd0aEZyb21UeXBlKCB0eXBlICkge1xyXG5cclxuXHRpZiAoIC9mbG9hdHxpbnR8dWludC8udGVzdCggdHlwZSApICkgcmV0dXJuIDE7XHJcblx0aWYgKCAvdmVjMi8udGVzdCggdHlwZSApICkgcmV0dXJuIDI7XHJcblx0aWYgKCAvdmVjMy8udGVzdCggdHlwZSApICkgcmV0dXJuIDM7XHJcblx0aWYgKCAvdmVjNC8udGVzdCggdHlwZSApICkgcmV0dXJuIDQ7XHJcblx0aWYgKCAvbWF0My8udGVzdCggdHlwZSApICkgcmV0dXJuIDk7XHJcblx0aWYgKCAvbWF0NC8udGVzdCggdHlwZSApICkgcmV0dXJuIDE2O1xyXG5cclxuXHRjb25zb2xlLmVycm9yKCAnVEhSRUUuVFNMOiBVbnN1cHBvcnRlZCB0eXBlOicsIHR5cGUgKTtcclxuXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBkYXRhIHR5cGUgZm9yIHRoZSBnaXZlbiB2YWx1ZS5cclxuICpcclxuICogQG1ldGhvZFxyXG4gKiBAcGFyYW0ge0FueX0gdmFsdWUgLSBUaGUgdmFsdWUuXHJcbiAqIEByZXR1cm4ge1N0cmluZz99IFRoZSBkYXRhIHR5cGUuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZ2V0VmFsdWVUeXBlKCB2YWx1ZSApIHtcclxuXHJcblx0aWYgKCB2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHZhbHVlID09PSBudWxsICkgcmV0dXJuIG51bGw7XHJcblxyXG5cdGNvbnN0IHR5cGVPZiA9IHR5cGVvZiB2YWx1ZTtcclxuXHJcblx0aWYgKCB2YWx1ZS5pc05vZGUgPT09IHRydWUgKSB7XHJcblxyXG5cdFx0cmV0dXJuICdub2RlJztcclxuXHJcblx0fSBlbHNlIGlmICggdHlwZU9mID09PSAnbnVtYmVyJyApIHtcclxuXHJcblx0XHRyZXR1cm4gJ2Zsb2F0JztcclxuXHJcblx0fSBlbHNlIGlmICggdHlwZU9mID09PSAnYm9vbGVhbicgKSB7XHJcblxyXG5cdFx0cmV0dXJuICdib29sJztcclxuXHJcblx0fSBlbHNlIGlmICggdHlwZU9mID09PSAnc3RyaW5nJyApIHtcclxuXHJcblx0XHRyZXR1cm4gJ3N0cmluZyc7XHJcblxyXG5cdH0gZWxzZSBpZiAoIHR5cGVPZiA9PT0gJ2Z1bmN0aW9uJyApIHtcclxuXHJcblx0XHRyZXR1cm4gJ3NoYWRlcic7XHJcblxyXG5cdH0gZWxzZSBpZiAoIHZhbHVlLmlzVmVjdG9yMiA9PT0gdHJ1ZSApIHtcclxuXHJcblx0XHRyZXR1cm4gJ3ZlYzInO1xyXG5cclxuXHR9IGVsc2UgaWYgKCB2YWx1ZS5pc1ZlY3RvcjMgPT09IHRydWUgKSB7XHJcblxyXG5cdFx0cmV0dXJuICd2ZWMzJztcclxuXHJcblx0fSBlbHNlIGlmICggdmFsdWUuaXNWZWN0b3I0ID09PSB0cnVlICkge1xyXG5cclxuXHRcdHJldHVybiAndmVjNCc7XHJcblxyXG5cdH0gZWxzZSBpZiAoIHZhbHVlLmlzTWF0cml4MyA9PT0gdHJ1ZSApIHtcclxuXHJcblx0XHRyZXR1cm4gJ21hdDMnO1xyXG5cclxuXHR9IGVsc2UgaWYgKCB2YWx1ZS5pc01hdHJpeDQgPT09IHRydWUgKSB7XHJcblxyXG5cdFx0cmV0dXJuICdtYXQ0JztcclxuXHJcblx0fSBlbHNlIGlmICggdmFsdWUuaXNDb2xvciA9PT0gdHJ1ZSApIHtcclxuXHJcblx0XHRyZXR1cm4gJ2NvbG9yJztcclxuXHJcblx0fSBlbHNlIGlmICggdmFsdWUgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlciApIHtcclxuXHJcblx0XHRyZXR1cm4gJ0FycmF5QnVmZmVyJztcclxuXHJcblx0fVxyXG5cclxuXHRyZXR1cm4gbnVsbDtcclxuXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSB2YWx1ZS9vYmplY3QgZm9yIHRoZSBnaXZlbiBkYXRhIHR5cGUgYW5kIHBhcmFtZXRlcnMuXHJcbiAqXHJcbiAqIEBtZXRob2RcclxuICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgLSBUaGUgZ2l2ZW4gdHlwZS5cclxuICogQHBhcmFtIHsuLi5Bbnl9IHBhcmFtcyAtIEEgcGFyYW1ldGVyIGxpc3QuXHJcbiAqIEByZXR1cm4ge0FueX0gVGhlIHZhbHVlL29iamVjdC5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRWYWx1ZUZyb21UeXBlKCB0eXBlLCAuLi5wYXJhbXMgKSB7XHJcblxyXG5cdGNvbnN0IGxhc3Q0ID0gdHlwZSA/IHR5cGUuc2xpY2UoIC0gNCApIDogdW5kZWZpbmVkO1xyXG5cclxuXHRpZiAoIHBhcmFtcy5sZW5ndGggPT09IDEgKSB7IC8vIGVuc3VyZSBzYW1lIGJlaGF2aW91ciBhcyBpbiBOb2RlQnVpbGRlci5mb3JtYXQoKVxyXG5cclxuXHRcdGlmICggbGFzdDQgPT09ICd2ZWMyJyApIHBhcmFtcyA9IFsgcGFyYW1zWyAwIF0sIHBhcmFtc1sgMCBdIF07XHJcblx0XHRlbHNlIGlmICggbGFzdDQgPT09ICd2ZWMzJyApIHBhcmFtcyA9IFsgcGFyYW1zWyAwIF0sIHBhcmFtc1sgMCBdLCBwYXJhbXNbIDAgXSBdO1xyXG5cdFx0ZWxzZSBpZiAoIGxhc3Q0ID09PSAndmVjNCcgKSBwYXJhbXMgPSBbIHBhcmFtc1sgMCBdLCBwYXJhbXNbIDAgXSwgcGFyYW1zWyAwIF0sIHBhcmFtc1sgMCBdIF07XHJcblxyXG5cdH1cclxuXHJcblx0aWYgKCB0eXBlID09PSAnY29sb3InICkge1xyXG5cclxuXHRcdHJldHVybiBuZXcgQ29sb3IoIC4uLnBhcmFtcyApO1xyXG5cclxuXHR9IGVsc2UgaWYgKCBsYXN0NCA9PT0gJ3ZlYzInICkge1xyXG5cclxuXHRcdHJldHVybiBuZXcgVmVjdG9yMiggLi4ucGFyYW1zICk7XHJcblxyXG5cdH0gZWxzZSBpZiAoIGxhc3Q0ID09PSAndmVjMycgKSB7XHJcblxyXG5cdFx0cmV0dXJuIG5ldyBWZWN0b3IzKCAuLi5wYXJhbXMgKTtcclxuXHJcblx0fSBlbHNlIGlmICggbGFzdDQgPT09ICd2ZWM0JyApIHtcclxuXHJcblx0XHRyZXR1cm4gbmV3IFZlY3RvcjQoIC4uLnBhcmFtcyApO1xyXG5cclxuXHR9IGVsc2UgaWYgKCBsYXN0NCA9PT0gJ21hdDMnICkge1xyXG5cclxuXHRcdHJldHVybiBuZXcgTWF0cml4MyggLi4ucGFyYW1zICk7XHJcblxyXG5cdH0gZWxzZSBpZiAoIGxhc3Q0ID09PSAnbWF0NCcgKSB7XHJcblxyXG5cdFx0cmV0dXJuIG5ldyBNYXRyaXg0KCAuLi5wYXJhbXMgKTtcclxuXHJcblx0fSBlbHNlIGlmICggdHlwZSA9PT0gJ2Jvb2wnICkge1xyXG5cclxuXHRcdHJldHVybiBwYXJhbXNbIDAgXSB8fCBmYWxzZTtcclxuXHJcblx0fSBlbHNlIGlmICggKCB0eXBlID09PSAnZmxvYXQnICkgfHwgKCB0eXBlID09PSAnaW50JyApIHx8ICggdHlwZSA9PT0gJ3VpbnQnICkgKSB7XHJcblxyXG5cdFx0cmV0dXJuIHBhcmFtc1sgMCBdIHx8IDA7XHJcblxyXG5cdH0gZWxzZSBpZiAoIHR5cGUgPT09ICdzdHJpbmcnICkge1xyXG5cclxuXHRcdHJldHVybiBwYXJhbXNbIDAgXSB8fCAnJztcclxuXHJcblx0fSBlbHNlIGlmICggdHlwZSA9PT0gJ0FycmF5QnVmZmVyJyApIHtcclxuXHJcblx0XHRyZXR1cm4gYmFzZTY0VG9BcnJheUJ1ZmZlciggcGFyYW1zWyAwIF0gKTtcclxuXHJcblx0fVxyXG5cclxuXHRyZXR1cm4gbnVsbDtcclxuXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDb252ZXJ0cyB0aGUgZ2l2ZW4gYXJyYXkgYnVmZmVyIHRvIGEgQmFzZTY0IHN0cmluZy5cclxuICpcclxuICogQG1ldGhvZFxyXG4gKiBAcGFyYW0ge0FycmF5QnVmZmVyfSBhcnJheUJ1ZmZlciAtIFRoZSBhcnJheSBidWZmZXIuXHJcbiAqIEByZXR1cm4ge1N0cmluZ30gVGhlIEJhc2U2NCBzdHJpbmcuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gYXJyYXlCdWZmZXJUb0Jhc2U2NCggYXJyYXlCdWZmZXIgKSB7XHJcblxyXG5cdGxldCBjaGFycyA9ICcnO1xyXG5cclxuXHRjb25zdCBhcnJheSA9IG5ldyBVaW50OEFycmF5KCBhcnJheUJ1ZmZlciApO1xyXG5cclxuXHRmb3IgKCBsZXQgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkgKysgKSB7XHJcblxyXG5cdFx0Y2hhcnMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSggYXJyYXlbIGkgXSApO1xyXG5cclxuXHR9XHJcblxyXG5cdHJldHVybiBidG9hKCBjaGFycyApO1xyXG5cclxufVxyXG5cclxuLyoqXHJcbiAqIENvbnZlcnRzIHRoZSBnaXZlbiBCYXNlNjQgc3RyaW5nIHRvIGFuIGFycmF5IGJ1ZmZlci5cclxuICpcclxuICogQG1ldGhvZFxyXG4gKiBAcGFyYW0ge1N0cmluZ30gYmFzZTY0IC0gVGhlIEJhc2U2NCBzdHJpbmcuXHJcbiAqIEByZXR1cm4ge0FycmF5QnVmZmVyfSBUaGUgYXJyYXkgYnVmZmVyLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGJhc2U2NFRvQXJyYXlCdWZmZXIoIGJhc2U2NCApIHtcclxuXHJcblx0cmV0dXJuIFVpbnQ4QXJyYXkuZnJvbSggYXRvYiggYmFzZTY0ICksIGMgPT4gYy5jaGFyQ29kZUF0KCAwICkgKS5idWZmZXI7XHJcblxyXG59XHJcbiIsIi8qKiBAbW9kdWxlIE5vZGVDb25zdGFudHMgKiovXHJcblxyXG4vKipcclxuICogUG9zc2libGUgc2hhZGVyIHN0YWdlcy5cclxuICpcclxuICogQHByb3BlcnR5IHtzdHJpbmd9IFZFUlRFWCBUaGUgdmVydGV4IHNoYWRlciBzdGFnZS5cclxuICogQHByb3BlcnR5IHtzdHJpbmd9IEZSQUdNRU5UIFRoZSBmcmFnbWVudCBzaGFkZXIgc3RhZ2UuXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgTm9kZVNoYWRlclN0YWdlID0ge1xyXG5cdFZFUlRFWDogJ3ZlcnRleCcsXHJcblx0RlJBR01FTlQ6ICdmcmFnbWVudCdcclxufTtcclxuXHJcbi8qKlxyXG4gKiBVcGRhdGUgdHlwZXMgb2YgYSBub2RlLlxyXG4gKlxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gTk9ORSBUaGUgdXBkYXRlIG1ldGhvZCBpcyBub3QgZXhlY3V0ZWQuXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBGUkFNRSBUaGUgdXBkYXRlIG1ldGhvZCBpcyBleGVjdXRlZCBwZXIgZnJhbWUuXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBSRU5ERVIgVGhlIHVwZGF0ZSBtZXRob2QgaXMgZXhlY3V0ZWQgcGVyIHJlbmRlci4gQSBmcmFtZSBtaWdodCBiZSBwcm9kdWNlZCBieSBtdWx0aXBsZSByZW5kZXIgY2FsbHMgc28gdGhpcyB2YWx1ZSBhbGxvd3MgbW9yZSBkZXRhaWxlZCB1cGRhdGVzIHRoYW4gRlJBTUUuXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBPQkpFQ1QgVGhlIHVwZGF0ZSBtZXRob2QgaXMgZXhlY3V0ZWQgcGVyIHtAbGluayBPYmplY3QzRH0gdGhhdCB1c2VzIHRoZSBub2RlIGZvciByZW5kZXJpbmcuXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgTm9kZVVwZGF0ZVR5cGUgPSB7XHJcblx0Tk9ORTogJ25vbmUnLFxyXG5cdEZSQU1FOiAnZnJhbWUnLFxyXG5cdFJFTkRFUjogJ3JlbmRlcicsXHJcblx0T0JKRUNUOiAnb2JqZWN0J1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIERhdGEgdHlwZXMgb2YgYSBub2RlLlxyXG4gKlxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gQk9PTEVBTiBCb29sZWFuIHR5cGUuXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBJTlRFR0VSIEludGVnZXIgdHlwZS5cclxuICogQHByb3BlcnR5IHtzdHJpbmd9IEZMT0FUIEZsb2F0IHR5cGUuXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBWRUNUT1IyIFR3by1kaW1lbnNpb25hbCB2ZWN0b3IgdHlwZS5cclxuICogQHByb3BlcnR5IHtzdHJpbmd9IFZFQ1RPUjMgVGhyZWUtZGltZW5zaW9uYWwgdmVjdG9yIHR5cGUuXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBWRUNUT1I0IEZvdXItZGltZW5zaW9uYWwgdmVjdG9yIHR5cGUuXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBNQVRSSVgyIDJ4MiBtYXRyaXggdHlwZS5cclxuICogQHByb3BlcnR5IHtzdHJpbmd9IE1BVFJJWDMgM3gzIG1hdHJpeCB0eXBlLlxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gTUFUUklYNCA0eDQgbWF0cml4IHR5cGUuXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgTm9kZVR5cGUgPSB7XHJcblx0Qk9PTEVBTjogJ2Jvb2wnLFxyXG5cdElOVEVHRVI6ICdpbnQnLFxyXG5cdEZMT0FUOiAnZmxvYXQnLFxyXG5cdFZFQ1RPUjI6ICd2ZWMyJyxcclxuXHRWRUNUT1IzOiAndmVjMycsXHJcblx0VkVDVE9SNDogJ3ZlYzQnLFxyXG5cdE1BVFJJWDI6ICdtYXQyJyxcclxuXHRNQVRSSVgzOiAnbWF0MycsXHJcblx0TUFUUklYNDogJ21hdDQnXHJcbn07XHJcblxyXG4vKipcclxuICogQWNjZXNzIHR5cGVzIG9mIGEgbm9kZS4gVGhlc2UgYXJlIHJlbGV2YW50IGZvciBjb21wdXRlIGFuZCBzdG9yYWdlIHVzYWdlLlxyXG4gKlxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gUkVBRF9PTkxZIFJlYWQtb25seSBhY2Nlc3NcclxuICogQHByb3BlcnR5IHtzdHJpbmd9IFdSSVRFX09OTFkgV3JpdGUtb25seSBhY2Nlc3MuXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBSRUFEX1dSSVRFIFJlYWQgYW5kIHdyaXRlIGFjY2Vzcy5cclxuICovXHJcbmV4cG9ydCBjb25zdCBOb2RlQWNjZXNzID0ge1xyXG5cdFJFQURfT05MWTogJ3JlYWRPbmx5JyxcclxuXHRXUklURV9PTkxZOiAnd3JpdGVPbmx5JyxcclxuXHRSRUFEX1dSSVRFOiAncmVhZFdyaXRlJyxcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBkZWZhdWx0U2hhZGVyU3RhZ2VzID0gWyAnZnJhZ21lbnQnLCAndmVydGV4JyBdO1xyXG5leHBvcnQgY29uc3QgZGVmYXVsdEJ1aWxkU3RhZ2VzID0gWyAnc2V0dXAnLCAnYW5hbHl6ZScsICdnZW5lcmF0ZScgXTtcclxuZXhwb3J0IGNvbnN0IHNoYWRlclN0YWdlcyA9IFsgLi4uZGVmYXVsdFNoYWRlclN0YWdlcywgJ2NvbXB1dGUnIF07XHJcbmV4cG9ydCBjb25zdCB2ZWN0b3JDb21wb25lbnRzID0gWyAneCcsICd5JywgJ3onLCAndycgXTtcclxuIiwiaW1wb3J0IHsgTm9kZVVwZGF0ZVR5cGUgfSBmcm9tICcuL2NvbnN0YW50cy5qcyc7XHJcbmltcG9ydCB7IGdldE5vZGVDaGlsZHJlbiwgZ2V0Q2FjaGVLZXksIGhhc2ggfSBmcm9tICcuL05vZGVVdGlscy5qcyc7XHJcblxyXG5pbXBvcnQgeyBFdmVudERpc3BhdGNoZXIgfSBmcm9tICcuLi8uLi9jb3JlL0V2ZW50RGlzcGF0Y2hlci5qcyc7XHJcbmltcG9ydCB7IE1hdGhVdGlscyB9IGZyb20gJy4uLy4uL21hdGgvTWF0aFV0aWxzLmpzJztcclxuXHJcbmxldCBfbm9kZUlkID0gMDtcclxuXHJcbi8qKlxyXG4gKiBCYXNlIGNsYXNzIGZvciBhbGwgbm9kZXMuXHJcbiAqXHJcbiAqIEBhdWdtZW50cyBFdmVudERpc3BhdGNoZXJcclxuICovXHJcbmNsYXNzIE5vZGUgZXh0ZW5kcyBFdmVudERpc3BhdGNoZXIge1xyXG5cclxuXHRzdGF0aWMgZ2V0IHR5cGUoKSB7XHJcblxyXG5cdFx0cmV0dXJuICdOb2RlJztcclxuXHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBDb25zdHJ1Y3RzIGEgbmV3IG5vZGUuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge1N0cmluZz99IG5vZGVUeXBlIC0gVGhlIG5vZGUgdHlwZS5cclxuXHQgKi9cclxuXHRjb25zdHJ1Y3Rvciggbm9kZVR5cGUgPSBudWxsICkge1xyXG5cclxuXHRcdHN1cGVyKCk7XHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBUaGUgbm9kZSB0eXBlLiBUaGlzIHJlcHJlc2VudHMgdGhlIHJlc3VsdCB0eXBlIG9mIHRoZSBub2RlIChlLmcuIGBmbG9hdGAgb3IgYHZlYzNgKS5cclxuXHRcdCAqXHJcblx0XHQgKiBAdHlwZSB7U3RyaW5nP31cclxuXHRcdCAqIEBkZWZhdWx0IG51bGxcclxuXHRcdCAqL1xyXG5cdFx0dGhpcy5ub2RlVHlwZSA9IG5vZGVUeXBlO1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogVGhlIHVwZGF0ZSB0eXBlIG9mIHRoZSBub2RlJ3Mge0BsaW5rIE5vZGUjdXBkYXRlfSBtZXRob2QuIFBvc3NpYmxlIHZhbHVlcyBhcmUgbGlzdGVkIGluIHtAbGluayBOb2RlVXBkYXRlVHlwZX0uXHJcblx0XHQgKlxyXG5cdFx0ICogQHR5cGUge1N0cmluZ31cclxuXHRcdCAqIEBkZWZhdWx0ICdub25lJ1xyXG5cdFx0ICovXHJcblx0XHR0aGlzLnVwZGF0ZVR5cGUgPSBOb2RlVXBkYXRlVHlwZS5OT05FO1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogVGhlIHVwZGF0ZSB0eXBlIG9mIHRoZSBub2RlJ3Mge0BsaW5rIE5vZGUjdXBkYXRlQmVmb3JlfSBtZXRob2QuIFBvc3NpYmxlIHZhbHVlcyBhcmUgbGlzdGVkIGluIHtAbGluayBOb2RlVXBkYXRlVHlwZX0uXHJcblx0XHQgKlxyXG5cdFx0ICogQHR5cGUge1N0cmluZ31cclxuXHRcdCAqIEBkZWZhdWx0ICdub25lJ1xyXG5cdFx0ICovXHJcblx0XHR0aGlzLnVwZGF0ZUJlZm9yZVR5cGUgPSBOb2RlVXBkYXRlVHlwZS5OT05FO1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogVGhlIHVwZGF0ZSB0eXBlIG9mIHRoZSBub2RlJ3Mge0BsaW5rIE5vZGUjdXBkYXRlQWZ0ZXJ9IG1ldGhvZC4gUG9zc2libGUgdmFsdWVzIGFyZSBsaXN0ZWQgaW4ge0BsaW5rIE5vZGVVcGRhdGVUeXBlfS5cclxuXHRcdCAqXHJcblx0XHQgKiBAdHlwZSB7U3RyaW5nfVxyXG5cdFx0ICogQGRlZmF1bHQgJ25vbmUnXHJcblx0XHQgKi9cclxuXHRcdHRoaXMudXBkYXRlQWZ0ZXJUeXBlID0gTm9kZVVwZGF0ZVR5cGUuTk9ORTtcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIFRoZSBVVUlEIG9mIHRoZSBub2RlLlxyXG5cdFx0ICpcclxuXHRcdCAqIEB0eXBlIHtTdHJpbmd9XHJcblx0XHQgKiBAcmVhZG9ubHlcclxuXHRcdCAqL1xyXG5cdFx0dGhpcy51dWlkID0gTWF0aFV0aWxzLmdlbmVyYXRlVVVJRCgpO1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogVGhlIHZlcnNpb24gb2YgdGhlIG5vZGUuIFRoZSB2ZXJzaW9uIGF1dG9tYXRpY2FsbHkgaXMgaW5jcmVhc2VkIHdoZW4ge0BsaW5rIE5vZGUjbmVlZHNVcGRhdGV9IGlzIHNldCB0byBgdHJ1ZWAuXHJcblx0XHQgKlxyXG5cdFx0ICogQHR5cGUge051bWJlcn1cclxuXHRcdCAqIEByZWFkb25seVxyXG5cdFx0ICogQGRlZmF1bHQgMFxyXG5cdFx0ICovXHJcblx0XHR0aGlzLnZlcnNpb24gPSAwO1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogV2hldGhlciB0aGlzIG5vZGUgaXMgZ2xvYmFsIG9yIG5vdC4gVGhpcyBwcm9wZXJ0eSBpcyByZWxldmFudCBmb3IgdGhlIGludGVybmFsXHJcblx0XHQgKiBub2RlIGNhY2hpbmcgc3lzdGVtLiBBbGwgbm9kZXMgd2hpY2ggc2hvdWxkIGJlIGRlY2xhcmVkIGp1c3Qgb25jZSBzaG91bGRcclxuXHRcdCAqIHNldCB0aGlzIGZsYWcgdG8gYHRydWVgIChhIHR5cGljYWwgZXhhbXBsZSBpcyB7QGxpbmsgQXR0cmlidXRlTm9kZX0pLlxyXG5cdFx0ICpcclxuXHRcdCAqIEB0eXBlIHtCb29sZWFufVxyXG5cdFx0ICogQGRlZmF1bHQgZmFsc2VcclxuXHRcdCAqL1xyXG5cdFx0dGhpcy5nbG9iYWwgPSBmYWxzZTtcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIFRoaXMgZmxhZyBjYW4gYmUgdXNlZCBmb3IgdHlwZSB0ZXN0aW5nLlxyXG5cdFx0ICpcclxuXHRcdCAqIEB0eXBlIHtCb29sZWFufVxyXG5cdFx0ICogQHJlYWRvbmx5XHJcblx0XHQgKiBAZGVmYXVsdCB0cnVlXHJcblx0XHQgKi9cclxuXHRcdHRoaXMuaXNOb2RlID0gdHJ1ZTtcclxuXHJcblx0XHQvLyBwcml2YXRlXHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBUaGUgY2FjaGUga2V5IG9mIHRoaXMgbm9kZS5cclxuXHRcdCAqXHJcblx0XHQgKiBAcHJpdmF0ZVxyXG5cdFx0ICogQHR5cGUge051bWJlcj99XHJcblx0XHQgKiBAZGVmYXVsdCBudWxsXHJcblx0XHQgKi9cclxuXHRcdHRoaXMuX2NhY2hlS2V5ID0gbnVsbDtcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIFRoZSBjYWNoZSBrZXkgJ3MgdmVyc2lvbi5cclxuXHRcdCAqXHJcblx0XHQgKiBAcHJpdmF0ZVxyXG5cdFx0ICogQHR5cGUge051bWJlcn1cclxuXHRcdCAqIEBkZWZhdWx0IDBcclxuXHRcdCAqL1xyXG5cdFx0dGhpcy5fY2FjaGVLZXlWZXJzaW9uID0gMDtcclxuXHJcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoIHRoaXMsICdpZCcsIHsgdmFsdWU6IF9ub2RlSWQgKysgfSApO1xyXG5cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFNldCB0aGlzIHByb3BlcnR5IHRvIGB0cnVlYCB3aGVuIHRoZSBub2RlIHNob3VsZCBiZSByZWdlbmVyYXRlZC5cclxuXHQgKlxyXG5cdCAqIEB0eXBlIHtCb29sZWFufVxyXG5cdCAqIEBkZWZhdWx0IGZhbHNlXHJcblx0ICogQHBhcmFtIHtib29sZWFufSB2YWx1ZVxyXG5cdCAqL1xyXG5cdHNldCBuZWVkc1VwZGF0ZSggdmFsdWUgKSB7XHJcblxyXG5cdFx0aWYgKCB2YWx1ZSA9PT0gdHJ1ZSApIHtcclxuXHJcblx0XHRcdHRoaXMudmVyc2lvbiArKztcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogVGhlIHR5cGUgb2YgdGhlIGNsYXNzLiBUaGUgdmFsdWUgaXMgdXN1YWxseSB0aGUgY29uc3RydWN0b3IgbmFtZS5cclxuXHQgKlxyXG5cdCAqIEB0eXBlIHtTdHJpbmd9XHJcbiBcdCAqIEByZWFkb25seVxyXG5cdCAqL1xyXG5cdGdldCB0eXBlKCkge1xyXG5cclxuXHRcdHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLnR5cGU7XHJcblxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogQ29udmVuaWVudCBtZXRob2QgZm9yIGRlZmluaW5nIHtAbGluayBOb2RlI3VwZGF0ZX0uXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayAtIFRoZSB1cGRhdGUgbWV0aG9kLlxyXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSB1cGRhdGVUeXBlIC0gVGhlIHVwZGF0ZSB0eXBlLlxyXG5cdCAqIEByZXR1cm4ge05vZGV9IEEgcmVmZXJlbmNlIHRvIHRoaXMgbm9kZS5cclxuXHQgKi9cclxuXHRvblVwZGF0ZSggY2FsbGJhY2ssIHVwZGF0ZVR5cGUgKSB7XHJcblxyXG5cdFx0dGhpcy51cGRhdGVUeXBlID0gdXBkYXRlVHlwZTtcclxuXHRcdHRoaXMudXBkYXRlID0gY2FsbGJhY2suYmluZCggdGhpcy5nZXRTZWxmKCkgKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBDb252ZW5pZW50IG1ldGhvZCBmb3IgZGVmaW5pbmcge0BsaW5rIE5vZGUjdXBkYXRlfS4gU2ltaWxhciB0byB7QGxpbmsgTm9kZSNvblVwZGF0ZX0sIGJ1dFxyXG5cdCAqIHRoaXMgbWV0aG9kIGF1dG9tYXRpY2FsbHkgc2V0cyB0aGUgdXBkYXRlIHR5cGUgdG8gYEZSQU1FYC5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIC0gVGhlIHVwZGF0ZSBtZXRob2QuXHJcblx0ICogQHJldHVybiB7Tm9kZX0gQSByZWZlcmVuY2UgdG8gdGhpcyBub2RlLlxyXG5cdCAqL1xyXG5cdG9uRnJhbWVVcGRhdGUoIGNhbGxiYWNrICkge1xyXG5cclxuXHRcdHJldHVybiB0aGlzLm9uVXBkYXRlKCBjYWxsYmFjaywgTm9kZVVwZGF0ZVR5cGUuRlJBTUUgKTtcclxuXHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBDb252ZW5pZW50IG1ldGhvZCBmb3IgZGVmaW5pbmcge0BsaW5rIE5vZGUjdXBkYXRlfS4gU2ltaWxhciB0byB7QGxpbmsgTm9kZSNvblVwZGF0ZX0sIGJ1dFxyXG5cdCAqIHRoaXMgbWV0aG9kIGF1dG9tYXRpY2FsbHkgc2V0cyB0aGUgdXBkYXRlIHR5cGUgdG8gYFJFTkRFUmAuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayAtIFRoZSB1cGRhdGUgbWV0aG9kLlxyXG5cdCAqIEByZXR1cm4ge05vZGV9IEEgcmVmZXJlbmNlIHRvIHRoaXMgbm9kZS5cclxuXHQgKi9cclxuXHRvblJlbmRlclVwZGF0ZSggY2FsbGJhY2sgKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMub25VcGRhdGUoIGNhbGxiYWNrLCBOb2RlVXBkYXRlVHlwZS5SRU5ERVIgKTtcclxuXHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBDb252ZW5pZW50IG1ldGhvZCBmb3IgZGVmaW5pbmcge0BsaW5rIE5vZGUjdXBkYXRlfS4gU2ltaWxhciB0byB7QGxpbmsgTm9kZSNvblVwZGF0ZX0sIGJ1dFxyXG5cdCAqIHRoaXMgbWV0aG9kIGF1dG9tYXRpY2FsbHkgc2V0cyB0aGUgdXBkYXRlIHR5cGUgdG8gYE9CSkVDVGAuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayAtIFRoZSB1cGRhdGUgbWV0aG9kLlxyXG5cdCAqIEByZXR1cm4ge05vZGV9IEEgcmVmZXJlbmNlIHRvIHRoaXMgbm9kZS5cclxuXHQgKi9cclxuXHRvbk9iamVjdFVwZGF0ZSggY2FsbGJhY2sgKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMub25VcGRhdGUoIGNhbGxiYWNrLCBOb2RlVXBkYXRlVHlwZS5PQkpFQ1QgKTtcclxuXHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBDb252ZW5pZW50IG1ldGhvZCBmb3IgZGVmaW5pbmcge0BsaW5rIE5vZGUjdXBkYXRlUmVmZXJlbmNlfS5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIC0gVGhlIHVwZGF0ZSBtZXRob2QuXHJcblx0ICogQHJldHVybiB7Tm9kZX0gQSByZWZlcmVuY2UgdG8gdGhpcyBub2RlLlxyXG5cdCAqL1xyXG5cdG9uUmVmZXJlbmNlKCBjYWxsYmFjayApIHtcclxuXHJcblx0XHR0aGlzLnVwZGF0ZVJlZmVyZW5jZSA9IGNhbGxiYWNrLmJpbmQoIHRoaXMuZ2V0U2VsZigpICk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogVGhlIGB0aGlzYCByZWZlcmVuY2UgbWlnaHQgcG9pbnQgdG8gYSBQcm94eSBzbyB0aGlzIG1ldGhvZCBjYW4gYmUgdXNlZFxyXG5cdCAqIHRvIGdldCB0aGUgcmVmZXJlbmNlIHRvIHRoZSBhY3R1YWwgbm9kZSBpbnN0YW5jZS5cclxuXHQgKlxyXG5cdCAqIEByZXR1cm4ge05vZGV9IEEgcmVmZXJlbmNlIHRvIHRoZSBub2RlLlxyXG5cdCAqL1xyXG5cdGdldFNlbGYoKSB7XHJcblxyXG5cdFx0Ly8gUmV0dXJucyBub24tbm9kZSBvYmplY3QuXHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuc2VsZiB8fCB0aGlzO1xyXG5cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIE5vZGVzIG1pZ2h0IHJlZmVyIHRvIG90aGVyIG9iamVjdHMgbGlrZSBtYXRlcmlhbHMuIFRoaXMgbWV0aG9kIGFsbG93cyB0byBkeW5hbWljYWxseSB1cGRhdGUgdGhlIHJlZmVyZW5jZVxyXG5cdCAqIHRvIHN1Y2ggb2JqZWN0cyBiYXNlZCBvbiBhIGdpdmVuIHN0YXRlIChlLmcuIHRoZSBjdXJyZW50IG5vZGUgZnJhbWUgb3IgYnVpbGRlcikuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge0FueX0gc3RhdGUgLSBUaGlzIG1ldGhvZCBjYW4gYmUgaW52b2NhdGVkIGluIGRpZmZlcmVudCBjb250ZXh0cyBzbyBgc3RhdGVgIGNhbiByZWZlciB0byBhbnkgb2JqZWN0IHR5cGUuXHJcblx0ICogQHJldHVybiB7QW55fSBUaGUgdXBkYXRlZCByZWZlcmVuY2UuXHJcblx0ICovXHJcblx0dXBkYXRlUmVmZXJlbmNlKCAvKnN0YXRlKi8gKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogQnkgZGVmYXVsdCB0aGlzIG1ldGhvZCByZXR1cm5zIHRoZSB2YWx1ZSBvZiB0aGUge0BsaW5rIE5vZGUjZ2xvYmFsfSBmbGFnLiBUaGlzIG1ldGhvZFxyXG5cdCAqIGNhbiBiZSBvdmVyd3JpdHRlbiBpbiBkZXJpdmVkIGNsYXNzZXMgaWYgYW4gYW5hbHl0aWNhbCB3YXkgaXMgcmVxdWlyZWQgdG8gZGV0ZXJtaW5lIHRoZVxyXG5cdCAqIGdsb2JhbCBzdGF0dXMuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge05vZGVCdWlsZGVyfSBidWlsZGVyIC0gVGhlIGN1cnJlbnQgbm9kZSBidWlsZGVyLlxyXG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59IFdoZXRoZXIgdGhpcyBub2RlIGlzIGdsb2JhbCBvciBub3QuXHJcblx0ICovXHJcblx0aXNHbG9iYWwoIC8qYnVpbGRlciovICkge1xyXG5cclxuXHRcdHJldHVybiB0aGlzLmdsb2JhbDtcclxuXHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBHZW5lcmF0b3IgZnVuY3Rpb24gdGhhdCBjYW4gYmUgdXNlZCB0byBpdGVyYXRlIG92ZXIgdGhlIGNoaWxkIG5vZGVzLlxyXG5cdCAqXHJcblx0ICogQGdlbmVyYXRvclxyXG5cdCAqIEB5aWVsZHMge05vZGV9IEEgY2hpbGQgbm9kZS5cclxuXHQgKi9cclxuXHQqIGdldENoaWxkcmVuKCkge1xyXG5cclxuXHRcdGZvciAoIGNvbnN0IHsgY2hpbGROb2RlIH0gb2YgZ2V0Tm9kZUNoaWxkcmVuKCB0aGlzICkgKSB7XHJcblxyXG5cdFx0XHR5aWVsZCBjaGlsZE5vZGU7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIENhbGxpbmcgdGhpcyBtZXRob2QgZGlzcGF0Y2hlcyB0aGUgYGRpc3Bvc2VgIGV2ZW50LiBUaGlzIGV2ZW50IGNhbiBiZSB1c2VkXHJcblx0ICogdG8gcmVnaXN0ZXIgZXZlbnQgbGlzdGVuZXJzIGZvciBjbGVhbiB1cCB0YXNrcy5cclxuXHQgKi9cclxuXHRkaXNwb3NlKCkge1xyXG5cclxuXHRcdHRoaXMuZGlzcGF0Y2hFdmVudCggeyB0eXBlOiAnZGlzcG9zZScgfSApO1xyXG5cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIENhbGxiYWNrIGZvciB7QGxpbmsgTm9kZSN0cmF2ZXJzZX0uXHJcblx0ICpcclxuXHQgKiBAY2FsbGJhY2sgdHJhdmVyc2VDYWxsYmFja1xyXG5cdCAqIEBwYXJhbSB7Tm9kZX0gbm9kZSAtIFRoZSBjdXJyZW50IG5vZGUuXHJcblx0ICovXHJcblxyXG5cdC8qKlxyXG5cdCAqIENhbiBiZSB1c2VkIHRvIHRyYXZlcnNlIHRocm91Z2ggdGhlIG5vZGUncyBoaWVyYXJjaHkuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge3RyYXZlcnNlQ2FsbGJhY2t9IGNhbGxiYWNrIC0gQSBjYWxsYmFjayB0aGF0IGlzIGV4ZWN1dGVkIHBlciBub2RlLlxyXG5cdCAqL1xyXG5cdHRyYXZlcnNlKCBjYWxsYmFjayApIHtcclxuXHJcblx0XHRjYWxsYmFjayggdGhpcyApO1xyXG5cclxuXHRcdGZvciAoIGNvbnN0IGNoaWxkTm9kZSBvZiB0aGlzLmdldENoaWxkcmVuKCkgKSB7XHJcblxyXG5cdFx0XHRjaGlsZE5vZGUudHJhdmVyc2UoIGNhbGxiYWNrICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFJldHVybnMgdGhlIGNhY2hlIGtleSBmb3IgdGhpcyBub2RlLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtCb29sZWFufSBbZm9yY2U9ZmFsc2VdIC0gV2hlbiBzZXQgdG8gYHRydWVgLCBhIHJlY29tcHV0YXRpb24gb2YgdGhlIGNhY2hlIGtleSBpcyBmb3JjZWQuXHJcblx0ICogQHJldHVybiB7TnVtYmVyfSBUaGUgY2FjaGUga2V5IG9mIHRoZSBub2RlLlxyXG5cdCAqL1xyXG5cdGdldENhY2hlS2V5KCBmb3JjZSA9IGZhbHNlICkge1xyXG5cclxuXHRcdGZvcmNlID0gZm9yY2UgfHwgdGhpcy52ZXJzaW9uICE9PSB0aGlzLl9jYWNoZUtleVZlcnNpb247XHJcblxyXG5cdFx0aWYgKCBmb3JjZSA9PT0gdHJ1ZSB8fCB0aGlzLl9jYWNoZUtleSA9PT0gbnVsbCApIHtcclxuXHJcblx0XHRcdHRoaXMuX2NhY2hlS2V5ID0gaGFzaCggZ2V0Q2FjaGVLZXkoIHRoaXMsIGZvcmNlICksIHRoaXMuY3VzdG9tQ2FjaGVLZXkoKSApO1xyXG5cdFx0XHR0aGlzLl9jYWNoZUtleVZlcnNpb24gPSB0aGlzLnZlcnNpb247XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzLl9jYWNoZUtleTtcclxuXHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBHZW5lcmF0ZSBhIGN1c3RvbSBjYWNoZSBrZXkgZm9yIHRoaXMgbm9kZS5cclxuXHQgKlxyXG5cdCAqIEByZXR1cm4ge051bWJlcn0gVGhlIGNhY2hlIGtleSBvZiB0aGUgbm9kZS5cclxuXHQgKi9cclxuXHRjdXN0b21DYWNoZUtleSgpIHtcclxuXHJcblx0XHRyZXR1cm4gMDtcclxuXHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBSZXR1cm5zIHRoZSByZWZlcmVuY2VzIHRvIHRoaXMgbm9kZSB3aGljaCBpcyBieSBkZWZhdWx0IGB0aGlzYC5cclxuXHQgKlxyXG5cdCAqIEByZXR1cm4ge05vZGV9IEEgcmVmZXJlbmNlIHRvIHRoaXMgbm9kZS5cclxuXHQgKi9cclxuXHRnZXRTY29wZSgpIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBSZXR1cm5zIHRoZSBoYXNoIG9mIHRoZSBub2RlIHdoaWNoIGlzIHVzZWQgdG8gaWRlbnRpZnkgdGhlIG5vZGUuIEJ5IGRlZmF1bHQgaXQnc1xyXG5cdCAqIHRoZSB7QGxpbmsgTm9kZSN1dWlkfSBob3dldmVyIGRlcml2ZWQgbm9kZSBjbGFzc2VzIG1pZ2h0IGhhdmUgdG8gb3ZlcndyaXRlIHRoaXMgbWV0aG9kXHJcblx0ICogZGVwZW5kaW5nIG9uIHRoZWlyIGltcGxlbWVudGF0aW9uLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtOb2RlQnVpbGRlcn0gYnVpbGRlciAtIFRoZSBjdXJyZW50IG5vZGUgYnVpbGRlci5cclxuXHQgKiBAcmV0dXJuIHtTdHJpbmd9IFRoZSBoYXNoLlxyXG5cdCAqL1xyXG5cdGdldEhhc2goIC8qYnVpbGRlciovICkge1xyXG5cclxuXHRcdHJldHVybiB0aGlzLnV1aWQ7XHJcblxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogUmV0dXJucyB0aGUgdXBkYXRlIHR5cGUgb2Yge0BsaW5rIE5vZGUjdXBkYXRlfS5cclxuXHQgKlxyXG5cdCAqIEByZXR1cm4ge05vZGVVcGRhdGVUeXBlfSBUaGUgdXBkYXRlIHR5cGUuXHJcblx0ICovXHJcblx0Z2V0VXBkYXRlVHlwZSgpIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy51cGRhdGVUeXBlO1xyXG5cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFJldHVybnMgdGhlIHVwZGF0ZSB0eXBlIG9mIHtAbGluayBOb2RlI3VwZGF0ZUJlZm9yZX0uXHJcblx0ICpcclxuXHQgKiBAcmV0dXJuIHtOb2RlVXBkYXRlVHlwZX0gVGhlIHVwZGF0ZSB0eXBlLlxyXG5cdCAqL1xyXG5cdGdldFVwZGF0ZUJlZm9yZVR5cGUoKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMudXBkYXRlQmVmb3JlVHlwZTtcclxuXHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBSZXR1cm5zIHRoZSB1cGRhdGUgdHlwZSBvZiB7QGxpbmsgTm9kZSN1cGRhdGVBZnRlcn0uXHJcblx0ICpcclxuXHQgKiBAcmV0dXJuIHtOb2RlVXBkYXRlVHlwZX0gVGhlIHVwZGF0ZSB0eXBlLlxyXG5cdCAqL1xyXG5cdGdldFVwZGF0ZUFmdGVyVHlwZSgpIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy51cGRhdGVBZnRlclR5cGU7XHJcblxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogQ2VydGFpbiB0eXBlcyBhcmUgY29tcG9zZWQgb2YgbXVsdGlwbGUgZWxlbWVudHMuIEZvciBleGFtcGxlIGEgYHZlYzNgXHJcblx0ICogaXMgY29tcG9zZWQgb2YgdGhyZWUgYGZsb2F0YCB2YWx1ZXMuIFRoaXMgbWV0aG9kIHJldHVybnMgdGhlIHR5cGUgb2ZcclxuXHQgKiB0aGVzZSBlbGVtZW50cy5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7Tm9kZUJ1aWxkZXJ9IGJ1aWxkZXIgLSBUaGUgY3VycmVudCBub2RlIGJ1aWxkZXIuXHJcblx0ICogQHJldHVybiB7U3RyaW5nfSBUaGUgdHlwZSBvZiB0aGUgbm9kZS5cclxuXHQgKi9cclxuXHRnZXRFbGVtZW50VHlwZSggYnVpbGRlciApIHtcclxuXHJcblx0XHRjb25zdCB0eXBlID0gdGhpcy5nZXROb2RlVHlwZSggYnVpbGRlciApO1xyXG5cdFx0Y29uc3QgZWxlbWVudFR5cGUgPSBidWlsZGVyLmdldEVsZW1lbnRUeXBlKCB0eXBlICk7XHJcblxyXG5cdFx0cmV0dXJuIGVsZW1lbnRUeXBlO1xyXG5cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFJldHVybnMgdGhlIG5vZGUncyB0eXBlLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtOb2RlQnVpbGRlcn0gYnVpbGRlciAtIFRoZSBjdXJyZW50IG5vZGUgYnVpbGRlci5cclxuXHQgKiBAcmV0dXJuIHtTdHJpbmd9IFRoZSB0eXBlIG9mIHRoZSBub2RlLlxyXG5cdCAqL1xyXG5cdGdldE5vZGVUeXBlKCBidWlsZGVyICkge1xyXG5cclxuXHRcdGNvbnN0IG5vZGVQcm9wZXJ0aWVzID0gYnVpbGRlci5nZXROb2RlUHJvcGVydGllcyggdGhpcyApO1xyXG5cclxuXHRcdGlmICggbm9kZVByb3BlcnRpZXMub3V0cHV0Tm9kZSApIHtcclxuXHJcblx0XHRcdHJldHVybiBub2RlUHJvcGVydGllcy5vdXRwdXROb2RlLmdldE5vZGVUeXBlKCBidWlsZGVyICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzLm5vZGVUeXBlO1xyXG5cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFRoaXMgbWV0aG9kIGlzIHVzZWQgZHVyaW5nIHRoZSBidWlsZCBwcm9jZXNzIG9mIGEgbm9kZSBhbmQgZW5zdXJlc1xyXG5cdCAqIGVxdWFsIG5vZGVzIGFyZSBub3QgYnVpbHQgbXVsdGlwbGUgdGltZXMgYnV0IGp1c3Qgb25jZS4gRm9yIGV4YW1wbGUgaWZcclxuXHQgKiBgYXR0cmlidXRlKCAndXYnIClgIGlzIHVzZWQgbXVsdGlwbGUgdGltZXMgYnkgdGhlIHVzZXIsIHRoZSBidWlsZFxyXG5cdCAqIHByb2Nlc3MgbWFrZXMgc3VyZSB0byBwcm9jZXNzIGp1c3QgdGhlIGZpcnN0IG5vZGUuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge05vZGVCdWlsZGVyfSBidWlsZGVyIC0gVGhlIGN1cnJlbnQgbm9kZSBidWlsZGVyLlxyXG5cdCAqIEByZXR1cm4ge05vZGV9IFRoZSBzaGFyZWQgbm9kZSBpZiBwb3NzaWJsZS4gT3RoZXJ3aXNlIGB0aGlzYCBpcyByZXR1cm5lZC5cclxuXHQgKi9cclxuXHRnZXRTaGFyZWQoIGJ1aWxkZXIgKSB7XHJcblxyXG5cdFx0Y29uc3QgaGFzaCA9IHRoaXMuZ2V0SGFzaCggYnVpbGRlciApO1xyXG5cdFx0Y29uc3Qgbm9kZUZyb21IYXNoID0gYnVpbGRlci5nZXROb2RlRnJvbUhhc2goIGhhc2ggKTtcclxuXHJcblx0XHRyZXR1cm4gbm9kZUZyb21IYXNoIHx8IHRoaXM7XHJcblxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogUmVwcmVzZW50cyB0aGUgc2V0dXAgc3RhZ2Ugd2hpY2ggaXMgdGhlIGZpcnN0IHN0ZXAgb2YgdGhlIGJ1aWxkIHByb2Nlc3MsIHNlZSB7QGxpbmsgTm9kZSNidWlsZH0gbWV0aG9kLlxyXG5cdCAqIFRoaXMgbWV0aG9kIGlzIG9mdGVuIG92ZXJ3cml0dGVuIGluIGRlcml2ZWQgbW9kdWxlcyB0byBwcmVwYXJlIHRoZSBub2RlIHdoaWNoIGlzIHVzZWQgYXMgdGhlIG91dHB1dC9yZXN1bHQuXHJcblx0ICogVGhlIG91dHB1dCBub2RlIG11c3QgYmUgcmV0dXJuZWQgaW4gdGhlIGByZXR1cm5gIHN0YXRlbWVudC5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7Tm9kZUJ1aWxkZXJ9IGJ1aWxkZXIgLSBUaGUgY3VycmVudCBub2RlIGJ1aWxkZXIuXHJcblx0ICogQHJldHVybiB7Tm9kZT99IFRoZSBvdXRwdXQgbm9kZS5cclxuXHQgKi9cclxuXHRzZXR1cCggYnVpbGRlciApIHtcclxuXHJcblx0XHRjb25zdCBub2RlUHJvcGVydGllcyA9IGJ1aWxkZXIuZ2V0Tm9kZVByb3BlcnRpZXMoIHRoaXMgKTtcclxuXHJcblx0XHRsZXQgaW5kZXggPSAwO1xyXG5cclxuXHRcdGZvciAoIGNvbnN0IGNoaWxkTm9kZSBvZiB0aGlzLmdldENoaWxkcmVuKCkgKSB7XHJcblxyXG5cdFx0XHRub2RlUHJvcGVydGllc1sgJ25vZGUnICsgaW5kZXggKysgXSA9IGNoaWxkTm9kZTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gcmV0dXJuIGEgb3V0cHV0Tm9kZSBpZiBleGlzdHNcclxuXHRcdHJldHVybiBudWxsO1xyXG5cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFJlcHJlc2VudHMgdGhlIGFuYWx5emUgc3RhZ2Ugd2hpY2ggaXMgdGhlIHNlY29uZCBzdGVwIG9mIHRoZSBidWlsZCBwcm9jZXNzLCBzZWUge0BsaW5rIE5vZGUjYnVpbGR9IG1ldGhvZC5cclxuXHQgKiBUaGlzIHN0YWdlIGFuYWx5emVzIHRoZSBub2RlIGhpZXJhcmNoeSBhbmQgZW5zdXJlcyBkZXNjZW5kZW50IG5vZGVzIGFyZSBidWlsdC5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7Tm9kZUJ1aWxkZXJ9IGJ1aWxkZXIgLSBUaGUgY3VycmVudCBub2RlIGJ1aWxkZXIuXHJcblx0ICovXHJcblx0YW5hbHl6ZSggYnVpbGRlciApIHtcclxuXHJcblx0XHRjb25zdCB1c2FnZUNvdW50ID0gYnVpbGRlci5pbmNyZWFzZVVzYWdlKCB0aGlzICk7XHJcblxyXG5cdFx0aWYgKCB1c2FnZUNvdW50ID09PSAxICkge1xyXG5cclxuXHRcdFx0Ly8gbm9kZSBmbG93IGNoaWxkcmVuXHJcblxyXG5cdFx0XHRjb25zdCBub2RlUHJvcGVydGllcyA9IGJ1aWxkZXIuZ2V0Tm9kZVByb3BlcnRpZXMoIHRoaXMgKTtcclxuXHJcblx0XHRcdGZvciAoIGNvbnN0IGNoaWxkTm9kZSBvZiBPYmplY3QudmFsdWVzKCBub2RlUHJvcGVydGllcyApICkge1xyXG5cclxuXHRcdFx0XHRpZiAoIGNoaWxkTm9kZSAmJiBjaGlsZE5vZGUuaXNOb2RlID09PSB0cnVlICkge1xyXG5cclxuXHRcdFx0XHRcdGNoaWxkTm9kZS5idWlsZCggYnVpbGRlciApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFJlcHJlc2VudHMgdGhlIGdlbmVyYXRlIHN0YWdlIHdoaWNoIGlzIHRoZSB0aGlyZCBzdGVwIG9mIHRoZSBidWlsZCBwcm9jZXNzLCBzZWUge0BsaW5rIE5vZGUjYnVpbGR9IG1ldGhvZC5cclxuXHQgKiBUaGlzIHN0YXRlIGJ1aWxkcyB0aGUgb3V0cHV0IG5vZGUgYW5kIHJldHVybnMgdGhlIHJlc3VsdGluZyBzaGFkZXIgc3RyaW5nLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtOb2RlQnVpbGRlcn0gYnVpbGRlciAtIFRoZSBjdXJyZW50IG5vZGUgYnVpbGRlci5cclxuXHQgKiBAcGFyYW0ge1N0cmluZz99IG91dHB1dCAtIENhbiBiZSB1c2VkIHRvIGRlZmluZSB0aGUgb3V0cHV0IHR5cGUuXHJcblx0ICogQHJldHVybiB7U3RyaW5nP30gVGhlIGdlbmVyYXRlZCBzaGFkZXIgc3RyaW5nLlxyXG5cdCAqL1xyXG5cdGdlbmVyYXRlKCBidWlsZGVyLCBvdXRwdXQgKSB7XHJcblxyXG5cdFx0Y29uc3QgeyBvdXRwdXROb2RlIH0gPSBidWlsZGVyLmdldE5vZGVQcm9wZXJ0aWVzKCB0aGlzICk7XHJcblxyXG5cdFx0aWYgKCBvdXRwdXROb2RlICYmIG91dHB1dE5vZGUuaXNOb2RlID09PSB0cnVlICkge1xyXG5cclxuXHRcdFx0cmV0dXJuIG91dHB1dE5vZGUuYnVpbGQoIGJ1aWxkZXIsIG91dHB1dCApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBUaGUgbWV0aG9kIGNhbiBiZSBpbXBsZW1lbnRlZCB0byB1cGRhdGUgdGhlIG5vZGUncyBpbnRlcm5hbCBzdGF0ZSBiZWZvcmUgaXQgaXMgdXNlZCB0byByZW5kZXIgYW4gb2JqZWN0LlxyXG5cdCAqIFRoZSB7QGxpbmsgTm9kZSN1cGRhdGVCZWZvcmVUeXBlfSBwcm9wZXJ0eSBkZWZpbmVzIGhvdyBvZnRlbiB0aGUgdXBkYXRlIGlzIGV4ZWN1dGVkLlxyXG5cdCAqXHJcblx0ICogQGFic3RyYWN0XHJcblx0ICogQHBhcmFtIHtOb2RlRnJhbWV9IGZyYW1lIC0gQSByZWZlcmVuY2UgdG8gdGhlIGN1cnJlbnQgbm9kZSBmcmFtZS5cclxuXHQgKiBAcmV0dXJuIHtCb29sZWFuP30gQW4gb3B0aW9uYWwgYm9vbCB0aGF0IGluZGljYXRlcyB3aGV0aGVyIHRoZSBpbXBsZW1lbnRhdGlvbiBhY3R1YWxseSBwZXJmb3JtZWQgYW4gdXBkYXRlIG9yIG5vdCAoZS5nLiBkdWUgdG8gY2FjaGluZykuXHJcblx0ICovXHJcblx0dXBkYXRlQmVmb3JlKCAvKmZyYW1lKi8gKSB7XHJcblxyXG5cdFx0Y29uc29sZS53YXJuKCAnQWJzdHJhY3QgZnVuY3Rpb24uJyApO1xyXG5cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFRoZSBtZXRob2QgY2FuIGJlIGltcGxlbWVudGVkIHRvIHVwZGF0ZSB0aGUgbm9kZSdzIGludGVybmFsIHN0YXRlIGFmdGVyIGl0IHdhcyB1c2VkIHRvIHJlbmRlciBhbiBvYmplY3QuXHJcblx0ICogVGhlIHtAbGluayBOb2RlI3VwZGF0ZUFmdGVyVHlwZX0gcHJvcGVydHkgZGVmaW5lcyBob3cgb2Z0ZW4gdGhlIHVwZGF0ZSBpcyBleGVjdXRlZC5cclxuXHQgKlxyXG5cdCAqIEBhYnN0cmFjdFxyXG5cdCAqIEBwYXJhbSB7Tm9kZUZyYW1lfSBmcmFtZSAtIEEgcmVmZXJlbmNlIHRvIHRoZSBjdXJyZW50IG5vZGUgZnJhbWUuXHJcblx0ICogQHJldHVybiB7Qm9vbGVhbj99IEFuIG9wdGlvbmFsIGJvb2wgdGhhdCBpbmRpY2F0ZXMgd2hldGhlciB0aGUgaW1wbGVtZW50YXRpb24gYWN0dWFsbHkgcGVyZm9ybWVkIGFuIHVwZGF0ZSBvciBub3QgKGUuZy4gZHVlIHRvIGNhY2hpbmcpLlxyXG5cdCAqL1xyXG5cdHVwZGF0ZUFmdGVyKCAvKmZyYW1lKi8gKSB7XHJcblxyXG5cdFx0Y29uc29sZS53YXJuKCAnQWJzdHJhY3QgZnVuY3Rpb24uJyApO1xyXG5cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFRoZSBtZXRob2QgY2FuIGJlIGltcGxlbWVudGVkIHRvIHVwZGF0ZSB0aGUgbm9kZSdzIGludGVybmFsIHN0YXRlIHdoZW4gaXQgaXMgdXNlZCB0byByZW5kZXIgYW4gb2JqZWN0LlxyXG5cdCAqIFRoZSB7QGxpbmsgTm9kZSN1cGRhdGVUeXBlfSBwcm9wZXJ0eSBkZWZpbmVzIGhvdyBvZnRlbiB0aGUgdXBkYXRlIGlzIGV4ZWN1dGVkLlxyXG5cdCAqXHJcblx0ICogQGFic3RyYWN0XHJcblx0ICogQHBhcmFtIHtOb2RlRnJhbWV9IGZyYW1lIC0gQSByZWZlcmVuY2UgdG8gdGhlIGN1cnJlbnQgbm9kZSBmcmFtZS5cclxuXHQgKiBAcmV0dXJuIHtCb29sZWFuP30gQW4gb3B0aW9uYWwgYm9vbCB0aGF0IGluZGljYXRlcyB3aGV0aGVyIHRoZSBpbXBsZW1lbnRhdGlvbiBhY3R1YWxseSBwZXJmb3JtZWQgYW4gdXBkYXRlIG9yIG5vdCAoZS5nLiBkdWUgdG8gY2FjaGluZykuXHJcblx0ICovXHJcblx0dXBkYXRlKCAvKmZyYW1lKi8gKSB7XHJcblxyXG5cdFx0Y29uc29sZS53YXJuKCAnQWJzdHJhY3QgZnVuY3Rpb24uJyApO1xyXG5cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFRoaXMgbWV0aG9kIHBlcmZvcm1zIHRoZSBidWlsZCBvZiBhIG5vZGUuIFRoZSBiZWhhdmlvciBvZiB0aGlzIG1ldGhvZCBhcyB3ZWxsIGFzIGl0cyByZXR1cm4gdmFsdWUgZGVwZW5kXHJcblx0ICogb24gdGhlIGN1cnJlbnQgYnVpbGQgc3RhZ2UgKHNldHVwLCBhbmFseXplIG9yIGdlbmVyYXRlKS5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7Tm9kZUJ1aWxkZXJ9IGJ1aWxkZXIgLSBUaGUgY3VycmVudCBub2RlIGJ1aWxkZXIuXHJcblx0ICogQHBhcmFtIHtTdHJpbmc/fSBvdXRwdXQgLSBDYW4gYmUgdXNlZCB0byBkZWZpbmUgdGhlIG91dHB1dCB0eXBlLlxyXG5cdCAqIEByZXR1cm4ge1N0cmluZz99IFdoZW4gdGhpcyBtZXRob2QgaXMgZXhlY3V0ZWQgaW4gdGhlIHNldHVwIG9yIGFuYWx5emUgc3RhZ2UsIGBudWxsYCBpcyByZXR1cm5lZC4gSW4gdGhlIGdlbmVyYXRlIHN0YWdlLCB0aGUgZ2VuZXJhdGVkIHNoYWRlciBzdHJpbmcuXHJcblx0ICovXHJcblx0YnVpbGQoIGJ1aWxkZXIsIG91dHB1dCA9IG51bGwgKSB7XHJcblxyXG5cdFx0Y29uc3QgcmVmTm9kZSA9IHRoaXMuZ2V0U2hhcmVkKCBidWlsZGVyICk7XHJcblxyXG5cdFx0aWYgKCB0aGlzICE9PSByZWZOb2RlICkge1xyXG5cclxuXHRcdFx0cmV0dXJuIHJlZk5vZGUuYnVpbGQoIGJ1aWxkZXIsIG91dHB1dCApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRidWlsZGVyLmFkZE5vZGUoIHRoaXMgKTtcclxuXHRcdGJ1aWxkZXIuYWRkQ2hhaW4oIHRoaXMgKTtcclxuXHJcblx0XHQvKiBCdWlsZCBzdGFnZXMgZXhwZWN0ZWQgcmVzdWx0czpcclxuXHRcdFx0LSBcInNldHVwXCJcdFx0LT4gTm9kZVxyXG5cdFx0XHQtIFwiYW5hbHl6ZVwiXHRcdC0+IG51bGxcclxuXHRcdFx0LSBcImdlbmVyYXRlXCJcdC0+IFN0cmluZ1xyXG5cdFx0Ki9cclxuXHRcdGxldCByZXN1bHQgPSBudWxsO1xyXG5cclxuXHRcdGNvbnN0IGJ1aWxkU3RhZ2UgPSBidWlsZGVyLmdldEJ1aWxkU3RhZ2UoKTtcclxuXHJcblx0XHRpZiAoIGJ1aWxkU3RhZ2UgPT09ICdzZXR1cCcgKSB7XHJcblxyXG5cdFx0XHR0aGlzLnVwZGF0ZVJlZmVyZW5jZSggYnVpbGRlciApO1xyXG5cclxuXHRcdFx0Y29uc3QgcHJvcGVydGllcyA9IGJ1aWxkZXIuZ2V0Tm9kZVByb3BlcnRpZXMoIHRoaXMgKTtcclxuXHJcblx0XHRcdGlmICggcHJvcGVydGllcy5pbml0aWFsaXplZCAhPT0gdHJ1ZSApIHtcclxuXHJcblx0XHRcdFx0Y29uc3Qgc3RhY2tOb2Rlc0JlZm9yZVNldHVwID0gYnVpbGRlci5zdGFjay5ub2Rlcy5sZW5ndGg7XHJcblxyXG5cdFx0XHRcdHByb3BlcnRpZXMuaW5pdGlhbGl6ZWQgPSB0cnVlO1xyXG5cdFx0XHRcdHByb3BlcnRpZXMub3V0cHV0Tm9kZSA9IHRoaXMuc2V0dXAoIGJ1aWxkZXIgKTtcclxuXHJcblx0XHRcdFx0aWYgKCBwcm9wZXJ0aWVzLm91dHB1dE5vZGUgIT09IG51bGwgJiYgYnVpbGRlci5zdGFjay5ub2Rlcy5sZW5ndGggIT09IHN0YWNrTm9kZXNCZWZvcmVTZXR1cCApIHtcclxuXHJcblx0XHRcdFx0XHQvLyAhISBubyBvdXRwdXROb2RlICEhXHJcblx0XHRcdFx0XHQvL3Byb3BlcnRpZXMub3V0cHV0Tm9kZSA9IGJ1aWxkZXIuc3RhY2s7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0Zm9yICggY29uc3QgY2hpbGROb2RlIG9mIE9iamVjdC52YWx1ZXMoIHByb3BlcnRpZXMgKSApIHtcclxuXHJcblx0XHRcdFx0XHRpZiAoIGNoaWxkTm9kZSAmJiBjaGlsZE5vZGUuaXNOb2RlID09PSB0cnVlICkge1xyXG5cclxuXHRcdFx0XHRcdFx0Y2hpbGROb2RlLmJ1aWxkKCBidWlsZGVyICk7XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fSBlbHNlIGlmICggYnVpbGRTdGFnZSA9PT0gJ2FuYWx5emUnICkge1xyXG5cclxuXHRcdFx0dGhpcy5hbmFseXplKCBidWlsZGVyICk7XHJcblxyXG5cdFx0fSBlbHNlIGlmICggYnVpbGRTdGFnZSA9PT0gJ2dlbmVyYXRlJyApIHtcclxuXHJcblx0XHRcdGNvbnN0IGlzR2VuZXJhdGVPbmNlID0gdGhpcy5nZW5lcmF0ZS5sZW5ndGggPT09IDE7XHJcblxyXG5cdFx0XHRpZiAoIGlzR2VuZXJhdGVPbmNlICkge1xyXG5cclxuXHRcdFx0XHRjb25zdCB0eXBlID0gdGhpcy5nZXROb2RlVHlwZSggYnVpbGRlciApO1xyXG5cdFx0XHRcdGNvbnN0IG5vZGVEYXRhID0gYnVpbGRlci5nZXREYXRhRnJvbU5vZGUoIHRoaXMgKTtcclxuXHJcblx0XHRcdFx0cmVzdWx0ID0gbm9kZURhdGEuc25pcHBldDtcclxuXHJcblx0XHRcdFx0aWYgKCByZXN1bHQgPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0XHRyZXN1bHQgPSB0aGlzLmdlbmVyYXRlKCBidWlsZGVyICkgfHwgJyc7XHJcblxyXG5cdFx0XHRcdFx0bm9kZURhdGEuc25pcHBldCA9IHJlc3VsdDtcclxuXHJcblx0XHRcdFx0fSBlbHNlIGlmICggbm9kZURhdGEuZmxvd0NvZGVzICE9PSB1bmRlZmluZWQgJiYgYnVpbGRlci5jb250ZXh0Lm5vZGVCbG9jayAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRcdGJ1aWxkZXIuYWRkRmxvd0NvZGVIaWVyYXJjaHkoIHRoaXMsIGJ1aWxkZXIuY29udGV4dC5ub2RlQmxvY2sgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRyZXN1bHQgPSBidWlsZGVyLmZvcm1hdCggcmVzdWx0LCB0eXBlLCBvdXRwdXQgKTtcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdHJlc3VsdCA9IHRoaXMuZ2VuZXJhdGUoIGJ1aWxkZXIsIG91dHB1dCApIHx8ICcnO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRidWlsZGVyLnJlbW92ZUNoYWluKCB0aGlzICk7XHJcblx0XHRidWlsZGVyLmFkZFNlcXVlbnRpYWxOb2RlKCB0aGlzICk7XHJcblxyXG5cdFx0cmV0dXJuIHJlc3VsdDtcclxuXHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBSZXR1cm5zIHRoZSBjaGlsZCBub2RlcyBhcyBhIEpTT04gb2JqZWN0LlxyXG5cdCAqXHJcblx0ICogQHJldHVybiB7T2JqZWN0fSBUaGUgc2VyaWFsaXplZCBjaGlsZCBvYmplY3RzIGFzIEpTT04uXHJcblx0ICovXHJcblx0Z2V0U2VyaWFsaXplQ2hpbGRyZW4oKSB7XHJcblxyXG5cdFx0cmV0dXJuIGdldE5vZGVDaGlsZHJlbiggdGhpcyApO1xyXG5cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFNlcmlhbGl6ZXMgdGhlIG5vZGUgdG8gSlNPTi5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBqc29uIC0gVGhlIG91dHB1dCBKU09OIG9iamVjdC5cclxuXHQgKi9cclxuXHRzZXJpYWxpemUoIGpzb24gKSB7XHJcblxyXG5cdFx0Y29uc3Qgbm9kZUNoaWxkcmVuID0gdGhpcy5nZXRTZXJpYWxpemVDaGlsZHJlbigpO1xyXG5cclxuXHRcdGNvbnN0IGlucHV0Tm9kZXMgPSB7fTtcclxuXHJcblx0XHRmb3IgKCBjb25zdCB7IHByb3BlcnR5LCBpbmRleCwgY2hpbGROb2RlIH0gb2Ygbm9kZUNoaWxkcmVuICkge1xyXG5cclxuXHRcdFx0aWYgKCBpbmRleCAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRpZiAoIGlucHV0Tm9kZXNbIHByb3BlcnR5IF0gPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0XHRpbnB1dE5vZGVzWyBwcm9wZXJ0eSBdID0gTnVtYmVyLmlzSW50ZWdlciggaW5kZXggKSA/IFtdIDoge307XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0aW5wdXROb2Rlc1sgcHJvcGVydHkgXVsgaW5kZXggXSA9IGNoaWxkTm9kZS50b0pTT04oIGpzb24ubWV0YSApLnV1aWQ7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRpbnB1dE5vZGVzWyBwcm9wZXJ0eSBdID0gY2hpbGROb2RlLnRvSlNPTigganNvbi5tZXRhICkudXVpZDtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBPYmplY3Qua2V5cyggaW5wdXROb2RlcyApLmxlbmd0aCA+IDAgKSB7XHJcblxyXG5cdFx0XHRqc29uLmlucHV0Tm9kZXMgPSBpbnB1dE5vZGVzO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBEZXNlcmlhbGl6ZXMgdGhlIG5vZGUgZnJvbSB0aGUgZ2l2ZW4gSlNPTi5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBqc29uIC0gVGhlIEpTT04gb2JqZWN0LlxyXG5cdCAqL1xyXG5cdGRlc2VyaWFsaXplKCBqc29uICkge1xyXG5cclxuXHRcdGlmICgganNvbi5pbnB1dE5vZGVzICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRjb25zdCBub2RlcyA9IGpzb24ubWV0YS5ub2RlcztcclxuXHJcblx0XHRcdGZvciAoIGNvbnN0IHByb3BlcnR5IGluIGpzb24uaW5wdXROb2RlcyApIHtcclxuXHJcblx0XHRcdFx0aWYgKCBBcnJheS5pc0FycmF5KCBqc29uLmlucHV0Tm9kZXNbIHByb3BlcnR5IF0gKSApIHtcclxuXHJcblx0XHRcdFx0XHRjb25zdCBpbnB1dEFycmF5ID0gW107XHJcblxyXG5cdFx0XHRcdFx0Zm9yICggY29uc3QgdXVpZCBvZiBqc29uLmlucHV0Tm9kZXNbIHByb3BlcnR5IF0gKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRpbnB1dEFycmF5LnB1c2goIG5vZGVzWyB1dWlkIF0gKTtcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0dGhpc1sgcHJvcGVydHkgXSA9IGlucHV0QXJyYXk7XHJcblxyXG5cdFx0XHRcdH0gZWxzZSBpZiAoIHR5cGVvZiBqc29uLmlucHV0Tm9kZXNbIHByb3BlcnR5IF0gPT09ICdvYmplY3QnICkge1xyXG5cclxuXHRcdFx0XHRcdGNvbnN0IGlucHV0T2JqZWN0ID0ge307XHJcblxyXG5cdFx0XHRcdFx0Zm9yICggY29uc3Qgc3ViUHJvcGVydHkgaW4ganNvbi5pbnB1dE5vZGVzWyBwcm9wZXJ0eSBdICkge1xyXG5cclxuXHRcdFx0XHRcdFx0Y29uc3QgdXVpZCA9IGpzb24uaW5wdXROb2Rlc1sgcHJvcGVydHkgXVsgc3ViUHJvcGVydHkgXTtcclxuXHJcblx0XHRcdFx0XHRcdGlucHV0T2JqZWN0WyBzdWJQcm9wZXJ0eSBdID0gbm9kZXNbIHV1aWQgXTtcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0dGhpc1sgcHJvcGVydHkgXSA9IGlucHV0T2JqZWN0O1xyXG5cclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdGNvbnN0IHV1aWQgPSBqc29uLmlucHV0Tm9kZXNbIHByb3BlcnR5IF07XHJcblxyXG5cdFx0XHRcdFx0dGhpc1sgcHJvcGVydHkgXSA9IG5vZGVzWyB1dWlkIF07XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogU2VyaWFsaXplcyB0aGUgbm9kZSBpbnRvIHRoZSB0aHJlZS5qcyBKU09OIE9iamVjdC9TY2VuZSBmb3JtYXQuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge09iamVjdD99IG1ldGEgLSBBbiBvcHRpb25hbCBKU09OIG9iamVjdCB0aGF0IGFscmVhZHkgaG9sZHMgc2VyaWFsaXplZCBkYXRhIGZyb20gb3RoZXIgc2NlbmUgb2JqZWN0cy5cclxuXHQgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBzZXJpYWxpemVkIG5vZGUuXHJcblx0ICovXHJcblx0dG9KU09OKCBtZXRhICkge1xyXG5cclxuXHRcdGNvbnN0IHsgdXVpZCwgdHlwZSB9ID0gdGhpcztcclxuXHRcdGNvbnN0IGlzUm9vdCA9ICggbWV0YSA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiBtZXRhID09PSAnc3RyaW5nJyApO1xyXG5cclxuXHRcdGlmICggaXNSb290ICkge1xyXG5cclxuXHRcdFx0bWV0YSA9IHtcclxuXHRcdFx0XHR0ZXh0dXJlczoge30sXHJcblx0XHRcdFx0aW1hZ2VzOiB7fSxcclxuXHRcdFx0XHRub2Rlczoge31cclxuXHRcdFx0fTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gc2VyaWFsaXplXHJcblxyXG5cdFx0bGV0IGRhdGEgPSBtZXRhLm5vZGVzWyB1dWlkIF07XHJcblxyXG5cdFx0aWYgKCBkYXRhID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRkYXRhID0ge1xyXG5cdFx0XHRcdHV1aWQsXHJcblx0XHRcdFx0dHlwZSxcclxuXHRcdFx0XHRtZXRhLFxyXG5cdFx0XHRcdG1ldGFkYXRhOiB7XHJcblx0XHRcdFx0XHR2ZXJzaW9uOiA0LjYsXHJcblx0XHRcdFx0XHR0eXBlOiAnTm9kZScsXHJcblx0XHRcdFx0XHRnZW5lcmF0b3I6ICdOb2RlLnRvSlNPTidcclxuXHRcdFx0XHR9XHJcblx0XHRcdH07XHJcblxyXG5cdFx0XHRpZiAoIGlzUm9vdCAhPT0gdHJ1ZSApIG1ldGEubm9kZXNbIGRhdGEudXVpZCBdID0gZGF0YTtcclxuXHJcblx0XHRcdHRoaXMuc2VyaWFsaXplKCBkYXRhICk7XHJcblxyXG5cdFx0XHRkZWxldGUgZGF0YS5tZXRhO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvLyBUT0RPOiBDb3BpZWQgZnJvbSBPYmplY3QzRC50b0pTT05cclxuXHJcblx0XHRmdW5jdGlvbiBleHRyYWN0RnJvbUNhY2hlKCBjYWNoZSApIHtcclxuXHJcblx0XHRcdGNvbnN0IHZhbHVlcyA9IFtdO1xyXG5cclxuXHRcdFx0Zm9yICggY29uc3Qga2V5IGluIGNhY2hlICkge1xyXG5cclxuXHRcdFx0XHRjb25zdCBkYXRhID0gY2FjaGVbIGtleSBdO1xyXG5cdFx0XHRcdGRlbGV0ZSBkYXRhLm1ldGFkYXRhO1xyXG5cdFx0XHRcdHZhbHVlcy5wdXNoKCBkYXRhICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRyZXR1cm4gdmFsdWVzO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIGlzUm9vdCApIHtcclxuXHJcblx0XHRcdGNvbnN0IHRleHR1cmVzID0gZXh0cmFjdEZyb21DYWNoZSggbWV0YS50ZXh0dXJlcyApO1xyXG5cdFx0XHRjb25zdCBpbWFnZXMgPSBleHRyYWN0RnJvbUNhY2hlKCBtZXRhLmltYWdlcyApO1xyXG5cdFx0XHRjb25zdCBub2RlcyA9IGV4dHJhY3RGcm9tQ2FjaGUoIG1ldGEubm9kZXMgKTtcclxuXHJcblx0XHRcdGlmICggdGV4dHVyZXMubGVuZ3RoID4gMCApIGRhdGEudGV4dHVyZXMgPSB0ZXh0dXJlcztcclxuXHRcdFx0aWYgKCBpbWFnZXMubGVuZ3RoID4gMCApIGRhdGEuaW1hZ2VzID0gaW1hZ2VzO1xyXG5cdFx0XHRpZiAoIG5vZGVzLmxlbmd0aCA+IDAgKSBkYXRhLm5vZGVzID0gbm9kZXM7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBkYXRhO1xyXG5cclxuXHR9XHJcblxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBOb2RlO1xyXG4iLCJpbXBvcnQgTm9kZSBmcm9tICcuLi9jb3JlL05vZGUuanMnO1xyXG5cclxuLyoqXHJcbiAqIEJhc2UgY2xhc3MgZm9yIHJlcHJlc2VudGluZyBlbGVtZW50IGFjY2VzcyBvbiBhbiBhcnJheS1saWtlXHJcbiAqIG5vZGUgZGF0YSBzdHJ1Y3R1cmVzLlxyXG4gKlxyXG4gKiBAYXVnbWVudHMgTm9kZVxyXG4gKi9cclxuY2xhc3MgQXJyYXlFbGVtZW50Tm9kZSBleHRlbmRzIE5vZGUgeyAvLyBAVE9ETzogSWYgZXh0ZW5kaW5nIGZyb20gVGVtcE5vZGUgaXQgYnJlYWtzIHdlYmdwdV9jb21wdXRlXHJcblxyXG5cdHN0YXRpYyBnZXQgdHlwZSgpIHtcclxuXHJcblx0XHRyZXR1cm4gJ0FycmF5RWxlbWVudE5vZGUnO1xyXG5cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIENvbnN0cnVjdHMgYW4gYXJyYXkgZWxlbWVudCBub2RlLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtOb2RlfSBub2RlIC0gVGhlIGFycmF5LWxpa2Ugbm9kZS5cclxuXHQgKiBAcGFyYW0ge05vZGV9IGluZGV4Tm9kZSAtIFRoZSBpbmRleCBub2RlIHRoYXQgZGVmaW5lcyB0aGUgZWxlbWVudCBhY2Nlc3MuXHJcblx0ICovXHJcblx0Y29uc3RydWN0b3IoIG5vZGUsIGluZGV4Tm9kZSApIHtcclxuXHJcblx0XHRzdXBlcigpO1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogVGhlIGFycmF5LWxpa2Ugbm9kZS5cclxuXHRcdCAqXHJcblx0XHQgKiBAdHlwZSB7Tm9kZX1cclxuXHRcdCAqL1xyXG5cdFx0dGhpcy5ub2RlID0gbm9kZTtcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIFRoZSBpbmRleCBub2RlIHRoYXQgZGVmaW5lcyB0aGUgZWxlbWVudCBhY2Nlc3MuXHJcblx0XHQgKlxyXG5cdFx0ICogQHR5cGUge05vZGV9XHJcblx0XHQgKi9cclxuXHRcdHRoaXMuaW5kZXhOb2RlID0gaW5kZXhOb2RlO1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogVGhpcyBmbGFnIGNhbiBiZSB1c2VkIGZvciB0eXBlIHRlc3RpbmcuXHJcblx0XHQgKlxyXG5cdFx0ICogQHR5cGUge0Jvb2xlYW59XHJcblx0XHQgKiBAcmVhZG9ubHlcclxuXHRcdCAqIEBkZWZhdWx0IHRydWVcclxuXHRcdCAqL1xyXG5cdFx0dGhpcy5pc0FycmF5RWxlbWVudE5vZGUgPSB0cnVlO1xyXG5cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFRoaXMgbWV0aG9kIGlzIG92ZXJ3cml0dGVuIHNpbmNlIHRoZSBub2RlIHR5cGUgaXMgaW5mZXJyZWQgZnJvbSB0aGUgYXJyYXktbGlrZSBub2RlLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtOb2RlQnVpbGRlcn0gYnVpbGRlciAtIFRoZSBjdXJyZW50IG5vZGUgYnVpbGRlci5cclxuXHQgKiBAcmV0dXJuIHtTdHJpbmd9IFRoZSBub2RlIHR5cGUuXHJcblx0ICovXHJcblx0Z2V0Tm9kZVR5cGUoIGJ1aWxkZXIgKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMubm9kZS5nZXRFbGVtZW50VHlwZSggYnVpbGRlciApO1xyXG5cclxuXHR9XHJcblxyXG5cdGdlbmVyYXRlKCBidWlsZGVyICkge1xyXG5cclxuXHRcdGNvbnN0IG5vZGVTbmlwcGV0ID0gdGhpcy5ub2RlLmJ1aWxkKCBidWlsZGVyICk7XHJcblx0XHRjb25zdCBpbmRleFNuaXBwZXQgPSB0aGlzLmluZGV4Tm9kZS5idWlsZCggYnVpbGRlciwgJ3VpbnQnICk7XHJcblxyXG5cdFx0cmV0dXJuIGAke25vZGVTbmlwcGV0fVsgJHtpbmRleFNuaXBwZXR9IF1gO1xyXG5cclxuXHR9XHJcblxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBBcnJheUVsZW1lbnROb2RlO1xyXG4iLCJpbXBvcnQgTm9kZSBmcm9tICcuLi9jb3JlL05vZGUuanMnO1xyXG5cclxuLyoqXHJcbiAqIFRoaXMgbW9kdWxlIGlzIHBhcnQgb2YgdGhlIFRTTCBjb3JlIGFuZCB1c3VhbGx5IG5vdCB1c2VkIGluIGFwcCBsZXZlbCBjb2RlLlxyXG4gKiBJdCByZXByZXNlbnRzIGEgY29udmVydCBvcGVyYXRpb24gZHVyaW5nIHRoZSBzaGFkZXIgZ2VuZXJhdGlvbiBwcm9jZXNzXHJcbiAqIG1lYW5pbmcgaXQgY29udmVydHMgdGhlIGRhdGEgdHlwZSBvZiBhIG5vZGUgdG8gYSB0YXJnZXQgZGF0YSB0eXBlLlxyXG4gKlxyXG4gKiBAYXVnbWVudHMgTm9kZVxyXG4gKi9cclxuY2xhc3MgQ29udmVydE5vZGUgZXh0ZW5kcyBOb2RlIHtcclxuXHJcblx0c3RhdGljIGdldCB0eXBlKCkge1xyXG5cclxuXHRcdHJldHVybiAnQ29udmVydE5vZGUnO1xyXG5cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIENvbnN0cnVjdHMgYSBuZXcgY29udmVydCBub2RlLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtOb2RlfSBub2RlIC0gVGhlIG5vZGUgd2hpY2ggdHlwZSBzaG91bGQgYmUgY29udmVydGVkLlxyXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBjb252ZXJ0VG8gLSBUaGUgdGFyZ2V0IG5vZGUgdHlwZS4gTXVsdGlwbGUgdHlwZXMgY2FuIGJlIGRlZmluZWQgYnkgc2VwYXJhdGluZyB0aGVtIHdpdGggYSBgfGAgc2lnbi5cclxuXHQgKi9cclxuXHRjb25zdHJ1Y3Rvciggbm9kZSwgY29udmVydFRvICkge1xyXG5cclxuXHRcdHN1cGVyKCk7XHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBUaGUgbm9kZSB3aGljaCB0eXBlIHNob3VsZCBiZSBjb252ZXJ0ZWQuXHJcblx0XHQgKlxyXG5cdFx0ICogQHR5cGUge05vZGV9XHJcblx0XHQgKi9cclxuXHRcdHRoaXMubm9kZSA9IG5vZGU7XHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBUaGUgdGFyZ2V0IG5vZGUgdHlwZS4gTXVsdGlwbGUgdHlwZXMgY2FuIGJlIGRlZmluZWQgYnkgc2VwYXJhdGluZyB0aGVtIHdpdGggYSBgfGAgc2lnbi5cclxuXHRcdCAqXHJcblx0XHQgKiBAdHlwZSB7U3RyaW5nfVxyXG5cdFx0ICovXHJcblx0XHR0aGlzLmNvbnZlcnRUbyA9IGNvbnZlcnRUbztcclxuXHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBUaGlzIG1ldGhvZCBpcyBvdmVyd3JpdHRlbiBzaW5jZSB0aGUgaW1wbGVtZW50YXRpb24gdHJpZXMgdG8gaW5mZXIgdGhlIGJlc3RcclxuXHQgKiBtYXRjaGluZyB0eXBlIGZyb20gdGhlIHtAbGluayBDb252ZXJ0Tm9kZSNjb252ZXJ0VG99IHByb3BlcnR5LlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtOb2RlQnVpbGRlcn0gYnVpbGRlciAtIFRoZSBjdXJyZW50IG5vZGUgYnVpbGRlci5cclxuXHQgKiBAcmV0dXJuIHtTdHJpbmd9IFRoZSBub2RlIHR5cGUuXHJcblx0ICovXHJcblx0Z2V0Tm9kZVR5cGUoIGJ1aWxkZXIgKSB7XHJcblxyXG5cdFx0Y29uc3QgcmVxdWVzdFR5cGUgPSB0aGlzLm5vZGUuZ2V0Tm9kZVR5cGUoIGJ1aWxkZXIgKTtcclxuXHJcblx0XHRsZXQgY29udmVydFRvID0gbnVsbDtcclxuXHJcblx0XHRmb3IgKCBjb25zdCBvdmVybG9hZGluZ1R5cGUgb2YgdGhpcy5jb252ZXJ0VG8uc3BsaXQoICd8JyApICkge1xyXG5cclxuXHRcdFx0aWYgKCBjb252ZXJ0VG8gPT09IG51bGwgfHwgYnVpbGRlci5nZXRUeXBlTGVuZ3RoKCByZXF1ZXN0VHlwZSApID09PSBidWlsZGVyLmdldFR5cGVMZW5ndGgoIG92ZXJsb2FkaW5nVHlwZSApICkge1xyXG5cclxuXHRcdFx0XHRjb252ZXJ0VG8gPSBvdmVybG9hZGluZ1R5cGU7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBjb252ZXJ0VG87XHJcblxyXG5cdH1cclxuXHJcblx0c2VyaWFsaXplKCBkYXRhICkge1xyXG5cclxuXHRcdHN1cGVyLnNlcmlhbGl6ZSggZGF0YSApO1xyXG5cclxuXHRcdGRhdGEuY29udmVydFRvID0gdGhpcy5jb252ZXJ0VG87XHJcblxyXG5cdH1cclxuXHJcblx0ZGVzZXJpYWxpemUoIGRhdGEgKSB7XHJcblxyXG5cdFx0c3VwZXIuZGVzZXJpYWxpemUoIGRhdGEgKTtcclxuXHJcblx0XHR0aGlzLmNvbnZlcnRUbyA9IGRhdGEuY29udmVydFRvO1xyXG5cclxuXHR9XHJcblxyXG5cdGdlbmVyYXRlKCBidWlsZGVyLCBvdXRwdXQgKSB7XHJcblxyXG5cdFx0Y29uc3Qgbm9kZSA9IHRoaXMubm9kZTtcclxuXHRcdGNvbnN0IHR5cGUgPSB0aGlzLmdldE5vZGVUeXBlKCBidWlsZGVyICk7XHJcblxyXG5cdFx0Y29uc3Qgc25pcHBldCA9IG5vZGUuYnVpbGQoIGJ1aWxkZXIsIHR5cGUgKTtcclxuXHJcblx0XHRyZXR1cm4gYnVpbGRlci5mb3JtYXQoIHNuaXBwZXQsIHR5cGUsIG91dHB1dCApO1xyXG5cclxuXHR9XHJcblxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBDb252ZXJ0Tm9kZTtcclxuIiwiaW1wb3J0IE5vZGUgZnJvbSAnLi9Ob2RlLmpzJztcclxuXHJcbi8qKlxyXG4gKiBUaGlzIG1vZHVsZSB1c2VzIGNhY2hlIG1hbmFnZW1lbnQgdG8gY3JlYXRlIHRlbXBvcmFyeSB2YXJpYWJsZXNcclxuICogaWYgdGhlIG5vZGUgaXMgdXNlZCBtb3JlIHRoYW4gb25jZSB0byBwcmV2ZW50IGR1cGxpY2F0ZSBjYWxjdWxhdGlvbnMuXHJcbiAqXHJcbiAqIFRoZSBjbGFzcyBhY3RzIGFzIGEgYmFzZSBjbGFzcyBmb3IgbWFueSBvdGhlciBub2RlcyB0eXBlcy5cclxuICpcclxuICogQGF1Z21lbnRzIE5vZGVcclxuICovXHJcbmNsYXNzIFRlbXBOb2RlIGV4dGVuZHMgTm9kZSB7XHJcblxyXG5cdHN0YXRpYyBnZXQgdHlwZSgpIHtcclxuXHJcblx0XHRyZXR1cm4gJ1RlbXBOb2RlJztcclxuXHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBDb25zdHJ1Y3RzIGEgdGVtcCBub2RlLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtTdHJpbmc/fSBub2RlVHlwZSAtIFRoZSBub2RlIHR5cGUuXHJcblx0ICovXHJcblx0Y29uc3RydWN0b3IoIG5vZGVUeXBlID0gbnVsbCApIHtcclxuXHJcblx0XHRzdXBlciggbm9kZVR5cGUgKTtcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIFRoaXMgZmxhZyBjYW4gYmUgdXNlZCBmb3IgdHlwZSB0ZXN0aW5nLlxyXG5cdFx0ICpcclxuXHRcdCAqIEB0eXBlIHtCb29sZWFufVxyXG5cdFx0ICogQHJlYWRvbmx5XHJcblx0XHQgKiBAZGVmYXVsdCB0cnVlXHJcblx0XHQgKi9cclxuXHRcdHRoaXMuaXNUZW1wTm9kZSA9IHRydWU7XHJcblxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogV2hldGhlciB0aGlzIG5vZGUgaXMgdXNlZCBtb3JlIHRoYW4gb25jZSBpbiBjb250ZXh0IG9mIG90aGVyIG5vZGVzLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtOb2RlQnVpbGRlcn0gYnVpbGRlciAtIFRoZSBub2RlIGJ1aWxkZXIuXHJcblx0ICogQHJldHVybiB7Qm9vbGVhbn0gQSBmbGFnIHRoYXQgaW5kaWNhdGVzIGlmIHRoZXJlIGlzIG1vcmUgdGhhbiBvbmUgZGVwZW5kZW5jeSB0byBvdGhlciBub2Rlcy5cclxuXHQgKi9cclxuXHRoYXNEZXBlbmRlbmNpZXMoIGJ1aWxkZXIgKSB7XHJcblxyXG5cdFx0cmV0dXJuIGJ1aWxkZXIuZ2V0RGF0YUZyb21Ob2RlKCB0aGlzICkudXNhZ2VDb3VudCA+IDE7XHJcblxyXG5cdH1cclxuXHJcblx0YnVpbGQoIGJ1aWxkZXIsIG91dHB1dCApIHtcclxuXHJcblx0XHRjb25zdCBidWlsZFN0YWdlID0gYnVpbGRlci5nZXRCdWlsZFN0YWdlKCk7XHJcblxyXG5cdFx0aWYgKCBidWlsZFN0YWdlID09PSAnZ2VuZXJhdGUnICkge1xyXG5cclxuXHRcdFx0Y29uc3QgdHlwZSA9IGJ1aWxkZXIuZ2V0VmVjdG9yVHlwZSggdGhpcy5nZXROb2RlVHlwZSggYnVpbGRlciwgb3V0cHV0ICkgKTtcclxuXHRcdFx0Y29uc3Qgbm9kZURhdGEgPSBidWlsZGVyLmdldERhdGFGcm9tTm9kZSggdGhpcyApO1xyXG5cclxuXHRcdFx0aWYgKCBub2RlRGF0YS5wcm9wZXJ0eU5hbWUgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0cmV0dXJuIGJ1aWxkZXIuZm9ybWF0KCBub2RlRGF0YS5wcm9wZXJ0eU5hbWUsIHR5cGUsIG91dHB1dCApO1xyXG5cclxuXHRcdFx0fSBlbHNlIGlmICggdHlwZSAhPT0gJ3ZvaWQnICYmIG91dHB1dCAhPT0gJ3ZvaWQnICYmIHRoaXMuaGFzRGVwZW5kZW5jaWVzKCBidWlsZGVyICkgKSB7XHJcblxyXG5cdFx0XHRcdGNvbnN0IHNuaXBwZXQgPSBzdXBlci5idWlsZCggYnVpbGRlciwgdHlwZSApO1xyXG5cclxuXHRcdFx0XHRjb25zdCBub2RlVmFyID0gYnVpbGRlci5nZXRWYXJGcm9tTm9kZSggdGhpcywgbnVsbCwgdHlwZSApO1xyXG5cdFx0XHRcdGNvbnN0IHByb3BlcnR5TmFtZSA9IGJ1aWxkZXIuZ2V0UHJvcGVydHlOYW1lKCBub2RlVmFyICk7XHJcblxyXG5cdFx0XHRcdGJ1aWxkZXIuYWRkTGluZUZsb3dDb2RlKCBgJHtwcm9wZXJ0eU5hbWV9ID0gJHtzbmlwcGV0fWAsIHRoaXMgKTtcclxuXHJcblx0XHRcdFx0bm9kZURhdGEuc25pcHBldCA9IHNuaXBwZXQ7XHJcblx0XHRcdFx0bm9kZURhdGEucHJvcGVydHlOYW1lID0gcHJvcGVydHlOYW1lO1xyXG5cclxuXHRcdFx0XHRyZXR1cm4gYnVpbGRlci5mb3JtYXQoIG5vZGVEYXRhLnByb3BlcnR5TmFtZSwgdHlwZSwgb3V0cHV0ICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBzdXBlci5idWlsZCggYnVpbGRlciwgb3V0cHV0ICk7XHJcblxyXG5cdH1cclxuXHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IFRlbXBOb2RlO1xyXG4iLCJpbXBvcnQgVGVtcE5vZGUgZnJvbSAnLi4vY29yZS9UZW1wTm9kZS5qcyc7XHJcblxyXG4vKipcclxuICogVGhpcyBtb2R1bGUgaXMgcGFydCBvZiB0aGUgVFNMIGNvcmUgYW5kIHVzdWFsbHkgbm90IHVzZWQgaW4gYXBwIGxldmVsIGNvZGUuXHJcbiAqIEl0IHJlcHJlc2VudHMgYSBqb2luIG9wZXJhdGlvbiBkdXJpbmcgdGhlIHNoYWRlciBnZW5lcmF0aW9uIHByb2Nlc3MuXHJcbiAqIEZvciBleGFtcGxlIGluIGNhbiBjb21wb3NlL2pvaW4gdHdvIHNpbmdsZSBmbG9hdHMgaW50byBhIGB2ZWMyYCB0eXBlLlxyXG4gKlxyXG4gKiBAYXVnbWVudHMgVGVtcE5vZGVcclxuICovXHJcbmNsYXNzIEpvaW5Ob2RlIGV4dGVuZHMgVGVtcE5vZGUge1xyXG5cclxuXHRzdGF0aWMgZ2V0IHR5cGUoKSB7XHJcblxyXG5cdFx0cmV0dXJuICdKb2luTm9kZSc7XHJcblxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogQ29uc3RydWN0cyBhIG5ldyBqb2luIG5vZGUuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge0FycmF5PE5vZGU+fSBub2RlcyAtIEFuIGFycmF5IG9mIG5vZGVzIHRoYXQgc2hvdWxkIGJlIGpvaW5lZC5cclxuXHQgKiBAcGFyYW0ge1N0cmluZz99IFtub2RlVHlwZT1udWxsXSAtIFRoZSBub2RlIHR5cGUuXHJcblx0ICovXHJcblx0Y29uc3RydWN0b3IoIG5vZGVzID0gW10sIG5vZGVUeXBlID0gbnVsbCApIHtcclxuXHJcblx0XHRzdXBlciggbm9kZVR5cGUgKTtcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIEFuIGFycmF5IG9mIG5vZGVzIHRoYXQgc2hvdWxkIGJlIGpvaW5lZC5cclxuXHRcdCAqXHJcblx0XHQgKiBAdHlwZSB7QXJyYXk8Tm9kZT59XHJcblx0XHQgKi9cclxuXHRcdHRoaXMubm9kZXMgPSBub2RlcztcclxuXHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBUaGlzIG1ldGhvZCBpcyBvdmVyd3JpdHRlbiBzaW5jZSB0aGUgbm9kZSB0eXBlIG11c3QgYmUgaW5mZXJyZWQgZnJvbSB0aGVcclxuXHQgKiBqb2luZWQgZGF0YSBsZW5ndGggaWYgbm90IGV4cGxpY2l0bHkgZGVmaW5lZC5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7Tm9kZUJ1aWxkZXJ9IGJ1aWxkZXIgLSBUaGUgY3VycmVudCBub2RlIGJ1aWxkZXIuXHJcblx0ICogQHJldHVybiB7U3RyaW5nfSBUaGUgbm9kZSB0eXBlLlxyXG5cdCAqL1xyXG5cdGdldE5vZGVUeXBlKCBidWlsZGVyICkge1xyXG5cclxuXHRcdGlmICggdGhpcy5ub2RlVHlwZSAhPT0gbnVsbCApIHtcclxuXHJcblx0XHRcdHJldHVybiBidWlsZGVyLmdldFZlY3RvclR5cGUoIHRoaXMubm9kZVR5cGUgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGJ1aWxkZXIuZ2V0VHlwZUZyb21MZW5ndGgoIHRoaXMubm9kZXMucmVkdWNlKCAoIGNvdW50LCBjdXIgKSA9PiBjb3VudCArIGJ1aWxkZXIuZ2V0VHlwZUxlbmd0aCggY3VyLmdldE5vZGVUeXBlKCBidWlsZGVyICkgKSwgMCApICk7XHJcblxyXG5cdH1cclxuXHJcblx0Z2VuZXJhdGUoIGJ1aWxkZXIsIG91dHB1dCApIHtcclxuXHJcblx0XHRjb25zdCB0eXBlID0gdGhpcy5nZXROb2RlVHlwZSggYnVpbGRlciApO1xyXG5cdFx0Y29uc3Qgbm9kZXMgPSB0aGlzLm5vZGVzO1xyXG5cclxuXHRcdGNvbnN0IHByaW1pdGl2ZVR5cGUgPSBidWlsZGVyLmdldENvbXBvbmVudFR5cGUoIHR5cGUgKTtcclxuXHJcblx0XHRjb25zdCBzbmlwcGV0VmFsdWVzID0gW107XHJcblxyXG5cdFx0Zm9yICggY29uc3QgaW5wdXQgb2Ygbm9kZXMgKSB7XHJcblxyXG5cdFx0XHRsZXQgaW5wdXRTbmlwcGV0ID0gaW5wdXQuYnVpbGQoIGJ1aWxkZXIgKTtcclxuXHJcblx0XHRcdGNvbnN0IGlucHV0UHJpbWl0aXZlVHlwZSA9IGJ1aWxkZXIuZ2V0Q29tcG9uZW50VHlwZSggaW5wdXQuZ2V0Tm9kZVR5cGUoIGJ1aWxkZXIgKSApO1xyXG5cclxuXHRcdFx0aWYgKCBpbnB1dFByaW1pdGl2ZVR5cGUgIT09IHByaW1pdGl2ZVR5cGUgKSB7XHJcblxyXG5cdFx0XHRcdGlucHV0U25pcHBldCA9IGJ1aWxkZXIuZm9ybWF0KCBpbnB1dFNuaXBwZXQsIGlucHV0UHJpbWl0aXZlVHlwZSwgcHJpbWl0aXZlVHlwZSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0c25pcHBldFZhbHVlcy5wdXNoKCBpbnB1dFNuaXBwZXQgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Y29uc3Qgc25pcHBldCA9IGAkeyBidWlsZGVyLmdldFR5cGUoIHR5cGUgKSB9KCAkeyBzbmlwcGV0VmFsdWVzLmpvaW4oICcsICcgKSB9IClgO1xyXG5cclxuXHRcdHJldHVybiBidWlsZGVyLmZvcm1hdCggc25pcHBldCwgdHlwZSwgb3V0cHV0ICk7XHJcblxyXG5cdH1cclxuXHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IEpvaW5Ob2RlO1xyXG4iLCJpbXBvcnQgTm9kZSBmcm9tICcuLi9jb3JlL05vZGUuanMnO1xyXG5pbXBvcnQgeyB2ZWN0b3JDb21wb25lbnRzIH0gZnJvbSAnLi4vY29yZS9jb25zdGFudHMuanMnO1xyXG5cclxuY29uc3QgX3N0cmluZ1ZlY3RvckNvbXBvbmVudHMgPSB2ZWN0b3JDb21wb25lbnRzLmpvaW4oICcnICk7XHJcblxyXG4vKipcclxuICogVGhpcyBtb2R1bGUgaXMgcGFydCBvZiB0aGUgVFNMIGNvcmUgYW5kIHVzdWFsbHkgbm90IHVzZWQgaW4gYXBwIGxldmVsIGNvZGUuXHJcbiAqIGBTcGxpdE5vZGVgIHJlcHJlc2VudHMgYSBwcm9wZXJ0eSBhY2Nlc3Mgb3BlcmF0aW9uIHdoaWNoIG1lYW5zIGl0IGlzXHJcbiAqIHVzZWQgdG8gaW1wbGVtZW50IGFueSBgLnh5endgLCBgLnJnYmFgIGFuZCBgc3RwcWAgdXNhZ2Ugb24gbm9kZSBvYmplY3RzLlxyXG4gKiBGb3IgZXhhbXBsZTpcclxuICogYGBganNcclxuICogY29uc3QgcmVkVmFsdWUgPSBjb2xvci5yO1xyXG4gKiBgYGBcclxuICpcclxuICogQGF1Z21lbnRzIE5vZGVcclxuICovXHJcbmNsYXNzIFNwbGl0Tm9kZSBleHRlbmRzIE5vZGUge1xyXG5cclxuXHRzdGF0aWMgZ2V0IHR5cGUoKSB7XHJcblxyXG5cdFx0cmV0dXJuICdTcGxpdE5vZGUnO1xyXG5cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIENvbnN0cnVjdHMgYSBuZXcgc3BsaXQgbm9kZS5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7Tm9kZX0gbm9kZSAtIFRoZSBub2RlIHRoYXQgc2hvdWxkIGJlIGFjY2Vzc2VkLlxyXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBbY29tcG9uZW50cz0neCddIC0gVGhlIGNvbXBvbmVudHMgdGhhdCBzaG91bGQgYmUgYWNjZXNzZWQuXHJcblx0ICovXHJcblx0Y29uc3RydWN0b3IoIG5vZGUsIGNvbXBvbmVudHMgPSAneCcgKSB7XHJcblxyXG5cdFx0c3VwZXIoKTtcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIFRoZSBub2RlIHRoYXQgc2hvdWxkIGJlIGFjY2Vzc2VkLlxyXG5cdFx0ICpcclxuXHRcdCAqIEB0eXBlIHtOb2RlfVxyXG5cdFx0ICovXHJcblx0XHR0aGlzLm5vZGUgPSBub2RlO1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogVGhlIGNvbXBvbmVudHMgdGhhdCBzaG91bGQgYmUgYWNjZXNzZWQuXHJcblx0XHQgKlxyXG5cdFx0ICogQHR5cGUge3N0cmluZ31cclxuXHRcdCAqL1xyXG5cdFx0dGhpcy5jb21wb25lbnRzID0gY29tcG9uZW50cztcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIFRoaXMgZmxhZyBjYW4gYmUgdXNlZCBmb3IgdHlwZSB0ZXN0aW5nLlxyXG5cdFx0ICpcclxuXHRcdCAqIEB0eXBlIHtCb29sZWFufVxyXG5cdFx0ICogQHJlYWRvbmx5XHJcblx0XHQgKiBAZGVmYXVsdCB0cnVlXHJcblx0XHQgKi9cclxuXHRcdHRoaXMuaXNTcGxpdE5vZGUgPSB0cnVlO1xyXG5cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFJldHVybnMgdGhlIHZlY3RvciBsZW5ndGggd2hpY2ggaXMgY29tcHV0ZWQgYmFzZWQgb24gdGhlIHJlcXVlc3RlZCBjb21wb25lbnRzLlxyXG5cdCAqXHJcblx0ICogQHJldHVybiB7TnVtYmVyfSBUaGUgdmVjdG9yIGxlbmd0aC5cclxuXHQgKi9cclxuXHRnZXRWZWN0b3JMZW5ndGgoKSB7XHJcblxyXG5cdFx0bGV0IHZlY3Rvckxlbmd0aCA9IHRoaXMuY29tcG9uZW50cy5sZW5ndGg7XHJcblxyXG5cdFx0Zm9yICggY29uc3QgYyBvZiB0aGlzLmNvbXBvbmVudHMgKSB7XHJcblxyXG5cdFx0XHR2ZWN0b3JMZW5ndGggPSBNYXRoLm1heCggdmVjdG9yQ29tcG9uZW50cy5pbmRleE9mKCBjICkgKyAxLCB2ZWN0b3JMZW5ndGggKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHZlY3Rvckxlbmd0aDtcclxuXHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBSZXR1cm5zIHRoZSBjb21wb25lbnQgdHlwZSBvZiB0aGUgbm9kZSdzIHR5cGUuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge05vZGVCdWlsZGVyfSBidWlsZGVyIC0gVGhlIGN1cnJlbnQgbm9kZSBidWlsZGVyLlxyXG5cdCAqIEByZXR1cm4ge1N0cmluZ30gVGhlIGNvbXBvbmVudCB0eXBlLlxyXG5cdCAqL1xyXG5cdGdldENvbXBvbmVudFR5cGUoIGJ1aWxkZXIgKSB7XHJcblxyXG5cdFx0cmV0dXJuIGJ1aWxkZXIuZ2V0Q29tcG9uZW50VHlwZSggdGhpcy5ub2RlLmdldE5vZGVUeXBlKCBidWlsZGVyICkgKTtcclxuXHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBUaGlzIG1ldGhvZCBpcyBvdmVyd3JpdHRlbiBzaW5jZSB0aGUgbm9kZSB0eXBlIGlzIGluZmVycmVkIGZyb20gcmVxdWVzdGVkIGNvbXBvbmVudHMuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge05vZGVCdWlsZGVyfSBidWlsZGVyIC0gVGhlIGN1cnJlbnQgbm9kZSBidWlsZGVyLlxyXG5cdCAqIEByZXR1cm4ge1N0cmluZ30gVGhlIG5vZGUgdHlwZS5cclxuXHQgKi9cclxuXHRnZXROb2RlVHlwZSggYnVpbGRlciApIHtcclxuXHJcblx0XHRyZXR1cm4gYnVpbGRlci5nZXRUeXBlRnJvbUxlbmd0aCggdGhpcy5jb21wb25lbnRzLmxlbmd0aCwgdGhpcy5nZXRDb21wb25lbnRUeXBlKCBidWlsZGVyICkgKTtcclxuXHJcblx0fVxyXG5cclxuXHRnZW5lcmF0ZSggYnVpbGRlciwgb3V0cHV0ICkge1xyXG5cclxuXHRcdGNvbnN0IG5vZGUgPSB0aGlzLm5vZGU7XHJcblx0XHRjb25zdCBub2RlVHlwZUxlbmd0aCA9IGJ1aWxkZXIuZ2V0VHlwZUxlbmd0aCggbm9kZS5nZXROb2RlVHlwZSggYnVpbGRlciApICk7XHJcblxyXG5cdFx0bGV0IHNuaXBwZXQgPSBudWxsO1xyXG5cclxuXHRcdGlmICggbm9kZVR5cGVMZW5ndGggPiAxICkge1xyXG5cclxuXHRcdFx0bGV0IHR5cGUgPSBudWxsO1xyXG5cclxuXHRcdFx0Y29uc3QgY29tcG9uZW50c0xlbmd0aCA9IHRoaXMuZ2V0VmVjdG9yTGVuZ3RoKCk7XHJcblxyXG5cdFx0XHRpZiAoIGNvbXBvbmVudHNMZW5ndGggPj0gbm9kZVR5cGVMZW5ndGggKSB7XHJcblxyXG5cdFx0XHRcdC8vIG5lZWRlZCBleHBhbmQgdGhlIGlucHV0IG5vZGVcclxuXHJcblx0XHRcdFx0dHlwZSA9IGJ1aWxkZXIuZ2V0VHlwZUZyb21MZW5ndGgoIHRoaXMuZ2V0VmVjdG9yTGVuZ3RoKCksIHRoaXMuZ2V0Q29tcG9uZW50VHlwZSggYnVpbGRlciApICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRjb25zdCBub2RlU25pcHBldCA9IG5vZGUuYnVpbGQoIGJ1aWxkZXIsIHR5cGUgKTtcclxuXHJcblx0XHRcdGlmICggdGhpcy5jb21wb25lbnRzLmxlbmd0aCA9PT0gbm9kZVR5cGVMZW5ndGggJiYgdGhpcy5jb21wb25lbnRzID09PSBfc3RyaW5nVmVjdG9yQ29tcG9uZW50cy5zbGljZSggMCwgdGhpcy5jb21wb25lbnRzLmxlbmd0aCApICkge1xyXG5cclxuXHRcdFx0XHQvLyB1bm5lY2Vzc2FyeSBzd2l6emxlXHJcblxyXG5cdFx0XHRcdHNuaXBwZXQgPSBidWlsZGVyLmZvcm1hdCggbm9kZVNuaXBwZXQsIHR5cGUsIG91dHB1dCApO1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0c25pcHBldCA9IGJ1aWxkZXIuZm9ybWF0KCBgJHtub2RlU25pcHBldH0uJHt0aGlzLmNvbXBvbmVudHN9YCwgdGhpcy5nZXROb2RlVHlwZSggYnVpbGRlciApLCBvdXRwdXQgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0Ly8gaWdub3JlIC5jb21wb25lbnRzIGlmIC5ub2RlIHJldHVybnMgZmxvYXQvaW50ZWdlclxyXG5cclxuXHRcdFx0c25pcHBldCA9IG5vZGUuYnVpbGQoIGJ1aWxkZXIsIG91dHB1dCApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gc25pcHBldDtcclxuXHJcblx0fVxyXG5cclxuXHRzZXJpYWxpemUoIGRhdGEgKSB7XHJcblxyXG5cdFx0c3VwZXIuc2VyaWFsaXplKCBkYXRhICk7XHJcblxyXG5cdFx0ZGF0YS5jb21wb25lbnRzID0gdGhpcy5jb21wb25lbnRzO1xyXG5cclxuXHR9XHJcblxyXG5cdGRlc2VyaWFsaXplKCBkYXRhICkge1xyXG5cclxuXHRcdHN1cGVyLmRlc2VyaWFsaXplKCBkYXRhICk7XHJcblxyXG5cdFx0dGhpcy5jb21wb25lbnRzID0gZGF0YS5jb21wb25lbnRzO1xyXG5cclxuXHR9XHJcblxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBTcGxpdE5vZGU7XHJcbiIsImltcG9ydCBUZW1wTm9kZSBmcm9tICcuLi9jb3JlL1RlbXBOb2RlLmpzJztcclxuaW1wb3J0IHsgdmVjdG9yQ29tcG9uZW50cyB9IGZyb20gJy4uL2NvcmUvY29uc3RhbnRzLmpzJztcclxuXHJcbi8qKlxyXG4gKiBUaGlzIG1vZHVsZSBpcyBwYXJ0IG9mIHRoZSBUU0wgY29yZSBhbmQgdXN1YWxseSBub3QgdXNlZCBpbiBhcHAgbGV2ZWwgY29kZS5cclxuICogYFNldE5vZGVgIHJlcHJlc2VudHMgYSBzZXQgb3BlcmF0aW9uIHdoaWNoIG1lYW5zIGl0IGlzIHVzZWQgdG8gaW1wbGVtZW50IGFueVxyXG4gKiBgc2V0WFlaVygpYCwgYHNldFJHQkEoKWAgYW5kIGBzZXRTVFBRKClgIG1ldGhvZCBpbnZvY2F0aW9ucyBvbiBub2RlIG9iamVjdHMuXHJcbiAqIEZvciBleGFtcGxlOlxyXG4gKiBgYGBqc1xyXG4gKiBtYXRlcmlhbExpbmUuY29sb3JOb2RlID0gY29sb3IoIDAsIDAsIDAgKS5zZXRSKCBmbG9hdCggMSApICk7XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBAYXVnbWVudHMgVGVtcE5vZGVcclxuICovXHJcbmNsYXNzIFNldE5vZGUgZXh0ZW5kcyBUZW1wTm9kZSB7XHJcblxyXG5cdHN0YXRpYyBnZXQgdHlwZSgpIHtcclxuXHJcblx0XHRyZXR1cm4gJ1NldE5vZGUnO1xyXG5cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIENvbnN0cnVjdHMgYSBuZXcgc2V0IG5vZGUuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge05vZGV9IHNvdXJjZU5vZGUgLSBUaGUgbm9kZSB0aGF0IHNob3VsZCBiZSB1cGRhdGVkLlxyXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBjb21wb25lbnRzIC0gVGhlIGNvbXBvbmVudHMgdGhhdCBzaG91bGQgYmUgdXBkYXRlZC5cclxuXHQgKiBAcGFyYW0ge05vZGV9IHRhcmdldE5vZGUgLSBUaGUgdmFsdWUgbm9kZS5cclxuXHQgKi9cclxuXHRjb25zdHJ1Y3Rvciggc291cmNlTm9kZSwgY29tcG9uZW50cywgdGFyZ2V0Tm9kZSApIHtcclxuXHJcblx0XHRzdXBlcigpO1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogVGhlIG5vZGUgdGhhdCBzaG91bGQgYmUgdXBkYXRlZC5cclxuXHRcdCAqXHJcblx0XHQgKiBAdHlwZSB7Tm9kZX1cclxuXHRcdCAqL1xyXG5cdFx0dGhpcy5zb3VyY2VOb2RlID0gc291cmNlTm9kZTtcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIFRoZSBjb21wb25lbnRzIHRoYXQgc2hvdWxkIGJlIHVwZGF0ZWQuXHJcblx0XHQgKlxyXG5cdFx0ICogQHR5cGUge1N0cmluZ31cclxuXHRcdCAqL1xyXG5cdFx0dGhpcy5jb21wb25lbnRzID0gY29tcG9uZW50cztcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIFRoZSB2YWx1ZSBub2RlLlxyXG5cdFx0ICpcclxuXHRcdCAqIEB0eXBlIHtOb2RlfVxyXG5cdFx0ICovXHJcblx0XHR0aGlzLnRhcmdldE5vZGUgPSB0YXJnZXROb2RlO1xyXG5cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFRoaXMgbWV0aG9kIGlzIG92ZXJ3cml0dGVuIHNpbmNlIHRoZSBub2RlIHR5cGUgaXMgaW5mZXJyZWQgZnJvbSB7QGxpbmsgU2V0Tm9kZSNzb3VyY2VOb2RlfS5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7Tm9kZUJ1aWxkZXJ9IGJ1aWxkZXIgLSBUaGUgY3VycmVudCBub2RlIGJ1aWxkZXIuXHJcblx0ICogQHJldHVybiB7U3RyaW5nfSBUaGUgbm9kZSB0eXBlLlxyXG5cdCAqL1xyXG5cdGdldE5vZGVUeXBlKCBidWlsZGVyICkge1xyXG5cclxuXHRcdHJldHVybiB0aGlzLnNvdXJjZU5vZGUuZ2V0Tm9kZVR5cGUoIGJ1aWxkZXIgKTtcclxuXHJcblx0fVxyXG5cclxuXHRnZW5lcmF0ZSggYnVpbGRlciApIHtcclxuXHJcblx0XHRjb25zdCB7IHNvdXJjZU5vZGUsIGNvbXBvbmVudHMsIHRhcmdldE5vZGUgfSA9IHRoaXM7XHJcblxyXG5cdFx0Y29uc3Qgc291cmNlVHlwZSA9IHRoaXMuZ2V0Tm9kZVR5cGUoIGJ1aWxkZXIgKTtcclxuXHJcblx0XHRjb25zdCBjb21wb25lbnRUeXBlID0gYnVpbGRlci5nZXRDb21wb25lbnRUeXBlKCB0YXJnZXROb2RlLmdldE5vZGVUeXBlKCBidWlsZGVyICkgKTtcclxuXHRcdGNvbnN0IHRhcmdldFR5cGUgPSBidWlsZGVyLmdldFR5cGVGcm9tTGVuZ3RoKCBjb21wb25lbnRzLmxlbmd0aCwgY29tcG9uZW50VHlwZSApO1xyXG5cclxuXHRcdGNvbnN0IHRhcmdldFNuaXBwZXQgPSB0YXJnZXROb2RlLmJ1aWxkKCBidWlsZGVyLCB0YXJnZXRUeXBlICk7XHJcblx0XHRjb25zdCBzb3VyY2VTbmlwcGV0ID0gc291cmNlTm9kZS5idWlsZCggYnVpbGRlciwgc291cmNlVHlwZSApO1xyXG5cclxuXHRcdGNvbnN0IGxlbmd0aCA9IGJ1aWxkZXIuZ2V0VHlwZUxlbmd0aCggc291cmNlVHlwZSApO1xyXG5cdFx0Y29uc3Qgc25pcHBldFZhbHVlcyA9IFtdO1xyXG5cclxuXHRcdGZvciAoIGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSArKyApIHtcclxuXHJcblx0XHRcdGNvbnN0IGNvbXBvbmVudCA9IHZlY3RvckNvbXBvbmVudHNbIGkgXTtcclxuXHJcblx0XHRcdGlmICggY29tcG9uZW50ID09PSBjb21wb25lbnRzWyAwIF0gKSB7XHJcblxyXG5cdFx0XHRcdHNuaXBwZXRWYWx1ZXMucHVzaCggdGFyZ2V0U25pcHBldCApO1xyXG5cclxuXHRcdFx0XHRpICs9IGNvbXBvbmVudHMubGVuZ3RoIC0gMTtcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdHNuaXBwZXRWYWx1ZXMucHVzaCggc291cmNlU25pcHBldCArICcuJyArIGNvbXBvbmVudCApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gYCR7IGJ1aWxkZXIuZ2V0VHlwZSggc291cmNlVHlwZSApIH0oICR7IHNuaXBwZXRWYWx1ZXMuam9pbiggJywgJyApIH0gKWA7XHJcblxyXG5cdH1cclxuXHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IFNldE5vZGU7XHJcbiIsImltcG9ydCBUZW1wTm9kZSBmcm9tICcuLi9jb3JlL1RlbXBOb2RlLmpzJztcclxuaW1wb3J0IHsgdmVjdG9yQ29tcG9uZW50cyB9IGZyb20gJy4uL2NvcmUvY29uc3RhbnRzLmpzJztcclxuXHJcbi8qKlxyXG4gKiBUaGlzIG1vZHVsZSBpcyBwYXJ0IG9mIHRoZSBUU0wgY29yZSBhbmQgdXN1YWxseSBub3QgdXNlZCBpbiBhcHAgbGV2ZWwgY29kZS5cclxuICogSXQgcmVwcmVzZW50cyBhIGZsaXAgb3BlcmF0aW9uIGR1cmluZyB0aGUgc2hhZGVyIGdlbmVyYXRpb24gcHJvY2Vzc1xyXG4gKiBtZWFuaW5nIGl0IGZsaXBzIG5vcm1hbGl6ZWQgdmFsdWVzIHdpdGggdGhlIGZvbGxvd2luZyBmb3JtdWxhOlxyXG4gKiBgYGBcclxuICogeCA9IDEgLSB4O1xyXG4gKiBgYGBcclxuICogYEZsaXBOb2RlYCBpcyBpbnRlcm5hbGx5IHVzZWQgdG8gaW1wbGVtZW50IGFueSBgZmxpcFhZWlcoKWAsIGBmbGlwUkdCQSgpYCBhbmRcclxuICogYGZsaXBTVFBRKClgIG1ldGhvZCBpbnZvY2F0aW9ucyBvbiBub2RlIG9iamVjdHMuIEZvciBleGFtcGxlOlxyXG4gKiBgYGBqc1xyXG4gKiB1dk5vZGUgPSB1dk5vZGUuZmxpcFkoKTtcclxuICogYGBgXHJcbiAqXHJcbiAqIEBhdWdtZW50cyBUZW1wTm9kZVxyXG4gKi9cclxuY2xhc3MgRmxpcE5vZGUgZXh0ZW5kcyBUZW1wTm9kZSB7XHJcblxyXG5cdHN0YXRpYyBnZXQgdHlwZSgpIHtcclxuXHJcblx0XHRyZXR1cm4gJ0ZsaXBOb2RlJztcclxuXHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBDb25zdHJ1Y3RzIGEgbmV3IGZsaXAgbm9kZS5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7Tm9kZX0gc291cmNlTm9kZSAtIFRoZSBub2RlIHdoaWNoIGNvbXBvbmVudChzKSBzaG91bGQgYmUgZmxpcHBlZC5cclxuXHQgKiBAcGFyYW0ge1N0cmluZ30gY29tcG9uZW50cyAtIFRoZSBjb21wb25lbnRzIHRoYXQgc2hvdWxkIGJlIGZsaXBwZWQgZS5nLiBgJ3gnYCBvciBgJ3h5J2AuXHJcblx0ICovXHJcblx0Y29uc3RydWN0b3IoIHNvdXJjZU5vZGUsIGNvbXBvbmVudHMgKSB7XHJcblxyXG5cdFx0c3VwZXIoKTtcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIFRoZSBub2RlIHdoaWNoIGNvbXBvbmVudChzKSBzaG91bGQgYmUgZmxpcHBlZC5cclxuXHRcdCAqXHJcblx0XHQgKiBAdHlwZSB7Tm9kZX1cclxuXHRcdCAqL1xyXG5cdFx0dGhpcy5zb3VyY2VOb2RlID0gc291cmNlTm9kZTtcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIFRoZSBjb21wb25lbnRzIHRoYXQgc2hvdWxkIGJlIGZsaXBwZWQgZS5nLiBgJ3gnYCBvciBgJ3h5J2AuXHJcblx0XHQgKlxyXG5cdFx0ICogQHR5cGUge1N0cmluZ31cclxuXHRcdCAqL1xyXG5cdFx0dGhpcy5jb21wb25lbnRzID0gY29tcG9uZW50cztcclxuXHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBUaGlzIG1ldGhvZCBpcyBvdmVyd3JpdHRlbiBzaW5jZSB0aGUgbm9kZSB0eXBlIGlzIGluZmVycmVkIGZyb20gdGhlIHNvdXJjZSBub2RlLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtOb2RlQnVpbGRlcn0gYnVpbGRlciAtIFRoZSBjdXJyZW50IG5vZGUgYnVpbGRlci5cclxuXHQgKiBAcmV0dXJuIHtTdHJpbmd9IFRoZSBub2RlIHR5cGUuXHJcblx0ICovXHJcblx0Z2V0Tm9kZVR5cGUoIGJ1aWxkZXIgKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuc291cmNlTm9kZS5nZXROb2RlVHlwZSggYnVpbGRlciApO1xyXG5cclxuXHR9XHJcblxyXG5cdGdlbmVyYXRlKCBidWlsZGVyICkge1xyXG5cclxuXHRcdGNvbnN0IHsgY29tcG9uZW50cywgc291cmNlTm9kZSB9ID0gdGhpcztcclxuXHJcblx0XHRjb25zdCBzb3VyY2VUeXBlID0gdGhpcy5nZXROb2RlVHlwZSggYnVpbGRlciApO1xyXG5cdFx0Y29uc3Qgc291cmNlU25pcHBldCA9IHNvdXJjZU5vZGUuYnVpbGQoIGJ1aWxkZXIgKTtcclxuXHJcblx0XHRjb25zdCBzb3VyY2VDYWNoZSA9IGJ1aWxkZXIuZ2V0VmFyRnJvbU5vZGUoIHRoaXMgKTtcclxuXHRcdGNvbnN0IHNvdXJjZVByb3BlcnR5ID0gYnVpbGRlci5nZXRQcm9wZXJ0eU5hbWUoIHNvdXJjZUNhY2hlICk7XHJcblxyXG5cdFx0YnVpbGRlci5hZGRMaW5lRmxvd0NvZGUoIHNvdXJjZVByb3BlcnR5ICsgJyA9ICcgKyBzb3VyY2VTbmlwcGV0LCB0aGlzICk7XHJcblxyXG5cdFx0Y29uc3QgbGVuZ3RoID0gYnVpbGRlci5nZXRUeXBlTGVuZ3RoKCBzb3VyY2VUeXBlICk7XHJcblx0XHRjb25zdCBzbmlwcGV0VmFsdWVzID0gW107XHJcblxyXG5cdFx0bGV0IGNvbXBvbmVudEluZGV4ID0gMDtcclxuXHJcblx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRjb25zdCBjb21wb25lbnQgPSB2ZWN0b3JDb21wb25lbnRzWyBpIF07XHJcblxyXG5cdFx0XHRpZiAoIGNvbXBvbmVudCA9PT0gY29tcG9uZW50c1sgY29tcG9uZW50SW5kZXggXSApIHtcclxuXHJcblx0XHRcdFx0c25pcHBldFZhbHVlcy5wdXNoKCAnMS4wIC0gJyArICggc291cmNlUHJvcGVydHkgKyAnLicgKyBjb21wb25lbnQgKSApO1xyXG5cclxuXHRcdFx0XHRjb21wb25lbnRJbmRleCArKztcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdHNuaXBwZXRWYWx1ZXMucHVzaCggc291cmNlUHJvcGVydHkgKyAnLicgKyBjb21wb25lbnQgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGAkeyBidWlsZGVyLmdldFR5cGUoIHNvdXJjZVR5cGUgKSB9KCAkeyBzbmlwcGV0VmFsdWVzLmpvaW4oICcsICcgKSB9IClgO1xyXG5cclxuXHR9XHJcblxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBGbGlwTm9kZTtcclxuIiwiaW1wb3J0IE5vZGUgZnJvbSAnLi9Ob2RlLmpzJztcclxuaW1wb3J0IHsgZ2V0VmFsdWVUeXBlLCBnZXRWYWx1ZUZyb21UeXBlLCBhcnJheUJ1ZmZlclRvQmFzZTY0IH0gZnJvbSAnLi9Ob2RlVXRpbHMuanMnO1xyXG5cclxuLyoqXHJcbiAqIEJhc2UgY2xhc3MgZm9yIHJlcHJlc2VudGluZyBkYXRhIGlucHV0IG5vZGVzLlxyXG4gKlxyXG4gKiBAYXVnbWVudHMgTm9kZVxyXG4gKi9cclxuY2xhc3MgSW5wdXROb2RlIGV4dGVuZHMgTm9kZSB7XHJcblxyXG5cdHN0YXRpYyBnZXQgdHlwZSgpIHtcclxuXHJcblx0XHRyZXR1cm4gJ0lucHV0Tm9kZSc7XHJcblxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogQ29uc3RydWN0cyBhIG5ldyBpbnB1dCBub2RlLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtBbnl9IHZhbHVlIC0gVGhlIHZhbHVlIG9mIHRoaXMgbm9kZS4gVGhpcyBjYW4gYmUgYSBhbnkgSlMgcHJpbWl0aXZlLCBmdW5jdGlvbnMsIGFycmF5IGJ1ZmZlcnMgb3IgZXZlbiB0aHJlZS5qcyBvYmplY3RzICh2ZWN0b3IsIG1hdHJpY2VzLCBjb2xvcnMpLlxyXG5cdCAqIEBwYXJhbSB7U3RyaW5nP30gbm9kZVR5cGUgLSBUaGUgbm9kZSB0eXBlLiBJZiBubyBleHBsaWNpdCB0eXBlIGlzIGRlZmluZWQsIHRoZSBub2RlIHRyaWVzIHRvIGRlcml2ZSB0aGUgdHlwZSBmcm9tIGl0cyB2YWx1ZS5cclxuXHQgKi9cclxuXHRjb25zdHJ1Y3RvciggdmFsdWUsIG5vZGVUeXBlID0gbnVsbCApIHtcclxuXHJcblx0XHRzdXBlciggbm9kZVR5cGUgKTtcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIFRoaXMgZmxhZyBjYW4gYmUgdXNlZCBmb3IgdHlwZSB0ZXN0aW5nLlxyXG5cdFx0ICpcclxuXHRcdCAqIEB0eXBlIHtCb29sZWFufVxyXG5cdFx0ICogQHJlYWRvbmx5XHJcblx0XHQgKiBAZGVmYXVsdCB0cnVlXHJcblx0XHQgKi9cclxuXHRcdHRoaXMuaXNJbnB1dE5vZGUgPSB0cnVlO1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogVGhlIHZhbHVlIG9mIHRoaXMgbm9kZS4gVGhpcyBjYW4gYmUgYSBhbnkgSlMgcHJpbWl0aXZlLCBmdW5jdGlvbnMsIGFycmF5IGJ1ZmZlcnMgb3IgZXZlbiB0aHJlZS5qcyBvYmplY3RzICh2ZWN0b3IsIG1hdHJpY2VzLCBjb2xvcnMpLlxyXG5cdFx0ICpcclxuXHRcdCAqIEB0eXBlIHtBbnl9XHJcblx0XHQgKi9cclxuXHRcdHRoaXMudmFsdWUgPSB2YWx1ZTtcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIFRoZSBwcmVjaXNpb24gb2YgdGhlIHZhbHVlIGluIHRoZSBzaGFkZXIuXHJcblx0XHQgKlxyXG5cdFx0ICogQHR5cGUgeygnbG93J3wnbWVkaXVtJ3wnaGlnaCcpP31cclxuXHRcdCAqIEBkZWZhdWx0IG51bGxcclxuXHRcdCAqL1xyXG5cdFx0dGhpcy5wcmVjaXNpb24gPSBudWxsO1xyXG5cclxuXHR9XHJcblxyXG5cdGdldE5vZGVUeXBlKCAvKmJ1aWxkZXIqLyApIHtcclxuXHJcblx0XHRpZiAoIHRoaXMubm9kZVR5cGUgPT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gZ2V0VmFsdWVUeXBlKCB0aGlzLnZhbHVlICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzLm5vZGVUeXBlO1xyXG5cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFJldHVybnMgdGhlIGlucHV0IHR5cGUgb2YgdGhlIG5vZGUgd2hpY2ggaXMgYnkgZGVmYXVsdCB0aGUgbm9kZSB0eXBlLiBEZXJpdmVkIG1vZHVsZXNcclxuXHQgKiBtaWdodCBvdmVyd3JpdGUgdGhpcyBtZXRob2QgYW5kIHVzZSBhIGZpeGVkIHR5cGUgb3IgY29tcHV0ZSBvbmUgYW5hbHl0aWNhbGx5LlxyXG5cdCAqXHJcblx0ICogQSB0eXBpY2FsIGV4YW1wbGUgZm9yIGRpZmZlcmVudCBpbnB1dCBhbmQgbm9kZSB0eXBlcyBhcmUgdGV4dHVyZXMuIFRoZSBpbnB1dCB0eXBlIG9mIGFcclxuXHQgKiBub3JtYWwgUkdCQSB0ZXh0dXJlIGlzIGB0ZXh0dXJlYCB3aGVyZWFzIGl0cyBub2RlIHR5cGUgaXMgYHZlYzRgLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtOb2RlQnVpbGRlcn0gYnVpbGRlciAtIFRoZSBjdXJyZW50IG5vZGUgYnVpbGRlci5cclxuXHQgKiBAcmV0dXJuIHtTdHJpbmd9IFRoZSBpbnB1dCB0eXBlLlxyXG5cdCAqL1xyXG5cdGdldElucHV0VHlwZSggYnVpbGRlciApIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5nZXROb2RlVHlwZSggYnVpbGRlciApO1xyXG5cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFNldHMgdGhlIHByZWNpc2lvbiB0byB0aGUgZ2l2ZW4gdmFsdWUuIFRoZSBtZXRob2QgY2FuIGJlXHJcblx0ICogb3ZlcndyaXR0ZW4gaW4gZGVyaXZlZCBjbGFzc2VzIGlmIHRoZSBmaW5hbCBwcmVjaXNpb24gbXVzdCBiZSBjb21wdXRlZFxyXG5cdCAqIGFuYWx5dGljYWxseS5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7KCdsb3cnfCdtZWRpdW0nfCdoaWdoJyl9IHByZWNpc2lvbiAtIFRoZSBwcmVjaXNpb24gb2YgdGhlIGlucHV0IHZhbHVlIGluIHRoZSBzaGFkZXIuXHJcblx0ICogQHJldHVybiB7SW5wdXROb2RlfSBBIHJlZmVyZW5jZSB0byB0aGlzIG5vZGUuXHJcblx0ICovXHJcblx0c2V0UHJlY2lzaW9uKCBwcmVjaXNpb24gKSB7XHJcblxyXG5cdFx0dGhpcy5wcmVjaXNpb24gPSBwcmVjaXNpb247XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHJcblx0c2VyaWFsaXplKCBkYXRhICkge1xyXG5cclxuXHRcdHN1cGVyLnNlcmlhbGl6ZSggZGF0YSApO1xyXG5cclxuXHRcdGRhdGEudmFsdWUgPSB0aGlzLnZhbHVlO1xyXG5cclxuXHRcdGlmICggdGhpcy52YWx1ZSAmJiB0aGlzLnZhbHVlLnRvQXJyYXkgKSBkYXRhLnZhbHVlID0gdGhpcy52YWx1ZS50b0FycmF5KCk7XHJcblxyXG5cdFx0ZGF0YS52YWx1ZVR5cGUgPSBnZXRWYWx1ZVR5cGUoIHRoaXMudmFsdWUgKTtcclxuXHRcdGRhdGEubm9kZVR5cGUgPSB0aGlzLm5vZGVUeXBlO1xyXG5cclxuXHRcdGlmICggZGF0YS52YWx1ZVR5cGUgPT09ICdBcnJheUJ1ZmZlcicgKSBkYXRhLnZhbHVlID0gYXJyYXlCdWZmZXJUb0Jhc2U2NCggZGF0YS52YWx1ZSApO1xyXG5cclxuXHRcdGRhdGEucHJlY2lzaW9uID0gdGhpcy5wcmVjaXNpb247XHJcblxyXG5cdH1cclxuXHJcblx0ZGVzZXJpYWxpemUoIGRhdGEgKSB7XHJcblxyXG5cdFx0c3VwZXIuZGVzZXJpYWxpemUoIGRhdGEgKTtcclxuXHJcblx0XHR0aGlzLm5vZGVUeXBlID0gZGF0YS5ub2RlVHlwZTtcclxuXHRcdHRoaXMudmFsdWUgPSBBcnJheS5pc0FycmF5KCBkYXRhLnZhbHVlICkgPyBnZXRWYWx1ZUZyb21UeXBlKCBkYXRhLnZhbHVlVHlwZSwgLi4uZGF0YS52YWx1ZSApIDogZGF0YS52YWx1ZTtcclxuXHJcblx0XHR0aGlzLnByZWNpc2lvbiA9IGRhdGEucHJlY2lzaW9uIHx8IG51bGw7XHJcblxyXG5cdFx0aWYgKCB0aGlzLnZhbHVlICYmIHRoaXMudmFsdWUuZnJvbUFycmF5ICkgdGhpcy52YWx1ZSA9IHRoaXMudmFsdWUuZnJvbUFycmF5KCBkYXRhLnZhbHVlICk7XHJcblxyXG5cdH1cclxuXHJcblx0Z2VuZXJhdGUoIC8qYnVpbGRlciwgb3V0cHV0Ki8gKSB7XHJcblxyXG5cdFx0Y29uc29sZS53YXJuKCAnQWJzdHJhY3QgZnVuY3Rpb24uJyApO1xyXG5cclxuXHR9XHJcblxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBJbnB1dE5vZGU7XHJcbiIsImltcG9ydCBJbnB1dE5vZGUgZnJvbSAnLi9JbnB1dE5vZGUuanMnO1xyXG5cclxuLyoqXHJcbiAqIENsYXNzIGZvciByZXByZXNlbnRpbmcgYSBjb25zdGFudCB2YWx1ZSBpbiB0aGUgc2hhZGVyLlxyXG4gKlxyXG4gKiBAYXVnbWVudHMgSW5wdXROb2RlXHJcbiAqL1xyXG5jbGFzcyBDb25zdE5vZGUgZXh0ZW5kcyBJbnB1dE5vZGUge1xyXG5cclxuXHRzdGF0aWMgZ2V0IHR5cGUoKSB7XHJcblxyXG5cdFx0cmV0dXJuICdDb25zdE5vZGUnO1xyXG5cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIENvbnN0cnVjdHMgYSBuZXcgaW5wdXQgbm9kZS5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7QW55fSB2YWx1ZSAtIFRoZSB2YWx1ZSBvZiB0aGlzIG5vZGUuIFVzdWFsbHkgYSBKUyBwcmltaXRpdmUgb3IgdGhyZWUuanMgb2JqZWN0ICh2ZWN0b3IsIG1hdHJpeCwgY29sb3IpLlxyXG5cdCAqIEBwYXJhbSB7U3RyaW5nP30gbm9kZVR5cGUgLSBUaGUgbm9kZSB0eXBlLiBJZiBubyBleHBsaWNpdCB0eXBlIGlzIGRlZmluZWQsIHRoZSBub2RlIHRyaWVzIHRvIGRlcml2ZSB0aGUgdHlwZSBmcm9tIGl0cyB2YWx1ZS5cclxuXHQgKi9cclxuXHRjb25zdHJ1Y3RvciggdmFsdWUsIG5vZGVUeXBlID0gbnVsbCApIHtcclxuXHJcblx0XHRzdXBlciggdmFsdWUsIG5vZGVUeXBlICk7XHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBUaGlzIGZsYWcgY2FuIGJlIHVzZWQgZm9yIHR5cGUgdGVzdGluZy5cclxuXHRcdCAqXHJcblx0XHQgKiBAdHlwZSB7Qm9vbGVhbn1cclxuXHRcdCAqIEByZWFkb25seVxyXG5cdFx0ICogQGRlZmF1bHQgdHJ1ZVxyXG5cdFx0ICovXHJcblx0XHR0aGlzLmlzQ29uc3ROb2RlID0gdHJ1ZTtcclxuXHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBHZW5lcmF0ZXMgdGhlIHNoYWRlciBzdHJpbmcgb2YgdGhlIHZhbHVlIHdpdGggdGhlIGN1cnJlbnQgbm9kZSBidWlsZGVyLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtOb2RlQnVpbGRlcn0gYnVpbGRlciAtIFRoZSBjdXJyZW50IG5vZGUgYnVpbGRlci5cclxuXHQgKiBAcmV0dXJuIHtTdHJpbmd9IFRoZSBnZW5lcmF0ZWQgdmFsdWUgYXMgYSBzaGFkZXIgc3RyaW5nLlxyXG5cdCAqL1xyXG5cdGdlbmVyYXRlQ29uc3QoIGJ1aWxkZXIgKSB7XHJcblxyXG5cdFx0cmV0dXJuIGJ1aWxkZXIuZ2VuZXJhdGVDb25zdCggdGhpcy5nZXROb2RlVHlwZSggYnVpbGRlciApLCB0aGlzLnZhbHVlICk7XHJcblxyXG5cdH1cclxuXHJcblx0Z2VuZXJhdGUoIGJ1aWxkZXIsIG91dHB1dCApIHtcclxuXHJcblx0XHRjb25zdCB0eXBlID0gdGhpcy5nZXROb2RlVHlwZSggYnVpbGRlciApO1xyXG5cclxuXHRcdHJldHVybiBidWlsZGVyLmZvcm1hdCggdGhpcy5nZW5lcmF0ZUNvbnN0KCBidWlsZGVyICksIHR5cGUsIG91dHB1dCApO1xyXG5cclxuXHR9XHJcblxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBDb25zdE5vZGU7XHJcbiIsImltcG9ydCBOb2RlIGZyb20gJy4uL2NvcmUvTm9kZS5qcyc7XHJcbmltcG9ydCBBcnJheUVsZW1lbnROb2RlIGZyb20gJy4uL3V0aWxzL0FycmF5RWxlbWVudE5vZGUuanMnO1xyXG5pbXBvcnQgQ29udmVydE5vZGUgZnJvbSAnLi4vdXRpbHMvQ29udmVydE5vZGUuanMnO1xyXG5pbXBvcnQgSm9pbk5vZGUgZnJvbSAnLi4vdXRpbHMvSm9pbk5vZGUuanMnO1xyXG5pbXBvcnQgU3BsaXROb2RlIGZyb20gJy4uL3V0aWxzL1NwbGl0Tm9kZS5qcyc7XHJcbmltcG9ydCBTZXROb2RlIGZyb20gJy4uL3V0aWxzL1NldE5vZGUuanMnO1xyXG5pbXBvcnQgRmxpcE5vZGUgZnJvbSAnLi4vdXRpbHMvRmxpcE5vZGUuanMnO1xyXG5pbXBvcnQgQ29uc3ROb2RlIGZyb20gJy4uL2NvcmUvQ29uc3ROb2RlLmpzJztcclxuaW1wb3J0IHsgZ2V0VmFsdWVGcm9tVHlwZSwgZ2V0VmFsdWVUeXBlIH0gZnJvbSAnLi4vY29yZS9Ob2RlVXRpbHMuanMnO1xyXG5cclxuLy9cclxuXHJcbmxldCBjdXJyZW50U3RhY2sgPSBudWxsO1xyXG5cclxuY29uc3QgTm9kZUVsZW1lbnRzID0gbmV3IE1hcCgpO1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGFkZE1ldGhvZENoYWluaW5nKCBuYW1lLCBub2RlRWxlbWVudCApIHtcclxuXHJcblx0aWYgKCBOb2RlRWxlbWVudHMuaGFzKCBuYW1lICkgKSB7XHJcblxyXG5cdFx0Y29uc29sZS53YXJuKCBgUmVkZWZpbml0aW9uIG9mIG1ldGhvZCBjaGFpbmluZyAkeyBuYW1lIH1gICk7XHJcblx0XHRyZXR1cm47XHJcblxyXG5cdH1cclxuXHJcblx0aWYgKCB0eXBlb2Ygbm9kZUVsZW1lbnQgIT09ICdmdW5jdGlvbicgKSB0aHJvdyBuZXcgRXJyb3IoIGBOb2RlIGVsZW1lbnQgJHsgbmFtZSB9IGlzIG5vdCBhIGZ1bmN0aW9uYCApO1xyXG5cclxuXHROb2RlRWxlbWVudHMuc2V0KCBuYW1lLCBub2RlRWxlbWVudCApO1xyXG5cclxufVxyXG5cclxuY29uc3QgcGFyc2VTd2l6emxlID0gKCBwcm9wcyApID0+IHByb3BzLnJlcGxhY2UoIC9yfHMvZywgJ3gnICkucmVwbGFjZSggL2d8dC9nLCAneScgKS5yZXBsYWNlKCAvYnxwL2csICd6JyApLnJlcGxhY2UoIC9hfHEvZywgJ3cnICk7XHJcbmNvbnN0IHBhcnNlU3dpenpsZUFuZFNvcnQgPSAoIHByb3BzICkgPT4gcGFyc2VTd2l6emxlKCBwcm9wcyApLnNwbGl0KCAnJyApLnNvcnQoKS5qb2luKCAnJyApO1xyXG5cclxuY29uc3Qgc2hhZGVyTm9kZUhhbmRsZXIgPSB7XHJcblxyXG5cdHNldHVwKCBOb2RlQ2xvc3VyZSwgcGFyYW1zICkge1xyXG5cclxuXHRcdGNvbnN0IGlucHV0cyA9IHBhcmFtcy5zaGlmdCgpO1xyXG5cclxuXHRcdHJldHVybiBOb2RlQ2xvc3VyZSggbm9kZU9iamVjdHMoIGlucHV0cyApLCAuLi5wYXJhbXMgKTtcclxuXHJcblx0fSxcclxuXHJcblx0Z2V0KCBub2RlLCBwcm9wLCBub2RlT2JqICkge1xyXG5cclxuXHRcdGlmICggdHlwZW9mIHByb3AgPT09ICdzdHJpbmcnICYmIG5vZGVbIHByb3AgXSA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0aWYgKCBub2RlLmlzU3RhY2tOb2RlICE9PSB0cnVlICYmIHByb3AgPT09ICdhc3NpZ24nICkge1xyXG5cclxuXHRcdFx0XHRyZXR1cm4gKCAuLi5wYXJhbXMgKSA9PiB7XHJcblxyXG5cdFx0XHRcdFx0Y3VycmVudFN0YWNrLmFzc2lnbiggbm9kZU9iaiwgLi4ucGFyYW1zICk7XHJcblxyXG5cdFx0XHRcdFx0cmV0dXJuIG5vZGVPYmo7XHJcblxyXG5cdFx0XHRcdH07XHJcblxyXG5cdFx0XHR9IGVsc2UgaWYgKCBOb2RlRWxlbWVudHMuaGFzKCBwcm9wICkgKSB7XHJcblxyXG5cdFx0XHRcdGNvbnN0IG5vZGVFbGVtZW50ID0gTm9kZUVsZW1lbnRzLmdldCggcHJvcCApO1xyXG5cclxuXHRcdFx0XHRyZXR1cm4gbm9kZS5pc1N0YWNrTm9kZSA/ICggLi4ucGFyYW1zICkgPT4gbm9kZU9iai5hZGQoIG5vZGVFbGVtZW50KCAuLi5wYXJhbXMgKSApIDogKCAuLi5wYXJhbXMgKSA9PiBub2RlRWxlbWVudCggbm9kZU9iaiwgLi4ucGFyYW1zICk7XHJcblxyXG5cdFx0XHR9IGVsc2UgaWYgKCBwcm9wID09PSAnc2VsZicgKSB7XHJcblxyXG5cdFx0XHRcdHJldHVybiBub2RlO1xyXG5cclxuXHRcdFx0fSBlbHNlIGlmICggcHJvcC5lbmRzV2l0aCggJ0Fzc2lnbicgKSAmJiBOb2RlRWxlbWVudHMuaGFzKCBwcm9wLnNsaWNlKCAwLCBwcm9wLmxlbmd0aCAtICdBc3NpZ24nLmxlbmd0aCApICkgKSB7XHJcblxyXG5cdFx0XHRcdGNvbnN0IG5vZGVFbGVtZW50ID0gTm9kZUVsZW1lbnRzLmdldCggcHJvcC5zbGljZSggMCwgcHJvcC5sZW5ndGggLSAnQXNzaWduJy5sZW5ndGggKSApO1xyXG5cclxuXHRcdFx0XHRyZXR1cm4gbm9kZS5pc1N0YWNrTm9kZSA/ICggLi4ucGFyYW1zICkgPT4gbm9kZU9iai5hc3NpZ24oIHBhcmFtc1sgMCBdLCBub2RlRWxlbWVudCggLi4ucGFyYW1zICkgKSA6ICggLi4ucGFyYW1zICkgPT4gbm9kZU9iai5hc3NpZ24oIG5vZGVFbGVtZW50KCBub2RlT2JqLCAuLi5wYXJhbXMgKSApO1xyXG5cclxuXHRcdFx0fSBlbHNlIGlmICggL15beHl6d3JnYmFzdHBxXXsxLDR9JC8udGVzdCggcHJvcCApID09PSB0cnVlICkge1xyXG5cclxuXHRcdFx0XHQvLyBhY2Nlc3NpbmcgcHJvcGVydGllcyAoIHN3aXp6bGUgKVxyXG5cclxuXHRcdFx0XHRwcm9wID0gcGFyc2VTd2l6emxlKCBwcm9wICk7XHJcblxyXG5cdFx0XHRcdHJldHVybiBub2RlT2JqZWN0KCBuZXcgU3BsaXROb2RlKCBub2RlT2JqLCBwcm9wICkgKTtcclxuXHJcblx0XHRcdH0gZWxzZSBpZiAoIC9ec2V0W1hZWldSR0JBU1RQUV17MSw0fSQvLnRlc3QoIHByb3AgKSA9PT0gdHJ1ZSApIHtcclxuXHJcblx0XHRcdFx0Ly8gc2V0IHByb3BlcnRpZXMgKCBzd2l6emxlICkgYW5kIHNvcnQgdG8geHl6dyBzZXF1ZW5jZVxyXG5cclxuXHRcdFx0XHRwcm9wID0gcGFyc2VTd2l6emxlQW5kU29ydCggcHJvcC5zbGljZSggMyApLnRvTG93ZXJDYXNlKCkgKTtcclxuXHJcblx0XHRcdFx0cmV0dXJuICggdmFsdWUgKSA9PiBub2RlT2JqZWN0KCBuZXcgU2V0Tm9kZSggbm9kZSwgcHJvcCwgdmFsdWUgKSApO1xyXG5cclxuXHRcdFx0fSBlbHNlIGlmICggL15mbGlwW1hZWldSR0JBU1RQUV17MSw0fSQvLnRlc3QoIHByb3AgKSA9PT0gdHJ1ZSApIHtcclxuXHJcblx0XHRcdFx0Ly8gc2V0IHByb3BlcnRpZXMgKCBzd2l6emxlICkgYW5kIHNvcnQgdG8geHl6dyBzZXF1ZW5jZVxyXG5cclxuXHRcdFx0XHRwcm9wID0gcGFyc2VTd2l6emxlQW5kU29ydCggcHJvcC5zbGljZSggNCApLnRvTG93ZXJDYXNlKCkgKTtcclxuXHJcblx0XHRcdFx0cmV0dXJuICgpID0+IG5vZGVPYmplY3QoIG5ldyBGbGlwTm9kZSggbm9kZU9iamVjdCggbm9kZSApLCBwcm9wICkgKTtcclxuXHJcblx0XHRcdH0gZWxzZSBpZiAoIHByb3AgPT09ICd3aWR0aCcgfHwgcHJvcCA9PT0gJ2hlaWdodCcgfHwgcHJvcCA9PT0gJ2RlcHRoJyApIHtcclxuXHJcblx0XHRcdFx0Ly8gYWNjZXNzaW5nIHByb3BlcnR5XHJcblxyXG5cdFx0XHRcdGlmICggcHJvcCA9PT0gJ3dpZHRoJyApIHByb3AgPSAneCc7XHJcblx0XHRcdFx0ZWxzZSBpZiAoIHByb3AgPT09ICdoZWlnaHQnICkgcHJvcCA9ICd5JztcclxuXHRcdFx0XHRlbHNlIGlmICggcHJvcCA9PT0gJ2RlcHRoJyApIHByb3AgPSAneic7XHJcblxyXG5cdFx0XHRcdHJldHVybiBub2RlT2JqZWN0KCBuZXcgU3BsaXROb2RlKCBub2RlLCBwcm9wICkgKTtcclxuXHJcblx0XHRcdH0gZWxzZSBpZiAoIC9eXFxkKyQvLnRlc3QoIHByb3AgKSA9PT0gdHJ1ZSApIHtcclxuXHJcblx0XHRcdFx0Ly8gYWNjZXNzaW5nIGFycmF5XHJcblxyXG5cdFx0XHRcdHJldHVybiBub2RlT2JqZWN0KCBuZXcgQXJyYXlFbGVtZW50Tm9kZSggbm9kZU9iaiwgbmV3IENvbnN0Tm9kZSggTnVtYmVyKCBwcm9wICksICd1aW50JyApICkgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIFJlZmxlY3QuZ2V0KCBub2RlLCBwcm9wLCBub2RlT2JqICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdHNldCggbm9kZSwgcHJvcCwgdmFsdWUsIG5vZGVPYmogKSB7XHJcblxyXG5cdFx0aWYgKCB0eXBlb2YgcHJvcCA9PT0gJ3N0cmluZycgJiYgbm9kZVsgcHJvcCBdID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHQvLyBzZXR0aW5nIHByb3BlcnRpZXNcclxuXHJcblx0XHRcdGlmICggL15beHl6d3JnYmFzdHBxXXsxLDR9JC8udGVzdCggcHJvcCApID09PSB0cnVlIHx8IHByb3AgPT09ICd3aWR0aCcgfHwgcHJvcCA9PT0gJ2hlaWdodCcgfHwgcHJvcCA9PT0gJ2RlcHRoJyB8fCAvXlxcZCskLy50ZXN0KCBwcm9wICkgPT09IHRydWUgKSB7XHJcblxyXG5cdFx0XHRcdG5vZGVPYmpbIHByb3AgXS5hc3NpZ24oIHZhbHVlICk7XHJcblxyXG5cdFx0XHRcdHJldHVybiB0cnVlO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gUmVmbGVjdC5zZXQoIG5vZGUsIHByb3AsIHZhbHVlLCBub2RlT2JqICk7XHJcblxyXG5cdH1cclxuXHJcbn07XHJcblxyXG5jb25zdCBub2RlT2JqZWN0c0NhY2hlTWFwID0gbmV3IFdlYWtNYXAoKTtcclxuY29uc3Qgbm9kZUJ1aWxkZXJGdW5jdGlvbnNDYWNoZU1hcCA9IG5ldyBXZWFrTWFwKCk7XHJcblxyXG5jb25zdCBTaGFkZXJOb2RlT2JqZWN0ID0gZnVuY3Rpb24gKCBvYmosIGFsdFR5cGUgPSBudWxsICkge1xyXG5cclxuXHRjb25zdCB0eXBlID0gZ2V0VmFsdWVUeXBlKCBvYmogKTtcclxuXHJcblx0aWYgKCB0eXBlID09PSAnbm9kZScgKSB7XHJcblxyXG5cdFx0bGV0IG5vZGVPYmplY3QgPSBub2RlT2JqZWN0c0NhY2hlTWFwLmdldCggb2JqICk7XHJcblxyXG5cdFx0aWYgKCBub2RlT2JqZWN0ID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRub2RlT2JqZWN0ID0gbmV3IFByb3h5KCBvYmosIHNoYWRlck5vZGVIYW5kbGVyICk7XHJcblxyXG5cdFx0XHRub2RlT2JqZWN0c0NhY2hlTWFwLnNldCggb2JqLCBub2RlT2JqZWN0ICk7XHJcblx0XHRcdG5vZGVPYmplY3RzQ2FjaGVNYXAuc2V0KCBub2RlT2JqZWN0LCBub2RlT2JqZWN0ICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBub2RlT2JqZWN0O1xyXG5cclxuXHR9IGVsc2UgaWYgKCAoIGFsdFR5cGUgPT09IG51bGwgJiYgKCB0eXBlID09PSAnZmxvYXQnIHx8IHR5cGUgPT09ICdib29sZWFuJyApICkgfHwgKCB0eXBlICYmIHR5cGUgIT09ICdzaGFkZXInICYmIHR5cGUgIT09ICdzdHJpbmcnICkgKSB7XHJcblxyXG5cdFx0cmV0dXJuIG5vZGVPYmplY3QoIGdldENvbnN0Tm9kZSggb2JqLCBhbHRUeXBlICkgKTtcclxuXHJcblx0fSBlbHNlIGlmICggdHlwZSA9PT0gJ3NoYWRlcicgKSB7XHJcblxyXG5cdFx0cmV0dXJuIEZuKCBvYmogKTtcclxuXHJcblx0fVxyXG5cclxuXHRyZXR1cm4gb2JqO1xyXG5cclxufTtcclxuXHJcbmNvbnN0IFNoYWRlck5vZGVPYmplY3RzID0gZnVuY3Rpb24gKCBvYmplY3RzLCBhbHRUeXBlID0gbnVsbCApIHtcclxuXHJcblx0Zm9yICggY29uc3QgbmFtZSBpbiBvYmplY3RzICkge1xyXG5cclxuXHRcdG9iamVjdHNbIG5hbWUgXSA9IG5vZGVPYmplY3QoIG9iamVjdHNbIG5hbWUgXSwgYWx0VHlwZSApO1xyXG5cclxuXHR9XHJcblxyXG5cdHJldHVybiBvYmplY3RzO1xyXG5cclxufTtcclxuXHJcbmNvbnN0IFNoYWRlck5vZGVBcnJheSA9IGZ1bmN0aW9uICggYXJyYXksIGFsdFR5cGUgPSBudWxsICkge1xyXG5cclxuXHRjb25zdCBsZW4gPSBhcnJheS5sZW5ndGg7XHJcblxyXG5cdGZvciAoIGxldCBpID0gMDsgaSA8IGxlbjsgaSArKyApIHtcclxuXHJcblx0XHRhcnJheVsgaSBdID0gbm9kZU9iamVjdCggYXJyYXlbIGkgXSwgYWx0VHlwZSApO1xyXG5cclxuXHR9XHJcblxyXG5cdHJldHVybiBhcnJheTtcclxuXHJcbn07XHJcblxyXG5jb25zdCBTaGFkZXJOb2RlUHJveHkgPSBmdW5jdGlvbiAoIE5vZGVDbGFzcywgc2NvcGUgPSBudWxsLCBmYWN0b3IgPSBudWxsLCBzZXR0aW5ncyA9IG51bGwgKSB7XHJcblxyXG5cdGNvbnN0IGFzc2lnbk5vZGUgPSAoIG5vZGUgKSA9PiBub2RlT2JqZWN0KCBzZXR0aW5ncyAhPT0gbnVsbCA/IE9iamVjdC5hc3NpZ24oIG5vZGUsIHNldHRpbmdzICkgOiBub2RlICk7XHJcblxyXG5cdGlmICggc2NvcGUgPT09IG51bGwgKSB7XHJcblxyXG5cdFx0cmV0dXJuICggLi4ucGFyYW1zICkgPT4ge1xyXG5cclxuXHRcdFx0cmV0dXJuIGFzc2lnbk5vZGUoIG5ldyBOb2RlQ2xhc3MoIC4uLm5vZGVBcnJheSggcGFyYW1zICkgKSApO1xyXG5cclxuXHRcdH07XHJcblxyXG5cdH0gZWxzZSBpZiAoIGZhY3RvciAhPT0gbnVsbCApIHtcclxuXHJcblx0XHRmYWN0b3IgPSBub2RlT2JqZWN0KCBmYWN0b3IgKTtcclxuXHJcblx0XHRyZXR1cm4gKCAuLi5wYXJhbXMgKSA9PiB7XHJcblxyXG5cdFx0XHRyZXR1cm4gYXNzaWduTm9kZSggbmV3IE5vZGVDbGFzcyggc2NvcGUsIC4uLm5vZGVBcnJheSggcGFyYW1zICksIGZhY3RvciApICk7XHJcblxyXG5cdFx0fTtcclxuXHJcblx0fSBlbHNlIHtcclxuXHJcblx0XHRyZXR1cm4gKCAuLi5wYXJhbXMgKSA9PiB7XHJcblxyXG5cdFx0XHRyZXR1cm4gYXNzaWduTm9kZSggbmV3IE5vZGVDbGFzcyggc2NvcGUsIC4uLm5vZGVBcnJheSggcGFyYW1zICkgKSApO1xyXG5cclxuXHRcdH07XHJcblxyXG5cdH1cclxuXHJcbn07XHJcblxyXG5jb25zdCBTaGFkZXJOb2RlSW1tdXRhYmxlID0gZnVuY3Rpb24gKCBOb2RlQ2xhc3MsIC4uLnBhcmFtcyApIHtcclxuXHJcblx0cmV0dXJuIG5vZGVPYmplY3QoIG5ldyBOb2RlQ2xhc3MoIC4uLm5vZGVBcnJheSggcGFyYW1zICkgKSApO1xyXG5cclxufTtcclxuXHJcbmNsYXNzIFNoYWRlckNhbGxOb2RlSW50ZXJuYWwgZXh0ZW5kcyBOb2RlIHtcclxuXHJcblx0Y29uc3RydWN0b3IoIHNoYWRlck5vZGUsIGlucHV0Tm9kZXMgKSB7XHJcblxyXG5cdFx0c3VwZXIoKTtcclxuXHJcblx0XHR0aGlzLnNoYWRlck5vZGUgPSBzaGFkZXJOb2RlO1xyXG5cdFx0dGhpcy5pbnB1dE5vZGVzID0gaW5wdXROb2RlcztcclxuXHJcblx0fVxyXG5cclxuXHRnZXROb2RlVHlwZSggYnVpbGRlciApIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5zaGFkZXJOb2RlLm5vZGVUeXBlIHx8IHRoaXMuZ2V0T3V0cHV0Tm9kZSggYnVpbGRlciApLmdldE5vZGVUeXBlKCBidWlsZGVyICk7XHJcblxyXG5cdH1cclxuXHJcblx0Y2FsbCggYnVpbGRlciApIHtcclxuXHJcblx0XHRjb25zdCB7IHNoYWRlck5vZGUsIGlucHV0Tm9kZXMgfSA9IHRoaXM7XHJcblxyXG5cdFx0Y29uc3QgcHJvcGVydGllcyA9IGJ1aWxkZXIuZ2V0Tm9kZVByb3BlcnRpZXMoIHNoYWRlck5vZGUgKTtcclxuXHRcdGlmICggcHJvcGVydGllcy5vbmNlT3V0cHV0ICkgcmV0dXJuIHByb3BlcnRpZXMub25jZU91dHB1dDtcclxuXHJcblx0XHQvL1xyXG5cclxuXHRcdGxldCByZXN1bHQgPSBudWxsO1xyXG5cclxuXHRcdGlmICggc2hhZGVyTm9kZS5sYXlvdXQgKSB7XHJcblxyXG5cdFx0XHRsZXQgZnVuY3Rpb25Ob2Rlc0NhY2hlTWFwID0gbm9kZUJ1aWxkZXJGdW5jdGlvbnNDYWNoZU1hcC5nZXQoIGJ1aWxkZXIuY29uc3RydWN0b3IgKTtcclxuXHJcblx0XHRcdGlmICggZnVuY3Rpb25Ob2Rlc0NhY2hlTWFwID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdGZ1bmN0aW9uTm9kZXNDYWNoZU1hcCA9IG5ldyBXZWFrTWFwKCk7XHJcblxyXG5cdFx0XHRcdG5vZGVCdWlsZGVyRnVuY3Rpb25zQ2FjaGVNYXAuc2V0KCBidWlsZGVyLmNvbnN0cnVjdG9yLCBmdW5jdGlvbk5vZGVzQ2FjaGVNYXAgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGxldCBmdW5jdGlvbk5vZGUgPSBmdW5jdGlvbk5vZGVzQ2FjaGVNYXAuZ2V0KCBzaGFkZXJOb2RlICk7XHJcblxyXG5cdFx0XHRpZiAoIGZ1bmN0aW9uTm9kZSA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRmdW5jdGlvbk5vZGUgPSBub2RlT2JqZWN0KCBidWlsZGVyLmJ1aWxkRnVuY3Rpb25Ob2RlKCBzaGFkZXJOb2RlICkgKTtcclxuXHJcblx0XHRcdFx0ZnVuY3Rpb25Ob2Rlc0NhY2hlTWFwLnNldCggc2hhZGVyTm9kZSwgZnVuY3Rpb25Ob2RlICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoIGJ1aWxkZXIuY3VycmVudEZ1bmN0aW9uTm9kZSAhPT0gbnVsbCApIHtcclxuXHJcblx0XHRcdFx0YnVpbGRlci5jdXJyZW50RnVuY3Rpb25Ob2RlLmluY2x1ZGVzLnB1c2goIGZ1bmN0aW9uTm9kZSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmVzdWx0ID0gbm9kZU9iamVjdCggZnVuY3Rpb25Ob2RlLmNhbGwoIGlucHV0Tm9kZXMgKSApO1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRjb25zdCBqc0Z1bmMgPSBzaGFkZXJOb2RlLmpzRnVuYztcclxuXHRcdFx0Y29uc3Qgb3V0cHV0Tm9kZSA9IGlucHV0Tm9kZXMgIT09IG51bGwgPyBqc0Z1bmMoIGlucHV0Tm9kZXMsIGJ1aWxkZXIgKSA6IGpzRnVuYyggYnVpbGRlciApO1xyXG5cclxuXHRcdFx0cmVzdWx0ID0gbm9kZU9iamVjdCggb3V0cHV0Tm9kZSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIHNoYWRlck5vZGUub25jZSApIHtcclxuXHJcblx0XHRcdHByb3BlcnRpZXMub25jZU91dHB1dCA9IHJlc3VsdDtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHJlc3VsdDtcclxuXHJcblx0fVxyXG5cclxuXHRnZXRPdXRwdXROb2RlKCBidWlsZGVyICkge1xyXG5cclxuXHRcdGNvbnN0IHByb3BlcnRpZXMgPSBidWlsZGVyLmdldE5vZGVQcm9wZXJ0aWVzKCB0aGlzICk7XHJcblxyXG5cdFx0aWYgKCBwcm9wZXJ0aWVzLm91dHB1dE5vZGUgPT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHRwcm9wZXJ0aWVzLm91dHB1dE5vZGUgPSB0aGlzLnNldHVwT3V0cHV0KCBidWlsZGVyICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBwcm9wZXJ0aWVzLm91dHB1dE5vZGU7XHJcblxyXG5cdH1cclxuXHJcblx0c2V0dXAoIGJ1aWxkZXIgKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuZ2V0T3V0cHV0Tm9kZSggYnVpbGRlciApO1xyXG5cclxuXHR9XHJcblxyXG5cdHNldHVwT3V0cHV0KCBidWlsZGVyICkge1xyXG5cclxuXHRcdGJ1aWxkZXIuYWRkU3RhY2soKTtcclxuXHJcblx0XHRidWlsZGVyLnN0YWNrLm91dHB1dE5vZGUgPSB0aGlzLmNhbGwoIGJ1aWxkZXIgKTtcclxuXHJcblx0XHRyZXR1cm4gYnVpbGRlci5yZW1vdmVTdGFjaygpO1xyXG5cclxuXHR9XHJcblxyXG5cdGdlbmVyYXRlKCBidWlsZGVyLCBvdXRwdXQgKSB7XHJcblxyXG5cdFx0Y29uc3Qgb3V0cHV0Tm9kZSA9IHRoaXMuZ2V0T3V0cHV0Tm9kZSggYnVpbGRlciApO1xyXG5cclxuXHRcdHJldHVybiBvdXRwdXROb2RlLmJ1aWxkKCBidWlsZGVyLCBvdXRwdXQgKTtcclxuXHJcblx0fVxyXG5cclxufVxyXG5cclxuY2xhc3MgU2hhZGVyTm9kZUludGVybmFsIGV4dGVuZHMgTm9kZSB7XHJcblxyXG5cdGNvbnN0cnVjdG9yKCBqc0Z1bmMsIG5vZGVUeXBlICkge1xyXG5cclxuXHRcdHN1cGVyKCBub2RlVHlwZSApO1xyXG5cclxuXHRcdHRoaXMuanNGdW5jID0ganNGdW5jO1xyXG5cdFx0dGhpcy5sYXlvdXQgPSBudWxsO1xyXG5cclxuXHRcdHRoaXMuZ2xvYmFsID0gdHJ1ZTtcclxuXHJcblx0XHR0aGlzLm9uY2UgPSBmYWxzZTtcclxuXHJcblx0fVxyXG5cclxuXHRzZXRMYXlvdXQoIGxheW91dCApIHtcclxuXHJcblx0XHR0aGlzLmxheW91dCA9IGxheW91dDtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fVxyXG5cclxuXHRjYWxsKCBpbnB1dHMgPSBudWxsICkge1xyXG5cclxuXHRcdG5vZGVPYmplY3RzKCBpbnB1dHMgKTtcclxuXHJcblx0XHRyZXR1cm4gbm9kZU9iamVjdCggbmV3IFNoYWRlckNhbGxOb2RlSW50ZXJuYWwoIHRoaXMsIGlucHV0cyApICk7XHJcblxyXG5cdH1cclxuXHJcblx0c2V0dXAoKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuY2FsbCgpO1xyXG5cclxuXHR9XHJcblxyXG59XHJcblxyXG5jb25zdCBib29scyA9IFsgZmFsc2UsIHRydWUgXTtcclxuY29uc3QgdWludHMgPSBbIDAsIDEsIDIsIDMgXTtcclxuY29uc3QgaW50cyA9IFsgLSAxLCAtIDIgXTtcclxuY29uc3QgZmxvYXRzID0gWyAwLjUsIDEuNSwgMSAvIDMsIDFlLTYsIDFlNiwgTWF0aC5QSSwgTWF0aC5QSSAqIDIsIDEgLyBNYXRoLlBJLCAyIC8gTWF0aC5QSSwgMSAvICggTWF0aC5QSSAqIDIgKSwgTWF0aC5QSSAvIDIgXTtcclxuXHJcbmNvbnN0IGJvb2xzQ2FjaGVNYXAgPSBuZXcgTWFwKCk7XHJcbmZvciAoIGNvbnN0IGJvb2wgb2YgYm9vbHMgKSBib29sc0NhY2hlTWFwLnNldCggYm9vbCwgbmV3IENvbnN0Tm9kZSggYm9vbCApICk7XHJcblxyXG5jb25zdCB1aW50c0NhY2hlTWFwID0gbmV3IE1hcCgpO1xyXG5mb3IgKCBjb25zdCB1aW50IG9mIHVpbnRzICkgdWludHNDYWNoZU1hcC5zZXQoIHVpbnQsIG5ldyBDb25zdE5vZGUoIHVpbnQsICd1aW50JyApICk7XHJcblxyXG5jb25zdCBpbnRzQ2FjaGVNYXAgPSBuZXcgTWFwKCBbIC4uLnVpbnRzQ2FjaGVNYXAgXS5tYXAoIGVsID0+IG5ldyBDb25zdE5vZGUoIGVsLnZhbHVlLCAnaW50JyApICkgKTtcclxuZm9yICggY29uc3QgaW50IG9mIGludHMgKSBpbnRzQ2FjaGVNYXAuc2V0KCBpbnQsIG5ldyBDb25zdE5vZGUoIGludCwgJ2ludCcgKSApO1xyXG5cclxuY29uc3QgZmxvYXRzQ2FjaGVNYXAgPSBuZXcgTWFwKCBbIC4uLmludHNDYWNoZU1hcCBdLm1hcCggZWwgPT4gbmV3IENvbnN0Tm9kZSggZWwudmFsdWUgKSApICk7XHJcbmZvciAoIGNvbnN0IGZsb2F0IG9mIGZsb2F0cyApIGZsb2F0c0NhY2hlTWFwLnNldCggZmxvYXQsIG5ldyBDb25zdE5vZGUoIGZsb2F0ICkgKTtcclxuZm9yICggY29uc3QgZmxvYXQgb2YgZmxvYXRzICkgZmxvYXRzQ2FjaGVNYXAuc2V0KCAtIGZsb2F0LCBuZXcgQ29uc3ROb2RlKCAtIGZsb2F0ICkgKTtcclxuXHJcbmNvbnN0IGNhY2hlTWFwcyA9IHsgYm9vbDogYm9vbHNDYWNoZU1hcCwgdWludDogdWludHNDYWNoZU1hcCwgaW50czogaW50c0NhY2hlTWFwLCBmbG9hdDogZmxvYXRzQ2FjaGVNYXAgfTtcclxuXHJcbmNvbnN0IGNvbnN0Tm9kZXNDYWNoZU1hcCA9IG5ldyBNYXAoIFsgLi4uYm9vbHNDYWNoZU1hcCwgLi4uZmxvYXRzQ2FjaGVNYXAgXSApO1xyXG5cclxuY29uc3QgZ2V0Q29uc3ROb2RlID0gKCB2YWx1ZSwgdHlwZSApID0+IHtcclxuXHJcblx0aWYgKCBjb25zdE5vZGVzQ2FjaGVNYXAuaGFzKCB2YWx1ZSApICkge1xyXG5cclxuXHRcdHJldHVybiBjb25zdE5vZGVzQ2FjaGVNYXAuZ2V0KCB2YWx1ZSApO1xyXG5cclxuXHR9IGVsc2UgaWYgKCB2YWx1ZS5pc05vZGUgPT09IHRydWUgKSB7XHJcblxyXG5cdFx0cmV0dXJuIHZhbHVlO1xyXG5cclxuXHR9IGVsc2Uge1xyXG5cclxuXHRcdHJldHVybiBuZXcgQ29uc3ROb2RlKCB2YWx1ZSwgdHlwZSApO1xyXG5cclxuXHR9XHJcblxyXG59O1xyXG5cclxuY29uc3Qgc2FmZUdldE5vZGVUeXBlID0gKCBub2RlICkgPT4ge1xyXG5cclxuXHR0cnkge1xyXG5cclxuXHRcdHJldHVybiBub2RlLmdldE5vZGVUeXBlKCk7XHJcblxyXG5cdH0gY2F0Y2ggKCBfICkge1xyXG5cclxuXHRcdHJldHVybiB1bmRlZmluZWQ7XHJcblxyXG5cdH1cclxuXHJcbn07XHJcblxyXG5jb25zdCBDb252ZXJ0VHlwZSA9IGZ1bmN0aW9uICggdHlwZSwgY2FjaGVNYXAgPSBudWxsICkge1xyXG5cclxuXHRyZXR1cm4gKCAuLi5wYXJhbXMgKSA9PiB7XHJcblxyXG5cdFx0aWYgKCBwYXJhbXMubGVuZ3RoID09PSAwIHx8ICggISBbICdib29sJywgJ2Zsb2F0JywgJ2ludCcsICd1aW50JyBdLmluY2x1ZGVzKCB0eXBlICkgJiYgcGFyYW1zLmV2ZXJ5KCBwYXJhbSA9PiB0eXBlb2YgcGFyYW0gIT09ICdvYmplY3QnICkgKSApIHtcclxuXHJcblx0XHRcdHBhcmFtcyA9IFsgZ2V0VmFsdWVGcm9tVHlwZSggdHlwZSwgLi4ucGFyYW1zICkgXTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBwYXJhbXMubGVuZ3RoID09PSAxICYmIGNhY2hlTWFwICE9PSBudWxsICYmIGNhY2hlTWFwLmhhcyggcGFyYW1zWyAwIF0gKSApIHtcclxuXHJcblx0XHRcdHJldHVybiBub2RlT2JqZWN0KCBjYWNoZU1hcC5nZXQoIHBhcmFtc1sgMCBdICkgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBwYXJhbXMubGVuZ3RoID09PSAxICkge1xyXG5cclxuXHRcdFx0Y29uc3Qgbm9kZSA9IGdldENvbnN0Tm9kZSggcGFyYW1zWyAwIF0sIHR5cGUgKTtcclxuXHRcdFx0aWYgKCBzYWZlR2V0Tm9kZVR5cGUoIG5vZGUgKSA9PT0gdHlwZSApIHJldHVybiBub2RlT2JqZWN0KCBub2RlICk7XHJcblx0XHRcdHJldHVybiBub2RlT2JqZWN0KCBuZXcgQ29udmVydE5vZGUoIG5vZGUsIHR5cGUgKSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRjb25zdCBub2RlcyA9IHBhcmFtcy5tYXAoIHBhcmFtID0+IGdldENvbnN0Tm9kZSggcGFyYW0gKSApO1xyXG5cdFx0cmV0dXJuIG5vZGVPYmplY3QoIG5ldyBKb2luTm9kZSggbm9kZXMsIHR5cGUgKSApO1xyXG5cclxuXHR9O1xyXG5cclxufTtcclxuXHJcbi8vIGV4cG9ydHNcclxuXHJcbmV4cG9ydCBjb25zdCBkZWZpbmVkID0gKCB2ICkgPT4gdHlwZW9mIHYgPT09ICdvYmplY3QnICYmIHYgIT09IG51bGwgPyB2LnZhbHVlIDogdjsgLy8gVE9ETzogcmVtb3ZlIGJvb2xlYW4gY29udmVyc2lvbiBhbmQgZGVmaW5lZCBmdW5jdGlvblxyXG5cclxuLy8gdXRpbHNcclxuXHJcbmV4cG9ydCBjb25zdCBnZXRDb25zdE5vZGVUeXBlID0gKCB2YWx1ZSApID0+ICggdmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSAhPT0gbnVsbCApID8gKCB2YWx1ZS5ub2RlVHlwZSB8fCB2YWx1ZS5jb252ZXJ0VG8gfHwgKCB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnID8gdmFsdWUgOiBudWxsICkgKSA6IG51bGw7XHJcblxyXG4vLyBzaGFkZXIgbm9kZSBiYXNlXHJcblxyXG5leHBvcnQgZnVuY3Rpb24gU2hhZGVyTm9kZSgganNGdW5jLCBub2RlVHlwZSApIHtcclxuXHJcblx0cmV0dXJuIG5ldyBQcm94eSggbmV3IFNoYWRlck5vZGVJbnRlcm5hbCgganNGdW5jLCBub2RlVHlwZSApLCBzaGFkZXJOb2RlSGFuZGxlciApO1xyXG5cclxufVxyXG5cclxuZXhwb3J0IGNvbnN0IG5vZGVPYmplY3QgPSAoIHZhbCwgYWx0VHlwZSA9IG51bGwgKSA9PiAvKiBuZXcgKi8gU2hhZGVyTm9kZU9iamVjdCggdmFsLCBhbHRUeXBlICk7XHJcbmV4cG9ydCBjb25zdCBub2RlT2JqZWN0cyA9ICggdmFsLCBhbHRUeXBlID0gbnVsbCApID0+IG5ldyBTaGFkZXJOb2RlT2JqZWN0cyggdmFsLCBhbHRUeXBlICk7XHJcbmV4cG9ydCBjb25zdCBub2RlQXJyYXkgPSAoIHZhbCwgYWx0VHlwZSA9IG51bGwgKSA9PiBuZXcgU2hhZGVyTm9kZUFycmF5KCB2YWwsIGFsdFR5cGUgKTtcclxuZXhwb3J0IGNvbnN0IG5vZGVQcm94eSA9ICggLi4ucGFyYW1zICkgPT4gbmV3IFNoYWRlck5vZGVQcm94eSggLi4ucGFyYW1zICk7XHJcbmV4cG9ydCBjb25zdCBub2RlSW1tdXRhYmxlID0gKCAuLi5wYXJhbXMgKSA9PiBuZXcgU2hhZGVyTm9kZUltbXV0YWJsZSggLi4ucGFyYW1zICk7XHJcblxyXG5leHBvcnQgY29uc3QgRm4gPSAoIGpzRnVuYywgbm9kZVR5cGUgKSA9PiB7XHJcblxyXG5cdGNvbnN0IHNoYWRlck5vZGUgPSBuZXcgU2hhZGVyTm9kZSgganNGdW5jLCBub2RlVHlwZSApO1xyXG5cclxuXHRjb25zdCBmbiA9ICggLi4ucGFyYW1zICkgPT4ge1xyXG5cclxuXHRcdGxldCBpbnB1dHM7XHJcblxyXG5cdFx0bm9kZU9iamVjdHMoIHBhcmFtcyApO1xyXG5cclxuXHRcdGlmICggcGFyYW1zWyAwIF0gJiYgcGFyYW1zWyAwIF0uaXNOb2RlICkge1xyXG5cclxuXHRcdFx0aW5wdXRzID0gWyAuLi5wYXJhbXMgXTtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0aW5wdXRzID0gcGFyYW1zWyAwIF07XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBzaGFkZXJOb2RlLmNhbGwoIGlucHV0cyApO1xyXG5cclxuXHR9O1xyXG5cclxuXHRmbi5zaGFkZXJOb2RlID0gc2hhZGVyTm9kZTtcclxuXHJcblx0Zm4uc2V0TGF5b3V0ID0gKCBsYXlvdXQgKSA9PiB7XHJcblxyXG5cdFx0c2hhZGVyTm9kZS5zZXRMYXlvdXQoIGxheW91dCApO1xyXG5cclxuXHRcdHJldHVybiBmbjtcclxuXHJcblx0fTtcclxuXHJcblx0Zm4ub25jZSA9ICgpID0+IHtcclxuXHJcblx0XHRzaGFkZXJOb2RlLm9uY2UgPSB0cnVlO1xyXG5cclxuXHRcdHJldHVybiBmbjtcclxuXHJcblx0fTtcclxuXHJcblx0cmV0dXJuIGZuO1xyXG5cclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCB0c2xGbiA9ICggLi4ucGFyYW1zICkgPT4geyAvLyBAZGVwcmVjYXRlZCwgcjE2OFxyXG5cclxuXHRjb25zb2xlLndhcm4oICdUU0wuU2hhZGVyTm9kZTogdHNsRm4oKSBoYXMgYmVlbiByZW5hbWVkIHRvIEZuKCkuJyApO1xyXG5cdHJldHVybiBGbiggLi4ucGFyYW1zICk7XHJcblxyXG59O1xyXG5cclxuLy9cclxuXHJcbmFkZE1ldGhvZENoYWluaW5nKCAndG9HbG9iYWwnLCAoIG5vZGUgKSA9PiB7XHJcblxyXG5cdG5vZGUuZ2xvYmFsID0gdHJ1ZTtcclxuXHJcblx0cmV0dXJuIG5vZGU7XHJcblxyXG59ICk7XHJcblxyXG4vL1xyXG5cclxuZXhwb3J0IGNvbnN0IHNldEN1cnJlbnRTdGFjayA9ICggc3RhY2sgKSA9PiB7XHJcblxyXG5cdGlmICggY3VycmVudFN0YWNrID09PSBzdGFjayApIHtcclxuXHJcblx0XHQvL3Rocm93IG5ldyBFcnJvciggJ1N0YWNrIGFscmVhZHkgZGVmaW5lZC4nICk7XHJcblxyXG5cdH1cclxuXHJcblx0Y3VycmVudFN0YWNrID0gc3RhY2s7XHJcblxyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IGdldEN1cnJlbnRTdGFjayA9ICgpID0+IGN1cnJlbnRTdGFjaztcclxuXHJcbmV4cG9ydCBjb25zdCBJZiA9ICggLi4ucGFyYW1zICkgPT4gY3VycmVudFN0YWNrLklmKCAuLi5wYXJhbXMgKTtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBhcHBlbmQoIG5vZGUgKSB7XHJcblxyXG5cdGlmICggY3VycmVudFN0YWNrICkgY3VycmVudFN0YWNrLmFkZCggbm9kZSApO1xyXG5cclxuXHRyZXR1cm4gbm9kZTtcclxuXHJcbn1cclxuXHJcbmFkZE1ldGhvZENoYWluaW5nKCAnYXBwZW5kJywgYXBwZW5kICk7XHJcblxyXG4vLyB0eXBlc1xyXG5cclxuZXhwb3J0IGNvbnN0IGNvbG9yID0gbmV3IENvbnZlcnRUeXBlKCAnY29sb3InICk7XHJcblxyXG5leHBvcnQgY29uc3QgZmxvYXQgPSBuZXcgQ29udmVydFR5cGUoICdmbG9hdCcsIGNhY2hlTWFwcy5mbG9hdCApO1xyXG5leHBvcnQgY29uc3QgaW50ID0gbmV3IENvbnZlcnRUeXBlKCAnaW50JywgY2FjaGVNYXBzLmludHMgKTtcclxuZXhwb3J0IGNvbnN0IHVpbnQgPSBuZXcgQ29udmVydFR5cGUoICd1aW50JywgY2FjaGVNYXBzLnVpbnQgKTtcclxuZXhwb3J0IGNvbnN0IGJvb2wgPSBuZXcgQ29udmVydFR5cGUoICdib29sJywgY2FjaGVNYXBzLmJvb2wgKTtcclxuXHJcbmV4cG9ydCBjb25zdCB2ZWMyID0gbmV3IENvbnZlcnRUeXBlKCAndmVjMicgKTtcclxuZXhwb3J0IGNvbnN0IGl2ZWMyID0gbmV3IENvbnZlcnRUeXBlKCAnaXZlYzInICk7XHJcbmV4cG9ydCBjb25zdCB1dmVjMiA9IG5ldyBDb252ZXJ0VHlwZSggJ3V2ZWMyJyApO1xyXG5leHBvcnQgY29uc3QgYnZlYzIgPSBuZXcgQ29udmVydFR5cGUoICdidmVjMicgKTtcclxuXHJcbmV4cG9ydCBjb25zdCB2ZWMzID0gbmV3IENvbnZlcnRUeXBlKCAndmVjMycgKTtcclxuZXhwb3J0IGNvbnN0IGl2ZWMzID0gbmV3IENvbnZlcnRUeXBlKCAnaXZlYzMnICk7XHJcbmV4cG9ydCBjb25zdCB1dmVjMyA9IG5ldyBDb252ZXJ0VHlwZSggJ3V2ZWMzJyApO1xyXG5leHBvcnQgY29uc3QgYnZlYzMgPSBuZXcgQ29udmVydFR5cGUoICdidmVjMycgKTtcclxuXHJcbmV4cG9ydCBjb25zdCB2ZWM0ID0gbmV3IENvbnZlcnRUeXBlKCAndmVjNCcgKTtcclxuZXhwb3J0IGNvbnN0IGl2ZWM0ID0gbmV3IENvbnZlcnRUeXBlKCAnaXZlYzQnICk7XHJcbmV4cG9ydCBjb25zdCB1dmVjNCA9IG5ldyBDb252ZXJ0VHlwZSggJ3V2ZWM0JyApO1xyXG5leHBvcnQgY29uc3QgYnZlYzQgPSBuZXcgQ29udmVydFR5cGUoICdidmVjNCcgKTtcclxuXHJcbmV4cG9ydCBjb25zdCBtYXQyID0gbmV3IENvbnZlcnRUeXBlKCAnbWF0MicgKTtcclxuZXhwb3J0IGNvbnN0IG1hdDMgPSBuZXcgQ29udmVydFR5cGUoICdtYXQzJyApO1xyXG5leHBvcnQgY29uc3QgbWF0NCA9IG5ldyBDb252ZXJ0VHlwZSggJ21hdDQnICk7XHJcblxyXG5leHBvcnQgY29uc3Qgc3RyaW5nID0gKCB2YWx1ZSA9ICcnICkgPT4gbm9kZU9iamVjdCggbmV3IENvbnN0Tm9kZSggdmFsdWUsICdzdHJpbmcnICkgKTtcclxuZXhwb3J0IGNvbnN0IGFycmF5QnVmZmVyID0gKCB2YWx1ZSApID0+IG5vZGVPYmplY3QoIG5ldyBDb25zdE5vZGUoIHZhbHVlLCAnQXJyYXlCdWZmZXInICkgKTtcclxuXHJcbmFkZE1ldGhvZENoYWluaW5nKCAndG9Db2xvcicsIGNvbG9yICk7XHJcbmFkZE1ldGhvZENoYWluaW5nKCAndG9GbG9hdCcsIGZsb2F0ICk7XHJcbmFkZE1ldGhvZENoYWluaW5nKCAndG9JbnQnLCBpbnQgKTtcclxuYWRkTWV0aG9kQ2hhaW5pbmcoICd0b1VpbnQnLCB1aW50ICk7XHJcbmFkZE1ldGhvZENoYWluaW5nKCAndG9Cb29sJywgYm9vbCApO1xyXG5hZGRNZXRob2RDaGFpbmluZyggJ3RvVmVjMicsIHZlYzIgKTtcclxuYWRkTWV0aG9kQ2hhaW5pbmcoICd0b0lWZWMyJywgaXZlYzIgKTtcclxuYWRkTWV0aG9kQ2hhaW5pbmcoICd0b1VWZWMyJywgdXZlYzIgKTtcclxuYWRkTWV0aG9kQ2hhaW5pbmcoICd0b0JWZWMyJywgYnZlYzIgKTtcclxuYWRkTWV0aG9kQ2hhaW5pbmcoICd0b1ZlYzMnLCB2ZWMzICk7XHJcbmFkZE1ldGhvZENoYWluaW5nKCAndG9JVmVjMycsIGl2ZWMzICk7XHJcbmFkZE1ldGhvZENoYWluaW5nKCAndG9VVmVjMycsIHV2ZWMzICk7XHJcbmFkZE1ldGhvZENoYWluaW5nKCAndG9CVmVjMycsIGJ2ZWMzICk7XHJcbmFkZE1ldGhvZENoYWluaW5nKCAndG9WZWM0JywgdmVjNCApO1xyXG5hZGRNZXRob2RDaGFpbmluZyggJ3RvSVZlYzQnLCBpdmVjNCApO1xyXG5hZGRNZXRob2RDaGFpbmluZyggJ3RvVVZlYzQnLCB1dmVjNCApO1xyXG5hZGRNZXRob2RDaGFpbmluZyggJ3RvQlZlYzQnLCBidmVjNCApO1xyXG5hZGRNZXRob2RDaGFpbmluZyggJ3RvTWF0MicsIG1hdDIgKTtcclxuYWRkTWV0aG9kQ2hhaW5pbmcoICd0b01hdDMnLCBtYXQzICk7XHJcbmFkZE1ldGhvZENoYWluaW5nKCAndG9NYXQ0JywgbWF0NCApO1xyXG5cclxuLy8gYmFzaWMgbm9kZXNcclxuXHJcbmV4cG9ydCBjb25zdCBlbGVtZW50ID0gLypAX19QVVJFX18qLyBub2RlUHJveHkoIEFycmF5RWxlbWVudE5vZGUgKTtcclxuZXhwb3J0IGNvbnN0IGNvbnZlcnQgPSAoIG5vZGUsIHR5cGVzICkgPT4gbm9kZU9iamVjdCggbmV3IENvbnZlcnROb2RlKCBub2RlT2JqZWN0KCBub2RlICksIHR5cGVzICkgKTtcclxuZXhwb3J0IGNvbnN0IHNwbGl0ID0gKCBub2RlLCBjaGFubmVscyApID0+IG5vZGVPYmplY3QoIG5ldyBTcGxpdE5vZGUoIG5vZGVPYmplY3QoIG5vZGUgKSwgY2hhbm5lbHMgKSApO1xyXG5cclxuYWRkTWV0aG9kQ2hhaW5pbmcoICdlbGVtZW50JywgZWxlbWVudCApO1xyXG5hZGRNZXRob2RDaGFpbmluZyggJ2NvbnZlcnQnLCBjb252ZXJ0ICk7XHJcbiIsImltcG9ydCBOb2RlIGZyb20gJy4vTm9kZS5qcyc7XHJcblxyXG4vKiogQG1vZHVsZSBVbmlmb3JtR3JvdXBOb2RlICoqL1xyXG5cclxuLyoqXHJcbiAqIFRoaXMgbm9kZSBjYW4gYmUgdXNlZCB0byBncm91cCBzaW5nbGUgaW5zdGFuY2VzIG9mIHtAbGluayBVbmlmb3JtTm9kZX1cclxuICogYW5kIG1hbmFnZSB0aGVtIGFzIGEgdW5pZm9ybSBidWZmZXIuXHJcbiAqXHJcbiAqIEluIG1vc3QgY2FzZXMsIHRoZSBwcmVkZWZpbmVkIG5vZGVzIGBvYmplY3RHcm91cGAsIGByZW5kZXJHcm91cGAgYW5kIGBmcmFtZUdyb3VwYFxyXG4gKiB3aWxsIGJlIHVzZWQgd2hlbiBkZWZpbmluZyB0aGUge0BsaW5rIFVuaWZvcm1Ob2RlI2dyb3VwTm9kZX0gcHJvcGVydHkuXHJcbiAqXHJcbiAqIC0gYG9iamVjdEdyb3VwYDogVW5pZm9ybSBidWZmZXIgcGVyIG9iamVjdC5cclxuICogLSBgcmVuZGVyR3JvdXBgOiBTaGFyZWQgdW5pZm9ybSBidWZmZXIsIHVwZGF0ZWQgb25jZSBwZXIgcmVuZGVyIGNhbGwuXHJcbiAqIC0gYGZyYW1lR3JvdXBgOiBTaGFyZWQgdW5pZm9ybSBidWZmZXIsIHVwZGF0ZWQgb25jZSBwZXIgZnJhbWUuXHJcbiAqXHJcbiAqIEBhdWdtZW50cyBOb2RlXHJcbiAqL1xyXG5jbGFzcyBVbmlmb3JtR3JvdXBOb2RlIGV4dGVuZHMgTm9kZSB7XHJcblxyXG5cdHN0YXRpYyBnZXQgdHlwZSgpIHtcclxuXHJcblx0XHRyZXR1cm4gJ1VuaWZvcm1Hcm91cE5vZGUnO1xyXG5cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIENvbnN0cnVjdHMgYSBuZXcgdW5pZm9ybSBncm91cCBub2RlLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgdW5pZm9ybSBncm91cCBub2RlLlxyXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gW3NoYXJlZD1mYWxzZV0gLSBXaGV0aGVyIHRoaXMgdW5pZm9ybSBncm91cCBub2RlIGlzIHNoYXJlZCBvciBub3QuXHJcblx0ICogQHBhcmFtIHtOdW1iZXJ9IFtvcmRlcj0xXSAtIEluZmx1ZW5jZXMgdGhlIGludGVybmFsIHNvcnRpbmcuXHJcblx0ICovXHJcblx0Y29uc3RydWN0b3IoIG5hbWUsIHNoYXJlZCA9IGZhbHNlLCBvcmRlciA9IDEgKSB7XHJcblxyXG5cdFx0c3VwZXIoICdzdHJpbmcnICk7XHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBUaGUgbmFtZSBvZiB0aGUgdW5pZm9ybSBncm91cCBub2RlLlxyXG5cdFx0ICpcclxuXHRcdCAqIEB0eXBlIHtTdHJpbmd9XHJcblx0XHQgKi9cclxuXHRcdHRoaXMubmFtZSA9IG5hbWU7XHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBXaGV0aGVyIHRoaXMgdW5pZm9ybSBncm91cCBub2RlIGlzIHNoYXJlZCBvciBub3QuXHJcblx0XHQgKlxyXG5cdFx0ICogQHR5cGUge0Jvb2xlYW59XHJcblx0XHQgKiBAZGVmYXVsdCBmYWxzZVxyXG5cdFx0ICovXHJcblx0XHR0aGlzLnNoYXJlZCA9IHNoYXJlZDtcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIEluZmx1ZW5jZXMgdGhlIGludGVybmFsIHNvcnRpbmcuXHJcblx0XHQgKiBUT0RPOiBBZGQgZGV0YWlscyB3aGVuIHRoaXMgcHJvcGVydHkgc2hvdWxkIGJlIGNoYW5nZWQuXHJcblx0XHQgKlxyXG5cdFx0ICogQHR5cGUge051bWJlcn1cclxuXHRcdCAqIEBkZWZhdWx0IDFcclxuXHRcdCAqL1xyXG5cdFx0dGhpcy5vcmRlciA9IG9yZGVyO1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogVGhpcyBmbGFnIGNhbiBiZSB1c2VkIGZvciB0eXBlIHRlc3RpbmcuXHJcblx0XHQgKlxyXG5cdFx0ICogQHR5cGUge0Jvb2xlYW59XHJcblx0XHQgKiBAcmVhZG9ubHlcclxuXHRcdCAqIEBkZWZhdWx0IHRydWVcclxuXHRcdCAqL1xyXG5cdFx0dGhpcy5pc1VuaWZvcm1Hcm91cCA9IHRydWU7XHJcblxyXG5cdH1cclxuXHJcblx0c2VyaWFsaXplKCBkYXRhICkge1xyXG5cclxuXHRcdHN1cGVyLnNlcmlhbGl6ZSggZGF0YSApO1xyXG5cclxuXHRcdGRhdGEubmFtZSA9IHRoaXMubmFtZTtcclxuXHRcdGRhdGEudmVyc2lvbiA9IHRoaXMudmVyc2lvbjtcclxuXHRcdGRhdGEuc2hhcmVkID0gdGhpcy5zaGFyZWQ7XHJcblxyXG5cdH1cclxuXHJcblx0ZGVzZXJpYWxpemUoIGRhdGEgKSB7XHJcblxyXG5cdFx0c3VwZXIuZGVzZXJpYWxpemUoIGRhdGEgKTtcclxuXHJcblx0XHR0aGlzLm5hbWUgPSBkYXRhLm5hbWU7XHJcblx0XHR0aGlzLnZlcnNpb24gPSBkYXRhLnZlcnNpb247XHJcblx0XHR0aGlzLnNoYXJlZCA9IGRhdGEuc2hhcmVkO1xyXG5cclxuXHR9XHJcblxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBVbmlmb3JtR3JvdXBOb2RlO1xyXG5cclxuLyoqXHJcbiAqIFRTTCBmdW5jdGlvbiBmb3IgY3JlYXRpbmcgYSB1bmlmb3JtIGdyb3VwIG5vZGUgd2l0aCB0aGUgZ2l2ZW4gbmFtZS5cclxuICpcclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIC0gVGhlIG5hbWUgb2YgdGhlIHVuaWZvcm0gZ3JvdXAgbm9kZS5cclxuICogQHJldHVybnMge1VuaWZvcm1Hcm91cE5vZGV9XHJcbiAqL1xyXG5leHBvcnQgY29uc3QgdW5pZm9ybUdyb3VwID0gKCBuYW1lICkgPT4gbmV3IFVuaWZvcm1Hcm91cE5vZGUoIG5hbWUgKTtcclxuXHJcbi8qKlxyXG4gKiBUU0wgZnVuY3Rpb24gZm9yIGNyZWF0aW5nIGEgc2hhcmVkIHVuaWZvcm0gZ3JvdXAgbm9kZSB3aXRoIHRoZSBnaXZlbiBuYW1lIGFuZCBvcmRlci5cclxuICpcclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIC0gVGhlIG5hbWUgb2YgdGhlIHVuaWZvcm0gZ3JvdXAgbm9kZS5cclxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcmRlcj0wXSAtIEluZmx1ZW5jZXMgdGhlIGludGVybmFsIHNvcnRpbmcuXHJcbiAqIEByZXR1cm5zIHtVbmlmb3JtR3JvdXBOb2RlfVxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IHNoYXJlZFVuaWZvcm1Hcm91cCA9ICggbmFtZSwgb3JkZXIgPSAwICkgPT4gbmV3IFVuaWZvcm1Hcm91cE5vZGUoIG5hbWUsIHRydWUsIG9yZGVyICk7XHJcblxyXG4vKipcclxuICogVFNMIG9iamVjdCB0aGF0IHJlcHJlc2VudHMgYSBzaGFyZWQgdW5pZm9ybSBncm91cCBub2RlIHdoaWNoIGlzIHVwZGF0ZWQgb25jZSBwZXIgZnJhbWUuXHJcbiAqXHJcbiAqIEB0eXBlIHtVbmlmb3JtR3JvdXBOb2RlfVxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IGZyYW1lR3JvdXAgPSAvKkBfX1BVUkVfXyovIHNoYXJlZFVuaWZvcm1Hcm91cCggJ2ZyYW1lJyApO1xyXG5cclxuLyoqXHJcbiAqIFRTTCBvYmplY3QgdGhhdCByZXByZXNlbnRzIGEgc2hhcmVkIHVuaWZvcm0gZ3JvdXAgbm9kZSB3aGljaCBpcyB1cGRhdGVkIG9uY2UgcGVyIHJlbmRlci5cclxuICpcclxuICogQHR5cGUge1VuaWZvcm1Hcm91cE5vZGV9XHJcbiAqL1xyXG5leHBvcnQgY29uc3QgcmVuZGVyR3JvdXAgPSAvKkBfX1BVUkVfXyovIHNoYXJlZFVuaWZvcm1Hcm91cCggJ3JlbmRlcicgKTtcclxuXHJcbi8qKlxyXG4gKiBUU0wgb2JqZWN0IHRoYXQgcmVwcmVzZW50cyBhIHVuaWZvcm0gZ3JvdXAgbm9kZSB3aGljaCBpcyB1cGRhdGVkIG9uY2UgcGVyIG9iamVjdC5cclxuICpcclxuICogQHR5cGUge1VuaWZvcm1Hcm91cE5vZGV9XHJcbiAqL1xyXG5leHBvcnQgY29uc3Qgb2JqZWN0R3JvdXAgPSAvKkBfX1BVUkVfXyovIHVuaWZvcm1Hcm91cCggJ29iamVjdCcgKTtcclxuIiwiaW1wb3J0IElucHV0Tm9kZSBmcm9tICcuL0lucHV0Tm9kZS5qcyc7XHJcbmltcG9ydCB7IG9iamVjdEdyb3VwIH0gZnJvbSAnLi9Vbmlmb3JtR3JvdXBOb2RlLmpzJztcclxuaW1wb3J0IHsgbm9kZU9iamVjdCwgZ2V0Q29uc3ROb2RlVHlwZSB9IGZyb20gJy4uL3RzbC9UU0xDb3JlLmpzJztcclxuXHJcbi8qKiBAbW9kdWxlIFVuaWZvcm1Ob2RlICoqL1xyXG5cclxuLyoqXHJcbiAqIENsYXNzIGZvciByZXByZXNlbnRpbmcgYSB1bmlmb3JtLlxyXG4gKlxyXG4gKiBAYXVnbWVudHMgSW5wdXROb2RlXHJcbiAqL1xyXG5jbGFzcyBVbmlmb3JtTm9kZSBleHRlbmRzIElucHV0Tm9kZSB7XHJcblxyXG5cdHN0YXRpYyBnZXQgdHlwZSgpIHtcclxuXHJcblx0XHRyZXR1cm4gJ1VuaWZvcm1Ob2RlJztcclxuXHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBDb25zdHJ1Y3RzIGEgbmV3IHVuaWZvcm0gbm9kZS5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7QW55fSB2YWx1ZSAtIFRoZSB2YWx1ZSBvZiB0aGlzIG5vZGUuIFVzdWFsbHkgYSBKUyBwcmltaXRpdmUgb3IgdGhyZWUuanMgb2JqZWN0ICh2ZWN0b3IsIG1hdHJpeCwgY29sb3IsIHRleHR1cmUpLlxyXG5cdCAqIEBwYXJhbSB7U3RyaW5nP30gbm9kZVR5cGUgLSBUaGUgbm9kZSB0eXBlLiBJZiBubyBleHBsaWNpdCB0eXBlIGlzIGRlZmluZWQsIHRoZSBub2RlIHRyaWVzIHRvIGRlcml2ZSB0aGUgdHlwZSBmcm9tIGl0cyB2YWx1ZS5cclxuXHQgKi9cclxuXHRjb25zdHJ1Y3RvciggdmFsdWUsIG5vZGVUeXBlID0gbnVsbCApIHtcclxuXHJcblx0XHRzdXBlciggdmFsdWUsIG5vZGVUeXBlICk7XHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBUaGlzIGZsYWcgY2FuIGJlIHVzZWQgZm9yIHR5cGUgdGVzdGluZy5cclxuXHRcdCAqXHJcblx0XHQgKiBAdHlwZSB7Qm9vbGVhbn1cclxuXHRcdCAqIEByZWFkb25seVxyXG5cdFx0ICogQGRlZmF1bHQgdHJ1ZVxyXG5cdFx0ICovXHJcblx0XHR0aGlzLmlzVW5pZm9ybU5vZGUgPSB0cnVlO1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogVGhlIG5hbWUgb3IgbGFiZWwgb2YgdGhlIHVuaWZvcm0uXHJcblx0XHQgKlxyXG5cdFx0ICogQHR5cGUge1N0cmluZ31cclxuXHRcdCAqIEBkZWZhdWx0ICcnXHJcblx0XHQgKi9cclxuXHRcdHRoaXMubmFtZSA9ICcnO1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogVGhlIHVuaWZvcm0gZ3JvdXAgb2YgdGhpcyB1bmlmb3JtLiBCeSBkZWZhdWx0LCB1bmlmb3JtcyBhcmVcclxuXHRcdCAqIG1hbmFnZWQgcGVyIG9iamVjdCBidXQgdGhleSBtaWdodCBiZWxvbmcgdG8gYSBzaGFyZWQgZ3JvdXBcclxuXHRcdCAqIHdoaWNoIGlzIHVwZGF0ZWQgcGVyIGZyYW1lIG9yIHJlbmRlciBjYWxsLlxyXG5cdFx0ICpcclxuXHRcdCAqIEB0eXBlIHtVbmlmb3JtR3JvdXBOb2RlfVxyXG5cdFx0ICovXHJcblx0XHR0aGlzLmdyb3VwTm9kZSA9IG9iamVjdEdyb3VwO1xyXG5cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFNldHMgdGhlIHtAbGluayBVbmlmb3JtTm9kZSNuYW1lfSBwcm9wZXJ0eS5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIC0gVGhlIG5hbWUgb2YgdGhlIHVuaWZvcm0uXHJcblx0ICogQHJldHVybiB7VW5pZm9ybU5vZGV9IEEgcmVmZXJlbmNlIHRvIHRoaXMgbm9kZS5cclxuXHQgKi9cclxuXHRsYWJlbCggbmFtZSApIHtcclxuXHJcblx0XHR0aGlzLm5hbWUgPSBuYW1lO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFNldHMgdGhlIHtAbGluayBVbmlmb3JtTm9kZSNncm91cE5vZGV9IHByb3BlcnR5LlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtVbmlmb3JtR3JvdXBOb2RlfSBncm91cCAtIFRoZSB1bmlmb3JtIGdyb3VwLlxyXG5cdCAqIEByZXR1cm4ge1VuaWZvcm1Ob2RlfSBBIHJlZmVyZW5jZSB0byB0aGlzIG5vZGUuXHJcblx0ICovXHJcblx0c2V0R3JvdXAoIGdyb3VwICkge1xyXG5cclxuXHRcdHRoaXMuZ3JvdXBOb2RlID0gZ3JvdXA7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogUmV0dXJucyB0aGUge0BsaW5rIFVuaWZvcm1Ob2RlI2dyb3VwTm9kZX0uXHJcblx0ICpcclxuXHQgKiBAcmV0dXJuIHtVbmlmb3JtR3JvdXBOb2RlfSBUaGUgdW5pZm9ybSBncm91cC5cclxuXHQgKi9cclxuXHRnZXRHcm91cCgpIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5ncm91cE5vZGU7XHJcblxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogQnkgZGVmYXVsdCwgdGhpcyBtZXRob2QgcmV0dXJucyB0aGUgcmVzdWx0IG9mIHtAbGluayBOb2RlI2dldEhhc2h9IGJ1dCBkZXJpdmVkXHJcblx0ICogY2xhc3NlcyBtaWdodCBvdmVyd3JpdGUgdGhpcyBtZXRob2Qgd2l0aCBhIGRpZmZlcmVudCBpbXBsZW1lbnRhdGlvbi5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7Tm9kZUJ1aWxkZXJ9IGJ1aWxkZXIgLSBUaGUgY3VycmVudCBub2RlIGJ1aWxkZXIuXHJcblx0ICogQHJldHVybiB7U3RyaW5nfSBUaGUgdW5pZm9ybSBoYXNoLlxyXG5cdCAqL1xyXG5cdGdldFVuaWZvcm1IYXNoKCBidWlsZGVyICkge1xyXG5cclxuXHRcdHJldHVybiB0aGlzLmdldEhhc2goIGJ1aWxkZXIgKTtcclxuXHJcblx0fVxyXG5cclxuXHRvblVwZGF0ZSggY2FsbGJhY2ssIHVwZGF0ZVR5cGUgKSB7XHJcblxyXG5cdFx0Y29uc3Qgc2VsZiA9IHRoaXMuZ2V0U2VsZigpO1xyXG5cclxuXHRcdGNhbGxiYWNrID0gY2FsbGJhY2suYmluZCggc2VsZiApO1xyXG5cclxuXHRcdHJldHVybiBzdXBlci5vblVwZGF0ZSggKCBmcmFtZSApID0+IHtcclxuXHJcblx0XHRcdGNvbnN0IHZhbHVlID0gY2FsbGJhY2soIGZyYW1lLCBzZWxmICk7XHJcblxyXG5cdFx0XHRpZiAoIHZhbHVlICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdHRoaXMudmFsdWUgPSB2YWx1ZTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0IFx0fSwgdXBkYXRlVHlwZSApO1xyXG5cclxuXHR9XHJcblxyXG5cdGdlbmVyYXRlKCBidWlsZGVyLCBvdXRwdXQgKSB7XHJcblxyXG5cdFx0Y29uc3QgdHlwZSA9IHRoaXMuZ2V0Tm9kZVR5cGUoIGJ1aWxkZXIgKTtcclxuXHJcblx0XHRjb25zdCBoYXNoID0gdGhpcy5nZXRVbmlmb3JtSGFzaCggYnVpbGRlciApO1xyXG5cclxuXHRcdGxldCBzaGFyZWROb2RlID0gYnVpbGRlci5nZXROb2RlRnJvbUhhc2goIGhhc2ggKTtcclxuXHJcblx0XHRpZiAoIHNoYXJlZE5vZGUgPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdGJ1aWxkZXIuc2V0SGFzaE5vZGUoIHRoaXMsIGhhc2ggKTtcclxuXHJcblx0XHRcdHNoYXJlZE5vZGUgPSB0aGlzO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRjb25zdCBzaGFyZWROb2RlVHlwZSA9IHNoYXJlZE5vZGUuZ2V0SW5wdXRUeXBlKCBidWlsZGVyICk7XHJcblxyXG5cdFx0Y29uc3Qgbm9kZVVuaWZvcm0gPSBidWlsZGVyLmdldFVuaWZvcm1Gcm9tTm9kZSggc2hhcmVkTm9kZSwgc2hhcmVkTm9kZVR5cGUsIGJ1aWxkZXIuc2hhZGVyU3RhZ2UsIHRoaXMubmFtZSB8fCBidWlsZGVyLmNvbnRleHQubGFiZWwgKTtcclxuXHRcdGNvbnN0IHByb3BlcnR5TmFtZSA9IGJ1aWxkZXIuZ2V0UHJvcGVydHlOYW1lKCBub2RlVW5pZm9ybSApO1xyXG5cclxuXHRcdGlmICggYnVpbGRlci5jb250ZXh0LmxhYmVsICE9PSB1bmRlZmluZWQgKSBkZWxldGUgYnVpbGRlci5jb250ZXh0LmxhYmVsO1xyXG5cclxuXHRcdHJldHVybiBidWlsZGVyLmZvcm1hdCggcHJvcGVydHlOYW1lLCB0eXBlLCBvdXRwdXQgKTtcclxuXHJcblx0fVxyXG5cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgVW5pZm9ybU5vZGU7XHJcblxyXG4vKipcclxuICogVFNMIGZ1bmN0aW9uIGZvciBjcmVhdGluZyBhIHVuaWZvcm0gbm9kZS5cclxuICpcclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7QW55fSBhcmcxIC0gVGhlIHZhbHVlIG9mIHRoaXMgbm9kZS4gVXN1YWxseSBhIEpTIHByaW1pdGl2ZSBvciB0aHJlZS5qcyBvYmplY3QgKHZlY3RvciwgbWF0cml4LCBjb2xvciwgdGV4dHVyZSkuXHJcbiAqIEBwYXJhbSB7U3RyaW5nP30gYXJnMiAtIFRoZSBub2RlIHR5cGUuIElmIG5vIGV4cGxpY2l0IHR5cGUgaXMgZGVmaW5lZCwgdGhlIG5vZGUgdHJpZXMgdG8gZGVyaXZlIHRoZSB0eXBlIGZyb20gaXRzIHZhbHVlLlxyXG4gKiBAcmV0dXJucyB7VW5pZm9ybU5vZGV9XHJcbiAqL1xyXG5leHBvcnQgY29uc3QgdW5pZm9ybSA9ICggYXJnMSwgYXJnMiApID0+IHtcclxuXHJcblx0Y29uc3Qgbm9kZVR5cGUgPSBnZXRDb25zdE5vZGVUeXBlKCBhcmcyIHx8IGFyZzEgKTtcclxuXHJcblx0Ly8gQFRPRE86IGdldCBDb25zdE5vZGUgZnJvbSAudHJhdmVyc2UoKSBpbiB0aGUgZnV0dXJlXHJcblx0Y29uc3QgdmFsdWUgPSAoIGFyZzEgJiYgYXJnMS5pc05vZGUgPT09IHRydWUgKSA/ICggYXJnMS5ub2RlICYmIGFyZzEubm9kZS52YWx1ZSApIHx8IGFyZzEudmFsdWUgOiBhcmcxO1xyXG5cclxuXHRyZXR1cm4gbm9kZU9iamVjdCggbmV3IFVuaWZvcm1Ob2RlKCB2YWx1ZSwgbm9kZVR5cGUgKSApO1xyXG5cclxufTtcclxuIiwiaW1wb3J0IE5vZGUgZnJvbSAnLi9Ob2RlLmpzJztcclxuaW1wb3J0IHsgbm9kZUltbXV0YWJsZSwgbm9kZU9iamVjdCB9IGZyb20gJy4uL3RzbC9UU0xDb3JlLmpzJztcclxuXHJcbi8qKlxyXG4gKiBUaGlzIGNsYXNzIHJlcHJlc2VudHMgYSBzaGFkZXIgcHJvcGVydHkuIEl0IGNhbiBiZSB1c2VkIG9uXHJcbiAqIHRvIGV4cGxpY2l0bHkgZGVmaW5lIGEgcHJvcGVydHkgYW5kIGFzc2lnbiBhIHZhbHVlIHRvIGl0LlxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiBjb25zdCB0aHJlc2hvbGQgPSBwcm9wZXJ0eSggJ2Zsb2F0JywgJ3RocmVzaG9sZCcgKS5hc3NpZ24oIFRIUkVTSE9MRCApO1xyXG4gKmBgYFxyXG4gKiBgUHJvcGVydHlOb2RlYCBpcyB1c2VkIGJ5IHRoZSBlbmdpbmUgdG8gcHJlZGVmaW5lZCBjb21tb24gbWF0ZXJpYWwgcHJvcGVydGllc1xyXG4gKiBmb3IgVFNMIGNvZGUuXHJcbiAqXHJcbiAqIEBhdWdtZW50cyBOb2RlXHJcbiAqL1xyXG5jbGFzcyBQcm9wZXJ0eU5vZGUgZXh0ZW5kcyBOb2RlIHtcclxuXHJcblx0c3RhdGljIGdldCB0eXBlKCkge1xyXG5cclxuXHRcdHJldHVybiAnUHJvcGVydHlOb2RlJztcclxuXHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBDb25zdHJ1Y3RzIGEgbmV3IHByb3BlcnR5IG5vZGUuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge1N0cmluZ30gbm9kZVR5cGUgLSBUaGUgdHlwZSBvZiB0aGUgbm9kZS5cclxuXHQgKiBAcGFyYW0ge1N0cmluZz99IFtuYW1lPW51bGxdIC0gVGhlIG5hbWUgb2YgdGhlIHByb3BlcnR5IGluIHRoZSBzaGFkZXIuXHJcblx0ICogQHBhcmFtIHtCb29sZWFufSBbdmFyeWluZz1mYWxzZV0gLSBXaGV0aGVyIHRoaXMgcHJvcGVydHkgaXMgYSB2YXJ5aW5nIG9yIG5vdC5cclxuXHQgKi9cclxuXHRjb25zdHJ1Y3Rvciggbm9kZVR5cGUsIG5hbWUgPSBudWxsLCB2YXJ5aW5nID0gZmFsc2UgKSB7XHJcblxyXG5cdFx0c3VwZXIoIG5vZGVUeXBlICk7XHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBUaGUgbmFtZSBvZiB0aGUgcHJvcGVydHkgaW4gdGhlIHNoYWRlci4gSWYgbm8gbmFtZSBpcyBkZWZpbmVkLFxyXG5cdFx0ICogdGhlIG5vZGUgc3lzdGVtIGF1dG8tZ2VuZXJhdGVzIG9uZS5cclxuXHRcdCAqXHJcblx0XHQgKiBAdHlwZSB7U3RyaW5nP31cclxuXHRcdCAqIEBkZWZhdWx0IG51bGxcclxuXHRcdCAqL1xyXG5cdFx0dGhpcy5uYW1lID0gbmFtZTtcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIFdoZXRoZXIgdGhpcyBwcm9wZXJ0eSBpcyBhIHZhcnlpbmcgb3Igbm90LlxyXG5cdFx0ICpcclxuXHRcdCAqIEB0eXBlIHtCb29sZWFufVxyXG5cdFx0ICogQGRlZmF1bHQgZmFsc2VcclxuXHRcdCAqL1xyXG5cdFx0dGhpcy52YXJ5aW5nID0gdmFyeWluZztcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIFRoaXMgZmxhZyBjYW4gYmUgdXNlZCBmb3IgdHlwZSB0ZXN0aW5nLlxyXG5cdFx0ICpcclxuXHRcdCAqIEB0eXBlIHtCb29sZWFufVxyXG5cdFx0ICogQHJlYWRvbmx5XHJcblx0XHQgKiBAZGVmYXVsdCB0cnVlXHJcblx0XHQgKi9cclxuXHRcdHRoaXMuaXNQcm9wZXJ0eU5vZGUgPSB0cnVlO1xyXG5cclxuXHR9XHJcblxyXG5cdGdldEhhc2goIGJ1aWxkZXIgKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMubmFtZSB8fCBzdXBlci5nZXRIYXNoKCBidWlsZGVyICk7XHJcblxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogVGhlIG1ldGhvZCBpcyBvdmVyd3JpdHRlbiBzbyBpdCBhbHdheXMgcmV0dXJucyBgdHJ1ZWAuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge05vZGVCdWlsZGVyfSBidWlsZGVyIC0gVGhlIGN1cnJlbnQgbm9kZSBidWlsZGVyLlxyXG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59IFdoZXRoZXIgdGhpcyBub2RlIGlzIGdsb2JhbCBvciBub3QuXHJcblx0ICovXHJcblx0aXNHbG9iYWwoIC8qYnVpbGRlciovICkge1xyXG5cclxuXHRcdHJldHVybiB0cnVlO1xyXG5cclxuXHR9XHJcblxyXG5cdGdlbmVyYXRlKCBidWlsZGVyICkge1xyXG5cclxuXHRcdGxldCBub2RlVmFyO1xyXG5cclxuXHRcdGlmICggdGhpcy52YXJ5aW5nID09PSB0cnVlICkge1xyXG5cclxuXHRcdFx0bm9kZVZhciA9IGJ1aWxkZXIuZ2V0VmFyeWluZ0Zyb21Ob2RlKCB0aGlzLCB0aGlzLm5hbWUgKTtcclxuXHRcdFx0bm9kZVZhci5uZWVkc0ludGVycG9sYXRpb24gPSB0cnVlO1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRub2RlVmFyID0gYnVpbGRlci5nZXRWYXJGcm9tTm9kZSggdGhpcywgdGhpcy5uYW1lICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBidWlsZGVyLmdldFByb3BlcnR5TmFtZSggbm9kZVZhciApO1xyXG5cclxuXHR9XHJcblxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBQcm9wZXJ0eU5vZGU7XHJcblxyXG5leHBvcnQgY29uc3QgcHJvcGVydHkgPSAoIHR5cGUsIG5hbWUgKSA9PiBub2RlT2JqZWN0KCBuZXcgUHJvcGVydHlOb2RlKCB0eXBlLCBuYW1lICkgKTtcclxuZXhwb3J0IGNvbnN0IHZhcnlpbmdQcm9wZXJ0eSA9ICggdHlwZSwgbmFtZSApID0+IG5vZGVPYmplY3QoIG5ldyBQcm9wZXJ0eU5vZGUoIHR5cGUsIG5hbWUsIHRydWUgKSApO1xyXG5cclxuZXhwb3J0IGNvbnN0IGRpZmZ1c2VDb2xvciA9IC8qQF9fUFVSRV9fKi8gbm9kZUltbXV0YWJsZSggUHJvcGVydHlOb2RlLCAndmVjNCcsICdEaWZmdXNlQ29sb3InICk7XHJcbmV4cG9ydCBjb25zdCBlbWlzc2l2ZSA9IC8qQF9fUFVSRV9fKi8gbm9kZUltbXV0YWJsZSggUHJvcGVydHlOb2RlLCAndmVjMycsICdFbWlzc2l2ZUNvbG9yJyApO1xyXG5leHBvcnQgY29uc3Qgcm91Z2huZXNzID0gLypAX19QVVJFX18qLyBub2RlSW1tdXRhYmxlKCBQcm9wZXJ0eU5vZGUsICdmbG9hdCcsICdSb3VnaG5lc3MnICk7XHJcbmV4cG9ydCBjb25zdCBtZXRhbG5lc3MgPSAvKkBfX1BVUkVfXyovIG5vZGVJbW11dGFibGUoIFByb3BlcnR5Tm9kZSwgJ2Zsb2F0JywgJ01ldGFsbmVzcycgKTtcclxuZXhwb3J0IGNvbnN0IGNsZWFyY29hdCA9IC8qQF9fUFVSRV9fKi8gbm9kZUltbXV0YWJsZSggUHJvcGVydHlOb2RlLCAnZmxvYXQnLCAnQ2xlYXJjb2F0JyApO1xyXG5leHBvcnQgY29uc3QgY2xlYXJjb2F0Um91Z2huZXNzID0gLypAX19QVVJFX18qLyBub2RlSW1tdXRhYmxlKCBQcm9wZXJ0eU5vZGUsICdmbG9hdCcsICdDbGVhcmNvYXRSb3VnaG5lc3MnICk7XHJcbmV4cG9ydCBjb25zdCBzaGVlbiA9IC8qQF9fUFVSRV9fKi8gbm9kZUltbXV0YWJsZSggUHJvcGVydHlOb2RlLCAndmVjMycsICdTaGVlbicgKTtcclxuZXhwb3J0IGNvbnN0IHNoZWVuUm91Z2huZXNzID0gLypAX19QVVJFX18qLyBub2RlSW1tdXRhYmxlKCBQcm9wZXJ0eU5vZGUsICdmbG9hdCcsICdTaGVlblJvdWdobmVzcycgKTtcclxuZXhwb3J0IGNvbnN0IGlyaWRlc2NlbmNlID0gLypAX19QVVJFX18qLyBub2RlSW1tdXRhYmxlKCBQcm9wZXJ0eU5vZGUsICdmbG9hdCcsICdJcmlkZXNjZW5jZScgKTtcclxuZXhwb3J0IGNvbnN0IGlyaWRlc2NlbmNlSU9SID0gLypAX19QVVJFX18qLyBub2RlSW1tdXRhYmxlKCBQcm9wZXJ0eU5vZGUsICdmbG9hdCcsICdJcmlkZXNjZW5jZUlPUicgKTtcclxuZXhwb3J0IGNvbnN0IGlyaWRlc2NlbmNlVGhpY2tuZXNzID0gLypAX19QVVJFX18qLyBub2RlSW1tdXRhYmxlKCBQcm9wZXJ0eU5vZGUsICdmbG9hdCcsICdJcmlkZXNjZW5jZVRoaWNrbmVzcycgKTtcclxuZXhwb3J0IGNvbnN0IGFscGhhVCA9IC8qQF9fUFVSRV9fKi8gbm9kZUltbXV0YWJsZSggUHJvcGVydHlOb2RlLCAnZmxvYXQnLCAnQWxwaGFUJyApO1xyXG5leHBvcnQgY29uc3QgYW5pc290cm9weSA9IC8qQF9fUFVSRV9fKi8gbm9kZUltbXV0YWJsZSggUHJvcGVydHlOb2RlLCAnZmxvYXQnLCAnQW5pc290cm9weScgKTtcclxuZXhwb3J0IGNvbnN0IGFuaXNvdHJvcHlUID0gLypAX19QVVJFX18qLyBub2RlSW1tdXRhYmxlKCBQcm9wZXJ0eU5vZGUsICd2ZWMzJywgJ0FuaXNvdHJvcHlUJyApO1xyXG5leHBvcnQgY29uc3QgYW5pc290cm9weUIgPSAvKkBfX1BVUkVfXyovIG5vZGVJbW11dGFibGUoIFByb3BlcnR5Tm9kZSwgJ3ZlYzMnLCAnQW5pc290cm9weUInICk7XHJcbmV4cG9ydCBjb25zdCBzcGVjdWxhckNvbG9yID0gLypAX19QVVJFX18qLyBub2RlSW1tdXRhYmxlKCBQcm9wZXJ0eU5vZGUsICdjb2xvcicsICdTcGVjdWxhckNvbG9yJyApO1xyXG5leHBvcnQgY29uc3Qgc3BlY3VsYXJGOTAgPSAvKkBfX1BVUkVfXyovIG5vZGVJbW11dGFibGUoIFByb3BlcnR5Tm9kZSwgJ2Zsb2F0JywgJ1NwZWN1bGFyRjkwJyApO1xyXG5leHBvcnQgY29uc3Qgc2hpbmluZXNzID0gLypAX19QVVJFX18qLyBub2RlSW1tdXRhYmxlKCBQcm9wZXJ0eU5vZGUsICdmbG9hdCcsICdTaGluaW5lc3MnICk7XHJcbmV4cG9ydCBjb25zdCBvdXRwdXQgPSAvKkBfX1BVUkVfXyovIG5vZGVJbW11dGFibGUoIFByb3BlcnR5Tm9kZSwgJ3ZlYzQnLCAnT3V0cHV0JyApO1xyXG5leHBvcnQgY29uc3QgZGFzaFNpemUgPSAvKkBfX1BVUkVfXyovIG5vZGVJbW11dGFibGUoIFByb3BlcnR5Tm9kZSwgJ2Zsb2F0JywgJ2Rhc2hTaXplJyApO1xyXG5leHBvcnQgY29uc3QgZ2FwU2l6ZSA9IC8qQF9fUFVSRV9fKi8gbm9kZUltbXV0YWJsZSggUHJvcGVydHlOb2RlLCAnZmxvYXQnLCAnZ2FwU2l6ZScgKTtcclxuZXhwb3J0IGNvbnN0IHBvaW50V2lkdGggPSAvKkBfX1BVUkVfXyovIG5vZGVJbW11dGFibGUoIFByb3BlcnR5Tm9kZSwgJ2Zsb2F0JywgJ3BvaW50V2lkdGgnICk7XHJcbmV4cG9ydCBjb25zdCBpb3IgPSAvKkBfX1BVUkVfXyovIG5vZGVJbW11dGFibGUoIFByb3BlcnR5Tm9kZSwgJ2Zsb2F0JywgJ0lPUicgKTtcclxuZXhwb3J0IGNvbnN0IHRyYW5zbWlzc2lvbiA9IC8qQF9fUFVSRV9fKi8gbm9kZUltbXV0YWJsZSggUHJvcGVydHlOb2RlLCAnZmxvYXQnLCAnVHJhbnNtaXNzaW9uJyApO1xyXG5leHBvcnQgY29uc3QgdGhpY2tuZXNzID0gLypAX19QVVJFX18qLyBub2RlSW1tdXRhYmxlKCBQcm9wZXJ0eU5vZGUsICdmbG9hdCcsICdUaGlja25lc3MnICk7XHJcbmV4cG9ydCBjb25zdCBhdHRlbnVhdGlvbkRpc3RhbmNlID0gLypAX19QVVJFX18qLyBub2RlSW1tdXRhYmxlKCBQcm9wZXJ0eU5vZGUsICdmbG9hdCcsICdBdHRlbnVhdGlvbkRpc3RhbmNlJyApO1xyXG5leHBvcnQgY29uc3QgYXR0ZW51YXRpb25Db2xvciA9IC8qQF9fUFVSRV9fKi8gbm9kZUltbXV0YWJsZSggUHJvcGVydHlOb2RlLCAnY29sb3InLCAnQXR0ZW51YXRpb25Db2xvcicgKTtcclxuZXhwb3J0IGNvbnN0IGRpc3BlcnNpb24gPSAvKkBfX1BVUkVfXyovIG5vZGVJbW11dGFibGUoIFByb3BlcnR5Tm9kZSwgJ2Zsb2F0JywgJ0Rpc3BlcnNpb24nICk7XHJcbiIsImltcG9ydCBUZW1wTm9kZSBmcm9tICcuLi9jb3JlL1RlbXBOb2RlLmpzJztcclxuaW1wb3J0IHsgYWRkTWV0aG9kQ2hhaW5pbmcsIG5vZGVQcm94eSB9IGZyb20gJy4uL3RzbC9UU0xDb3JlLmpzJztcclxuaW1wb3J0IHsgdmVjdG9yQ29tcG9uZW50cyB9IGZyb20gJy4uL2NvcmUvY29uc3RhbnRzLmpzJztcclxuXHJcbi8qKiBAbW9kdWxlIEFzc2lnbk5vZGUgKiovXHJcblxyXG4vKipcclxuICogVGhlc2Ugbm9kZSByZXByZXNlbnRzIGFuIGFzc2lnbiBvcGVyYXRpb24uIE1lYW5pbmcgYSBub2RlIGlzIGFzc2lnbmVkXHJcbiAqIHRvIGFub3RoZXIgbm9kZS5cclxuICpcclxuICogQGF1Z21lbnRzIFRlbXBOb2RlXHJcbiAqL1xyXG5jbGFzcyBBc3NpZ25Ob2RlIGV4dGVuZHMgVGVtcE5vZGUge1xyXG5cclxuXHRzdGF0aWMgZ2V0IHR5cGUoKSB7XHJcblxyXG5cdFx0cmV0dXJuICdBc3NpZ25Ob2RlJztcclxuXHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBDb25zdHJ1Y3RzIGEgbmV3IGFzc2lnbiBub2RlLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtOb2RlfSB0YXJnZXROb2RlIC0gVGhlIHRhcmdldCBub2RlLlxyXG5cdCAqIEBwYXJhbSB7Tm9kZX0gc291cmNlTm9kZSAtIFRoZSBzb3VyY2UgdHlwZS5cclxuXHQgKi9cclxuXHRjb25zdHJ1Y3RvciggdGFyZ2V0Tm9kZSwgc291cmNlTm9kZSApIHtcclxuXHJcblx0XHRzdXBlcigpO1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogVGhlIHRhcmdldCBub2RlLlxyXG5cdFx0ICpcclxuXHRcdCAqIEB0eXBlIHtOb2RlfVxyXG5cdFx0ICovXHJcblx0XHR0aGlzLnRhcmdldE5vZGUgPSB0YXJnZXROb2RlO1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogVGhlIHNvdXJjZSBub2RlLlxyXG5cdFx0ICpcclxuXHRcdCAqIEB0eXBlIHtOb2RlfVxyXG5cdFx0ICovXHJcblx0XHR0aGlzLnNvdXJjZU5vZGUgPSBzb3VyY2VOb2RlO1xyXG5cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFdoZXRoZXIgdGhpcyBub2RlIGlzIHVzZWQgbW9yZSB0aGFuIG9uY2UgaW4gY29udGV4dCBvZiBvdGhlciBub2Rlcy4gVGhpcyBtZXRob2RcclxuXHQgKiBpcyBvdmVyd3JpdHRlbiBzaW5jZSBpdCBhbHdheXMgcmV0dXJucyBgZmFsc2VgIChhc3NpZ25zIGFyZSB1bmlxdWUpLlxyXG5cdCAqXHJcblx0ICogQHJldHVybiB7Qm9vbGVhbn0gQSBmbGFnIHRoYXQgaW5kaWNhdGVzIGlmIHRoZXJlIGlzIG1vcmUgdGhhbiBvbmUgZGVwZW5kZW5jeSB0byBvdGhlciBub2Rlcy4gQWx3YXlzIGBmYWxzZWAuXHJcblx0ICovXHJcblx0aGFzRGVwZW5kZW5jaWVzKCkge1xyXG5cclxuXHRcdHJldHVybiBmYWxzZTtcclxuXHJcblx0fVxyXG5cclxuXHRnZXROb2RlVHlwZSggYnVpbGRlciwgb3V0cHV0ICkge1xyXG5cclxuXHRcdHJldHVybiBvdXRwdXQgIT09ICd2b2lkJyA/IHRoaXMudGFyZ2V0Tm9kZS5nZXROb2RlVHlwZSggYnVpbGRlciApIDogJ3ZvaWQnO1xyXG5cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFdoZXRoZXIgYSBzcGxpdCBpcyByZXF1aXJlZCB3aGVuIGFzc2lnbmluZyBzb3VyY2UgdG8gdGFyZ2V0LiBUaGlzIGNhbiBoYXBwZW4gd2hlbiB0aGUgY29tcG9uZW50IGxlbmd0aCBvZlxyXG5cdCAqIHRhcmdldCBhbmQgc291cmNlIGRhdGEgdHlwZSBkb2VzIG5vdCBtYXRjaC5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7Tm9kZUJ1aWxkZXJ9IGJ1aWxkZXIgLSBUaGUgY3VycmVudCBub2RlIGJ1aWxkZXIuXHJcblx0ICogQHJldHVybiB7Qm9vbGVhbn0gV2hldGhlciBhIHNwbGl0IGlzIHJlcXVpcmVkIHdoZW4gYXNzaWduaW5nIHNvdXJjZSB0byB0YXJnZXQuXHJcblx0ICovXHJcblx0bmVlZHNTcGxpdEFzc2lnbiggYnVpbGRlciApIHtcclxuXHJcblx0XHRjb25zdCB7IHRhcmdldE5vZGUgfSA9IHRoaXM7XHJcblxyXG5cdFx0aWYgKCBidWlsZGVyLmlzQXZhaWxhYmxlKCAnc3dpenpsZUFzc2lnbicgKSA9PT0gZmFsc2UgJiYgdGFyZ2V0Tm9kZS5pc1NwbGl0Tm9kZSAmJiB0YXJnZXROb2RlLmNvbXBvbmVudHMubGVuZ3RoID4gMSApIHtcclxuXHJcblx0XHRcdGNvbnN0IHRhcmdldExlbmd0aCA9IGJ1aWxkZXIuZ2V0VHlwZUxlbmd0aCggdGFyZ2V0Tm9kZS5ub2RlLmdldE5vZGVUeXBlKCBidWlsZGVyICkgKTtcclxuXHRcdFx0Y29uc3QgYXNzaWduRGlmZmVyZW50VmVjdG9yID0gdmVjdG9yQ29tcG9uZW50cy5qb2luKCAnJyApLnNsaWNlKCAwLCB0YXJnZXRMZW5ndGggKSAhPT0gdGFyZ2V0Tm9kZS5jb21wb25lbnRzO1xyXG5cclxuXHRcdFx0cmV0dXJuIGFzc2lnbkRpZmZlcmVudFZlY3RvcjtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGZhbHNlO1xyXG5cclxuXHR9XHJcblxyXG5cdGdlbmVyYXRlKCBidWlsZGVyLCBvdXRwdXQgKSB7XHJcblxyXG5cdFx0Y29uc3QgeyB0YXJnZXROb2RlLCBzb3VyY2VOb2RlIH0gPSB0aGlzO1xyXG5cclxuXHRcdGNvbnN0IG5lZWRzU3BsaXRBc3NpZ24gPSB0aGlzLm5lZWRzU3BsaXRBc3NpZ24oIGJ1aWxkZXIgKTtcclxuXHJcblx0XHRjb25zdCB0YXJnZXRUeXBlID0gdGFyZ2V0Tm9kZS5nZXROb2RlVHlwZSggYnVpbGRlciApO1xyXG5cclxuXHRcdGNvbnN0IHRhcmdldCA9IHRhcmdldE5vZGUuY29udGV4dCggeyBhc3NpZ246IHRydWUgfSApLmJ1aWxkKCBidWlsZGVyICk7XHJcblx0XHRjb25zdCBzb3VyY2UgPSBzb3VyY2VOb2RlLmJ1aWxkKCBidWlsZGVyLCB0YXJnZXRUeXBlICk7XHJcblxyXG5cdFx0Y29uc3Qgc291cmNlVHlwZSA9IHNvdXJjZU5vZGUuZ2V0Tm9kZVR5cGUoIGJ1aWxkZXIgKTtcclxuXHJcblx0XHRjb25zdCBub2RlRGF0YSA9IGJ1aWxkZXIuZ2V0RGF0YUZyb21Ob2RlKCB0aGlzICk7XHJcblxyXG5cdFx0Ly9cclxuXHJcblx0XHRsZXQgc25pcHBldDtcclxuXHJcblx0XHRpZiAoIG5vZGVEYXRhLmluaXRpYWxpemVkID09PSB0cnVlICkge1xyXG5cclxuXHRcdFx0aWYgKCBvdXRwdXQgIT09ICd2b2lkJyApIHtcclxuXHJcblx0XHRcdFx0c25pcHBldCA9IHRhcmdldDtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9IGVsc2UgaWYgKCBuZWVkc1NwbGl0QXNzaWduICkge1xyXG5cclxuXHRcdFx0Y29uc3Qgc291cmNlVmFyID0gYnVpbGRlci5nZXRWYXJGcm9tTm9kZSggdGhpcywgbnVsbCwgdGFyZ2V0VHlwZSApO1xyXG5cdFx0XHRjb25zdCBzb3VyY2VQcm9wZXJ0eSA9IGJ1aWxkZXIuZ2V0UHJvcGVydHlOYW1lKCBzb3VyY2VWYXIgKTtcclxuXHJcblx0XHRcdGJ1aWxkZXIuYWRkTGluZUZsb3dDb2RlKCBgJHsgc291cmNlUHJvcGVydHkgfSA9ICR7IHNvdXJjZSB9YCwgdGhpcyApO1xyXG5cclxuXHRcdFx0Y29uc3QgdGFyZ2V0Um9vdCA9IHRhcmdldE5vZGUubm9kZS5jb250ZXh0KCB7IGFzc2lnbjogdHJ1ZSB9ICkuYnVpbGQoIGJ1aWxkZXIgKTtcclxuXHJcblx0XHRcdGZvciAoIGxldCBpID0gMDsgaSA8IHRhcmdldE5vZGUuY29tcG9uZW50cy5sZW5ndGg7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdGNvbnN0IGNvbXBvbmVudCA9IHRhcmdldE5vZGUuY29tcG9uZW50c1sgaSBdO1xyXG5cclxuXHRcdFx0XHRidWlsZGVyLmFkZExpbmVGbG93Q29kZSggYCR7IHRhcmdldFJvb3QgfS4keyBjb21wb25lbnQgfSA9ICR7IHNvdXJjZVByb3BlcnR5IH1bICR7IGkgfSBdYCwgdGhpcyApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKCBvdXRwdXQgIT09ICd2b2lkJyApIHtcclxuXHJcblx0XHRcdFx0c25pcHBldCA9IHRhcmdldDtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0c25pcHBldCA9IGAkeyB0YXJnZXQgfSA9ICR7IHNvdXJjZSB9YDtcclxuXHJcblx0XHRcdGlmICggb3V0cHV0ID09PSAndm9pZCcgfHwgc291cmNlVHlwZSA9PT0gJ3ZvaWQnICkge1xyXG5cclxuXHRcdFx0XHRidWlsZGVyLmFkZExpbmVGbG93Q29kZSggc25pcHBldCwgdGhpcyApO1xyXG5cclxuXHRcdFx0XHRpZiAoIG91dHB1dCAhPT0gJ3ZvaWQnICkge1xyXG5cclxuXHRcdFx0XHRcdHNuaXBwZXQgPSB0YXJnZXQ7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0bm9kZURhdGEuaW5pdGlhbGl6ZWQgPSB0cnVlO1xyXG5cclxuXHRcdHJldHVybiBidWlsZGVyLmZvcm1hdCggc25pcHBldCwgdGFyZ2V0VHlwZSwgb3V0cHV0ICk7XHJcblxyXG5cdH1cclxuXHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IEFzc2lnbk5vZGU7XHJcblxyXG4vKipcclxuICogVFNMIGZ1bmN0aW9uIGZvciBjcmVhdGluZyBhbiBhc3NpZ24gbm9kZS5cclxuICpcclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7Tm9kZX0gdGFyZ2V0Tm9kZSAtIFRoZSB0YXJnZXQgbm9kZS5cclxuICogQHBhcmFtIHtOb2RlfSBzb3VyY2VOb2RlIC0gVGhlIHNvdXJjZSB0eXBlLlxyXG4gKiBAcmV0dXJucyB7QXNzaWduTm9kZX1cclxuICovXHJcbmV4cG9ydCBjb25zdCBhc3NpZ24gPSAvKkBfX1BVUkVfXyovIG5vZGVQcm94eSggQXNzaWduTm9kZSApO1xyXG5cclxuYWRkTWV0aG9kQ2hhaW5pbmcoICdhc3NpZ24nLCBhc3NpZ24gKTtcclxuIiwiaW1wb3J0IFRlbXBOb2RlIGZyb20gJy4uL2NvcmUvVGVtcE5vZGUuanMnO1xyXG5pbXBvcnQgeyBhZGRNZXRob2RDaGFpbmluZywgbm9kZUFycmF5LCBub2RlT2JqZWN0LCBub2RlT2JqZWN0cyB9IGZyb20gJy4uL3RzbC9UU0xDb3JlLmpzJztcclxuXHJcbi8qKlxyXG4gKiBUaGlzIG1vZHVsZSByZXByZXNlbnRzIHRoZSBjYWxsIG9mIGEge0BsaW5rIEZ1bmN0aW9uTm9kZX0uIERldmVsb3BlcnMgYXJlIHVzdWFsbHkgbm90IGNvbmZyb250ZWRcclxuICogd2l0aCB0aGlzIG1vZHVsZSBzaW5jZSB0aGV5IHVzZSB0aGUgcHJlZGVmaW5lZCBUU0wgc3ludGF4IGB3Z3NsRm5gIGFuZCBgZ2xzbEZuYCB3aGljaCBlbmNhcHN1bGF0ZVxyXG4gKiB0aGlzIGxvZ2ljLlxyXG4gKlxyXG4gKiBAYXVnbWVudHMgVGVtcE5vZGVcclxuICovXHJcbmNsYXNzIEZ1bmN0aW9uQ2FsbE5vZGUgZXh0ZW5kcyBUZW1wTm9kZSB7XHJcblxyXG5cdHN0YXRpYyBnZXQgdHlwZSgpIHtcclxuXHJcblx0XHRyZXR1cm4gJ0Z1bmN0aW9uQ2FsbE5vZGUnO1xyXG5cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIENvbnN0cnVjdHMgYSBuZXcgZnVuY3Rpb24gY2FsbCBub2RlLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtGdW5jdGlvbk5vZGU/fSBmdW5jdGlvbk5vZGUgLSBUaGUgZnVuY3Rpb24gbm9kZS5cclxuXHQgKiBAcGFyYW0ge09iamVjdDxTdHJpbmcsIE5vZGU+fSBbcGFyYW1ldGVycz17fV0gLSBUaGUgcGFyYW1ldGVycyBmb3IgdGhlIGZ1bmN0aW9uIGNhbGwuXHJcblx0ICovXHJcblx0Y29uc3RydWN0b3IoIGZ1bmN0aW9uTm9kZSA9IG51bGwsIHBhcmFtZXRlcnMgPSB7fSApIHtcclxuXHJcblx0XHRzdXBlcigpO1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogVGhlIGZ1bmN0aW9uIG5vZGUuXHJcblx0XHQgKlxyXG5cdFx0ICogQHR5cGUge0Z1bmN0aW9uTm9kZX1cclxuXHRcdCAqIEBkZWZhdWx0IG51bGxcclxuXHRcdCAqL1xyXG5cdFx0dGhpcy5mdW5jdGlvbk5vZGUgPSBmdW5jdGlvbk5vZGU7XHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBUaGUgcGFyYW1ldGVycyBvZiB0aGUgZnVuY3Rpb24gY2FsbC5cclxuXHRcdCAqXHJcblx0XHQgKiBAdHlwZSB7T2JqZWN0PFN0cmluZywgTm9kZT59XHJcblx0XHQgKiBAZGVmYXVsdCB7fVxyXG5cdFx0ICovXHJcblx0XHR0aGlzLnBhcmFtZXRlcnMgPSBwYXJhbWV0ZXJzO1xyXG5cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFNldHMgdGhlIHBhcmFtZXRlcnMgb2YgdGhlIGZ1bmN0aW9uIGNhbGwgbm9kZS5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7T2JqZWN0PFN0cmluZywgTm9kZT59IHBhcmFtZXRlcnMgLSBUaGUgcGFyYW1ldGVycyB0byBzZXQuXHJcblx0ICogQHJldHVybiB7RnVuY3Rpb25DYWxsTm9kZX0gQSByZWZlcmVuY2UgdG8gdGhpcyBub2RlLlxyXG5cdCAqL1xyXG5cdHNldFBhcmFtZXRlcnMoIHBhcmFtZXRlcnMgKSB7XHJcblxyXG5cdFx0dGhpcy5wYXJhbWV0ZXJzID0gcGFyYW1ldGVycztcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBSZXR1cm5zIHRoZSBwYXJhbWV0ZXJzIG9mIHRoZSBmdW5jdGlvbiBjYWxsIG5vZGUuXHJcblx0ICpcclxuXHQgKiBAcmV0dXJuIHtPYmplY3Q8U3RyaW5nLCBOb2RlPn0gVGhlIHBhcmFtZXRlcnMgb2YgdGhpcyBub2RlLlxyXG5cdCAqL1xyXG5cdGdldFBhcmFtZXRlcnMoKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMucGFyYW1ldGVycztcclxuXHJcblx0fVxyXG5cclxuXHRnZXROb2RlVHlwZSggYnVpbGRlciApIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5mdW5jdGlvbk5vZGUuZ2V0Tm9kZVR5cGUoIGJ1aWxkZXIgKTtcclxuXHJcblx0fVxyXG5cclxuXHRnZW5lcmF0ZSggYnVpbGRlciApIHtcclxuXHJcblx0XHRjb25zdCBwYXJhbXMgPSBbXTtcclxuXHJcblx0XHRjb25zdCBmdW5jdGlvbk5vZGUgPSB0aGlzLmZ1bmN0aW9uTm9kZTtcclxuXHJcblx0XHRjb25zdCBpbnB1dHMgPSBmdW5jdGlvbk5vZGUuZ2V0SW5wdXRzKCBidWlsZGVyICk7XHJcblx0XHRjb25zdCBwYXJhbWV0ZXJzID0gdGhpcy5wYXJhbWV0ZXJzO1xyXG5cclxuXHRcdGNvbnN0IGdlbmVyYXRlSW5wdXQgPSAoIG5vZGUsIGlucHV0Tm9kZSApID0+IHtcclxuXHJcblx0XHRcdGNvbnN0IHR5cGUgPSBpbnB1dE5vZGUudHlwZTtcclxuXHRcdFx0Y29uc3QgcG9pbnRlciA9IHR5cGUgPT09ICdwb2ludGVyJztcclxuXHJcblx0XHRcdGxldCBvdXRwdXQ7XHJcblxyXG5cdFx0XHRpZiAoIHBvaW50ZXIgKSBvdXRwdXQgPSAnJicgKyBub2RlLmJ1aWxkKCBidWlsZGVyICk7XHJcblx0XHRcdGVsc2Ugb3V0cHV0ID0gbm9kZS5idWlsZCggYnVpbGRlciwgdHlwZSApO1xyXG5cclxuXHRcdFx0cmV0dXJuIG91dHB1dDtcclxuXHJcblx0XHR9O1xyXG5cclxuXHRcdGlmICggQXJyYXkuaXNBcnJheSggcGFyYW1ldGVycyApICkge1xyXG5cclxuXHRcdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgcGFyYW1ldGVycy5sZW5ndGg7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdHBhcmFtcy5wdXNoKCBnZW5lcmF0ZUlucHV0KCBwYXJhbWV0ZXJzWyBpIF0sIGlucHV0c1sgaSBdICkgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0Zm9yICggY29uc3QgaW5wdXROb2RlIG9mIGlucHV0cyApIHtcclxuXHJcblx0XHRcdFx0Y29uc3Qgbm9kZSA9IHBhcmFtZXRlcnNbIGlucHV0Tm9kZS5uYW1lIF07XHJcblxyXG5cdFx0XHRcdGlmICggbm9kZSAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRcdHBhcmFtcy5wdXNoKCBnZW5lcmF0ZUlucHV0KCBub2RlLCBpbnB1dE5vZGUgKSApO1xyXG5cclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvciggYEZ1bmN0aW9uQ2FsbE5vZGU6IElucHV0ICcke2lucHV0Tm9kZS5uYW1lfScgbm90IGZvdW5kIGluIEZ1bmN0aW9uTm9kZS5gICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Y29uc3QgZnVuY3Rpb25OYW1lID0gZnVuY3Rpb25Ob2RlLmJ1aWxkKCBidWlsZGVyLCAncHJvcGVydHknICk7XHJcblxyXG5cdFx0cmV0dXJuIGAke2Z1bmN0aW9uTmFtZX0oICR7cGFyYW1zLmpvaW4oICcsICcgKX0gKWA7XHJcblxyXG5cdH1cclxuXHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IEZ1bmN0aW9uQ2FsbE5vZGU7XHJcblxyXG5leHBvcnQgY29uc3QgY2FsbCA9ICggZnVuYywgLi4ucGFyYW1zICkgPT4ge1xyXG5cclxuXHRwYXJhbXMgPSBwYXJhbXMubGVuZ3RoID4gMSB8fCAoIHBhcmFtc1sgMCBdICYmIHBhcmFtc1sgMCBdLmlzTm9kZSA9PT0gdHJ1ZSApID8gbm9kZUFycmF5KCBwYXJhbXMgKSA6IG5vZGVPYmplY3RzKCBwYXJhbXNbIDAgXSApO1xyXG5cclxuXHRyZXR1cm4gbm9kZU9iamVjdCggbmV3IEZ1bmN0aW9uQ2FsbE5vZGUoIG5vZGVPYmplY3QoIGZ1bmMgKSwgcGFyYW1zICkgKTtcclxuXHJcbn07XHJcblxyXG5hZGRNZXRob2RDaGFpbmluZyggJ2NhbGwnLCBjYWxsICk7XHJcbiIsImltcG9ydCBUZW1wTm9kZSBmcm9tICcuLi9jb3JlL1RlbXBOb2RlLmpzJztcclxuaW1wb3J0IHsgYWRkTWV0aG9kQ2hhaW5pbmcsIG5vZGVQcm94eSB9IGZyb20gJy4uL3RzbC9UU0xDb3JlLmpzJztcclxuXHJcbi8qKiBAbW9kdWxlIE9wZXJhdG9yTm9kZSAqKi9cclxuXHJcbi8qKlxyXG4gKiBUaGlzIG5vZGUgcmVwcmVzZW50cyBiYXNpYyBtYXRoZW1hdGljYWwgYW5kIGxvZ2ljYWwgb3BlcmF0aW9ucyBsaWtlIGFkZGl0aW9uLFxyXG4gKiBzdWJ0cmFjdGlvbiBvciBjb21wYXJpc29ucyAoZS5nLiBgZXF1YWwoKWApLlxyXG4gKlxyXG4gKiBAYXVnbWVudHMgVGVtcE5vZGVcclxuICovXHJcbmNsYXNzIE9wZXJhdG9yTm9kZSBleHRlbmRzIFRlbXBOb2RlIHtcclxuXHJcblx0c3RhdGljIGdldCB0eXBlKCkge1xyXG5cclxuXHRcdHJldHVybiAnT3BlcmF0b3JOb2RlJztcclxuXHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBDb25zdHJ1Y3RzIGEgbmV3IG9wZXJhdG9yIG5vZGUuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge1N0cmluZ30gb3AgLSBUaGUgb3BlcmF0b3IuXHJcblx0ICogQHBhcmFtIHtOb2RlfSBhTm9kZSAtIFRoZSBmaXJzdCBpbnB1dC5cclxuXHQgKiBAcGFyYW0ge05vZGV9IGJOb2RlIC0gVGhlIHNlY29uZCBpbnB1dC5cclxuXHQgKiBAcGFyYW0gey4uLk5vZGV9IHBhcmFtcyAtIEFkZGl0aW9uYWwgaW5wdXQgcGFyYW1ldGVycy5cclxuXHQgKi9cclxuXHRjb25zdHJ1Y3Rvciggb3AsIGFOb2RlLCBiTm9kZSwgLi4ucGFyYW1zICkge1xyXG5cclxuXHRcdHN1cGVyKCk7XHJcblxyXG5cdFx0aWYgKCBwYXJhbXMubGVuZ3RoID4gMCApIHtcclxuXHJcblx0XHRcdGxldCBmaW5hbE9wID0gbmV3IE9wZXJhdG9yTm9kZSggb3AsIGFOb2RlLCBiTm9kZSApO1xyXG5cclxuXHRcdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgcGFyYW1zLmxlbmd0aCAtIDE7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdGZpbmFsT3AgPSBuZXcgT3BlcmF0b3JOb2RlKCBvcCwgZmluYWxPcCwgcGFyYW1zWyBpIF0gKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGFOb2RlID0gZmluYWxPcDtcclxuXHRcdFx0Yk5vZGUgPSBwYXJhbXNbIHBhcmFtcy5sZW5ndGggLSAxIF07XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogVGhlIG9wZXJhdG9yLlxyXG5cdFx0ICpcclxuXHRcdCAqIEB0eXBlIHtTdHJpbmd9XHJcblx0XHQgKi9cclxuXHRcdHRoaXMub3AgPSBvcDtcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIFRoZSBmaXJzdCBpbnB1dC5cclxuXHRcdCAqXHJcblx0XHQgKiBAdHlwZSB7Tm9kZX1cclxuXHRcdCAqL1xyXG5cdFx0dGhpcy5hTm9kZSA9IGFOb2RlO1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogVGhlIHNlY29uZCBpbnB1dC5cclxuXHRcdCAqXHJcblx0XHQgKiBAdHlwZSB7Tm9kZX1cclxuXHRcdCAqL1xyXG5cdFx0dGhpcy5iTm9kZSA9IGJOb2RlO1xyXG5cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFRoaXMgbWV0aG9kIGlzIG92ZXJ3cml0dGVuIHNpbmNlIHRoZSBub2RlIHR5cGUgaXMgaW5mZXJyZWQgZnJvbSB0aGUgb3BlcmF0b3JcclxuXHQgKiBhbmQgdGhlIGlucHV0IG5vZGUgdHlwZXMuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge05vZGVCdWlsZGVyfSBidWlsZGVyIC0gVGhlIGN1cnJlbnQgbm9kZSBidWlsZGVyLlxyXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBvdXRwdXQgLSBUaGUgY3VycmVudCBvdXRwdXQgc3RyaW5nLlxyXG5cdCAqIEByZXR1cm4ge1N0cmluZ30gVGhlIG5vZGUgdHlwZS5cclxuXHQgKi9cclxuXHRnZXROb2RlVHlwZSggYnVpbGRlciwgb3V0cHV0ICkge1xyXG5cclxuXHRcdGNvbnN0IG9wID0gdGhpcy5vcDtcclxuXHJcblx0XHRjb25zdCBhTm9kZSA9IHRoaXMuYU5vZGU7XHJcblx0XHRjb25zdCBiTm9kZSA9IHRoaXMuYk5vZGU7XHJcblxyXG5cdFx0Y29uc3QgdHlwZUEgPSBhTm9kZS5nZXROb2RlVHlwZSggYnVpbGRlciApO1xyXG5cdFx0Y29uc3QgdHlwZUIgPSB0eXBlb2YgYk5vZGUgIT09ICd1bmRlZmluZWQnID8gYk5vZGUuZ2V0Tm9kZVR5cGUoIGJ1aWxkZXIgKSA6IG51bGw7XHJcblxyXG5cdFx0aWYgKCB0eXBlQSA9PT0gJ3ZvaWQnIHx8IHR5cGVCID09PSAndm9pZCcgKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gJ3ZvaWQnO1xyXG5cclxuXHRcdH0gZWxzZSBpZiAoIG9wID09PSAnJScgKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gdHlwZUE7XHJcblxyXG5cdFx0fSBlbHNlIGlmICggb3AgPT09ICd+JyB8fCBvcCA9PT0gJyYnIHx8IG9wID09PSAnfCcgfHwgb3AgPT09ICdeJyB8fCBvcCA9PT0gJz4+JyB8fCBvcCA9PT0gJzw8JyApIHtcclxuXHJcblx0XHRcdHJldHVybiBidWlsZGVyLmdldEludGVnZXJUeXBlKCB0eXBlQSApO1xyXG5cclxuXHRcdH0gZWxzZSBpZiAoIG9wID09PSAnIScgfHwgb3AgPT09ICc9PScgfHwgb3AgPT09ICcmJicgfHwgb3AgPT09ICd8fCcgfHwgb3AgPT09ICdeXicgKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gJ2Jvb2wnO1xyXG5cclxuXHRcdH0gZWxzZSBpZiAoIG9wID09PSAnPCcgfHwgb3AgPT09ICc+JyB8fCBvcCA9PT0gJzw9JyB8fCBvcCA9PT0gJz49JyApIHtcclxuXHJcblx0XHRcdGNvbnN0IHR5cGVMZW5ndGggPSBvdXRwdXQgPyBidWlsZGVyLmdldFR5cGVMZW5ndGgoIG91dHB1dCApIDogTWF0aC5tYXgoIGJ1aWxkZXIuZ2V0VHlwZUxlbmd0aCggdHlwZUEgKSwgYnVpbGRlci5nZXRUeXBlTGVuZ3RoKCB0eXBlQiApICk7XHJcblxyXG5cdFx0XHRyZXR1cm4gdHlwZUxlbmd0aCA+IDEgPyBgYnZlYyR7IHR5cGVMZW5ndGggfWAgOiAnYm9vbCc7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdGlmICggdHlwZUEgPT09ICdmbG9hdCcgJiYgYnVpbGRlci5pc01hdHJpeCggdHlwZUIgKSApIHtcclxuXHJcblx0XHRcdFx0cmV0dXJuIHR5cGVCO1xyXG5cclxuXHRcdFx0fSBlbHNlIGlmICggYnVpbGRlci5pc01hdHJpeCggdHlwZUEgKSAmJiBidWlsZGVyLmlzVmVjdG9yKCB0eXBlQiApICkge1xyXG5cclxuXHRcdFx0XHQvLyBtYXRyaXggeCB2ZWN0b3JcclxuXHJcblx0XHRcdFx0cmV0dXJuIGJ1aWxkZXIuZ2V0VmVjdG9yRnJvbU1hdHJpeCggdHlwZUEgKTtcclxuXHJcblx0XHRcdH0gZWxzZSBpZiAoIGJ1aWxkZXIuaXNWZWN0b3IoIHR5cGVBICkgJiYgYnVpbGRlci5pc01hdHJpeCggdHlwZUIgKSApIHtcclxuXHJcblx0XHRcdFx0Ly8gdmVjdG9yIHggbWF0cml4XHJcblxyXG5cdFx0XHRcdHJldHVybiBidWlsZGVyLmdldFZlY3RvckZyb21NYXRyaXgoIHR5cGVCICk7XHJcblxyXG5cdFx0XHR9IGVsc2UgaWYgKCBidWlsZGVyLmdldFR5cGVMZW5ndGgoIHR5cGVCICkgPiBidWlsZGVyLmdldFR5cGVMZW5ndGgoIHR5cGVBICkgKSB7XHJcblxyXG5cdFx0XHRcdC8vIGFueXR5cGUgeCBhbnl0eXBlOiB1c2UgdGhlIGdyZWF0ZXIgbGVuZ3RoIHZlY3RvclxyXG5cclxuXHRcdFx0XHRyZXR1cm4gdHlwZUI7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRyZXR1cm4gdHlwZUE7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdGdlbmVyYXRlKCBidWlsZGVyLCBvdXRwdXQgKSB7XHJcblxyXG5cdFx0Y29uc3Qgb3AgPSB0aGlzLm9wO1xyXG5cclxuXHRcdGNvbnN0IGFOb2RlID0gdGhpcy5hTm9kZTtcclxuXHRcdGNvbnN0IGJOb2RlID0gdGhpcy5iTm9kZTtcclxuXHJcblx0XHRjb25zdCB0eXBlID0gdGhpcy5nZXROb2RlVHlwZSggYnVpbGRlciwgb3V0cHV0ICk7XHJcblxyXG5cdFx0bGV0IHR5cGVBID0gbnVsbDtcclxuXHRcdGxldCB0eXBlQiA9IG51bGw7XHJcblxyXG5cdFx0aWYgKCB0eXBlICE9PSAndm9pZCcgKSB7XHJcblxyXG5cdFx0XHR0eXBlQSA9IGFOb2RlLmdldE5vZGVUeXBlKCBidWlsZGVyICk7XHJcblx0XHRcdHR5cGVCID0gdHlwZW9mIGJOb2RlICE9PSAndW5kZWZpbmVkJyA/IGJOb2RlLmdldE5vZGVUeXBlKCBidWlsZGVyICkgOiBudWxsO1xyXG5cclxuXHRcdFx0aWYgKCBvcCA9PT0gJzwnIHx8IG9wID09PSAnPicgfHwgb3AgPT09ICc8PScgfHwgb3AgPT09ICc+PScgfHwgb3AgPT09ICc9PScgKSB7XHJcblxyXG5cdFx0XHRcdGlmICggYnVpbGRlci5pc1ZlY3RvciggdHlwZUEgKSApIHtcclxuXHJcblx0XHRcdFx0XHR0eXBlQiA9IHR5cGVBO1xyXG5cclxuXHRcdFx0XHR9IGVsc2UgaWYgKCB0eXBlQSAhPT0gdHlwZUIgKSB7XHJcblxyXG5cdFx0XHRcdFx0dHlwZUEgPSB0eXBlQiA9ICdmbG9hdCc7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH0gZWxzZSBpZiAoIG9wID09PSAnPj4nIHx8IG9wID09PSAnPDwnICkge1xyXG5cclxuXHRcdFx0XHR0eXBlQSA9IHR5cGU7XHJcblx0XHRcdFx0dHlwZUIgPSBidWlsZGVyLmNoYW5nZUNvbXBvbmVudFR5cGUoIHR5cGVCLCAndWludCcgKTtcclxuXHJcblx0XHRcdH0gZWxzZSBpZiAoIGJ1aWxkZXIuaXNNYXRyaXgoIHR5cGVBICkgJiYgYnVpbGRlci5pc1ZlY3RvciggdHlwZUIgKSApIHtcclxuXHJcblx0XHRcdFx0Ly8gbWF0cml4IHggdmVjdG9yXHJcblxyXG5cdFx0XHRcdHR5cGVCID0gYnVpbGRlci5nZXRWZWN0b3JGcm9tTWF0cml4KCB0eXBlQSApO1xyXG5cclxuXHRcdFx0fSBlbHNlIGlmICggYnVpbGRlci5pc1ZlY3RvciggdHlwZUEgKSAmJiBidWlsZGVyLmlzTWF0cml4KCB0eXBlQiApICkge1xyXG5cclxuXHRcdFx0XHQvLyB2ZWN0b3IgeCBtYXRyaXhcclxuXHJcblx0XHRcdFx0dHlwZUEgPSBidWlsZGVyLmdldFZlY3RvckZyb21NYXRyaXgoIHR5cGVCICk7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHQvLyBhbnl0eXBlIHggYW55dHlwZVxyXG5cclxuXHRcdFx0XHR0eXBlQSA9IHR5cGVCID0gdHlwZTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0dHlwZUEgPSB0eXBlQiA9IHR5cGU7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGNvbnN0IGEgPSBhTm9kZS5idWlsZCggYnVpbGRlciwgdHlwZUEgKTtcclxuXHRcdGNvbnN0IGIgPSB0eXBlb2YgYk5vZGUgIT09ICd1bmRlZmluZWQnID8gYk5vZGUuYnVpbGQoIGJ1aWxkZXIsIHR5cGVCICkgOiBudWxsO1xyXG5cclxuXHRcdGNvbnN0IG91dHB1dExlbmd0aCA9IGJ1aWxkZXIuZ2V0VHlwZUxlbmd0aCggb3V0cHV0ICk7XHJcblx0XHRjb25zdCBmbk9wU25pcHBldCA9IGJ1aWxkZXIuZ2V0RnVuY3Rpb25PcGVyYXRvciggb3AgKTtcclxuXHJcblx0XHRpZiAoIG91dHB1dCAhPT0gJ3ZvaWQnICkge1xyXG5cclxuXHRcdFx0aWYgKCBvcCA9PT0gJzwnICYmIG91dHB1dExlbmd0aCA+IDEgKSB7XHJcblxyXG5cdFx0XHRcdGlmICggYnVpbGRlci51c2VDb21wYXJpc29uTWV0aG9kICkge1xyXG5cclxuXHRcdFx0XHRcdHJldHVybiBidWlsZGVyLmZvcm1hdCggYCR7IGJ1aWxkZXIuZ2V0TWV0aG9kKCAnbGVzc1RoYW4nLCBvdXRwdXQgKSB9KCAkeyBhIH0sICR7IGIgfSApYCwgdHlwZSwgb3V0cHV0ICk7XHJcblxyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0cmV0dXJuIGJ1aWxkZXIuZm9ybWF0KCBgKCAkeyBhIH0gPCAkeyBiIH0gKWAsIHR5cGUsIG91dHB1dCApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9IGVsc2UgaWYgKCBvcCA9PT0gJzw9JyAmJiBvdXRwdXRMZW5ndGggPiAxICkge1xyXG5cclxuXHRcdFx0XHRpZiAoIGJ1aWxkZXIudXNlQ29tcGFyaXNvbk1ldGhvZCApIHtcclxuXHJcblx0XHRcdFx0XHRyZXR1cm4gYnVpbGRlci5mb3JtYXQoIGAkeyBidWlsZGVyLmdldE1ldGhvZCggJ2xlc3NUaGFuRXF1YWwnLCBvdXRwdXQgKSB9KCAkeyBhIH0sICR7IGIgfSApYCwgdHlwZSwgb3V0cHV0ICk7XHJcblxyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0cmV0dXJuIGJ1aWxkZXIuZm9ybWF0KCBgKCAkeyBhIH0gPD0gJHsgYiB9IClgLCB0eXBlLCBvdXRwdXQgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fSBlbHNlIGlmICggb3AgPT09ICc+JyAmJiBvdXRwdXRMZW5ndGggPiAxICkge1xyXG5cclxuXHRcdFx0XHRpZiAoIGJ1aWxkZXIudXNlQ29tcGFyaXNvbk1ldGhvZCApIHtcclxuXHJcblx0XHRcdFx0XHRyZXR1cm4gYnVpbGRlci5mb3JtYXQoIGAkeyBidWlsZGVyLmdldE1ldGhvZCggJ2dyZWF0ZXJUaGFuJywgb3V0cHV0ICkgfSggJHsgYSB9LCAkeyBiIH0gKWAsIHR5cGUsIG91dHB1dCApO1xyXG5cclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdHJldHVybiBidWlsZGVyLmZvcm1hdCggYCggJHsgYSB9ID4gJHsgYiB9IClgLCB0eXBlLCBvdXRwdXQgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fSBlbHNlIGlmICggb3AgPT09ICc+PScgJiYgb3V0cHV0TGVuZ3RoID4gMSApIHtcclxuXHJcblx0XHRcdFx0aWYgKCBidWlsZGVyLnVzZUNvbXBhcmlzb25NZXRob2QgKSB7XHJcblxyXG5cdFx0XHRcdFx0cmV0dXJuIGJ1aWxkZXIuZm9ybWF0KCBgJHsgYnVpbGRlci5nZXRNZXRob2QoICdncmVhdGVyVGhhbkVxdWFsJywgb3V0cHV0ICkgfSggJHsgYSB9LCAkeyBiIH0gKWAsIHR5cGUsIG91dHB1dCApO1xyXG5cclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdHJldHVybiBidWlsZGVyLmZvcm1hdCggYCggJHsgYSB9ID49ICR7IGIgfSApYCwgdHlwZSwgb3V0cHV0ICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH0gZWxzZSBpZiAoIG9wID09PSAnIScgfHwgb3AgPT09ICd+JyApIHtcclxuXHJcblx0XHRcdFx0cmV0dXJuIGJ1aWxkZXIuZm9ybWF0KCBgKCR7b3B9JHthfSlgLCB0eXBlQSwgb3V0cHV0ICk7XHJcblxyXG5cdFx0XHR9IGVsc2UgaWYgKCBmbk9wU25pcHBldCApIHtcclxuXHJcblx0XHRcdFx0cmV0dXJuIGJ1aWxkZXIuZm9ybWF0KCBgJHsgZm5PcFNuaXBwZXQgfSggJHsgYSB9LCAkeyBiIH0gKWAsIHR5cGUsIG91dHB1dCApO1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0cmV0dXJuIGJ1aWxkZXIuZm9ybWF0KCBgKCAkeyBhIH0gJHsgb3AgfSAkeyBiIH0gKWAsIHR5cGUsIG91dHB1dCApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH0gZWxzZSBpZiAoIHR5cGVBICE9PSAndm9pZCcgKSB7XHJcblxyXG5cdFx0XHRpZiAoIGZuT3BTbmlwcGV0ICkge1xyXG5cclxuXHRcdFx0XHRyZXR1cm4gYnVpbGRlci5mb3JtYXQoIGAkeyBmbk9wU25pcHBldCB9KCAkeyBhIH0sICR7IGIgfSApYCwgdHlwZSwgb3V0cHV0ICk7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRyZXR1cm4gYnVpbGRlci5mb3JtYXQoIGAkeyBhIH0gJHsgb3AgfSAkeyBiIH1gLCB0eXBlLCBvdXRwdXQgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0c2VyaWFsaXplKCBkYXRhICkge1xyXG5cclxuXHRcdHN1cGVyLnNlcmlhbGl6ZSggZGF0YSApO1xyXG5cclxuXHRcdGRhdGEub3AgPSB0aGlzLm9wO1xyXG5cclxuXHR9XHJcblxyXG5cdGRlc2VyaWFsaXplKCBkYXRhICkge1xyXG5cclxuXHRcdHN1cGVyLmRlc2VyaWFsaXplKCBkYXRhICk7XHJcblxyXG5cdFx0dGhpcy5vcCA9IGRhdGEub3A7XHJcblxyXG5cdH1cclxuXHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IE9wZXJhdG9yTm9kZTtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBhZGRpdGlvbiBvZiB0d28gb3IgbW9yZSB2YWx1ZS5cclxuICpcclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7Tm9kZX0gYU5vZGUgLSBUaGUgZmlyc3QgaW5wdXQuXHJcbiAqIEBwYXJhbSB7Tm9kZX0gYk5vZGUgLSBUaGUgc2Vjb25kIGlucHV0LlxyXG4gKiBAcGFyYW0gey4uLk5vZGV9IHBhcmFtcyAtIEFkZGl0aW9uYWwgaW5wdXQgcGFyYW1ldGVycy5cclxuICogQHJldHVybnMge09wZXJhdG9yTm9kZX1cclxuICovXHJcbmV4cG9ydCBjb25zdCBhZGQgPSAvKkBfX1BVUkVfXyovIG5vZGVQcm94eSggT3BlcmF0b3JOb2RlLCAnKycgKTtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBzdWJyYWN0aW9uIG9mIHR3byBvciBtb3JlIHZhbHVlLlxyXG4gKlxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHtOb2RlfSBhTm9kZSAtIFRoZSBmaXJzdCBpbnB1dC5cclxuICogQHBhcmFtIHtOb2RlfSBiTm9kZSAtIFRoZSBzZWNvbmQgaW5wdXQuXHJcbiAqIEBwYXJhbSB7Li4uTm9kZX0gcGFyYW1zIC0gQWRkaXRpb25hbCBpbnB1dCBwYXJhbWV0ZXJzLlxyXG4gKiBAcmV0dXJucyB7T3BlcmF0b3JOb2RlfVxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IHN1YiA9IC8qQF9fUFVSRV9fKi8gbm9kZVByb3h5KCBPcGVyYXRvck5vZGUsICctJyApO1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgdGhlIG11bHRpcGxpY2F0aW9uIG9mIHR3byBvciBtb3JlIHZhbHVlLlxyXG4gKlxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHtOb2RlfSBhTm9kZSAtIFRoZSBmaXJzdCBpbnB1dC5cclxuICogQHBhcmFtIHtOb2RlfSBiTm9kZSAtIFRoZSBzZWNvbmQgaW5wdXQuXHJcbiAqIEBwYXJhbSB7Li4uTm9kZX0gcGFyYW1zIC0gQWRkaXRpb25hbCBpbnB1dCBwYXJhbWV0ZXJzLlxyXG4gKiBAcmV0dXJucyB7T3BlcmF0b3JOb2RlfVxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IG11bCA9IC8qQF9fUFVSRV9fKi8gbm9kZVByb3h5KCBPcGVyYXRvck5vZGUsICcqJyApO1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgdGhlIGRpdmlzaW9uIG9mIHR3byBvciBtb3JlIHZhbHVlLlxyXG4gKlxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHtOb2RlfSBhTm9kZSAtIFRoZSBmaXJzdCBpbnB1dC5cclxuICogQHBhcmFtIHtOb2RlfSBiTm9kZSAtIFRoZSBzZWNvbmQgaW5wdXQuXHJcbiAqIEBwYXJhbSB7Li4uTm9kZX0gcGFyYW1zIC0gQWRkaXRpb25hbCBpbnB1dCBwYXJhbWV0ZXJzLlxyXG4gKiBAcmV0dXJucyB7T3BlcmF0b3JOb2RlfVxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IGRpdiA9IC8qQF9fUFVSRV9fKi8gbm9kZVByb3h5KCBPcGVyYXRvck5vZGUsICcvJyApO1xyXG5cclxuLyoqXHJcbiAqIENvbXB1dGVzIHRoZSByZW1haW5kZXIgb2YgZGl2aWRpbmcgdGhlIGZpcnN0IG5vZGUgYnkgdGhlIHNlY29uZCwgZm9yIGludGVnZXIgdmFsdWVzLlxyXG4gKlxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHtOb2RlfSBhTm9kZSAtIFRoZSBmaXJzdCBpbnB1dC5cclxuICogQHBhcmFtIHtOb2RlfSBiTm9kZSAtIFRoZSBzZWNvbmQgaW5wdXQuXHJcbiAqIEByZXR1cm5zIHtPcGVyYXRvck5vZGV9XHJcbiAqL1xyXG5leHBvcnQgY29uc3QgbW9kSW50ID0gLypAX19QVVJFX18qLyBub2RlUHJveHkoIE9wZXJhdG9yTm9kZSwgJyUnICk7XHJcblxyXG4vKipcclxuICogQ2hlY2tzIGlmIHR3byBub2RlcyBhcmUgZXF1YWwuXHJcbiAqXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0ge05vZGV9IGFOb2RlIC0gVGhlIGZpcnN0IGlucHV0LlxyXG4gKiBAcGFyYW0ge05vZGV9IGJOb2RlIC0gVGhlIHNlY29uZCBpbnB1dC5cclxuICogQHJldHVybnMge09wZXJhdG9yTm9kZX1cclxuICovXHJcbmV4cG9ydCBjb25zdCBlcXVhbCA9IC8qQF9fUFVSRV9fKi8gbm9kZVByb3h5KCBPcGVyYXRvck5vZGUsICc9PScgKTtcclxuXHJcbi8qKlxyXG4gKiBDaGVja3MgaWYgdHdvIG5vZGVzIGFyZSBub3QgZXF1YWwuXHJcbiAqXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0ge05vZGV9IGFOb2RlIC0gVGhlIGZpcnN0IGlucHV0LlxyXG4gKiBAcGFyYW0ge05vZGV9IGJOb2RlIC0gVGhlIHNlY29uZCBpbnB1dC5cclxuICogQHJldHVybnMge09wZXJhdG9yTm9kZX1cclxuICovXHJcbmV4cG9ydCBjb25zdCBub3RFcXVhbCA9IC8qQF9fUFVSRV9fKi8gbm9kZVByb3h5KCBPcGVyYXRvck5vZGUsICchPScgKTtcclxuXHJcbi8qKlxyXG4gKiBDaGVja3MgaWYgdGhlIGZpcnN0IG5vZGUgaXMgbGVzcyB0aGFuIHRoZSBzZWNvbmQuXHJcbiAqXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0ge05vZGV9IGFOb2RlIC0gVGhlIGZpcnN0IGlucHV0LlxyXG4gKiBAcGFyYW0ge05vZGV9IGJOb2RlIC0gVGhlIHNlY29uZCBpbnB1dC5cclxuICogQHJldHVybnMge09wZXJhdG9yTm9kZX1cclxuICovXHJcbmV4cG9ydCBjb25zdCBsZXNzVGhhbiA9IC8qQF9fUFVSRV9fKi8gbm9kZVByb3h5KCBPcGVyYXRvck5vZGUsICc8JyApO1xyXG5cclxuLyoqXHJcbiAqIENoZWNrcyBpZiB0aGUgZmlyc3Qgbm9kZSBpcyBncmVhdGVyIHRoYW4gdGhlIHNlY29uZC5cclxuICpcclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7Tm9kZX0gYU5vZGUgLSBUaGUgZmlyc3QgaW5wdXQuXHJcbiAqIEBwYXJhbSB7Tm9kZX0gYk5vZGUgLSBUaGUgc2Vjb25kIGlucHV0LlxyXG4gKiBAcmV0dXJucyB7T3BlcmF0b3JOb2RlfVxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IGdyZWF0ZXJUaGFuID0gLypAX19QVVJFX18qLyBub2RlUHJveHkoIE9wZXJhdG9yTm9kZSwgJz4nICk7XHJcblxyXG4vKipcclxuICogQ2hlY2tzIGlmIHRoZSBmaXJzdCBub2RlIGlzIGxlc3MgdGhhbiBvciBlcXVhbCB0byB0aGUgc2Vjb25kLlxyXG4gKlxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHtOb2RlfSBhTm9kZSAtIFRoZSBmaXJzdCBpbnB1dC5cclxuICogQHBhcmFtIHtOb2RlfSBiTm9kZSAtIFRoZSBzZWNvbmQgaW5wdXQuXHJcbiAqIEByZXR1cm5zIHtPcGVyYXRvck5vZGV9XHJcbiAqL1xyXG5leHBvcnQgY29uc3QgbGVzc1RoYW5FcXVhbCA9IC8qQF9fUFVSRV9fKi8gbm9kZVByb3h5KCBPcGVyYXRvck5vZGUsICc8PScgKTtcclxuXHJcbi8qKlxyXG4gKiBDaGVja3MgaWYgdGhlIGZpcnN0IG5vZGUgaXMgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIHRoZSBzZWNvbmQuXHJcbiAqXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0ge05vZGV9IGFOb2RlIC0gVGhlIGZpcnN0IGlucHV0LlxyXG4gKiBAcGFyYW0ge05vZGV9IGJOb2RlIC0gVGhlIHNlY29uZCBpbnB1dC5cclxuICogQHJldHVybnMge09wZXJhdG9yTm9kZX1cclxuICovXHJcbmV4cG9ydCBjb25zdCBncmVhdGVyVGhhbkVxdWFsID0gLypAX19QVVJFX18qLyBub2RlUHJveHkoIE9wZXJhdG9yTm9kZSwgJz49JyApO1xyXG5cclxuLyoqXHJcbiAqIFBlcmZvcm1zIGxvZ2ljYWwgQU5EIG9uIHR3byBub2Rlcy5cclxuICpcclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7Tm9kZX0gYU5vZGUgLSBUaGUgZmlyc3QgaW5wdXQuXHJcbiAqIEBwYXJhbSB7Tm9kZX0gYk5vZGUgLSBUaGUgc2Vjb25kIGlucHV0LlxyXG4gKiBAcmV0dXJucyB7T3BlcmF0b3JOb2RlfVxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IGFuZCA9IC8qQF9fUFVSRV9fKi8gbm9kZVByb3h5KCBPcGVyYXRvck5vZGUsICcmJicgKTtcclxuXHJcbi8qKlxyXG4gKiBQZXJmb3JtcyBsb2dpY2FsIE9SIG9uIHR3byBub2Rlcy5cclxuICpcclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7Tm9kZX0gYU5vZGUgLSBUaGUgZmlyc3QgaW5wdXQuXHJcbiAqIEBwYXJhbSB7Tm9kZX0gYk5vZGUgLSBUaGUgc2Vjb25kIGlucHV0LlxyXG4gKiBAcmV0dXJucyB7T3BlcmF0b3JOb2RlfVxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IG9yID0gLypAX19QVVJFX18qLyBub2RlUHJveHkoIE9wZXJhdG9yTm9kZSwgJ3x8JyApO1xyXG5cclxuLyoqXHJcbiAqIFBlcmZvcm1zIGxvZ2ljYWwgTk9UIG9uIGEgbm9kZS5cclxuICpcclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7Tm9kZX0gYU5vZGUgLSBUaGUgZmlyc3QgaW5wdXQuXHJcbiAqIEBwYXJhbSB7Tm9kZX0gYk5vZGUgLSBUaGUgc2Vjb25kIGlucHV0LlxyXG4gKiBAcmV0dXJucyB7T3BlcmF0b3JOb2RlfVxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IG5vdCA9IC8qQF9fUFVSRV9fKi8gbm9kZVByb3h5KCBPcGVyYXRvck5vZGUsICchJyApO1xyXG5cclxuLyoqXHJcbiAqIFBlcmZvcm1zIGxvZ2ljYWwgWE9SIG9uIHR3byBub2Rlcy5cclxuICpcclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7Tm9kZX0gYU5vZGUgLSBUaGUgZmlyc3QgaW5wdXQuXHJcbiAqIEBwYXJhbSB7Tm9kZX0gYk5vZGUgLSBUaGUgc2Vjb25kIGlucHV0LlxyXG4gKiBAcmV0dXJucyB7T3BlcmF0b3JOb2RlfVxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IHhvciA9IC8qQF9fUFVSRV9fKi8gbm9kZVByb3h5KCBPcGVyYXRvck5vZGUsICdeXicgKTtcclxuXHJcbi8qKlxyXG4gKiBQZXJmb3JtcyBiaXR3aXNlIEFORCBvbiB0d28gbm9kZXMuXHJcbiAqXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0ge05vZGV9IGFOb2RlIC0gVGhlIGZpcnN0IGlucHV0LlxyXG4gKiBAcGFyYW0ge05vZGV9IGJOb2RlIC0gVGhlIHNlY29uZCBpbnB1dC5cclxuICogQHJldHVybnMge09wZXJhdG9yTm9kZX1cclxuICovXHJcbmV4cG9ydCBjb25zdCBiaXRBbmQgPSAvKkBfX1BVUkVfXyovIG5vZGVQcm94eSggT3BlcmF0b3JOb2RlLCAnJicgKTtcclxuXHJcbi8qKlxyXG4gKiBQZXJmb3JtcyBiaXR3aXNlIE5PVCBvbiBhIG5vZGUuXHJcbiAqXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0ge05vZGV9IGFOb2RlIC0gVGhlIGZpcnN0IGlucHV0LlxyXG4gKiBAcGFyYW0ge05vZGV9IGJOb2RlIC0gVGhlIHNlY29uZCBpbnB1dC5cclxuICogQHJldHVybnMge09wZXJhdG9yTm9kZX1cclxuICovXHJcbmV4cG9ydCBjb25zdCBiaXROb3QgPSAvKkBfX1BVUkVfXyovIG5vZGVQcm94eSggT3BlcmF0b3JOb2RlLCAnficgKTtcclxuXHJcbi8qKlxyXG4gKiBQZXJmb3JtcyBiaXR3aXNlIE9SIG9uIHR3byBub2Rlcy5cclxuICpcclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7Tm9kZX0gYU5vZGUgLSBUaGUgZmlyc3QgaW5wdXQuXHJcbiAqIEBwYXJhbSB7Tm9kZX0gYk5vZGUgLSBUaGUgc2Vjb25kIGlucHV0LlxyXG4gKiBAcmV0dXJucyB7T3BlcmF0b3JOb2RlfVxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IGJpdE9yID0gLypAX19QVVJFX18qLyBub2RlUHJveHkoIE9wZXJhdG9yTm9kZSwgJ3wnICk7XHJcblxyXG4vKipcclxuICogUGVyZm9ybXMgYml0d2lzZSBYT1Igb24gdHdvIG5vZGVzLlxyXG4gKlxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHtOb2RlfSBhTm9kZSAtIFRoZSBmaXJzdCBpbnB1dC5cclxuICogQHBhcmFtIHtOb2RlfSBiTm9kZSAtIFRoZSBzZWNvbmQgaW5wdXQuXHJcbiAqIEByZXR1cm5zIHtPcGVyYXRvck5vZGV9XHJcbiAqL1xyXG5leHBvcnQgY29uc3QgYml0WG9yID0gLypAX19QVVJFX18qLyBub2RlUHJveHkoIE9wZXJhdG9yTm9kZSwgJ14nICk7XHJcblxyXG4vKipcclxuICogU2hpZnRzIGEgbm9kZSB0byB0aGUgbGVmdC5cclxuICpcclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7Tm9kZX0gYU5vZGUgLSBUaGUgbm9kZSB0byBzaGlmdC5cclxuICogQHBhcmFtIHtOb2RlfSBiTm9kZSAtIFRoZSB2YWx1ZSB0byBzaGlmdC5cclxuICogQHJldHVybnMge09wZXJhdG9yTm9kZX1cclxuICovXHJcbmV4cG9ydCBjb25zdCBzaGlmdExlZnQgPSAvKkBfX1BVUkVfXyovIG5vZGVQcm94eSggT3BlcmF0b3JOb2RlLCAnPDwnICk7XHJcblxyXG4vKipcclxuICogU2hpZnRzIGEgbm9kZSB0byB0aGUgcmlnaHQuXHJcbiAqXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0ge05vZGV9IGFOb2RlIC0gVGhlIG5vZGUgdG8gc2hpZnQuXHJcbiAqIEBwYXJhbSB7Tm9kZX0gYk5vZGUgLSBUaGUgdmFsdWUgdG8gc2hpZnQuXHJcbiAqIEByZXR1cm5zIHtPcGVyYXRvck5vZGV9XHJcbiAqL1xyXG5leHBvcnQgY29uc3Qgc2hpZnRSaWdodCA9IC8qQF9fUFVSRV9fKi8gbm9kZVByb3h5KCBPcGVyYXRvck5vZGUsICc+PicgKTtcclxuXHJcbmFkZE1ldGhvZENoYWluaW5nKCAnYWRkJywgYWRkICk7XHJcbmFkZE1ldGhvZENoYWluaW5nKCAnc3ViJywgc3ViICk7XHJcbmFkZE1ldGhvZENoYWluaW5nKCAnbXVsJywgbXVsICk7XHJcbmFkZE1ldGhvZENoYWluaW5nKCAnZGl2JywgZGl2ICk7XHJcbmFkZE1ldGhvZENoYWluaW5nKCAnbW9kSW50JywgbW9kSW50ICk7XHJcbmFkZE1ldGhvZENoYWluaW5nKCAnZXF1YWwnLCBlcXVhbCApO1xyXG5hZGRNZXRob2RDaGFpbmluZyggJ25vdEVxdWFsJywgbm90RXF1YWwgKTtcclxuYWRkTWV0aG9kQ2hhaW5pbmcoICdsZXNzVGhhbicsIGxlc3NUaGFuICk7XHJcbmFkZE1ldGhvZENoYWluaW5nKCAnZ3JlYXRlclRoYW4nLCBncmVhdGVyVGhhbiApO1xyXG5hZGRNZXRob2RDaGFpbmluZyggJ2xlc3NUaGFuRXF1YWwnLCBsZXNzVGhhbkVxdWFsICk7XHJcbmFkZE1ldGhvZENoYWluaW5nKCAnZ3JlYXRlclRoYW5FcXVhbCcsIGdyZWF0ZXJUaGFuRXF1YWwgKTtcclxuYWRkTWV0aG9kQ2hhaW5pbmcoICdhbmQnLCBhbmQgKTtcclxuYWRkTWV0aG9kQ2hhaW5pbmcoICdvcicsIG9yICk7XHJcbmFkZE1ldGhvZENoYWluaW5nKCAnbm90Jywgbm90ICk7XHJcbmFkZE1ldGhvZENoYWluaW5nKCAneG9yJywgeG9yICk7XHJcbmFkZE1ldGhvZENoYWluaW5nKCAnYml0QW5kJywgYml0QW5kICk7XHJcbmFkZE1ldGhvZENoYWluaW5nKCAnYml0Tm90JywgYml0Tm90ICk7XHJcbmFkZE1ldGhvZENoYWluaW5nKCAnYml0T3InLCBiaXRPciApO1xyXG5hZGRNZXRob2RDaGFpbmluZyggJ2JpdFhvcicsIGJpdFhvciApO1xyXG5hZGRNZXRob2RDaGFpbmluZyggJ3NoaWZ0TGVmdCcsIHNoaWZ0TGVmdCApO1xyXG5hZGRNZXRob2RDaGFpbmluZyggJ3NoaWZ0UmlnaHQnLCBzaGlmdFJpZ2h0ICk7XHJcblxyXG5cclxuZXhwb3J0IGNvbnN0IHJlbWFpbmRlciA9ICggLi4ucGFyYW1zICkgPT4geyAvLyBAZGVwcmVjYXRlZCwgcjE2OFxyXG5cclxuXHRjb25zb2xlLndhcm4oICdUU0wuT3BlcmF0b3JOb2RlOiAucmVtYWluZGVyKCkgaGFzIGJlZW4gcmVuYW1lZCB0byAubW9kSW50KCkuJyApO1xyXG5cdHJldHVybiBtb2RJbnQoIC4uLnBhcmFtcyApO1xyXG5cclxufTtcclxuXHJcbmFkZE1ldGhvZENoYWluaW5nKCAncmVtYWluZGVyJywgcmVtYWluZGVyICk7XHJcbiIsImltcG9ydCBUZW1wTm9kZSBmcm9tICcuLi9jb3JlL1RlbXBOb2RlLmpzJztcclxuaW1wb3J0IHsgc3ViLCBtdWwsIGRpdiB9IGZyb20gJy4vT3BlcmF0b3JOb2RlLmpzJztcclxuaW1wb3J0IHsgYWRkTWV0aG9kQ2hhaW5pbmcsIG5vZGVPYmplY3QsIG5vZGVQcm94eSwgZmxvYXQsIHZlYzIsIHZlYzMsIHZlYzQsIEZuIH0gZnJvbSAnLi4vdHNsL1RTTENvcmUuanMnO1xyXG5cclxuLyoqXHJcbiAqIFRoaXMgbm9kZSByZXByZXNlbnRzIGEgdmFyaWV0eSBvZiBtYXRoZW1hdGljYWwgbWV0aG9kcyBhdmFpbGFibGUgaW4gc2hhZGVycy5cclxuICogVGhleSBhcmUgZGl2aWRlZCBpbnRvIHRocmVlIGNhdGVnb3JpZXM6XHJcbiAqXHJcbiAqIC0gTWV0aG9kcyB3aXRoIG9uZSBpbnB1dCBsaWtlIGBzaW5gLCBgY29zYCBvciBgbm9ybWFsaXplYC5cclxuICogLSBNZXRob2RzIHdpdGggdHdvIGlucHV0cyBsaWtlIGBkb3RgLCBgY3Jvc3NgIG9yIGBwb3dgLlxyXG4gKiAtIE1ldGhvZHMgd2l0aCB0aHJlZSBpbnB1dHMgbGlrZSBgbWl4YCwgYGNsYW1wYCBvciBgc21vb3Roc3RlcGAuXHJcbiAqXHJcbiAqIEBhdWdtZW50cyBUZW1wTm9kZVxyXG4gKi9cclxuY2xhc3MgTWF0aE5vZGUgZXh0ZW5kcyBUZW1wTm9kZSB7XHJcblxyXG5cdHN0YXRpYyBnZXQgdHlwZSgpIHtcclxuXHJcblx0XHRyZXR1cm4gJ01hdGhOb2RlJztcclxuXHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBDb25zdHJ1Y3RzIGEgbmV3IG1hdGggbm9kZS5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBtZXRob2QgLSBUaGUgbWV0aG9kIG5hbWUuXHJcblx0ICogQHBhcmFtIHtOb2RlfSBhTm9kZSAtIFRoZSBmaXJzdCBpbnB1dC5cclxuXHQgKiBAcGFyYW0ge05vZGU/fSBbYk5vZGU9bnVsbF0gLSBUaGUgc2Vjb25kIGlucHV0LlxyXG5cdCAqIEBwYXJhbSB7Tm9kZT99IFtjTm9kZT1udWxsXSAtIFRoZSB0aGlyZCBpbnB1dC5cclxuXHQgKi9cclxuXHRjb25zdHJ1Y3RvciggbWV0aG9kLCBhTm9kZSwgYk5vZGUgPSBudWxsLCBjTm9kZSA9IG51bGwgKSB7XHJcblxyXG5cdFx0c3VwZXIoKTtcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIFRoZSBtZXRob2QgbmFtZS5cclxuXHRcdCAqXHJcblx0XHQgKiBAdHlwZSB7U3RyaW5nfVxyXG5cdFx0ICovXHJcblx0XHR0aGlzLm1ldGhvZCA9IG1ldGhvZDtcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIFRoZSBmaXJzdCBpbnB1dC5cclxuXHRcdCAqXHJcblx0XHQgKiBAdHlwZSB7Tm9kZX1cclxuXHRcdCAqL1xyXG5cdFx0dGhpcy5hTm9kZSA9IGFOb2RlO1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogVGhlIHNlY29uZCBpbnB1dC5cclxuXHRcdCAqXHJcblx0XHQgKiBAdHlwZSB7Tm9kZT99XHJcblx0XHQgKiBAZGVmYXVsdCBudWxsXHJcblx0XHQgKi9cclxuXHRcdHRoaXMuYk5vZGUgPSBiTm9kZTtcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIFRoZSB0aGlyZCBpbnB1dC5cclxuXHRcdCAqXHJcblx0XHQgKiBAdHlwZSB7Tm9kZT99XHJcblx0XHQgKiBAZGVmYXVsdCBudWxsXHJcblx0XHQgKi9cclxuXHRcdHRoaXMuY05vZGUgPSBjTm9kZTtcclxuXHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBUaGUgaW5wdXQgdHlwZSBpcyBpbmZlcnJlZCBmcm9tIHRoZSBub2RlIHR5cGVzIG9mIHRoZSBpbnB1dCBub2Rlcy5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7Tm9kZUJ1aWxkZXJ9IGJ1aWxkZXIgLSBUaGUgY3VycmVudCBub2RlIGJ1aWxkZXIuXHJcblx0ICogQHJldHVybiB7U3RyaW5nfSBUaGUgaW5wdXQgdHlwZS5cclxuXHQgKi9cclxuXHRnZXRJbnB1dFR5cGUoIGJ1aWxkZXIgKSB7XHJcblxyXG5cdFx0Y29uc3QgYVR5cGUgPSB0aGlzLmFOb2RlLmdldE5vZGVUeXBlKCBidWlsZGVyICk7XHJcblx0XHRjb25zdCBiVHlwZSA9IHRoaXMuYk5vZGUgPyB0aGlzLmJOb2RlLmdldE5vZGVUeXBlKCBidWlsZGVyICkgOiBudWxsO1xyXG5cdFx0Y29uc3QgY1R5cGUgPSB0aGlzLmNOb2RlID8gdGhpcy5jTm9kZS5nZXROb2RlVHlwZSggYnVpbGRlciApIDogbnVsbDtcclxuXHJcblx0XHRjb25zdCBhTGVuID0gYnVpbGRlci5pc01hdHJpeCggYVR5cGUgKSA/IDAgOiBidWlsZGVyLmdldFR5cGVMZW5ndGgoIGFUeXBlICk7XHJcblx0XHRjb25zdCBiTGVuID0gYnVpbGRlci5pc01hdHJpeCggYlR5cGUgKSA/IDAgOiBidWlsZGVyLmdldFR5cGVMZW5ndGgoIGJUeXBlICk7XHJcblx0XHRjb25zdCBjTGVuID0gYnVpbGRlci5pc01hdHJpeCggY1R5cGUgKSA/IDAgOiBidWlsZGVyLmdldFR5cGVMZW5ndGgoIGNUeXBlICk7XHJcblxyXG5cdFx0aWYgKCBhTGVuID4gYkxlbiAmJiBhTGVuID4gY0xlbiApIHtcclxuXHJcblx0XHRcdHJldHVybiBhVHlwZTtcclxuXHJcblx0XHR9IGVsc2UgaWYgKCBiTGVuID4gY0xlbiApIHtcclxuXHJcblx0XHRcdHJldHVybiBiVHlwZTtcclxuXHJcblx0XHR9IGVsc2UgaWYgKCBjTGVuID4gYUxlbiApIHtcclxuXHJcblx0XHRcdHJldHVybiBjVHlwZTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGFUeXBlO1xyXG5cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFRoZSBzZWxlY3RlZCBtZXRob2QgYXMgd2VsbCBhcyB0aGUgaW5wdXQgdHlwZSBkZXRlcm1pbmUgdGhlIG5vZGUgdHlwZSBvZiB0aGlzIG5vZGUuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge05vZGVCdWlsZGVyfSBidWlsZGVyIC0gVGhlIGN1cnJlbnQgbm9kZSBidWlsZGVyLlxyXG5cdCAqIEByZXR1cm4ge1N0cmluZ30gVGhlIG5vZGUgdHlwZS5cclxuXHQgKi9cclxuXHRnZXROb2RlVHlwZSggYnVpbGRlciApIHtcclxuXHJcblx0XHRjb25zdCBtZXRob2QgPSB0aGlzLm1ldGhvZDtcclxuXHJcblx0XHRpZiAoIG1ldGhvZCA9PT0gTWF0aE5vZGUuTEVOR1RIIHx8IG1ldGhvZCA9PT0gTWF0aE5vZGUuRElTVEFOQ0UgfHwgbWV0aG9kID09PSBNYXRoTm9kZS5ET1QgKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gJ2Zsb2F0JztcclxuXHJcblx0XHR9IGVsc2UgaWYgKCBtZXRob2QgPT09IE1hdGhOb2RlLkNST1NTICkge1xyXG5cclxuXHRcdFx0cmV0dXJuICd2ZWMzJztcclxuXHJcblx0XHR9IGVsc2UgaWYgKCBtZXRob2QgPT09IE1hdGhOb2RlLkFMTCApIHtcclxuXHJcblx0XHRcdHJldHVybiAnYm9vbCc7XHJcblxyXG5cdFx0fSBlbHNlIGlmICggbWV0aG9kID09PSBNYXRoTm9kZS5FUVVBTFMgKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gYnVpbGRlci5jaGFuZ2VDb21wb25lbnRUeXBlKCB0aGlzLmFOb2RlLmdldE5vZGVUeXBlKCBidWlsZGVyICksICdib29sJyApO1xyXG5cclxuXHRcdH0gZWxzZSBpZiAoIG1ldGhvZCA9PT0gTWF0aE5vZGUuTU9EICkge1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXMuYU5vZGUuZ2V0Tm9kZVR5cGUoIGJ1aWxkZXIgKTtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXMuZ2V0SW5wdXRUeXBlKCBidWlsZGVyICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdGdlbmVyYXRlKCBidWlsZGVyLCBvdXRwdXQgKSB7XHJcblxyXG5cdFx0Y29uc3QgbWV0aG9kID0gdGhpcy5tZXRob2Q7XHJcblxyXG5cdFx0Y29uc3QgdHlwZSA9IHRoaXMuZ2V0Tm9kZVR5cGUoIGJ1aWxkZXIgKTtcclxuXHRcdGNvbnN0IGlucHV0VHlwZSA9IHRoaXMuZ2V0SW5wdXRUeXBlKCBidWlsZGVyICk7XHJcblxyXG5cdFx0Y29uc3QgYSA9IHRoaXMuYU5vZGU7XHJcblx0XHRjb25zdCBiID0gdGhpcy5iTm9kZTtcclxuXHRcdGNvbnN0IGMgPSB0aGlzLmNOb2RlO1xyXG5cclxuXHRcdGNvbnN0IGlzV2ViR0wgPSBidWlsZGVyLnJlbmRlcmVyLmlzV2ViR0xSZW5kZXJlciA9PT0gdHJ1ZTtcclxuXHJcblx0XHRpZiAoIG1ldGhvZCA9PT0gTWF0aE5vZGUuVFJBTlNGT1JNX0RJUkVDVElPTiApIHtcclxuXHJcblx0XHRcdC8vIGRpciBjYW4gYmUgZWl0aGVyIGEgZGlyZWN0aW9uIHZlY3RvciBvciBhIG5vcm1hbCB2ZWN0b3JcclxuXHRcdFx0Ly8gdXBwZXItbGVmdCAzeDMgb2YgbWF0cml4IGlzIGFzc3VtZWQgdG8gYmUgb3J0aG9nb25hbFxyXG5cclxuXHRcdFx0bGV0IHRBID0gYTtcclxuXHRcdFx0bGV0IHRCID0gYjtcclxuXHJcblx0XHRcdGlmICggYnVpbGRlci5pc01hdHJpeCggdEEuZ2V0Tm9kZVR5cGUoIGJ1aWxkZXIgKSApICkge1xyXG5cclxuXHRcdFx0XHR0QiA9IHZlYzQoIHZlYzMoIHRCICksIDAuMCApO1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0dEEgPSB2ZWM0KCB2ZWMzKCB0QSApLCAwLjAgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGNvbnN0IG11bE5vZGUgPSBtdWwoIHRBLCB0QiApLnh5ejtcclxuXHJcblx0XHRcdHJldHVybiBub3JtYWxpemUoIG11bE5vZGUgKS5idWlsZCggYnVpbGRlciwgb3V0cHV0ICk7XHJcblxyXG5cdFx0fSBlbHNlIGlmICggbWV0aG9kID09PSBNYXRoTm9kZS5ORUdBVEUgKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gYnVpbGRlci5mb3JtYXQoICcoIC0gJyArIGEuYnVpbGQoIGJ1aWxkZXIsIGlucHV0VHlwZSApICsgJyApJywgdHlwZSwgb3V0cHV0ICk7XHJcblxyXG5cdFx0fSBlbHNlIGlmICggbWV0aG9kID09PSBNYXRoTm9kZS5PTkVfTUlOVVMgKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gc3ViKCAxLjAsIGEgKS5idWlsZCggYnVpbGRlciwgb3V0cHV0ICk7XHJcblxyXG5cdFx0fSBlbHNlIGlmICggbWV0aG9kID09PSBNYXRoTm9kZS5SRUNJUFJPQ0FMICkge1xyXG5cclxuXHRcdFx0cmV0dXJuIGRpdiggMS4wLCBhICkuYnVpbGQoIGJ1aWxkZXIsIG91dHB1dCApO1xyXG5cclxuXHRcdH0gZWxzZSBpZiAoIG1ldGhvZCA9PT0gTWF0aE5vZGUuRElGRkVSRU5DRSApIHtcclxuXHJcblx0XHRcdHJldHVybiBhYnMoIHN1YiggYSwgYiApICkuYnVpbGQoIGJ1aWxkZXIsIG91dHB1dCApO1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRjb25zdCBwYXJhbXMgPSBbXTtcclxuXHJcblx0XHRcdGlmICggbWV0aG9kID09PSBNYXRoTm9kZS5DUk9TUyB8fCBtZXRob2QgPT09IE1hdGhOb2RlLk1PRCApIHtcclxuXHJcblx0XHRcdFx0cGFyYW1zLnB1c2goXHJcblx0XHRcdFx0XHRhLmJ1aWxkKCBidWlsZGVyLCB0eXBlICksXHJcblx0XHRcdFx0XHRiLmJ1aWxkKCBidWlsZGVyLCB0eXBlIClcclxuXHRcdFx0XHQpO1xyXG5cclxuXHRcdFx0fSBlbHNlIGlmICggaXNXZWJHTCAmJiBtZXRob2QgPT09IE1hdGhOb2RlLlNURVAgKSB7XHJcblxyXG5cdFx0XHRcdHBhcmFtcy5wdXNoKFxyXG5cdFx0XHRcdFx0YS5idWlsZCggYnVpbGRlciwgYnVpbGRlci5nZXRUeXBlTGVuZ3RoKCBhLmdldE5vZGVUeXBlKCBidWlsZGVyICkgKSA9PT0gMSA/ICdmbG9hdCcgOiBpbnB1dFR5cGUgKSxcclxuXHRcdFx0XHRcdGIuYnVpbGQoIGJ1aWxkZXIsIGlucHV0VHlwZSApXHJcblx0XHRcdFx0KTtcclxuXHJcblx0XHRcdH0gZWxzZSBpZiAoICggaXNXZWJHTCAmJiAoIG1ldGhvZCA9PT0gTWF0aE5vZGUuTUlOIHx8IG1ldGhvZCA9PT0gTWF0aE5vZGUuTUFYICkgKSB8fCBtZXRob2QgPT09IE1hdGhOb2RlLk1PRCApIHtcclxuXHJcblx0XHRcdFx0cGFyYW1zLnB1c2goXHJcblx0XHRcdFx0XHRhLmJ1aWxkKCBidWlsZGVyLCBpbnB1dFR5cGUgKSxcclxuXHRcdFx0XHRcdGIuYnVpbGQoIGJ1aWxkZXIsIGJ1aWxkZXIuZ2V0VHlwZUxlbmd0aCggYi5nZXROb2RlVHlwZSggYnVpbGRlciApICkgPT09IDEgPyAnZmxvYXQnIDogaW5wdXRUeXBlIClcclxuXHRcdFx0XHQpO1xyXG5cclxuXHRcdFx0fSBlbHNlIGlmICggbWV0aG9kID09PSBNYXRoTm9kZS5SRUZSQUNUICkge1xyXG5cclxuXHRcdFx0XHRwYXJhbXMucHVzaChcclxuXHRcdFx0XHRcdGEuYnVpbGQoIGJ1aWxkZXIsIGlucHV0VHlwZSApLFxyXG5cdFx0XHRcdFx0Yi5idWlsZCggYnVpbGRlciwgaW5wdXRUeXBlICksXHJcblx0XHRcdFx0XHRjLmJ1aWxkKCBidWlsZGVyLCAnZmxvYXQnIClcclxuXHRcdFx0XHQpO1xyXG5cclxuXHRcdFx0fSBlbHNlIGlmICggbWV0aG9kID09PSBNYXRoTm9kZS5NSVggKSB7XHJcblxyXG5cdFx0XHRcdHBhcmFtcy5wdXNoKFxyXG5cdFx0XHRcdFx0YS5idWlsZCggYnVpbGRlciwgaW5wdXRUeXBlICksXHJcblx0XHRcdFx0XHRiLmJ1aWxkKCBidWlsZGVyLCBpbnB1dFR5cGUgKSxcclxuXHRcdFx0XHRcdGMuYnVpbGQoIGJ1aWxkZXIsIGJ1aWxkZXIuZ2V0VHlwZUxlbmd0aCggYy5nZXROb2RlVHlwZSggYnVpbGRlciApICkgPT09IDEgPyAnZmxvYXQnIDogaW5wdXRUeXBlIClcclxuXHRcdFx0XHQpO1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0cGFyYW1zLnB1c2goIGEuYnVpbGQoIGJ1aWxkZXIsIGlucHV0VHlwZSApICk7XHJcblx0XHRcdFx0aWYgKCBiICE9PSBudWxsICkgcGFyYW1zLnB1c2goIGIuYnVpbGQoIGJ1aWxkZXIsIGlucHV0VHlwZSApICk7XHJcblx0XHRcdFx0aWYgKCBjICE9PSBudWxsICkgcGFyYW1zLnB1c2goIGMuYnVpbGQoIGJ1aWxkZXIsIGlucHV0VHlwZSApICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRyZXR1cm4gYnVpbGRlci5mb3JtYXQoIGAkeyBidWlsZGVyLmdldE1ldGhvZCggbWV0aG9kLCB0eXBlICkgfSggJHtwYXJhbXMuam9pbiggJywgJyApfSApYCwgdHlwZSwgb3V0cHV0ICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdHNlcmlhbGl6ZSggZGF0YSApIHtcclxuXHJcblx0XHRzdXBlci5zZXJpYWxpemUoIGRhdGEgKTtcclxuXHJcblx0XHRkYXRhLm1ldGhvZCA9IHRoaXMubWV0aG9kO1xyXG5cclxuXHR9XHJcblxyXG5cdGRlc2VyaWFsaXplKCBkYXRhICkge1xyXG5cclxuXHRcdHN1cGVyLmRlc2VyaWFsaXplKCBkYXRhICk7XHJcblxyXG5cdFx0dGhpcy5tZXRob2QgPSBkYXRhLm1ldGhvZDtcclxuXHJcblx0fVxyXG5cclxufVxyXG5cclxuLy8gMSBpbnB1dFxyXG5cclxuTWF0aE5vZGUuQUxMID0gJ2FsbCc7XHJcbk1hdGhOb2RlLkFOWSA9ICdhbnknO1xyXG5NYXRoTm9kZS5FUVVBTFMgPSAnZXF1YWxzJztcclxuXHJcbk1hdGhOb2RlLlJBRElBTlMgPSAncmFkaWFucyc7XHJcbk1hdGhOb2RlLkRFR1JFRVMgPSAnZGVncmVlcyc7XHJcbk1hdGhOb2RlLkVYUCA9ICdleHAnO1xyXG5NYXRoTm9kZS5FWFAyID0gJ2V4cDInO1xyXG5NYXRoTm9kZS5MT0cgPSAnbG9nJztcclxuTWF0aE5vZGUuTE9HMiA9ICdsb2cyJztcclxuTWF0aE5vZGUuU1FSVCA9ICdzcXJ0JztcclxuTWF0aE5vZGUuSU5WRVJTRV9TUVJUID0gJ2ludmVyc2VzcXJ0JztcclxuTWF0aE5vZGUuRkxPT1IgPSAnZmxvb3InO1xyXG5NYXRoTm9kZS5DRUlMID0gJ2NlaWwnO1xyXG5NYXRoTm9kZS5OT1JNQUxJWkUgPSAnbm9ybWFsaXplJztcclxuTWF0aE5vZGUuRlJBQ1QgPSAnZnJhY3QnO1xyXG5NYXRoTm9kZS5TSU4gPSAnc2luJztcclxuTWF0aE5vZGUuQ09TID0gJ2Nvcyc7XHJcbk1hdGhOb2RlLlRBTiA9ICd0YW4nO1xyXG5NYXRoTm9kZS5BU0lOID0gJ2FzaW4nO1xyXG5NYXRoTm9kZS5BQ09TID0gJ2Fjb3MnO1xyXG5NYXRoTm9kZS5BVEFOID0gJ2F0YW4nO1xyXG5NYXRoTm9kZS5BQlMgPSAnYWJzJztcclxuTWF0aE5vZGUuU0lHTiA9ICdzaWduJztcclxuTWF0aE5vZGUuTEVOR1RIID0gJ2xlbmd0aCc7XHJcbk1hdGhOb2RlLk5FR0FURSA9ICduZWdhdGUnO1xyXG5NYXRoTm9kZS5PTkVfTUlOVVMgPSAnb25lTWludXMnO1xyXG5NYXRoTm9kZS5ERkRYID0gJ2RGZHgnO1xyXG5NYXRoTm9kZS5ERkRZID0gJ2RGZHknO1xyXG5NYXRoTm9kZS5ST1VORCA9ICdyb3VuZCc7XHJcbk1hdGhOb2RlLlJFQ0lQUk9DQUwgPSAncmVjaXByb2NhbCc7XHJcbk1hdGhOb2RlLlRSVU5DID0gJ3RydW5jJztcclxuTWF0aE5vZGUuRldJRFRIID0gJ2Z3aWR0aCc7XHJcbk1hdGhOb2RlLkJJVENBU1QgPSAnYml0Y2FzdCc7XHJcbk1hdGhOb2RlLlRSQU5TUE9TRSA9ICd0cmFuc3Bvc2UnO1xyXG5cclxuLy8gMiBpbnB1dHNcclxuXHJcbk1hdGhOb2RlLkFUQU4yID0gJ2F0YW4yJztcclxuTWF0aE5vZGUuTUlOID0gJ21pbic7XHJcbk1hdGhOb2RlLk1BWCA9ICdtYXgnO1xyXG5NYXRoTm9kZS5NT0QgPSAnbW9kJztcclxuTWF0aE5vZGUuU1RFUCA9ICdzdGVwJztcclxuTWF0aE5vZGUuUkVGTEVDVCA9ICdyZWZsZWN0JztcclxuTWF0aE5vZGUuRElTVEFOQ0UgPSAnZGlzdGFuY2UnO1xyXG5NYXRoTm9kZS5ESUZGRVJFTkNFID0gJ2RpZmZlcmVuY2UnO1xyXG5NYXRoTm9kZS5ET1QgPSAnZG90JztcclxuTWF0aE5vZGUuQ1JPU1MgPSAnY3Jvc3MnO1xyXG5NYXRoTm9kZS5QT1cgPSAncG93JztcclxuTWF0aE5vZGUuVFJBTlNGT1JNX0RJUkVDVElPTiA9ICd0cmFuc2Zvcm1EaXJlY3Rpb24nO1xyXG5cclxuLy8gMyBpbnB1dHNcclxuXHJcbk1hdGhOb2RlLk1JWCA9ICdtaXgnO1xyXG5NYXRoTm9kZS5DTEFNUCA9ICdjbGFtcCc7XHJcbk1hdGhOb2RlLlJFRlJBQ1QgPSAncmVmcmFjdCc7XHJcbk1hdGhOb2RlLlNNT09USFNURVAgPSAnc21vb3Roc3RlcCc7XHJcbk1hdGhOb2RlLkZBQ0VGT1JXQVJEID0gJ2ZhY2Vmb3J3YXJkJztcclxuXHJcbmV4cG9ydCBkZWZhdWx0IE1hdGhOb2RlO1xyXG5cclxuZXhwb3J0IGNvbnN0IEVQU0lMT04gPSAvKkBfX1BVUkVfXyovIGZsb2F0KCAxZS02ICk7XHJcbmV4cG9ydCBjb25zdCBJTkZJTklUWSA9IC8qQF9fUFVSRV9fKi8gZmxvYXQoIDFlNiApO1xyXG5leHBvcnQgY29uc3QgUEkgPSAvKkBfX1BVUkVfXyovIGZsb2F0KCBNYXRoLlBJICk7XHJcbmV4cG9ydCBjb25zdCBQSTIgPSAvKkBfX1BVUkVfXyovIGZsb2F0KCBNYXRoLlBJICogMiApO1xyXG5cclxuZXhwb3J0IGNvbnN0IGFsbCA9IC8qQF9fUFVSRV9fKi8gbm9kZVByb3h5KCBNYXRoTm9kZSwgTWF0aE5vZGUuQUxMICk7XHJcbmV4cG9ydCBjb25zdCBhbnkgPSAvKkBfX1BVUkVfXyovIG5vZGVQcm94eSggTWF0aE5vZGUsIE1hdGhOb2RlLkFOWSApO1xyXG5leHBvcnQgY29uc3QgZXF1YWxzID0gLypAX19QVVJFX18qLyBub2RlUHJveHkoIE1hdGhOb2RlLCBNYXRoTm9kZS5FUVVBTFMgKTtcclxuXHJcbmV4cG9ydCBjb25zdCByYWRpYW5zID0gLypAX19QVVJFX18qLyBub2RlUHJveHkoIE1hdGhOb2RlLCBNYXRoTm9kZS5SQURJQU5TICk7XHJcbmV4cG9ydCBjb25zdCBkZWdyZWVzID0gLypAX19QVVJFX18qLyBub2RlUHJveHkoIE1hdGhOb2RlLCBNYXRoTm9kZS5ERUdSRUVTICk7XHJcbmV4cG9ydCBjb25zdCBleHAgPSAvKkBfX1BVUkVfXyovIG5vZGVQcm94eSggTWF0aE5vZGUsIE1hdGhOb2RlLkVYUCApO1xyXG5leHBvcnQgY29uc3QgZXhwMiA9IC8qQF9fUFVSRV9fKi8gbm9kZVByb3h5KCBNYXRoTm9kZSwgTWF0aE5vZGUuRVhQMiApO1xyXG5leHBvcnQgY29uc3QgbG9nID0gLypAX19QVVJFX18qLyBub2RlUHJveHkoIE1hdGhOb2RlLCBNYXRoTm9kZS5MT0cgKTtcclxuZXhwb3J0IGNvbnN0IGxvZzIgPSAvKkBfX1BVUkVfXyovIG5vZGVQcm94eSggTWF0aE5vZGUsIE1hdGhOb2RlLkxPRzIgKTtcclxuZXhwb3J0IGNvbnN0IHNxcnQgPSAvKkBfX1BVUkVfXyovIG5vZGVQcm94eSggTWF0aE5vZGUsIE1hdGhOb2RlLlNRUlQgKTtcclxuZXhwb3J0IGNvbnN0IGludmVyc2VTcXJ0ID0gLypAX19QVVJFX18qLyBub2RlUHJveHkoIE1hdGhOb2RlLCBNYXRoTm9kZS5JTlZFUlNFX1NRUlQgKTtcclxuZXhwb3J0IGNvbnN0IGZsb29yID0gLypAX19QVVJFX18qLyBub2RlUHJveHkoIE1hdGhOb2RlLCBNYXRoTm9kZS5GTE9PUiApO1xyXG5leHBvcnQgY29uc3QgY2VpbCA9IC8qQF9fUFVSRV9fKi8gbm9kZVByb3h5KCBNYXRoTm9kZSwgTWF0aE5vZGUuQ0VJTCApO1xyXG5leHBvcnQgY29uc3Qgbm9ybWFsaXplID0gLypAX19QVVJFX18qLyBub2RlUHJveHkoIE1hdGhOb2RlLCBNYXRoTm9kZS5OT1JNQUxJWkUgKTtcclxuZXhwb3J0IGNvbnN0IGZyYWN0ID0gLypAX19QVVJFX18qLyBub2RlUHJveHkoIE1hdGhOb2RlLCBNYXRoTm9kZS5GUkFDVCApO1xyXG5leHBvcnQgY29uc3Qgc2luID0gLypAX19QVVJFX18qLyBub2RlUHJveHkoIE1hdGhOb2RlLCBNYXRoTm9kZS5TSU4gKTtcclxuZXhwb3J0IGNvbnN0IGNvcyA9IC8qQF9fUFVSRV9fKi8gbm9kZVByb3h5KCBNYXRoTm9kZSwgTWF0aE5vZGUuQ09TICk7XHJcbmV4cG9ydCBjb25zdCB0YW4gPSAvKkBfX1BVUkVfXyovIG5vZGVQcm94eSggTWF0aE5vZGUsIE1hdGhOb2RlLlRBTiApO1xyXG5leHBvcnQgY29uc3QgYXNpbiA9IC8qQF9fUFVSRV9fKi8gbm9kZVByb3h5KCBNYXRoTm9kZSwgTWF0aE5vZGUuQVNJTiApO1xyXG5leHBvcnQgY29uc3QgYWNvcyA9IC8qQF9fUFVSRV9fKi8gbm9kZVByb3h5KCBNYXRoTm9kZSwgTWF0aE5vZGUuQUNPUyApO1xyXG5leHBvcnQgY29uc3QgYXRhbiA9IC8qQF9fUFVSRV9fKi8gbm9kZVByb3h5KCBNYXRoTm9kZSwgTWF0aE5vZGUuQVRBTiApO1xyXG5leHBvcnQgY29uc3QgYWJzID0gLypAX19QVVJFX18qLyBub2RlUHJveHkoIE1hdGhOb2RlLCBNYXRoTm9kZS5BQlMgKTtcclxuZXhwb3J0IGNvbnN0IHNpZ24gPSAvKkBfX1BVUkVfXyovIG5vZGVQcm94eSggTWF0aE5vZGUsIE1hdGhOb2RlLlNJR04gKTtcclxuZXhwb3J0IGNvbnN0IGxlbmd0aCA9IC8qQF9fUFVSRV9fKi8gbm9kZVByb3h5KCBNYXRoTm9kZSwgTWF0aE5vZGUuTEVOR1RIICk7XHJcbmV4cG9ydCBjb25zdCBuZWdhdGUgPSAvKkBfX1BVUkVfXyovIG5vZGVQcm94eSggTWF0aE5vZGUsIE1hdGhOb2RlLk5FR0FURSApO1xyXG5leHBvcnQgY29uc3Qgb25lTWludXMgPSAvKkBfX1BVUkVfXyovIG5vZGVQcm94eSggTWF0aE5vZGUsIE1hdGhOb2RlLk9ORV9NSU5VUyApO1xyXG5leHBvcnQgY29uc3QgZEZkeCA9IC8qQF9fUFVSRV9fKi8gbm9kZVByb3h5KCBNYXRoTm9kZSwgTWF0aE5vZGUuREZEWCApO1xyXG5leHBvcnQgY29uc3QgZEZkeSA9IC8qQF9fUFVSRV9fKi8gbm9kZVByb3h5KCBNYXRoTm9kZSwgTWF0aE5vZGUuREZEWSApO1xyXG5leHBvcnQgY29uc3Qgcm91bmQgPSAvKkBfX1BVUkVfXyovIG5vZGVQcm94eSggTWF0aE5vZGUsIE1hdGhOb2RlLlJPVU5EICk7XHJcbmV4cG9ydCBjb25zdCByZWNpcHJvY2FsID0gLypAX19QVVJFX18qLyBub2RlUHJveHkoIE1hdGhOb2RlLCBNYXRoTm9kZS5SRUNJUFJPQ0FMICk7XHJcbmV4cG9ydCBjb25zdCB0cnVuYyA9IC8qQF9fUFVSRV9fKi8gbm9kZVByb3h5KCBNYXRoTm9kZSwgTWF0aE5vZGUuVFJVTkMgKTtcclxuZXhwb3J0IGNvbnN0IGZ3aWR0aCA9IC8qQF9fUFVSRV9fKi8gbm9kZVByb3h5KCBNYXRoTm9kZSwgTWF0aE5vZGUuRldJRFRIICk7XHJcbmV4cG9ydCBjb25zdCBiaXRjYXN0ID0gLypAX19QVVJFX18qLyBub2RlUHJveHkoIE1hdGhOb2RlLCBNYXRoTm9kZS5CSVRDQVNUICk7XHJcbmV4cG9ydCBjb25zdCB0cmFuc3Bvc2UgPSAvKkBfX1BVUkVfXyovIG5vZGVQcm94eSggTWF0aE5vZGUsIE1hdGhOb2RlLlRSQU5TUE9TRSApO1xyXG5cclxuZXhwb3J0IGNvbnN0IGF0YW4yID0gLypAX19QVVJFX18qLyBub2RlUHJveHkoIE1hdGhOb2RlLCBNYXRoTm9kZS5BVEFOMiApO1xyXG5leHBvcnQgY29uc3QgbWluID0gLypAX19QVVJFX18qLyBub2RlUHJveHkoIE1hdGhOb2RlLCBNYXRoTm9kZS5NSU4gKTtcclxuZXhwb3J0IGNvbnN0IG1heCA9IC8qQF9fUFVSRV9fKi8gbm9kZVByb3h5KCBNYXRoTm9kZSwgTWF0aE5vZGUuTUFYICk7XHJcbmV4cG9ydCBjb25zdCBtb2QgPSAvKkBfX1BVUkVfXyovIG5vZGVQcm94eSggTWF0aE5vZGUsIE1hdGhOb2RlLk1PRCApO1xyXG5leHBvcnQgY29uc3Qgc3RlcCA9IC8qQF9fUFVSRV9fKi8gbm9kZVByb3h5KCBNYXRoTm9kZSwgTWF0aE5vZGUuU1RFUCApO1xyXG5leHBvcnQgY29uc3QgcmVmbGVjdCA9IC8qQF9fUFVSRV9fKi8gbm9kZVByb3h5KCBNYXRoTm9kZSwgTWF0aE5vZGUuUkVGTEVDVCApO1xyXG5leHBvcnQgY29uc3QgZGlzdGFuY2UgPSAvKkBfX1BVUkVfXyovIG5vZGVQcm94eSggTWF0aE5vZGUsIE1hdGhOb2RlLkRJU1RBTkNFICk7XHJcbmV4cG9ydCBjb25zdCBkaWZmZXJlbmNlID0gLypAX19QVVJFX18qLyBub2RlUHJveHkoIE1hdGhOb2RlLCBNYXRoTm9kZS5ESUZGRVJFTkNFICk7XHJcbmV4cG9ydCBjb25zdCBkb3QgPSAvKkBfX1BVUkVfXyovIG5vZGVQcm94eSggTWF0aE5vZGUsIE1hdGhOb2RlLkRPVCApO1xyXG5leHBvcnQgY29uc3QgY3Jvc3MgPSAvKkBfX1BVUkVfXyovIG5vZGVQcm94eSggTWF0aE5vZGUsIE1hdGhOb2RlLkNST1NTICk7XHJcbmV4cG9ydCBjb25zdCBwb3cgPSAvKkBfX1BVUkVfXyovIG5vZGVQcm94eSggTWF0aE5vZGUsIE1hdGhOb2RlLlBPVyApO1xyXG5leHBvcnQgY29uc3QgcG93MiA9IC8qQF9fUFVSRV9fKi8gbm9kZVByb3h5KCBNYXRoTm9kZSwgTWF0aE5vZGUuUE9XLCAyICk7XHJcbmV4cG9ydCBjb25zdCBwb3czID0gLypAX19QVVJFX18qLyBub2RlUHJveHkoIE1hdGhOb2RlLCBNYXRoTm9kZS5QT1csIDMgKTtcclxuZXhwb3J0IGNvbnN0IHBvdzQgPSAvKkBfX1BVUkVfXyovIG5vZGVQcm94eSggTWF0aE5vZGUsIE1hdGhOb2RlLlBPVywgNCApO1xyXG5leHBvcnQgY29uc3QgdHJhbnNmb3JtRGlyZWN0aW9uID0gLypAX19QVVJFX18qLyBub2RlUHJveHkoIE1hdGhOb2RlLCBNYXRoTm9kZS5UUkFOU0ZPUk1fRElSRUNUSU9OICk7XHJcblxyXG5leHBvcnQgY29uc3QgY2JydCA9ICggYSApID0+IG11bCggc2lnbiggYSApLCBwb3coIGFicyggYSApLCAxLjAgLyAzLjAgKSApO1xyXG5leHBvcnQgY29uc3QgbGVuZ3RoU3EgPSAoIGEgKSA9PiBkb3QoIGEsIGEgKTtcclxuZXhwb3J0IGNvbnN0IG1peCA9IC8qQF9fUFVSRV9fKi8gbm9kZVByb3h5KCBNYXRoTm9kZSwgTWF0aE5vZGUuTUlYICk7XHJcbmV4cG9ydCBjb25zdCBjbGFtcCA9ICggdmFsdWUsIGxvdyA9IDAsIGhpZ2ggPSAxICkgPT4gbm9kZU9iamVjdCggbmV3IE1hdGhOb2RlKCBNYXRoTm9kZS5DTEFNUCwgbm9kZU9iamVjdCggdmFsdWUgKSwgbm9kZU9iamVjdCggbG93ICksIG5vZGVPYmplY3QoIGhpZ2ggKSApICk7XHJcbmV4cG9ydCBjb25zdCBzYXR1cmF0ZSA9ICggdmFsdWUgKSA9PiBjbGFtcCggdmFsdWUgKTtcclxuZXhwb3J0IGNvbnN0IHJlZnJhY3QgPSAvKkBfX1BVUkVfXyovIG5vZGVQcm94eSggTWF0aE5vZGUsIE1hdGhOb2RlLlJFRlJBQ1QgKTtcclxuZXhwb3J0IGNvbnN0IHNtb290aHN0ZXAgPSAvKkBfX1BVUkVfXyovIG5vZGVQcm94eSggTWF0aE5vZGUsIE1hdGhOb2RlLlNNT09USFNURVAgKTtcclxuZXhwb3J0IGNvbnN0IGZhY2VGb3J3YXJkID0gLypAX19QVVJFX18qLyBub2RlUHJveHkoIE1hdGhOb2RlLCBNYXRoTm9kZS5GQUNFRk9SV0FSRCApO1xyXG5cclxuZXhwb3J0IGNvbnN0IHJhbmQgPSAvKkBfX1BVUkVfXyovIEZuKCAoIFsgdXYgXSApID0+IHtcclxuXHJcblx0Y29uc3QgYSA9IDEyLjk4OTgsIGIgPSA3OC4yMzMsIGMgPSA0Mzc1OC41NDUzO1xyXG5cdGNvbnN0IGR0ID0gZG90KCB1di54eSwgdmVjMiggYSwgYiApICksIHNuID0gbW9kKCBkdCwgUEkgKTtcclxuXHJcblx0cmV0dXJuIGZyYWN0KCBzaW4oIHNuICkubXVsKCBjICkgKTtcclxuXHJcbn0gKTtcclxuXHJcbmV4cG9ydCBjb25zdCBtaXhFbGVtZW50ID0gKCB0LCBlMSwgZTIgKSA9PiBtaXgoIGUxLCBlMiwgdCApO1xyXG5leHBvcnQgY29uc3Qgc21vb3Roc3RlcEVsZW1lbnQgPSAoIHgsIGxvdywgaGlnaCApID0+IHNtb290aHN0ZXAoIGxvdywgaGlnaCwgeCApO1xyXG5cclxuYWRkTWV0aG9kQ2hhaW5pbmcoICdhbGwnLCBhbGwgKTtcclxuYWRkTWV0aG9kQ2hhaW5pbmcoICdhbnknLCBhbnkgKTtcclxuYWRkTWV0aG9kQ2hhaW5pbmcoICdlcXVhbHMnLCBlcXVhbHMgKTtcclxuXHJcbmFkZE1ldGhvZENoYWluaW5nKCAncmFkaWFucycsIHJhZGlhbnMgKTtcclxuYWRkTWV0aG9kQ2hhaW5pbmcoICdkZWdyZWVzJywgZGVncmVlcyApO1xyXG5hZGRNZXRob2RDaGFpbmluZyggJ2V4cCcsIGV4cCApO1xyXG5hZGRNZXRob2RDaGFpbmluZyggJ2V4cDInLCBleHAyICk7XHJcbmFkZE1ldGhvZENoYWluaW5nKCAnbG9nJywgbG9nICk7XHJcbmFkZE1ldGhvZENoYWluaW5nKCAnbG9nMicsIGxvZzIgKTtcclxuYWRkTWV0aG9kQ2hhaW5pbmcoICdzcXJ0Jywgc3FydCApO1xyXG5hZGRNZXRob2RDaGFpbmluZyggJ2ludmVyc2VTcXJ0JywgaW52ZXJzZVNxcnQgKTtcclxuYWRkTWV0aG9kQ2hhaW5pbmcoICdmbG9vcicsIGZsb29yICk7XHJcbmFkZE1ldGhvZENoYWluaW5nKCAnY2VpbCcsIGNlaWwgKTtcclxuYWRkTWV0aG9kQ2hhaW5pbmcoICdub3JtYWxpemUnLCBub3JtYWxpemUgKTtcclxuYWRkTWV0aG9kQ2hhaW5pbmcoICdmcmFjdCcsIGZyYWN0ICk7XHJcbmFkZE1ldGhvZENoYWluaW5nKCAnc2luJywgc2luICk7XHJcbmFkZE1ldGhvZENoYWluaW5nKCAnY29zJywgY29zICk7XHJcbmFkZE1ldGhvZENoYWluaW5nKCAndGFuJywgdGFuICk7XHJcbmFkZE1ldGhvZENoYWluaW5nKCAnYXNpbicsIGFzaW4gKTtcclxuYWRkTWV0aG9kQ2hhaW5pbmcoICdhY29zJywgYWNvcyApO1xyXG5hZGRNZXRob2RDaGFpbmluZyggJ2F0YW4nLCBhdGFuICk7XHJcbmFkZE1ldGhvZENoYWluaW5nKCAnYWJzJywgYWJzICk7XHJcbmFkZE1ldGhvZENoYWluaW5nKCAnc2lnbicsIHNpZ24gKTtcclxuYWRkTWV0aG9kQ2hhaW5pbmcoICdsZW5ndGgnLCBsZW5ndGggKTtcclxuYWRkTWV0aG9kQ2hhaW5pbmcoICdsZW5ndGhTcScsIGxlbmd0aFNxICk7XHJcbmFkZE1ldGhvZENoYWluaW5nKCAnbmVnYXRlJywgbmVnYXRlICk7XHJcbmFkZE1ldGhvZENoYWluaW5nKCAnb25lTWludXMnLCBvbmVNaW51cyApO1xyXG5hZGRNZXRob2RDaGFpbmluZyggJ2RGZHgnLCBkRmR4ICk7XHJcbmFkZE1ldGhvZENoYWluaW5nKCAnZEZkeScsIGRGZHkgKTtcclxuYWRkTWV0aG9kQ2hhaW5pbmcoICdyb3VuZCcsIHJvdW5kICk7XHJcbmFkZE1ldGhvZENoYWluaW5nKCAncmVjaXByb2NhbCcsIHJlY2lwcm9jYWwgKTtcclxuYWRkTWV0aG9kQ2hhaW5pbmcoICd0cnVuYycsIHRydW5jICk7XHJcbmFkZE1ldGhvZENoYWluaW5nKCAnZndpZHRoJywgZndpZHRoICk7XHJcbmFkZE1ldGhvZENoYWluaW5nKCAnYXRhbjInLCBhdGFuMiApO1xyXG5hZGRNZXRob2RDaGFpbmluZyggJ21pbicsIG1pbiApO1xyXG5hZGRNZXRob2RDaGFpbmluZyggJ21heCcsIG1heCApO1xyXG5hZGRNZXRob2RDaGFpbmluZyggJ21vZCcsIG1vZCApO1xyXG5hZGRNZXRob2RDaGFpbmluZyggJ3N0ZXAnLCBzdGVwICk7XHJcbmFkZE1ldGhvZENoYWluaW5nKCAncmVmbGVjdCcsIHJlZmxlY3QgKTtcclxuYWRkTWV0aG9kQ2hhaW5pbmcoICdkaXN0YW5jZScsIGRpc3RhbmNlICk7XHJcbmFkZE1ldGhvZENoYWluaW5nKCAnZG90JywgZG90ICk7XHJcbmFkZE1ldGhvZENoYWluaW5nKCAnY3Jvc3MnLCBjcm9zcyApO1xyXG5hZGRNZXRob2RDaGFpbmluZyggJ3BvdycsIHBvdyApO1xyXG5hZGRNZXRob2RDaGFpbmluZyggJ3BvdzInLCBwb3cyICk7XHJcbmFkZE1ldGhvZENoYWluaW5nKCAncG93MycsIHBvdzMgKTtcclxuYWRkTWV0aG9kQ2hhaW5pbmcoICdwb3c0JywgcG93NCApO1xyXG5hZGRNZXRob2RDaGFpbmluZyggJ3RyYW5zZm9ybURpcmVjdGlvbicsIHRyYW5zZm9ybURpcmVjdGlvbiApO1xyXG5hZGRNZXRob2RDaGFpbmluZyggJ21peCcsIG1peEVsZW1lbnQgKTtcclxuYWRkTWV0aG9kQ2hhaW5pbmcoICdjbGFtcCcsIGNsYW1wICk7XHJcbmFkZE1ldGhvZENoYWluaW5nKCAncmVmcmFjdCcsIHJlZnJhY3QgKTtcclxuYWRkTWV0aG9kQ2hhaW5pbmcoICdzbW9vdGhzdGVwJywgc21vb3Roc3RlcEVsZW1lbnQgKTtcclxuYWRkTWV0aG9kQ2hhaW5pbmcoICdmYWNlRm9yd2FyZCcsIGZhY2VGb3J3YXJkICk7XHJcbmFkZE1ldGhvZENoYWluaW5nKCAnZGlmZmVyZW5jZScsIGRpZmZlcmVuY2UgKTtcclxuYWRkTWV0aG9kQ2hhaW5pbmcoICdzYXR1cmF0ZScsIHNhdHVyYXRlICk7XHJcbmFkZE1ldGhvZENoYWluaW5nKCAnY2JydCcsIGNicnQgKTtcclxuYWRkTWV0aG9kQ2hhaW5pbmcoICd0cmFuc3Bvc2UnLCB0cmFuc3Bvc2UgKTtcclxuYWRkTWV0aG9kQ2hhaW5pbmcoICdyYW5kJywgcmFuZCApO1xyXG4iLCJpbXBvcnQgTm9kZSBmcm9tICcuLi9jb3JlL05vZGUuanMnO1xyXG5pbXBvcnQgeyBwcm9wZXJ0eSB9IGZyb20gJy4uL2NvcmUvUHJvcGVydHlOb2RlLmpzJztcclxuaW1wb3J0IHsgYWRkTWV0aG9kQ2hhaW5pbmcsIG5vZGVQcm94eSB9IGZyb20gJy4uL3RzbC9UU0xDb3JlLmpzJztcclxuXHJcbi8qKiBAbW9kdWxlIENvbmRpdGlvbmFsTm9kZSAqKi9cclxuXHJcbi8qKlxyXG4gKiBSZXByZXNlbnRzIGEgbG9naWNhbCBgaWYvZWxzZWAgc3RhdGVtZW50LiBDYW4gYmUgdXNlZCBhcyBhbiBhbHRlcm5hdGl2ZVxyXG4gKiB0byB0aGUgYElmKClgL2BFbHNlKClgIHN5bnRheC5cclxuICpcclxuICogVGhlIGNvcnJlc3BvbmRpbmcgVFNMIGBzZWxlY3QoKWAgbG9va3MgbGlrZSBzbzpcclxuICogYGBganNcclxuICogdmVsb2NpdHkgPSBwb3NpdGlvbi5ncmVhdGVyVGhhbkVxdWFsKCBsaW1pdCApLnNlbGVjdCggdmVsb2NpdHkubmVnYXRlKCksIHZlbG9jaXR5ICk7XHJcbiAqIGBgYFxyXG4gKiBUaGUgYHNlbGVjdCgpYCBtZXRob2QgaXMgY2FsbGVkIGluIGEgY2hhaW5pbmcgZmFzaGlvbiBvbiBhIGNvbmRpdGlvbi4gVGhlIHBhcmFtZXRlciBub2RlcyBvZiBgc2VsZWN0KClgXHJcbiAqIGRldGVybWluZSB0aGUgb3V0Y29tZSBvZiB0aGUgZW50aXJlIHN0YXRlbWVudC5cclxuICpcclxuICogQGF1Z21lbnRzIE5vZGVcclxuICovXHJcbmNsYXNzIENvbmRpdGlvbmFsTm9kZSBleHRlbmRzIE5vZGUge1xyXG5cclxuXHRzdGF0aWMgZ2V0IHR5cGUoKSB7XHJcblxyXG5cdFx0cmV0dXJuICdDb25kaXRpb25hbE5vZGUnO1xyXG5cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIENvbnN0cnVjdHMgYSBuZXcgY29uZGl0aW9uYWwgbm9kZS5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7Tm9kZX0gY29uZE5vZGUgLSBUaGUgbm9kZSB0aGF0IGRlZmluZXMgdGhlIGNvbmRpdGlvbi5cclxuXHQgKiBAcGFyYW0ge05vZGV9IGlmTm9kZSAtIFRoZSBub2RlIHRoYXQgaXMgZXZhbHVhdGUgd2hlbiB0aGUgY29uZGl0aW9uIGVuZHMgdXAgYHRydWVgLlxyXG5cdCAqIEBwYXJhbSB7Tm9kZT99IFtlbHNlTm9kZT1udWxsXSAtIFRoZSBub2RlIHRoYXQgaXMgZXZhbHVhdGUgd2hlbiB0aGUgY29uZGl0aW9uIGVuZHMgdXAgYGZhbHNlYC5cclxuXHQgKi9cclxuXHRjb25zdHJ1Y3RvciggY29uZE5vZGUsIGlmTm9kZSwgZWxzZU5vZGUgPSBudWxsICkge1xyXG5cclxuXHRcdHN1cGVyKCk7XHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBUaGUgbm9kZSB0aGF0IGRlZmluZXMgdGhlIGNvbmRpdGlvbi5cclxuXHRcdCAqXHJcblx0XHQgKiBAdHlwZSB7Tm9kZX1cclxuXHRcdCAqL1xyXG5cdFx0dGhpcy5jb25kTm9kZSA9IGNvbmROb2RlO1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogVGhlIG5vZGUgdGhhdCBpcyBldmFsdWF0ZSB3aGVuIHRoZSBjb25kaXRpb24gZW5kcyB1cCBgdHJ1ZWAuXHJcblx0XHQgKlxyXG5cdFx0ICogQHR5cGUge05vZGV9XHJcblx0XHQgKi9cclxuXHRcdHRoaXMuaWZOb2RlID0gaWZOb2RlO1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogVGhlIG5vZGUgdGhhdCBpcyBldmFsdWF0ZSB3aGVuIHRoZSBjb25kaXRpb24gZW5kcyB1cCBgZmFsc2VgLlxyXG5cdFx0ICpcclxuXHRcdCAqIEB0eXBlIHtOb2RlP31cclxuXHRcdCAqIEBkZWZhdWx0IG51bGxcclxuXHRcdCAqL1xyXG5cdFx0dGhpcy5lbHNlTm9kZSA9IGVsc2VOb2RlO1xyXG5cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFRoaXMgbWV0aG9kIGlzIG92ZXJ3cml0dGVuIHNpbmNlIHRoZSBub2RlIHR5cGUgaXMgaW5mZXJyZWQgZnJvbSB0aGUgaWYvZWxzZVxyXG5cdCAqIG5vZGVzLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtOb2RlQnVpbGRlcn0gYnVpbGRlciAtIFRoZSBjdXJyZW50IG5vZGUgYnVpbGRlci5cclxuXHQgKiBAcmV0dXJuIHtTdHJpbmd9IFRoZSBub2RlIHR5cGUuXHJcblx0ICovXHJcblx0Z2V0Tm9kZVR5cGUoIGJ1aWxkZXIgKSB7XHJcblxyXG5cdFx0Y29uc3QgaWZUeXBlID0gdGhpcy5pZk5vZGUuZ2V0Tm9kZVR5cGUoIGJ1aWxkZXIgKTtcclxuXHJcblx0XHRpZiAoIHRoaXMuZWxzZU5vZGUgIT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHRjb25zdCBlbHNlVHlwZSA9IHRoaXMuZWxzZU5vZGUuZ2V0Tm9kZVR5cGUoIGJ1aWxkZXIgKTtcclxuXHJcblx0XHRcdGlmICggYnVpbGRlci5nZXRUeXBlTGVuZ3RoKCBlbHNlVHlwZSApID4gYnVpbGRlci5nZXRUeXBlTGVuZ3RoKCBpZlR5cGUgKSApIHtcclxuXHJcblx0XHRcdFx0cmV0dXJuIGVsc2VUeXBlO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gaWZUeXBlO1xyXG5cclxuXHR9XHJcblxyXG5cdHNldHVwKCBidWlsZGVyICkge1xyXG5cclxuXHRcdGNvbnN0IGNvbmROb2RlID0gdGhpcy5jb25kTm9kZS5jYWNoZSgpO1xyXG5cdFx0Y29uc3QgaWZOb2RlID0gdGhpcy5pZk5vZGUuY2FjaGUoKTtcclxuXHRcdGNvbnN0IGVsc2VOb2RlID0gdGhpcy5lbHNlTm9kZSA/IHRoaXMuZWxzZU5vZGUuY2FjaGUoKSA6IG51bGw7XHJcblxyXG5cdFx0Ly9cclxuXHJcblx0XHRjb25zdCBjdXJyZW50Tm9kZUJsb2NrID0gYnVpbGRlci5jb250ZXh0Lm5vZGVCbG9jaztcclxuXHJcblx0XHRidWlsZGVyLmdldERhdGFGcm9tTm9kZSggaWZOb2RlICkucGFyZW50Tm9kZUJsb2NrID0gY3VycmVudE5vZGVCbG9jaztcclxuXHRcdGlmICggZWxzZU5vZGUgIT09IG51bGwgKSBidWlsZGVyLmdldERhdGFGcm9tTm9kZSggZWxzZU5vZGUgKS5wYXJlbnROb2RlQmxvY2sgPSBjdXJyZW50Tm9kZUJsb2NrO1xyXG5cclxuXHRcdC8vXHJcblxyXG5cdFx0Y29uc3QgcHJvcGVydGllcyA9IGJ1aWxkZXIuZ2V0Tm9kZVByb3BlcnRpZXMoIHRoaXMgKTtcclxuXHRcdHByb3BlcnRpZXMuY29uZE5vZGUgPSBjb25kTm9kZTtcclxuXHRcdHByb3BlcnRpZXMuaWZOb2RlID0gaWZOb2RlLmNvbnRleHQoIHsgbm9kZUJsb2NrOiBpZk5vZGUgfSApO1xyXG5cdFx0cHJvcGVydGllcy5lbHNlTm9kZSA9IGVsc2VOb2RlID8gZWxzZU5vZGUuY29udGV4dCggeyBub2RlQmxvY2s6IGVsc2VOb2RlIH0gKSA6IG51bGw7XHJcblxyXG5cdH1cclxuXHJcblx0Z2VuZXJhdGUoIGJ1aWxkZXIsIG91dHB1dCApIHtcclxuXHJcblx0XHRjb25zdCB0eXBlID0gdGhpcy5nZXROb2RlVHlwZSggYnVpbGRlciApO1xyXG5cclxuXHRcdGNvbnN0IG5vZGVEYXRhID0gYnVpbGRlci5nZXREYXRhRnJvbU5vZGUoIHRoaXMgKTtcclxuXHJcblx0XHRpZiAoIG5vZGVEYXRhLm5vZGVQcm9wZXJ0eSAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0cmV0dXJuIG5vZGVEYXRhLm5vZGVQcm9wZXJ0eTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Y29uc3QgeyBjb25kTm9kZSwgaWZOb2RlLCBlbHNlTm9kZSB9ID0gYnVpbGRlci5nZXROb2RlUHJvcGVydGllcyggdGhpcyApO1xyXG5cclxuXHRcdGNvbnN0IG5lZWRzT3V0cHV0ID0gb3V0cHV0ICE9PSAndm9pZCc7XHJcblx0XHRjb25zdCBub2RlUHJvcGVydHkgPSBuZWVkc091dHB1dCA/IHByb3BlcnR5KCB0eXBlICkuYnVpbGQoIGJ1aWxkZXIgKSA6ICcnO1xyXG5cclxuXHRcdG5vZGVEYXRhLm5vZGVQcm9wZXJ0eSA9IG5vZGVQcm9wZXJ0eTtcclxuXHJcblx0XHRjb25zdCBub2RlU25pcHBldCA9IGNvbmROb2RlLmJ1aWxkKCBidWlsZGVyLCAnYm9vbCcgKTtcclxuXHJcblx0XHRidWlsZGVyLmFkZEZsb3dDb2RlKCBgXFxuJHsgYnVpbGRlci50YWIgfWlmICggJHsgbm9kZVNuaXBwZXQgfSApIHtcXG5cXG5gICkuYWRkRmxvd1RhYigpO1xyXG5cclxuXHRcdGxldCBpZlNuaXBwZXQgPSBpZk5vZGUuYnVpbGQoIGJ1aWxkZXIsIHR5cGUgKTtcclxuXHJcblx0XHRpZiAoIGlmU25pcHBldCApIHtcclxuXHJcblx0XHRcdGlmICggbmVlZHNPdXRwdXQgKSB7XHJcblxyXG5cdFx0XHRcdGlmU25pcHBldCA9IG5vZGVQcm9wZXJ0eSArICcgPSAnICsgaWZTbmlwcGV0ICsgJzsnO1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0aWZTbmlwcGV0ID0gJ3JldHVybiAnICsgaWZTbmlwcGV0ICsgJzsnO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRidWlsZGVyLnJlbW92ZUZsb3dUYWIoKS5hZGRGbG93Q29kZSggYnVpbGRlci50YWIgKyAnXFx0JyArIGlmU25pcHBldCArICdcXG5cXG4nICsgYnVpbGRlci50YWIgKyAnfScgKTtcclxuXHJcblx0XHRpZiAoIGVsc2VOb2RlICE9PSBudWxsICkge1xyXG5cclxuXHRcdFx0YnVpbGRlci5hZGRGbG93Q29kZSggJyBlbHNlIHtcXG5cXG4nICkuYWRkRmxvd1RhYigpO1xyXG5cclxuXHRcdFx0bGV0IGVsc2VTbmlwcGV0ID0gZWxzZU5vZGUuYnVpbGQoIGJ1aWxkZXIsIHR5cGUgKTtcclxuXHJcblx0XHRcdGlmICggZWxzZVNuaXBwZXQgKSB7XHJcblxyXG5cdFx0XHRcdGlmICggbmVlZHNPdXRwdXQgKSB7XHJcblxyXG5cdFx0XHRcdFx0ZWxzZVNuaXBwZXQgPSBub2RlUHJvcGVydHkgKyAnID0gJyArIGVsc2VTbmlwcGV0ICsgJzsnO1xyXG5cclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdGVsc2VTbmlwcGV0ID0gJ3JldHVybiAnICsgZWxzZVNuaXBwZXQgKyAnOyc7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGJ1aWxkZXIucmVtb3ZlRmxvd1RhYigpLmFkZEZsb3dDb2RlKCBidWlsZGVyLnRhYiArICdcXHQnICsgZWxzZVNuaXBwZXQgKyAnXFxuXFxuJyArIGJ1aWxkZXIudGFiICsgJ31cXG5cXG4nICk7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdGJ1aWxkZXIuYWRkRmxvd0NvZGUoICdcXG5cXG4nICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBidWlsZGVyLmZvcm1hdCggbm9kZVByb3BlcnR5LCB0eXBlLCBvdXRwdXQgKTtcclxuXHJcblx0fVxyXG5cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgQ29uZGl0aW9uYWxOb2RlO1xyXG5cclxuLyoqXHJcbiAqIFRTTCBmdW5jdGlvbiBmb3IgY3JlYXRpbmcgYSBjb25kaXRpb25hbCBub2RlLlxyXG4gKlxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHtOb2RlfSBjb25kTm9kZSAtIFRoZSBub2RlIHRoYXQgZGVmaW5lcyB0aGUgY29uZGl0aW9uLlxyXG4gKiBAcGFyYW0ge05vZGV9IGlmTm9kZSAtIFRoZSBub2RlIHRoYXQgaXMgZXZhbHVhdGUgd2hlbiB0aGUgY29uZGl0aW9uIGVuZHMgdXAgYHRydWVgLlxyXG4gKiBAcGFyYW0ge05vZGU/fSBbZWxzZU5vZGU9bnVsbF0gLSBUaGUgbm9kZSB0aGF0IGlzIGV2YWx1YXRlIHdoZW4gdGhlIGNvbmRpdGlvbiBlbmRzIHVwIGBmYWxzZWAuXHJcbiAqIEByZXR1cm5zIHtDb25kaXRpb25hbE5vZGV9XHJcbiAqL1xyXG5leHBvcnQgY29uc3Qgc2VsZWN0ID0gLypAX19QVVJFX18qLyBub2RlUHJveHkoIENvbmRpdGlvbmFsTm9kZSApO1xyXG5cclxuYWRkTWV0aG9kQ2hhaW5pbmcoICdzZWxlY3QnLCBzZWxlY3QgKTtcclxuXHJcbi8vXHJcblxyXG5leHBvcnQgY29uc3QgY29uZCA9ICggLi4ucGFyYW1zICkgPT4geyAvLyBAZGVwcmVjYXRlZCwgcjE2OFxyXG5cclxuXHRjb25zb2xlLndhcm4oICdUU0wuQ29uZGl0aW9uYWxOb2RlOiBjb25kKCkgaGFzIGJlZW4gcmVuYW1lZCB0byBzZWxlY3QoKS4nICk7XHJcblx0cmV0dXJuIHNlbGVjdCggLi4ucGFyYW1zICk7XHJcblxyXG59O1xyXG5cclxuYWRkTWV0aG9kQ2hhaW5pbmcoICdjb25kJywgY29uZCApO1xyXG4iLCJpbXBvcnQgTm9kZSBmcm9tICcuL05vZGUuanMnO1xyXG5pbXBvcnQgeyBhZGRNZXRob2RDaGFpbmluZywgbm9kZVByb3h5IH0gZnJvbSAnLi4vdHNsL1RTTENvcmUuanMnO1xyXG5cclxuLyoqIEBtb2R1bGUgQ29udGV4dE5vZGUgKiovXHJcblxyXG4vKipcclxuICogVGhpcyBub2RlIGNhbiBiZSB1c2VkIGFzIGEgY29udGV4dCBtYW5hZ2VtZW50IGNvbXBvbmVudCBmb3IgYW5vdGhlciBub2RlLlxyXG4gKiB7QGxpbmsgTm9kZUJ1aWxkZXJ9IHBlcmZvcm1zIGl0cyBub2RlIGJ1aWxkaW5nIHByb2Nlc3MgaW4gYSBzcGVjaWZpYyBjb250ZXh0IGFuZFxyXG4gKiB0aGlzIG5vZGUgYWxsb3dzIHRoZSBtb2RpZnkgdGhlIGNvbnRleHQuIEEgdHlwaWNhbCB1c2UgY2FzZSBpcyB0byBvdmVyd3JpdGUgYGdldFVWKClgIGUuZy46XHJcbiAqXHJcbiAqIGBgYGpzXHJcbiAqbm9kZS5jb250ZXh0KCB7IGdldFVWOiAoKSA9PiBjdXN0b21Db29yZCB9ICk7XHJcbiAqYGBgXHJcbiAqIEBhdWdtZW50cyBOb2RlXHJcbiAqL1xyXG5jbGFzcyBDb250ZXh0Tm9kZSBleHRlbmRzIE5vZGUge1xyXG5cclxuXHRzdGF0aWMgZ2V0IHR5cGUoKSB7XHJcblxyXG5cdFx0cmV0dXJuICdDb250ZXh0Tm9kZSc7XHJcblxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogQ29uc3RydWN0cyBhIG5ldyBjb250ZXh0IG5vZGUuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge05vZGV9IG5vZGUgLSBUaGUgbm9kZSB3aG9zZSBjb250ZXh0IHNob3VsZCBiZSBtb2RpZmllZC5cclxuXHQgKiBAcGFyYW0ge09iamVjdH0gW3ZhbHVlPXt9XSAtIFRoZSBtb2RpZmllZCBjb250ZXh0IGRhdGEuXHJcblx0ICovXHJcblx0Y29uc3RydWN0b3IoIG5vZGUsIHZhbHVlID0ge30gKSB7XHJcblxyXG5cdFx0c3VwZXIoKTtcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIFRoaXMgZmxhZyBjYW4gYmUgdXNlZCBmb3IgdHlwZSB0ZXN0aW5nLlxyXG5cdFx0ICpcclxuXHRcdCAqIEB0eXBlIHtCb29sZWFufVxyXG5cdFx0ICogQHJlYWRvbmx5XHJcblx0XHQgKiBAZGVmYXVsdCB0cnVlXHJcblx0XHQgKi9cclxuXHRcdHRoaXMuaXNDb250ZXh0Tm9kZSA9IHRydWU7XHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBUaGUgbm9kZSB3aG9zZSBjb250ZXh0IHNob3VsZCBiZSBtb2RpZmllZC5cclxuXHRcdCAqXHJcblx0XHQgKiBAdHlwZSB7Tm9kZX1cclxuXHRcdCAqL1xyXG5cdFx0dGhpcy5ub2RlID0gbm9kZTtcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIFRoZSBtb2RpZmllZCBjb250ZXh0IGRhdGEuXHJcblx0XHQgKlxyXG5cdFx0ICogQHR5cGUge09iamVjdH1cclxuXHRcdCAqIEBkZWZhdWx0IHt9XHJcblx0XHQgKi9cclxuXHRcdHRoaXMudmFsdWUgPSB2YWx1ZTtcclxuXHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBUaGlzIG1ldGhvZCBpcyBvdmVyd3JpdHRlbiB0byBlbnN1cmUgaXQgcmV0dXJucyB0aGUgcmVmZXJlbmNlIHRvIHtAbGluayBtb2R1bGU6Q29udGV4dE5vZGV+Q29udGV4dE5vZGUjbm9kZX0uXHJcblx0ICpcclxuXHQgKiBAcmV0dXJuIHtOb2RlfSBBIHJlZmVyZW5jZSB0byB7QGxpbmsgbW9kdWxlOkNvbnRleHROb2RlfkNvbnRleHROb2RlI25vZGV9LlxyXG5cdCAqL1xyXG5cdGdldFNjb3BlKCkge1xyXG5cclxuXHRcdHJldHVybiB0aGlzLm5vZGUuZ2V0U2NvcGUoKTtcclxuXHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBUaGlzIG1ldGhvZCBpcyBvdmVyd3JpdHRlbiB0byBlbnN1cmUgaXQgcmV0dXJucyB0aGUgdHlwZSBvZiB7QGxpbmsgbW9kdWxlOkNvbnRleHROb2RlfkNvbnRleHROb2RlI25vZGV9LlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtOb2RlQnVpbGRlcn0gYnVpbGRlciAtIFRoZSBjdXJyZW50IG5vZGUgYnVpbGRlci5cclxuXHQgKiBAcmV0dXJuIHtTdHJpbmd9IFRoZSBub2RlIHR5cGUuXHJcblx0ICovXHJcblx0Z2V0Tm9kZVR5cGUoIGJ1aWxkZXIgKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMubm9kZS5nZXROb2RlVHlwZSggYnVpbGRlciApO1xyXG5cclxuXHR9XHJcblxyXG5cdGFuYWx5emUoIGJ1aWxkZXIgKSB7XHJcblxyXG5cdFx0dGhpcy5ub2RlLmJ1aWxkKCBidWlsZGVyICk7XHJcblxyXG5cdH1cclxuXHJcblx0c2V0dXAoIGJ1aWxkZXIgKSB7XHJcblxyXG5cdFx0Y29uc3QgcHJldmlvdXNDb250ZXh0ID0gYnVpbGRlci5nZXRDb250ZXh0KCk7XHJcblxyXG5cdFx0YnVpbGRlci5zZXRDb250ZXh0KCB7IC4uLmJ1aWxkZXIuY29udGV4dCwgLi4udGhpcy52YWx1ZSB9ICk7XHJcblxyXG5cdFx0Y29uc3Qgbm9kZSA9IHRoaXMubm9kZS5idWlsZCggYnVpbGRlciApO1xyXG5cclxuXHRcdGJ1aWxkZXIuc2V0Q29udGV4dCggcHJldmlvdXNDb250ZXh0ICk7XHJcblxyXG5cdFx0cmV0dXJuIG5vZGU7XHJcblxyXG5cdH1cclxuXHJcblx0Z2VuZXJhdGUoIGJ1aWxkZXIsIG91dHB1dCApIHtcclxuXHJcblx0XHRjb25zdCBwcmV2aW91c0NvbnRleHQgPSBidWlsZGVyLmdldENvbnRleHQoKTtcclxuXHJcblx0XHRidWlsZGVyLnNldENvbnRleHQoIHsgLi4uYnVpbGRlci5jb250ZXh0LCAuLi50aGlzLnZhbHVlIH0gKTtcclxuXHJcblx0XHRjb25zdCBzbmlwcGV0ID0gdGhpcy5ub2RlLmJ1aWxkKCBidWlsZGVyLCBvdXRwdXQgKTtcclxuXHJcblx0XHRidWlsZGVyLnNldENvbnRleHQoIHByZXZpb3VzQ29udGV4dCApO1xyXG5cclxuXHRcdHJldHVybiBzbmlwcGV0O1xyXG5cclxuXHR9XHJcblxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBDb250ZXh0Tm9kZTtcclxuXHJcbi8qKlxyXG4gKiBUU0wgZnVuY3Rpb24gZm9yIGNyZWF0aW5nIGEgY29udGV4dCBub2RlLlxyXG4gKlxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHtOb2RlfSBub2RlIC0gVGhlIG5vZGUgd2hvc2UgY29udGV4dCBzaG91bGQgYmUgbW9kaWZpZWQuXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBbdmFsdWU9e31dIC0gVGhlIG1vZGlmaWVkIGNvbnRleHQgZGF0YS5cclxuICogQHJldHVybnMge0NvbnRleHROb2RlfVxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IGNvbnRleHQgPSAvKkBfX1BVUkVfXyovIG5vZGVQcm94eSggQ29udGV4dE5vZGUgKTtcclxuXHJcbi8qKlxyXG4gKiBUU0wgZnVuY3Rpb24gZm9yIGRlZmluaW5nIGEgbGFiZWwgY29udGV4dCB2YWx1ZSBmb3IgYSBnaXZlbiBub2RlLlxyXG4gKlxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHtOb2RlfSBub2RlIC0gVGhlIG5vZGUgd2hvc2UgY29udGV4dCBzaG91bGQgYmUgbW9kaWZpZWQuXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIC0gVGhlIG5hbWUvbGFiZWwgdG8gc2V0LlxyXG4gKiBAcmV0dXJucyB7Q29udGV4dE5vZGV9XHJcbiAqL1xyXG5leHBvcnQgY29uc3QgbGFiZWwgPSAoIG5vZGUsIG5hbWUgKSA9PiBjb250ZXh0KCBub2RlLCB7IGxhYmVsOiBuYW1lIH0gKTtcclxuXHJcbmFkZE1ldGhvZENoYWluaW5nKCAnY29udGV4dCcsIGNvbnRleHQgKTtcclxuYWRkTWV0aG9kQ2hhaW5pbmcoICdsYWJlbCcsIGxhYmVsICk7XHJcbiIsImltcG9ydCBOb2RlIGZyb20gJy4vTm9kZS5qcyc7XHJcbmltcG9ydCB7IGFkZE1ldGhvZENoYWluaW5nLCBub2RlUHJveHkgfSBmcm9tICcuLi90c2wvVFNMQ29yZS5qcyc7XHJcblxyXG4vKiogQG1vZHVsZSBWYXJOb2RlICoqL1xyXG5cclxuLyoqXHJcbiAqIENsYXNzIGZvciByZXByZXNlbnRpbmcgc2hhZGVyIHZhcmlhYmxlcyBhcyBub2Rlcy4gVmFyaWFibGVzIGFyZSBjcmVhdGVkIGZyb21cclxuICogZXhpc3Rpbmcgbm9kZXMgbGlrZSB0aGUgZm9sbG93aW5nOlxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiBjb25zdCBkZXB0aCA9IHNhbXBsZURlcHRoKCB1dk5vZGUgKS50b1ZhciggJ2RlcHRoJyApO1xyXG4gKiBgYGBcclxuICpcclxuICogQGF1Z21lbnRzIE5vZGVcclxuICovXHJcbmNsYXNzIFZhck5vZGUgZXh0ZW5kcyBOb2RlIHtcclxuXHJcblx0c3RhdGljIGdldCB0eXBlKCkge1xyXG5cclxuXHRcdHJldHVybiAnVmFyTm9kZSc7XHJcblxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogQ29uc3RydWN0cyBhIG5ldyB2YXJpYWJsZSBub2RlLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtOb2RlfSBub2RlIC0gVGhlIG5vZGUgZm9yIHdoaWNoIGEgdmFyaWFibGUgc2hvdWxkIGJlIGNyZWF0ZWQuXHJcblx0ICogQHBhcmFtIHtTdHJpbmc/fSBuYW1lIC0gVGhlIG5hbWUgb2YgdGhlIHZhcmlhYmxlIGluIHRoZSBzaGFkZXIuXHJcblx0ICovXHJcblx0Y29uc3RydWN0b3IoIG5vZGUsIG5hbWUgPSBudWxsICkge1xyXG5cclxuXHRcdHN1cGVyKCk7XHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBUaGUgbm9kZSBmb3Igd2hpY2ggYSB2YXJpYWJsZSBzaG91bGQgYmUgY3JlYXRlZC5cclxuXHRcdCAqXHJcblx0XHQgKiBAdHlwZSB7Tm9kZX1cclxuXHRcdCAqL1xyXG5cdFx0dGhpcy5ub2RlID0gbm9kZTtcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIFRoZSBuYW1lIG9mIHRoZSB2YXJpYWJsZSBpbiB0aGUgc2hhZGVyLiBJZiBubyBuYW1lIGlzIGRlZmluZWQsXHJcblx0XHQgKiB0aGUgbm9kZSBzeXN0ZW0gYXV0by1nZW5lcmF0ZXMgb25lLlxyXG5cdFx0ICpcclxuXHRcdCAqIEB0eXBlIHtTdHJpbmc/fVxyXG5cdFx0ICogQGRlZmF1bHQgbnVsbFxyXG5cdFx0ICovXHJcblx0XHR0aGlzLm5hbWUgPSBuYW1lO1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogYFZhck5vZGVgIHNldHMgdGhpcyBwcm9wZXJ0eSB0byBgdHJ1ZWAgYnkgZGVmYXVsdC5cclxuXHRcdCAqXHJcblx0XHQgKiBAdHlwZSB7Qm9vbGVhbn1cclxuXHRcdCAqIEBkZWZhdWx0IHRydWVcclxuXHRcdCAqL1xyXG5cdFx0dGhpcy5nbG9iYWwgPSB0cnVlO1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogVGhpcyBmbGFnIGNhbiBiZSB1c2VkIGZvciB0eXBlIHRlc3RpbmcuXHJcblx0XHQgKlxyXG5cdFx0ICogQHR5cGUge0Jvb2xlYW59XHJcblx0XHQgKiBAcmVhZG9ubHlcclxuXHRcdCAqIEBkZWZhdWx0IHRydWVcclxuXHRcdCAqL1xyXG5cdFx0dGhpcy5pc1Zhck5vZGUgPSB0cnVlO1xyXG5cclxuXHR9XHJcblxyXG5cdGdldEhhc2goIGJ1aWxkZXIgKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMubmFtZSB8fCBzdXBlci5nZXRIYXNoKCBidWlsZGVyICk7XHJcblxyXG5cdH1cclxuXHJcblx0Z2V0Tm9kZVR5cGUoIGJ1aWxkZXIgKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMubm9kZS5nZXROb2RlVHlwZSggYnVpbGRlciApO1xyXG5cclxuXHR9XHJcblxyXG5cdGdlbmVyYXRlKCBidWlsZGVyICkge1xyXG5cclxuXHRcdGNvbnN0IHsgbm9kZSwgbmFtZSB9ID0gdGhpcztcclxuXHJcblx0XHRjb25zdCBub2RlVmFyID0gYnVpbGRlci5nZXRWYXJGcm9tTm9kZSggdGhpcywgbmFtZSwgYnVpbGRlci5nZXRWZWN0b3JUeXBlKCB0aGlzLmdldE5vZGVUeXBlKCBidWlsZGVyICkgKSApO1xyXG5cclxuXHRcdGNvbnN0IHByb3BlcnR5TmFtZSA9IGJ1aWxkZXIuZ2V0UHJvcGVydHlOYW1lKCBub2RlVmFyICk7XHJcblxyXG5cdFx0Y29uc3Qgc25pcHBldCA9IG5vZGUuYnVpbGQoIGJ1aWxkZXIsIG5vZGVWYXIudHlwZSApO1xyXG5cclxuXHRcdGJ1aWxkZXIuYWRkTGluZUZsb3dDb2RlKCBgJHtwcm9wZXJ0eU5hbWV9ID0gJHtzbmlwcGV0fWAsIHRoaXMgKTtcclxuXHJcblx0XHRyZXR1cm4gcHJvcGVydHlOYW1lO1xyXG5cclxuXHR9XHJcblxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBWYXJOb2RlO1xyXG5cclxuLyoqXHJcbiAqIFRTTCBmdW5jdGlvbiBmb3IgY3JlYXRpbmcgYSB2YXIgbm9kZS5cclxuICpcclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7Tm9kZX0gbm9kZSAtIFRoZSBub2RlIGZvciB3aGljaCBhIHZhcmlhYmxlIHNob3VsZCBiZSBjcmVhdGVkLlxyXG4gKiBAcGFyYW0ge1N0cmluZz99IG5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgdmFyaWFibGUgaW4gdGhlIHNoYWRlci5cclxuICogQHJldHVybnMge1Zhck5vZGV9XHJcbiAqL1xyXG5jb25zdCBjcmVhdGVWYXIgPSAvKkBfX1BVUkVfXyovIG5vZGVQcm94eSggVmFyTm9kZSApO1xyXG5cclxuYWRkTWV0aG9kQ2hhaW5pbmcoICd0b1ZhcicsICggLi4ucGFyYW1zICkgPT4gY3JlYXRlVmFyKCAuLi5wYXJhbXMgKS5hcHBlbmQoKSApO1xyXG5cclxuLy8gRGVwcmVjYXRlZFxyXG5cclxuZXhwb3J0IGNvbnN0IHRlbXAgPSAoIG5vZGUgKSA9PiB7IC8vIEBkZXByZWNhdGVkLCByMTcwXHJcblxyXG5cdGNvbnNvbGUud2FybiggJ1RTTDogXCJ0ZW1wXCIgaXMgZGVwcmVjYXRlZC4gVXNlIFwiLnRvVmFyKClcIiBpbnN0ZWFkLicgKTtcclxuXHJcblx0cmV0dXJuIGNyZWF0ZVZhciggbm9kZSApO1xyXG5cclxufTtcclxuXHJcbmFkZE1ldGhvZENoYWluaW5nKCAndGVtcCcsIHRlbXAgKTtcclxuXHJcbiIsImltcG9ydCBOb2RlIGZyb20gJy4vTm9kZS5qcyc7XHJcbmltcG9ydCB7IE5vZGVTaGFkZXJTdGFnZSB9IGZyb20gJy4vY29uc3RhbnRzLmpzJztcclxuaW1wb3J0IHsgYWRkTWV0aG9kQ2hhaW5pbmcsIG5vZGVQcm94eSB9IGZyb20gJy4uL3RzbC9UU0xDb3JlLmpzJztcclxuXHJcbi8qKiBAbW9kdWxlIFZhcnlpbmdOb2RlICoqL1xyXG5cclxuLyoqXHJcbiAqIENsYXNzIGZvciByZXByZXNlbnRpbmcgc2hhZGVyIHZhcnlpbmdzIGFzIG5vZGVzLiBWYXJ5aW5ncyBhcmUgY3JlYXRlIGZyb21cclxuICogZXhpc3Rpbmcgbm9kZXMgbGlrZSB0aGUgZm9sbG93aW5nOlxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiBjb25zdCBwb3NpdGlvbkxvY2FsID0gcG9zaXRpb25HZW9tZXRyeS52YXJ5aW5nKCAndlBvc2l0aW9uTG9jYWwnICk7XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBAYXVnbWVudHMgTm9kZVxyXG4gKi9cclxuY2xhc3MgVmFyeWluZ05vZGUgZXh0ZW5kcyBOb2RlIHtcclxuXHJcblx0c3RhdGljIGdldCB0eXBlKCkge1xyXG5cclxuXHRcdHJldHVybiAnVmFyeWluZ05vZGUnO1xyXG5cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIENvbnN0cnVjdHMgYSBuZXcgdmFyeWluZyBub2RlLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtOb2RlfSBub2RlIC0gVGhlIG5vZGUgZm9yIHdoaWNoIGEgdmFyeWluZyBzaG91bGQgYmUgY3JlYXRlZC5cclxuXHQgKiBAcGFyYW0ge1N0cmluZz99IG5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgdmFyeWluZyBpbiB0aGUgc2hhZGVyLlxyXG5cdCAqL1xyXG5cdGNvbnN0cnVjdG9yKCBub2RlLCBuYW1lID0gbnVsbCApIHtcclxuXHJcblx0XHRzdXBlcigpO1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogVGhlIG5vZGUgZm9yIHdoaWNoIGEgdmFyeWluZyBzaG91bGQgYmUgY3JlYXRlZC5cclxuXHRcdCAqXHJcblx0XHQgKiBAdHlwZSB7Tm9kZX1cclxuXHRcdCAqL1xyXG5cdFx0dGhpcy5ub2RlID0gbm9kZTtcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIFRoZSBuYW1lIG9mIHRoZSB2YXJ5aW5nIGluIHRoZSBzaGFkZXIuIElmIG5vIG5hbWUgaXMgZGVmaW5lZCxcclxuXHRcdCAqIHRoZSBub2RlIHN5c3RlbSBhdXRvLWdlbmVyYXRlcyBvbmUuXHJcblx0XHQgKlxyXG5cdFx0ICogQHR5cGUge1N0cmluZz99XHJcblx0XHQgKiBAZGVmYXVsdCBudWxsXHJcblx0XHQgKi9cclxuXHRcdHRoaXMubmFtZSA9IG5hbWU7XHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBUaGlzIGZsYWcgY2FuIGJlIHVzZWQgZm9yIHR5cGUgdGVzdGluZy5cclxuXHRcdCAqXHJcblx0XHQgKiBAdHlwZSB7Qm9vbGVhbn1cclxuXHRcdCAqIEByZWFkb25seVxyXG5cdFx0ICogQGRlZmF1bHQgdHJ1ZVxyXG5cdFx0ICovXHJcblx0XHR0aGlzLmlzVmFyeWluZ05vZGUgPSB0cnVlO1xyXG5cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFRoZSBtZXRob2QgaXMgb3ZlcndyaXR0ZW4gc28gaXQgYWx3YXlzIHJldHVybnMgYHRydWVgLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtOb2RlQnVpbGRlcn0gYnVpbGRlciAtIFRoZSBjdXJyZW50IG5vZGUgYnVpbGRlci5cclxuXHQgKiBAcmV0dXJuIHtCb29sZWFufSBXaGV0aGVyIHRoaXMgbm9kZSBpcyBnbG9iYWwgb3Igbm90LlxyXG5cdCAqL1xyXG5cdGlzR2xvYmFsKCAvKmJ1aWxkZXIqLyApIHtcclxuXHJcblx0XHRyZXR1cm4gdHJ1ZTtcclxuXHJcblx0fVxyXG5cclxuXHRnZXRIYXNoKCBidWlsZGVyICkge1xyXG5cclxuXHRcdHJldHVybiB0aGlzLm5hbWUgfHwgc3VwZXIuZ2V0SGFzaCggYnVpbGRlciApO1xyXG5cclxuXHR9XHJcblxyXG5cdGdldE5vZGVUeXBlKCBidWlsZGVyICkge1xyXG5cclxuXHRcdC8vIFZhcnlpbmdOb2RlIGlzIGF1dG8gdHlwZVxyXG5cclxuXHRcdHJldHVybiB0aGlzLm5vZGUuZ2V0Tm9kZVR5cGUoIGJ1aWxkZXIgKTtcclxuXHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBUaGlzIG1ldGhvZCBwZXJmb3JtcyB0aGUgc2V0dXAgb2YgYSB2YXJ5aW5nIG5vZGUgd2l0aCB0aGUgY3VycmVudCBub2RlIGJ1aWxkZXIuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge05vZGVCdWlsZGVyfSBidWlsZGVyIC0gVGhlIGN1cnJlbnQgbm9kZSBidWlsZGVyLlxyXG5cdCAqIEByZXR1cm4ge05vZGVWYXJ5aW5nfSBUaGUgbm9kZSB2YXJ5aW5nIGZyb20gdGhlIG5vZGUgYnVpbGRlci5cclxuXHQgKi9cclxuXHRzZXR1cFZhcnlpbmcoIGJ1aWxkZXIgKSB7XHJcblxyXG5cdFx0Y29uc3QgcHJvcGVydGllcyA9IGJ1aWxkZXIuZ2V0Tm9kZVByb3BlcnRpZXMoIHRoaXMgKTtcclxuXHJcblx0XHRsZXQgdmFyeWluZyA9IHByb3BlcnRpZXMudmFyeWluZztcclxuXHJcblx0XHRpZiAoIHZhcnlpbmcgPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdGNvbnN0IG5hbWUgPSB0aGlzLm5hbWU7XHJcblx0XHRcdGNvbnN0IHR5cGUgPSB0aGlzLmdldE5vZGVUeXBlKCBidWlsZGVyICk7XHJcblxyXG5cdFx0XHRwcm9wZXJ0aWVzLnZhcnlpbmcgPSB2YXJ5aW5nID0gYnVpbGRlci5nZXRWYXJ5aW5nRnJvbU5vZGUoIHRoaXMsIG5hbWUsIHR5cGUgKTtcclxuXHRcdFx0cHJvcGVydGllcy5ub2RlID0gdGhpcy5ub2RlO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvLyB0aGlzIHByb3BlcnR5IGNhbiBiZSB1c2VkIHRvIGNoZWNrIGlmIHRoZSB2YXJ5aW5nIGNhbiBiZSBvcHRpbWl6ZWQgZm9yIGEgdmFyaWFibGVcclxuXHRcdHZhcnlpbmcubmVlZHNJbnRlcnBvbGF0aW9uIHx8ICggdmFyeWluZy5uZWVkc0ludGVycG9sYXRpb24gPSAoIGJ1aWxkZXIuc2hhZGVyU3RhZ2UgPT09ICdmcmFnbWVudCcgKSApO1xyXG5cclxuXHRcdHJldHVybiB2YXJ5aW5nO1xyXG5cclxuXHR9XHJcblxyXG5cdHNldHVwKCBidWlsZGVyICkge1xyXG5cclxuXHRcdHRoaXMuc2V0dXBWYXJ5aW5nKCBidWlsZGVyICk7XHJcblxyXG5cdH1cclxuXHJcblx0YW5hbHl6ZSggYnVpbGRlciApIHtcclxuXHJcblx0XHR0aGlzLnNldHVwVmFyeWluZyggYnVpbGRlciApO1xyXG5cclxuXHRcdHJldHVybiB0aGlzLm5vZGUuYW5hbHl6ZSggYnVpbGRlciApO1xyXG5cclxuXHR9XHJcblxyXG5cdGdlbmVyYXRlKCBidWlsZGVyICkge1xyXG5cclxuXHRcdGNvbnN0IHByb3BlcnRpZXMgPSBidWlsZGVyLmdldE5vZGVQcm9wZXJ0aWVzKCB0aGlzICk7XHJcblx0XHRjb25zdCB2YXJ5aW5nID0gdGhpcy5zZXR1cFZhcnlpbmcoIGJ1aWxkZXIgKTtcclxuXHJcblx0XHRjb25zdCBuZWVkc1JlYXNzaWduID0gYnVpbGRlci5zaGFkZXJTdGFnZSA9PT0gJ2ZyYWdtZW50JyAmJiBwcm9wZXJ0aWVzLnJlYXNzaWduUG9zaXRpb24gPT09IHRydWUgJiYgYnVpbGRlci5jb250ZXh0Lm5lZWRzUG9zaXRpb25SZWFzc2lnbjtcclxuXHJcblx0XHRpZiAoIHByb3BlcnRpZXMucHJvcGVydHlOYW1lID09PSB1bmRlZmluZWQgfHwgbmVlZHNSZWFzc2lnbiApIHtcclxuXHJcblx0XHRcdGNvbnN0IHR5cGUgPSB0aGlzLmdldE5vZGVUeXBlKCBidWlsZGVyICk7XHJcblx0XHRcdGNvbnN0IHByb3BlcnR5TmFtZSA9IGJ1aWxkZXIuZ2V0UHJvcGVydHlOYW1lKCB2YXJ5aW5nLCBOb2RlU2hhZGVyU3RhZ2UuVkVSVEVYICk7XHJcblxyXG5cdFx0XHQvLyBmb3JjZSBub2RlIHJ1biBpbiB2ZXJ0ZXggc3RhZ2VcclxuXHRcdFx0YnVpbGRlci5mbG93Tm9kZUZyb21TaGFkZXJTdGFnZSggTm9kZVNoYWRlclN0YWdlLlZFUlRFWCwgdGhpcy5ub2RlLCB0eXBlLCBwcm9wZXJ0eU5hbWUgKTtcclxuXHJcblx0XHRcdHByb3BlcnRpZXMucHJvcGVydHlOYW1lID0gcHJvcGVydHlOYW1lO1xyXG5cclxuXHRcdFx0aWYgKCBuZWVkc1JlYXNzaWduICkge1xyXG5cclxuXHRcdFx0XHQvLyBvbmNlIHJlYXNzaWduIHZhcnlpbmcgaW4gZnJhZ21lbnQgc3RhZ2VcclxuXHRcdFx0XHRwcm9wZXJ0aWVzLnJlYXNzaWduUG9zaXRpb24gPSBmYWxzZTtcclxuXHJcblx0XHRcdH0gZWxzZSBpZiAoIHByb3BlcnRpZXMucmVhc3NpZ25Qb3NpdGlvbiA9PT0gdW5kZWZpbmVkICYmIGJ1aWxkZXIuY29udGV4dC5pc1Bvc2l0aW9uTm9kZUlucHV0ICkge1xyXG5cclxuXHRcdFx0XHRwcm9wZXJ0aWVzLnJlYXNzaWduUG9zaXRpb24gPSB0cnVlO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gYnVpbGRlci5nZXRQcm9wZXJ0eU5hbWUoIHZhcnlpbmcgKTtcclxuXHJcblx0fVxyXG5cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgVmFyeWluZ05vZGU7XHJcblxyXG4vKipcclxuICogVFNMIGZ1bmN0aW9uIGZvciBjcmVhdGluZyBhIHZhcnlpbmcgbm9kZS5cclxuICpcclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7Tm9kZX0gbm9kZSAtIFRoZSBub2RlIGZvciB3aGljaCBhIHZhcnlpbmcgc2hvdWxkIGJlIGNyZWF0ZWQuXHJcbiAqIEBwYXJhbSB7U3RyaW5nP30gbmFtZSAtIFRoZSBuYW1lIG9mIHRoZSB2YXJ5aW5nIGluIHRoZSBzaGFkZXIuXHJcbiAqIEByZXR1cm5zIHtWYXJ5aW5nTm9kZX1cclxuICovXHJcbmV4cG9ydCBjb25zdCB2YXJ5aW5nID0gLypAX19QVVJFX18qLyBub2RlUHJveHkoIFZhcnlpbmdOb2RlICk7XHJcblxyXG5hZGRNZXRob2RDaGFpbmluZyggJ3ZhcnlpbmcnLCB2YXJ5aW5nICk7XHJcbiIsImltcG9ydCB7IG1peCB9IGZyb20gJy4uL21hdGgvTWF0aE5vZGUuanMnO1xyXG5pbXBvcnQgeyBGbiB9IGZyb20gJy4uL3RzbC9UU0xDb3JlLmpzJztcclxuXHJcbi8qKiBAbW9kdWxlIENvbG9yU3BhY2VGdW5jdGlvbnMgKiovXHJcblxyXG4vKipcclxuICogQ29udmVydHMgdGhlIGdpdmVuIGNvbG9yIHZhbHVlIGZyb20gc1JHQiB0byBsaW5lYXItc1JHQiBjb2xvciBzcGFjZS5cclxuICpcclxuICogQG1ldGhvZFxyXG4gKiBAcGFyYW0ge05vZGU8dmVjMz59IGNvbG9yIC0gVGhlIHNSR0IgY29sb3IuXHJcbiAqIEByZXR1cm4ge05vZGU8dmVjMz59IFRoZSBsaW5lYXItc1JHQiBjb2xvci5cclxuICovXHJcbmV4cG9ydCBjb25zdCBzUkdCVHJhbnNmZXJFT1RGID0gLypAX19QVVJFX18qLyBGbiggKCBbIGNvbG9yIF0gKSA9PiB7XHJcblxyXG5cdGNvbnN0IGEgPSBjb2xvci5tdWwoIDAuOTQ3ODY3Mjk4NiApLmFkZCggMC4wNTIxMzI3MDE0ICkucG93KCAyLjQgKTtcclxuXHRjb25zdCBiID0gY29sb3IubXVsKCAwLjA3NzM5OTM4MDggKTtcclxuXHRjb25zdCBmYWN0b3IgPSBjb2xvci5sZXNzVGhhbkVxdWFsKCAwLjA0MDQ1ICk7XHJcblxyXG5cdGNvbnN0IHJnYlJlc3VsdCA9IG1peCggYSwgYiwgZmFjdG9yICk7XHJcblxyXG5cdHJldHVybiByZ2JSZXN1bHQ7XHJcblxyXG59ICkuc2V0TGF5b3V0KCB7XHJcblx0bmFtZTogJ3NSR0JUcmFuc2ZlckVPVEYnLFxyXG5cdHR5cGU6ICd2ZWMzJyxcclxuXHRpbnB1dHM6IFtcclxuXHRcdHsgbmFtZTogJ2NvbG9yJywgdHlwZTogJ3ZlYzMnIH1cclxuXHRdXHJcbn0gKTtcclxuXHJcbi8qKlxyXG4gKiBDb252ZXJ0cyB0aGUgZ2l2ZW4gY29sb3IgdmFsdWUgZnJvbSBsaW5lYXItc1JHQiB0byBzUkdCIGNvbG9yIHNwYWNlLlxyXG4gKlxyXG4gKiBAbWV0aG9kXHJcbiAqIEBwYXJhbSB7Tm9kZTx2ZWMzPn0gY29sb3IgLSBUaGUgbGluZWFyLXNSR0IgY29sb3IuXHJcbiAqIEByZXR1cm4ge05vZGU8dmVjMz59IFRoZSBzUkdCIGNvbG9yLlxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IHNSR0JUcmFuc2Zlck9FVEYgPSAvKkBfX1BVUkVfXyovIEZuKCAoIFsgY29sb3IgXSApID0+IHtcclxuXHJcblx0Y29uc3QgYSA9IGNvbG9yLnBvdyggMC40MTY2NiApLm11bCggMS4wNTUgKS5zdWIoIDAuMDU1ICk7XHJcblx0Y29uc3QgYiA9IGNvbG9yLm11bCggMTIuOTIgKTtcclxuXHRjb25zdCBmYWN0b3IgPSBjb2xvci5sZXNzVGhhbkVxdWFsKCAwLjAwMzEzMDggKTtcclxuXHJcblx0Y29uc3QgcmdiUmVzdWx0ID0gbWl4KCBhLCBiLCBmYWN0b3IgKTtcclxuXHJcblx0cmV0dXJuIHJnYlJlc3VsdDtcclxuXHJcbn0gKS5zZXRMYXlvdXQoIHtcclxuXHRuYW1lOiAnc1JHQlRyYW5zZmVyT0VURicsXHJcblx0dHlwZTogJ3ZlYzMnLFxyXG5cdGlucHV0czogW1xyXG5cdFx0eyBuYW1lOiAnY29sb3InLCB0eXBlOiAndmVjMycgfVxyXG5cdF1cclxufSApO1xyXG4iLCJpbXBvcnQgVGVtcE5vZGUgZnJvbSAnLi4vY29yZS9UZW1wTm9kZS5qcyc7XHJcbmltcG9ydCB7IGFkZE1ldGhvZENoYWluaW5nLCBtYXQzLCBub2RlT2JqZWN0LCB2ZWM0IH0gZnJvbSAnLi4vdHNsL1RTTENvcmUuanMnO1xyXG5cclxuaW1wb3J0IHsgU1JHQlRyYW5zZmVyIH0gZnJvbSAnLi4vLi4vY29uc3RhbnRzLmpzJztcclxuaW1wb3J0IHsgQ29sb3JNYW5hZ2VtZW50IH0gZnJvbSAnLi4vLi4vbWF0aC9Db2xvck1hbmFnZW1lbnQuanMnO1xyXG5pbXBvcnQgeyBzUkdCVHJhbnNmZXJFT1RGLCBzUkdCVHJhbnNmZXJPRVRGIH0gZnJvbSAnLi9Db2xvclNwYWNlRnVuY3Rpb25zLmpzJztcclxuaW1wb3J0IHsgTWF0cml4MyB9IGZyb20gJy4uLy4uL21hdGgvTWF0cml4My5qcyc7XHJcblxyXG4vKiogQG1vZHVsZSBDb2xvclNwYWNlTm9kZSAqKi9cclxuXHJcbmNvbnN0IFdPUktJTkdfQ09MT1JfU1BBQ0UgPSAnV29ya2luZ0NvbG9yU3BhY2UnO1xyXG5jb25zdCBPVVRQVVRfQ09MT1JfU1BBQ0UgPSAnT3V0cHV0Q29sb3JTcGFjZSc7XHJcblxyXG4vKipcclxuICogVGhpcyBub2RlIHJlcHJlc2VudHMgYSBjb2xvciBzcGFjZSBjb252ZXJzaW9uLiBNZWFuaW5nIGl0IGNvbnZlcnRzXHJcbiAqIGEgY29sb3IgdmFsdWUgZnJvbSBhIHNvdXJjZSB0byBhIHRhcmdldCBjb2xvciBzcGFjZS5cclxuICpcclxuICogQGF1Z21lbnRzIFRlbXBOb2RlXHJcbiAqL1xyXG5jbGFzcyBDb2xvclNwYWNlTm9kZSBleHRlbmRzIFRlbXBOb2RlIHtcclxuXHJcblx0c3RhdGljIGdldCB0eXBlKCkge1xyXG5cclxuXHRcdHJldHVybiAnQ29sb3JTcGFjZU5vZGUnO1xyXG5cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIENvbnN0cnVjdHMgYSBuZXcgY29sb3Igc3BhY2Ugbm9kZS5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7Tm9kZX0gY29sb3JOb2RlIC0gUmVwcmVzZW50cyB0aGUgY29sb3IgdG8gY29udmVydC5cclxuXHQgKiBAcGFyYW0ge1N0cmluZ30gc291cmNlIC0gVGhlIHNvdXJjZSBjb2xvciBzcGFjZS5cclxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdGFyZ2V0IC0gVGhlIHRhcmdldCBjb2xvciBzcGFjZS5cclxuXHQgKi9cclxuXHRjb25zdHJ1Y3RvciggY29sb3JOb2RlLCBzb3VyY2UsIHRhcmdldCApIHtcclxuXHJcblx0XHRzdXBlciggJ3ZlYzQnICk7XHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBSZXByZXNlbnRzIHRoZSBjb2xvciB0byBjb252ZXJ0LlxyXG5cdFx0ICpcclxuXHRcdCAqIEB0eXBlIHtOb2RlfVxyXG5cdFx0ICovXHJcblx0XHR0aGlzLmNvbG9yTm9kZSA9IGNvbG9yTm9kZTtcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIFRoZSBzb3VyY2UgY29sb3Igc3BhY2UuXHJcblx0XHQgKlxyXG5cdFx0ICogQHR5cGUge1N0cmluZ31cclxuXHRcdCAqL1xyXG5cdFx0dGhpcy5zb3VyY2UgPSBzb3VyY2U7XHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBUaGUgdGFyZ2V0IGNvbG9yIHNwYWNlLlxyXG5cdFx0ICpcclxuXHRcdCAqIEB0eXBlIHtTdHJpbmd9XHJcblx0XHQgKi9cclxuXHRcdHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xyXG5cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFRoaXMgbWV0aG9kIHJlc29sdmVzIHRoZSBjb25zdGFudHMgYFdPUktJTkdfQ09MT1JfU1BBQ0VgIGFuZFxyXG5cdCAqIGBPVVRQVVRfQ09MT1JfU1BBQ0VgIGJhc2VkIG9uIHRoZSBjdXJyZW50IGNvbmZpZ3VyYXRpb24gb2YgdGhlXHJcblx0ICogY29sb3IgbWFuYWdlbWVudCBhbmQgcmVuZGVyZXIuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge05vZGVCdWlsZGVyfSBidWlsZGVyIC0gVGhlIGN1cnJlbnQgbm9kZSBidWlsZGVyLlxyXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBjb2xvclNwYWNlIC0gVGhlIGNvbG9yIHNwYWNlIHRvIHJlc29sdmUuXHJcblx0ICogQHJldHVybiB7U3RyaW5nfSBUaGUgcmVzb2x2ZWQgY29sb3Igc3BhY2UuXHJcblx0ICovXHJcblx0cmVzb2x2ZUNvbG9yU3BhY2UoIGJ1aWxkZXIsIGNvbG9yU3BhY2UgKSB7XHJcblxyXG5cdFx0aWYgKCBjb2xvclNwYWNlID09PSBXT1JLSU5HX0NPTE9SX1NQQUNFICkge1xyXG5cclxuXHRcdFx0cmV0dXJuIENvbG9yTWFuYWdlbWVudC53b3JraW5nQ29sb3JTcGFjZTtcclxuXHJcblx0XHR9IGVsc2UgaWYgKCBjb2xvclNwYWNlID09PSBPVVRQVVRfQ09MT1JfU1BBQ0UgKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gYnVpbGRlci5jb250ZXh0Lm91dHB1dENvbG9yU3BhY2UgfHwgYnVpbGRlci5yZW5kZXJlci5vdXRwdXRDb2xvclNwYWNlO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gY29sb3JTcGFjZTtcclxuXHJcblx0fVxyXG5cclxuXHRzZXR1cCggYnVpbGRlciApIHtcclxuXHJcblx0XHRjb25zdCB7IGNvbG9yTm9kZSB9ID0gdGhpcztcclxuXHJcblx0XHRjb25zdCBzb3VyY2UgPSB0aGlzLnJlc29sdmVDb2xvclNwYWNlKCBidWlsZGVyLCB0aGlzLnNvdXJjZSApO1xyXG5cdFx0Y29uc3QgdGFyZ2V0ID0gdGhpcy5yZXNvbHZlQ29sb3JTcGFjZSggYnVpbGRlciwgdGhpcy50YXJnZXQgKTtcclxuXHJcblx0XHRsZXQgb3V0cHV0Tm9kZSA9IGNvbG9yTm9kZTtcclxuXHJcblx0XHRpZiAoIENvbG9yTWFuYWdlbWVudC5lbmFibGVkID09PSBmYWxzZSB8fCBzb3VyY2UgPT09IHRhcmdldCB8fCAhIHNvdXJjZSB8fCAhIHRhcmdldCApIHtcclxuXHJcblx0XHRcdHJldHVybiBvdXRwdXROb2RlO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIENvbG9yTWFuYWdlbWVudC5nZXRUcmFuc2Zlciggc291cmNlICkgPT09IFNSR0JUcmFuc2ZlciApIHtcclxuXHJcblx0XHRcdG91dHB1dE5vZGUgPSB2ZWM0KCBzUkdCVHJhbnNmZXJFT1RGKCBvdXRwdXROb2RlLnJnYiApLCBvdXRwdXROb2RlLmEgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBDb2xvck1hbmFnZW1lbnQuZ2V0UHJpbWFyaWVzKCBzb3VyY2UgKSAhPT0gQ29sb3JNYW5hZ2VtZW50LmdldFByaW1hcmllcyggdGFyZ2V0ICkgKSB7XHJcblxyXG5cdFx0XHRvdXRwdXROb2RlID0gdmVjNChcclxuXHRcdFx0XHRtYXQzKCBDb2xvck1hbmFnZW1lbnQuX2dldE1hdHJpeCggbmV3IE1hdHJpeDMoKSwgc291cmNlLCB0YXJnZXQgKSApLm11bCggb3V0cHV0Tm9kZS5yZ2IgKSxcclxuXHRcdFx0XHRvdXRwdXROb2RlLmFcclxuXHRcdFx0KTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBDb2xvck1hbmFnZW1lbnQuZ2V0VHJhbnNmZXIoIHRhcmdldCApID09PSBTUkdCVHJhbnNmZXIgKSB7XHJcblxyXG5cdFx0XHRvdXRwdXROb2RlID0gdmVjNCggc1JHQlRyYW5zZmVyT0VURiggb3V0cHV0Tm9kZS5yZ2IgKSwgb3V0cHV0Tm9kZS5hICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBvdXRwdXROb2RlO1xyXG5cclxuXHR9XHJcblxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBDb2xvclNwYWNlTm9kZTtcclxuXHJcbi8qKlxyXG4gKiBUU0wgZnVuY3Rpb24gZm9yIGNvbnZlcnRpbmcgYSBnaXZlbiBjb2xvciBub2RlIHRvIHRoZSBjdXJyZW50IG91dHB1dCBjb2xvciBzcGFjZS5cclxuICpcclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7Tm9kZX0gbm9kZSAtIFJlcHJlc2VudHMgdGhlIG5vZGUgdG8gY29udmVydC5cclxuICogQHJldHVybnMge0NvbG9yU3BhY2VOb2RlfVxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IHRvT3V0cHV0Q29sb3JTcGFjZSA9ICggbm9kZSApID0+IG5vZGVPYmplY3QoIG5ldyBDb2xvclNwYWNlTm9kZSggbm9kZU9iamVjdCggbm9kZSApLCBXT1JLSU5HX0NPTE9SX1NQQUNFLCBPVVRQVVRfQ09MT1JfU1BBQ0UgKSApO1xyXG5cclxuLyoqXHJcbiAqIFRTTCBmdW5jdGlvbiBmb3IgY29udmVydGluZyBhIGdpdmVuIGNvbG9yIG5vZGUgdG8gdGhlIGN1cnJlbnQgd29ya2luZyBjb2xvciBzcGFjZS5cclxuICpcclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7Tm9kZX0gbm9kZSAtIFJlcHJlc2VudHMgdGhlIG5vZGUgdG8gY29udmVydC5cclxuICogQHJldHVybnMge0NvbG9yU3BhY2VOb2RlfVxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IHRvV29ya2luZ0NvbG9yU3BhY2UgPSAoIG5vZGUgKSA9PiBub2RlT2JqZWN0KCBuZXcgQ29sb3JTcGFjZU5vZGUoIG5vZGVPYmplY3QoIG5vZGUgKSwgT1VUUFVUX0NPTE9SX1NQQUNFLCBXT1JLSU5HX0NPTE9SX1NQQUNFICkgKTtcclxuXHJcbi8qKlxyXG4gKiBUU0wgZnVuY3Rpb24gZm9yIGNvbnZlcnRpbmcgYSBnaXZlbiBjb2xvciBub2RlIGZyb20gdGhlIGN1cnJlbnQgd29ya2luZyBjb2xvciBzcGFjZSB0byB0aGUgZ2l2ZW4gY29sb3Igc3BhY2UuXHJcbiAqXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0ge05vZGV9IG5vZGUgLSBSZXByZXNlbnRzIHRoZSBub2RlIHRvIGNvbnZlcnQuXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBjb2xvclNwYWNlIC0gVGhlIHRhcmdldCBjb2xvciBzcGFjZS5cclxuICogQHJldHVybnMge0NvbG9yU3BhY2VOb2RlfVxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IHdvcmtpbmdUb0NvbG9yU3BhY2UgPSAoIG5vZGUsIGNvbG9yU3BhY2UgKSA9PiBub2RlT2JqZWN0KCBuZXcgQ29sb3JTcGFjZU5vZGUoIG5vZGVPYmplY3QoIG5vZGUgKSwgV09SS0lOR19DT0xPUl9TUEFDRSwgY29sb3JTcGFjZSApICk7XHJcblxyXG4vKipcclxuICogVFNMIGZ1bmN0aW9uIGZvciBjb252ZXJ0aW5nIGEgZ2l2ZW4gY29sb3Igbm9kZSBmcm9tIHRoZSBnaXZlbiBjb2xvciBzcGFjZSB0byB0aGUgY3VycmVudCB3b3JraW5nIGNvbG9yIHNwYWNlLlxyXG4gKlxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHtOb2RlfSBub2RlIC0gUmVwcmVzZW50cyB0aGUgbm9kZSB0byBjb252ZXJ0LlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gY29sb3JTcGFjZSAtIFRoZSBzb3VyY2UgY29sb3Igc3BhY2UuXHJcbiAqIEByZXR1cm5zIHtDb2xvclNwYWNlTm9kZX1cclxuICovXHJcbmV4cG9ydCBjb25zdCBjb2xvclNwYWNlVG9Xb3JraW5nID0gKCBub2RlLCBjb2xvclNwYWNlICkgPT4gbm9kZU9iamVjdCggbmV3IENvbG9yU3BhY2VOb2RlKCBub2RlT2JqZWN0KCBub2RlICksIGNvbG9yU3BhY2UsIFdPUktJTkdfQ09MT1JfU1BBQ0UgKSApO1xyXG5cclxuLyoqXHJcbiAqIFRTTCBmdW5jdGlvbiBmb3IgY29udmVydGluZyBhIGdpdmVuIGNvbG9yIG5vZGUgZnJvbSBvbmUgY29sb3Igc3BhY2UgdG8gYW5vdGhlciBvbmUuXHJcbiAqXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0ge05vZGV9IG5vZGUgLSBSZXByZXNlbnRzIHRoZSBub2RlIHRvIGNvbnZlcnQuXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBzb3VyY2VDb2xvclNwYWNlIC0gVGhlIHNvdXJjZSBjb2xvciBzcGFjZS5cclxuICogQHBhcmFtIHtTdHJpbmd9IHRhcmdldENvbG9yU3BhY2UgLSBUaGUgdGFyZ2V0IGNvbG9yIHNwYWNlLlxyXG4gKiBAcmV0dXJucyB7Q29sb3JTcGFjZU5vZGV9XHJcbiAqL1xyXG5leHBvcnQgY29uc3QgY29udmVydENvbG9yU3BhY2UgPSAoIG5vZGUsIHNvdXJjZUNvbG9yU3BhY2UsIHRhcmdldENvbG9yU3BhY2UgKSA9PiBub2RlT2JqZWN0KCBuZXcgQ29sb3JTcGFjZU5vZGUoIG5vZGVPYmplY3QoIG5vZGUgKSwgc291cmNlQ29sb3JTcGFjZSwgdGFyZ2V0Q29sb3JTcGFjZSApICk7XHJcblxyXG5hZGRNZXRob2RDaGFpbmluZyggJ3RvT3V0cHV0Q29sb3JTcGFjZScsIHRvT3V0cHV0Q29sb3JTcGFjZSApO1xyXG5hZGRNZXRob2RDaGFpbmluZyggJ3RvV29ya2luZ0NvbG9yU3BhY2UnLCB0b1dvcmtpbmdDb2xvclNwYWNlICk7XHJcblxyXG5hZGRNZXRob2RDaGFpbmluZyggJ3dvcmtpbmdUb0NvbG9yU3BhY2UnLCB3b3JraW5nVG9Db2xvclNwYWNlICk7XHJcbmFkZE1ldGhvZENoYWluaW5nKCAnY29sb3JTcGFjZVRvV29ya2luZycsIGNvbG9yU3BhY2VUb1dvcmtpbmcgKTtcclxuIiwiaW1wb3J0IE5vZGUgZnJvbSAnLi4vY29yZS9Ob2RlLmpzJztcclxuaW1wb3J0IHsgTm9kZVVwZGF0ZVR5cGUgfSBmcm9tICcuLi9jb3JlL2NvbnN0YW50cy5qcyc7XHJcbmltcG9ydCB7IHVuaWZvcm0gfSBmcm9tICcuLi9jb3JlL1VuaWZvcm1Ob2RlLmpzJztcclxuaW1wb3J0IHsgbm9kZU9iamVjdCB9IGZyb20gJy4uL3RzbC9UU0xDb3JlLmpzJztcclxuaW1wb3J0IEFycmF5RWxlbWVudE5vZGUgZnJvbSAnLi4vdXRpbHMvQXJyYXlFbGVtZW50Tm9kZS5qcyc7XHJcblxyXG5jbGFzcyBSZWZlcmVuY2VFbGVtZW50Tm9kZSBleHRlbmRzIEFycmF5RWxlbWVudE5vZGUge1xyXG5cclxuXHRzdGF0aWMgZ2V0IHR5cGUoKSB7XHJcblxyXG5cdFx0cmV0dXJuICdSZWZlcmVuY2VFbGVtZW50Tm9kZSc7XHJcblxyXG5cdH1cclxuXHJcblx0Y29uc3RydWN0b3IoIHJlZmVyZW5jZU5vZGUsIGluZGV4Tm9kZSApIHtcclxuXHJcblx0XHRzdXBlciggcmVmZXJlbmNlTm9kZSwgaW5kZXhOb2RlICk7XHJcblxyXG5cdFx0dGhpcy5yZWZlcmVuY2VOb2RlID0gcmVmZXJlbmNlTm9kZTtcclxuXHJcblx0XHR0aGlzLmlzUmVmZXJlbmNlRWxlbWVudE5vZGUgPSB0cnVlO1xyXG5cclxuXHR9XHJcblxyXG5cdGdldE5vZGVUeXBlKCkge1xyXG5cclxuXHRcdHJldHVybiB0aGlzLnJlZmVyZW5jZU5vZGUudW5pZm9ybVR5cGU7XHJcblxyXG5cdH1cclxuXHJcblx0Z2VuZXJhdGUoIGJ1aWxkZXIgKSB7XHJcblxyXG5cdFx0Y29uc3Qgc25pcHBldCA9IHN1cGVyLmdlbmVyYXRlKCBidWlsZGVyICk7XHJcblx0XHRjb25zdCBhcnJheVR5cGUgPSB0aGlzLnJlZmVyZW5jZU5vZGUuZ2V0Tm9kZVR5cGUoKTtcclxuXHRcdGNvbnN0IGVsZW1lbnRUeXBlID0gdGhpcy5nZXROb2RlVHlwZSgpO1xyXG5cclxuXHRcdHJldHVybiBidWlsZGVyLmZvcm1hdCggc25pcHBldCwgYXJyYXlUeXBlLCBlbGVtZW50VHlwZSApO1xyXG5cclxuXHR9XHJcblxyXG59XHJcblxyXG5jbGFzcyBSZWZlcmVuY2VCYXNlTm9kZSBleHRlbmRzIE5vZGUge1xyXG5cclxuXHRzdGF0aWMgZ2V0IHR5cGUoKSB7XHJcblxyXG5cdFx0cmV0dXJuICdSZWZlcmVuY2VCYXNlTm9kZSc7XHJcblxyXG5cdH1cclxuXHJcblx0Y29uc3RydWN0b3IoIHByb3BlcnR5LCB1bmlmb3JtVHlwZSwgb2JqZWN0ID0gbnVsbCwgY291bnQgPSBudWxsICkge1xyXG5cclxuXHRcdHN1cGVyKCk7XHJcblxyXG5cdFx0dGhpcy5wcm9wZXJ0eSA9IHByb3BlcnR5O1xyXG5cdFx0dGhpcy51bmlmb3JtVHlwZSA9IHVuaWZvcm1UeXBlO1xyXG5cdFx0dGhpcy5vYmplY3QgPSBvYmplY3Q7XHJcblx0XHR0aGlzLmNvdW50ID0gY291bnQ7XHJcblxyXG5cdFx0dGhpcy5wcm9wZXJ0aWVzID0gcHJvcGVydHkuc3BsaXQoICcuJyApO1xyXG5cdFx0dGhpcy5yZWZlcmVuY2UgPSBvYmplY3Q7XHJcblx0XHR0aGlzLm5vZGUgPSBudWxsO1xyXG5cdFx0dGhpcy5ncm91cCA9IG51bGw7XHJcblxyXG5cdFx0dGhpcy51cGRhdGVUeXBlID0gTm9kZVVwZGF0ZVR5cGUuT0JKRUNUO1xyXG5cclxuXHR9XHJcblxyXG5cdHNldEdyb3VwKCBncm91cCApIHtcclxuXHJcblx0XHR0aGlzLmdyb3VwID0gZ3JvdXA7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHJcblx0ZWxlbWVudCggaW5kZXhOb2RlICkge1xyXG5cclxuXHRcdHJldHVybiBub2RlT2JqZWN0KCBuZXcgUmVmZXJlbmNlRWxlbWVudE5vZGUoIHRoaXMsIG5vZGVPYmplY3QoIGluZGV4Tm9kZSApICkgKTtcclxuXHJcblx0fVxyXG5cclxuXHRzZXROb2RlVHlwZSggdW5pZm9ybVR5cGUgKSB7XHJcblxyXG5cdFx0Y29uc3Qgbm9kZSA9IHVuaWZvcm0oIG51bGwsIHVuaWZvcm1UeXBlICkuZ2V0U2VsZigpO1xyXG5cclxuXHRcdGlmICggdGhpcy5ncm91cCAhPT0gbnVsbCApIHtcclxuXHJcblx0XHRcdG5vZGUuc2V0R3JvdXAoIHRoaXMuZ3JvdXAgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5ub2RlID0gbm9kZTtcclxuXHJcblx0fVxyXG5cclxuXHRnZXROb2RlVHlwZSggYnVpbGRlciApIHtcclxuXHJcblx0XHRpZiAoIHRoaXMubm9kZSA9PT0gbnVsbCApIHtcclxuXHJcblx0XHRcdHRoaXMudXBkYXRlUmVmZXJlbmNlKCBidWlsZGVyICk7XHJcblx0XHRcdHRoaXMudXBkYXRlVmFsdWUoKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMubm9kZS5nZXROb2RlVHlwZSggYnVpbGRlciApO1xyXG5cclxuXHR9XHJcblxyXG5cdGdldFZhbHVlRnJvbVJlZmVyZW5jZSggb2JqZWN0ID0gdGhpcy5yZWZlcmVuY2UgKSB7XHJcblxyXG5cdFx0Y29uc3QgeyBwcm9wZXJ0aWVzIH0gPSB0aGlzO1xyXG5cclxuXHRcdGxldCB2YWx1ZSA9IG9iamVjdFsgcHJvcGVydGllc1sgMCBdIF07XHJcblxyXG5cdFx0Zm9yICggbGV0IGkgPSAxOyBpIDwgcHJvcGVydGllcy5sZW5ndGg7IGkgKysgKSB7XHJcblxyXG5cdFx0XHR2YWx1ZSA9IHZhbHVlWyBwcm9wZXJ0aWVzWyBpIF0gXTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHZhbHVlO1xyXG5cclxuXHR9XHJcblxyXG5cdHVwZGF0ZVJlZmVyZW5jZSggc3RhdGUgKSB7XHJcblxyXG5cdFx0dGhpcy5yZWZlcmVuY2UgPSB0aGlzLm9iamVjdCAhPT0gbnVsbCA/IHRoaXMub2JqZWN0IDogc3RhdGUub2JqZWN0O1xyXG5cclxuXHRcdHJldHVybiB0aGlzLnJlZmVyZW5jZTtcclxuXHJcblx0fVxyXG5cclxuXHRzZXR1cCgpIHtcclxuXHJcblx0XHR0aGlzLnVwZGF0ZVZhbHVlKCk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMubm9kZTtcclxuXHJcblx0fVxyXG5cclxuXHR1cGRhdGUoIC8qZnJhbWUqLyApIHtcclxuXHJcblx0XHR0aGlzLnVwZGF0ZVZhbHVlKCk7XHJcblxyXG5cdH1cclxuXHJcblx0dXBkYXRlVmFsdWUoKSB7XHJcblxyXG5cdFx0aWYgKCB0aGlzLm5vZGUgPT09IG51bGwgKSB0aGlzLnNldE5vZGVUeXBlKCB0aGlzLnVuaWZvcm1UeXBlICk7XHJcblxyXG5cdFx0Y29uc3QgdmFsdWUgPSB0aGlzLmdldFZhbHVlRnJvbVJlZmVyZW5jZSgpO1xyXG5cclxuXHRcdGlmICggQXJyYXkuaXNBcnJheSggdmFsdWUgKSApIHtcclxuXHJcblx0XHRcdHRoaXMubm9kZS5hcnJheSA9IHZhbHVlO1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHR0aGlzLm5vZGUudmFsdWUgPSB2YWx1ZTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IFJlZmVyZW5jZUJhc2VOb2RlO1xyXG5cclxuZXhwb3J0IGNvbnN0IHJlZmVyZW5jZSA9ICggbmFtZSwgdHlwZSwgb2JqZWN0ICkgPT4gbm9kZU9iamVjdCggbmV3IFJlZmVyZW5jZUJhc2VOb2RlKCBuYW1lLCB0eXBlLCBvYmplY3QgKSApO1xyXG5leHBvcnQgY29uc3QgcmVmZXJlbmNlQnVmZmVyID0gKCBuYW1lLCB0eXBlLCBjb3VudCwgb2JqZWN0ICkgPT4gbm9kZU9iamVjdCggbmV3IFJlZmVyZW5jZUJhc2VOb2RlKCBuYW1lLCB0eXBlLCBvYmplY3QsIGNvdW50ICkgKTtcclxuIiwiaW1wb3J0IFJlZmVyZW5jZUJhc2VOb2RlIGZyb20gJy4vUmVmZXJlbmNlQmFzZU5vZGUuanMnO1xyXG5pbXBvcnQgeyBub2RlT2JqZWN0IH0gZnJvbSAnLi4vdHNsL1RTTENvcmUuanMnO1xyXG5pbXBvcnQgeyByZW5kZXJHcm91cCB9IGZyb20gJy4uL2NvcmUvVW5pZm9ybUdyb3VwTm9kZS5qcyc7XHJcblxyXG5jbGFzcyBSZW5kZXJlclJlZmVyZW5jZU5vZGUgZXh0ZW5kcyBSZWZlcmVuY2VCYXNlTm9kZSB7XHJcblxyXG5cdHN0YXRpYyBnZXQgdHlwZSgpIHtcclxuXHJcblx0XHRyZXR1cm4gJ1JlbmRlcmVyUmVmZXJlbmNlTm9kZSc7XHJcblxyXG5cdH1cclxuXHJcblx0Y29uc3RydWN0b3IoIHByb3BlcnR5LCBpbnB1dFR5cGUsIHJlbmRlcmVyID0gbnVsbCApIHtcclxuXHJcblx0XHRzdXBlciggcHJvcGVydHksIGlucHV0VHlwZSwgcmVuZGVyZXIgKTtcclxuXHJcblx0XHR0aGlzLnJlbmRlcmVyID0gcmVuZGVyZXI7XHJcblxyXG5cdFx0dGhpcy5zZXRHcm91cCggcmVuZGVyR3JvdXAgKTtcclxuXHJcblx0fVxyXG5cclxuXHR1cGRhdGVSZWZlcmVuY2UoIHN0YXRlICkge1xyXG5cclxuXHRcdHRoaXMucmVmZXJlbmNlID0gdGhpcy5yZW5kZXJlciAhPT0gbnVsbCA/IHRoaXMucmVuZGVyZXIgOiBzdGF0ZS5yZW5kZXJlcjtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5yZWZlcmVuY2U7XHJcblxyXG5cdH1cclxuXHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IFJlbmRlcmVyUmVmZXJlbmNlTm9kZTtcclxuXHJcbmV4cG9ydCBjb25zdCByZW5kZXJlclJlZmVyZW5jZSA9ICggbmFtZSwgdHlwZSwgcmVuZGVyZXIgKSA9PiBub2RlT2JqZWN0KCBuZXcgUmVuZGVyZXJSZWZlcmVuY2VOb2RlKCBuYW1lLCB0eXBlLCByZW5kZXJlciApICk7XHJcbiIsImltcG9ydCBUZW1wTm9kZSBmcm9tICcuLi9jb3JlL1RlbXBOb2RlLmpzJztcclxuaW1wb3J0IHsgYWRkTWV0aG9kQ2hhaW5pbmcsIG5vZGVPYmplY3QsIHZlYzQgfSBmcm9tICcuLi90c2wvVFNMQ29yZS5qcyc7XHJcbmltcG9ydCB7IHJlbmRlcmVyUmVmZXJlbmNlIH0gZnJvbSAnLi4vYWNjZXNzb3JzL1JlbmRlcmVyUmVmZXJlbmNlTm9kZS5qcyc7XHJcblxyXG5pbXBvcnQgeyBOb1RvbmVNYXBwaW5nIH0gZnJvbSAnLi4vLi4vY29uc3RhbnRzLmpzJztcclxuaW1wb3J0IHsgaGFzaCB9IGZyb20gJy4uL2NvcmUvTm9kZVV0aWxzLmpzJztcclxuXHJcbi8qKiBAbW9kdWxlIFRvbmVNYXBwaW5nTm9kZSAqKi9cclxuXHJcbi8qKlxyXG4gKiBUaGlzIG5vZGUgcmVwcmVzZW50cyBhIHRvbmUgbWFwcGluZyBvcGVyYXRpb24uXHJcbiAqXHJcbiAqIEBhdWdtZW50cyBUZW1wTm9kZVxyXG4gKi9cclxuY2xhc3MgVG9uZU1hcHBpbmdOb2RlIGV4dGVuZHMgVGVtcE5vZGUge1xyXG5cclxuXHRzdGF0aWMgZ2V0IHR5cGUoKSB7XHJcblxyXG5cdFx0cmV0dXJuICdUb25lTWFwcGluZ05vZGUnO1xyXG5cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIENvbnN0cnVjdHMgYSBuZXcgdG9uZSBtYXBwaW5nIG5vZGUuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge051bWJlcn0gdG9uZU1hcHBpbmcgLSBUaGUgdG9uZSBtYXBwaW5nIHR5cGUuXHJcblx0ICogQHBhcmFtIHtOb2RlfSBleHBvc3VyZU5vZGUgLSBUaGUgdG9uZSBtYXBwaW5nIGV4cG9zdXJlLlxyXG5cdCAqIEBwYXJhbSB7Tm9kZX0gW2NvbG9yTm9kZT1udWxsXSAtIFRoZSBjb2xvciBub2RlIHRvIHByb2Nlc3MuXHJcblx0ICovXHJcblx0Y29uc3RydWN0b3IoIHRvbmVNYXBwaW5nLCBleHBvc3VyZU5vZGUgPSB0b25lTWFwcGluZ0V4cG9zdXJlLCBjb2xvck5vZGUgPSBudWxsICkge1xyXG5cclxuXHRcdHN1cGVyKCAndmVjMycgKTtcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIFRoZSB0b25lIG1hcHBpbmcgdHlwZS5cclxuXHRcdCAqXHJcblx0XHQgKiBAdHlwZSB7TnVtYmVyfVxyXG5cdFx0ICovXHJcblx0XHR0aGlzLnRvbmVNYXBwaW5nID0gdG9uZU1hcHBpbmc7XHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBUaGUgdG9uZSBtYXBwaW5nIGV4cG9zdXJlLlxyXG5cdFx0ICpcclxuXHRcdCAqIEB0eXBlIHtOb2RlfVxyXG5cdFx0ICogQGRlZmF1bHQgbnVsbFxyXG5cdFx0ICovXHJcblx0XHR0aGlzLmV4cG9zdXJlTm9kZSA9IGV4cG9zdXJlTm9kZTtcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIFJlcHJlc2VudHMgdGhlIGNvbG9yIHRvIHByb2Nlc3MuXHJcblx0XHQgKlxyXG5cdFx0ICogQHR5cGUge05vZGU/fVxyXG5cdFx0ICogQGRlZmF1bHQgbnVsbFxyXG5cdFx0ICovXHJcblx0XHR0aGlzLmNvbG9yTm9kZSA9IGNvbG9yTm9kZTtcclxuXHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBPdmVyd3JpdGVzIHRoZSBkZWZhdWx0IGBjdXN0b21DYWNoZUtleSgpYCBpbXBsZW1lbnRhdGlvbiBieSBpbmNsdWRpbmcgdGhlIHRvbmVcclxuXHQgKiBtYXBwaW5nIHR5cGUgaW50byB0aGUgY2FjaGUga2V5LlxyXG5cdCAqXHJcblx0ICogQHJldHVybiB7TnVtYmVyfSBUaGUgaGFzaC5cclxuXHQgKi9cclxuXHRjdXN0b21DYWNoZUtleSgpIHtcclxuXHJcblx0XHRyZXR1cm4gaGFzaCggdGhpcy50b25lTWFwcGluZyApO1xyXG5cclxuXHR9XHJcblxyXG5cdHNldHVwKCBidWlsZGVyICkge1xyXG5cclxuXHRcdGNvbnN0IGNvbG9yTm9kZSA9IHRoaXMuY29sb3JOb2RlIHx8IGJ1aWxkZXIuY29udGV4dC5jb2xvcjtcclxuXHRcdGNvbnN0IHRvbmVNYXBwaW5nID0gdGhpcy50b25lTWFwcGluZztcclxuXHJcblx0XHRpZiAoIHRvbmVNYXBwaW5nID09PSBOb1RvbmVNYXBwaW5nICkgcmV0dXJuIGNvbG9yTm9kZTtcclxuXHJcblx0XHRsZXQgb3V0cHV0Tm9kZSA9IG51bGw7XHJcblxyXG5cdFx0Y29uc3QgdG9uZU1hcHBpbmdGbiA9IGJ1aWxkZXIucmVuZGVyZXIubGlicmFyeS5nZXRUb25lTWFwcGluZ0Z1bmN0aW9uKCB0b25lTWFwcGluZyApO1xyXG5cclxuXHRcdGlmICggdG9uZU1hcHBpbmdGbiAhPT0gbnVsbCApIHtcclxuXHJcblx0XHRcdG91dHB1dE5vZGUgPSB2ZWM0KCB0b25lTWFwcGluZ0ZuKCBjb2xvck5vZGUucmdiLCB0aGlzLmV4cG9zdXJlTm9kZSApLCBjb2xvck5vZGUuYSApO1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRjb25zb2xlLmVycm9yKCAnVG9uZU1hcHBpbmdOb2RlOiBVbnN1cHBvcnRlZCBUb25lIE1hcHBpbmcgY29uZmlndXJhdGlvbi4nLCB0b25lTWFwcGluZyApO1xyXG5cclxuXHRcdFx0b3V0cHV0Tm9kZSA9IGNvbG9yTm9kZTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIG91dHB1dE5vZGU7XHJcblxyXG5cdH1cclxuXHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IFRvbmVNYXBwaW5nTm9kZTtcclxuXHJcbi8qKlxyXG4gKiBUU0wgZnVuY3Rpb24gZm9yIGNyZWF0aW5nIGEgdG9uZSBtYXBwaW5nIG5vZGUuXHJcbiAqXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0ge051bWJlcn0gbWFwcGluZyAtIFRoZSB0b25lIG1hcHBpbmcgdHlwZS5cclxuICogQHBhcmFtIHtOb2RlPGZsb2F0PiB8IE51bWJlcn0gZXhwb3N1cmUgLSBUaGUgdG9uZSBtYXBwaW5nIGV4cG9zdXJlLlxyXG4gKiBAcGFyYW0ge05vZGU8dmVjMz4gfCBDb2xvcn0gY29sb3IgLSBUaGUgY29sb3Igbm9kZSB0byBwcm9jZXNzLlxyXG4gKiBAcmV0dXJucyB7VG9uZU1hcHBpbmdOb2RlPHZlYzM+fVxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IHRvbmVNYXBwaW5nID0gKCBtYXBwaW5nLCBleHBvc3VyZSwgY29sb3IgKSA9PiBub2RlT2JqZWN0KCBuZXcgVG9uZU1hcHBpbmdOb2RlKCBtYXBwaW5nLCBub2RlT2JqZWN0KCBleHBvc3VyZSApLCBub2RlT2JqZWN0KCBjb2xvciApICkgKTtcclxuXHJcbi8qKlxyXG4gKiBUU0wgb2JqZWN0IHRoYXQgcmVwcmVzZW50cyB0aGUgZ2xvYmFsIHRvbmUgbWFwcGluZyBleHBvc3VyZSBvZiB0aGUgcmVuZGVyZXIuXHJcbiAqXHJcbiAqIEB0eXBlIHtSZW5kZXJlclJlZmVyZW5jZU5vZGU8dmVjMz59XHJcbiAqL1xyXG5leHBvcnQgY29uc3QgdG9uZU1hcHBpbmdFeHBvc3VyZSA9IC8qQF9fUFVSRV9fKi8gcmVuZGVyZXJSZWZlcmVuY2UoICd0b25lTWFwcGluZ0V4cG9zdXJlJywgJ2Zsb2F0JyApO1xyXG5cclxuYWRkTWV0aG9kQ2hhaW5pbmcoICd0b25lTWFwcGluZycsICggY29sb3IsIG1hcHBpbmcsIGV4cG9zdXJlICkgPT4gdG9uZU1hcHBpbmcoIG1hcHBpbmcsIGV4cG9zdXJlLCBjb2xvciApICk7XHJcbiIsImltcG9ydCBJbnB1dE5vZGUgZnJvbSAnLi4vY29yZS9JbnB1dE5vZGUuanMnO1xyXG5pbXBvcnQgeyBub2RlT2JqZWN0LCBhZGRNZXRob2RDaGFpbmluZyB9IGZyb20gJy4uL3RzbC9UU0xDb3JlLmpzJztcclxuaW1wb3J0IHsgdmFyeWluZyB9IGZyb20gJy4uL2NvcmUvVmFyeWluZ05vZGUuanMnO1xyXG5cclxuaW1wb3J0IHsgSW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGUgfSBmcm9tICcuLi8uLi9jb3JlL0ludGVybGVhdmVkQnVmZmVyQXR0cmlidXRlLmpzJztcclxuaW1wb3J0IHsgSW50ZXJsZWF2ZWRCdWZmZXIgfSBmcm9tICcuLi8uLi9jb3JlL0ludGVybGVhdmVkQnVmZmVyLmpzJztcclxuaW1wb3J0IHsgU3RhdGljRHJhd1VzYWdlLCBEeW5hbWljRHJhd1VzYWdlIH0gZnJvbSAnLi4vLi4vY29uc3RhbnRzLmpzJztcclxuXHJcbmNsYXNzIEJ1ZmZlckF0dHJpYnV0ZU5vZGUgZXh0ZW5kcyBJbnB1dE5vZGUge1xyXG5cclxuXHRzdGF0aWMgZ2V0IHR5cGUoKSB7XHJcblxyXG5cdFx0cmV0dXJuICdCdWZmZXJBdHRyaWJ1dGVOb2RlJztcclxuXHJcblx0fVxyXG5cclxuXHRjb25zdHJ1Y3RvciggdmFsdWUsIGJ1ZmZlclR5cGUgPSBudWxsLCBidWZmZXJTdHJpZGUgPSAwLCBidWZmZXJPZmZzZXQgPSAwICkge1xyXG5cclxuXHRcdHN1cGVyKCB2YWx1ZSwgYnVmZmVyVHlwZSApO1xyXG5cclxuXHRcdHRoaXMuaXNCdWZmZXJOb2RlID0gdHJ1ZTtcclxuXHJcblx0XHR0aGlzLmJ1ZmZlclR5cGUgPSBidWZmZXJUeXBlO1xyXG5cdFx0dGhpcy5idWZmZXJTdHJpZGUgPSBidWZmZXJTdHJpZGU7XHJcblx0XHR0aGlzLmJ1ZmZlck9mZnNldCA9IGJ1ZmZlck9mZnNldDtcclxuXHJcblx0XHR0aGlzLnVzYWdlID0gU3RhdGljRHJhd1VzYWdlO1xyXG5cdFx0dGhpcy5pbnN0YW5jZWQgPSBmYWxzZTtcclxuXHJcblx0XHR0aGlzLmF0dHJpYnV0ZSA9IG51bGw7XHJcblxyXG5cdFx0dGhpcy5nbG9iYWwgPSB0cnVlO1xyXG5cclxuXHRcdGlmICggdmFsdWUgJiYgdmFsdWUuaXNCdWZmZXJBdHRyaWJ1dGUgPT09IHRydWUgKSB7XHJcblxyXG5cdFx0XHR0aGlzLmF0dHJpYnV0ZSA9IHZhbHVlO1xyXG5cdFx0XHR0aGlzLnVzYWdlID0gdmFsdWUudXNhZ2U7XHJcblx0XHRcdHRoaXMuaW5zdGFuY2VkID0gdmFsdWUuaXNJbnN0YW5jZWRCdWZmZXJBdHRyaWJ1dGU7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdGdldEhhc2goIGJ1aWxkZXIgKSB7XHJcblxyXG5cdFx0aWYgKCB0aGlzLmJ1ZmZlclN0cmlkZSA9PT0gMCAmJiB0aGlzLmJ1ZmZlck9mZnNldCA9PT0gMCApIHtcclxuXHJcblx0XHRcdGxldCBidWZmZXJEYXRhID0gYnVpbGRlci5nbG9iYWxDYWNoZS5nZXREYXRhKCB0aGlzLnZhbHVlICk7XHJcblxyXG5cdFx0XHRpZiAoIGJ1ZmZlckRhdGEgPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0YnVmZmVyRGF0YSA9IHtcclxuXHRcdFx0XHRcdG5vZGU6IHRoaXNcclxuXHRcdFx0XHR9O1xyXG5cclxuXHRcdFx0XHRidWlsZGVyLmdsb2JhbENhY2hlLnNldERhdGEoIHRoaXMudmFsdWUsIGJ1ZmZlckRhdGEgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHJldHVybiBidWZmZXJEYXRhLm5vZGUudXVpZDtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMudXVpZDtcclxuXHJcblx0fVxyXG5cclxuXHRnZXROb2RlVHlwZSggYnVpbGRlciApIHtcclxuXHJcblx0XHRpZiAoIHRoaXMuYnVmZmVyVHlwZSA9PT0gbnVsbCApIHtcclxuXHJcblx0XHRcdHRoaXMuYnVmZmVyVHlwZSA9IGJ1aWxkZXIuZ2V0VHlwZUZyb21BdHRyaWJ1dGUoIHRoaXMuYXR0cmlidXRlICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzLmJ1ZmZlclR5cGU7XHJcblxyXG5cdH1cclxuXHJcblx0c2V0dXAoIGJ1aWxkZXIgKSB7XHJcblxyXG5cdFx0aWYgKCB0aGlzLmF0dHJpYnV0ZSAhPT0gbnVsbCApIHJldHVybjtcclxuXHJcblx0XHRjb25zdCB0eXBlID0gdGhpcy5nZXROb2RlVHlwZSggYnVpbGRlciApO1xyXG5cdFx0Y29uc3QgYXJyYXkgPSB0aGlzLnZhbHVlO1xyXG5cdFx0Y29uc3QgaXRlbVNpemUgPSBidWlsZGVyLmdldFR5cGVMZW5ndGgoIHR5cGUgKTtcclxuXHRcdGNvbnN0IHN0cmlkZSA9IHRoaXMuYnVmZmVyU3RyaWRlIHx8IGl0ZW1TaXplO1xyXG5cdFx0Y29uc3Qgb2Zmc2V0ID0gdGhpcy5idWZmZXJPZmZzZXQ7XHJcblxyXG5cdFx0Y29uc3QgYnVmZmVyID0gYXJyYXkuaXNJbnRlcmxlYXZlZEJ1ZmZlciA9PT0gdHJ1ZSA/IGFycmF5IDogbmV3IEludGVybGVhdmVkQnVmZmVyKCBhcnJheSwgc3RyaWRlICk7XHJcblx0XHRjb25zdCBidWZmZXJBdHRyaWJ1dGUgPSBuZXcgSW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGUoIGJ1ZmZlciwgaXRlbVNpemUsIG9mZnNldCApO1xyXG5cclxuXHRcdGJ1ZmZlci5zZXRVc2FnZSggdGhpcy51c2FnZSApO1xyXG5cclxuXHRcdHRoaXMuYXR0cmlidXRlID0gYnVmZmVyQXR0cmlidXRlO1xyXG5cdFx0dGhpcy5hdHRyaWJ1dGUuaXNJbnN0YW5jZWRCdWZmZXJBdHRyaWJ1dGUgPSB0aGlzLmluc3RhbmNlZDsgLy8gQFRPRE86IEFkZCBhIHBvc3NpYmxlOiBJbnN0YW5jZWRJbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZVxyXG5cclxuXHR9XHJcblxyXG5cdGdlbmVyYXRlKCBidWlsZGVyICkge1xyXG5cclxuXHRcdGNvbnN0IG5vZGVUeXBlID0gdGhpcy5nZXROb2RlVHlwZSggYnVpbGRlciApO1xyXG5cclxuXHRcdGNvbnN0IG5vZGVBdHRyaWJ1dGUgPSBidWlsZGVyLmdldEJ1ZmZlckF0dHJpYnV0ZUZyb21Ob2RlKCB0aGlzLCBub2RlVHlwZSApO1xyXG5cdFx0Y29uc3QgcHJvcGVydHlOYW1lID0gYnVpbGRlci5nZXRQcm9wZXJ0eU5hbWUoIG5vZGVBdHRyaWJ1dGUgKTtcclxuXHJcblx0XHRsZXQgb3V0cHV0ID0gbnVsbDtcclxuXHJcblx0XHRpZiAoIGJ1aWxkZXIuc2hhZGVyU3RhZ2UgPT09ICd2ZXJ0ZXgnIHx8IGJ1aWxkZXIuc2hhZGVyU3RhZ2UgPT09ICdjb21wdXRlJyApIHtcclxuXHJcblx0XHRcdHRoaXMubmFtZSA9IHByb3BlcnR5TmFtZTtcclxuXHJcblx0XHRcdG91dHB1dCA9IHByb3BlcnR5TmFtZTtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0Y29uc3Qgbm9kZVZhcnlpbmcgPSB2YXJ5aW5nKCB0aGlzICk7XHJcblxyXG5cdFx0XHRvdXRwdXQgPSBub2RlVmFyeWluZy5idWlsZCggYnVpbGRlciwgbm9kZVR5cGUgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIG91dHB1dDtcclxuXHJcblx0fVxyXG5cclxuXHRnZXRJbnB1dFR5cGUoIC8qYnVpbGRlciovICkge1xyXG5cclxuXHRcdHJldHVybiAnYnVmZmVyQXR0cmlidXRlJztcclxuXHJcblx0fVxyXG5cclxuXHRzZXRVc2FnZSggdmFsdWUgKSB7XHJcblxyXG5cdFx0dGhpcy51c2FnZSA9IHZhbHVlO1xyXG5cclxuXHRcdGlmICggdGhpcy5hdHRyaWJ1dGUgJiYgdGhpcy5hdHRyaWJ1dGUuaXNCdWZmZXJBdHRyaWJ1dGUgPT09IHRydWUgKSB7XHJcblxyXG5cdFx0XHR0aGlzLmF0dHJpYnV0ZS51c2FnZSA9IHZhbHVlO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fVxyXG5cclxuXHRzZXRJbnN0YW5jZWQoIHZhbHVlICkge1xyXG5cclxuXHRcdHRoaXMuaW5zdGFuY2VkID0gdmFsdWU7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IEJ1ZmZlckF0dHJpYnV0ZU5vZGU7XHJcblxyXG5leHBvcnQgY29uc3QgYnVmZmVyQXR0cmlidXRlID0gKCBhcnJheSwgdHlwZSwgc3RyaWRlLCBvZmZzZXQgKSA9PiBub2RlT2JqZWN0KCBuZXcgQnVmZmVyQXR0cmlidXRlTm9kZSggYXJyYXksIHR5cGUsIHN0cmlkZSwgb2Zmc2V0ICkgKTtcclxuZXhwb3J0IGNvbnN0IGR5bmFtaWNCdWZmZXJBdHRyaWJ1dGUgPSAoIGFycmF5LCB0eXBlLCBzdHJpZGUsIG9mZnNldCApID0+IGJ1ZmZlckF0dHJpYnV0ZSggYXJyYXksIHR5cGUsIHN0cmlkZSwgb2Zmc2V0ICkuc2V0VXNhZ2UoIER5bmFtaWNEcmF3VXNhZ2UgKTtcclxuXHJcbmV4cG9ydCBjb25zdCBpbnN0YW5jZWRCdWZmZXJBdHRyaWJ1dGUgPSAoIGFycmF5LCB0eXBlLCBzdHJpZGUsIG9mZnNldCApID0+IGJ1ZmZlckF0dHJpYnV0ZSggYXJyYXksIHR5cGUsIHN0cmlkZSwgb2Zmc2V0ICkuc2V0SW5zdGFuY2VkKCB0cnVlICk7XHJcbmV4cG9ydCBjb25zdCBpbnN0YW5jZWREeW5hbWljQnVmZmVyQXR0cmlidXRlID0gKCBhcnJheSwgdHlwZSwgc3RyaWRlLCBvZmZzZXQgKSA9PiBkeW5hbWljQnVmZmVyQXR0cmlidXRlKCBhcnJheSwgdHlwZSwgc3RyaWRlLCBvZmZzZXQgKS5zZXRJbnN0YW5jZWQoIHRydWUgKTtcclxuXHJcbmFkZE1ldGhvZENoYWluaW5nKCAndG9BdHRyaWJ1dGUnLCAoIGJ1ZmZlck5vZGUgKSA9PiBidWZmZXJBdHRyaWJ1dGUoIGJ1ZmZlck5vZGUudmFsdWUgKSApO1xyXG4iLCJpbXBvcnQgTm9kZSBmcm9tICcuLi9jb3JlL05vZGUuanMnO1xyXG5pbXBvcnQgeyBOb2RlVXBkYXRlVHlwZSB9IGZyb20gJy4uL2NvcmUvY29uc3RhbnRzLmpzJztcclxuaW1wb3J0IHsgYWRkTWV0aG9kQ2hhaW5pbmcsIG5vZGVPYmplY3QgfSBmcm9tICcuLi90c2wvVFNMQ29yZS5qcyc7XHJcblxyXG5jbGFzcyBDb21wdXRlTm9kZSBleHRlbmRzIE5vZGUge1xyXG5cclxuXHRzdGF0aWMgZ2V0IHR5cGUoKSB7XHJcblxyXG5cdFx0cmV0dXJuICdDb21wdXRlTm9kZSc7XHJcblxyXG5cdH1cclxuXHJcblx0Y29uc3RydWN0b3IoIGNvbXB1dGVOb2RlLCBjb3VudCwgd29ya2dyb3VwU2l6ZSA9IFsgNjQgXSApIHtcclxuXHJcblx0XHRzdXBlciggJ3ZvaWQnICk7XHJcblxyXG5cdFx0dGhpcy5pc0NvbXB1dGVOb2RlID0gdHJ1ZTtcclxuXHJcblx0XHR0aGlzLmNvbXB1dGVOb2RlID0gY29tcHV0ZU5vZGU7XHJcblxyXG5cdFx0dGhpcy5jb3VudCA9IGNvdW50O1xyXG5cdFx0dGhpcy53b3JrZ3JvdXBTaXplID0gd29ya2dyb3VwU2l6ZTtcclxuXHRcdHRoaXMuZGlzcGF0Y2hDb3VudCA9IDA7XHJcblxyXG5cdFx0dGhpcy52ZXJzaW9uID0gMTtcclxuXHRcdHRoaXMudXBkYXRlQmVmb3JlVHlwZSA9IE5vZGVVcGRhdGVUeXBlLk9CSkVDVDtcclxuXHJcblx0XHR0aGlzLm9uSW5pdEZ1bmN0aW9uID0gbnVsbDtcclxuXHJcblx0XHR0aGlzLnVwZGF0ZURpc3BhdGNoQ291bnQoKTtcclxuXHJcblx0fVxyXG5cclxuXHRkaXNwb3NlKCkge1xyXG5cclxuXHRcdHRoaXMuZGlzcGF0Y2hFdmVudCggeyB0eXBlOiAnZGlzcG9zZScgfSApO1xyXG5cclxuXHR9XHJcblxyXG5cdHNldCBuZWVkc1VwZGF0ZSggdmFsdWUgKSB7XHJcblxyXG5cdFx0aWYgKCB2YWx1ZSA9PT0gdHJ1ZSApIHRoaXMudmVyc2lvbiArKztcclxuXHJcblx0fVxyXG5cclxuXHR1cGRhdGVEaXNwYXRjaENvdW50KCkge1xyXG5cclxuXHRcdGNvbnN0IHsgY291bnQsIHdvcmtncm91cFNpemUgfSA9IHRoaXM7XHJcblxyXG5cdFx0bGV0IHNpemUgPSB3b3JrZ3JvdXBTaXplWyAwIF07XHJcblxyXG5cdFx0Zm9yICggbGV0IGkgPSAxOyBpIDwgd29ya2dyb3VwU2l6ZS5sZW5ndGg7IGkgKysgKVxyXG5cdFx0XHRzaXplICo9IHdvcmtncm91cFNpemVbIGkgXTtcclxuXHJcblx0XHR0aGlzLmRpc3BhdGNoQ291bnQgPSBNYXRoLmNlaWwoIGNvdW50IC8gc2l6ZSApO1xyXG5cclxuXHR9XHJcblxyXG5cdG9uSW5pdCggY2FsbGJhY2sgKSB7XHJcblxyXG5cdFx0dGhpcy5vbkluaXRGdW5jdGlvbiA9IGNhbGxiYWNrO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9XHJcblxyXG5cdHVwZGF0ZUJlZm9yZSggeyByZW5kZXJlciB9ICkge1xyXG5cclxuXHRcdHJlbmRlcmVyLmNvbXB1dGUoIHRoaXMgKTtcclxuXHJcblx0fVxyXG5cclxuXHRnZW5lcmF0ZSggYnVpbGRlciApIHtcclxuXHJcblx0XHRjb25zdCB7IHNoYWRlclN0YWdlIH0gPSBidWlsZGVyO1xyXG5cclxuXHRcdGlmICggc2hhZGVyU3RhZ2UgPT09ICdjb21wdXRlJyApIHtcclxuXHJcblx0XHRcdGNvbnN0IHNuaXBwZXQgPSB0aGlzLmNvbXB1dGVOb2RlLmJ1aWxkKCBidWlsZGVyLCAndm9pZCcgKTtcclxuXHJcblx0XHRcdGlmICggc25pcHBldCAhPT0gJycgKSB7XHJcblxyXG5cdFx0XHRcdGJ1aWxkZXIuYWRkTGluZUZsb3dDb2RlKCBzbmlwcGV0LCB0aGlzICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBDb21wdXRlTm9kZTtcclxuXHJcbmV4cG9ydCBjb25zdCBjb21wdXRlID0gKCBub2RlLCBjb3VudCwgd29ya2dyb3VwU2l6ZSApID0+IG5vZGVPYmplY3QoIG5ldyBDb21wdXRlTm9kZSggbm9kZU9iamVjdCggbm9kZSApLCBjb3VudCwgd29ya2dyb3VwU2l6ZSApICk7XHJcblxyXG5hZGRNZXRob2RDaGFpbmluZyggJ2NvbXB1dGUnLCBjb21wdXRlICk7XHJcbiIsImltcG9ydCBOb2RlIGZyb20gJy4vTm9kZS5qcyc7XHJcbmltcG9ydCB7IGFkZE1ldGhvZENoYWluaW5nLCBub2RlT2JqZWN0IH0gZnJvbSAnLi4vdHNsL1RTTENvcmUuanMnO1xyXG5cclxuLyoqIEBtb2R1bGUgQ2FjaGVOb2RlICoqL1xyXG5cclxuLyoqXHJcbiAqIFRoaXMgbm9kZSBjYW4gYmUgdXNlZCBhcyBhIGNhY2hlIG1hbmFnZW1lbnQgY29tcG9uZW50IGZvciBhbm90aGVyIG5vZGUuXHJcbiAqIENhY2hpbmcgaXMgaW4gZ2VuZXJhbCB1c2VkIGJ5IGRlZmF1bHQgaW4ge0BsaW5rIE5vZGVCdWlsZGVyfSBidXQgdGhpcyBub2RlXHJcbiAqIGFsbG93cyB0aGUgdXNhZ2Ugb2YgYSBzaGFyZWQgcGFyZW50IGNhY2hlIGR1cmluZyB0aGUgYnVpbGQgcHJvY2Vzcy5cclxuICpcclxuICogQGF1Z21lbnRzIE5vZGVcclxuICovXHJcbmNsYXNzIENhY2hlTm9kZSBleHRlbmRzIE5vZGUge1xyXG5cclxuXHRzdGF0aWMgZ2V0IHR5cGUoKSB7XHJcblxyXG5cdFx0cmV0dXJuICdDYWNoZU5vZGUnO1xyXG5cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIENvbnN0cnVjdHMgYSBuZXcgY2FjaGUgbm9kZS5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7Tm9kZX0gbm9kZSAtIFRoZSBub2RlIHRoYXQgc2hvdWxkIGJlIGNhY2hlZC5cclxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IFtwYXJlbnQ9dHJ1ZV0gLSBXaGV0aGVyIHRoaXMgbm9kZSByZWZlcnMgdG8gYSBzaGFyZWQgcGFyZW50IGNhY2hlIG9yIG5vdC5cclxuXHQgKi9cclxuXHRjb25zdHJ1Y3Rvciggbm9kZSwgcGFyZW50ID0gdHJ1ZSApIHtcclxuXHJcblx0XHRzdXBlcigpO1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogVGhlIG5vZGUgdGhhdCBzaG91bGQgYmUgY2FjaGVkLlxyXG5cdFx0ICpcclxuXHRcdCAqIEB0eXBlIHtOb2RlfVxyXG5cdFx0ICovXHJcblx0XHR0aGlzLm5vZGUgPSBub2RlO1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogV2hldGhlciB0aGlzIG5vZGUgcmVmZXJzIHRvIGEgc2hhcmVkIHBhcmVudCBjYWNoZSBvciBub3QuXHJcblx0XHQgKlxyXG5cdFx0ICogQHR5cGUge0Jvb2xlYW59XHJcblx0XHQgKiBAZGVmYXVsdCB0cnVlXHJcblx0XHQgKi9cclxuXHRcdHRoaXMucGFyZW50ID0gcGFyZW50O1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogVGhpcyBmbGFnIGNhbiBiZSB1c2VkIGZvciB0eXBlIHRlc3RpbmcuXHJcblx0XHQgKlxyXG5cdFx0ICogQHR5cGUge0Jvb2xlYW59XHJcblx0XHQgKiBAcmVhZG9ubHlcclxuXHRcdCAqIEBkZWZhdWx0IHRydWVcclxuXHRcdCAqL1xyXG5cdFx0dGhpcy5pc0NhY2hlTm9kZSA9IHRydWU7XHJcblxyXG5cdH1cclxuXHJcblx0Z2V0Tm9kZVR5cGUoIGJ1aWxkZXIgKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMubm9kZS5nZXROb2RlVHlwZSggYnVpbGRlciApO1xyXG5cclxuXHR9XHJcblxyXG5cdGJ1aWxkKCBidWlsZGVyLCAuLi5wYXJhbXMgKSB7XHJcblxyXG5cdFx0Y29uc3QgcHJldmlvdXNDYWNoZSA9IGJ1aWxkZXIuZ2V0Q2FjaGUoKTtcclxuXHRcdGNvbnN0IGNhY2hlID0gYnVpbGRlci5nZXRDYWNoZUZyb21Ob2RlKCB0aGlzLCB0aGlzLnBhcmVudCApO1xyXG5cclxuXHRcdGJ1aWxkZXIuc2V0Q2FjaGUoIGNhY2hlICk7XHJcblxyXG5cdFx0Y29uc3QgZGF0YSA9IHRoaXMubm9kZS5idWlsZCggYnVpbGRlciwgLi4ucGFyYW1zICk7XHJcblxyXG5cdFx0YnVpbGRlci5zZXRDYWNoZSggcHJldmlvdXNDYWNoZSApO1xyXG5cclxuXHRcdHJldHVybiBkYXRhO1xyXG5cclxuXHR9XHJcblxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBDYWNoZU5vZGU7XHJcblxyXG4vKipcclxuICogVFNMIGZ1bmN0aW9uIGZvciBjcmVhdGluZyBhIGNhY2hlIG5vZGUuXHJcbiAqXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0ge05vZGV9IG5vZGUgLSBUaGUgbm9kZSB0aGF0IHNob3VsZCBiZSBjYWNoZWQuXHJcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gcGFyZW50IC0gV2hldGhlciB0aGlzIG5vZGUgcmVmZXJzIHRvIGEgc2hhcmVkIHBhcmVudCBjYWNoZSBvciBub3QuXHJcbiAqIEByZXR1cm5zIHtDYWNoZU5vZGV9XHJcbiAqL1xyXG5leHBvcnQgY29uc3QgY2FjaGUgPSAoIG5vZGUsIHBhcmVudCApID0+IG5vZGVPYmplY3QoIG5ldyBDYWNoZU5vZGUoIG5vZGVPYmplY3QoIG5vZGUgKSwgcGFyZW50ICkgKTtcclxuXHJcbmFkZE1ldGhvZENoYWluaW5nKCAnY2FjaGUnLCBjYWNoZSApO1xyXG4iLCJpbXBvcnQgTm9kZSBmcm9tICcuL05vZGUuanMnO1xyXG5pbXBvcnQgeyBhZGRNZXRob2RDaGFpbmluZywgbm9kZVByb3h5IH0gZnJvbSAnLi4vdHNsL1RTTENvcmUuanMnO1xyXG5cclxuLyoqIEBtb2R1bGUgQnlwYXNzTm9kZSAqKi9cclxuXHJcbi8qKlxyXG4gKiBUaGUgY2xhc3MgZ2VuZXJhdGVzIHRoZSBjb2RlIG9mIGEgZ2l2ZW4gbm9kZSBidXQgcmV0dXJucyBhbm90aGVyIG5vZGUgaW4gdGhlIG91dHB1dC5cclxuICogVGhpcyBjYW4gYmUgdXNlZCB0byBjYWxsIGEgbWV0aG9kIG9yIG5vZGUgdGhhdCBkb2VzIG5vdCByZXR1cm4gYSB2YWx1ZSwgaS5lLlxyXG4gKiB0eXBlIGB2b2lkYCBvbiBhbiBpbnB1dCB3aGVyZSByZXR1cm5pbmcgYSB2YWx1ZSBpcyByZXF1aXJlZC4gRXhhbXBsZTpcclxuICpcclxuICogYGBganNcclxuICogbWF0ZXJpYWwuY29sb3JOb2RlID0gbXlDb2xvci5ieXBhc3MoIHJ1blZvaWRGbigpIClcclxuICpgYGBcclxuICpcclxuICogQGF1Z21lbnRzIE5vZGVcclxuICovXHJcbmNsYXNzIEJ5cGFzc05vZGUgZXh0ZW5kcyBOb2RlIHtcclxuXHJcblx0c3RhdGljIGdldCB0eXBlKCkge1xyXG5cclxuXHRcdHJldHVybiAnQnlwYXNzTm9kZSc7XHJcblxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogQ29uc3RydWN0cyBhIG5ldyBieXBhc3Mgbm9kZS5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7Tm9kZX0gb3V0cHV0Tm9kZSAtIFRoZSBvdXRwdXQgbm9kZS5cclxuXHQgKiBAcGFyYW0ge05vZGV9IGNhbGxOb2RlIC0gVGhlIGNhbGwgbm9kZS5cclxuXHQgKi9cclxuXHRjb25zdHJ1Y3Rvciggb3V0cHV0Tm9kZSwgY2FsbE5vZGUgKSB7XHJcblxyXG5cdFx0c3VwZXIoKTtcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIFRoaXMgZmxhZyBjYW4gYmUgdXNlZCBmb3IgdHlwZSB0ZXN0aW5nLlxyXG5cdFx0ICpcclxuXHRcdCAqIEB0eXBlIHtCb29sZWFufVxyXG5cdFx0ICogQHJlYWRvbmx5XHJcblx0XHQgKiBAZGVmYXVsdCB0cnVlXHJcblx0XHQgKi9cclxuXHRcdHRoaXMuaXNCeXBhc3NOb2RlID0gdHJ1ZTtcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIFRoZSBvdXRwdXQgbm9kZS5cclxuXHRcdCAqXHJcblx0XHQgKiBAdHlwZSB7Tm9kZX1cclxuXHRcdCAqL1xyXG5cdFx0dGhpcy5vdXRwdXROb2RlID0gb3V0cHV0Tm9kZTtcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIFRoZSBjYWxsIG5vZGUuXHJcblx0XHQgKlxyXG5cdFx0ICogQHR5cGUge05vZGV9XHJcblx0XHQgKi9cclxuXHRcdHRoaXMuY2FsbE5vZGUgPSBjYWxsTm9kZTtcclxuXHJcblx0fVxyXG5cclxuXHRnZXROb2RlVHlwZSggYnVpbGRlciApIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5vdXRwdXROb2RlLmdldE5vZGVUeXBlKCBidWlsZGVyICk7XHJcblxyXG5cdH1cclxuXHJcblx0Z2VuZXJhdGUoIGJ1aWxkZXIgKSB7XHJcblxyXG5cdFx0Y29uc3Qgc25pcHBldCA9IHRoaXMuY2FsbE5vZGUuYnVpbGQoIGJ1aWxkZXIsICd2b2lkJyApO1xyXG5cclxuXHRcdGlmICggc25pcHBldCAhPT0gJycgKSB7XHJcblxyXG5cdFx0XHRidWlsZGVyLmFkZExpbmVGbG93Q29kZSggc25pcHBldCwgdGhpcyApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcy5vdXRwdXROb2RlLmJ1aWxkKCBidWlsZGVyICk7XHJcblxyXG5cdH1cclxuXHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IEJ5cGFzc05vZGU7XHJcblxyXG4vKipcclxuICogVFNMIGZ1bmN0aW9uIGZvciBjcmVhdGluZyBhIGJ5cGFzcyBub2RlLlxyXG4gKlxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHtOb2RlfSBvdXRwdXROb2RlIC0gVGhlIG91dHB1dCBub2RlLlxyXG4gKiBAcGFyYW0ge05vZGV9IGNhbGxOb2RlIC0gVGhlIGNhbGwgbm9kZS5cclxuICogQHJldHVybnMge0J5cGFzc05vZGV9XHJcbiAqL1xyXG5leHBvcnQgY29uc3QgYnlwYXNzID0gLypAX19QVVJFX18qLyBub2RlUHJveHkoIEJ5cGFzc05vZGUgKTtcclxuXHJcbmFkZE1ldGhvZENoYWluaW5nKCAnYnlwYXNzJywgYnlwYXNzICk7XHJcbiIsImltcG9ydCBOb2RlIGZyb20gJy4uL2NvcmUvTm9kZS5qcyc7XHJcbmltcG9ydCB7IGZsb2F0LCBhZGRNZXRob2RDaGFpbmluZywgbm9kZVByb3h5IH0gZnJvbSAnLi4vdHNsL1RTTENvcmUuanMnO1xyXG5cclxuLyoqIEBtb2R1bGUgUmVtYXBOb2RlICoqL1xyXG5cclxuLyoqXHJcbiAqIFRoaXMgbm9kZSBhbGxvd3MgdG8gcmVtYXAgYSBub2RlIHZhbHVlIGZyb20gb25lIHJhbmdlIGludG8gYW5vdGhlci4gRS5nIGEgdmFsdWUgb2ZcclxuICogYDAuNGAgaW4gdGhlIHJhbmdlIGBbIDAuMywgMC41IF1gIHNob3VsZCBiZSByZW1hcHBlZCBpbnRvIHRoZSBub3JtYWxpemVkIHJhbmdlIGBbIDAsIDEgXWAuXHJcbiAqIGBSZW1hcE5vZGVgIHRha2VzIGNhcmUgb2YgdGhhdCBhbmQgY29udmVydHMgdGhlIG9yaWdpbmFsIHZhbHVlIG9mIGAwLjRgIHRvIGAwLjVgLlxyXG4gKlxyXG4gKiBAYXVnbWVudHMgTm9kZVxyXG4gKi9cclxuY2xhc3MgUmVtYXBOb2RlIGV4dGVuZHMgTm9kZSB7XHJcblxyXG5cdHN0YXRpYyBnZXQgdHlwZSgpIHtcclxuXHJcblx0XHRyZXR1cm4gJ1JlbWFwTm9kZSc7XHJcblxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogQ29uc3RydWN0cyBhIG5ldyByZW1hcCBub2RlLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtOb2RlfSBub2RlIC0gVGhlIG5vZGUgdGhhdCBzaG91bGQgYmUgcmVtYXBwZWQuXHJcblx0ICogQHBhcmFtIHtOb2RlfSBpbkxvd05vZGUgLSBUaGUgc291cmNlIG9yIGN1cnJlbnQgbG93ZXIgYm91bmQgb2YgdGhlIHJhbmdlLlxyXG5cdCAqIEBwYXJhbSB7Tm9kZX0gaW5IaWdoTm9kZSAtIFRoZSBzb3VyY2Ugb3IgY3VycmVudCB1cHBlciBib3VuZCBvZiB0aGUgcmFuZ2UuXHJcblx0ICogQHBhcmFtIHtOb2RlfSBbb3V0TG93Tm9kZT1mbG9hdCgwKV0gLSBUaGUgdGFyZ2V0IGxvd2VyIGJvdW5kIG9mIHRoZSByYW5nZS5cclxuXHQgKiBAcGFyYW0ge05vZGV9IFtvdXRIaWdoTm9kZT1mbG9hdCgxKV0gLSBUaGUgdGFyZ2V0IHVwcGVyIGJvdW5kIG9mIHRoZSByYW5nZS5cclxuXHQgKi9cclxuXHRjb25zdHJ1Y3Rvciggbm9kZSwgaW5Mb3dOb2RlLCBpbkhpZ2hOb2RlLCBvdXRMb3dOb2RlID0gZmxvYXQoIDAgKSwgb3V0SGlnaE5vZGUgPSBmbG9hdCggMSApICkge1xyXG5cclxuXHRcdHN1cGVyKCk7XHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBUaGUgbm9kZSB0aGF0IHNob3VsZCBiZSByZW1hcHBlZC5cclxuXHRcdCAqXHJcblx0XHQgKiBAdHlwZSB7Tm9kZX1cclxuXHRcdCAqL1xyXG5cdFx0dGhpcy5ub2RlID0gbm9kZTtcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIFRoZSBzb3VyY2Ugb3IgY3VycmVudCBsb3dlciBib3VuZCBvZiB0aGUgcmFuZ2UuXHJcblx0XHQgKlxyXG5cdFx0ICogQHR5cGUge05vZGV9XHJcblx0XHQgKi9cclxuXHRcdHRoaXMuaW5Mb3dOb2RlID0gaW5Mb3dOb2RlO1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogVGhlIHNvdXJjZSBvciBjdXJyZW50IHVwcGVyIGJvdW5kIG9mIHRoZSByYW5nZS5cclxuXHRcdCAqXHJcblx0XHQgKiBAdHlwZSB7Tm9kZX1cclxuXHRcdCAqL1xyXG5cdFx0dGhpcy5pbkhpZ2hOb2RlID0gaW5IaWdoTm9kZTtcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIFRoZSB0YXJnZXQgbG93ZXIgYm91bmQgb2YgdGhlIHJhbmdlLlxyXG5cdFx0ICpcclxuXHRcdCAqIEB0eXBlIHtOb2RlfVxyXG5cdFx0ICogQGRlZmF1bHQgZmxvYXQoMClcclxuXHRcdCAqL1xyXG5cdFx0dGhpcy5vdXRMb3dOb2RlID0gb3V0TG93Tm9kZTtcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIFRoZSB0YXJnZXQgdXBwZXIgYm91bmQgb2YgdGhlIHJhbmdlLlxyXG5cdFx0ICpcclxuXHRcdCAqIEB0eXBlIHtOb2RlfVxyXG5cdFx0ICogQGRlZmF1bHQgZmxvYXQoMSlcclxuXHRcdCAqL1xyXG5cdFx0dGhpcy5vdXRIaWdoTm9kZSA9IG91dEhpZ2hOb2RlO1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogV2hldGhlciB0aGUgbm9kZSB2YWx1ZSBzaG91bGQgYmUgY2xhbXBlZCBiZWZvcmVcclxuXHRcdCAqIHJlbWFwcGluZyBpdCB0byB0aGUgdGFyZ2V0IHJhbmdlLlxyXG5cdFx0ICpcclxuXHRcdCAqIEB0eXBlIHtCb29sZWFufVxyXG5cdFx0ICogQGRlZmF1bHQgdHJ1ZVxyXG5cdFx0ICovXHJcblx0XHR0aGlzLmRvQ2xhbXAgPSB0cnVlO1xyXG5cclxuXHR9XHJcblxyXG5cdHNldHVwKCkge1xyXG5cclxuXHRcdGNvbnN0IHsgbm9kZSwgaW5Mb3dOb2RlLCBpbkhpZ2hOb2RlLCBvdXRMb3dOb2RlLCBvdXRIaWdoTm9kZSwgZG9DbGFtcCB9ID0gdGhpcztcclxuXHJcblx0XHRsZXQgdCA9IG5vZGUuc3ViKCBpbkxvd05vZGUgKS5kaXYoIGluSGlnaE5vZGUuc3ViKCBpbkxvd05vZGUgKSApO1xyXG5cclxuXHRcdGlmICggZG9DbGFtcCA9PT0gdHJ1ZSApIHQgPSB0LmNsYW1wKCk7XHJcblxyXG5cdFx0cmV0dXJuIHQubXVsKCBvdXRIaWdoTm9kZS5zdWIoIG91dExvd05vZGUgKSApLmFkZCggb3V0TG93Tm9kZSApO1xyXG5cclxuXHR9XHJcblxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBSZW1hcE5vZGU7XHJcblxyXG4vKipcclxuICogVFNMIGZ1bmN0aW9uIGZvciBjcmVhdGluZyBhIHJlbWFwIG5vZGUuXHJcbiAqXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0ge05vZGV9IG5vZGUgLSBUaGUgbm9kZSB0aGF0IHNob3VsZCBiZSByZW1hcHBlZC5cclxuICogQHBhcmFtIHtOb2RlfSBpbkxvd05vZGUgLSBUaGUgc291cmNlIG9yIGN1cnJlbnQgbG93ZXIgYm91bmQgb2YgdGhlIHJhbmdlLlxyXG4gKiBAcGFyYW0ge05vZGV9IGluSGlnaE5vZGUgLSBUaGUgc291cmNlIG9yIGN1cnJlbnQgdXBwZXIgYm91bmQgb2YgdGhlIHJhbmdlLlxyXG4gKiBAcGFyYW0ge05vZGV9IFtvdXRMb3dOb2RlPWZsb2F0KDApXSAtIFRoZSB0YXJnZXQgbG93ZXIgYm91bmQgb2YgdGhlIHJhbmdlLlxyXG4gKiBAcGFyYW0ge05vZGV9IFtvdXRIaWdoTm9kZT1mbG9hdCgxKV0gLSBUaGUgdGFyZ2V0IHVwcGVyIGJvdW5kIG9mIHRoZSByYW5nZS5cclxuICogQHJldHVybnMge1JlbWFwTm9kZX1cclxuICovXHJcbmV4cG9ydCBjb25zdCByZW1hcCA9IC8qQF9fUFVSRV9fKi8gbm9kZVByb3h5KCBSZW1hcE5vZGUsIG51bGwsIG51bGwsIHsgZG9DbGFtcDogZmFsc2UgfSApO1xyXG5cclxuLyoqXHJcbiAqIFRTTCBmdW5jdGlvbiBmb3IgY3JlYXRpbmcgYSByZW1hcCBub2RlLCBidXQgd2l0aCBlbmFibGVkIGNsYW1waW5nLlxyXG4gKlxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHtOb2RlfSBub2RlIC0gVGhlIG5vZGUgdGhhdCBzaG91bGQgYmUgcmVtYXBwZWQuXHJcbiAqIEBwYXJhbSB7Tm9kZX0gaW5Mb3dOb2RlIC0gVGhlIHNvdXJjZSBvciBjdXJyZW50IGxvd2VyIGJvdW5kIG9mIHRoZSByYW5nZS5cclxuICogQHBhcmFtIHtOb2RlfSBpbkhpZ2hOb2RlIC0gVGhlIHNvdXJjZSBvciBjdXJyZW50IHVwcGVyIGJvdW5kIG9mIHRoZSByYW5nZS5cclxuICogQHBhcmFtIHtOb2RlfSBbb3V0TG93Tm9kZT1mbG9hdCgwKV0gLSBUaGUgdGFyZ2V0IGxvd2VyIGJvdW5kIG9mIHRoZSByYW5nZS5cclxuICogQHBhcmFtIHtOb2RlfSBbb3V0SGlnaE5vZGU9ZmxvYXQoMSldIC0gVGhlIHRhcmdldCB1cHBlciBib3VuZCBvZiB0aGUgcmFuZ2UuXHJcbiAqIEByZXR1cm5zIHtSZW1hcE5vZGV9XHJcbiAqL1xyXG5leHBvcnQgY29uc3QgcmVtYXBDbGFtcCA9IC8qQF9fUFVSRV9fKi8gbm9kZVByb3h5KCBSZW1hcE5vZGUgKTtcclxuXHJcbmFkZE1ldGhvZENoYWluaW5nKCAncmVtYXAnLCByZW1hcCApO1xyXG5hZGRNZXRob2RDaGFpbmluZyggJ3JlbWFwQ2xhbXAnLCByZW1hcENsYW1wICk7XHJcbiIsImltcG9ydCBOb2RlIGZyb20gJy4uL2NvcmUvTm9kZS5qcyc7XHJcbmltcG9ydCB7IG5vZGVQcm94eSB9IGZyb20gJy4uL3RzbC9UU0xDb3JlLmpzJztcclxuXHJcbi8qKiBAbW9kdWxlIEV4cHJlc3Npb25Ob2RlICoqL1xyXG5cclxuLyoqXHJcbiAqIFRoaXMgY2xhc3MgY2FuIGJlIHVzZWQgdG8gaW1wbGVtZW50IGJhc2ljIGV4cHJlc3Npb25zIGluIHNoYWRlciBjb2RlLlxyXG4gKiBCYXNpYyBleGFtcGxlcyBmb3IgdGhhdCBhcmUgYHJldHVybmAsIGBjb250aW51ZWAgb3IgYGRpc2NhcmRgIHN0YXRlbWVudHMuXHJcbiAqXHJcbiAqIEBhdWdtZW50cyBOb2RlXHJcbiAqL1xyXG5jbGFzcyBFeHByZXNzaW9uTm9kZSBleHRlbmRzIE5vZGUge1xyXG5cclxuXHRzdGF0aWMgZ2V0IHR5cGUoKSB7XHJcblxyXG5cdFx0cmV0dXJuICdFeHByZXNzaW9uTm9kZSc7XHJcblxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogQ29uc3RydWN0cyBhIG5ldyBleHByZXNzaW9uIG5vZGUuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge1N0cmluZ30gW3NuaXBwZXQ9JyddIC0gVGhlIG5hdGl2ZSBjb2RlIHNuaXBwZXQuXHJcblx0ICogQHBhcmFtIHtTdHJpbmd9IFtub2RlVHlwZT0ndm9pZCddIC0gVGhlIG5vZGUgdHlwZS5cclxuXHQgKi9cclxuXHRjb25zdHJ1Y3Rvciggc25pcHBldCA9ICcnLCBub2RlVHlwZSA9ICd2b2lkJyApIHtcclxuXHJcblx0XHRzdXBlciggbm9kZVR5cGUgKTtcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIFRoZSBuYXRpdmUgY29kZSBzbmlwcGV0LlxyXG5cdFx0ICpcclxuXHRcdCAqIEB0eXBlIHtTdHJpbmd9XHJcblx0XHQgKiBAZGVmYXVsdCAnJ1xyXG5cdFx0ICovXHJcblx0XHR0aGlzLnNuaXBwZXQgPSBzbmlwcGV0O1xyXG5cclxuXHR9XHJcblxyXG5cdGdlbmVyYXRlKCBidWlsZGVyLCBvdXRwdXQgKSB7XHJcblxyXG5cdFx0Y29uc3QgdHlwZSA9IHRoaXMuZ2V0Tm9kZVR5cGUoIGJ1aWxkZXIgKTtcclxuXHRcdGNvbnN0IHNuaXBwZXQgPSB0aGlzLnNuaXBwZXQ7XHJcblxyXG5cdFx0aWYgKCB0eXBlID09PSAndm9pZCcgKSB7XHJcblxyXG5cdFx0XHRidWlsZGVyLmFkZExpbmVGbG93Q29kZSggc25pcHBldCwgdGhpcyApO1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gYnVpbGRlci5mb3JtYXQoIGAoICR7IHNuaXBwZXQgfSApYCwgdHlwZSwgb3V0cHV0ICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBFeHByZXNzaW9uTm9kZTtcclxuXHJcbi8qKlxyXG4gKiBUU0wgZnVuY3Rpb24gZm9yIGNyZWF0aW5nIGFuIGV4cHJlc3Npb24gbm9kZS5cclxuICpcclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBbc25pcHBldD0nJ10gLSBUaGUgbmF0aXZlIGNvZGUgc25pcHBldC5cclxuICogQHBhcmFtIHtTdHJpbmd9IFtub2RlVHlwZT0ndm9pZCddIC0gVGhlIG5vZGUgdHlwZS5cclxuICogQHJldHVybnMge0V4cHJlc3Npb25Ob2RlfVxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IGV4cHJlc3Npb24gPSAvKkBfX1BVUkVfXyovIG5vZGVQcm94eSggRXhwcmVzc2lvbk5vZGUgKTtcclxuIiwiaW1wb3J0IHsgc2VsZWN0IH0gZnJvbSAnLi4vbWF0aC9Db25kaXRpb25hbE5vZGUuanMnO1xyXG5pbXBvcnQgeyBleHByZXNzaW9uIH0gZnJvbSAnLi4vY29kZS9FeHByZXNzaW9uTm9kZS5qcyc7XHJcbmltcG9ydCB7IGFkZE1ldGhvZENoYWluaW5nIH0gZnJvbSAnLi4vdHNsL1RTTENvcmUuanMnO1xyXG5cclxuLyoqIEBtb2R1bGUgRGlzY2FyZCAqKi9cclxuXHJcbi8qKlxyXG4gKiBSZXByZXNlbnRzIGEgYGRpc2NhcmRgIHNoYWRlciBvcGVyYXRpb24gaW4gVFNMLlxyXG4gKlxyXG4gKiBAbWV0aG9kXHJcbiAqIEBwYXJhbSB7Q29uZGl0aW9uYWxOb2RlP30gY29uZGl0aW9uYWwgLSBBbiBvcHRpb25hbCBjb25kaXRpb25hbCBub2RlLiBJdCBhbGxvd3MgdG8gZGVjaWRlIHdoZXRoZXIgdGhlIGRpc2NhcmQgc2hvdWxkIGJlIGV4ZWN1dGVkIG9yIG5vdC5cclxuICogQHJldHVybiB7Tm9kZX0gVGhlIGBkaXNjYXJkYCBleHByZXNzaW9uLlxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IERpc2NhcmQgPSAoIGNvbmRpdGlvbmFsICkgPT4gKCBjb25kaXRpb25hbCA/IHNlbGVjdCggY29uZGl0aW9uYWwsIGV4cHJlc3Npb24oICdkaXNjYXJkJyApICkgOiBleHByZXNzaW9uKCAnZGlzY2FyZCcgKSApLmFwcGVuZCgpO1xyXG5cclxuLyoqXHJcbiAqIFJlcHJlc2VudHMgYSBgcmV0dXJuYCBzaGFkZXIgb3BlcmF0aW9uIGluIFRTTC5cclxuICpcclxuICogQG1ldGhvZFxyXG4gKiBAcmV0dXJuIHtFeHByZXNzaW9uTm9kZX0gVGhlIGByZXR1cm5gIGV4cHJlc3Npb24uXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgUmV0dXJuID0gKCkgPT4gZXhwcmVzc2lvbiggJ3JldHVybicgKS5hcHBlbmQoKTtcclxuXHJcbmFkZE1ldGhvZENoYWluaW5nKCAnZGlzY2FyZCcsIERpc2NhcmQgKTtcclxuIiwiaW1wb3J0IFRlbXBOb2RlIGZyb20gJy4uL2NvcmUvVGVtcE5vZGUuanMnO1xyXG5pbXBvcnQgeyBhZGRNZXRob2RDaGFpbmluZywgbm9kZU9iamVjdCB9IGZyb20gJy4uL3RzbC9UU0xDb3JlLmpzJztcclxuXHJcbmltcG9ydCB7IE5vQ29sb3JTcGFjZSwgTm9Ub25lTWFwcGluZyB9IGZyb20gJy4uLy4uL2NvbnN0YW50cy5qcyc7XHJcbmltcG9ydCB7IENvbG9yTWFuYWdlbWVudCB9IGZyb20gJy4uLy4uL21hdGgvQ29sb3JNYW5hZ2VtZW50LmpzJztcclxuXHJcbi8qKiBAbW9kdWxlIFJlbmRlck91dHB1dE5vZGUgKiovXHJcblxyXG4vKipcclxuICogTm9ybWFsbHksIHRvbmUgbWFwcGluZyBhbmQgY29sb3IgY29udmVyc2lvbiBoYXBwZW5zIGF1dG9tYXRpY2FsbHlcclxuICogYmVmb3JlIG91dHB1dHRpbmcgcGl4ZWwgdG9vIHRoZSBkZWZhdWx0IChzY3JlZW4pIGZyYW1lYnVmZmVyLiBJbiBjZXJ0YWluXHJcbiAqIHBvc3QgcHJvY2Vzc2luZyBzZXR1cHMgdGhpcyBoYXBwZW5zIHRvIGxhdGUgYmVjYXVzZSBjZXJ0YWluIGVmZmVjdHNcclxuICogcmVxdWlyZSBlLmcuIHNSR0IgaW5wdXQuIEZvciBzdWNoIHNjZW5hcmlvcywgYFJlbmRlck91dHB1dE5vZGVgIGNhbiBiZSB1c2VkXHJcbiAqIHRvIGFwcGx5IHRvbmUgbWFwcGluZyBhbmQgY29sb3Igc3BhY2UgY29udmVyc2lvbiBhdCBhbiBhcmJpdHJhcnkgcG9pbnRcclxuICogaW4gdGhlIGVmZmVjdCBjaGFpbi5cclxuICpcclxuICogV2hlbiBhcHBseWluZyB0b25lIG1hcHBpbmcgYW5kIGNvbG9yIHNwYWNlIGNvbnZlcnNpb24gbWFudWFsbHkgd2l0aCB0aGlzIG5vZGUsXHJcbiAqIHlvdSBoYXZlIHRvIHNldCB7QGxpbmsgUG9zdFByb2Nlc3Npbmcjb3V0cHV0Q29sb3JUcmFuc2Zvcm19IHRvIGBmYWxzZWAuXHJcbiAqXHJcbiAqIGBgYGpzXHJcbiAqIGNvbnN0IHBvc3RQcm9jZXNzaW5nID0gbmV3IFBvc3RQcm9jZXNzaW5nKCByZW5kZXJlciApO1xyXG4gKiBwb3N0UHJvY2Vzc2luZy5vdXRwdXRDb2xvclRyYW5zZm9ybSA9IGZhbHNlO1xyXG4gKlxyXG4gKiBjb25zdCBzY2VuZVBhc3MgPSBwYXNzKCBzY2VuZSwgY2FtZXJhICk7XHJcbiAqIGNvbnN0IG91dHB1dFBhc3MgPSByZW5kZXJPdXRwdXQoIHNjZW5lUGFzcyApO1xyXG4gKlxyXG4gKiBwb3N0UHJvY2Vzc2luZy5vdXRwdXROb2RlID0gb3V0cHV0UGFzcztcclxuICogYGBgXHJcbiAqXHJcbiAqIEBhdWdtZW50cyBUZW1wTm9kZVxyXG4gKi9cclxuY2xhc3MgUmVuZGVyT3V0cHV0Tm9kZSBleHRlbmRzIFRlbXBOb2RlIHtcclxuXHJcblx0c3RhdGljIGdldCB0eXBlKCkge1xyXG5cclxuXHRcdHJldHVybiAnUmVuZGVyT3V0cHV0Tm9kZSc7XHJcblxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogQ29uc3RydWN0cyBhIG5ldyByZW5kZXIgb3V0cHV0IG5vZGUuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge05vZGV9IGNvbG9yTm9kZSAtIFRoZSBjb2xvciBub2RlIHRvIHByb2Nlc3MuXHJcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHRvbmVNYXBwaW5nIC0gVGhlIHRvbmUgbWFwcGluZyB0eXBlLlxyXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBvdXRwdXRDb2xvclNwYWNlIC0gVGhlIG91dHB1dCBjb2xvciBzcGFjZS5cclxuXHQgKi9cclxuXHRjb25zdHJ1Y3RvciggY29sb3JOb2RlLCB0b25lTWFwcGluZywgb3V0cHV0Q29sb3JTcGFjZSApIHtcclxuXHJcblx0XHRzdXBlciggJ3ZlYzQnICk7XHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBUaGUgY29sb3Igbm9kZSB0byBwcm9jZXNzLlxyXG5cdFx0ICpcclxuXHRcdCAqIEB0eXBlIHtOb2RlfVxyXG5cdFx0ICovXHJcblx0XHR0aGlzLmNvbG9yTm9kZSA9IGNvbG9yTm9kZTtcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIFRoZSB0b25lIG1hcHBpbmcgdHlwZS5cclxuXHRcdCAqXHJcblx0XHQgKiBAdHlwZSB7TnVtYmVyP31cclxuXHRcdCAqL1xyXG5cdFx0dGhpcy50b25lTWFwcGluZyA9IHRvbmVNYXBwaW5nO1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogVGhlIG91dHB1dCBjb2xvciBzcGFjZS5cclxuXHRcdCAqXHJcblx0XHQgKiBAdHlwZSB7U3RyaW5nP31cclxuXHRcdCAqL1xyXG5cdFx0dGhpcy5vdXRwdXRDb2xvclNwYWNlID0gb3V0cHV0Q29sb3JTcGFjZTtcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIFRoaXMgZmxhZyBjYW4gYmUgdXNlZCBmb3IgdHlwZSB0ZXN0aW5nLlxyXG5cdFx0ICpcclxuXHRcdCAqIEB0eXBlIHtCb29sZWFufVxyXG5cdFx0ICogQHJlYWRvbmx5XHJcblx0XHQgKiBAZGVmYXVsdCB0cnVlXHJcblx0XHQgKi9cclxuXHRcdHRoaXMuaXNSZW5kZXJPdXRwdXROb2RlID0gdHJ1ZTtcclxuXHJcblx0fVxyXG5cclxuXHRzZXR1cCggeyBjb250ZXh0IH0gKSB7XHJcblxyXG5cdFx0bGV0IG91dHB1dE5vZGUgPSB0aGlzLmNvbG9yTm9kZSB8fCBjb250ZXh0LmNvbG9yO1xyXG5cclxuXHRcdC8vIHRvbmUgbWFwcGluZ1xyXG5cclxuXHRcdGNvbnN0IHRvbmVNYXBwaW5nID0gKCB0aGlzLnRvbmVNYXBwaW5nICE9PSBudWxsID8gdGhpcy50b25lTWFwcGluZyA6IGNvbnRleHQudG9uZU1hcHBpbmcgKSB8fCBOb1RvbmVNYXBwaW5nO1xyXG5cdFx0Y29uc3Qgb3V0cHV0Q29sb3JTcGFjZSA9ICggdGhpcy5vdXRwdXRDb2xvclNwYWNlICE9PSBudWxsID8gdGhpcy5vdXRwdXRDb2xvclNwYWNlIDogY29udGV4dC5vdXRwdXRDb2xvclNwYWNlICkgfHwgTm9Db2xvclNwYWNlO1xyXG5cclxuXHRcdGlmICggdG9uZU1hcHBpbmcgIT09IE5vVG9uZU1hcHBpbmcgKSB7XHJcblxyXG5cdFx0XHRvdXRwdXROb2RlID0gb3V0cHV0Tm9kZS50b25lTWFwcGluZyggdG9uZU1hcHBpbmcgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gd29ya2luZyB0byBvdXRwdXQgY29sb3Igc3BhY2VcclxuXHJcblx0XHRpZiAoIG91dHB1dENvbG9yU3BhY2UgIT09IE5vQ29sb3JTcGFjZSAmJiBvdXRwdXRDb2xvclNwYWNlICE9PSBDb2xvck1hbmFnZW1lbnQud29ya2luZ0NvbG9yU3BhY2UgKSB7XHJcblxyXG5cdFx0XHRvdXRwdXROb2RlID0gb3V0cHV0Tm9kZS53b3JraW5nVG9Db2xvclNwYWNlKCBvdXRwdXRDb2xvclNwYWNlICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBvdXRwdXROb2RlO1xyXG5cclxuXHR9XHJcblxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBSZW5kZXJPdXRwdXROb2RlO1xyXG5cclxuLyoqXHJcbiAqIFRTTCBmdW5jdGlvbiBmb3IgY3JlYXRpbmcgYSBwb3N0ZXJpemUgbm9kZS5cclxuICpcclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7Tm9kZX0gY29sb3IgLSBUaGUgY29sb3Igbm9kZSB0byBwcm9jZXNzLlxyXG4gKiBAcGFyYW0ge051bWJlcj99IFt0b25lTWFwcGluZz1udWxsXSAtIFRoZSB0b25lIG1hcHBpbmcgdHlwZS5cclxuICogQHBhcmFtIHtTdHJpbmc/fSBbb3V0cHV0Q29sb3JTcGFjZT1udWxsXSAtIFRoZSBvdXRwdXQgY29sb3Igc3BhY2UuXHJcbiAqIEByZXR1cm5zIHtSZW5kZXJPdXRwdXROb2RlfVxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IHJlbmRlck91dHB1dCA9ICggY29sb3IsIHRvbmVNYXBwaW5nID0gbnVsbCwgb3V0cHV0Q29sb3JTcGFjZSA9IG51bGwgKSA9PiBub2RlT2JqZWN0KCBuZXcgUmVuZGVyT3V0cHV0Tm9kZSggbm9kZU9iamVjdCggY29sb3IgKSwgdG9uZU1hcHBpbmcsIG91dHB1dENvbG9yU3BhY2UgKSApO1xyXG5cclxuYWRkTWV0aG9kQ2hhaW5pbmcoICdyZW5kZXJPdXRwdXQnLCByZW5kZXJPdXRwdXQgKTtcclxuIiwiLy8gTm9uLVBVUkUgZXhwb3J0cyBsaXN0LCBzaWRlLWVmZmVjdHMgYXJlIHJlcXVpcmVkIGhlcmUuXHJcbi8vIFRTTCBCYXNlIFN5bnRheFxyXG5cclxuZXhwb3J0ICogZnJvbSAnLi9UU0xDb3JlLmpzJzsgLy8gZmxvYXQoKSwgdmVjMigpLCB2ZWMzKCksIHZlYzQoKSwgbWF0MygpLCBtYXQ0KCksIEZuKCksIElmKCksIGVsZW1lbnQoKSwgbm9kZU9iamVjdCgpLCBub2RlUHJveHkoKSwgLi4uXHJcbmV4cG9ydCAqIGZyb20gJy4uL2NvcmUvVW5pZm9ybU5vZGUuanMnOyAvLyB1bmlmb3JtKClcclxuZXhwb3J0ICogZnJvbSAnLi4vY29yZS9Qcm9wZXJ0eU5vZGUuanMnOyAvLyBwcm9wZXJ0eSgpICA8LT4gVE9ETzogU2VwYXJhdGUgTWF0ZXJpYWwgUHJvcGVydGllcyBpbiBvdGhlciBmaWxlXHJcbmV4cG9ydCAqIGZyb20gJy4uL2NvcmUvQXNzaWduTm9kZS5qcyc7IC8vIC5hc3NpZ24oKVxyXG5leHBvcnQgKiBmcm9tICcuLi9jb2RlL0Z1bmN0aW9uQ2FsbE5vZGUuanMnOyAvLyAuY2FsbCgpXHJcbmV4cG9ydCAqIGZyb20gJy4uL21hdGgvT3BlcmF0b3JOb2RlLmpzJzsgLy8gLmFkZCgpLCAuc3ViKCksIC4uLlxyXG5leHBvcnQgKiBmcm9tICcuLi9tYXRoL01hdGhOb2RlLmpzJzsgLy8gYWJzKCksIGZsb29yKCksIC4uLlxyXG5leHBvcnQgKiBmcm9tICcuLi9tYXRoL0NvbmRpdGlvbmFsTm9kZS5qcyc7IC8vIHNlbGVjdCgpLCAuLi5cclxuZXhwb3J0ICogZnJvbSAnLi4vY29yZS9Db250ZXh0Tm9kZS5qcyc7IC8vIC5jb250ZXh0KClcclxuZXhwb3J0ICogZnJvbSAnLi4vY29yZS9WYXJOb2RlLmpzJzsgLy8gLnZhcigpIC0+IFRPRE86IE1heWJlIHJlbmFtZSAudG9WYXIoKSAtPiAudmFyKClcclxuZXhwb3J0ICogZnJvbSAnLi4vY29yZS9WYXJ5aW5nTm9kZS5qcyc7IC8vIHZhcnlpbmcoKSAtPiBUT0RPOiBBZGQgdmVydGV4U3RhZ2UoKVxyXG5leHBvcnQgKiBmcm9tICcuLi9kaXNwbGF5L0NvbG9yU3BhY2VOb2RlLmpzJzsgLy8gLnRvQ29sb3JTcGFjZSgpXHJcbmV4cG9ydCAqIGZyb20gJy4uL2Rpc3BsYXkvVG9uZU1hcHBpbmdOb2RlLmpzJzsgLy8gLnRvVG9uZU1hcHBpbmcoKVxyXG5leHBvcnQgKiBmcm9tICcuLi9hY2Nlc3NvcnMvQnVmZmVyQXR0cmlidXRlTm9kZS5qcyc7IC8vIC50b0F0dHJpYnV0ZSgpXHJcbmV4cG9ydCAqIGZyb20gJy4uL2dwZ3B1L0NvbXB1dGVOb2RlLmpzJzsgLy8gLmNvbXB1dGUoKVxyXG5leHBvcnQgKiBmcm9tICcuLi9jb3JlL0NhY2hlTm9kZS5qcyc7IC8vIC5jYWNoZSgpXHJcbmV4cG9ydCAqIGZyb20gJy4uL2NvcmUvQnlwYXNzTm9kZS5qcyc7IC8vIC5ieXBhc3MoKVxyXG5leHBvcnQgKiBmcm9tICcuLi91dGlscy9SZW1hcE5vZGUuanMnOyAvLyAucmVtYXAoKSwgLnJlbWFwQ2xhbXAoKVxyXG5leHBvcnQgKiBmcm9tICcuLi9jb2RlL0V4cHJlc3Npb25Ob2RlLmpzJzsgLy8gZXhwcmVzc2lvbigpXHJcbmV4cG9ydCAqIGZyb20gJy4uL3V0aWxzL0Rpc2NhcmQuanMnOyAvLyBEaXNjYXJkKCksIFJldHVybigpXHJcbmV4cG9ydCAqIGZyb20gJy4uL2Rpc3BsYXkvUmVuZGVyT3V0cHV0Tm9kZS5qcyc7IC8vIC5yZW5kZXJPdXRwdXQoKVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGFkZE5vZGVFbGVtZW50KCBuYW1lLyosIG5vZGVFbGVtZW50Ki8gKSB7XHJcblxyXG5cdGNvbnNvbGUud2FybiggJ1RIUkVFLlRTTEJhc2U6IEFkZE5vZGVFbGVtZW50IGhhcyBiZWVuIHJlbW92ZWQgaW4gZmF2b3Igb2YgdHJlZS1zaGFraW5nLiBUcnlpbmcgYWRkJywgbmFtZSApO1xyXG5cclxufVxyXG4iLCJpbXBvcnQgTm9kZSBmcm9tICcuL05vZGUuanMnO1xyXG5pbXBvcnQgeyBub2RlT2JqZWN0LCB2YXJ5aW5nIH0gZnJvbSAnLi4vdHNsL1RTTEJhc2UuanMnO1xyXG5cclxuLyoqIEBtb2R1bGUgQXR0cmlidXRlTm9kZSAqKi9cclxuXHJcbi8qKlxyXG4gKiBCYXNlIGNsYXNzIGZvciByZXByZXNlbnRpbmcgc2hhZGVyIGF0dHJpYnV0ZXMgYXMgbm9kZXMuXHJcbiAqXHJcbiAqIEBhdWdtZW50cyBOb2RlXHJcbiAqL1xyXG5jbGFzcyBBdHRyaWJ1dGVOb2RlIGV4dGVuZHMgTm9kZSB7XHJcblxyXG5cdHN0YXRpYyBnZXQgdHlwZSgpIHtcclxuXHJcblx0XHRyZXR1cm4gJ0F0dHJpYnV0ZU5vZGUnO1xyXG5cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIENvbnN0cnVjdHMgYSBuZXcgYXR0cmlidXRlIG5vZGUuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge1N0cmluZ30gYXR0cmlidXRlTmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBhdHRyaWJ1dGUuXHJcblx0ICogQHBhcmFtIHtTdHJpbmc/fSBub2RlVHlwZSAtIFRoZSBub2RlIHR5cGUuXHJcblx0ICovXHJcblx0Y29uc3RydWN0b3IoIGF0dHJpYnV0ZU5hbWUsIG5vZGVUeXBlID0gbnVsbCApIHtcclxuXHJcblx0XHRzdXBlciggbm9kZVR5cGUgKTtcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIGBBdHRyaWJ1dGVOb2RlYCBzZXRzIHRoaXMgcHJvcGVydHkgdG8gYHRydWVgIGJ5IGRlZmF1bHQuXHJcblx0XHQgKlxyXG5cdFx0ICogQHR5cGUge0Jvb2xlYW59XHJcblx0XHQgKiBAZGVmYXVsdCB0cnVlXHJcblx0XHQgKi9cclxuXHRcdHRoaXMuZ2xvYmFsID0gdHJ1ZTtcclxuXHJcblx0XHR0aGlzLl9hdHRyaWJ1dGVOYW1lID0gYXR0cmlidXRlTmFtZTtcclxuXHJcblx0fVxyXG5cclxuXHRnZXRIYXNoKCBidWlsZGVyICkge1xyXG5cclxuXHRcdHJldHVybiB0aGlzLmdldEF0dHJpYnV0ZU5hbWUoIGJ1aWxkZXIgKTtcclxuXHJcblx0fVxyXG5cclxuXHRnZXROb2RlVHlwZSggYnVpbGRlciApIHtcclxuXHJcblx0XHRsZXQgbm9kZVR5cGUgPSB0aGlzLm5vZGVUeXBlO1xyXG5cclxuXHRcdGlmICggbm9kZVR5cGUgPT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHRjb25zdCBhdHRyaWJ1dGVOYW1lID0gdGhpcy5nZXRBdHRyaWJ1dGVOYW1lKCBidWlsZGVyICk7XHJcblxyXG5cdFx0XHRpZiAoIGJ1aWxkZXIuaGFzR2VvbWV0cnlBdHRyaWJ1dGUoIGF0dHJpYnV0ZU5hbWUgKSApIHtcclxuXHJcblx0XHRcdFx0Y29uc3QgYXR0cmlidXRlID0gYnVpbGRlci5nZW9tZXRyeS5nZXRBdHRyaWJ1dGUoIGF0dHJpYnV0ZU5hbWUgKTtcclxuXHJcblx0XHRcdFx0bm9kZVR5cGUgPSBidWlsZGVyLmdldFR5cGVGcm9tQXR0cmlidXRlKCBhdHRyaWJ1dGUgKTtcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdG5vZGVUeXBlID0gJ2Zsb2F0JztcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIG5vZGVUeXBlO1xyXG5cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFNldHMgdGhlIGF0dHJpYnV0ZSBuYW1lIHRvIHRoZSBnaXZlbiB2YWx1ZS4gVGhlIG1ldGhvZCBjYW4gYmVcclxuXHQgKiBvdmVyd3JpdHRlbiBpbiBkZXJpdmVkIGNsYXNzZXMgaWYgdGhlIGZpbmFsIG5hbWUgbXVzdCBiZSBjb21wdXRlZFxyXG5cdCAqIGFuYWx5dGljYWxseS5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBhdHRyaWJ1dGVOYW1lIC0gVGhlIG5hbWUgb2YgdGhlIGF0dHJpYnV0ZS5cclxuXHQgKiBAcmV0dXJuIHtBdHRyaWJ1dGVOb2RlfSBBIHJlZmVyZW5jZSB0byB0aGlzIG5vZGUuXHJcblx0ICovXHJcblx0c2V0QXR0cmlidXRlTmFtZSggYXR0cmlidXRlTmFtZSApIHtcclxuXHJcblx0XHR0aGlzLl9hdHRyaWJ1dGVOYW1lID0gYXR0cmlidXRlTmFtZTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBSZXR1cm5zIHRoZSBhdHRyaWJ1dGUgbmFtZSBvZiB0aGlzIG5vZGUuIFRoZSBtZXRob2QgY2FuIGJlXHJcblx0ICogb3ZlcndyaXR0ZW4gaW4gZGVyaXZlZCBjbGFzc2VzIGlmIHRoZSBmaW5hbCBuYW1lIG11c3QgYmUgY29tcHV0ZWRcclxuXHQgKiBhbmFseXRpY2FsbHkuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge05vZGVCdWlsZGVyfSBidWlsZGVyIC0gVGhlIGN1cnJlbnQgbm9kZSBidWlsZGVyLlxyXG5cdCAqIEByZXR1cm4ge1N0cmluZ30gVGhlIGF0dHJpYnV0ZSBuYW1lLlxyXG5cdCAqL1xyXG5cdGdldEF0dHJpYnV0ZU5hbWUoIC8qYnVpbGRlciovICkge1xyXG5cclxuXHRcdHJldHVybiB0aGlzLl9hdHRyaWJ1dGVOYW1lO1xyXG5cclxuXHR9XHJcblxyXG5cdGdlbmVyYXRlKCBidWlsZGVyICkge1xyXG5cclxuXHRcdGNvbnN0IGF0dHJpYnV0ZU5hbWUgPSB0aGlzLmdldEF0dHJpYnV0ZU5hbWUoIGJ1aWxkZXIgKTtcclxuXHRcdGNvbnN0IG5vZGVUeXBlID0gdGhpcy5nZXROb2RlVHlwZSggYnVpbGRlciApO1xyXG5cdFx0Y29uc3QgZ2VvbWV0cnlBdHRyaWJ1dGUgPSBidWlsZGVyLmhhc0dlb21ldHJ5QXR0cmlidXRlKCBhdHRyaWJ1dGVOYW1lICk7XHJcblxyXG5cdFx0aWYgKCBnZW9tZXRyeUF0dHJpYnV0ZSA9PT0gdHJ1ZSApIHtcclxuXHJcblx0XHRcdGNvbnN0IGF0dHJpYnV0ZSA9IGJ1aWxkZXIuZ2VvbWV0cnkuZ2V0QXR0cmlidXRlKCBhdHRyaWJ1dGVOYW1lICk7XHJcblx0XHRcdGNvbnN0IGF0dHJpYnV0ZVR5cGUgPSBidWlsZGVyLmdldFR5cGVGcm9tQXR0cmlidXRlKCBhdHRyaWJ1dGUgKTtcclxuXHJcblx0XHRcdGNvbnN0IG5vZGVBdHRyaWJ1dGUgPSBidWlsZGVyLmdldEF0dHJpYnV0ZSggYXR0cmlidXRlTmFtZSwgYXR0cmlidXRlVHlwZSApO1xyXG5cclxuXHRcdFx0aWYgKCBidWlsZGVyLnNoYWRlclN0YWdlID09PSAndmVydGV4JyApIHtcclxuXHJcblx0XHRcdFx0cmV0dXJuIGJ1aWxkZXIuZm9ybWF0KCBub2RlQXR0cmlidXRlLm5hbWUsIGF0dHJpYnV0ZVR5cGUsIG5vZGVUeXBlICk7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRjb25zdCBub2RlVmFyeWluZyA9IHZhcnlpbmcoIHRoaXMgKTtcclxuXHJcblx0XHRcdFx0cmV0dXJuIG5vZGVWYXJ5aW5nLmJ1aWxkKCBidWlsZGVyLCBub2RlVHlwZSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRjb25zb2xlLndhcm4oIGBBdHRyaWJ1dGVOb2RlOiBWZXJ0ZXggYXR0cmlidXRlIFwiJHsgYXR0cmlidXRlTmFtZSB9XCIgbm90IGZvdW5kIG9uIGdlb21ldHJ5LmAgKTtcclxuXHJcblx0XHRcdHJldHVybiBidWlsZGVyLmdlbmVyYXRlQ29uc3QoIG5vZGVUeXBlICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdHNlcmlhbGl6ZSggZGF0YSApIHtcclxuXHJcblx0XHRzdXBlci5zZXJpYWxpemUoIGRhdGEgKTtcclxuXHJcblx0XHRkYXRhLmdsb2JhbCA9IHRoaXMuZ2xvYmFsO1xyXG5cdFx0ZGF0YS5fYXR0cmlidXRlTmFtZSA9IHRoaXMuX2F0dHJpYnV0ZU5hbWU7XHJcblxyXG5cdH1cclxuXHJcblx0ZGVzZXJpYWxpemUoIGRhdGEgKSB7XHJcblxyXG5cdFx0c3VwZXIuZGVzZXJpYWxpemUoIGRhdGEgKTtcclxuXHJcblx0XHR0aGlzLmdsb2JhbCA9IGRhdGEuZ2xvYmFsO1xyXG5cdFx0dGhpcy5fYXR0cmlidXRlTmFtZSA9IGRhdGEuX2F0dHJpYnV0ZU5hbWU7XHJcblxyXG5cdH1cclxuXHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IEF0dHJpYnV0ZU5vZGU7XHJcblxyXG4vKipcclxuICogVFNMIGZ1bmN0aW9uIGZvciBjcmVhdGluZyBhbiBhdHRyaWJ1dGUgbm9kZS5cclxuICpcclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIC0gVGhlIG5hbWUgb2YgdGhlIGF0dHJpYnV0ZS5cclxuICogQHBhcmFtIHtTdHJpbmc/fSBub2RlVHlwZSAtIFRoZSBub2RlIHR5cGUuXHJcbiAqIEByZXR1cm5zIHtBdHRyaWJ1dGVOb2RlfVxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IGF0dHJpYnV0ZSA9ICggbmFtZSwgbm9kZVR5cGUgKSA9PiBub2RlT2JqZWN0KCBuZXcgQXR0cmlidXRlTm9kZSggbmFtZSwgbm9kZVR5cGUgKSApO1xyXG4iLCJpbXBvcnQgeyBhdHRyaWJ1dGUgfSBmcm9tICcuLi9jb3JlL0F0dHJpYnV0ZU5vZGUuanMnO1xyXG5cclxuLyoqIEBtb2R1bGUgVVYgKiovXHJcblxyXG4vKipcclxuICogVFNMIGZ1bmN0aW9uIGZvciBjcmVhdGluZyBhbiB1diBhdHRyaWJ1dGUgbm9kZSB3aXRoIHRoZSBnaXZlbiBpbmRleC5cclxuICpcclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBbaW5kZXg9MF0gLSBUaGUgdXYgaW5kZXguXHJcbiAqIEByZXR1cm4ge0F0dHJpYnV0ZU5vZGU8dmVjMj59IFRoZSB1diBhdHRyaWJ1dGUgbm9kZS5cclxuICovXHJcbmV4cG9ydCBjb25zdCB1diA9ICggaW5kZXggPSAwICkgPT4gYXR0cmlidXRlKCAndXYnICsgKCBpbmRleCA+IDAgPyBpbmRleCA6ICcnICksICd2ZWMyJyApO1xyXG4iLCJpbXBvcnQgTm9kZSBmcm9tICcuLi9jb3JlL05vZGUuanMnO1xyXG5pbXBvcnQgeyBub2RlUHJveHkgfSBmcm9tICcuLi90c2wvVFNMQmFzZS5qcyc7XHJcblxyXG4vKiogQG1vZHVsZSBUZXh0dXJlU2l6ZU5vZGUgKiovXHJcblxyXG4vKipcclxuICogQSBub2RlIHRoYXQgcmVwcmVzZW50cyB0aGUgZGltZW5zaW9ucyBvZiBhIHRleHR1cmUuIFRoZSB0ZXh0dXJlIHNpemUgaXNcclxuICogcmV0cmlldmVkIGluIHRoZSBzaGFkZXIgdmlhIGJ1aWx0LWluIHNoYWRlciBmdW5jdGlvbnMgbGlrZSBgdGV4dHVyZURpbWVuc2lvbnMoKWBcclxuICogb3IgYHRleHR1cmVTaXplKClgLlxyXG4gKlxyXG4gKiBAYXVnbWVudHMgTm9kZVxyXG4gKi9cclxuY2xhc3MgVGV4dHVyZVNpemVOb2RlIGV4dGVuZHMgTm9kZSB7XHJcblxyXG5cdHN0YXRpYyBnZXQgdHlwZSgpIHtcclxuXHJcblx0XHRyZXR1cm4gJ1RleHR1cmVTaXplTm9kZSc7XHJcblxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogQ29uc3RydWN0cyBhIG5ldyB0ZXh0dXJlIHNpemUgbm9kZS5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7VGV4dHVyZU5vZGV9IHRleHR1cmVOb2RlIC0gQSB0ZXh0dXJlIG5vZGUgd2hpY2ggc2l6ZSBzaG91bGQgYmUgcmV0cmlldmVkLlxyXG5cdCAqIEBwYXJhbSB7Tm9kZTxpbnQ+P30gW2xldmVsTm9kZT1udWxsXSAtIEEgbGV2ZWwgbm9kZSB3aGljaCBkZWZpbmVzIHRoZSByZXF1ZXN0ZWQgbWlwLlxyXG5cdCAqL1xyXG5cdGNvbnN0cnVjdG9yKCB0ZXh0dXJlTm9kZSwgbGV2ZWxOb2RlID0gbnVsbCApIHtcclxuXHJcblx0XHRzdXBlciggJ3V2ZWMyJyApO1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogVGhpcyBmbGFnIGNhbiBiZSB1c2VkIGZvciB0eXBlIHRlc3RpbmcuXHJcblx0XHQgKlxyXG5cdFx0ICogQHR5cGUge0Jvb2xlYW59XHJcblx0XHQgKiBAcmVhZG9ubHlcclxuXHRcdCAqIEBkZWZhdWx0IHRydWVcclxuXHRcdCAqL1xyXG5cdFx0dGhpcy5pc1RleHR1cmVTaXplTm9kZSA9IHRydWU7XHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBBIHRleHR1cmUgbm9kZSB3aGljaCBzaXplIHNob3VsZCBiZSByZXRyaWV2ZWQuXHJcblx0XHQgKlxyXG5cdFx0ICogQHR5cGUge1RleHR1cmVOb2RlfVxyXG5cdFx0ICovXHJcblx0XHR0aGlzLnRleHR1cmVOb2RlID0gdGV4dHVyZU5vZGU7XHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBBIGxldmVsIG5vZGUgd2hpY2ggZGVmaW5lcyB0aGUgcmVxdWVzdGVkIG1pcC5cclxuXHRcdCAqXHJcblx0XHQgKiBAdHlwZSB7Tm9kZTxpbnQ+fVxyXG5cdFx0ICogQGRlZmF1bHQgbnVsbFxyXG5cdFx0ICovXHJcblx0XHR0aGlzLmxldmVsTm9kZSA9IGxldmVsTm9kZTtcclxuXHJcblx0fVxyXG5cclxuXHRnZW5lcmF0ZSggYnVpbGRlciwgb3V0cHV0ICkge1xyXG5cclxuXHRcdGNvbnN0IHRleHR1cmVQcm9wZXJ0eSA9IHRoaXMudGV4dHVyZU5vZGUuYnVpbGQoIGJ1aWxkZXIsICdwcm9wZXJ0eScgKTtcclxuXHRcdGNvbnN0IGxldmVsID0gdGhpcy5sZXZlbE5vZGUgPT09IG51bGwgPyAnMCcgOiB0aGlzLmxldmVsTm9kZS5idWlsZCggYnVpbGRlciwgJ2ludCcgKTtcclxuXHJcblx0XHRyZXR1cm4gYnVpbGRlci5mb3JtYXQoIGAkeyBidWlsZGVyLmdldE1ldGhvZCggJ3RleHR1cmVEaW1lbnNpb25zJyApIH0oICR7IHRleHR1cmVQcm9wZXJ0eSB9LCAkeyBsZXZlbCB9IClgLCB0aGlzLmdldE5vZGVUeXBlKCBidWlsZGVyICksIG91dHB1dCApO1xyXG5cclxuXHR9XHJcblxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBUZXh0dXJlU2l6ZU5vZGU7XHJcblxyXG4vKipcclxuICogVFNMIGZ1bmN0aW9uIGZvciBjcmVhdGluZyBhIHRleHR1cmUgc2l6ZSBub2RlLlxyXG4gKlxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHtUZXh0dXJlTm9kZX0gdGV4dHVyZU5vZGUgLSBBIHRleHR1cmUgbm9kZSB3aGljaCBzaXplIHNob3VsZCBiZSByZXRyaWV2ZWQuXHJcbiAqIEBwYXJhbSB7Tm9kZTxpbnQ+P30gW2xldmVsTm9kZT1udWxsXSAtIEEgbGV2ZWwgbm9kZSB3aGljaCBkZWZpbmVzIHRoZSByZXF1ZXN0ZWQgbWlwLlxyXG4gKiBAcmV0dXJucyB7VGV4dHVyZVNpemVOb2RlfVxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IHRleHR1cmVTaXplID0gLypAX19QVVJFX18qLyBub2RlUHJveHkoIFRleHR1cmVTaXplTm9kZSApO1xyXG4iLCJpbXBvcnQgVW5pZm9ybU5vZGUgZnJvbSAnLi4vY29yZS9Vbmlmb3JtTm9kZS5qcyc7XHJcbmltcG9ydCB7IE5vZGVVcGRhdGVUeXBlIH0gZnJvbSAnLi4vY29yZS9jb25zdGFudHMuanMnO1xyXG5pbXBvcnQgeyBub2RlUHJveHkgfSBmcm9tICcuLi90c2wvVFNMQmFzZS5qcyc7XHJcblxyXG4vKiogQG1vZHVsZSBNYXRjYXBVVk5vZGUgKiovXHJcblxyXG4vKipcclxuICogQSBzcGVjaWFsIHR5cGUgb2YgdW5pZm9ybSBub2RlIHRoYXQgY29tcHV0ZXMgdGhlXHJcbiAqIG1heGltdW0gbWlwbWFwIGxldmVsIGZvciBhIGdpdmVuIHRleHR1cmUgbm9kZS5cclxuICpcclxuICogYGBganNcclxuICogY29uc3QgbGV2ZWwgPSBtYXhNaXBMZXZlbCggdGV4dHVyZU5vZGUgKTtcclxuICogYGBgXHJcbiAqXHJcbiAqIEBhdWdtZW50cyBtb2R1bGU6VW5pZm9ybU5vZGV+VW5pZm9ybU5vZGVcclxuICovXHJcbmNsYXNzIE1heE1pcExldmVsTm9kZSBleHRlbmRzIFVuaWZvcm1Ob2RlIHtcclxuXHJcblx0c3RhdGljIGdldCB0eXBlKCkge1xyXG5cclxuXHRcdHJldHVybiAnTWF4TWlwTGV2ZWxOb2RlJztcclxuXHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBDb25zdHJ1Y3RzIGEgbmV3IG1heCBtaXAgbGV2ZWwgbm9kZS5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7VGV4dHVyZU5vZGV9IHRleHR1cmVOb2RlIC0gVGhlIHRleHR1cmUgbm9kZSB0byBjb21wdXRlIHRoZSBtYXggbWlwIGxldmVsIGZvci5cclxuXHQgKi9cclxuXHRjb25zdHJ1Y3RvciggdGV4dHVyZU5vZGUgKSB7XHJcblxyXG5cdFx0c3VwZXIoIDAgKTtcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIFRoZSB0ZXh0dXJlIG5vZGUgdG8gY29tcHV0ZSB0aGUgbWF4IG1pcCBsZXZlbCBmb3IuXHJcblx0XHQgKlxyXG5cdFx0ICogQHByaXZhdGVcclxuXHRcdCAqIEB0eXBlIHtUZXh0dXJlTm9kZX1cclxuXHRcdCAqL1xyXG5cdFx0dGhpcy5fdGV4dHVyZU5vZGUgPSB0ZXh0dXJlTm9kZTtcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIFRoZSBgdXBkYXRlVHlwZWAgaXMgc2V0IHRvIGBOb2RlVXBkYXRlVHlwZS5GUkFNRWAgc2luY2UgdGhlIG5vZGUgdXBkYXRlc1xyXG5cdFx0ICogdGhlIHRleHR1cmUgb25jZSBwZXIgZnJhbWUgaW4gaXRzIHtAbGluayBNYXhNaXBMZXZlbE5vZGUjdXBkYXRlfSBtZXRob2QuXHJcblx0XHQgKlxyXG5cdFx0ICogQHR5cGUge1N0cmluZ31cclxuXHRcdCAqIEBkZWZhdWx0ICdmcmFtZSdcclxuXHRcdCAqL1xyXG5cdFx0dGhpcy51cGRhdGVUeXBlID0gTm9kZVVwZGF0ZVR5cGUuRlJBTUU7XHJcblxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogVGhlIHRleHR1cmUgbm9kZSB0byBjb21wdXRlIHRoZSBtYXggbWlwIGxldmVsIGZvci5cclxuXHQgKlxyXG5cdCAqIEByZWFkb25seVxyXG5cdCAqIEB0eXBlIHtUZXh0dXJlTm9kZX1cclxuXHQgKi9cclxuXHRnZXQgdGV4dHVyZU5vZGUoKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuX3RleHR1cmVOb2RlO1xyXG5cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFRoZSB0ZXh0dXJlLlxyXG5cdCAqXHJcblx0ICogQHJlYWRvbmx5XHJcblx0ICogQHR5cGUge1RleHR1cmV9XHJcblx0ICovXHJcblx0Z2V0IHRleHR1cmUoKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuX3RleHR1cmVOb2RlLnZhbHVlO1xyXG5cclxuXHR9XHJcblxyXG5cdHVwZGF0ZSgpIHtcclxuXHJcblx0XHRjb25zdCB0ZXh0dXJlID0gdGhpcy50ZXh0dXJlO1xyXG5cdFx0Y29uc3QgaW1hZ2VzID0gdGV4dHVyZS5pbWFnZXM7XHJcblx0XHRjb25zdCBpbWFnZSA9ICggaW1hZ2VzICYmIGltYWdlcy5sZW5ndGggPiAwICkgPyAoICggaW1hZ2VzWyAwIF0gJiYgaW1hZ2VzWyAwIF0uaW1hZ2UgKSB8fCBpbWFnZXNbIDAgXSApIDogdGV4dHVyZS5pbWFnZTtcclxuXHJcblx0XHRpZiAoIGltYWdlICYmIGltYWdlLndpZHRoICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRjb25zdCB7IHdpZHRoLCBoZWlnaHQgfSA9IGltYWdlO1xyXG5cclxuXHRcdFx0dGhpcy52YWx1ZSA9IE1hdGgubG9nMiggTWF0aC5tYXgoIHdpZHRoLCBoZWlnaHQgKSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgTWF4TWlwTGV2ZWxOb2RlO1xyXG5cclxuLyoqXHJcbiAqIFRTTCBmdW5jdGlvbiBmb3IgY3JlYXRpbmcgYSBtYXggbWlwIGxldmVsIG5vZGUuXHJcbiAqXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0ge1RleHR1cmVOb2RlfSB0ZXh0dXJlTm9kZSAtIFRoZSB0ZXh0dXJlIG5vZGUgdG8gY29tcHV0ZSB0aGUgbWF4IG1pcCBsZXZlbCBmb3IuXHJcbiAqIEByZXR1cm5zIHtNYXhNaXBMZXZlbE5vZGV9XHJcbiAqL1xyXG5leHBvcnQgY29uc3QgbWF4TWlwTGV2ZWwgPSAvKkBfX1BVUkVfXyovIG5vZGVQcm94eSggTWF4TWlwTGV2ZWxOb2RlICk7XHJcbiIsImltcG9ydCBVbmlmb3JtTm9kZSwgeyB1bmlmb3JtIH0gZnJvbSAnLi4vY29yZS9Vbmlmb3JtTm9kZS5qcyc7XHJcbmltcG9ydCB7IHV2IH0gZnJvbSAnLi9VVi5qcyc7XHJcbmltcG9ydCB7IHRleHR1cmVTaXplIH0gZnJvbSAnLi9UZXh0dXJlU2l6ZU5vZGUuanMnO1xyXG5pbXBvcnQgeyBjb2xvclNwYWNlVG9Xb3JraW5nIH0gZnJvbSAnLi4vZGlzcGxheS9Db2xvclNwYWNlTm9kZS5qcyc7XHJcbmltcG9ydCB7IGV4cHJlc3Npb24gfSBmcm9tICcuLi9jb2RlL0V4cHJlc3Npb25Ob2RlLmpzJztcclxuaW1wb3J0IHsgbWF4TWlwTGV2ZWwgfSBmcm9tICcuLi91dGlscy9NYXhNaXBMZXZlbE5vZGUuanMnO1xyXG5pbXBvcnQgeyBub2RlUHJveHksIHZlYzMsIG5vZGVPYmplY3QsIGludCB9IGZyb20gJy4uL3RzbC9UU0xCYXNlLmpzJztcclxuaW1wb3J0IHsgTm9kZVVwZGF0ZVR5cGUgfSBmcm9tICcuLi9jb3JlL2NvbnN0YW50cy5qcyc7XHJcblxyXG5pbXBvcnQgeyBJbnRUeXBlLCBVbnNpZ25lZEludFR5cGUgfSBmcm9tICcuLi8uLi9jb25zdGFudHMuanMnO1xyXG5cclxuY2xhc3MgVGV4dHVyZU5vZGUgZXh0ZW5kcyBVbmlmb3JtTm9kZSB7XHJcblxyXG5cdHN0YXRpYyBnZXQgdHlwZSgpIHtcclxuXHJcblx0XHRyZXR1cm4gJ1RleHR1cmVOb2RlJztcclxuXHJcblx0fVxyXG5cclxuXHRjb25zdHJ1Y3RvciggdmFsdWUsIHV2Tm9kZSA9IG51bGwsIGxldmVsTm9kZSA9IG51bGwsIGJpYXNOb2RlID0gbnVsbCApIHtcclxuXHJcblx0XHRzdXBlciggdmFsdWUgKTtcclxuXHJcblx0XHR0aGlzLmlzVGV4dHVyZU5vZGUgPSB0cnVlO1xyXG5cclxuXHRcdHRoaXMudXZOb2RlID0gdXZOb2RlO1xyXG5cdFx0dGhpcy5sZXZlbE5vZGUgPSBsZXZlbE5vZGU7XHJcblx0XHR0aGlzLmJpYXNOb2RlID0gYmlhc05vZGU7XHJcblx0XHR0aGlzLmNvbXBhcmVOb2RlID0gbnVsbDtcclxuXHRcdHRoaXMuZGVwdGhOb2RlID0gbnVsbDtcclxuXHRcdHRoaXMuZ3JhZE5vZGUgPSBudWxsO1xyXG5cclxuXHRcdHRoaXMuc2FtcGxlciA9IHRydWU7XHJcblx0XHR0aGlzLnVwZGF0ZU1hdHJpeCA9IGZhbHNlO1xyXG5cdFx0dGhpcy51cGRhdGVUeXBlID0gTm9kZVVwZGF0ZVR5cGUuTk9ORTtcclxuXHJcblx0XHR0aGlzLnJlZmVyZW5jZU5vZGUgPSBudWxsO1xyXG5cclxuXHRcdHRoaXMuX3ZhbHVlID0gdmFsdWU7XHJcblx0XHR0aGlzLl9tYXRyaXhVbmlmb3JtID0gbnVsbDtcclxuXHJcblx0XHR0aGlzLnNldFVwZGF0ZU1hdHJpeCggdXZOb2RlID09PSBudWxsICk7XHJcblxyXG5cdH1cclxuXHJcblx0c2V0IHZhbHVlKCB2YWx1ZSApIHtcclxuXHJcblx0XHRpZiAoIHRoaXMucmVmZXJlbmNlTm9kZSApIHtcclxuXHJcblx0XHRcdHRoaXMucmVmZXJlbmNlTm9kZS52YWx1ZSA9IHZhbHVlO1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHR0aGlzLl92YWx1ZSA9IHZhbHVlO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHRnZXQgdmFsdWUoKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMucmVmZXJlbmNlTm9kZSA/IHRoaXMucmVmZXJlbmNlTm9kZS52YWx1ZSA6IHRoaXMuX3ZhbHVlO1xyXG5cclxuXHR9XHJcblxyXG5cdGdldFVuaWZvcm1IYXNoKCAvKmJ1aWxkZXIqLyApIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy52YWx1ZS51dWlkO1xyXG5cclxuXHR9XHJcblxyXG5cdGdldE5vZGVUeXBlKCAvKmJ1aWxkZXIqLyApIHtcclxuXHJcblx0XHRpZiAoIHRoaXMudmFsdWUuaXNEZXB0aFRleHR1cmUgPT09IHRydWUgKSByZXR1cm4gJ2Zsb2F0JztcclxuXHJcblx0XHRpZiAoIHRoaXMudmFsdWUudHlwZSA9PT0gVW5zaWduZWRJbnRUeXBlICkge1xyXG5cclxuXHRcdFx0cmV0dXJuICd1dmVjNCc7XHJcblxyXG5cdFx0fSBlbHNlIGlmICggdGhpcy52YWx1ZS50eXBlID09PSBJbnRUeXBlICkge1xyXG5cclxuXHRcdFx0cmV0dXJuICdpdmVjNCc7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiAndmVjNCc7XHJcblxyXG5cdH1cclxuXHJcblx0Z2V0SW5wdXRUeXBlKCAvKmJ1aWxkZXIqLyApIHtcclxuXHJcblx0XHRyZXR1cm4gJ3RleHR1cmUnO1xyXG5cclxuXHR9XHJcblxyXG5cdGdldERlZmF1bHRVVigpIHtcclxuXHJcblx0XHRyZXR1cm4gdXYoIHRoaXMudmFsdWUuY2hhbm5lbCApO1xyXG5cclxuXHR9XHJcblxyXG5cdHVwZGF0ZVJlZmVyZW5jZSggLypzdGF0ZSovICkge1xyXG5cclxuXHRcdHJldHVybiB0aGlzLnZhbHVlO1xyXG5cclxuXHR9XHJcblxyXG5cdGdldFRyYW5zZm9ybWVkVVYoIHV2Tm9kZSApIHtcclxuXHJcblx0XHRpZiAoIHRoaXMuX21hdHJpeFVuaWZvcm0gPT09IG51bGwgKSB0aGlzLl9tYXRyaXhVbmlmb3JtID0gdW5pZm9ybSggdGhpcy52YWx1ZS5tYXRyaXggKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5fbWF0cml4VW5pZm9ybS5tdWwoIHZlYzMoIHV2Tm9kZSwgMSApICkueHk7XHJcblxyXG5cdH1cclxuXHJcblx0c2V0VXBkYXRlTWF0cml4KCB2YWx1ZSApIHtcclxuXHJcblx0XHR0aGlzLnVwZGF0ZU1hdHJpeCA9IHZhbHVlO1xyXG5cdFx0dGhpcy51cGRhdGVUeXBlID0gdmFsdWUgPyBOb2RlVXBkYXRlVHlwZS5GUkFNRSA6IE5vZGVVcGRhdGVUeXBlLk5PTkU7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHJcblx0c2V0dXBVViggYnVpbGRlciwgdXZOb2RlICkge1xyXG5cclxuXHRcdGNvbnN0IHRleHR1cmUgPSB0aGlzLnZhbHVlO1xyXG5cclxuXHRcdGlmICggYnVpbGRlci5pc0ZsaXBZKCkgJiYgKCAoIHRleHR1cmUuaW1hZ2UgaW5zdGFuY2VvZiBJbWFnZUJpdG1hcCAmJiB0ZXh0dXJlLmZsaXBZID09PSB0cnVlICkgfHwgdGV4dHVyZS5pc1JlbmRlclRhcmdldFRleHR1cmUgPT09IHRydWUgfHwgdGV4dHVyZS5pc0ZyYW1lYnVmZmVyVGV4dHVyZSA9PT0gdHJ1ZSB8fCB0ZXh0dXJlLmlzRGVwdGhUZXh0dXJlID09PSB0cnVlICkgKSB7XHJcblxyXG5cdFx0XHRpZiAoIHRoaXMuc2FtcGxlciApIHtcclxuXHJcblx0XHRcdFx0dXZOb2RlID0gdXZOb2RlLmZsaXBZKCk7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHR1dk5vZGUgPSB1dk5vZGUuc2V0WSggaW50KCB0ZXh0dXJlU2l6ZSggdGhpcywgdGhpcy5sZXZlbE5vZGUgKS55ICkuc3ViKCB1dk5vZGUueSApLnN1YiggMSApICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB1dk5vZGU7XHJcblxyXG5cdH1cclxuXHJcblx0c2V0dXAoIGJ1aWxkZXIgKSB7XHJcblxyXG5cdFx0Y29uc3QgcHJvcGVydGllcyA9IGJ1aWxkZXIuZ2V0Tm9kZVByb3BlcnRpZXMoIHRoaXMgKTtcclxuXHRcdHByb3BlcnRpZXMucmVmZXJlbmNlTm9kZSA9IHRoaXMucmVmZXJlbmNlTm9kZTtcclxuXHJcblx0XHQvL1xyXG5cclxuXHRcdGxldCB1dk5vZGUgPSB0aGlzLnV2Tm9kZTtcclxuXHJcblx0XHRpZiAoICggdXZOb2RlID09PSBudWxsIHx8IGJ1aWxkZXIuY29udGV4dC5mb3JjZVVWQ29udGV4dCA9PT0gdHJ1ZSApICYmIGJ1aWxkZXIuY29udGV4dC5nZXRVViApIHtcclxuXHJcblx0XHRcdHV2Tm9kZSA9IGJ1aWxkZXIuY29udGV4dC5nZXRVViggdGhpcyApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoICEgdXZOb2RlICkgdXZOb2RlID0gdGhpcy5nZXREZWZhdWx0VVYoKTtcclxuXHJcblx0XHRpZiAoIHRoaXMudXBkYXRlTWF0cml4ID09PSB0cnVlICkge1xyXG5cclxuXHRcdFx0dXZOb2RlID0gdGhpcy5nZXRUcmFuc2Zvcm1lZFVWKCB1dk5vZGUgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dXZOb2RlID0gdGhpcy5zZXR1cFVWKCBidWlsZGVyLCB1dk5vZGUgKTtcclxuXHJcblx0XHQvL1xyXG5cclxuXHRcdGxldCBsZXZlbE5vZGUgPSB0aGlzLmxldmVsTm9kZTtcclxuXHJcblx0XHRpZiAoIGxldmVsTm9kZSA9PT0gbnVsbCAmJiBidWlsZGVyLmNvbnRleHQuZ2V0VGV4dHVyZUxldmVsICkge1xyXG5cclxuXHRcdFx0bGV2ZWxOb2RlID0gYnVpbGRlci5jb250ZXh0LmdldFRleHR1cmVMZXZlbCggdGhpcyApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvL1xyXG5cclxuXHRcdHByb3BlcnRpZXMudXZOb2RlID0gdXZOb2RlO1xyXG5cdFx0cHJvcGVydGllcy5sZXZlbE5vZGUgPSBsZXZlbE5vZGU7XHJcblx0XHRwcm9wZXJ0aWVzLmJpYXNOb2RlID0gdGhpcy5iaWFzTm9kZTtcclxuXHRcdHByb3BlcnRpZXMuY29tcGFyZU5vZGUgPSB0aGlzLmNvbXBhcmVOb2RlO1xyXG5cdFx0cHJvcGVydGllcy5ncmFkTm9kZSA9IHRoaXMuZ3JhZE5vZGU7XHJcblx0XHRwcm9wZXJ0aWVzLmRlcHRoTm9kZSA9IHRoaXMuZGVwdGhOb2RlO1xyXG5cclxuXHR9XHJcblxyXG5cdGdlbmVyYXRlVVYoIGJ1aWxkZXIsIHV2Tm9kZSApIHtcclxuXHJcblx0XHRyZXR1cm4gdXZOb2RlLmJ1aWxkKCBidWlsZGVyLCB0aGlzLnNhbXBsZXIgPT09IHRydWUgPyAndmVjMicgOiAnaXZlYzInICk7XHJcblxyXG5cdH1cclxuXHJcblx0Z2VuZXJhdGVTbmlwcGV0KCBidWlsZGVyLCB0ZXh0dXJlUHJvcGVydHksIHV2U25pcHBldCwgbGV2ZWxTbmlwcGV0LCBiaWFzU25pcHBldCwgZGVwdGhTbmlwcGV0LCBjb21wYXJlU25pcHBldCwgZ3JhZFNuaXBwZXQgKSB7XHJcblxyXG5cdFx0Y29uc3QgdGV4dHVyZSA9IHRoaXMudmFsdWU7XHJcblxyXG5cdFx0bGV0IHNuaXBwZXQ7XHJcblxyXG5cdFx0aWYgKCBsZXZlbFNuaXBwZXQgKSB7XHJcblxyXG5cdFx0XHRzbmlwcGV0ID0gYnVpbGRlci5nZW5lcmF0ZVRleHR1cmVMZXZlbCggdGV4dHVyZSwgdGV4dHVyZVByb3BlcnR5LCB1dlNuaXBwZXQsIGxldmVsU25pcHBldCwgZGVwdGhTbmlwcGV0ICk7XHJcblxyXG5cdFx0fSBlbHNlIGlmICggYmlhc1NuaXBwZXQgKSB7XHJcblxyXG5cdFx0XHRzbmlwcGV0ID0gYnVpbGRlci5nZW5lcmF0ZVRleHR1cmVCaWFzKCB0ZXh0dXJlLCB0ZXh0dXJlUHJvcGVydHksIHV2U25pcHBldCwgYmlhc1NuaXBwZXQsIGRlcHRoU25pcHBldCApO1xyXG5cclxuXHRcdH0gZWxzZSBpZiAoIGdyYWRTbmlwcGV0ICkge1xyXG5cclxuXHRcdFx0c25pcHBldCA9IGJ1aWxkZXIuZ2VuZXJhdGVUZXh0dXJlR3JhZCggdGV4dHVyZSwgdGV4dHVyZVByb3BlcnR5LCB1dlNuaXBwZXQsIGdyYWRTbmlwcGV0LCBkZXB0aFNuaXBwZXQgKTtcclxuXHJcblx0XHR9IGVsc2UgaWYgKCBjb21wYXJlU25pcHBldCApIHtcclxuXHJcblx0XHRcdHNuaXBwZXQgPSBidWlsZGVyLmdlbmVyYXRlVGV4dHVyZUNvbXBhcmUoIHRleHR1cmUsIHRleHR1cmVQcm9wZXJ0eSwgdXZTbmlwcGV0LCBjb21wYXJlU25pcHBldCwgZGVwdGhTbmlwcGV0ICk7XHJcblxyXG5cdFx0fSBlbHNlIGlmICggdGhpcy5zYW1wbGVyID09PSBmYWxzZSApIHtcclxuXHJcblx0XHRcdHNuaXBwZXQgPSBidWlsZGVyLmdlbmVyYXRlVGV4dHVyZUxvYWQoIHRleHR1cmUsIHRleHR1cmVQcm9wZXJ0eSwgdXZTbmlwcGV0LCBkZXB0aFNuaXBwZXQgKTtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0c25pcHBldCA9IGJ1aWxkZXIuZ2VuZXJhdGVUZXh0dXJlKCB0ZXh0dXJlLCB0ZXh0dXJlUHJvcGVydHksIHV2U25pcHBldCwgZGVwdGhTbmlwcGV0ICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBzbmlwcGV0O1xyXG5cclxuXHR9XHJcblxyXG5cdGdlbmVyYXRlKCBidWlsZGVyLCBvdXRwdXQgKSB7XHJcblxyXG5cdFx0Y29uc3QgcHJvcGVydGllcyA9IGJ1aWxkZXIuZ2V0Tm9kZVByb3BlcnRpZXMoIHRoaXMgKTtcclxuXHJcblx0XHRjb25zdCB0ZXh0dXJlID0gdGhpcy52YWx1ZTtcclxuXHJcblx0XHRpZiAoICEgdGV4dHVyZSB8fCB0ZXh0dXJlLmlzVGV4dHVyZSAhPT0gdHJ1ZSApIHtcclxuXHJcblx0XHRcdHRocm93IG5ldyBFcnJvciggJ1RleHR1cmVOb2RlOiBOZWVkIGEgdGhyZWUuanMgdGV4dHVyZS4nICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGNvbnN0IHRleHR1cmVQcm9wZXJ0eSA9IHN1cGVyLmdlbmVyYXRlKCBidWlsZGVyLCAncHJvcGVydHknICk7XHJcblxyXG5cdFx0aWYgKCBvdXRwdXQgPT09ICdzYW1wbGVyJyApIHtcclxuXHJcblx0XHRcdHJldHVybiB0ZXh0dXJlUHJvcGVydHkgKyAnX3NhbXBsZXInO1xyXG5cclxuXHRcdH0gZWxzZSBpZiAoIGJ1aWxkZXIuaXNSZWZlcmVuY2UoIG91dHB1dCApICkge1xyXG5cclxuXHRcdFx0cmV0dXJuIHRleHR1cmVQcm9wZXJ0eTtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0Y29uc3Qgbm9kZURhdGEgPSBidWlsZGVyLmdldERhdGFGcm9tTm9kZSggdGhpcyApO1xyXG5cclxuXHRcdFx0bGV0IHByb3BlcnR5TmFtZSA9IG5vZGVEYXRhLnByb3BlcnR5TmFtZTtcclxuXHJcblx0XHRcdGlmICggcHJvcGVydHlOYW1lID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdGNvbnN0IHsgdXZOb2RlLCBsZXZlbE5vZGUsIGJpYXNOb2RlLCBjb21wYXJlTm9kZSwgZGVwdGhOb2RlLCBncmFkTm9kZSB9ID0gcHJvcGVydGllcztcclxuXHJcblx0XHRcdFx0Y29uc3QgdXZTbmlwcGV0ID0gdGhpcy5nZW5lcmF0ZVVWKCBidWlsZGVyLCB1dk5vZGUgKTtcclxuXHRcdFx0XHRjb25zdCBsZXZlbFNuaXBwZXQgPSBsZXZlbE5vZGUgPyBsZXZlbE5vZGUuYnVpbGQoIGJ1aWxkZXIsICdmbG9hdCcgKSA6IG51bGw7XHJcblx0XHRcdFx0Y29uc3QgYmlhc1NuaXBwZXQgPSBiaWFzTm9kZSA/IGJpYXNOb2RlLmJ1aWxkKCBidWlsZGVyLCAnZmxvYXQnICkgOiBudWxsO1xyXG5cdFx0XHRcdGNvbnN0IGRlcHRoU25pcHBldCA9IGRlcHRoTm9kZSA/IGRlcHRoTm9kZS5idWlsZCggYnVpbGRlciwgJ2ludCcgKSA6IG51bGw7XHJcblx0XHRcdFx0Y29uc3QgY29tcGFyZVNuaXBwZXQgPSBjb21wYXJlTm9kZSA/IGNvbXBhcmVOb2RlLmJ1aWxkKCBidWlsZGVyLCAnZmxvYXQnICkgOiBudWxsO1xyXG5cdFx0XHRcdGNvbnN0IGdyYWRTbmlwcGV0ID0gZ3JhZE5vZGUgPyBbIGdyYWROb2RlWyAwIF0uYnVpbGQoIGJ1aWxkZXIsICd2ZWMyJyApLCBncmFkTm9kZVsgMSBdLmJ1aWxkKCBidWlsZGVyLCAndmVjMicgKSBdIDogbnVsbDtcclxuXHJcblx0XHRcdFx0Y29uc3Qgbm9kZVZhciA9IGJ1aWxkZXIuZ2V0VmFyRnJvbU5vZGUoIHRoaXMgKTtcclxuXHJcblx0XHRcdFx0cHJvcGVydHlOYW1lID0gYnVpbGRlci5nZXRQcm9wZXJ0eU5hbWUoIG5vZGVWYXIgKTtcclxuXHJcblx0XHRcdFx0Y29uc3Qgc25pcHBldCA9IHRoaXMuZ2VuZXJhdGVTbmlwcGV0KCBidWlsZGVyLCB0ZXh0dXJlUHJvcGVydHksIHV2U25pcHBldCwgbGV2ZWxTbmlwcGV0LCBiaWFzU25pcHBldCwgZGVwdGhTbmlwcGV0LCBjb21wYXJlU25pcHBldCwgZ3JhZFNuaXBwZXQgKTtcclxuXHJcblx0XHRcdFx0YnVpbGRlci5hZGRMaW5lRmxvd0NvZGUoIGAke3Byb3BlcnR5TmFtZX0gPSAke3NuaXBwZXR9YCwgdGhpcyApO1xyXG5cclxuXHRcdFx0XHRub2RlRGF0YS5zbmlwcGV0ID0gc25pcHBldDtcclxuXHRcdFx0XHRub2RlRGF0YS5wcm9wZXJ0eU5hbWUgPSBwcm9wZXJ0eU5hbWU7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRsZXQgc25pcHBldCA9IHByb3BlcnR5TmFtZTtcclxuXHRcdFx0Y29uc3Qgbm9kZVR5cGUgPSB0aGlzLmdldE5vZGVUeXBlKCBidWlsZGVyICk7XHJcblxyXG5cdFx0XHRpZiAoIGJ1aWxkZXIubmVlZHNUb1dvcmtpbmdDb2xvclNwYWNlKCB0ZXh0dXJlICkgKSB7XHJcblxyXG5cdFx0XHRcdHNuaXBwZXQgPSBjb2xvclNwYWNlVG9Xb3JraW5nKCBleHByZXNzaW9uKCBzbmlwcGV0LCBub2RlVHlwZSApLCB0ZXh0dXJlLmNvbG9yU3BhY2UgKS5zZXR1cCggYnVpbGRlciApLmJ1aWxkKCBidWlsZGVyLCBub2RlVHlwZSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmV0dXJuIGJ1aWxkZXIuZm9ybWF0KCBzbmlwcGV0LCBub2RlVHlwZSwgb3V0cHV0ICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdHNldFNhbXBsZXIoIHZhbHVlICkge1xyXG5cclxuXHRcdHRoaXMuc2FtcGxlciA9IHZhbHVlO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9XHJcblxyXG5cdGdldFNhbXBsZXIoKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuc2FtcGxlcjtcclxuXHJcblx0fVxyXG5cclxuXHQvLyBAVE9ETzogTW92ZSB0byBUU0xcclxuXHJcblx0dXYoIHV2Tm9kZSApIHsgLy8gQGRlcHJlY2F0ZWQsIHIxNzJcclxuXHJcblx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5UZXh0dXJlTm9kZTogLnV2KCkgaGFzIGJlZW4gcmVuYW1lZC4gVXNlIC5zYW1wbGUoKSBpbnN0ZWFkLicgKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5zYW1wbGUoIHV2Tm9kZSApO1xyXG5cclxuXHR9XHJcblxyXG5cdHNhbXBsZSggdXZOb2RlICkge1xyXG5cclxuXHRcdGNvbnN0IHRleHR1cmVOb2RlID0gdGhpcy5jbG9uZSgpO1xyXG5cdFx0dGV4dHVyZU5vZGUudXZOb2RlID0gbm9kZU9iamVjdCggdXZOb2RlICk7XHJcblx0XHR0ZXh0dXJlTm9kZS5yZWZlcmVuY2VOb2RlID0gdGhpcy5nZXRTZWxmKCk7XHJcblxyXG5cdFx0cmV0dXJuIG5vZGVPYmplY3QoIHRleHR1cmVOb2RlICk7XHJcblxyXG5cdH1cclxuXHJcblx0Ymx1ciggYW1vdW50Tm9kZSApIHtcclxuXHJcblx0XHRjb25zdCB0ZXh0dXJlTm9kZSA9IHRoaXMuY2xvbmUoKTtcclxuXHRcdHRleHR1cmVOb2RlLmJpYXNOb2RlID0gbm9kZU9iamVjdCggYW1vdW50Tm9kZSApLm11bCggbWF4TWlwTGV2ZWwoIHRleHR1cmVOb2RlICkgKTtcclxuXHRcdHRleHR1cmVOb2RlLnJlZmVyZW5jZU5vZGUgPSB0aGlzLmdldFNlbGYoKTtcclxuXHJcblx0XHRyZXR1cm4gbm9kZU9iamVjdCggdGV4dHVyZU5vZGUgKTtcclxuXHJcblx0fVxyXG5cclxuXHRsZXZlbCggbGV2ZWxOb2RlICkge1xyXG5cclxuXHRcdGNvbnN0IHRleHR1cmVOb2RlID0gdGhpcy5jbG9uZSgpO1xyXG5cdFx0dGV4dHVyZU5vZGUubGV2ZWxOb2RlID0gbm9kZU9iamVjdCggbGV2ZWxOb2RlICk7XHJcblx0XHR0ZXh0dXJlTm9kZS5yZWZlcmVuY2VOb2RlID0gdGhpcy5nZXRTZWxmKCk7XHJcblxyXG5cdFx0cmV0dXJuIG5vZGVPYmplY3QoIHRleHR1cmVOb2RlICk7XHJcblxyXG5cdH1cclxuXHJcblx0c2l6ZSggbGV2ZWxOb2RlICkge1xyXG5cclxuXHRcdHJldHVybiB0ZXh0dXJlU2l6ZSggdGhpcywgbGV2ZWxOb2RlICk7XHJcblxyXG5cdH1cclxuXHJcblx0YmlhcyggYmlhc05vZGUgKSB7XHJcblxyXG5cdFx0Y29uc3QgdGV4dHVyZU5vZGUgPSB0aGlzLmNsb25lKCk7XHJcblx0XHR0ZXh0dXJlTm9kZS5iaWFzTm9kZSA9IG5vZGVPYmplY3QoIGJpYXNOb2RlICk7XHJcblx0XHR0ZXh0dXJlTm9kZS5yZWZlcmVuY2VOb2RlID0gdGhpcy5nZXRTZWxmKCk7XHJcblxyXG5cdFx0cmV0dXJuIG5vZGVPYmplY3QoIHRleHR1cmVOb2RlICk7XHJcblxyXG5cdH1cclxuXHJcblx0Y29tcGFyZSggY29tcGFyZU5vZGUgKSB7XHJcblxyXG5cdFx0Y29uc3QgdGV4dHVyZU5vZGUgPSB0aGlzLmNsb25lKCk7XHJcblx0XHR0ZXh0dXJlTm9kZS5jb21wYXJlTm9kZSA9IG5vZGVPYmplY3QoIGNvbXBhcmVOb2RlICk7XHJcblx0XHR0ZXh0dXJlTm9kZS5yZWZlcmVuY2VOb2RlID0gdGhpcy5nZXRTZWxmKCk7XHJcblxyXG5cdFx0cmV0dXJuIG5vZGVPYmplY3QoIHRleHR1cmVOb2RlICk7XHJcblxyXG5cdH1cclxuXHJcblx0Z3JhZCggZ3JhZE5vZGVYLCBncmFkTm9kZVkgKSB7XHJcblxyXG5cdFx0Y29uc3QgdGV4dHVyZU5vZGUgPSB0aGlzLmNsb25lKCk7XHJcblx0XHR0ZXh0dXJlTm9kZS5ncmFkTm9kZSA9IFsgbm9kZU9iamVjdCggZ3JhZE5vZGVYICksIG5vZGVPYmplY3QoIGdyYWROb2RlWSApIF07XHJcblx0XHR0ZXh0dXJlTm9kZS5yZWZlcmVuY2VOb2RlID0gdGhpcy5nZXRTZWxmKCk7XHJcblxyXG5cdFx0cmV0dXJuIG5vZGVPYmplY3QoIHRleHR1cmVOb2RlICk7XHJcblxyXG5cdH1cclxuXHJcblx0ZGVwdGgoIGRlcHRoTm9kZSApIHtcclxuXHJcblx0XHRjb25zdCB0ZXh0dXJlTm9kZSA9IHRoaXMuY2xvbmUoKTtcclxuXHRcdHRleHR1cmVOb2RlLmRlcHRoTm9kZSA9IG5vZGVPYmplY3QoIGRlcHRoTm9kZSApO1xyXG5cdFx0dGV4dHVyZU5vZGUucmVmZXJlbmNlTm9kZSA9IHRoaXMuZ2V0U2VsZigpO1xyXG5cclxuXHRcdHJldHVybiBub2RlT2JqZWN0KCB0ZXh0dXJlTm9kZSApO1xyXG5cclxuXHR9XHJcblxyXG5cdC8vIC0tXHJcblxyXG5cdHNlcmlhbGl6ZSggZGF0YSApIHtcclxuXHJcblx0XHRzdXBlci5zZXJpYWxpemUoIGRhdGEgKTtcclxuXHJcblx0XHRkYXRhLnZhbHVlID0gdGhpcy52YWx1ZS50b0pTT04oIGRhdGEubWV0YSApLnV1aWQ7XHJcblx0XHRkYXRhLnNhbXBsZXIgPSB0aGlzLnNhbXBsZXI7XHJcblx0XHRkYXRhLnVwZGF0ZU1hdHJpeCA9IHRoaXMudXBkYXRlTWF0cml4O1xyXG5cdFx0ZGF0YS51cGRhdGVUeXBlID0gdGhpcy51cGRhdGVUeXBlO1xyXG5cclxuXHR9XHJcblxyXG5cdGRlc2VyaWFsaXplKCBkYXRhICkge1xyXG5cclxuXHRcdHN1cGVyLmRlc2VyaWFsaXplKCBkYXRhICk7XHJcblxyXG5cdFx0dGhpcy52YWx1ZSA9IGRhdGEubWV0YS50ZXh0dXJlc1sgZGF0YS52YWx1ZSBdO1xyXG5cdFx0dGhpcy5zYW1wbGVyID0gZGF0YS5zYW1wbGVyO1xyXG5cdFx0dGhpcy51cGRhdGVNYXRyaXggPSBkYXRhLnVwZGF0ZU1hdHJpeDtcclxuXHRcdHRoaXMudXBkYXRlVHlwZSA9IGRhdGEudXBkYXRlVHlwZTtcclxuXHJcblx0fVxyXG5cclxuXHR1cGRhdGUoKSB7XHJcblxyXG5cdFx0Y29uc3QgdGV4dHVyZSA9IHRoaXMudmFsdWU7XHJcblx0XHRjb25zdCBtYXRyaXhVbmlmb3JtID0gdGhpcy5fbWF0cml4VW5pZm9ybTtcclxuXHJcblx0XHRpZiAoIG1hdHJpeFVuaWZvcm0gIT09IG51bGwgKSBtYXRyaXhVbmlmb3JtLnZhbHVlID0gdGV4dHVyZS5tYXRyaXg7XHJcblxyXG5cdFx0aWYgKCB0ZXh0dXJlLm1hdHJpeEF1dG9VcGRhdGUgPT09IHRydWUgKSB7XHJcblxyXG5cdFx0XHR0ZXh0dXJlLnVwZGF0ZU1hdHJpeCgpO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHRjbG9uZSgpIHtcclxuXHJcblx0XHRjb25zdCBuZXdOb2RlID0gbmV3IHRoaXMuY29uc3RydWN0b3IoIHRoaXMudmFsdWUsIHRoaXMudXZOb2RlLCB0aGlzLmxldmVsTm9kZSwgdGhpcy5iaWFzTm9kZSApO1xyXG5cdFx0bmV3Tm9kZS5zYW1wbGVyID0gdGhpcy5zYW1wbGVyO1xyXG5cclxuXHRcdHJldHVybiBuZXdOb2RlO1xyXG5cclxuXHR9XHJcblxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBUZXh0dXJlTm9kZTtcclxuXHJcbmV4cG9ydCBjb25zdCB0ZXh0dXJlID0gLypAX19QVVJFX18qLyBub2RlUHJveHkoIFRleHR1cmVOb2RlICk7XHJcbmV4cG9ydCBjb25zdCB0ZXh0dXJlTG9hZCA9ICggLi4ucGFyYW1zICkgPT4gdGV4dHVyZSggLi4ucGFyYW1zICkuc2V0U2FtcGxlciggZmFsc2UgKTtcclxuXHJcbi8vZXhwb3J0IGNvbnN0IHRleHR1cmVMZXZlbCA9ICggdmFsdWUsIHV2LCBsZXZlbCApID0+IHRleHR1cmUoIHZhbHVlLCB1diApLmxldmVsKCBsZXZlbCApO1xyXG5cclxuZXhwb3J0IGNvbnN0IHNhbXBsZXIgPSAoIGFUZXh0dXJlICkgPT4gKCBhVGV4dHVyZS5pc05vZGUgPT09IHRydWUgPyBhVGV4dHVyZSA6IHRleHR1cmUoIGFUZXh0dXJlICkgKS5jb252ZXJ0KCAnc2FtcGxlcicgKTtcclxuIiwiaW1wb3J0IHsgdW5pZm9ybSB9IGZyb20gJy4uL2NvcmUvVW5pZm9ybU5vZGUuanMnO1xyXG5pbXBvcnQgeyByZW5kZXJHcm91cCB9IGZyb20gJy4uL2NvcmUvVW5pZm9ybUdyb3VwTm9kZS5qcyc7XHJcbmltcG9ydCB7IFZlY3RvcjMgfSBmcm9tICcuLi8uLi9tYXRoL1ZlY3RvcjMuanMnO1xyXG5cclxuLyoqIEBtb2R1bGUgQ2FtZXJhICoqL1xyXG5cclxuLyoqXHJcbiAqIFRTTCBvYmplY3QgdGhhdCByZXByZXNlbnRzIHRoZSBgbmVhcmAgdmFsdWUgb2YgdGhlIGNhbWVyYSB1c2VkIGZvciB0aGUgY3VycmVudCByZW5kZXIuXHJcbiAqXHJcbiAqIEB0eXBlIHtVbmlmb3JtTm9kZTxmbG9hdD59XHJcbiAqL1xyXG5leHBvcnQgY29uc3QgY2FtZXJhTmVhciA9IC8qQF9fUFVSRV9fKi8gdW5pZm9ybSggJ2Zsb2F0JyApLmxhYmVsKCAnY2FtZXJhTmVhcicgKS5zZXRHcm91cCggcmVuZGVyR3JvdXAgKS5vblJlbmRlclVwZGF0ZSggKCB7IGNhbWVyYSB9ICkgPT4gY2FtZXJhLm5lYXIgKTtcclxuXHJcbi8qKlxyXG4gKiBUU0wgb2JqZWN0IHRoYXQgcmVwcmVzZW50cyB0aGUgYGZhcmAgdmFsdWUgb2YgdGhlIGNhbWVyYSB1c2VkIGZvciB0aGUgY3VycmVudCByZW5kZXIuXHJcbiAqXHJcbiAqIEB0eXBlIHtVbmlmb3JtTm9kZTxmbG9hdD59XHJcbiAqL1xyXG5leHBvcnQgY29uc3QgY2FtZXJhRmFyID0gLypAX19QVVJFX18qLyB1bmlmb3JtKCAnZmxvYXQnICkubGFiZWwoICdjYW1lcmFGYXInICkuc2V0R3JvdXAoIHJlbmRlckdyb3VwICkub25SZW5kZXJVcGRhdGUoICggeyBjYW1lcmEgfSApID0+IGNhbWVyYS5mYXIgKTtcclxuXHJcbi8qKlxyXG4gKiBUU0wgb2JqZWN0IHRoYXQgcmVwcmVzZW50cyB0aGUgcHJvamVjdGlvbiBtYXRyaXggb2YgdGhlIGNhbWVyYSB1c2VkIGZvciB0aGUgY3VycmVudCByZW5kZXIuXHJcbiAqXHJcbiAqIEB0eXBlIHtVbmlmb3JtTm9kZTxtYXQ0Pn1cclxuICovXHJcbmV4cG9ydCBjb25zdCBjYW1lcmFQcm9qZWN0aW9uTWF0cml4ID0gLypAX19QVVJFX18qLyB1bmlmb3JtKCAnbWF0NCcgKS5sYWJlbCggJ2NhbWVyYVByb2plY3Rpb25NYXRyaXgnICkuc2V0R3JvdXAoIHJlbmRlckdyb3VwICkub25SZW5kZXJVcGRhdGUoICggeyBjYW1lcmEgfSApID0+IGNhbWVyYS5wcm9qZWN0aW9uTWF0cml4ICk7XHJcblxyXG4vKipcclxuICogVFNMIG9iamVjdCB0aGF0IHJlcHJlc2VudHMgdGhlIGludmVyc2UgcHJvamVjdGlvbiBtYXRyaXggb2YgdGhlIGNhbWVyYSB1c2VkIGZvciB0aGUgY3VycmVudCByZW5kZXIuXHJcbiAqXHJcbiAqIEB0eXBlIHtVbmlmb3JtTm9kZTxtYXQ0Pn1cclxuICovXHJcbmV4cG9ydCBjb25zdCBjYW1lcmFQcm9qZWN0aW9uTWF0cml4SW52ZXJzZSA9IC8qQF9fUFVSRV9fKi8gdW5pZm9ybSggJ21hdDQnICkubGFiZWwoICdjYW1lcmFQcm9qZWN0aW9uTWF0cml4SW52ZXJzZScgKS5zZXRHcm91cCggcmVuZGVyR3JvdXAgKS5vblJlbmRlclVwZGF0ZSggKCB7IGNhbWVyYSB9ICkgPT4gY2FtZXJhLnByb2plY3Rpb25NYXRyaXhJbnZlcnNlICk7XHJcblxyXG4vKipcclxuICogVFNMIG9iamVjdCB0aGF0IHJlcHJlc2VudHMgdGhlIHZpZXcgbWF0cml4IG9mIHRoZSBjYW1lcmEgdXNlZCBmb3IgdGhlIGN1cnJlbnQgcmVuZGVyLlxyXG4gKlxyXG4gKiBAdHlwZSB7VW5pZm9ybU5vZGU8bWF0ND59XHJcbiAqL1xyXG5leHBvcnQgY29uc3QgY2FtZXJhVmlld01hdHJpeCA9IC8qQF9fUFVSRV9fKi8gdW5pZm9ybSggJ21hdDQnICkubGFiZWwoICdjYW1lcmFWaWV3TWF0cml4JyApLnNldEdyb3VwKCByZW5kZXJHcm91cCApLm9uUmVuZGVyVXBkYXRlKCAoIHsgY2FtZXJhIH0gKSA9PiBjYW1lcmEubWF0cml4V29ybGRJbnZlcnNlICk7XHJcblxyXG4vKipcclxuICogVFNMIG9iamVjdCB0aGF0IHJlcHJlc2VudHMgdGhlIHdvcmxkIG1hdHJpeCBvZiB0aGUgY2FtZXJhIHVzZWQgZm9yIHRoZSBjdXJyZW50IHJlbmRlci5cclxuICpcclxuICogQHR5cGUge1VuaWZvcm1Ob2RlPG1hdDQ+fVxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IGNhbWVyYVdvcmxkTWF0cml4ID0gLypAX19QVVJFX18qLyB1bmlmb3JtKCAnbWF0NCcgKS5sYWJlbCggJ2NhbWVyYVdvcmxkTWF0cml4JyApLnNldEdyb3VwKCByZW5kZXJHcm91cCApLm9uUmVuZGVyVXBkYXRlKCAoIHsgY2FtZXJhIH0gKSA9PiBjYW1lcmEubWF0cml4V29ybGQgKTtcclxuXHJcbi8qKlxyXG4gKiBUU0wgb2JqZWN0IHRoYXQgcmVwcmVzZW50cyB0aGUgbm9ybWFsIG1hdHJpeCBvZiB0aGUgY2FtZXJhIHVzZWQgZm9yIHRoZSBjdXJyZW50IHJlbmRlci5cclxuICpcclxuICogQHR5cGUge1VuaWZvcm1Ob2RlPG1hdDM+fVxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IGNhbWVyYU5vcm1hbE1hdHJpeCA9IC8qQF9fUFVSRV9fKi8gdW5pZm9ybSggJ21hdDMnICkubGFiZWwoICdjYW1lcmFOb3JtYWxNYXRyaXgnICkuc2V0R3JvdXAoIHJlbmRlckdyb3VwICkub25SZW5kZXJVcGRhdGUoICggeyBjYW1lcmEgfSApID0+IGNhbWVyYS5ub3JtYWxNYXRyaXggKTtcclxuXHJcbi8qKlxyXG4gKiBUU0wgb2JqZWN0IHRoYXQgcmVwcmVzZW50cyB0aGUgcG9zaXRvbiBpbiB3b3JsZCBzcGFjZSBvZiB0aGUgY2FtZXJhIHVzZWQgZm9yIHRoZSBjdXJyZW50IHJlbmRlci5cclxuICpcclxuICogQHR5cGUge1VuaWZvcm1Ob2RlPHZlYzM+fVxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IGNhbWVyYVBvc2l0aW9uID0gLypAX19QVVJFX18qLyB1bmlmb3JtKCBuZXcgVmVjdG9yMygpICkubGFiZWwoICdjYW1lcmFQb3NpdGlvbicgKS5zZXRHcm91cCggcmVuZGVyR3JvdXAgKS5vblJlbmRlclVwZGF0ZSggKCB7IGNhbWVyYSB9LCBzZWxmICkgPT4gc2VsZi52YWx1ZS5zZXRGcm9tTWF0cml4UG9zaXRpb24oIGNhbWVyYS5tYXRyaXhXb3JsZCApICk7XHJcbiIsImltcG9ydCBOb2RlIGZyb20gJy4uL2NvcmUvTm9kZS5qcyc7XHJcbmltcG9ydCB7IE5vZGVVcGRhdGVUeXBlIH0gZnJvbSAnLi4vY29yZS9jb25zdGFudHMuanMnO1xyXG5pbXBvcnQgVW5pZm9ybU5vZGUgZnJvbSAnLi4vY29yZS9Vbmlmb3JtTm9kZS5qcyc7XHJcbmltcG9ydCB7IG5vZGVQcm94eSB9IGZyb20gJy4uL3RzbC9UU0xCYXNlLmpzJztcclxuXHJcbmltcG9ydCB7IFZlY3RvcjMgfSBmcm9tICcuLi8uLi9tYXRoL1ZlY3RvcjMuanMnO1xyXG5cclxuY2xhc3MgT2JqZWN0M0ROb2RlIGV4dGVuZHMgTm9kZSB7XHJcblxyXG5cdHN0YXRpYyBnZXQgdHlwZSgpIHtcclxuXHJcblx0XHRyZXR1cm4gJ09iamVjdDNETm9kZSc7XHJcblxyXG5cdH1cclxuXHJcblx0Y29uc3RydWN0b3IoIHNjb3BlLCBvYmplY3QzZCA9IG51bGwgKSB7XHJcblxyXG5cdFx0c3VwZXIoKTtcclxuXHJcblx0XHR0aGlzLnNjb3BlID0gc2NvcGU7XHJcblx0XHR0aGlzLm9iamVjdDNkID0gb2JqZWN0M2Q7XHJcblxyXG5cdFx0dGhpcy51cGRhdGVUeXBlID0gTm9kZVVwZGF0ZVR5cGUuT0JKRUNUO1xyXG5cclxuXHRcdHRoaXMuX3VuaWZvcm1Ob2RlID0gbmV3IFVuaWZvcm1Ob2RlKCBudWxsICk7XHJcblxyXG5cdH1cclxuXHJcblx0Z2V0Tm9kZVR5cGUoKSB7XHJcblxyXG5cdFx0Y29uc3Qgc2NvcGUgPSB0aGlzLnNjb3BlO1xyXG5cclxuXHRcdGlmICggc2NvcGUgPT09IE9iamVjdDNETm9kZS5XT1JMRF9NQVRSSVggKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gJ21hdDQnO1xyXG5cclxuXHRcdH0gZWxzZSBpZiAoIHNjb3BlID09PSBPYmplY3QzRE5vZGUuUE9TSVRJT04gfHwgc2NvcGUgPT09IE9iamVjdDNETm9kZS5WSUVXX1BPU0lUSU9OIHx8IHNjb3BlID09PSBPYmplY3QzRE5vZGUuRElSRUNUSU9OIHx8IHNjb3BlID09PSBPYmplY3QzRE5vZGUuU0NBTEUgKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gJ3ZlYzMnO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHR1cGRhdGUoIGZyYW1lICkge1xyXG5cclxuXHRcdGNvbnN0IG9iamVjdCA9IHRoaXMub2JqZWN0M2Q7XHJcblx0XHRjb25zdCB1bmlmb3JtTm9kZSA9IHRoaXMuX3VuaWZvcm1Ob2RlO1xyXG5cdFx0Y29uc3Qgc2NvcGUgPSB0aGlzLnNjb3BlO1xyXG5cclxuXHRcdGlmICggc2NvcGUgPT09IE9iamVjdDNETm9kZS5XT1JMRF9NQVRSSVggKSB7XHJcblxyXG5cdFx0XHR1bmlmb3JtTm9kZS52YWx1ZSA9IG9iamVjdC5tYXRyaXhXb3JsZDtcclxuXHJcblx0XHR9IGVsc2UgaWYgKCBzY29wZSA9PT0gT2JqZWN0M0ROb2RlLlBPU0lUSU9OICkge1xyXG5cclxuXHRcdFx0dW5pZm9ybU5vZGUudmFsdWUgPSB1bmlmb3JtTm9kZS52YWx1ZSB8fCBuZXcgVmVjdG9yMygpO1xyXG5cclxuXHRcdFx0dW5pZm9ybU5vZGUudmFsdWUuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCBvYmplY3QubWF0cml4V29ybGQgKTtcclxuXHJcblx0XHR9IGVsc2UgaWYgKCBzY29wZSA9PT0gT2JqZWN0M0ROb2RlLlNDQUxFICkge1xyXG5cclxuXHRcdFx0dW5pZm9ybU5vZGUudmFsdWUgPSB1bmlmb3JtTm9kZS52YWx1ZSB8fCBuZXcgVmVjdG9yMygpO1xyXG5cclxuXHRcdFx0dW5pZm9ybU5vZGUudmFsdWUuc2V0RnJvbU1hdHJpeFNjYWxlKCBvYmplY3QubWF0cml4V29ybGQgKTtcclxuXHJcblx0XHR9IGVsc2UgaWYgKCBzY29wZSA9PT0gT2JqZWN0M0ROb2RlLkRJUkVDVElPTiApIHtcclxuXHJcblx0XHRcdHVuaWZvcm1Ob2RlLnZhbHVlID0gdW5pZm9ybU5vZGUudmFsdWUgfHwgbmV3IFZlY3RvcjMoKTtcclxuXHJcblx0XHRcdG9iamVjdC5nZXRXb3JsZERpcmVjdGlvbiggdW5pZm9ybU5vZGUudmFsdWUgKTtcclxuXHJcblx0XHR9IGVsc2UgaWYgKCBzY29wZSA9PT0gT2JqZWN0M0ROb2RlLlZJRVdfUE9TSVRJT04gKSB7XHJcblxyXG5cdFx0XHRjb25zdCBjYW1lcmEgPSBmcmFtZS5jYW1lcmE7XHJcblxyXG5cdFx0XHR1bmlmb3JtTm9kZS52YWx1ZSA9IHVuaWZvcm1Ob2RlLnZhbHVlIHx8IG5ldyBWZWN0b3IzKCk7XHJcblx0XHRcdHVuaWZvcm1Ob2RlLnZhbHVlLnNldEZyb21NYXRyaXhQb3NpdGlvbiggb2JqZWN0Lm1hdHJpeFdvcmxkICk7XHJcblxyXG5cdFx0XHR1bmlmb3JtTm9kZS52YWx1ZS5hcHBseU1hdHJpeDQoIGNhbWVyYS5tYXRyaXhXb3JsZEludmVyc2UgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0Z2VuZXJhdGUoIGJ1aWxkZXIgKSB7XHJcblxyXG5cdFx0Y29uc3Qgc2NvcGUgPSB0aGlzLnNjb3BlO1xyXG5cclxuXHRcdGlmICggc2NvcGUgPT09IE9iamVjdDNETm9kZS5XT1JMRF9NQVRSSVggKSB7XHJcblxyXG5cdFx0XHR0aGlzLl91bmlmb3JtTm9kZS5ub2RlVHlwZSA9ICdtYXQ0JztcclxuXHJcblx0XHR9IGVsc2UgaWYgKCBzY29wZSA9PT0gT2JqZWN0M0ROb2RlLlBPU0lUSU9OIHx8IHNjb3BlID09PSBPYmplY3QzRE5vZGUuVklFV19QT1NJVElPTiB8fCBzY29wZSA9PT0gT2JqZWN0M0ROb2RlLkRJUkVDVElPTiB8fCBzY29wZSA9PT0gT2JqZWN0M0ROb2RlLlNDQUxFICkge1xyXG5cclxuXHRcdFx0dGhpcy5fdW5pZm9ybU5vZGUubm9kZVR5cGUgPSAndmVjMyc7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzLl91bmlmb3JtTm9kZS5idWlsZCggYnVpbGRlciApO1xyXG5cclxuXHR9XHJcblxyXG5cdHNlcmlhbGl6ZSggZGF0YSApIHtcclxuXHJcblx0XHRzdXBlci5zZXJpYWxpemUoIGRhdGEgKTtcclxuXHJcblx0XHRkYXRhLnNjb3BlID0gdGhpcy5zY29wZTtcclxuXHJcblx0fVxyXG5cclxuXHRkZXNlcmlhbGl6ZSggZGF0YSApIHtcclxuXHJcblx0XHRzdXBlci5kZXNlcmlhbGl6ZSggZGF0YSApO1xyXG5cclxuXHRcdHRoaXMuc2NvcGUgPSBkYXRhLnNjb3BlO1xyXG5cclxuXHR9XHJcblxyXG59XHJcblxyXG5PYmplY3QzRE5vZGUuV09STERfTUFUUklYID0gJ3dvcmxkTWF0cml4JztcclxuT2JqZWN0M0ROb2RlLlBPU0lUSU9OID0gJ3Bvc2l0aW9uJztcclxuT2JqZWN0M0ROb2RlLlNDQUxFID0gJ3NjYWxlJztcclxuT2JqZWN0M0ROb2RlLlZJRVdfUE9TSVRJT04gPSAndmlld1Bvc2l0aW9uJztcclxuT2JqZWN0M0ROb2RlLkRJUkVDVElPTiA9ICdkaXJlY3Rpb24nO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgT2JqZWN0M0ROb2RlO1xyXG5cclxuZXhwb3J0IGNvbnN0IG9iamVjdERpcmVjdGlvbiA9IC8qQF9fUFVSRV9fKi8gbm9kZVByb3h5KCBPYmplY3QzRE5vZGUsIE9iamVjdDNETm9kZS5ESVJFQ1RJT04gKTtcclxuZXhwb3J0IGNvbnN0IG9iamVjdFdvcmxkTWF0cml4ID0gLypAX19QVVJFX18qLyBub2RlUHJveHkoIE9iamVjdDNETm9kZSwgT2JqZWN0M0ROb2RlLldPUkxEX01BVFJJWCApO1xyXG5leHBvcnQgY29uc3Qgb2JqZWN0UG9zaXRpb24gPSAvKkBfX1BVUkVfXyovIG5vZGVQcm94eSggT2JqZWN0M0ROb2RlLCBPYmplY3QzRE5vZGUuUE9TSVRJT04gKTtcclxuZXhwb3J0IGNvbnN0IG9iamVjdFNjYWxlID0gLypAX19QVVJFX18qLyBub2RlUHJveHkoIE9iamVjdDNETm9kZSwgT2JqZWN0M0ROb2RlLlNDQUxFICk7XHJcbmV4cG9ydCBjb25zdCBvYmplY3RWaWV3UG9zaXRpb24gPSAvKkBfX1BVUkVfXyovIG5vZGVQcm94eSggT2JqZWN0M0ROb2RlLCBPYmplY3QzRE5vZGUuVklFV19QT1NJVElPTiApO1xyXG4iLCJpbXBvcnQgT2JqZWN0M0ROb2RlIGZyb20gJy4vT2JqZWN0M0ROb2RlLmpzJztcclxuaW1wb3J0IHsgRm4sIG5vZGVJbW11dGFibGUgfSBmcm9tICcuLi90c2wvVFNMQmFzZS5qcyc7XHJcbmltcG9ydCB7IHVuaWZvcm0gfSBmcm9tICcuLi9jb3JlL1VuaWZvcm1Ob2RlLmpzJztcclxuXHJcbmltcG9ydCB7IE1hdHJpeDQgfSBmcm9tICcuLi8uLi9tYXRoL01hdHJpeDQuanMnO1xyXG5pbXBvcnQgeyBjYW1lcmFWaWV3TWF0cml4IH0gZnJvbSAnLi9DYW1lcmEuanMnO1xyXG5pbXBvcnQgeyBNYXRyaXgzIH0gZnJvbSAnLi4vLi4vbWF0aC9NYXRyaXgzLmpzJztcclxuXHJcbmNsYXNzIE1vZGVsTm9kZSBleHRlbmRzIE9iamVjdDNETm9kZSB7XHJcblxyXG5cdHN0YXRpYyBnZXQgdHlwZSgpIHtcclxuXHJcblx0XHRyZXR1cm4gJ01vZGVsTm9kZSc7XHJcblxyXG5cdH1cclxuXHJcblx0Y29uc3RydWN0b3IoIHNjb3BlICkge1xyXG5cclxuXHRcdHN1cGVyKCBzY29wZSApO1xyXG5cclxuXHR9XHJcblxyXG5cdHVwZGF0ZSggZnJhbWUgKSB7XHJcblxyXG5cdFx0dGhpcy5vYmplY3QzZCA9IGZyYW1lLm9iamVjdDtcclxuXHJcblx0XHRzdXBlci51cGRhdGUoIGZyYW1lICk7XHJcblxyXG5cdH1cclxuXHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IE1vZGVsTm9kZTtcclxuXHJcbmV4cG9ydCBjb25zdCBtb2RlbERpcmVjdGlvbiA9IC8qQF9fUFVSRV9fKi8gbm9kZUltbXV0YWJsZSggTW9kZWxOb2RlLCBNb2RlbE5vZGUuRElSRUNUSU9OICk7XHJcbmV4cG9ydCBjb25zdCBtb2RlbFdvcmxkTWF0cml4ID0gLypAX19QVVJFX18qLyBub2RlSW1tdXRhYmxlKCBNb2RlbE5vZGUsIE1vZGVsTm9kZS5XT1JMRF9NQVRSSVggKTtcclxuZXhwb3J0IGNvbnN0IG1vZGVsUG9zaXRpb24gPSAvKkBfX1BVUkVfXyovIG5vZGVJbW11dGFibGUoIE1vZGVsTm9kZSwgTW9kZWxOb2RlLlBPU0lUSU9OICk7XHJcbmV4cG9ydCBjb25zdCBtb2RlbFNjYWxlID0gLypAX19QVVJFX18qLyBub2RlSW1tdXRhYmxlKCBNb2RlbE5vZGUsIE1vZGVsTm9kZS5TQ0FMRSApO1xyXG5leHBvcnQgY29uc3QgbW9kZWxWaWV3UG9zaXRpb24gPSAvKkBfX1BVUkVfXyovIG5vZGVJbW11dGFibGUoIE1vZGVsTm9kZSwgTW9kZWxOb2RlLlZJRVdfUE9TSVRJT04gKTtcclxuZXhwb3J0IGNvbnN0IG1vZGVsTm9ybWFsTWF0cml4ID0gLypAX19QVVJFX18qLyB1bmlmb3JtKCBuZXcgTWF0cml4MygpICkub25PYmplY3RVcGRhdGUoICggeyBvYmplY3QgfSwgc2VsZiApID0+IHNlbGYudmFsdWUuZ2V0Tm9ybWFsTWF0cml4KCBvYmplY3QubWF0cml4V29ybGQgKSApO1xyXG5leHBvcnQgY29uc3QgbW9kZWxXb3JsZE1hdHJpeEludmVyc2UgPSAvKkBfX1BVUkVfXyovIHVuaWZvcm0oIG5ldyBNYXRyaXg0KCkgKS5vbk9iamVjdFVwZGF0ZSggKCB7IG9iamVjdCB9LCBzZWxmICkgPT4gc2VsZi52YWx1ZS5jb3B5KCBvYmplY3QubWF0cml4V29ybGQgKS5pbnZlcnQoKSApO1xyXG5cclxuZXhwb3J0IGNvbnN0IG1vZGVsVmlld01hdHJpeCA9IC8qQF9fUFVSRV9fKi8gKCBGbiggKCBidWlsZGVyICkgPT4ge1xyXG5cclxuXHRyZXR1cm4gYnVpbGRlci5yZW5kZXJlci5ub2Rlcy5tb2RlbFZpZXdNYXRyaXggfHwgbWVkaXVtcE1vZGVsVmlld01hdHJpeDtcclxuXHJcbn0gKS5vbmNlKCkgKSgpLnRvVmFyKCAnbW9kZWxWaWV3TWF0cml4JyApO1xyXG5cclxuLy8gR1BVIFByZWNpc2lvblxyXG5cclxuZXhwb3J0IGNvbnN0IG1lZGl1bXBNb2RlbFZpZXdNYXRyaXggPSAvKkBfX1BVUkVfXyovIGNhbWVyYVZpZXdNYXRyaXgubXVsKCBtb2RlbFdvcmxkTWF0cml4ICk7XHJcblxyXG4vLyBDUFUgUHJlY2lzaW9uXHJcblxyXG5leHBvcnQgY29uc3QgaGlnaHBNb2RlbFZpZXdNYXRyaXggPSAvKkBfX1BVUkVfXyovICggRm4oICggYnVpbGRlciApID0+IHtcclxuXHJcblx0YnVpbGRlci5jb250ZXh0LmlzSGlnaFByZWNpc2lvbk1vZGVsVmlld01hdHJpeCA9IHRydWU7XHJcblxyXG5cdHJldHVybiB1bmlmb3JtKCAnbWF0NCcgKS5vbk9iamVjdFVwZGF0ZSggKCB7IG9iamVjdCwgY2FtZXJhIH0gKSA9PiB7XHJcblxyXG5cdFx0cmV0dXJuIG9iamVjdC5tb2RlbFZpZXdNYXRyaXgubXVsdGlwbHlNYXRyaWNlcyggY2FtZXJhLm1hdHJpeFdvcmxkSW52ZXJzZSwgb2JqZWN0Lm1hdHJpeFdvcmxkICk7XHJcblxyXG5cdH0gKTtcclxuXHJcbn0gKS5vbmNlKCkgKSgpLnRvVmFyKCAnaGlnaHBNb2RlbFZpZXdNYXRyaXgnICk7XHJcblxyXG5leHBvcnQgY29uc3QgaGlnaHBNb2RlbE5vcm1hbFZpZXdNYXRyaXggPSAvKkBfX1BVUkVfXyovICggRm4oICggYnVpbGRlciApID0+IHtcclxuXHJcblx0Y29uc3QgaXNIaWdoUHJlY2lzaW9uTW9kZWxWaWV3TWF0cml4ID0gYnVpbGRlci5jb250ZXh0LmlzSGlnaFByZWNpc2lvbk1vZGVsVmlld01hdHJpeDtcclxuXHJcblx0cmV0dXJuIHVuaWZvcm0oICdtYXQzJyApLm9uT2JqZWN0VXBkYXRlKCAoIHsgb2JqZWN0LCBjYW1lcmEgfSApID0+IHtcclxuXHJcblx0XHRpZiAoIGlzSGlnaFByZWNpc2lvbk1vZGVsVmlld01hdHJpeCAhPT0gdHJ1ZSApIHtcclxuXHJcblx0XHRcdG9iamVjdC5tb2RlbFZpZXdNYXRyaXgubXVsdGlwbHlNYXRyaWNlcyggY2FtZXJhLm1hdHJpeFdvcmxkSW52ZXJzZSwgb2JqZWN0Lm1hdHJpeFdvcmxkICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBvYmplY3Qubm9ybWFsTWF0cml4LmdldE5vcm1hbE1hdHJpeCggb2JqZWN0Lm1vZGVsVmlld01hdHJpeCApO1xyXG5cclxuXHR9ICk7XHJcblxyXG59ICkub25jZSgpICkoKS50b1ZhciggJ2hpZ2hwTW9kZWxOb3JtYWxWaWV3TWF0cml4JyApO1xyXG4iLCJpbXBvcnQgeyBhdHRyaWJ1dGUgfSBmcm9tICcuLi9jb3JlL0F0dHJpYnV0ZU5vZGUuanMnO1xyXG5pbXBvcnQgeyBGbiB9IGZyb20gJy4uL3RzbC9UU0xDb3JlLmpzJztcclxuaW1wb3J0IHsgbW9kZWxXb3JsZE1hdHJpeCB9IGZyb20gJy4vTW9kZWxOb2RlLmpzJztcclxuXHJcbi8qKiBAbW9kdWxlIFBvc2l0aW9uICoqL1xyXG5cclxuLyoqXHJcbiAqIFRTTCBvYmplY3QgdGhhdCByZXByZXNlbnRzIHRoZSBwb3NpdGlvbiBhdHRyaWJ1dGUgb2YgdGhlIGN1cnJlbnQgcmVuZGVyZWQgb2JqZWN0LlxyXG4gKlxyXG4gKiBAdHlwZSB7QXR0cmlidXRlTm9kZTx2ZWMzPn1cclxuICovXHJcbmV4cG9ydCBjb25zdCBwb3NpdGlvbkdlb21ldHJ5ID0gLypAX19QVVJFX18qLyBhdHRyaWJ1dGUoICdwb3NpdGlvbicsICd2ZWMzJyApO1xyXG5cclxuLyoqXHJcbiAqIFRTTCBvYmplY3QgdGhhdCByZXByZXNlbnRzIHRoZSB2ZXJ0ZXggcG9zaXRpb24gaW4gbG9jYWwgc3BhY2Ugb2YgdGhlIGN1cnJlbnQgcmVuZGVyZWQgb2JqZWN0LlxyXG4gKlxyXG4gKiBAdHlwZSB7QXR0cmlidXRlTm9kZTx2ZWMzPn1cclxuICovXHJcbmV4cG9ydCBjb25zdCBwb3NpdGlvbkxvY2FsID0gLypAX19QVVJFX18qLyBwb3NpdGlvbkdlb21ldHJ5LnZhcnlpbmcoICdwb3NpdGlvbkxvY2FsJyApO1xyXG5cclxuLyoqXHJcbiAqIFRTTCBvYmplY3QgdGhhdCByZXByZXNlbnRzIHRoZSBwcmV2aW91cyB2ZXJ0ZXggcG9zaXRpb24gaW4gbG9jYWwgc3BhY2Ugb2YgdGhlIGN1cnJlbnQgcmVuZGVyZWQgb2JqZWN0LlxyXG4gKiBVc2VkIGluIGNvbnRleHQgb2Yge0BsaW5rIG1vZHVsZTpWZWxvY2l0eU5vZGV+VmVsb2NpdHlOb2RlfSBmb3IgcmVuZGVyaW5nIG1vdGlvbiB2ZWN0b3JzLlxyXG4gKlxyXG4gKiBAdHlwZSB7QXR0cmlidXRlTm9kZTx2ZWMzPn1cclxuICovXHJcbmV4cG9ydCBjb25zdCBwb3NpdGlvblByZXZpb3VzID0gLypAX19QVVJFX18qLyBwb3NpdGlvbkdlb21ldHJ5LnZhcnlpbmcoICdwb3NpdGlvblByZXZpb3VzJyApO1xyXG5cclxuLyoqXHJcbiAqIFRTTCBvYmplY3QgdGhhdCByZXByZXNlbnRzIHRoZSB2ZXJ0ZXggcG9zaXRpb24gaW4gd29ybGQgc3BhY2Ugb2YgdGhlIGN1cnJlbnQgcmVuZGVyZWQgb2JqZWN0LlxyXG4gKlxyXG4gKiBAdHlwZSB7VmFyeWluZ05vZGU8dmVjMz59XHJcbiAqL1xyXG5leHBvcnQgY29uc3QgcG9zaXRpb25Xb3JsZCA9IC8qQF9fUFVSRV9fKi8gbW9kZWxXb3JsZE1hdHJpeC5tdWwoIHBvc2l0aW9uTG9jYWwgKS54eXoudmFyeWluZyggJ3ZfcG9zaXRpb25Xb3JsZCcgKS5jb250ZXh0KCB7IG5lZWRzUG9zaXRpb25SZWFzc2lnbjogdHJ1ZSB9ICk7XHJcblxyXG4vKipcclxuICogVFNMIG9iamVjdCB0aGF0IHJlcHJlc2VudHMgdGhlIHBvc2l0aW9uIHdvcmxkIGRpcmVjdGlvbiBvZiB0aGUgY3VycmVudCByZW5kZXJlZCBvYmplY3QuXHJcbiAqXHJcbiAqIEB0eXBlIHtOb2RlPHZlYzM+fVxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IHBvc2l0aW9uV29ybGREaXJlY3Rpb24gPSAvKkBfX1BVUkVfXyovIHBvc2l0aW9uTG9jYWwudHJhbnNmb3JtRGlyZWN0aW9uKCBtb2RlbFdvcmxkTWF0cml4ICkudmFyeWluZyggJ3ZfcG9zaXRpb25Xb3JsZERpcmVjdGlvbicgKS5ub3JtYWxpemUoKS50b1ZhciggJ3Bvc2l0aW9uV29ybGREaXJlY3Rpb24nICkuY29udGV4dCggeyBuZWVkc1Bvc2l0aW9uUmVhc3NpZ246IHRydWUgfSApO1xyXG5cclxuLyoqXHJcbiAqIFRTTCBvYmplY3QgdGhhdCByZXByZXNlbnRzIHRoZSB2ZXJ0ZXggcG9zaXRpb24gaW4gdmlldyBzcGFjZSBvZiB0aGUgY3VycmVudCByZW5kZXJlZCBvYmplY3QuXHJcbiAqXHJcbiAqIEB0eXBlIHtWYXJ5aW5nTm9kZTx2ZWMzPn1cclxuICovXHJcbmV4cG9ydCBjb25zdCBwb3NpdGlvblZpZXcgPSAvKkBfX1BVUkVfXyovICggRm4oICggYnVpbGRlciApID0+IHtcclxuXHJcblx0cmV0dXJuIGJ1aWxkZXIuY29udGV4dC5zZXR1cFBvc2l0aW9uVmlldygpO1xyXG5cclxufSwgJ3ZlYzMnICkub25jZSgpICkoKS52YXJ5aW5nKCAndl9wb3NpdGlvblZpZXcnICkuY29udGV4dCggeyBuZWVkc1Bvc2l0aW9uUmVhc3NpZ246IHRydWUgfSApO1xyXG5cclxuLyoqXHJcbiAqIFRTTCBvYmplY3QgdGhhdCByZXByZXNlbnRzIHRoZSBwb3NpdGlvbiB2aWV3IGRpcmVjdGlvbiBvZiB0aGUgY3VycmVudCByZW5kZXJlZCBvYmplY3QuXHJcbiAqXHJcbiAqIEB0eXBlIHtWYXJ5aW5nTm9kZTx2ZWMzPn1cclxuICovXHJcbmV4cG9ydCBjb25zdCBwb3NpdGlvblZpZXdEaXJlY3Rpb24gPSAvKkBfX1BVUkVfXyovIHBvc2l0aW9uVmlldy5uZWdhdGUoKS52YXJ5aW5nKCAndl9wb3NpdGlvblZpZXdEaXJlY3Rpb24nICkubm9ybWFsaXplKCkudG9WYXIoICdwb3NpdGlvblZpZXdEaXJlY3Rpb24nICk7XHJcbiIsImltcG9ydCBOb2RlIGZyb20gJy4uL2NvcmUvTm9kZS5qcyc7XHJcbmltcG9ydCB7IG5vZGVJbW11dGFibGUsIGZsb2F0IH0gZnJvbSAnLi4vdHNsL1RTTEJhc2UuanMnO1xyXG5cclxuaW1wb3J0IHsgQmFja1NpZGUsIFdlYkdMQ29vcmRpbmF0ZVN5c3RlbSB9IGZyb20gJy4uLy4uL2NvbnN0YW50cy5qcyc7XHJcblxyXG4vKiogQG1vZHVsZSBGcm9udEZhY2luZ05vZGUgKiovXHJcblxyXG4vKipcclxuICogVGhpcyBub2RlIGNhbiBiZSB1c2VkIHRvIGV2YWx1YXRlIHdoZXRoZXIgYSBwcmltaXRpdmUgaXMgZnJvbnQgb3IgYmFjayBmYWNpbmcuXHJcbiAqXHJcbiAqIEBhdWdtZW50cyBOb2RlXHJcbiAqL1xyXG5jbGFzcyBGcm9udEZhY2luZ05vZGUgZXh0ZW5kcyBOb2RlIHtcclxuXHJcblx0c3RhdGljIGdldCB0eXBlKCkge1xyXG5cclxuXHRcdHJldHVybiAnRnJvbnRGYWNpbmdOb2RlJztcclxuXHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBDb25zdHJ1Y3RzIGEgbmV3IGZyb250IGZhY2luZyBub2RlLlxyXG5cdCAqL1xyXG5cdGNvbnN0cnVjdG9yKCkge1xyXG5cclxuXHRcdHN1cGVyKCAnYm9vbCcgKTtcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIFRoaXMgZmxhZyBjYW4gYmUgdXNlZCBmb3IgdHlwZSB0ZXN0aW5nLlxyXG5cdFx0ICpcclxuXHRcdCAqIEB0eXBlIHtCb29sZWFufVxyXG5cdFx0ICogQHJlYWRvbmx5XHJcblx0XHQgKiBAZGVmYXVsdCB0cnVlXHJcblx0XHQgKi9cclxuXHRcdHRoaXMuaXNGcm9udEZhY2luZ05vZGUgPSB0cnVlO1xyXG5cclxuXHR9XHJcblxyXG5cdGdlbmVyYXRlKCBidWlsZGVyICkge1xyXG5cclxuXHRcdGNvbnN0IHsgcmVuZGVyZXIsIG1hdGVyaWFsIH0gPSBidWlsZGVyO1xyXG5cclxuXHRcdGlmICggcmVuZGVyZXIuY29vcmRpbmF0ZVN5c3RlbSA9PT0gV2ViR0xDb29yZGluYXRlU3lzdGVtICkge1xyXG5cclxuXHRcdFx0aWYgKCBtYXRlcmlhbC5zaWRlID09PSBCYWNrU2lkZSApIHtcclxuXHJcblx0XHRcdFx0cmV0dXJuICdmYWxzZSc7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBidWlsZGVyLmdldEZyb250RmFjaW5nKCk7XHJcblxyXG5cdH1cclxuXHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IEZyb250RmFjaW5nTm9kZTtcclxuXHJcbi8qKlxyXG4gKiBUU0wgb2JqZWN0IHRoYXQgcmVwcmVzZW50cyB3aGV0aGVyIGEgcHJpbWl0aXZlIGlzIGZyb250IG9yIGJhY2sgZmFjaW5nXHJcbiAqXHJcbiAqIEB0eXBlIHtGcm9udEZhY2luZ05vZGU8Ym9vbD59XHJcbiAqL1xyXG5leHBvcnQgY29uc3QgZnJvbnRGYWNpbmcgPSAvKkBfX1BVUkVfXyovIG5vZGVJbW11dGFibGUoIEZyb250RmFjaW5nTm9kZSApO1xyXG5cclxuLyoqXHJcbiAqIFRTTCBvYmplY3QgdGhhdCByZXByZXNlbnRzIHRoZSBmcm9udCBmYWNpbmcgc3RhdHVzIGFzIGEgbnVtYmVyIGluc3RlYWQgb2YgYSBib29sLlxyXG4gKiBgMWAgbWVhbnMgZnJvbnQgZmFjaW5nLCBgLTFgIG1lYW5zIGJhY2sgZmFjaW5nLlxyXG4gKlxyXG4gKiBAdHlwZSB7Tm9kZTxmbG9hdD59XHJcbiAqL1xyXG5leHBvcnQgY29uc3QgZmFjZURpcmVjdGlvbiA9IC8qQF9fUFVSRV9fKi8gZmxvYXQoIGZyb250RmFjaW5nICkubXVsKCAyLjAgKS5zdWIoIDEuMCApO1xyXG4iLCJpbXBvcnQgeyBhdHRyaWJ1dGUgfSBmcm9tICcuLi9jb3JlL0F0dHJpYnV0ZU5vZGUuanMnO1xyXG5pbXBvcnQgeyBjYW1lcmFWaWV3TWF0cml4IH0gZnJvbSAnLi9DYW1lcmEuanMnO1xyXG5pbXBvcnQgeyBtb2RlbE5vcm1hbE1hdHJpeCwgbW9kZWxXb3JsZE1hdHJpeCB9IGZyb20gJy4vTW9kZWxOb2RlLmpzJztcclxuaW1wb3J0IHsgbWF0MywgdmVjMywgRm4sIHZhcnlpbmcgfSBmcm9tICcuLi90c2wvVFNMQmFzZS5qcyc7XHJcbmltcG9ydCB7IHBvc2l0aW9uVmlldyB9IGZyb20gJy4vUG9zaXRpb24uanMnO1xyXG5pbXBvcnQgeyBmYWNlRGlyZWN0aW9uIH0gZnJvbSAnLi4vZGlzcGxheS9Gcm9udEZhY2luZ05vZGUuanMnO1xyXG5cclxuLyoqIEBtb2R1bGUgTm9ybWFsICoqL1xyXG5cclxuLyoqXHJcbiAqIFRTTCBvYmplY3QgdGhhdCByZXByZXNlbnRzIHRoZSBub3JtYWwgYXR0cmlidXRlIG9mIHRoZSBjdXJyZW50IHJlbmRlcmVkIG9iamVjdC5cclxuICpcclxuICogQHR5cGUge05vZGU8dmVjMz59XHJcbiAqL1xyXG5leHBvcnQgY29uc3Qgbm9ybWFsR2VvbWV0cnkgPSAvKkBfX1BVUkVfXyovIGF0dHJpYnV0ZSggJ25vcm1hbCcsICd2ZWMzJyApO1xyXG5cclxuLyoqXHJcbiAqIFRTTCBvYmplY3QgdGhhdCByZXByZXNlbnRzIHRoZSB2ZXJ0ZXggbm9ybWFsIGluIGxvY2FsIHNwYWNlIG9mIHRoZSBjdXJyZW50IHJlbmRlcmVkIG9iamVjdC5cclxuICpcclxuICogQHR5cGUge05vZGU8dmVjMz59XHJcbiAqL1xyXG5leHBvcnQgY29uc3Qgbm9ybWFsTG9jYWwgPSAvKkBfX1BVUkVfXyovICggRm4oICggYnVpbGRlciApID0+IHtcclxuXHJcblx0aWYgKCBidWlsZGVyLmdlb21ldHJ5Lmhhc0F0dHJpYnV0ZSggJ25vcm1hbCcgKSA9PT0gZmFsc2UgKSB7XHJcblxyXG5cdFx0Y29uc29sZS53YXJuKCAnVFNMLk5vcm1hbE5vZGU6IFZlcnRleCBhdHRyaWJ1dGUgXCJub3JtYWxcIiBub3QgZm91bmQgb24gZ2VvbWV0cnkuJyApO1xyXG5cclxuXHRcdHJldHVybiB2ZWMzKCAwLCAxLCAwICk7XHJcblxyXG5cdH1cclxuXHJcblx0cmV0dXJuIG5vcm1hbEdlb21ldHJ5O1xyXG5cclxufSwgJ3ZlYzMnICkub25jZSgpICkoKS50b1ZhciggJ25vcm1hbExvY2FsJyApO1xyXG5cclxuLyoqXHJcbiAqIFRTTCBvYmplY3QgdGhhdCByZXByZXNlbnRzIHRoZSBmbGF0IHZlcnRleCBub3JtYWwgaW4gdmlldyBzcGFjZSBvZiB0aGUgY3VycmVudCByZW5kZXJlZCBvYmplY3QuXHJcbiAqXHJcbiAqIEB0eXBlIHtOb2RlPHZlYzM+fVxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IG5vcm1hbEZsYXQgPSAvKkBfX1BVUkVfXyovIHBvc2l0aW9uVmlldy5kRmR4KCkuY3Jvc3MoIHBvc2l0aW9uVmlldy5kRmR5KCkgKS5ub3JtYWxpemUoKS50b1ZhciggJ25vcm1hbEZsYXQnICk7XHJcblxyXG4vKipcclxuICogVFNMIG9iamVjdCB0aGF0IHJlcHJlc2VudHMgdGhlIHZlcnRleCBub3JtYWwgaW4gdmlldyBzcGFjZSBvZiB0aGUgY3VycmVudCByZW5kZXJlZCBvYmplY3QuXHJcbiAqXHJcbiAqIEB0eXBlIHtOb2RlPHZlYzM+fVxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IG5vcm1hbFZpZXcgPSAvKkBfX1BVUkVfXyovICggRm4oICggYnVpbGRlciApID0+IHtcclxuXHJcblx0bGV0IG5vZGU7XHJcblxyXG5cdGlmICggYnVpbGRlci5tYXRlcmlhbC5mbGF0U2hhZGluZyA9PT0gdHJ1ZSApIHtcclxuXHJcblx0XHRub2RlID0gbm9ybWFsRmxhdDtcclxuXHJcblx0fSBlbHNlIHtcclxuXHJcblx0XHRub2RlID0gdmFyeWluZyggdHJhbnNmb3JtTm9ybWFsVG9WaWV3KCBub3JtYWxMb2NhbCApLCAndl9ub3JtYWxWaWV3JyApLm5vcm1hbGl6ZSgpO1xyXG5cclxuXHR9XHJcblxyXG5cdHJldHVybiBub2RlO1xyXG5cclxufSwgJ3ZlYzMnICkub25jZSgpICkoKS50b1ZhciggJ25vcm1hbFZpZXcnICk7XHJcblxyXG4vKipcclxuICogVFNMIG9iamVjdCB0aGF0IHJlcHJlc2VudHMgdGhlIHZlcnRleCBub3JtYWwgaW4gd29ybGQgc3BhY2Ugb2YgdGhlIGN1cnJlbnQgcmVuZGVyZWQgb2JqZWN0LlxyXG4gKlxyXG4gKiBAdHlwZSB7Tm9kZTx2ZWMzPn1cclxuICovXHJcbmV4cG9ydCBjb25zdCBub3JtYWxXb3JsZCA9IC8qQF9fUFVSRV9fKi8gdmFyeWluZyggbm9ybWFsVmlldy50cmFuc2Zvcm1EaXJlY3Rpb24oIGNhbWVyYVZpZXdNYXRyaXggKSwgJ3Zfbm9ybWFsV29ybGQnICkubm9ybWFsaXplKCkudG9WYXIoICdub3JtYWxXb3JsZCcgKTtcclxuXHJcbi8qKlxyXG4gKiBUU0wgb2JqZWN0IHRoYXQgcmVwcmVzZW50cyB0aGUgdHJhbnNmb3JtZWQgdmVydGV4IG5vcm1hbCBpbiB2aWV3IHNwYWNlIG9mIHRoZSBjdXJyZW50IHJlbmRlcmVkIG9iamVjdC5cclxuICpcclxuICogQHR5cGUge05vZGU8dmVjMz59XHJcbiAqL1xyXG5leHBvcnQgY29uc3QgdHJhbnNmb3JtZWROb3JtYWxWaWV3ID0gLypAX19QVVJFX18qLyAoIEZuKCAoIGJ1aWxkZXIgKSA9PiB7XHJcblxyXG5cdHJldHVybiBidWlsZGVyLmNvbnRleHQuc2V0dXBOb3JtYWwoKTtcclxuXHJcbn0sICd2ZWMzJyApLm9uY2UoKSApKCkubXVsKCBmYWNlRGlyZWN0aW9uICkudG9WYXIoICd0cmFuc2Zvcm1lZE5vcm1hbFZpZXcnICk7XHJcblxyXG4vKipcclxuICogVFNMIG9iamVjdCB0aGF0IHJlcHJlc2VudHMgdGhlIHRyYW5zZm9ybWVkIHZlcnRleCBub3JtYWwgaW4gd29ybGQgc3BhY2Ugb2YgdGhlIGN1cnJlbnQgcmVuZGVyZWQgb2JqZWN0LlxyXG4gKlxyXG4gKiBAdHlwZSB7Tm9kZTx2ZWMzPn1cclxuICovXHJcbmV4cG9ydCBjb25zdCB0cmFuc2Zvcm1lZE5vcm1hbFdvcmxkID0gLypAX19QVVJFX18qLyB0cmFuc2Zvcm1lZE5vcm1hbFZpZXcudHJhbnNmb3JtRGlyZWN0aW9uKCBjYW1lcmFWaWV3TWF0cml4ICkudG9WYXIoICd0cmFuc2Zvcm1lZE5vcm1hbFdvcmxkJyApO1xyXG5cclxuLyoqXHJcbiAqIFRTTCBvYmplY3QgdGhhdCByZXByZXNlbnRzIHRoZSB0cmFuc2Zvcm1lZCBjbGVhcmNvYXQgdmVydGV4IG5vcm1hbCBpbiB2aWV3IHNwYWNlIG9mIHRoZSBjdXJyZW50IHJlbmRlcmVkIG9iamVjdC5cclxuICpcclxuICogQHR5cGUge05vZGU8dmVjMz59XHJcbiAqL1xyXG5leHBvcnQgY29uc3QgdHJhbnNmb3JtZWRDbGVhcmNvYXROb3JtYWxWaWV3ID0gLypAX19QVVJFX18qLyAoIEZuKCAoIGJ1aWxkZXIgKSA9PiB7XHJcblxyXG5cdHJldHVybiBidWlsZGVyLmNvbnRleHQuc2V0dXBDbGVhcmNvYXROb3JtYWwoKTtcclxuXHJcbn0sICd2ZWMzJyApLm9uY2UoKSApKCkubXVsKCBmYWNlRGlyZWN0aW9uICkudG9WYXIoICd0cmFuc2Zvcm1lZENsZWFyY29hdE5vcm1hbFZpZXcnICk7XHJcblxyXG4vKipcclxuICogVHJhbnNmb3JtcyB0aGUgbm9ybWFsIHdpdGggdGhlIGdpdmVuIG1hdHJpeC5cclxuICpcclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7Tm9kZTx2ZWMzPn0gbm9ybWFsIC0gVGhlIG5vcm1hbC5cclxuICogQHBhcmFtIHtOb2RlPG1hdDM+fSBbbWF0cml4PW1vZGVsV29ybGRNYXRyaXhdIC0gVGhlIG1hdHJpeC5cclxuICogQHJldHVybiB7Tm9kZTx2ZWMzPn0gVGhlIHRyYW5zZm9ybWVkIG5vcm1hbC5cclxuICovXHJcbmV4cG9ydCBjb25zdCB0cmFuc2Zvcm1Ob3JtYWwgPSAvKkBfX1BVUkVfXyovIEZuKCAoIFsgbm9ybWFsLCBtYXRyaXggPSBtb2RlbFdvcmxkTWF0cml4IF0gKSA9PiB7XHJcblxyXG5cdGNvbnN0IG0gPSBtYXQzKCBtYXRyaXggKTtcclxuXHJcblx0Y29uc3QgdHJhbnNmb3JtZWROb3JtYWwgPSBub3JtYWwuZGl2KCB2ZWMzKCBtWyAwIF0uZG90KCBtWyAwIF0gKSwgbVsgMSBdLmRvdCggbVsgMSBdICksIG1bIDIgXS5kb3QoIG1bIDIgXSApICkgKTtcclxuXHJcblx0cmV0dXJuIG0ubXVsKCB0cmFuc2Zvcm1lZE5vcm1hbCApLnh5ejtcclxuXHJcbn0gKTtcclxuXHJcbi8qKlxyXG4gKiBUcmFuc2Zvcm1zIHRoZSBnaXZlbiBub3JtYWwgZnJvbSBsb2NhbCB0byB2aWV3IHNwYWNlLlxyXG4gKlxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHtOb2RlPHZlYzM+fSBub3JtYWwgLSBUaGUgbm9ybWFsLlxyXG4gKiBAcGFyYW0ge05vZGVCdWlsZGVyfSBidWlsZGVyIC0gVGhlIGN1cnJlbnQgbm9kZSBidWlsZGVyLlxyXG4gKiBAcmV0dXJuIHtOb2RlPHZlYzM+fSBUaGUgdHJhbnNmb3JtZWQgbm9ybWFsLlxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IHRyYW5zZm9ybU5vcm1hbFRvVmlldyA9IC8qQF9fUFVSRV9fKi8gRm4oICggWyBub3JtYWwgXSwgYnVpbGRlciApID0+IHtcclxuXHJcblx0Y29uc3QgbW9kZWxOb3JtYWxWaWV3TWF0cml4ID0gYnVpbGRlci5yZW5kZXJlci5ub2Rlcy5tb2RlbE5vcm1hbFZpZXdNYXRyaXg7XHJcblxyXG5cdGlmICggbW9kZWxOb3JtYWxWaWV3TWF0cml4ICE9PSBudWxsICkge1xyXG5cclxuXHRcdHJldHVybiBtb2RlbE5vcm1hbFZpZXdNYXRyaXgudHJhbnNmb3JtRGlyZWN0aW9uKCBub3JtYWwgKTtcclxuXHJcblx0fVxyXG5cclxuXHQvL1xyXG5cclxuXHRjb25zdCB0cmFuc2Zvcm1lZE5vcm1hbCA9IG1vZGVsTm9ybWFsTWF0cml4Lm11bCggbm9ybWFsICk7XHJcblxyXG5cdHJldHVybiBjYW1lcmFWaWV3TWF0cml4LnRyYW5zZm9ybURpcmVjdGlvbiggdHJhbnNmb3JtZWROb3JtYWwgKTtcclxuXHJcbn0gKTtcclxuIiwiaW1wb3J0IHsgdW5pZm9ybSB9IGZyb20gJy4uL2NvcmUvVW5pZm9ybU5vZGUuanMnO1xyXG5cclxuZXhwb3J0IGNvbnN0IG1hdGVyaWFsUmVmcmFjdGlvblJhdGlvID0gLypAX19QVVJFX18qLyB1bmlmb3JtKCAwICkub25SZWZlcmVuY2UoICggeyBtYXRlcmlhbCB9ICkgPT4gbWF0ZXJpYWwgKS5vblJlbmRlclVwZGF0ZSggKCB7IG1hdGVyaWFsIH0gKSA9PiBtYXRlcmlhbC5yZWZyYWN0aW9uUmF0aW8gKTtcclxuIiwiaW1wb3J0IHsgY2FtZXJhVmlld01hdHJpeCB9IGZyb20gJy4vQ2FtZXJhLmpzJztcclxuaW1wb3J0IHsgdHJhbnNmb3JtZWROb3JtYWxWaWV3IH0gZnJvbSAnLi9Ob3JtYWwuanMnO1xyXG5pbXBvcnQgeyBwb3NpdGlvblZpZXdEaXJlY3Rpb24gfSBmcm9tICcuL1Bvc2l0aW9uLmpzJztcclxuaW1wb3J0IHsgbWF0ZXJpYWxSZWZyYWN0aW9uUmF0aW8gfSBmcm9tICcuL01hdGVyaWFsUHJvcGVydGllcy5qcyc7XHJcblxyXG5leHBvcnQgY29uc3QgcmVmbGVjdFZpZXcgPSAvKkBfX1BVUkVfXyovIHBvc2l0aW9uVmlld0RpcmVjdGlvbi5uZWdhdGUoKS5yZWZsZWN0KCB0cmFuc2Zvcm1lZE5vcm1hbFZpZXcgKTtcclxuZXhwb3J0IGNvbnN0IHJlZnJhY3RWaWV3ID0gLypAX19QVVJFX18qLyBwb3NpdGlvblZpZXdEaXJlY3Rpb24ubmVnYXRlKCkucmVmcmFjdCggdHJhbnNmb3JtZWROb3JtYWxWaWV3LCBtYXRlcmlhbFJlZnJhY3Rpb25SYXRpbyApO1xyXG5cclxuZXhwb3J0IGNvbnN0IHJlZmxlY3RWZWN0b3IgPSAvKkBfX1BVUkVfXyovIHJlZmxlY3RWaWV3LnRyYW5zZm9ybURpcmVjdGlvbiggY2FtZXJhVmlld01hdHJpeCApLnRvVmFyKCAncmVmbGVjdFZlY3RvcicgKTtcclxuZXhwb3J0IGNvbnN0IHJlZnJhY3RWZWN0b3IgPSAvKkBfX1BVUkVfXyovIHJlZnJhY3RWaWV3LnRyYW5zZm9ybURpcmVjdGlvbiggY2FtZXJhVmlld01hdHJpeCApLnRvVmFyKCAncmVmbGVjdFZlY3RvcicgKTtcclxuIiwiaW1wb3J0IFRleHR1cmVOb2RlIGZyb20gJy4vVGV4dHVyZU5vZGUuanMnO1xyXG5pbXBvcnQgeyByZWZsZWN0VmVjdG9yLCByZWZyYWN0VmVjdG9yIH0gZnJvbSAnLi9SZWZsZWN0VmVjdG9yLmpzJztcclxuaW1wb3J0IHsgbm9kZVByb3h5LCB2ZWMzIH0gZnJvbSAnLi4vdHNsL1RTTEJhc2UuanMnO1xyXG5cclxuaW1wb3J0IHsgQ3ViZVJlZmxlY3Rpb25NYXBwaW5nLCBDdWJlUmVmcmFjdGlvbk1hcHBpbmcsIFdlYkdQVUNvb3JkaW5hdGVTeXN0ZW0gfSBmcm9tICcuLi8uLi9jb25zdGFudHMuanMnO1xyXG5cclxuY2xhc3MgQ3ViZVRleHR1cmVOb2RlIGV4dGVuZHMgVGV4dHVyZU5vZGUge1xyXG5cclxuXHRzdGF0aWMgZ2V0IHR5cGUoKSB7XHJcblxyXG5cdFx0cmV0dXJuICdDdWJlVGV4dHVyZU5vZGUnO1xyXG5cclxuXHR9XHJcblxyXG5cdGNvbnN0cnVjdG9yKCB2YWx1ZSwgdXZOb2RlID0gbnVsbCwgbGV2ZWxOb2RlID0gbnVsbCwgYmlhc05vZGUgPSBudWxsICkge1xyXG5cclxuXHRcdHN1cGVyKCB2YWx1ZSwgdXZOb2RlLCBsZXZlbE5vZGUsIGJpYXNOb2RlICk7XHJcblxyXG5cdFx0dGhpcy5pc0N1YmVUZXh0dXJlTm9kZSA9IHRydWU7XHJcblxyXG5cdH1cclxuXHJcblx0Z2V0SW5wdXRUeXBlKCAvKmJ1aWxkZXIqLyApIHtcclxuXHJcblx0XHRyZXR1cm4gJ2N1YmVUZXh0dXJlJztcclxuXHJcblx0fVxyXG5cclxuXHRnZXREZWZhdWx0VVYoKSB7XHJcblxyXG5cdFx0Y29uc3QgdGV4dHVyZSA9IHRoaXMudmFsdWU7XHJcblxyXG5cdFx0aWYgKCB0ZXh0dXJlLm1hcHBpbmcgPT09IEN1YmVSZWZsZWN0aW9uTWFwcGluZyApIHtcclxuXHJcblx0XHRcdHJldHVybiByZWZsZWN0VmVjdG9yO1xyXG5cclxuXHRcdH0gZWxzZSBpZiAoIHRleHR1cmUubWFwcGluZyA9PT0gQ3ViZVJlZnJhY3Rpb25NYXBwaW5nICkge1xyXG5cclxuXHRcdFx0cmV0dXJuIHJlZnJhY3RWZWN0b3I7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5DdWJlVGV4dHVyZU5vZGU6IE1hcHBpbmcgXCIlc1wiIG5vdCBzdXBwb3J0ZWQuJywgdGV4dHVyZS5tYXBwaW5nICk7XHJcblxyXG5cdFx0XHRyZXR1cm4gdmVjMyggMCwgMCwgMCApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHRzZXRVcGRhdGVNYXRyaXgoIC8qdXBkYXRlTWF0cml4Ki8gKSB7IH0gLy8gSWdub3JlIC51cGRhdGVNYXRyaXggZm9yIEN1YmVUZXh0dXJlTm9kZVxyXG5cclxuXHRzZXR1cFVWKCBidWlsZGVyLCB1dk5vZGUgKSB7XHJcblxyXG5cdFx0Y29uc3QgdGV4dHVyZSA9IHRoaXMudmFsdWU7XHJcblxyXG5cdFx0aWYgKCBidWlsZGVyLnJlbmRlcmVyLmNvb3JkaW5hdGVTeXN0ZW0gPT09IFdlYkdQVUNvb3JkaW5hdGVTeXN0ZW0gfHwgISB0ZXh0dXJlLmlzUmVuZGVyVGFyZ2V0VGV4dHVyZSApIHtcclxuXHJcblx0XHRcdHJldHVybiB2ZWMzKCB1dk5vZGUueC5uZWdhdGUoKSwgdXZOb2RlLnl6ICk7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdHJldHVybiB1dk5vZGU7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdGdlbmVyYXRlVVYoIGJ1aWxkZXIsIGN1YmVVViApIHtcclxuXHJcblx0XHRyZXR1cm4gY3ViZVVWLmJ1aWxkKCBidWlsZGVyLCAndmVjMycgKTtcclxuXHJcblx0fVxyXG5cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgQ3ViZVRleHR1cmVOb2RlO1xyXG5cclxuZXhwb3J0IGNvbnN0IGN1YmVUZXh0dXJlID0gLypAX19QVVJFX18qLyBub2RlUHJveHkoIEN1YmVUZXh0dXJlTm9kZSApO1xyXG4iLCJpbXBvcnQgVW5pZm9ybU5vZGUgZnJvbSAnLi4vY29yZS9Vbmlmb3JtTm9kZS5qcyc7XHJcbmltcG9ydCB7IG5vZGVPYmplY3QgfSBmcm9tICcuLi90c2wvVFNMQmFzZS5qcyc7XHJcblxyXG4vKiogQG1vZHVsZSBCdWZmZXJOb2RlICoqL1xyXG5cclxuLyoqXHJcbiAqIEEgc3BlY2lhbCB0eXBlIG9mIHVuaWZvcm0gbm9kZSB3aGljaCByZXByZXNlbnRzIGFycmF5LWxpa2UgZGF0YVxyXG4gKiBhcyB1bmlmb3JtIGJ1ZmZlcnMuIFRoZSBhY2Nlc3MgdXN1YWxseSBoYXBwZW5zIHZpYSBgZWxlbWVudCgpYFxyXG4gKiB3aGljaCByZXR1cm5zIGFuIGluc3RhbmNlIG9mIHtAbGluayBBcnJheUVsZW1lbnROb2RlfS4gRm9yIGV4YW1wbGU6XHJcbiAqXHJcbiAqIGBgYGpzXHJcbiAqIGNvbnN0IGJ1ZmZlck5vZGUgPSBidWZmZXIoIGFycmF5LCAnbWF0NCcsIGNvdW50ICk7XHJcbiAqIGNvbnN0IG1hdHJpeE5vZGUgPSBidWZmZXJOb2RlLmVsZW1lbnQoIGluZGV4ICk7IC8vIGFjY2VzcyBhIG1hdHJpeCBmcm9tIHRoZSBidWZmZXJcclxuICogYGBgXHJcbiAqIEluIGdlbmVyYWwsIGl0IGlzIHJlY29tbWVuZWQgdG8gdXNlIHRoZSBtb3JlIG1hbmFnZWQge0BsaW5rIFVuaWZvcm1BcnJheU5vZGV9XHJcbiAqIHNpbmNlIGl0IGhhbmRsZXMgbW9yZSBpbnB1dCB0eXBlcyBhbmQgYXV0b21hdGljYWxseSBjYXJlcyBhYm91dCBidWZmZXIgcGFkZGluZ3MuXHJcbiAqXHJcbiAqIEBhdWdtZW50cyBtb2R1bGU6VW5pZm9ybU5vZGV+VW5pZm9ybU5vZGVcclxuICovXHJcbmNsYXNzIEJ1ZmZlck5vZGUgZXh0ZW5kcyBVbmlmb3JtTm9kZSB7XHJcblxyXG5cdHN0YXRpYyBnZXQgdHlwZSgpIHtcclxuXHJcblx0XHRyZXR1cm4gJ0J1ZmZlck5vZGUnO1xyXG5cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIENvbnN0cnVjdHMgYSBuZXcgYnVmZmVyIG5vZGUuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge0FycmF5PE51bWJlcj59IHZhbHVlIC0gQXJyYXktbGlrZSBidWZmZXIgZGF0YS5cclxuXHQgKiBAcGFyYW0ge1N0cmluZ30gYnVmZmVyVHlwZSAtIFRoZSBkYXRhIHR5cGUgb2YgdGhlIGJ1ZmZlci5cclxuXHQgKiBAcGFyYW0ge051bWJlcn0gW2J1ZmZlckNvdW50PTBdIC0gVGhlIGNvdW50IG9mIGJ1ZmZlciBlbGVtZW50cy5cclxuXHQgKi9cclxuXHRjb25zdHJ1Y3RvciggdmFsdWUsIGJ1ZmZlclR5cGUsIGJ1ZmZlckNvdW50ID0gMCApIHtcclxuXHJcblx0XHRzdXBlciggdmFsdWUsIGJ1ZmZlclR5cGUgKTtcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIFRoaXMgZmxhZyBjYW4gYmUgdXNlZCBmb3IgdHlwZSB0ZXN0aW5nLlxyXG5cdFx0ICpcclxuXHRcdCAqIEB0eXBlIHtCb29sZWFufVxyXG5cdFx0ICogQHJlYWRvbmx5XHJcblx0XHQgKiBAZGVmYXVsdCB0cnVlXHJcblx0XHQgKi9cclxuXHRcdHRoaXMuaXNCdWZmZXJOb2RlID0gdHJ1ZTtcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIFRoZSBkYXRhIHR5cGUgb2YgdGhlIGJ1ZmZlci5cclxuXHRcdCAqXHJcblx0XHQgKiBAdHlwZSB7U3RyaW5nfVxyXG5cdFx0ICovXHJcblx0XHR0aGlzLmJ1ZmZlclR5cGUgPSBidWZmZXJUeXBlO1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogVGhlIHVuaWZvcm0gbm9kZSB0aGF0IGhvbGRzIHRoZSB2YWx1ZSBvZiB0aGUgcmVmZXJlbmNlIG5vZGUuXHJcblx0XHQgKlxyXG5cdFx0ICogQHR5cGUge051bWJlcn1cclxuXHRcdCAqIEBkZWZhdWx0IDBcclxuXHRcdCAqL1xyXG5cdFx0dGhpcy5idWZmZXJDb3VudCA9IGJ1ZmZlckNvdW50O1xyXG5cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFRoZSBkYXRhIHR5cGUgb2YgdGhlIGJ1ZmZlciBlbGVtZW50cy5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7Tm9kZUJ1aWxkZXJ9IGJ1aWxkZXIgLSBUaGUgY3VycmVudCBub2RlIGJ1aWxkZXIuXHJcblx0ICogQHJldHVybiB7U3RyaW5nfSBUaGUgZWxlbWVudCB0eXBlLlxyXG5cdCAqL1xyXG5cdGdldEVsZW1lbnRUeXBlKCBidWlsZGVyICkge1xyXG5cclxuXHRcdHJldHVybiB0aGlzLmdldE5vZGVUeXBlKCBidWlsZGVyICk7XHJcblxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogT3ZlcndyaXRlcyB0aGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiB0byByZXR1cm4gYSBmaXhlZCB2YWx1ZSBgJ2J1ZmZlcidgLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtOb2RlQnVpbGRlcn0gYnVpbGRlciAtIFRoZSBjdXJyZW50IG5vZGUgYnVpbGRlci5cclxuXHQgKiBAcmV0dXJuIHtTdHJpbmd9IFRoZSBpbnB1dCB0eXBlLlxyXG5cdCAqL1xyXG5cdGdldElucHV0VHlwZSggLypidWlsZGVyKi8gKSB7XHJcblxyXG5cdFx0cmV0dXJuICdidWZmZXInO1xyXG5cclxuXHR9XHJcblxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBCdWZmZXJOb2RlO1xyXG5cclxuLyoqXHJcbiAqIFRTTCBmdW5jdGlvbiBmb3IgY3JlYXRpbmcgYSBidWZmZXIgbm9kZS5cclxuICpcclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7QXJyYXl9IHZhbHVlIC0gQXJyYXktbGlrZSBidWZmZXIgZGF0YS5cclxuICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgLSBUaGUgZGF0YSB0eXBlIG9mIGEgYnVmZmVyIGVsZW1lbnQuXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBjb3VudCAtIFRoZSBjb3VudCBvZiBidWZmZXIgZWxlbWVudHMuXHJcbiAqIEByZXR1cm5zIHtCdWZmZXJOb2RlfVxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IGJ1ZmZlciA9ICggdmFsdWUsIHR5cGUsIGNvdW50ICkgPT4gbm9kZU9iamVjdCggbmV3IEJ1ZmZlck5vZGUoIHZhbHVlLCB0eXBlLCBjb3VudCApICk7XHJcbiIsImltcG9ydCB7IG5vZGVPYmplY3QgfSBmcm9tICcuLi90c2wvVFNMQmFzZS5qcyc7XHJcbmltcG9ydCB7IE5vZGVVcGRhdGVUeXBlIH0gZnJvbSAnLi4vY29yZS9jb25zdGFudHMuanMnO1xyXG5pbXBvcnQgeyBnZXRWYWx1ZVR5cGUgfSBmcm9tICcuLi9jb3JlL05vZGVVdGlscy5qcyc7XHJcbmltcG9ydCBBcnJheUVsZW1lbnROb2RlIGZyb20gJy4uL3V0aWxzL0FycmF5RWxlbWVudE5vZGUuanMnO1xyXG5pbXBvcnQgQnVmZmVyTm9kZSBmcm9tICcuL0J1ZmZlck5vZGUuanMnO1xyXG5cclxuLyoqIEBtb2R1bGUgVW5pZm9ybUFycmF5Tm9kZSAqKi9cclxuXHJcbi8qKlxyXG4gKiBSZXByZXNlbnRzIHRoZSBlbGVtZW50IGFjY2VzcyBvbiB1bmlmb3JtIGFycmF5IG5vZGVzLlxyXG4gKlxyXG4gKiBAYXVnbWVudHMgQXJyYXlFbGVtZW50Tm9kZVxyXG4gKi9cclxuY2xhc3MgVW5pZm9ybUFycmF5RWxlbWVudE5vZGUgZXh0ZW5kcyBBcnJheUVsZW1lbnROb2RlIHtcclxuXHJcblx0c3RhdGljIGdldCB0eXBlKCkge1xyXG5cclxuXHRcdHJldHVybiAnVW5pZm9ybUFycmF5RWxlbWVudE5vZGUnO1xyXG5cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIENvbnN0cnVjdHMgYSBuZXcgYnVmZmVyIG5vZGUuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge1VuaWZvcm1BcnJheU5vZGV9IHVuaWZvcm1BcnJheU5vZGUgLSBUaGUgdW5pZm9ybSBhcnJheSBub2RlIHRvIGFjY2Vzcy5cclxuXHQgKiBAcGFyYW0ge0luZGV4Tm9kZX0gaW5kZXhOb2RlIC0gVGhlIGluZGV4IGRhdGEgdGhhdCBkZWZpbmUgdGhlIHBvc2l0aW9uIG9mIHRoZSBhY2Nlc3NlZCBlbGVtZW50IGluIHRoZSBhcnJheS5cclxuXHQgKi9cclxuXHRjb25zdHJ1Y3RvciggdW5pZm9ybUFycmF5Tm9kZSwgaW5kZXhOb2RlICkge1xyXG5cclxuXHRcdHN1cGVyKCB1bmlmb3JtQXJyYXlOb2RlLCBpbmRleE5vZGUgKTtcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIFRoaXMgZmxhZyBjYW4gYmUgdXNlZCBmb3IgdHlwZSB0ZXN0aW5nLlxyXG5cdFx0ICpcclxuXHRcdCAqIEB0eXBlIHtCb29sZWFufVxyXG5cdFx0ICogQHJlYWRvbmx5XHJcblx0XHQgKiBAZGVmYXVsdCB0cnVlXHJcblx0XHQgKi9cclxuXHRcdHRoaXMuaXNBcnJheUJ1ZmZlckVsZW1lbnROb2RlID0gdHJ1ZTtcclxuXHJcblx0fVxyXG5cclxuXHRnZW5lcmF0ZSggYnVpbGRlciApIHtcclxuXHJcblx0XHRjb25zdCBzbmlwcGV0ID0gc3VwZXIuZ2VuZXJhdGUoIGJ1aWxkZXIgKTtcclxuXHRcdGNvbnN0IHR5cGUgPSB0aGlzLmdldE5vZGVUeXBlKCk7XHJcblx0XHRjb25zdCBwYWRkZWRUeXBlID0gdGhpcy5ub2RlLmdldFBhZGRlZFR5cGUoKTtcclxuXHJcblx0XHRyZXR1cm4gYnVpbGRlci5mb3JtYXQoIHNuaXBwZXQsIHBhZGRlZFR5cGUsIHR5cGUgKTtcclxuXHJcblx0fVxyXG5cclxufVxyXG5cclxuLyoqXHJcbiAqIFNpbWlsYXIgdG8ge0BsaW5rIG1vZHVsZTpCdWZmZXJOb2RlfkJ1ZmZlck5vZGV9IHRoaXMgbW9kdWxlIHJlcHJlc2VudHMgYXJyYXktbGlrZSBkYXRhIGFzXHJcbiAqIHVuaWZvcm0gYnVmZmVycy4gVW5saWtlIHtAbGluayBtb2R1bGU6QnVmZmVyTm9kZX5CdWZmZXJOb2RlfSwgaXQgY2FuIGhhbmRsZSBtb3JlIGNvbW1vblxyXG4gKiBkYXRhIHR5cGVzIGluIHRoZSBhcnJheSAoZS5nIGB0aHJlZS5qc2AgcHJpbWl0aXZlcykgYW5kIGF1dG9tYXRpY2FsbHlcclxuICogbWFuYWdlIGJ1ZmZlciBwYWRkaW5nLiBJdCBzaG91bGQgYmUgdGhlIGZpcnN0IGNob2ljZSB3aGVuIHdvcmtpbmcgd2l0aFxyXG4gKiB1bmlmb3JtcyBidWZmZXJzLlxyXG4gKiBgYGBqc1xyXG4gKiBjb25zdCB0aW50Q29sb3JzID0gdW5pZm9ybUFycmF5KCBbXHJcbiAqIFx0bmV3IENvbG9yKCAxLCAwLCAwICksXHJcbiAqIFx0bmV3IENvbG9yKCAwLCAxLCAwICksXHJcbiAqIFx0bmV3IENvbG9yKCAwLCAwLCAxIClcclxuICogXSwgJ2NvbG9yJyApO1xyXG4gKlxyXG4gKiBjb25zdCByZWRDb2xvciA9IHRpbnRDb2xvcnMuZWxlbWVudCggMCApO1xyXG4gKlxyXG4gKiBAYXVnbWVudHMgbW9kdWxlOkJ1ZmZlck5vZGV+QnVmZmVyTm9kZVxyXG4gKi9cclxuY2xhc3MgVW5pZm9ybUFycmF5Tm9kZSBleHRlbmRzIEJ1ZmZlck5vZGUge1xyXG5cclxuXHRzdGF0aWMgZ2V0IHR5cGUoKSB7XHJcblxyXG5cdFx0cmV0dXJuICdVbmlmb3JtQXJyYXlOb2RlJztcclxuXHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBDb25zdHJ1Y3RzIGEgbmV3IHVuaWZvcm0gYXJyYXkgbm9kZS5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7QXJyYXk8QW55Pn0gdmFsdWUgLSBBcnJheSBob2xkaW5nIHRoZSBidWZmZXIgZGF0YS5cclxuXHQgKiBAcGFyYW0ge1N0cmluZz99IFtlbGVtZW50VHlwZT1udWxsXSAtIFRoZSBkYXRhIHR5cGUgb2YgYSBidWZmZXIgZWxlbWVudC5cclxuXHQgKi9cclxuXHRjb25zdHJ1Y3RvciggdmFsdWUsIGVsZW1lbnRUeXBlID0gbnVsbCApIHtcclxuXHJcblx0XHRzdXBlciggbnVsbCApO1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogQXJyYXkgaG9sZGluZyB0aGUgYnVmZmVyIGRhdGEuIFVubGlrZSB7QGxpbmsgbW9kdWxlOkJ1ZmZlck5vZGV+QnVmZmVyTm9kZX0sIHRoZSBhcnJheSBjYW5cclxuXHRcdCAqIGhvbGQgbnVtYmVyIHByaW1pdGl2ZXMgYXMgd2VsbCBhcyB0aHJlZS5qcyBvYmplY3RzIGxpa2UgdmVjdG9ycywgbWF0cmljZXNcclxuXHRcdCAqIG9yIGNvbG9ycy5cclxuXHRcdCAqXHJcblx0XHQgKiBAdHlwZSB7QXJyYXk8QW55Pn1cclxuXHRcdCAqL1xyXG5cdFx0dGhpcy5hcnJheSA9IHZhbHVlO1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogVGhlIGRhdGEgdHlwZSBvZiBhbiBhcnJheSBlbGVtZW50LlxyXG5cdFx0ICpcclxuXHRcdCAqIEB0eXBlIHtTdHJpbmd9XHJcblx0XHQgKi9cclxuXHRcdHRoaXMuZWxlbWVudFR5cGUgPSBlbGVtZW50VHlwZSA9PT0gbnVsbCA/IGdldFZhbHVlVHlwZSggdmFsdWVbIDAgXSApIDogZWxlbWVudFR5cGU7XHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBUaGUgcGFkZGVkIHR5cGUuIFVuaWZvcm0gYnVmZmVycyBtdXN0IGNvbmZvcm0gdG8gYSBjZXJ0YWluIGJ1ZmZlciBsYXlvdXRcclxuXHRcdCAqIHNvIGEgc2VwYXJhdGUgdHlwZSBpcyBjb21wdXRlZCB0byBlbnN1cmUgY29ycmVjdCBidWZmZXIgc2l6ZS5cclxuXHRcdCAqXHJcblx0XHQgKiBAdHlwZSB7U3RyaW5nfVxyXG5cdFx0ICovXHJcblx0XHR0aGlzLnBhZGRlZFR5cGUgPSB0aGlzLmdldFBhZGRlZFR5cGUoKTtcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIE92ZXJ3cml0dGVuIHNpbmNlIHVuaWZvcm0gYXJyYXkgbm9kZXMgYXJlIHVwZGF0ZWQgcGVyIHJlbmRlci5cclxuXHRcdCAqXHJcblx0XHQgKiBAdHlwZSB7U3RyaW5nfVxyXG5cdFx0ICogQGRlZmF1bHQgJ3JlbmRlcidcclxuXHRcdCAqL1xyXG5cdFx0dGhpcy51cGRhdGVUeXBlID0gTm9kZVVwZGF0ZVR5cGUuUkVOREVSO1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogVGhpcyBmbGFnIGNhbiBiZSB1c2VkIGZvciB0eXBlIHRlc3RpbmcuXHJcblx0XHQgKlxyXG5cdFx0ICogQHR5cGUge0Jvb2xlYW59XHJcblx0XHQgKiBAcmVhZG9ubHlcclxuXHRcdCAqIEBkZWZhdWx0IHRydWVcclxuXHRcdCAqL1xyXG5cdFx0dGhpcy5pc0FycmF5QnVmZmVyTm9kZSA9IHRydWU7XHJcblxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogVGhpcyBtZXRob2QgaXMgb3ZlcndyaXR0ZW4gc2luY2UgdGhlIG5vZGUgdHlwZSBpcyBpbmZlcnJlZCBmcm9tIHRoZVxyXG5cdCAqIHtAbGluayBtb2R1bGU6VW5pZm9ybUFycmF5Tm9kZX5Vbmlmb3JtQXJyYXlOb2RlI3BhZGRlZFR5cGV9LlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtOb2RlQnVpbGRlcn0gYnVpbGRlciAtIFRoZSBjdXJyZW50IG5vZGUgYnVpbGRlci5cclxuXHQgKiBAcmV0dXJuIHtTdHJpbmd9IFRoZSBub2RlIHR5cGUuXHJcblx0ICovXHJcblx0Z2V0Tm9kZVR5cGUoIC8qYnVpbGRlciovICkge1xyXG5cclxuXHRcdHJldHVybiB0aGlzLnBhZGRlZFR5cGU7XHJcblxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogVGhlIGRhdGEgdHlwZSBvZiB0aGUgYXJyYXkgZWxlbWVudHMuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge05vZGVCdWlsZGVyfSBidWlsZGVyIC0gVGhlIGN1cnJlbnQgbm9kZSBidWlsZGVyLlxyXG5cdCAqIEByZXR1cm4ge1N0cmluZ30gVGhlIGVsZW1lbnQgdHlwZS5cclxuXHQgKi9cclxuXHRnZXRFbGVtZW50VHlwZSgpIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5lbGVtZW50VHlwZTtcclxuXHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBSZXR1cm5zIHRoZSBwYWRkZWQgdHlwZSBiYXNlZCBvbiB0aGUgZWxlbWVudCB0eXBlLlxyXG5cdCAqXHJcblx0ICogQHJldHVybiB7U3RyaW5nfSBUaGUgcGFkZGVkIHR5cGUuXHJcblx0ICovXHJcblx0Z2V0UGFkZGVkVHlwZSgpIHtcclxuXHJcblx0XHRjb25zdCBlbGVtZW50VHlwZSA9IHRoaXMuZWxlbWVudFR5cGU7XHJcblxyXG5cdFx0bGV0IHBhZGRlZFR5cGUgPSAndmVjNCc7XHJcblxyXG5cdFx0aWYgKCBlbGVtZW50VHlwZSA9PT0gJ21hdDInICkge1xyXG5cclxuXHRcdFx0cGFkZGVkVHlwZSA9ICdtYXQyJztcclxuXHJcblx0XHR9IGVsc2UgaWYgKCAvbWF0Ly50ZXN0KCBlbGVtZW50VHlwZSApID09PSB0cnVlICkge1xyXG5cclxuXHRcdFx0cGFkZGVkVHlwZSA9ICdtYXQ0JztcclxuXHJcblx0XHR9IGVsc2UgaWYgKCBlbGVtZW50VHlwZS5jaGFyQXQoIDAgKSA9PT0gJ2knICkge1xyXG5cclxuXHRcdFx0cGFkZGVkVHlwZSA9ICdpdmVjNCc7XHJcblxyXG5cdFx0fSBlbHNlIGlmICggZWxlbWVudFR5cGUuY2hhckF0KCAwICkgPT09ICd1JyApIHtcclxuXHJcblx0XHRcdHBhZGRlZFR5cGUgPSAndXZlYzQnO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gcGFkZGVkVHlwZTtcclxuXHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBUaGUgdXBkYXRlIG1ha2VzIHN1cmUgdG8gY29ycmVjdGx5IHRyYW5zZmVyIHRoZSBkYXRhIGZyb20gdGhlIChjb21wbGV4KSBvYmplY3RzXHJcblx0ICogaW4gdGhlIGFycmF5IHRvIHRoZSBpbnRlcm5hbCwgY29ycmVjdGx5IHBhZGRlZCB2YWx1ZSBidWZmZXIuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge05vZGVGcmFtZX0gZnJhbWUgLSBBIHJlZmVyZW5jZSB0byB0aGUgY3VycmVudCBub2RlIGZyYW1lLlxyXG5cdCAqL1xyXG5cdHVwZGF0ZSggLypmcmFtZSovICkge1xyXG5cclxuXHRcdGNvbnN0IHsgYXJyYXksIHZhbHVlIH0gPSB0aGlzO1xyXG5cclxuXHRcdGNvbnN0IGVsZW1lbnRUeXBlID0gdGhpcy5lbGVtZW50VHlwZTtcclxuXHJcblx0XHRpZiAoIGVsZW1lbnRUeXBlID09PSAnZmxvYXQnIHx8IGVsZW1lbnRUeXBlID09PSAnaW50JyB8fCBlbGVtZW50VHlwZSA9PT0gJ3VpbnQnICkge1xyXG5cclxuXHRcdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHRjb25zdCBpbmRleCA9IGkgKiA0O1xyXG5cclxuXHRcdFx0XHR2YWx1ZVsgaW5kZXggXSA9IGFycmF5WyBpIF07XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fSBlbHNlIGlmICggZWxlbWVudFR5cGUgPT09ICdjb2xvcicgKSB7XHJcblxyXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdGNvbnN0IGluZGV4ID0gaSAqIDQ7XHJcblx0XHRcdFx0Y29uc3QgdmVjdG9yID0gYXJyYXlbIGkgXTtcclxuXHJcblx0XHRcdFx0dmFsdWVbIGluZGV4IF0gPSB2ZWN0b3IucjtcclxuXHRcdFx0XHR2YWx1ZVsgaW5kZXggKyAxIF0gPSB2ZWN0b3IuZztcclxuXHRcdFx0XHR2YWx1ZVsgaW5kZXggKyAyIF0gPSB2ZWN0b3IuYiB8fCAwO1xyXG5cdFx0XHRcdC8vdmFsdWVbIGluZGV4ICsgMyBdID0gdmVjdG9yLmEgfHwgMDtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9IGVsc2UgaWYgKCBlbGVtZW50VHlwZSA9PT0gJ21hdDInICkge1xyXG5cclxuXHRcdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHRjb25zdCBpbmRleCA9IGkgKiA0O1xyXG5cdFx0XHRcdGNvbnN0IG1hdHJpeCA9IGFycmF5WyBpIF07XHJcblxyXG5cdFx0XHRcdHZhbHVlWyBpbmRleCBdID0gbWF0cml4LmVsZW1lbnRzWyAwIF07XHJcblx0XHRcdFx0dmFsdWVbIGluZGV4ICsgMSBdID0gbWF0cml4LmVsZW1lbnRzWyAxIF07XHJcblx0XHRcdFx0dmFsdWVbIGluZGV4ICsgMiBdID0gbWF0cml4LmVsZW1lbnRzWyAyIF07XHJcblx0XHRcdFx0dmFsdWVbIGluZGV4ICsgMyBdID0gbWF0cml4LmVsZW1lbnRzWyAzIF07XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fSBlbHNlIGlmICggZWxlbWVudFR5cGUgPT09ICdtYXQzJyApIHtcclxuXHJcblx0XHRcdGZvciAoIGxldCBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0Y29uc3QgaW5kZXggPSBpICogMTY7XHJcblx0XHRcdFx0Y29uc3QgbWF0cml4ID0gYXJyYXlbIGkgXTtcclxuXHJcblx0XHRcdFx0dmFsdWVbIGluZGV4IF0gPSBtYXRyaXguZWxlbWVudHNbIDAgXTtcclxuXHRcdFx0XHR2YWx1ZVsgaW5kZXggKyAxIF0gPSBtYXRyaXguZWxlbWVudHNbIDEgXTtcclxuXHRcdFx0XHR2YWx1ZVsgaW5kZXggKyAyIF0gPSBtYXRyaXguZWxlbWVudHNbIDIgXTtcclxuXHJcblx0XHRcdFx0dmFsdWVbIGluZGV4ICsgNCBdID0gbWF0cml4LmVsZW1lbnRzWyAzIF07XHJcblx0XHRcdFx0dmFsdWVbIGluZGV4ICsgNSBdID0gbWF0cml4LmVsZW1lbnRzWyA0IF07XHJcblx0XHRcdFx0dmFsdWVbIGluZGV4ICsgNiBdID0gbWF0cml4LmVsZW1lbnRzWyA1IF07XHJcblxyXG5cdFx0XHRcdHZhbHVlWyBpbmRleCArIDggXSA9IG1hdHJpeC5lbGVtZW50c1sgNiBdO1xyXG5cdFx0XHRcdHZhbHVlWyBpbmRleCArIDkgXSA9IG1hdHJpeC5lbGVtZW50c1sgNyBdO1xyXG5cdFx0XHRcdHZhbHVlWyBpbmRleCArIDEwIF0gPSBtYXRyaXguZWxlbWVudHNbIDggXTtcclxuXHJcblx0XHRcdFx0dmFsdWVbIGluZGV4ICsgMTUgXSA9IDE7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fSBlbHNlIGlmICggZWxlbWVudFR5cGUgPT09ICdtYXQ0JyApIHtcclxuXHJcblx0XHRcdGZvciAoIGxldCBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0Y29uc3QgaW5kZXggPSBpICogMTY7XHJcblx0XHRcdFx0Y29uc3QgbWF0cml4ID0gYXJyYXlbIGkgXTtcclxuXHJcblx0XHRcdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgbWF0cml4LmVsZW1lbnRzLmxlbmd0aDsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0XHR2YWx1ZVsgaW5kZXggKyBpIF0gPSBtYXRyaXguZWxlbWVudHNbIGkgXTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdGNvbnN0IGluZGV4ID0gaSAqIDQ7XHJcblx0XHRcdFx0Y29uc3QgdmVjdG9yID0gYXJyYXlbIGkgXTtcclxuXHJcblx0XHRcdFx0dmFsdWVbIGluZGV4IF0gPSB2ZWN0b3IueDtcclxuXHRcdFx0XHR2YWx1ZVsgaW5kZXggKyAxIF0gPSB2ZWN0b3IueTtcclxuXHRcdFx0XHR2YWx1ZVsgaW5kZXggKyAyIF0gPSB2ZWN0b3IueiB8fCAwO1xyXG5cdFx0XHRcdHZhbHVlWyBpbmRleCArIDMgXSA9IHZlY3Rvci53IHx8IDA7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEltcGxlbWVudCB0aGUgdmFsdWUgYnVmZmVyIGNyZWF0aW9uIGJhc2VkIG9uIHRoZSBhcnJheSBkYXRhLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtOb2RlQnVpbGRlcn0gYnVpbGRlciAtIEEgcmVmZXJlbmNlIHRvIHRoZSBjdXJyZW50IG5vZGUgYnVpbGRlci5cclxuXHQgKiBAcmV0dXJuIHtudWxsfVxyXG5cdCAqL1xyXG5cdHNldHVwKCBidWlsZGVyICkge1xyXG5cclxuXHRcdGNvbnN0IGxlbmd0aCA9IHRoaXMuYXJyYXkubGVuZ3RoO1xyXG5cdFx0Y29uc3QgZWxlbWVudFR5cGUgPSB0aGlzLmVsZW1lbnRUeXBlO1xyXG5cclxuXHRcdGxldCBhcnJheVR5cGUgPSBGbG9hdDMyQXJyYXk7XHJcblxyXG5cdFx0Y29uc3QgcGFkZGVkVHlwZSA9IHRoaXMucGFkZGVkVHlwZTtcclxuXHRcdGNvbnN0IHBhZGRlZEVsZW1lbnRMZW5ndGggPSBidWlsZGVyLmdldFR5cGVMZW5ndGgoIHBhZGRlZFR5cGUgKTtcclxuXHJcblx0XHRpZiAoIGVsZW1lbnRUeXBlLmNoYXJBdCggMCApID09PSAnaScgKSBhcnJheVR5cGUgPSBJbnQzMkFycmF5O1xyXG5cdFx0aWYgKCBlbGVtZW50VHlwZS5jaGFyQXQoIDAgKSA9PT0gJ3UnICkgYXJyYXlUeXBlID0gVWludDMyQXJyYXk7XHJcblxyXG5cdFx0dGhpcy52YWx1ZSA9IG5ldyBhcnJheVR5cGUoIGxlbmd0aCAqIHBhZGRlZEVsZW1lbnRMZW5ndGggKTtcclxuXHRcdHRoaXMuYnVmZmVyQ291bnQgPSBsZW5ndGg7XHJcblx0XHR0aGlzLmJ1ZmZlclR5cGUgPSBwYWRkZWRUeXBlO1xyXG5cclxuXHRcdHJldHVybiBzdXBlci5zZXR1cCggYnVpbGRlciApO1xyXG5cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIE92ZXJ3cml0ZXMgdGhlIGRlZmF1bHQgYGVsZW1lbnQoKWAgbWV0aG9kIHRvIHByb3ZpZGUgZWxlbWVudCBhY2Nlc3NcclxuXHQgKiBiYXNlZCBvbiB7QGxpbmsgbW9kdWxlOlVuaWZvcm1BcnJheU5vZGV+VW5pZm9ybUFycmF5Tm9kZX0uXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge0luZGV4Tm9kZX0gaW5kZXhOb2RlIC0gVGhlIGluZGV4IG5vZGUuXHJcblx0ICogQHJldHVybiB7VW5pZm9ybUFycmF5RWxlbWVudE5vZGV9XHJcblx0ICovXHJcblx0ZWxlbWVudCggaW5kZXhOb2RlICkge1xyXG5cclxuXHRcdHJldHVybiBub2RlT2JqZWN0KCBuZXcgVW5pZm9ybUFycmF5RWxlbWVudE5vZGUoIHRoaXMsIG5vZGVPYmplY3QoIGluZGV4Tm9kZSApICkgKTtcclxuXHJcblx0fVxyXG5cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgVW5pZm9ybUFycmF5Tm9kZTtcclxuXHJcbi8qKlxyXG4gKiBUU0wgZnVuY3Rpb24gZm9yIGNyZWF0aW5nIGFuIHVuaWZvcm0gYXJyYXkgbm9kZS5cclxuICpcclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7QXJyYXk8QW55Pn0gdmFsdWVzIC0gQXJyYXktbGlrZSBkYXRhLlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gbm9kZVR5cGUgLSBUaGUgZGF0YSB0eXBlIG9mIHRoZSBhcnJheSBlbGVtZW50cy5cclxuICogQHJldHVybnMge1VuaWZvcm1BcnJheU5vZGV9XHJcbiAqL1xyXG5leHBvcnQgY29uc3QgdW5pZm9ybUFycmF5ID0gKCB2YWx1ZXMsIG5vZGVUeXBlICkgPT4gbm9kZU9iamVjdCggbmV3IFVuaWZvcm1BcnJheU5vZGUoIHZhbHVlcywgbm9kZVR5cGUgKSApO1xyXG5cclxuLy9cclxuXHJcbmV4cG9ydCBjb25zdCB1bmlmb3JtcyA9ICggdmFsdWVzLCBub2RlVHlwZSApID0+IHsgLy8gQGRlcHJlY2F0ZWQsIHIxNjhcclxuXHJcblx0Y29uc29sZS53YXJuKCAnVFNMLlVuaWZvcm1BcnJheU5vZGU6IHVuaWZvcm1zKCkgaGFzIGJlZW4gcmVuYW1lZCB0byB1bmlmb3JtQXJyYXkoKS4nICk7XHJcblx0cmV0dXJuIG5vZGVPYmplY3QoIG5ldyBVbmlmb3JtQXJyYXlOb2RlKCB2YWx1ZXMsIG5vZGVUeXBlICkgKTtcclxuXHJcbn07XHJcbiIsImltcG9ydCBOb2RlIGZyb20gJy4uL2NvcmUvTm9kZS5qcyc7XHJcbmltcG9ydCB7IE5vZGVVcGRhdGVUeXBlIH0gZnJvbSAnLi4vY29yZS9jb25zdGFudHMuanMnO1xyXG5pbXBvcnQgeyB1bmlmb3JtIH0gZnJvbSAnLi4vY29yZS9Vbmlmb3JtTm9kZS5qcyc7XHJcbmltcG9ydCB7IHRleHR1cmUgfSBmcm9tICcuL1RleHR1cmVOb2RlLmpzJztcclxuaW1wb3J0IHsgY3ViZVRleHR1cmUgfSBmcm9tICcuL0N1YmVUZXh0dXJlTm9kZS5qcyc7XHJcbmltcG9ydCB7IGJ1ZmZlciB9IGZyb20gJy4vQnVmZmVyTm9kZS5qcyc7XHJcbmltcG9ydCB7IG5vZGVPYmplY3QgfSBmcm9tICcuLi90c2wvVFNMQmFzZS5qcyc7XHJcbmltcG9ydCB7IHVuaWZvcm1BcnJheSB9IGZyb20gJy4vVW5pZm9ybUFycmF5Tm9kZS5qcyc7XHJcbmltcG9ydCBBcnJheUVsZW1lbnROb2RlIGZyb20gJy4uL3V0aWxzL0FycmF5RWxlbWVudE5vZGUuanMnO1xyXG5cclxuLyoqIEBtb2R1bGUgUmVmZXJlbmNlTm9kZSAqKi9cclxuXHJcbi8qKlxyXG4gKiBUaGlzIGNsYXNzIGlzIG9ubHkgcmVsZXZhbnQgaWYgdGhlIHJlZmVyZW5jZWQgcHJvcGVydHkgaXMgYXJyYXktbGlrZS5cclxuICogSW4gdGhpcyBjYXNlLCBgUmVmZXJlbmNlRWxlbWVudE5vZGVgIGFsbG93cyB0byByZWZlciB0byBhIHNwZWNpZmljXHJcbiAqIGVsZW1lbnQgaW5zaWRlIHRoZSBkYXRhIHN0cnVjdHVyZSB2aWEgYW4gaW5kZXguXHJcbiAqXHJcbiAqIEBhdWdtZW50cyBBcnJheUVsZW1lbnROb2RlXHJcbiAqL1xyXG5jbGFzcyBSZWZlcmVuY2VFbGVtZW50Tm9kZSBleHRlbmRzIEFycmF5RWxlbWVudE5vZGUge1xyXG5cclxuXHRzdGF0aWMgZ2V0IHR5cGUoKSB7XHJcblxyXG5cdFx0cmV0dXJuICdSZWZlcmVuY2VFbGVtZW50Tm9kZSc7XHJcblxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogQ29uc3RydWN0cyBhIG5ldyByZWZlcmVuY2UgZWxlbWVudCBub2RlLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtOb2RlfSByZWZlcmVuY2VOb2RlIC0gVGhlIHJlZmVyZW5jZSBub2RlLlxyXG5cdCAqIEBwYXJhbSB7Tm9kZX0gaW5kZXhOb2RlIC0gVGhlIGluZGV4IG5vZGUgdGhhdCBkZWZpbmVzIHRoZSBlbGVtZW50IGFjY2Vzcy5cclxuXHQgKi9cclxuXHRjb25zdHJ1Y3RvciggcmVmZXJlbmNlTm9kZSwgaW5kZXhOb2RlICkge1xyXG5cclxuXHRcdHN1cGVyKCByZWZlcmVuY2VOb2RlLCBpbmRleE5vZGUgKTtcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIFNpbWlsYXIgdG8ge0BsaW5rIG1vZHVsZTpSZWZlcmVuY2VOb2RlflJlZmVyZW5jZU5vZGUjcmVmZXJlbmNlfSwgYW4gYWRkaXRpb25hbFxyXG5cdFx0ICogcHJvcGVydHkgcmVmZXJlbmNlcyB0byB0aGUgY3VycmVudCBub2RlLlxyXG5cdFx0ICpcclxuXHRcdCAqIEB0eXBlIHtOb2RlfVxyXG5cdFx0ICogQGRlZmF1bHQgbnVsbFxyXG5cdFx0ICovXHJcblx0XHR0aGlzLnJlZmVyZW5jZU5vZGUgPSByZWZlcmVuY2VOb2RlO1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogVGhpcyBmbGFnIGNhbiBiZSB1c2VkIGZvciB0eXBlIHRlc3RpbmcuXHJcblx0XHQgKlxyXG5cdFx0ICogQHR5cGUge0Jvb2xlYW59XHJcblx0XHQgKiBAcmVhZG9ubHlcclxuXHRcdCAqIEBkZWZhdWx0IHRydWVcclxuXHRcdCAqL1xyXG5cdFx0dGhpcy5pc1JlZmVyZW5jZUVsZW1lbnROb2RlID0gdHJ1ZTtcclxuXHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBUaGlzIG1ldGhvZCBpcyBvdmVyd3JpdHRlbiBzaW5jZSB0aGUgbm9kZSB0eXBlIGlzIGluZmVycmVkIGZyb21cclxuXHQgKiB0aGUgdW5pZm9ybSB0eXBlIG9mIHRoZSByZWZlcmVuY2Ugbm9kZS5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7Tm9kZUJ1aWxkZXJ9IGJ1aWxkZXIgLSBUaGUgY3VycmVudCBub2RlIGJ1aWxkZXIuXHJcblx0ICogQHJldHVybiB7U3RyaW5nfSBUaGUgbm9kZSB0eXBlLlxyXG5cdCAqL1xyXG5cdGdldE5vZGVUeXBlKCkge1xyXG5cclxuXHRcdHJldHVybiB0aGlzLnJlZmVyZW5jZU5vZGUudW5pZm9ybVR5cGU7XHJcblxyXG5cdH1cclxuXHJcblx0Z2VuZXJhdGUoIGJ1aWxkZXIgKSB7XHJcblxyXG5cdFx0Y29uc3Qgc25pcHBldCA9IHN1cGVyLmdlbmVyYXRlKCBidWlsZGVyICk7XHJcblx0XHRjb25zdCBhcnJheVR5cGUgPSB0aGlzLnJlZmVyZW5jZU5vZGUuZ2V0Tm9kZVR5cGUoKTtcclxuXHRcdGNvbnN0IGVsZW1lbnRUeXBlID0gdGhpcy5nZXROb2RlVHlwZSgpO1xyXG5cclxuXHRcdHJldHVybiBidWlsZGVyLmZvcm1hdCggc25pcHBldCwgYXJyYXlUeXBlLCBlbGVtZW50VHlwZSApO1xyXG5cclxuXHR9XHJcblxyXG59XHJcblxyXG4vKipcclxuICogVGhpcyB0eXBlIG9mIG5vZGUgZXN0YWJsaXNoZXMgYSByZWZlcmVuY2UgdG8gYSBwcm9wZXJ0eSBvZiBhbm90aGVyIG9iamVjdC5cclxuICogSW4gdGhpcyB3YXksIHRoZSB2YWx1ZSBvZiB0aGUgbm9kZSBpcyBhdXRvbWF0aWNhbGx5IGxpbmtlZCB0byB0aGUgdmFsdWUgb2ZcclxuICogcmVmZXJlbmNlZCBvYmplY3QuIFJlZmVyZW5jZSBub2RlcyBpbnRlcm5hbGx5IHJlcHJlc2VudCB0aGUgbGlua2VkIHZhbHVlXHJcbiAqIGFzIGEgdW5pZm9ybS5cclxuICpcclxuICogQGF1Z21lbnRzIE5vZGVcclxuICovXHJcbmNsYXNzIFJlZmVyZW5jZU5vZGUgZXh0ZW5kcyBOb2RlIHtcclxuXHJcblx0c3RhdGljIGdldCB0eXBlKCkge1xyXG5cclxuXHRcdHJldHVybiAnUmVmZXJlbmNlTm9kZSc7XHJcblxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogQ29uc3RydWN0cyBhIG5ldyByZWZlcmVuY2Ugbm9kZS5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0eSAtIFRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eSB0aGUgbm9kZSByZWZlcnMgdG8uXHJcblx0ICogQHBhcmFtIHtTdHJpbmd9IHVuaWZvcm1UeXBlIC0gVGhlIHVuaWZvcm0gdHlwZSB0aGF0IHNob3VsZCBiZSB1c2VkIHRvIHJlcHJlc2VudCB0aGUgcHJvcGVydHkgdmFsdWUuXHJcblx0ICogQHBhcmFtIHtPYmplY3Q/fSBbb2JqZWN0PW51bGxdIC0gVGhlIG9iamVjdCB0aGUgcHJvcGVydHkgYmVsb25ncyB0by5cclxuXHQgKiBAcGFyYW0ge051bWJlcj99IFtjb3VudD1udWxsXSAtIFdoZW4gdGhlIGxpbmtlZCBwcm9wZXJ0eSBpcyBhbiBhcnJheS1saWtlLCB0aGlzIHBhcmFtZXRlciBkZWZpbmVzIGl0cyBsZW5ndGguXHJcblx0ICovXHJcblx0Y29uc3RydWN0b3IoIHByb3BlcnR5LCB1bmlmb3JtVHlwZSwgb2JqZWN0ID0gbnVsbCwgY291bnQgPSBudWxsICkge1xyXG5cclxuXHRcdHN1cGVyKCk7XHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBUaGUgbmFtZSBvZiB0aGUgcHJvcGVydHkgdGhlIG5vZGUgcmVmZXJzIHRvLlxyXG5cdFx0ICpcclxuXHRcdCAqIEB0eXBlIHtTdHJpbmd9XHJcblx0XHQgKi9cclxuXHRcdHRoaXMucHJvcGVydHkgPSBwcm9wZXJ0eTtcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIFRoZSB1bmlmb3JtIHR5cGUgdGhhdCBzaG91bGQgYmUgdXNlZCB0byByZXByZXNlbnQgdGhlIHByb3BlcnR5IHZhbHVlLlxyXG5cdFx0ICpcclxuXHRcdCAqIEB0eXBlIHtTdHJpbmd9XHJcblx0XHQgKi9cclxuXHRcdHRoaXMudW5pZm9ybVR5cGUgPSB1bmlmb3JtVHlwZTtcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIFRoZSBvYmplY3QgdGhlIHByb3BlcnR5IGJlbG9uZ3MgdG8uXHJcblx0XHQgKlxyXG5cdFx0ICogQHR5cGUge09iamVjdD99XHJcblx0XHQgKiBAZGVmYXVsdCBudWxsXHJcblx0XHQgKi9cclxuXHRcdHRoaXMub2JqZWN0ID0gb2JqZWN0O1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogV2hlbiB0aGUgbGlua2VkIHByb3BlcnR5IGlzIGFuIGFycmF5LCB0aGlzIHBhcmFtZXRlciBkZWZpbmVzIGl0cyBsZW5ndGguXHJcblx0XHQgKlxyXG5cdFx0ICogQHR5cGUge051bWJlcj99XHJcblx0XHQgKiBAZGVmYXVsdCBudWxsXHJcblx0XHQgKi9cclxuXHRcdHRoaXMuY291bnQgPSBjb3VudDtcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIFRoZSBwcm9wZXJ0eSBuYW1lIG1pZ2h0IGhhdmUgZG90cyBzbyBuZXN0ZWQgcHJvcGVydGllcyBjYW4gYmUgcmVmZXJyZWQuXHJcblx0XHQgKiBUaGUgaGllcmFyY2h5IG9mIHRoZSBuYW1lcyBpcyBzdG9yZWQgaW5zaWRlIHRoaXMgYXJyYXkuXHJcblx0XHQgKlxyXG5cdFx0ICogQHR5cGUge0FycmF5PFN0cmluZz59XHJcblx0XHQgKi9cclxuXHRcdHRoaXMucHJvcGVydGllcyA9IHByb3BlcnR5LnNwbGl0KCAnLicgKTtcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIFBvaW50cyB0byB0aGUgY3VycmVudCByZWZlcnJlZCBvYmplY3QuIFRoaXMgcHJvcGVydHkgZXhpc3RzIG5leHQgdG8ge0BsaW5rIG1vZHVsZTpSZWZlcmVuY2VOb2RlflJlZmVyZW5jZU5vZGUjb2JqZWN0fVxyXG5cdFx0ICogc2luY2UgdGhlIGZpbmFsIHJlZmVyZW5jZSBtaWdodCBiZSB1cGRhdGVkIGZyb20gY2FsbGluZyBjb2RlLlxyXG5cdFx0ICpcclxuXHRcdCAqIEB0eXBlIHtPYmplY3Q/fVxyXG5cdFx0ICogQGRlZmF1bHQgbnVsbFxyXG5cdFx0ICovXHJcblx0XHR0aGlzLnJlZmVyZW5jZSA9IG9iamVjdDtcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIFRoZSB1bmlmb3JtIG5vZGUgdGhhdCBob2xkcyB0aGUgdmFsdWUgb2YgdGhlIHJlZmVyZW5jZSBub2RlLlxyXG5cdFx0ICpcclxuXHRcdCAqIEB0eXBlIHtVbmlmb3JtTm9kZX1cclxuXHRcdCAqIEBkZWZhdWx0IG51bGxcclxuXHRcdCAqL1xyXG5cdFx0dGhpcy5ub2RlID0gbnVsbDtcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIFRoZSB1bmlmb3JtIGdyb3VwIG9mIHRoZSBpbnRlcm5hbCB1bmlmb3JtLlxyXG5cdFx0ICpcclxuXHRcdCAqIEB0eXBlIHtVbmlmb3JtR3JvdXBOb2RlfVxyXG5cdFx0ICogQGRlZmF1bHQgbnVsbFxyXG5cdFx0ICovXHJcblx0XHR0aGlzLmdyb3VwID0gbnVsbDtcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIEFuIG9wdGlvbmFsIGxhYmVsIG9mIHRoZSBpbnRlcm5hbCB1bmlmb3JtIG5vZGUuXHJcblx0XHQgKlxyXG5cdFx0ICogQHR5cGUge1N0cmluZz99XHJcblx0XHQgKiBAZGVmYXVsdCBudWxsXHJcblx0XHQgKi9cclxuXHRcdHRoaXMubmFtZSA9IG51bGw7XHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBPdmVyd3JpdHRlbiBzaW5jZSB2ZWxvY2l0eSBub2RlcyBhcmUgdXBkYXRlZCBwZXIgb2JqZWN0LlxyXG5cdFx0ICpcclxuXHRcdCAqIEB0eXBlIHtTdHJpbmd9XHJcblx0XHQgKiBAZGVmYXVsdCAnb2JqZWN0J1xyXG5cdFx0ICovXHJcblx0XHR0aGlzLnVwZGF0ZVR5cGUgPSBOb2RlVXBkYXRlVHlwZS5PQkpFQ1Q7XHJcblxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogV2hlbiB0aGUgcmVmZXJyZWQgcHJvcGVydHkgaXMgYXJyYXktbGlrZSwgdGhpcyBtZXRob2QgY2FuIGJlIHVzZWRcclxuXHQgKiB0byBhY2Nlc3MgZWxlbWVudHMgdmlhIGFuIGluZGV4IG5vZGUuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge0luZGV4Tm9kZX0gaW5kZXhOb2RlIC0gaW5kZXhOb2RlLlxyXG5cdCAqIEByZXR1cm4ge1JlZmVyZW5jZUVsZW1lbnROb2RlfSBBIHJlZmVyZW5jZSB0byBhbiBlbGVtZW50LlxyXG5cdCAqL1xyXG5cdGVsZW1lbnQoIGluZGV4Tm9kZSApIHtcclxuXHJcblx0XHRyZXR1cm4gbm9kZU9iamVjdCggbmV3IFJlZmVyZW5jZUVsZW1lbnROb2RlKCB0aGlzLCBub2RlT2JqZWN0KCBpbmRleE5vZGUgKSApICk7XHJcblxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogU2V0cyB0aGUgdW5pZm9ybSBncm91cCBmb3IgdGhpcyByZWZlcmVuY2Ugbm9kZS5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7VW5pZm9ybUdyb3VwTm9kZX0gZ3JvdXAgLSBUaGUgdW5pZm9ybSBncm91cCB0byBzZXQuXHJcblx0ICogQHJldHVybiB7UmVmZXJlbmNlTm9kZX0gQSByZWZlcmVuY2UgdG8gdGhpcyBub2RlLlxyXG5cdCAqL1xyXG5cdHNldEdyb3VwKCBncm91cCApIHtcclxuXHJcblx0XHR0aGlzLmdyb3VwID0gZ3JvdXA7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogU2V0cyB0aGUgbGFiZWwgZm9yIHRoZSBpbnRlcm5hbCB1bmlmb3JtLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgLSBUaGUgbGFiZWwgdG8gc2V0LlxyXG5cdCAqIEByZXR1cm4ge1JlZmVyZW5jZU5vZGV9IEEgcmVmZXJlbmNlIHRvIHRoaXMgbm9kZS5cclxuXHQgKi9cclxuXHRsYWJlbCggbmFtZSApIHtcclxuXHJcblx0XHR0aGlzLm5hbWUgPSBuYW1lO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFNldHMgdGhlIG5vZGUgdHlwZSB3aGljaCBhdXRvbWF0aWNhbGx5IGRlZmluZXMgdGhlIGludGVybmFsXHJcblx0ICogdW5pZm9ybSB0eXBlLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtTdHJpbmd9IHVuaWZvcm1UeXBlIC0gVGhlIHR5cGUgdG8gc2V0LlxyXG5cdCAqL1xyXG5cdHNldE5vZGVUeXBlKCB1bmlmb3JtVHlwZSApIHtcclxuXHJcblx0XHRsZXQgbm9kZSA9IG51bGw7XHJcblxyXG5cdFx0aWYgKCB0aGlzLmNvdW50ICE9PSBudWxsICkge1xyXG5cclxuXHRcdFx0bm9kZSA9IGJ1ZmZlciggbnVsbCwgdW5pZm9ybVR5cGUsIHRoaXMuY291bnQgKTtcclxuXHJcblx0XHR9IGVsc2UgaWYgKCBBcnJheS5pc0FycmF5KCB0aGlzLmdldFZhbHVlRnJvbVJlZmVyZW5jZSgpICkgKSB7XHJcblxyXG5cdFx0XHRub2RlID0gdW5pZm9ybUFycmF5KCBudWxsLCB1bmlmb3JtVHlwZSApO1xyXG5cclxuXHRcdH0gZWxzZSBpZiAoIHVuaWZvcm1UeXBlID09PSAndGV4dHVyZScgKSB7XHJcblxyXG5cdFx0XHRub2RlID0gdGV4dHVyZSggbnVsbCApO1xyXG5cclxuXHRcdH0gZWxzZSBpZiAoIHVuaWZvcm1UeXBlID09PSAnY3ViZVRleHR1cmUnICkge1xyXG5cclxuXHRcdFx0bm9kZSA9IGN1YmVUZXh0dXJlKCBudWxsICk7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdG5vZGUgPSB1bmlmb3JtKCBudWxsLCB1bmlmb3JtVHlwZSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIHRoaXMuZ3JvdXAgIT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHRub2RlLnNldEdyb3VwKCB0aGlzLmdyb3VwICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggdGhpcy5uYW1lICE9PSBudWxsICkgbm9kZS5sYWJlbCggdGhpcy5uYW1lICk7XHJcblxyXG5cdFx0dGhpcy5ub2RlID0gbm9kZS5nZXRTZWxmKCk7XHJcblxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogVGhpcyBtZXRob2QgaXMgb3ZlcndyaXR0ZW4gc2luY2UgdGhlIG5vZGUgdHlwZSBpcyBpbmZlcnJlZCBmcm9tXHJcblx0ICogdGhlIHR5cGUgb2YgdGhlIHJlZmVyZW5jZSBub2RlLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtOb2RlQnVpbGRlcn0gYnVpbGRlciAtIFRoZSBjdXJyZW50IG5vZGUgYnVpbGRlci5cclxuXHQgKiBAcmV0dXJuIHtTdHJpbmd9IFRoZSBub2RlIHR5cGUuXHJcblx0ICovXHJcblx0Z2V0Tm9kZVR5cGUoIGJ1aWxkZXIgKSB7XHJcblxyXG5cdFx0aWYgKCB0aGlzLm5vZGUgPT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHR0aGlzLnVwZGF0ZVJlZmVyZW5jZSggYnVpbGRlciApO1xyXG5cdFx0XHR0aGlzLnVwZGF0ZVZhbHVlKCk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzLm5vZGUuZ2V0Tm9kZVR5cGUoIGJ1aWxkZXIgKTtcclxuXHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBSZXR1cm5zIHRoZSBwcm9wZXJ0eSB2YWx1ZSBmcm9tIHRoZSBnaXZlbiByZWZlcnJlZCBvYmplY3QuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge09iamVjdH0gW29iamVjdD10aGlzLnJlZmVyZW5jZV0gLSBUaGUgb2JqZWN0IHRvIHJldHJpZXZlIHRoZSBwcm9wZXJ0eSB2YWx1ZSBmcm9tLlxyXG5cdCAqIEByZXR1cm4ge0FueX0gVGhlIHZhbHVlLlxyXG5cdCAqL1xyXG5cdGdldFZhbHVlRnJvbVJlZmVyZW5jZSggb2JqZWN0ID0gdGhpcy5yZWZlcmVuY2UgKSB7XHJcblxyXG5cdFx0Y29uc3QgeyBwcm9wZXJ0aWVzIH0gPSB0aGlzO1xyXG5cclxuXHRcdGxldCB2YWx1ZSA9IG9iamVjdFsgcHJvcGVydGllc1sgMCBdIF07XHJcblxyXG5cdFx0Zm9yICggbGV0IGkgPSAxOyBpIDwgcHJvcGVydGllcy5sZW5ndGg7IGkgKysgKSB7XHJcblxyXG5cdFx0XHR2YWx1ZSA9IHZhbHVlWyBwcm9wZXJ0aWVzWyBpIF0gXTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHZhbHVlO1xyXG5cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEFsbG93cyB0byB1cGRhdGUgdGhlIHJlZmVyZW5jZSBiYXNlZCBvbiB0aGUgZ2l2ZW4gc3RhdGUuIFRoZSBzdGF0ZSBpcyBvbmx5XHJcblx0ICogZXZhbHVhdGVkIHtAbGluayBtb2R1bGU6UmVmZXJlbmNlTm9kZX5SZWZlcmVuY2VOb2RlI29iamVjdH0gaXMgbm90IHNldC5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7KE5vZGVGcmFtZXxOb2RlQnVpbGRlcil9IHN0YXRlIC0gVGhlIGN1cnJlbnQgc3RhdGUuXHJcblx0ICogQHJldHVybiB7T2JqZWN0fSBUaGUgdXBkYXRlZCByZWZlcmVuY2UuXHJcblx0ICovXHJcblx0dXBkYXRlUmVmZXJlbmNlKCBzdGF0ZSApIHtcclxuXHJcblx0XHR0aGlzLnJlZmVyZW5jZSA9IHRoaXMub2JqZWN0ICE9PSBudWxsID8gdGhpcy5vYmplY3QgOiBzdGF0ZS5vYmplY3Q7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMucmVmZXJlbmNlO1xyXG5cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFRoZSBvdXRwdXQgb2YgdGhlIHJlZmVyZW5jZSBub2RlIGlzIHRoZSBpbnRlcm5hbCB1bmlmb3JtIG5vZGUuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge05vZGVCdWlsZGVyfSBidWlsZGVyIC0gVGhlIGN1cnJlbnQgbm9kZSBidWlsZGVyLlxyXG5cdCAqIEByZXR1cm4ge1VuaWZvcm1Ob2RlfSBUaGUgb3V0cHV0IG5vZGUuXHJcblx0ICovXHJcblx0c2V0dXAoIC8qIGJ1aWxkZXIgKi8gKSB7XHJcblxyXG5cdFx0dGhpcy51cGRhdGVWYWx1ZSgpO1xyXG5cclxuXHRcdHJldHVybiB0aGlzLm5vZGU7XHJcblxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogT3ZlcndyaXR0ZW4gdG8gdG8gdXBkYXRlIHRoZSBpbnRlcm5hbCB1bmlmb3JtIHZhbHVlLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtOb2RlRnJhbWV9IGZyYW1lIC0gQSByZWZlcmVuY2UgdG8gdGhlIGN1cnJlbnQgbm9kZSBmcmFtZS5cclxuXHQgKi9cclxuXHR1cGRhdGUoIC8qZnJhbWUqLyApIHtcclxuXHJcblx0XHR0aGlzLnVwZGF0ZVZhbHVlKCk7XHJcblxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogUmV0cmlldmVzIHRoZSB2YWx1ZSBmcm9tIHRoZSByZWZlcnJlZCBvYmplY3QgcHJvcGVydHkgYW5kIHVzZXMgaXRcclxuXHQgKiB0byB1cGRhdGVkIHRoZSBpbnRlcm5hbCB1bmlmb3JtLlxyXG5cdCAqL1xyXG5cdHVwZGF0ZVZhbHVlKCkge1xyXG5cclxuXHRcdGlmICggdGhpcy5ub2RlID09PSBudWxsICkgdGhpcy5zZXROb2RlVHlwZSggdGhpcy51bmlmb3JtVHlwZSApO1xyXG5cclxuXHRcdGNvbnN0IHZhbHVlID0gdGhpcy5nZXRWYWx1ZUZyb21SZWZlcmVuY2UoKTtcclxuXHJcblx0XHRpZiAoIEFycmF5LmlzQXJyYXkoIHZhbHVlICkgKSB7XHJcblxyXG5cdFx0XHR0aGlzLm5vZGUuYXJyYXkgPSB2YWx1ZTtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0dGhpcy5ub2RlLnZhbHVlID0gdmFsdWU7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBSZWZlcmVuY2VOb2RlO1xyXG5cclxuLyoqXHJcbiAqIFRTTCBmdW5jdGlvbiBmb3IgY3JlYXRpbmcgYSByZWZlcmVuY2Ugbm9kZS5cclxuICpcclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIC0gVGhlIG5hbWUgb2YgdGhlIHByb3BlcnR5IHRoZSBub2RlIHJlZmVycyB0by5cclxuICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgLSBUaGUgdW5pZm9ybSB0eXBlIHRoYXQgc2hvdWxkIGJlIHVzZWQgdG8gcmVwcmVzZW50IHRoZSBwcm9wZXJ0eSB2YWx1ZS5cclxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCAtIFRoZSBvYmplY3QgdGhlIHByb3BlcnR5IGJlbG9uZ3MgdG8uXHJcbiAqIEByZXR1cm5zIHtSZWZlcmVuY2VOb2RlfVxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IHJlZmVyZW5jZSA9ICggbmFtZSwgdHlwZSwgb2JqZWN0ICkgPT4gbm9kZU9iamVjdCggbmV3IFJlZmVyZW5jZU5vZGUoIG5hbWUsIHR5cGUsIG9iamVjdCApICk7XHJcblxyXG4vKipcclxuICogVFNMIGZ1bmN0aW9uIGZvciBjcmVhdGluZyBhIHJlZmVyZW5jZSBub2RlLlxyXG4gKlxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgcHJvcGVydHkgdGhlIG5vZGUgcmVmZXJzIHRvLlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZSAtIFRoZSB1bmlmb3JtIHR5cGUgdGhhdCBzaG91bGQgYmUgdXNlZCB0byByZXByZXNlbnQgdGhlIHByb3BlcnR5IHZhbHVlLlxyXG4gKiBAcGFyYW0ge051bWJlcn0gY291bnQgLSBUaGUgbnVtYmVyIG9mIHZhbHVlIGluc2lkZSB0aGUgYXJyYXktbGlrZSBvYmplY3QuXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgLSBBbiBhcnJheS1saWtlIG9iamVjdCB0aGUgcHJvcGVydHkgYmVsb25ncyB0by5cclxuICogQHJldHVybnMge1JlZmVyZW5jZU5vZGV9XHJcbiAqL1xyXG5leHBvcnQgY29uc3QgcmVmZXJlbmNlQnVmZmVyID0gKCBuYW1lLCB0eXBlLCBjb3VudCwgb2JqZWN0ICkgPT4gbm9kZU9iamVjdCggbmV3IFJlZmVyZW5jZU5vZGUoIG5hbWUsIHR5cGUsIG9iamVjdCwgY291bnQgKSApO1xyXG4iLCJpbXBvcnQgUmVmZXJlbmNlTm9kZSBmcm9tICcuL1JlZmVyZW5jZU5vZGUuanMnO1xyXG4vL2ltcG9ydCB7IHJlbmRlckdyb3VwIH0gZnJvbSAnLi4vY29yZS9Vbmlmb3JtR3JvdXBOb2RlLmpzJztcclxuLy9pbXBvcnQgeyBOb2RlVXBkYXRlVHlwZSB9IGZyb20gJy4uL2NvcmUvY29uc3RhbnRzLmpzJztcclxuaW1wb3J0IHsgbm9kZU9iamVjdCB9IGZyb20gJy4uL3RzbC9UU0xCYXNlLmpzJztcclxuXHJcbmNsYXNzIE1hdGVyaWFsUmVmZXJlbmNlTm9kZSBleHRlbmRzIFJlZmVyZW5jZU5vZGUge1xyXG5cclxuXHRzdGF0aWMgZ2V0IHR5cGUoKSB7XHJcblxyXG5cdFx0cmV0dXJuICdNYXRlcmlhbFJlZmVyZW5jZU5vZGUnO1xyXG5cclxuXHR9XHJcblxyXG5cdGNvbnN0cnVjdG9yKCBwcm9wZXJ0eSwgaW5wdXRUeXBlLCBtYXRlcmlhbCA9IG51bGwgKSB7XHJcblxyXG5cdFx0c3VwZXIoIHByb3BlcnR5LCBpbnB1dFR5cGUsIG1hdGVyaWFsICk7XHJcblxyXG5cdFx0dGhpcy5tYXRlcmlhbCA9IG1hdGVyaWFsO1xyXG5cclxuXHRcdC8vdGhpcy51cGRhdGVUeXBlID0gTm9kZVVwZGF0ZVR5cGUuUkVOREVSO1xyXG5cclxuXHRcdHRoaXMuaXNNYXRlcmlhbFJlZmVyZW5jZU5vZGUgPSB0cnVlO1xyXG5cclxuXHR9XHJcblxyXG5cdC8qc2V0Tm9kZVR5cGUoIG5vZGUgKSB7XHJcblxyXG5cdFx0c3VwZXIuc2V0Tm9kZVR5cGUoIG5vZGUgKTtcclxuXHJcblx0XHR0aGlzLm5vZGUuZ3JvdXBOb2RlID0gcmVuZGVyR3JvdXA7XHJcblxyXG5cdH0qL1xyXG5cclxuXHR1cGRhdGVSZWZlcmVuY2UoIHN0YXRlICkge1xyXG5cclxuXHRcdHRoaXMucmVmZXJlbmNlID0gdGhpcy5tYXRlcmlhbCAhPT0gbnVsbCA/IHRoaXMubWF0ZXJpYWwgOiBzdGF0ZS5tYXRlcmlhbDtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5yZWZlcmVuY2U7XHJcblxyXG5cdH1cclxuXHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IE1hdGVyaWFsUmVmZXJlbmNlTm9kZTtcclxuXHJcbmV4cG9ydCBjb25zdCBtYXRlcmlhbFJlZmVyZW5jZSA9ICggbmFtZSwgdHlwZSwgbWF0ZXJpYWwgKSA9PiBub2RlT2JqZWN0KCBuZXcgTWF0ZXJpYWxSZWZlcmVuY2VOb2RlKCBuYW1lLCB0eXBlLCBtYXRlcmlhbCApICk7XHJcbiIsImltcG9ydCB7IGF0dHJpYnV0ZSB9IGZyb20gJy4uL2NvcmUvQXR0cmlidXRlTm9kZS5qcyc7XHJcbmltcG9ydCB7IGNhbWVyYVZpZXdNYXRyaXggfSBmcm9tICcuL0NhbWVyYS5qcyc7XHJcbmltcG9ydCB7IG1vZGVsVmlld01hdHJpeCB9IGZyb20gJy4vTW9kZWxOb2RlLmpzJztcclxuaW1wb3J0IHsgRm4sIHZlYzQgfSBmcm9tICcuLi90c2wvVFNMQmFzZS5qcyc7XHJcblxyXG4vKiogQG1vZHVsZSBUYW5nZW50ICoqL1xyXG5cclxuLyoqXHJcbiAqIFRTTCBvYmplY3QgdGhhdCByZXByZXNlbnRzIHRoZSB0YW5nZW50IGF0dHJpYnV0ZSBvZiB0aGUgY3VycmVudCByZW5kZXJlZCBvYmplY3QuXHJcbiAqXHJcbiAqIEB0eXBlIHtOb2RlPHZlYzQ+fVxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IHRhbmdlbnRHZW9tZXRyeSA9IC8qQF9fUFVSRV9fKi8gRm4oICggYnVpbGRlciApID0+IHtcclxuXHJcblx0aWYgKCBidWlsZGVyLmdlb21ldHJ5Lmhhc0F0dHJpYnV0ZSggJ3RhbmdlbnQnICkgPT09IGZhbHNlICkge1xyXG5cclxuXHRcdGJ1aWxkZXIuZ2VvbWV0cnkuY29tcHV0ZVRhbmdlbnRzKCk7XHJcblxyXG5cdH1cclxuXHJcblx0cmV0dXJuIGF0dHJpYnV0ZSggJ3RhbmdlbnQnLCAndmVjNCcgKTtcclxuXHJcbn0gKSgpO1xyXG5cclxuLyoqXHJcbiAqIFRTTCBvYmplY3QgdGhhdCByZXByZXNlbnRzIHRoZSB2ZXJ0ZXggdGFuZ2VudCBpbiBsb2NhbCBzcGFjZSBvZiB0aGUgY3VycmVudCByZW5kZXJlZCBvYmplY3QuXHJcbiAqXHJcbiAqIEB0eXBlIHtOb2RlPHZlYzQ+fVxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IHRhbmdlbnRMb2NhbCA9IC8qQF9fUFVSRV9fKi8gdGFuZ2VudEdlb21ldHJ5Lnh5ei50b1ZhciggJ3RhbmdlbnRMb2NhbCcgKTtcclxuXHJcbi8qKlxyXG4gKiBUU0wgb2JqZWN0IHRoYXQgcmVwcmVzZW50cyB0aGUgdmVydGV4IHRhbmdlbnQgaW4gdmlldyBzcGFjZSBvZiB0aGUgY3VycmVudCByZW5kZXJlZCBvYmplY3QuXHJcbiAqXHJcbiAqIEB0eXBlIHtOb2RlPHZlYzQ+fVxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IHRhbmdlbnRWaWV3ID0gLypAX19QVVJFX18qLyBtb2RlbFZpZXdNYXRyaXgubXVsKCB2ZWM0KCB0YW5nZW50TG9jYWwsIDAgKSApLnh5ei52YXJ5aW5nKCAndl90YW5nZW50VmlldycgKS5ub3JtYWxpemUoKS50b1ZhciggJ3RhbmdlbnRWaWV3JyApO1xyXG5cclxuLyoqXHJcbiAqIFRTTCBvYmplY3QgdGhhdCByZXByZXNlbnRzIHRoZSB2ZXJ0ZXggdGFuZ2VudCBpbiB3b3JsZCBzcGFjZSBvZiB0aGUgY3VycmVudCByZW5kZXJlZCBvYmplY3QuXHJcbiAqXHJcbiAqIEB0eXBlIHtOb2RlPHZlYzQ+fVxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IHRhbmdlbnRXb3JsZCA9IC8qQF9fUFVSRV9fKi8gdGFuZ2VudFZpZXcudHJhbnNmb3JtRGlyZWN0aW9uKCBjYW1lcmFWaWV3TWF0cml4ICkudmFyeWluZyggJ3ZfdGFuZ2VudFdvcmxkJyApLm5vcm1hbGl6ZSgpLnRvVmFyKCAndGFuZ2VudFdvcmxkJyApO1xyXG5cclxuLyoqXHJcbiAqIFRTTCBvYmplY3QgdGhhdCByZXByZXNlbnRzIHRoZSB0cmFuc2Zvcm1lZCB2ZXJ0ZXggdGFuZ2VudCBpbiB2aWV3IHNwYWNlIG9mIHRoZSBjdXJyZW50IHJlbmRlcmVkIG9iamVjdC5cclxuICpcclxuICogQHR5cGUge05vZGU8dmVjND59XHJcbiAqL1xyXG5leHBvcnQgY29uc3QgdHJhbnNmb3JtZWRUYW5nZW50VmlldyA9IC8qQF9fUFVSRV9fKi8gdGFuZ2VudFZpZXcudG9WYXIoICd0cmFuc2Zvcm1lZFRhbmdlbnRWaWV3JyApO1xyXG5cclxuLyoqXHJcbiAqIFRTTCBvYmplY3QgdGhhdCByZXByZXNlbnRzIHRoZSB0cmFuc2Zvcm1lZCB2ZXJ0ZXggdGFuZ2VudCBpbiB3b3JsZCBzcGFjZSBvZiB0aGUgY3VycmVudCByZW5kZXJlZCBvYmplY3QuXHJcbiAqXHJcbiAqIEB0eXBlIHtOb2RlPHZlYzQ+fVxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IHRyYW5zZm9ybWVkVGFuZ2VudFdvcmxkID0gLypAX19QVVJFX18qLyB0cmFuc2Zvcm1lZFRhbmdlbnRWaWV3LnRyYW5zZm9ybURpcmVjdGlvbiggY2FtZXJhVmlld01hdHJpeCApLm5vcm1hbGl6ZSgpLnRvVmFyKCAndHJhbnNmb3JtZWRUYW5nZW50V29ybGQnICk7XHJcbiIsImltcG9ydCB7IHZhcnlpbmcgfSBmcm9tICcuLi9jb3JlL1ZhcnlpbmdOb2RlLmpzJztcclxuaW1wb3J0IHsgY2FtZXJhVmlld01hdHJpeCB9IGZyb20gJy4vQ2FtZXJhLmpzJztcclxuaW1wb3J0IHsgbm9ybWFsR2VvbWV0cnksIG5vcm1hbExvY2FsLCBub3JtYWxWaWV3LCBub3JtYWxXb3JsZCwgdHJhbnNmb3JtZWROb3JtYWxWaWV3IH0gZnJvbSAnLi9Ob3JtYWwuanMnO1xyXG5pbXBvcnQgeyB0YW5nZW50R2VvbWV0cnksIHRhbmdlbnRMb2NhbCwgdGFuZ2VudFZpZXcsIHRhbmdlbnRXb3JsZCwgdHJhbnNmb3JtZWRUYW5nZW50VmlldyB9IGZyb20gJy4vVGFuZ2VudC5qcyc7XHJcblxyXG5jb25zdCBnZXRCaXRhbmdlbnQgPSAoIGNyb3NzTm9ybWFsVGFuZ2VudCApID0+IGNyb3NzTm9ybWFsVGFuZ2VudC5tdWwoIHRhbmdlbnRHZW9tZXRyeS53ICkueHl6O1xyXG5cclxuZXhwb3J0IGNvbnN0IGJpdGFuZ2VudEdlb21ldHJ5ID0gLypAX19QVVJFX18qLyB2YXJ5aW5nKCBnZXRCaXRhbmdlbnQoIG5vcm1hbEdlb21ldHJ5LmNyb3NzKCB0YW5nZW50R2VvbWV0cnkgKSApLCAndl9iaXRhbmdlbnRHZW9tZXRyeScgKS5ub3JtYWxpemUoKS50b1ZhciggJ2JpdGFuZ2VudEdlb21ldHJ5JyApO1xyXG5leHBvcnQgY29uc3QgYml0YW5nZW50TG9jYWwgPSAvKkBfX1BVUkVfXyovIHZhcnlpbmcoIGdldEJpdGFuZ2VudCggbm9ybWFsTG9jYWwuY3Jvc3MoIHRhbmdlbnRMb2NhbCApICksICd2X2JpdGFuZ2VudExvY2FsJyApLm5vcm1hbGl6ZSgpLnRvVmFyKCAnYml0YW5nZW50TG9jYWwnICk7XHJcbmV4cG9ydCBjb25zdCBiaXRhbmdlbnRWaWV3ID0gLypAX19QVVJFX18qLyB2YXJ5aW5nKCBnZXRCaXRhbmdlbnQoIG5vcm1hbFZpZXcuY3Jvc3MoIHRhbmdlbnRWaWV3ICkgKSwgJ3ZfYml0YW5nZW50VmlldycgKS5ub3JtYWxpemUoKS50b1ZhciggJ2JpdGFuZ2VudFZpZXcnICk7XHJcbmV4cG9ydCBjb25zdCBiaXRhbmdlbnRXb3JsZCA9IC8qQF9fUFVSRV9fKi8gdmFyeWluZyggZ2V0Qml0YW5nZW50KCBub3JtYWxXb3JsZC5jcm9zcyggdGFuZ2VudFdvcmxkICkgKSwgJ3ZfYml0YW5nZW50V29ybGQnICkubm9ybWFsaXplKCkudG9WYXIoICdiaXRhbmdlbnRXb3JsZCcgKTtcclxuZXhwb3J0IGNvbnN0IHRyYW5zZm9ybWVkQml0YW5nZW50VmlldyA9IC8qQF9fUFVSRV9fKi8gZ2V0Qml0YW5nZW50KCB0cmFuc2Zvcm1lZE5vcm1hbFZpZXcuY3Jvc3MoIHRyYW5zZm9ybWVkVGFuZ2VudFZpZXcgKSApLm5vcm1hbGl6ZSgpLnRvVmFyKCAndHJhbnNmb3JtZWRCaXRhbmdlbnRWaWV3JyApO1xyXG5leHBvcnQgY29uc3QgdHJhbnNmb3JtZWRCaXRhbmdlbnRXb3JsZCA9IC8qQF9fUFVSRV9fKi8gdHJhbnNmb3JtZWRCaXRhbmdlbnRWaWV3LnRyYW5zZm9ybURpcmVjdGlvbiggY2FtZXJhVmlld01hdHJpeCApLm5vcm1hbGl6ZSgpLnRvVmFyKCAndHJhbnNmb3JtZWRCaXRhbmdlbnRXb3JsZCcgKTtcclxuIiwiaW1wb3J0IHsgYml0YW5nZW50VmlldyB9IGZyb20gJy4vQml0YW5nZW50LmpzJztcclxuaW1wb3J0IHsgbm9ybWFsVmlldywgdHJhbnNmb3JtZWROb3JtYWxWaWV3IH0gZnJvbSAnLi9Ob3JtYWwuanMnO1xyXG5pbXBvcnQgeyB0YW5nZW50VmlldyB9IGZyb20gJy4vVGFuZ2VudC5qcyc7XHJcbmltcG9ydCB7IG1hdDMgfSBmcm9tICcuLi90c2wvVFNMQmFzZS5qcyc7XHJcbmltcG9ydCB7IG1peCB9IGZyb20gJy4uL21hdGgvTWF0aE5vZGUuanMnO1xyXG5pbXBvcnQgeyBhbmlzb3Ryb3B5LCBhbmlzb3Ryb3B5Qiwgcm91Z2huZXNzIH0gZnJvbSAnLi4vY29yZS9Qcm9wZXJ0eU5vZGUuanMnO1xyXG5pbXBvcnQgeyBwb3NpdGlvblZpZXdEaXJlY3Rpb24gfSBmcm9tICcuL1Bvc2l0aW9uLmpzJztcclxuXHJcbmV4cG9ydCBjb25zdCBUQk5WaWV3TWF0cml4ID0gLypAX19QVVJFX18qLyBtYXQzKCB0YW5nZW50VmlldywgYml0YW5nZW50Vmlldywgbm9ybWFsVmlldyApO1xyXG5cclxuZXhwb3J0IGNvbnN0IHBhcmFsbGF4RGlyZWN0aW9uID0gLypAX19QVVJFX18qLyBwb3NpdGlvblZpZXdEaXJlY3Rpb24ubXVsKCBUQk5WaWV3TWF0cml4ICkvKi5ub3JtYWxpemUoKSovO1xyXG5leHBvcnQgY29uc3QgcGFyYWxsYXhVViA9ICggdXYsIHNjYWxlICkgPT4gdXYuc3ViKCBwYXJhbGxheERpcmVjdGlvbi5tdWwoIHNjYWxlICkgKTtcclxuXHJcbmV4cG9ydCBjb25zdCB0cmFuc2Zvcm1lZEJlbnROb3JtYWxWaWV3ID0gLypAX19QVVJFX18qLyAoICgpID0+IHtcclxuXHJcblx0Ly8gaHR0cHM6Ly9nb29nbGUuZ2l0aHViLmlvL2ZpbGFtZW50L0ZpbGFtZW50Lm1kLmh0bWwjbGlnaHRpbmcvaW1hZ2ViYXNlZGxpZ2h0cy9hbmlzb3Ryb3B5XHJcblxyXG5cdGxldCBiZW50Tm9ybWFsID0gYW5pc290cm9weUIuY3Jvc3MoIHBvc2l0aW9uVmlld0RpcmVjdGlvbiApO1xyXG5cdGJlbnROb3JtYWwgPSBiZW50Tm9ybWFsLmNyb3NzKCBhbmlzb3Ryb3B5QiApLm5vcm1hbGl6ZSgpO1xyXG5cdGJlbnROb3JtYWwgPSBtaXgoIGJlbnROb3JtYWwsIHRyYW5zZm9ybWVkTm9ybWFsVmlldywgYW5pc290cm9weS5tdWwoIHJvdWdobmVzcy5vbmVNaW51cygpICkub25lTWludXMoKS5wb3cyKCkucG93MigpICkubm9ybWFsaXplKCk7XHJcblxyXG5cdHJldHVybiBiZW50Tm9ybWFsO1xyXG5cclxuXHJcbn0gKSgpO1xyXG4iLCJpbXBvcnQgVGVtcE5vZGUgZnJvbSAnLi4vY29yZS9UZW1wTm9kZS5qcyc7XHJcbmltcG9ydCB7IGFkZCB9IGZyb20gJy4uL21hdGgvT3BlcmF0b3JOb2RlLmpzJztcclxuXHJcbmltcG9ydCB7IG5vcm1hbFZpZXcsIHRyYW5zZm9ybU5vcm1hbFRvVmlldyB9IGZyb20gJy4uL2FjY2Vzc29ycy9Ob3JtYWwuanMnO1xyXG5pbXBvcnQgeyBwb3NpdGlvblZpZXcgfSBmcm9tICcuLi9hY2Nlc3NvcnMvUG9zaXRpb24uanMnO1xyXG5pbXBvcnQgeyBUQk5WaWV3TWF0cml4IH0gZnJvbSAnLi4vYWNjZXNzb3JzL0FjY2Vzc29yc1V0aWxzLmpzJztcclxuaW1wb3J0IHsgdXYgfSBmcm9tICcuLi9hY2Nlc3NvcnMvVVYuanMnO1xyXG5pbXBvcnQgeyBmYWNlRGlyZWN0aW9uIH0gZnJvbSAnLi9Gcm9udEZhY2luZ05vZGUuanMnO1xyXG5pbXBvcnQgeyBGbiwgbm9kZVByb3h5LCB2ZWMzIH0gZnJvbSAnLi4vdHNsL1RTTEJhc2UuanMnO1xyXG5cclxuaW1wb3J0IHsgVGFuZ2VudFNwYWNlTm9ybWFsTWFwLCBPYmplY3RTcGFjZU5vcm1hbE1hcCB9IGZyb20gJy4uLy4uL2NvbnN0YW50cy5qcyc7XHJcblxyXG4vKiogQG1vZHVsZSBOb3JtYWxNYXBOb2RlICoqL1xyXG5cclxuLy8gTm9ybWFsIE1hcHBpbmcgV2l0aG91dCBQcmVjb21wdXRlZCBUYW5nZW50c1xyXG4vLyBodHRwOi8vd3d3LnRoZXRlbnRocGxhbmV0LmRlL2FyY2hpdmVzLzExODBcclxuXHJcbmNvbnN0IHBlcnR1cmJOb3JtYWwyQXJiID0gLypAX19QVVJFX18qLyBGbiggKCBpbnB1dHMgKSA9PiB7XHJcblxyXG5cdGNvbnN0IHsgZXllX3Bvcywgc3VyZl9ub3JtLCBtYXBOLCB1diB9ID0gaW5wdXRzO1xyXG5cclxuXHRjb25zdCBxMCA9IGV5ZV9wb3MuZEZkeCgpO1xyXG5cdGNvbnN0IHExID0gZXllX3Bvcy5kRmR5KCk7XHJcblx0Y29uc3Qgc3QwID0gdXYuZEZkeCgpO1xyXG5cdGNvbnN0IHN0MSA9IHV2LmRGZHkoKTtcclxuXHJcblx0Y29uc3QgTiA9IHN1cmZfbm9ybTsgLy8gbm9ybWFsaXplZFxyXG5cclxuXHRjb25zdCBxMXBlcnAgPSBxMS5jcm9zcyggTiApO1xyXG5cdGNvbnN0IHEwcGVycCA9IE4uY3Jvc3MoIHEwICk7XHJcblxyXG5cdGNvbnN0IFQgPSBxMXBlcnAubXVsKCBzdDAueCApLmFkZCggcTBwZXJwLm11bCggc3QxLnggKSApO1xyXG5cdGNvbnN0IEIgPSBxMXBlcnAubXVsKCBzdDAueSApLmFkZCggcTBwZXJwLm11bCggc3QxLnkgKSApO1xyXG5cclxuXHRjb25zdCBkZXQgPSBULmRvdCggVCApLm1heCggQi5kb3QoIEIgKSApO1xyXG5cdGNvbnN0IHNjYWxlID0gZmFjZURpcmVjdGlvbi5tdWwoIGRldC5pbnZlcnNlU3FydCgpICk7XHJcblxyXG5cdHJldHVybiBhZGQoIFQubXVsKCBtYXBOLngsIHNjYWxlICksIEIubXVsKCBtYXBOLnksIHNjYWxlICksIE4ubXVsKCBtYXBOLnogKSApLm5vcm1hbGl6ZSgpO1xyXG5cclxufSApO1xyXG5cclxuLyoqXHJcbiAqIFRoaXMgY2xhc3MgY2FuIGJlIHVzZWQgZm9yIGFwcGx5aW5nIG5vcm1hbHMgbWFwcyB0byBtYXRlcmlhbHMuXHJcbiAqXHJcbiAqIGBgYGpzXHJcbiAqIG1hdGVyaWFsLm5vcm1hbE5vZGUgPSBub3JtYWxNYXAoIHRleHR1cmUoIG5vcm1hbFRleCApICk7XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBAYXVnbWVudHMgVGVtcE5vZGVcclxuICovXHJcbmNsYXNzIE5vcm1hbE1hcE5vZGUgZXh0ZW5kcyBUZW1wTm9kZSB7XHJcblxyXG5cdHN0YXRpYyBnZXQgdHlwZSgpIHtcclxuXHJcblx0XHRyZXR1cm4gJ05vcm1hbE1hcE5vZGUnO1xyXG5cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIENvbnN0cnVjdHMgYSBuZXcgbm9ybWFsIG1hcCBub2RlLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtOb2RlfSBub2RlIC0gUmVwcmVzZW50cyB0aGUgbm9ybWFsIG1hcCBkYXRhLlxyXG5cdCAqIEBwYXJhbSB7Tm9kZT99IFtzY2FsZU5vZGU9bnVsbF0gLSBDb250cm9scyB0aGUgaW50ZW5zaXR5IG9mIHRoZSBlZmZlY3QuXHJcblx0ICovXHJcblx0Y29uc3RydWN0b3IoIG5vZGUsIHNjYWxlTm9kZSA9IG51bGwgKSB7XHJcblxyXG5cdFx0c3VwZXIoICd2ZWMzJyApO1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogUmVwcmVzZW50cyB0aGUgbm9ybWFsIG1hcCBkYXRhLlxyXG5cdFx0ICpcclxuXHRcdCAqIEB0eXBlIHtOb2RlfVxyXG5cdFx0ICovXHJcblx0XHR0aGlzLm5vZGUgPSBub2RlO1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogQ29udHJvbHMgdGhlIGludGVuc2l0eSBvZiB0aGUgZWZmZWN0LlxyXG5cdFx0ICpcclxuXHRcdCAqIEB0eXBlIHtOb2RlP31cclxuXHRcdCAqIEBkZWZhdWx0IG51bGxcclxuXHRcdCAqL1xyXG5cdFx0dGhpcy5zY2FsZU5vZGUgPSBzY2FsZU5vZGU7XHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBUaGUgbm9ybWFsIG1hcCB0eXBlLlxyXG5cdFx0ICpcclxuXHRcdCAqIEB0eXBlIHsoVGFuZ2VudFNwYWNlTm9ybWFsTWFwfE9iamVjdFNwYWNlTm9ybWFsTWFwKX1cclxuXHRcdCAqIEBkZWZhdWx0IFRhbmdlbnRTcGFjZU5vcm1hbE1hcFxyXG5cdFx0ICovXHJcblx0XHR0aGlzLm5vcm1hbE1hcFR5cGUgPSBUYW5nZW50U3BhY2VOb3JtYWxNYXA7XHJcblxyXG5cdH1cclxuXHJcblx0c2V0dXAoIGJ1aWxkZXIgKSB7XHJcblxyXG5cdFx0Y29uc3QgeyBub3JtYWxNYXBUeXBlLCBzY2FsZU5vZGUgfSA9IHRoaXM7XHJcblxyXG5cdFx0bGV0IG5vcm1hbE1hcCA9IHRoaXMubm9kZS5tdWwoIDIuMCApLnN1YiggMS4wICk7XHJcblxyXG5cdFx0aWYgKCBzY2FsZU5vZGUgIT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHRub3JtYWxNYXAgPSB2ZWMzKCBub3JtYWxNYXAueHkubXVsKCBzY2FsZU5vZGUgKSwgbm9ybWFsTWFwLnogKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0bGV0IG91dHB1dE5vZGUgPSBudWxsO1xyXG5cclxuXHRcdGlmICggbm9ybWFsTWFwVHlwZSA9PT0gT2JqZWN0U3BhY2VOb3JtYWxNYXAgKSB7XHJcblxyXG5cdFx0XHRvdXRwdXROb2RlID0gdHJhbnNmb3JtTm9ybWFsVG9WaWV3KCBub3JtYWxNYXAgKTtcclxuXHJcblx0XHR9IGVsc2UgaWYgKCBub3JtYWxNYXBUeXBlID09PSBUYW5nZW50U3BhY2VOb3JtYWxNYXAgKSB7XHJcblxyXG5cdFx0XHRjb25zdCB0YW5nZW50ID0gYnVpbGRlci5oYXNHZW9tZXRyeUF0dHJpYnV0ZSggJ3RhbmdlbnQnICk7XHJcblxyXG5cdFx0XHRpZiAoIHRhbmdlbnQgPT09IHRydWUgKSB7XHJcblxyXG5cdFx0XHRcdG91dHB1dE5vZGUgPSBUQk5WaWV3TWF0cml4Lm11bCggbm9ybWFsTWFwICkubm9ybWFsaXplKCk7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRvdXRwdXROb2RlID0gcGVydHVyYk5vcm1hbDJBcmIoIHtcclxuXHRcdFx0XHRcdGV5ZV9wb3M6IHBvc2l0aW9uVmlldyxcclxuXHRcdFx0XHRcdHN1cmZfbm9ybTogbm9ybWFsVmlldyxcclxuXHRcdFx0XHRcdG1hcE46IG5vcm1hbE1hcCxcclxuXHRcdFx0XHRcdHV2OiB1digpXHJcblx0XHRcdFx0fSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gb3V0cHV0Tm9kZTtcclxuXHJcblx0fVxyXG5cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgTm9ybWFsTWFwTm9kZTtcclxuXHJcbi8qKlxyXG4gKiBUU0wgZnVuY3Rpb24gZm9yIGNyZWF0aW5nIGEgbm9ybWFsIG1hcCBub2RlLlxyXG4gKlxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHtOb2RlfSBub2RlIC0gUmVwcmVzZW50cyB0aGUgbm9ybWFsIG1hcCBkYXRhLlxyXG4gKiBAcGFyYW0ge05vZGU/fSBbc2NhbGVOb2RlPW51bGxdIC0gQ29udHJvbHMgdGhlIGludGVuc2l0eSBvZiB0aGUgZWZmZWN0LlxyXG4gKiBAcmV0dXJucyB7Tm9ybWFsTWFwTm9kZX1cclxuICovXHJcbmV4cG9ydCBjb25zdCBub3JtYWxNYXAgPSAvKkBfX1BVUkVfXyovIG5vZGVQcm94eSggTm9ybWFsTWFwTm9kZSApO1xyXG4iLCJpbXBvcnQgVGVtcE5vZGUgZnJvbSAnLi4vY29yZS9UZW1wTm9kZS5qcyc7XHJcbmltcG9ydCB7IHV2IH0gZnJvbSAnLi4vYWNjZXNzb3JzL1VWLmpzJztcclxuaW1wb3J0IHsgbm9ybWFsVmlldyB9IGZyb20gJy4uL2FjY2Vzc29ycy9Ob3JtYWwuanMnO1xyXG5pbXBvcnQgeyBwb3NpdGlvblZpZXcgfSBmcm9tICcuLi9hY2Nlc3NvcnMvUG9zaXRpb24uanMnO1xyXG5pbXBvcnQgeyBmYWNlRGlyZWN0aW9uIH0gZnJvbSAnLi9Gcm9udEZhY2luZ05vZGUuanMnO1xyXG5pbXBvcnQgeyBGbiwgbm9kZVByb3h5LCBmbG9hdCwgdmVjMiB9IGZyb20gJy4uL3RzbC9UU0xCYXNlLmpzJztcclxuXHJcbi8qKiBAbW9kdWxlIEJ1bXBNYXBOb2RlICoqL1xyXG5cclxuLy8gQnVtcCBNYXBwaW5nIFVucGFyYW1ldHJpemVkIFN1cmZhY2VzIG9uIHRoZSBHUFUgYnkgTW9ydGVuIFMuIE1pa2tlbHNlblxyXG4vLyBodHRwczovL21taWtrLmdpdGh1Yi5pby9wYXBlcnMzZC9tbV9zZmdyYWRfYnVtcC5wZGZcclxuXHJcbmNvbnN0IGRIZHh5X2Z3ZCA9IEZuKCAoIHsgdGV4dHVyZU5vZGUsIGJ1bXBTY2FsZSB9ICkgPT4ge1xyXG5cclxuXHQvLyBJdCdzIHVzZWQgdG8gcHJlc2VydmUgdGhlIHNhbWUgVGV4dHVyZU5vZGUgaW5zdGFuY2VcclxuXHRjb25zdCBzYW1wbGVUZXh0dXJlID0gKCBjYWxsYmFjayApID0+IHRleHR1cmVOb2RlLmNhY2hlKCkuY29udGV4dCggeyBnZXRVVjogKCB0ZXhOb2RlICkgPT4gY2FsbGJhY2soIHRleE5vZGUudXZOb2RlIHx8IHV2KCkgKSwgZm9yY2VVVkNvbnRleHQ6IHRydWUgfSApO1xyXG5cclxuXHRjb25zdCBIbGwgPSBmbG9hdCggc2FtcGxlVGV4dHVyZSggKCB1dk5vZGUgKSA9PiB1dk5vZGUgKSApO1xyXG5cclxuXHRyZXR1cm4gdmVjMihcclxuXHRcdGZsb2F0KCBzYW1wbGVUZXh0dXJlKCAoIHV2Tm9kZSApID0+IHV2Tm9kZS5hZGQoIHV2Tm9kZS5kRmR4KCkgKSApICkuc3ViKCBIbGwgKSxcclxuXHRcdGZsb2F0KCBzYW1wbGVUZXh0dXJlKCAoIHV2Tm9kZSApID0+IHV2Tm9kZS5hZGQoIHV2Tm9kZS5kRmR5KCkgKSApICkuc3ViKCBIbGwgKVxyXG5cdCkubXVsKCBidW1wU2NhbGUgKTtcclxuXHJcbn0gKTtcclxuXHJcbi8vIEV2YWx1YXRlIHRoZSBkZXJpdmF0aXZlIG9mIHRoZSBoZWlnaHQgdy5yLnQuIHNjcmVlbi1zcGFjZSB1c2luZyBmb3J3YXJkIGRpZmZlcmVuY2luZyAobGlzdGluZyAyKVxyXG5cclxuY29uc3QgcGVydHVyYk5vcm1hbEFyYiA9IEZuKCAoIGlucHV0cyApID0+IHtcclxuXHJcblx0Y29uc3QgeyBzdXJmX3Bvcywgc3VyZl9ub3JtLCBkSGR4eSB9ID0gaW5wdXRzO1xyXG5cclxuXHQvLyBub3JtYWxpemUgaXMgZG9uZSB0byBlbnN1cmUgdGhhdCB0aGUgYnVtcCBtYXAgbG9va3MgdGhlIHNhbWUgcmVnYXJkbGVzcyBvZiB0aGUgdGV4dHVyZSdzIHNjYWxlXHJcblx0Y29uc3QgdlNpZ21hWCA9IHN1cmZfcG9zLmRGZHgoKS5ub3JtYWxpemUoKTtcclxuXHRjb25zdCB2U2lnbWFZID0gc3VyZl9wb3MuZEZkeSgpLm5vcm1hbGl6ZSgpO1xyXG5cdGNvbnN0IHZOID0gc3VyZl9ub3JtOyAvLyBub3JtYWxpemVkXHJcblxyXG5cdGNvbnN0IFIxID0gdlNpZ21hWS5jcm9zcyggdk4gKTtcclxuXHRjb25zdCBSMiA9IHZOLmNyb3NzKCB2U2lnbWFYICk7XHJcblxyXG5cdGNvbnN0IGZEZXQgPSB2U2lnbWFYLmRvdCggUjEgKS5tdWwoIGZhY2VEaXJlY3Rpb24gKTtcclxuXHJcblx0Y29uc3QgdkdyYWQgPSBmRGV0LnNpZ24oKS5tdWwoIGRIZHh5LngubXVsKCBSMSApLmFkZCggZEhkeHkueS5tdWwoIFIyICkgKSApO1xyXG5cclxuXHRyZXR1cm4gZkRldC5hYnMoKS5tdWwoIHN1cmZfbm9ybSApLnN1YiggdkdyYWQgKS5ub3JtYWxpemUoKTtcclxuXHJcbn0gKTtcclxuXHJcbi8qKlxyXG4gKiBUaGlzIGNsYXNzIGNhbiBiZSB1c2VkIGZvciBhcHBseWluZyBidW1wIG1hcHMgdG8gbWF0ZXJpYWxzLlxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiBtYXRlcmlhbC5ub3JtYWxOb2RlID0gYnVtcE1hcCggdGV4dHVyZSggYnVtcFRleCApICk7XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBAYXVnbWVudHMgVGVtcE5vZGVcclxuICovXHJcbmNsYXNzIEJ1bXBNYXBOb2RlIGV4dGVuZHMgVGVtcE5vZGUge1xyXG5cclxuXHRzdGF0aWMgZ2V0IHR5cGUoKSB7XHJcblxyXG5cdFx0cmV0dXJuICdCdW1wTWFwTm9kZSc7XHJcblxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogQ29uc3RydWN0cyBhIG5ldyBidW1wIG1hcCBub2RlLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtOb2RlfSB0ZXh0dXJlTm9kZSAtIFJlcHJlc2VudHMgdGhlIGJ1bXAgbWFwIGRhdGEuXHJcblx0ICogQHBhcmFtIHtOb2RlP30gW3NjYWxlTm9kZT1udWxsXSAtIENvbnRyb2xzIHRoZSBpbnRlbnNpdHkgb2YgdGhlIGJ1bXAgZWZmZWN0LlxyXG5cdCAqL1xyXG5cdGNvbnN0cnVjdG9yKCB0ZXh0dXJlTm9kZSwgc2NhbGVOb2RlID0gbnVsbCApIHtcclxuXHJcblx0XHRzdXBlciggJ3ZlYzMnICk7XHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBSZXByZXNlbnRzIHRoZSBidW1wIG1hcCBkYXRhLlxyXG5cdFx0ICpcclxuXHRcdCAqIEB0eXBlIHtOb2RlfVxyXG5cdFx0ICovXHJcblx0XHR0aGlzLnRleHR1cmVOb2RlID0gdGV4dHVyZU5vZGU7XHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBDb250cm9scyB0aGUgaW50ZW5zaXR5IG9mIHRoZSBidW1wIGVmZmVjdC5cclxuXHRcdCAqXHJcblx0XHQgKiBAdHlwZSB7Tm9kZT99XHJcblx0XHQgKiBAZGVmYXVsdCBudWxsXHJcblx0XHQgKi9cclxuXHRcdHRoaXMuc2NhbGVOb2RlID0gc2NhbGVOb2RlO1xyXG5cclxuXHR9XHJcblxyXG5cdHNldHVwKCkge1xyXG5cclxuXHRcdGNvbnN0IGJ1bXBTY2FsZSA9IHRoaXMuc2NhbGVOb2RlICE9PSBudWxsID8gdGhpcy5zY2FsZU5vZGUgOiAxO1xyXG5cdFx0Y29uc3QgZEhkeHkgPSBkSGR4eV9md2QoIHsgdGV4dHVyZU5vZGU6IHRoaXMudGV4dHVyZU5vZGUsIGJ1bXBTY2FsZSB9ICk7XHJcblxyXG5cdFx0cmV0dXJuIHBlcnR1cmJOb3JtYWxBcmIoIHtcclxuXHRcdFx0c3VyZl9wb3M6IHBvc2l0aW9uVmlldyxcclxuXHRcdFx0c3VyZl9ub3JtOiBub3JtYWxWaWV3LFxyXG5cdFx0XHRkSGR4eVxyXG5cdFx0fSApO1xyXG5cclxuXHR9XHJcblxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBCdW1wTWFwTm9kZTtcclxuXHJcbi8qKlxyXG4gKiBUU0wgZnVuY3Rpb24gZm9yIGNyZWF0aW5nIGEgYnVtcCBtYXAgbm9kZS5cclxuICpcclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7Tm9kZX0gdGV4dHVyZU5vZGUgLSBSZXByZXNlbnRzIHRoZSBidW1wIG1hcCBkYXRhLlxyXG4gKiBAcGFyYW0ge05vZGU/fSBbc2NhbGVOb2RlPW51bGxdIC0gQ29udHJvbHMgdGhlIGludGVuc2l0eSBvZiB0aGUgYnVtcCBlZmZlY3QuXHJcbiAqIEByZXR1cm5zIHtCdW1wTWFwTm9kZX1cclxuICovXHJcbmV4cG9ydCBjb25zdCBidW1wTWFwID0gLypAX19QVVJFX18qLyBub2RlUHJveHkoIEJ1bXBNYXBOb2RlICk7XHJcbiIsImltcG9ydCBOb2RlIGZyb20gJy4uL2NvcmUvTm9kZS5qcyc7XHJcbmltcG9ydCB7IHJlZmVyZW5jZSB9IGZyb20gJy4vUmVmZXJlbmNlTm9kZS5qcyc7XHJcbmltcG9ydCB7IG1hdGVyaWFsUmVmZXJlbmNlIH0gZnJvbSAnLi9NYXRlcmlhbFJlZmVyZW5jZU5vZGUuanMnO1xyXG5pbXBvcnQgeyBub3JtYWxWaWV3IH0gZnJvbSAnLi9Ob3JtYWwuanMnO1xyXG5pbXBvcnQgeyBub2RlSW1tdXRhYmxlLCBmbG9hdCwgdmVjMiwgdmVjMywgbWF0MiB9IGZyb20gJy4uL3RzbC9UU0xCYXNlLmpzJztcclxuaW1wb3J0IHsgdW5pZm9ybSB9IGZyb20gJy4uL2NvcmUvVW5pZm9ybU5vZGUuanMnO1xyXG5pbXBvcnQgeyBub3JtYWxNYXAgfSBmcm9tICcuLi9kaXNwbGF5L05vcm1hbE1hcE5vZGUuanMnO1xyXG5pbXBvcnQgeyBidW1wTWFwIH0gZnJvbSAnLi4vZGlzcGxheS9CdW1wTWFwTm9kZS5qcyc7XHJcblxyXG5pbXBvcnQgeyBWZWN0b3IyIH0gZnJvbSAnLi4vLi4vbWF0aC9WZWN0b3IyLmpzJztcclxuXHJcbmNvbnN0IF9wcm9wZXJ0eUNhY2hlID0gbmV3IE1hcCgpO1xyXG5cclxuY2xhc3MgTWF0ZXJpYWxOb2RlIGV4dGVuZHMgTm9kZSB7XHJcblxyXG5cdHN0YXRpYyBnZXQgdHlwZSgpIHtcclxuXHJcblx0XHRyZXR1cm4gJ01hdGVyaWFsTm9kZSc7XHJcblxyXG5cdH1cclxuXHJcblx0Y29uc3RydWN0b3IoIHNjb3BlICkge1xyXG5cclxuXHRcdHN1cGVyKCk7XHJcblxyXG5cdFx0dGhpcy5zY29wZSA9IHNjb3BlO1xyXG5cclxuXHR9XHJcblxyXG5cdGdldENhY2hlKCBwcm9wZXJ0eSwgdHlwZSApIHtcclxuXHJcblx0XHRsZXQgbm9kZSA9IF9wcm9wZXJ0eUNhY2hlLmdldCggcHJvcGVydHkgKTtcclxuXHJcblx0XHRpZiAoIG5vZGUgPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdG5vZGUgPSBtYXRlcmlhbFJlZmVyZW5jZSggcHJvcGVydHksIHR5cGUgKTtcclxuXHJcblx0XHRcdF9wcm9wZXJ0eUNhY2hlLnNldCggcHJvcGVydHksIG5vZGUgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIG5vZGU7XHJcblxyXG5cdH1cclxuXHJcblx0Z2V0RmxvYXQoIHByb3BlcnR5ICkge1xyXG5cclxuXHRcdHJldHVybiB0aGlzLmdldENhY2hlKCBwcm9wZXJ0eSwgJ2Zsb2F0JyApO1xyXG5cclxuXHR9XHJcblxyXG5cdGdldENvbG9yKCBwcm9wZXJ0eSApIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5nZXRDYWNoZSggcHJvcGVydHksICdjb2xvcicgKTtcclxuXHJcblx0fVxyXG5cclxuXHRnZXRUZXh0dXJlKCBwcm9wZXJ0eSApIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5nZXRDYWNoZSggcHJvcGVydHkgPT09ICdtYXAnID8gJ21hcCcgOiBwcm9wZXJ0eSArICdNYXAnLCAndGV4dHVyZScgKTtcclxuXHJcblx0fVxyXG5cclxuXHRzZXR1cCggYnVpbGRlciApIHtcclxuXHJcblx0XHRjb25zdCBtYXRlcmlhbCA9IGJ1aWxkZXIuY29udGV4dC5tYXRlcmlhbDtcclxuXHRcdGNvbnN0IHNjb3BlID0gdGhpcy5zY29wZTtcclxuXHJcblx0XHRsZXQgbm9kZSA9IG51bGw7XHJcblxyXG5cdFx0aWYgKCBzY29wZSA9PT0gTWF0ZXJpYWxOb2RlLkNPTE9SICkge1xyXG5cclxuXHRcdFx0Y29uc3QgY29sb3JOb2RlID0gbWF0ZXJpYWwuY29sb3IgIT09IHVuZGVmaW5lZCA/IHRoaXMuZ2V0Q29sb3IoIHNjb3BlICkgOiB2ZWMzKCk7XHJcblxyXG5cdFx0XHRpZiAoIG1hdGVyaWFsLm1hcCAmJiBtYXRlcmlhbC5tYXAuaXNUZXh0dXJlID09PSB0cnVlICkge1xyXG5cclxuXHRcdFx0XHRub2RlID0gY29sb3JOb2RlLm11bCggdGhpcy5nZXRUZXh0dXJlKCAnbWFwJyApICk7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRub2RlID0gY29sb3JOb2RlO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH0gZWxzZSBpZiAoIHNjb3BlID09PSBNYXRlcmlhbE5vZGUuT1BBQ0lUWSApIHtcclxuXHJcblx0XHRcdGNvbnN0IG9wYWNpdHlOb2RlID0gdGhpcy5nZXRGbG9hdCggc2NvcGUgKTtcclxuXHJcblx0XHRcdGlmICggbWF0ZXJpYWwuYWxwaGFNYXAgJiYgbWF0ZXJpYWwuYWxwaGFNYXAuaXNUZXh0dXJlID09PSB0cnVlICkge1xyXG5cclxuXHRcdFx0XHRub2RlID0gb3BhY2l0eU5vZGUubXVsKCB0aGlzLmdldFRleHR1cmUoICdhbHBoYScgKSApO1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0bm9kZSA9IG9wYWNpdHlOb2RlO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH0gZWxzZSBpZiAoIHNjb3BlID09PSBNYXRlcmlhbE5vZGUuU1BFQ1VMQVJfU1RSRU5HVEggKSB7XHJcblxyXG5cdFx0XHRpZiAoIG1hdGVyaWFsLnNwZWN1bGFyTWFwICYmIG1hdGVyaWFsLnNwZWN1bGFyTWFwLmlzVGV4dHVyZSA9PT0gdHJ1ZSApIHtcclxuXHJcblx0XHRcdFx0bm9kZSA9IHRoaXMuZ2V0VGV4dHVyZSggJ3NwZWN1bGFyJyApLnI7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRub2RlID0gZmxvYXQoIDEgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9IGVsc2UgaWYgKCBzY29wZSA9PT0gTWF0ZXJpYWxOb2RlLlNQRUNVTEFSX0lOVEVOU0lUWSApIHtcclxuXHJcblx0XHRcdGNvbnN0IHNwZWN1bGFySW50ZW5zaXR5ID0gdGhpcy5nZXRGbG9hdCggc2NvcGUgKTtcclxuXHJcblx0XHRcdGlmICggbWF0ZXJpYWwuc3BlY3VsYXJNYXAgKSB7XHJcblxyXG5cdFx0XHRcdG5vZGUgPSBzcGVjdWxhckludGVuc2l0eS5tdWwoIHRoaXMuZ2V0VGV4dHVyZSggc2NvcGUgKS5hICk7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRub2RlID0gc3BlY3VsYXJJbnRlbnNpdHk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fSBlbHNlIGlmICggc2NvcGUgPT09IE1hdGVyaWFsTm9kZS5TUEVDVUxBUl9DT0xPUiApIHtcclxuXHJcblx0XHRcdGNvbnN0IHNwZWN1bGFyQ29sb3JOb2RlID0gdGhpcy5nZXRDb2xvciggc2NvcGUgKTtcclxuXHJcblx0XHRcdGlmICggbWF0ZXJpYWwuc3BlY3VsYXJDb2xvck1hcCAmJiBtYXRlcmlhbC5zcGVjdWxhckNvbG9yTWFwLmlzVGV4dHVyZSA9PT0gdHJ1ZSApIHtcclxuXHJcblx0XHRcdFx0bm9kZSA9IHNwZWN1bGFyQ29sb3JOb2RlLm11bCggdGhpcy5nZXRUZXh0dXJlKCBzY29wZSApLnJnYiApO1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0bm9kZSA9IHNwZWN1bGFyQ29sb3JOb2RlO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH0gZWxzZSBpZiAoIHNjb3BlID09PSBNYXRlcmlhbE5vZGUuUk9VR0hORVNTICkgeyAvLyBUT0RPOiBjbGVhbnVwIHNpbWlsYXIgYnJhbmNoZXNcclxuXHJcblx0XHRcdGNvbnN0IHJvdWdobmVzc05vZGUgPSB0aGlzLmdldEZsb2F0KCBzY29wZSApO1xyXG5cclxuXHRcdFx0aWYgKCBtYXRlcmlhbC5yb3VnaG5lc3NNYXAgJiYgbWF0ZXJpYWwucm91Z2huZXNzTWFwLmlzVGV4dHVyZSA9PT0gdHJ1ZSApIHtcclxuXHJcblx0XHRcdFx0bm9kZSA9IHJvdWdobmVzc05vZGUubXVsKCB0aGlzLmdldFRleHR1cmUoIHNjb3BlICkuZyApO1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0bm9kZSA9IHJvdWdobmVzc05vZGU7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fSBlbHNlIGlmICggc2NvcGUgPT09IE1hdGVyaWFsTm9kZS5NRVRBTE5FU1MgKSB7XHJcblxyXG5cdFx0XHRjb25zdCBtZXRhbG5lc3NOb2RlID0gdGhpcy5nZXRGbG9hdCggc2NvcGUgKTtcclxuXHJcblx0XHRcdGlmICggbWF0ZXJpYWwubWV0YWxuZXNzTWFwICYmIG1hdGVyaWFsLm1ldGFsbmVzc01hcC5pc1RleHR1cmUgPT09IHRydWUgKSB7XHJcblxyXG5cdFx0XHRcdG5vZGUgPSBtZXRhbG5lc3NOb2RlLm11bCggdGhpcy5nZXRUZXh0dXJlKCBzY29wZSApLmIgKTtcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdG5vZGUgPSBtZXRhbG5lc3NOb2RlO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH0gZWxzZSBpZiAoIHNjb3BlID09PSBNYXRlcmlhbE5vZGUuRU1JU1NJVkUgKSB7XHJcblxyXG5cdFx0XHRjb25zdCBlbWlzc2l2ZUludGVuc2l0eU5vZGUgPSB0aGlzLmdldEZsb2F0KCAnZW1pc3NpdmVJbnRlbnNpdHknICk7XHJcblx0XHRcdGNvbnN0IGVtaXNzaXZlTm9kZSA9IHRoaXMuZ2V0Q29sb3IoIHNjb3BlICkubXVsKCBlbWlzc2l2ZUludGVuc2l0eU5vZGUgKTtcclxuXHJcblx0XHRcdGlmICggbWF0ZXJpYWwuZW1pc3NpdmVNYXAgJiYgbWF0ZXJpYWwuZW1pc3NpdmVNYXAuaXNUZXh0dXJlID09PSB0cnVlICkge1xyXG5cclxuXHRcdFx0XHRub2RlID0gZW1pc3NpdmVOb2RlLm11bCggdGhpcy5nZXRUZXh0dXJlKCBzY29wZSApICk7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRub2RlID0gZW1pc3NpdmVOb2RlO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH0gZWxzZSBpZiAoIHNjb3BlID09PSBNYXRlcmlhbE5vZGUuTk9STUFMICkge1xyXG5cclxuXHRcdFx0aWYgKCBtYXRlcmlhbC5ub3JtYWxNYXAgKSB7XHJcblxyXG5cdFx0XHRcdG5vZGUgPSBub3JtYWxNYXAoIHRoaXMuZ2V0VGV4dHVyZSggJ25vcm1hbCcgKSwgdGhpcy5nZXRDYWNoZSggJ25vcm1hbFNjYWxlJywgJ3ZlYzInICkgKTtcclxuXHRcdFx0XHRub2RlLm5vcm1hbE1hcFR5cGUgPSBtYXRlcmlhbC5ub3JtYWxNYXBUeXBlO1xyXG5cclxuXHRcdFx0fSBlbHNlIGlmICggbWF0ZXJpYWwuYnVtcE1hcCApIHtcclxuXHJcblx0XHRcdFx0bm9kZSA9IGJ1bXBNYXAoIHRoaXMuZ2V0VGV4dHVyZSggJ2J1bXAnICkuciwgdGhpcy5nZXRGbG9hdCggJ2J1bXBTY2FsZScgKSApO1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0bm9kZSA9IG5vcm1hbFZpZXc7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fSBlbHNlIGlmICggc2NvcGUgPT09IE1hdGVyaWFsTm9kZS5DTEVBUkNPQVQgKSB7XHJcblxyXG5cdFx0XHRjb25zdCBjbGVhcmNvYXROb2RlID0gdGhpcy5nZXRGbG9hdCggc2NvcGUgKTtcclxuXHJcblx0XHRcdGlmICggbWF0ZXJpYWwuY2xlYXJjb2F0TWFwICYmIG1hdGVyaWFsLmNsZWFyY29hdE1hcC5pc1RleHR1cmUgPT09IHRydWUgKSB7XHJcblxyXG5cdFx0XHRcdG5vZGUgPSBjbGVhcmNvYXROb2RlLm11bCggdGhpcy5nZXRUZXh0dXJlKCBzY29wZSApLnIgKTtcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdG5vZGUgPSBjbGVhcmNvYXROb2RlO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH0gZWxzZSBpZiAoIHNjb3BlID09PSBNYXRlcmlhbE5vZGUuQ0xFQVJDT0FUX1JPVUdITkVTUyApIHtcclxuXHJcblx0XHRcdGNvbnN0IGNsZWFyY29hdFJvdWdobmVzc05vZGUgPSB0aGlzLmdldEZsb2F0KCBzY29wZSApO1xyXG5cclxuXHRcdFx0aWYgKCBtYXRlcmlhbC5jbGVhcmNvYXRSb3VnaG5lc3NNYXAgJiYgbWF0ZXJpYWwuY2xlYXJjb2F0Um91Z2huZXNzTWFwLmlzVGV4dHVyZSA9PT0gdHJ1ZSApIHtcclxuXHJcblx0XHRcdFx0bm9kZSA9IGNsZWFyY29hdFJvdWdobmVzc05vZGUubXVsKCB0aGlzLmdldFRleHR1cmUoIHNjb3BlICkuciApO1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0bm9kZSA9IGNsZWFyY29hdFJvdWdobmVzc05vZGU7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fSBlbHNlIGlmICggc2NvcGUgPT09IE1hdGVyaWFsTm9kZS5DTEVBUkNPQVRfTk9STUFMICkge1xyXG5cclxuXHRcdFx0aWYgKCBtYXRlcmlhbC5jbGVhcmNvYXROb3JtYWxNYXAgKSB7XHJcblxyXG5cdFx0XHRcdG5vZGUgPSBub3JtYWxNYXAoIHRoaXMuZ2V0VGV4dHVyZSggc2NvcGUgKSwgdGhpcy5nZXRDYWNoZSggc2NvcGUgKyAnU2NhbGUnLCAndmVjMicgKSApO1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0bm9kZSA9IG5vcm1hbFZpZXc7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fSBlbHNlIGlmICggc2NvcGUgPT09IE1hdGVyaWFsTm9kZS5TSEVFTiApIHtcclxuXHJcblx0XHRcdGNvbnN0IHNoZWVuTm9kZSA9IHRoaXMuZ2V0Q29sb3IoICdzaGVlbkNvbG9yJyApLm11bCggdGhpcy5nZXRGbG9hdCggJ3NoZWVuJyApICk7IC8vIE1vdmUgdGhpcyBtdWwoKSB0byBDUFVcclxuXHJcblx0XHRcdGlmICggbWF0ZXJpYWwuc2hlZW5Db2xvck1hcCAmJiBtYXRlcmlhbC5zaGVlbkNvbG9yTWFwLmlzVGV4dHVyZSA9PT0gdHJ1ZSApIHtcclxuXHJcblx0XHRcdFx0bm9kZSA9IHNoZWVuTm9kZS5tdWwoIHRoaXMuZ2V0VGV4dHVyZSggJ3NoZWVuQ29sb3InICkucmdiICk7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRub2RlID0gc2hlZW5Ob2RlO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH0gZWxzZSBpZiAoIHNjb3BlID09PSBNYXRlcmlhbE5vZGUuU0hFRU5fUk9VR0hORVNTICkge1xyXG5cclxuXHRcdFx0Y29uc3Qgc2hlZW5Sb3VnaG5lc3NOb2RlID0gdGhpcy5nZXRGbG9hdCggc2NvcGUgKTtcclxuXHJcblx0XHRcdGlmICggbWF0ZXJpYWwuc2hlZW5Sb3VnaG5lc3NNYXAgJiYgbWF0ZXJpYWwuc2hlZW5Sb3VnaG5lc3NNYXAuaXNUZXh0dXJlID09PSB0cnVlICkge1xyXG5cclxuXHRcdFx0XHRub2RlID0gc2hlZW5Sb3VnaG5lc3NOb2RlLm11bCggdGhpcy5nZXRUZXh0dXJlKCBzY29wZSApLmEgKTtcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdG5vZGUgPSBzaGVlblJvdWdobmVzc05vZGU7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRub2RlID0gbm9kZS5jbGFtcCggMC4wNywgMS4wICk7XHJcblxyXG5cdFx0fSBlbHNlIGlmICggc2NvcGUgPT09IE1hdGVyaWFsTm9kZS5BTklTT1RST1BZICkge1xyXG5cclxuXHRcdFx0aWYgKCBtYXRlcmlhbC5hbmlzb3Ryb3B5TWFwICYmIG1hdGVyaWFsLmFuaXNvdHJvcHlNYXAuaXNUZXh0dXJlID09PSB0cnVlICkge1xyXG5cclxuXHRcdFx0XHRjb25zdCBhbmlzb3Ryb3B5UG9sYXIgPSB0aGlzLmdldFRleHR1cmUoIHNjb3BlICk7XHJcblx0XHRcdFx0Y29uc3QgYW5pc290cm9weU1hdCA9IG1hdDIoIG1hdGVyaWFsQW5pc290cm9weVZlY3Rvci54LCBtYXRlcmlhbEFuaXNvdHJvcHlWZWN0b3IueSwgbWF0ZXJpYWxBbmlzb3Ryb3B5VmVjdG9yLnkubmVnYXRlKCksIG1hdGVyaWFsQW5pc290cm9weVZlY3Rvci54ICk7XHJcblxyXG5cdFx0XHRcdG5vZGUgPSBhbmlzb3Ryb3B5TWF0Lm11bCggYW5pc290cm9weVBvbGFyLnJnLm11bCggMi4wICkuc3ViKCB2ZWMyKCAxLjAgKSApLm5vcm1hbGl6ZSgpLm11bCggYW5pc290cm9weVBvbGFyLmIgKSApO1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0bm9kZSA9IG1hdGVyaWFsQW5pc290cm9weVZlY3RvcjtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9IGVsc2UgaWYgKCBzY29wZSA9PT0gTWF0ZXJpYWxOb2RlLklSSURFU0NFTkNFX1RISUNLTkVTUyApIHtcclxuXHJcblx0XHRcdGNvbnN0IGlyaWRlc2NlbmNlVGhpY2tuZXNzTWF4aW11bSA9IHJlZmVyZW5jZSggJzEnLCAnZmxvYXQnLCBtYXRlcmlhbC5pcmlkZXNjZW5jZVRoaWNrbmVzc1JhbmdlICk7XHJcblxyXG5cdFx0XHRpZiAoIG1hdGVyaWFsLmlyaWRlc2NlbmNlVGhpY2tuZXNzTWFwICkge1xyXG5cclxuXHRcdFx0XHRjb25zdCBpcmlkZXNjZW5jZVRoaWNrbmVzc01pbmltdW0gPSByZWZlcmVuY2UoICcwJywgJ2Zsb2F0JywgbWF0ZXJpYWwuaXJpZGVzY2VuY2VUaGlja25lc3NSYW5nZSApO1xyXG5cclxuXHRcdFx0XHRub2RlID0gaXJpZGVzY2VuY2VUaGlja25lc3NNYXhpbXVtLnN1YiggaXJpZGVzY2VuY2VUaGlja25lc3NNaW5pbXVtICkubXVsKCB0aGlzLmdldFRleHR1cmUoIHNjb3BlICkuZyApLmFkZCggaXJpZGVzY2VuY2VUaGlja25lc3NNaW5pbXVtICk7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRub2RlID0gaXJpZGVzY2VuY2VUaGlja25lc3NNYXhpbXVtO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH0gZWxzZSBpZiAoIHNjb3BlID09PSBNYXRlcmlhbE5vZGUuVFJBTlNNSVNTSU9OICkge1xyXG5cclxuXHRcdFx0Y29uc3QgdHJhbnNtaXNzaW9uTm9kZSA9IHRoaXMuZ2V0RmxvYXQoIHNjb3BlICk7XHJcblxyXG5cdFx0XHRpZiAoIG1hdGVyaWFsLnRyYW5zbWlzc2lvbk1hcCApIHtcclxuXHJcblx0XHRcdFx0bm9kZSA9IHRyYW5zbWlzc2lvbk5vZGUubXVsKCB0aGlzLmdldFRleHR1cmUoIHNjb3BlICkuciApO1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0bm9kZSA9IHRyYW5zbWlzc2lvbk5vZGU7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fSBlbHNlIGlmICggc2NvcGUgPT09IE1hdGVyaWFsTm9kZS5USElDS05FU1MgKSB7XHJcblxyXG5cdFx0XHRjb25zdCB0aGlja25lc3NOb2RlID0gdGhpcy5nZXRGbG9hdCggc2NvcGUgKTtcclxuXHJcblx0XHRcdGlmICggbWF0ZXJpYWwudGhpY2tuZXNzTWFwICkge1xyXG5cclxuXHRcdFx0XHRub2RlID0gdGhpY2tuZXNzTm9kZS5tdWwoIHRoaXMuZ2V0VGV4dHVyZSggc2NvcGUgKS5nICk7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRub2RlID0gdGhpY2tuZXNzTm9kZTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9IGVsc2UgaWYgKCBzY29wZSA9PT0gTWF0ZXJpYWxOb2RlLklPUiApIHtcclxuXHJcblx0XHRcdG5vZGUgPSB0aGlzLmdldEZsb2F0KCBzY29wZSApO1xyXG5cclxuXHRcdH0gZWxzZSBpZiAoIHNjb3BlID09PSBNYXRlcmlhbE5vZGUuTElHSFRfTUFQICkge1xyXG5cclxuXHRcdFx0bm9kZSA9IHRoaXMuZ2V0VGV4dHVyZSggc2NvcGUgKS5yZ2IubXVsKCB0aGlzLmdldEZsb2F0KCAnbGlnaHRNYXBJbnRlbnNpdHknICkgKTtcclxuXHJcblx0XHR9IGVsc2UgaWYgKCBzY29wZSA9PT0gTWF0ZXJpYWxOb2RlLkFPX01BUCApIHtcclxuXHJcblx0XHRcdG5vZGUgPSB0aGlzLmdldFRleHR1cmUoIHNjb3BlICkuci5zdWIoIDEuMCApLm11bCggdGhpcy5nZXRGbG9hdCggJ2FvTWFwSW50ZW5zaXR5JyApICkuYWRkKCAxLjAgKTtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0Y29uc3Qgb3V0cHV0VHlwZSA9IHRoaXMuZ2V0Tm9kZVR5cGUoIGJ1aWxkZXIgKTtcclxuXHJcblx0XHRcdG5vZGUgPSB0aGlzLmdldENhY2hlKCBzY29wZSwgb3V0cHV0VHlwZSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gbm9kZTtcclxuXHJcblx0fVxyXG5cclxufVxyXG5cclxuTWF0ZXJpYWxOb2RlLkFMUEhBX1RFU1QgPSAnYWxwaGFUZXN0JztcclxuTWF0ZXJpYWxOb2RlLkNPTE9SID0gJ2NvbG9yJztcclxuTWF0ZXJpYWxOb2RlLk9QQUNJVFkgPSAnb3BhY2l0eSc7XHJcbk1hdGVyaWFsTm9kZS5TSElOSU5FU1MgPSAnc2hpbmluZXNzJztcclxuTWF0ZXJpYWxOb2RlLlNQRUNVTEFSID0gJ3NwZWN1bGFyJztcclxuTWF0ZXJpYWxOb2RlLlNQRUNVTEFSX1NUUkVOR1RIID0gJ3NwZWN1bGFyU3RyZW5ndGgnO1xyXG5NYXRlcmlhbE5vZGUuU1BFQ1VMQVJfSU5URU5TSVRZID0gJ3NwZWN1bGFySW50ZW5zaXR5JztcclxuTWF0ZXJpYWxOb2RlLlNQRUNVTEFSX0NPTE9SID0gJ3NwZWN1bGFyQ29sb3InO1xyXG5NYXRlcmlhbE5vZGUuUkVGTEVDVElWSVRZID0gJ3JlZmxlY3Rpdml0eSc7XHJcbk1hdGVyaWFsTm9kZS5ST1VHSE5FU1MgPSAncm91Z2huZXNzJztcclxuTWF0ZXJpYWxOb2RlLk1FVEFMTkVTUyA9ICdtZXRhbG5lc3MnO1xyXG5NYXRlcmlhbE5vZGUuTk9STUFMID0gJ25vcm1hbCc7XHJcbk1hdGVyaWFsTm9kZS5DTEVBUkNPQVQgPSAnY2xlYXJjb2F0JztcclxuTWF0ZXJpYWxOb2RlLkNMRUFSQ09BVF9ST1VHSE5FU1MgPSAnY2xlYXJjb2F0Um91Z2huZXNzJztcclxuTWF0ZXJpYWxOb2RlLkNMRUFSQ09BVF9OT1JNQUwgPSAnY2xlYXJjb2F0Tm9ybWFsJztcclxuTWF0ZXJpYWxOb2RlLkVNSVNTSVZFID0gJ2VtaXNzaXZlJztcclxuTWF0ZXJpYWxOb2RlLlJPVEFUSU9OID0gJ3JvdGF0aW9uJztcclxuTWF0ZXJpYWxOb2RlLlNIRUVOID0gJ3NoZWVuJztcclxuTWF0ZXJpYWxOb2RlLlNIRUVOX1JPVUdITkVTUyA9ICdzaGVlblJvdWdobmVzcyc7XHJcbk1hdGVyaWFsTm9kZS5BTklTT1RST1BZID0gJ2FuaXNvdHJvcHknO1xyXG5NYXRlcmlhbE5vZGUuSVJJREVTQ0VOQ0UgPSAnaXJpZGVzY2VuY2UnO1xyXG5NYXRlcmlhbE5vZGUuSVJJREVTQ0VOQ0VfSU9SID0gJ2lyaWRlc2NlbmNlSU9SJztcclxuTWF0ZXJpYWxOb2RlLklSSURFU0NFTkNFX1RISUNLTkVTUyA9ICdpcmlkZXNjZW5jZVRoaWNrbmVzcyc7XHJcbk1hdGVyaWFsTm9kZS5JT1IgPSAnaW9yJztcclxuTWF0ZXJpYWxOb2RlLlRSQU5TTUlTU0lPTiA9ICd0cmFuc21pc3Npb24nO1xyXG5NYXRlcmlhbE5vZGUuVEhJQ0tORVNTID0gJ3RoaWNrbmVzcyc7XHJcbk1hdGVyaWFsTm9kZS5BVFRFTlVBVElPTl9ESVNUQU5DRSA9ICdhdHRlbnVhdGlvbkRpc3RhbmNlJztcclxuTWF0ZXJpYWxOb2RlLkFUVEVOVUFUSU9OX0NPTE9SID0gJ2F0dGVudWF0aW9uQ29sb3InO1xyXG5NYXRlcmlhbE5vZGUuTElORV9TQ0FMRSA9ICdzY2FsZSc7XHJcbk1hdGVyaWFsTm9kZS5MSU5FX0RBU0hfU0laRSA9ICdkYXNoU2l6ZSc7XHJcbk1hdGVyaWFsTm9kZS5MSU5FX0dBUF9TSVpFID0gJ2dhcFNpemUnO1xyXG5NYXRlcmlhbE5vZGUuTElORV9XSURUSCA9ICdsaW5ld2lkdGgnO1xyXG5NYXRlcmlhbE5vZGUuTElORV9EQVNIX09GRlNFVCA9ICdkYXNoT2Zmc2V0JztcclxuTWF0ZXJpYWxOb2RlLlBPSU5UX1dJRFRIID0gJ3BvaW50V2lkdGgnO1xyXG5NYXRlcmlhbE5vZGUuRElTUEVSU0lPTiA9ICdkaXNwZXJzaW9uJztcclxuTWF0ZXJpYWxOb2RlLkxJR0hUX01BUCA9ICdsaWdodCc7XHJcbk1hdGVyaWFsTm9kZS5BT19NQVAgPSAnYW8nO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgTWF0ZXJpYWxOb2RlO1xyXG5cclxuZXhwb3J0IGNvbnN0IG1hdGVyaWFsQWxwaGFUZXN0ID0gLypAX19QVVJFX18qLyBub2RlSW1tdXRhYmxlKCBNYXRlcmlhbE5vZGUsIE1hdGVyaWFsTm9kZS5BTFBIQV9URVNUICk7XHJcbmV4cG9ydCBjb25zdCBtYXRlcmlhbENvbG9yID0gLypAX19QVVJFX18qLyBub2RlSW1tdXRhYmxlKCBNYXRlcmlhbE5vZGUsIE1hdGVyaWFsTm9kZS5DT0xPUiApO1xyXG5leHBvcnQgY29uc3QgbWF0ZXJpYWxTaGluaW5lc3MgPSAvKkBfX1BVUkVfXyovIG5vZGVJbW11dGFibGUoIE1hdGVyaWFsTm9kZSwgTWF0ZXJpYWxOb2RlLlNISU5JTkVTUyApO1xyXG5leHBvcnQgY29uc3QgbWF0ZXJpYWxFbWlzc2l2ZSA9IC8qQF9fUFVSRV9fKi8gbm9kZUltbXV0YWJsZSggTWF0ZXJpYWxOb2RlLCBNYXRlcmlhbE5vZGUuRU1JU1NJVkUgKTtcclxuZXhwb3J0IGNvbnN0IG1hdGVyaWFsT3BhY2l0eSA9IC8qQF9fUFVSRV9fKi8gbm9kZUltbXV0YWJsZSggTWF0ZXJpYWxOb2RlLCBNYXRlcmlhbE5vZGUuT1BBQ0lUWSApO1xyXG5leHBvcnQgY29uc3QgbWF0ZXJpYWxTcGVjdWxhciA9IC8qQF9fUFVSRV9fKi8gbm9kZUltbXV0YWJsZSggTWF0ZXJpYWxOb2RlLCBNYXRlcmlhbE5vZGUuU1BFQ1VMQVIgKTtcclxuXHJcbmV4cG9ydCBjb25zdCBtYXRlcmlhbFNwZWN1bGFySW50ZW5zaXR5ID0gLypAX19QVVJFX18qLyBub2RlSW1tdXRhYmxlKCBNYXRlcmlhbE5vZGUsIE1hdGVyaWFsTm9kZS5TUEVDVUxBUl9JTlRFTlNJVFkgKTtcclxuZXhwb3J0IGNvbnN0IG1hdGVyaWFsU3BlY3VsYXJDb2xvciA9IC8qQF9fUFVSRV9fKi8gbm9kZUltbXV0YWJsZSggTWF0ZXJpYWxOb2RlLCBNYXRlcmlhbE5vZGUuU1BFQ1VMQVJfQ09MT1IgKTtcclxuXHJcbmV4cG9ydCBjb25zdCBtYXRlcmlhbFNwZWN1bGFyU3RyZW5ndGggPSAvKkBfX1BVUkVfXyovIG5vZGVJbW11dGFibGUoIE1hdGVyaWFsTm9kZSwgTWF0ZXJpYWxOb2RlLlNQRUNVTEFSX1NUUkVOR1RIICk7XHJcbmV4cG9ydCBjb25zdCBtYXRlcmlhbFJlZmxlY3Rpdml0eSA9IC8qQF9fUFVSRV9fKi8gbm9kZUltbXV0YWJsZSggTWF0ZXJpYWxOb2RlLCBNYXRlcmlhbE5vZGUuUkVGTEVDVElWSVRZICk7XHJcbmV4cG9ydCBjb25zdCBtYXRlcmlhbFJvdWdobmVzcyA9IC8qQF9fUFVSRV9fKi8gbm9kZUltbXV0YWJsZSggTWF0ZXJpYWxOb2RlLCBNYXRlcmlhbE5vZGUuUk9VR0hORVNTICk7XHJcbmV4cG9ydCBjb25zdCBtYXRlcmlhbE1ldGFsbmVzcyA9IC8qQF9fUFVSRV9fKi8gbm9kZUltbXV0YWJsZSggTWF0ZXJpYWxOb2RlLCBNYXRlcmlhbE5vZGUuTUVUQUxORVNTICk7XHJcbmV4cG9ydCBjb25zdCBtYXRlcmlhbE5vcm1hbCA9IC8qQF9fUFVSRV9fKi8gbm9kZUltbXV0YWJsZSggTWF0ZXJpYWxOb2RlLCBNYXRlcmlhbE5vZGUuTk9STUFMICkuY29udGV4dCggeyBnZXRVVjogbnVsbCB9ICk7XHJcbmV4cG9ydCBjb25zdCBtYXRlcmlhbENsZWFyY29hdCA9IC8qQF9fUFVSRV9fKi8gbm9kZUltbXV0YWJsZSggTWF0ZXJpYWxOb2RlLCBNYXRlcmlhbE5vZGUuQ0xFQVJDT0FUICk7XHJcbmV4cG9ydCBjb25zdCBtYXRlcmlhbENsZWFyY29hdFJvdWdobmVzcyA9IC8qQF9fUFVSRV9fKi8gbm9kZUltbXV0YWJsZSggTWF0ZXJpYWxOb2RlLCBNYXRlcmlhbE5vZGUuQ0xFQVJDT0FUX1JPVUdITkVTUyApO1xyXG5leHBvcnQgY29uc3QgbWF0ZXJpYWxDbGVhcmNvYXROb3JtYWwgPSAvKkBfX1BVUkVfXyovIG5vZGVJbW11dGFibGUoIE1hdGVyaWFsTm9kZSwgTWF0ZXJpYWxOb2RlLkNMRUFSQ09BVF9OT1JNQUwgKS5jb250ZXh0KCB7IGdldFVWOiBudWxsIH0gKTtcclxuZXhwb3J0IGNvbnN0IG1hdGVyaWFsUm90YXRpb24gPSAvKkBfX1BVUkVfXyovIG5vZGVJbW11dGFibGUoIE1hdGVyaWFsTm9kZSwgTWF0ZXJpYWxOb2RlLlJPVEFUSU9OICk7XHJcbmV4cG9ydCBjb25zdCBtYXRlcmlhbFNoZWVuID0gLypAX19QVVJFX18qLyBub2RlSW1tdXRhYmxlKCBNYXRlcmlhbE5vZGUsIE1hdGVyaWFsTm9kZS5TSEVFTiApO1xyXG5leHBvcnQgY29uc3QgbWF0ZXJpYWxTaGVlblJvdWdobmVzcyA9IC8qQF9fUFVSRV9fKi8gbm9kZUltbXV0YWJsZSggTWF0ZXJpYWxOb2RlLCBNYXRlcmlhbE5vZGUuU0hFRU5fUk9VR0hORVNTICk7XHJcbmV4cG9ydCBjb25zdCBtYXRlcmlhbEFuaXNvdHJvcHkgPSAvKkBfX1BVUkVfXyovIG5vZGVJbW11dGFibGUoIE1hdGVyaWFsTm9kZSwgTWF0ZXJpYWxOb2RlLkFOSVNPVFJPUFkgKTtcclxuZXhwb3J0IGNvbnN0IG1hdGVyaWFsSXJpZGVzY2VuY2UgPSAvKkBfX1BVUkVfXyovIG5vZGVJbW11dGFibGUoIE1hdGVyaWFsTm9kZSwgTWF0ZXJpYWxOb2RlLklSSURFU0NFTkNFICk7XHJcbmV4cG9ydCBjb25zdCBtYXRlcmlhbElyaWRlc2NlbmNlSU9SID0gLypAX19QVVJFX18qLyBub2RlSW1tdXRhYmxlKCBNYXRlcmlhbE5vZGUsIE1hdGVyaWFsTm9kZS5JUklERVNDRU5DRV9JT1IgKTtcclxuZXhwb3J0IGNvbnN0IG1hdGVyaWFsSXJpZGVzY2VuY2VUaGlja25lc3MgPSAvKkBfX1BVUkVfXyovIG5vZGVJbW11dGFibGUoIE1hdGVyaWFsTm9kZSwgTWF0ZXJpYWxOb2RlLklSSURFU0NFTkNFX1RISUNLTkVTUyApO1xyXG5leHBvcnQgY29uc3QgbWF0ZXJpYWxUcmFuc21pc3Npb24gPSAvKkBfX1BVUkVfXyovIG5vZGVJbW11dGFibGUoIE1hdGVyaWFsTm9kZSwgTWF0ZXJpYWxOb2RlLlRSQU5TTUlTU0lPTiApO1xyXG5leHBvcnQgY29uc3QgbWF0ZXJpYWxUaGlja25lc3MgPSAvKkBfX1BVUkVfXyovIG5vZGVJbW11dGFibGUoIE1hdGVyaWFsTm9kZSwgTWF0ZXJpYWxOb2RlLlRISUNLTkVTUyApO1xyXG5leHBvcnQgY29uc3QgbWF0ZXJpYWxJT1IgPSAvKkBfX1BVUkVfXyovIG5vZGVJbW11dGFibGUoIE1hdGVyaWFsTm9kZSwgTWF0ZXJpYWxOb2RlLklPUiApO1xyXG5leHBvcnQgY29uc3QgbWF0ZXJpYWxBdHRlbnVhdGlvbkRpc3RhbmNlID0gLypAX19QVVJFX18qLyBub2RlSW1tdXRhYmxlKCBNYXRlcmlhbE5vZGUsIE1hdGVyaWFsTm9kZS5BVFRFTlVBVElPTl9ESVNUQU5DRSApO1xyXG5leHBvcnQgY29uc3QgbWF0ZXJpYWxBdHRlbnVhdGlvbkNvbG9yID0gLypAX19QVVJFX18qLyBub2RlSW1tdXRhYmxlKCBNYXRlcmlhbE5vZGUsIE1hdGVyaWFsTm9kZS5BVFRFTlVBVElPTl9DT0xPUiApO1xyXG5leHBvcnQgY29uc3QgbWF0ZXJpYWxMaW5lU2NhbGUgPSAvKkBfX1BVUkVfXyovIG5vZGVJbW11dGFibGUoIE1hdGVyaWFsTm9kZSwgTWF0ZXJpYWxOb2RlLkxJTkVfU0NBTEUgKTtcclxuZXhwb3J0IGNvbnN0IG1hdGVyaWFsTGluZURhc2hTaXplID0gLypAX19QVVJFX18qLyBub2RlSW1tdXRhYmxlKCBNYXRlcmlhbE5vZGUsIE1hdGVyaWFsTm9kZS5MSU5FX0RBU0hfU0laRSApO1xyXG5leHBvcnQgY29uc3QgbWF0ZXJpYWxMaW5lR2FwU2l6ZSA9IC8qQF9fUFVSRV9fKi8gbm9kZUltbXV0YWJsZSggTWF0ZXJpYWxOb2RlLCBNYXRlcmlhbE5vZGUuTElORV9HQVBfU0laRSApO1xyXG5leHBvcnQgY29uc3QgbWF0ZXJpYWxMaW5lV2lkdGggPSAvKkBfX1BVUkVfXyovIG5vZGVJbW11dGFibGUoIE1hdGVyaWFsTm9kZSwgTWF0ZXJpYWxOb2RlLkxJTkVfV0lEVEggKTtcclxuZXhwb3J0IGNvbnN0IG1hdGVyaWFsTGluZURhc2hPZmZzZXQgPSAvKkBfX1BVUkVfXyovIG5vZGVJbW11dGFibGUoIE1hdGVyaWFsTm9kZSwgTWF0ZXJpYWxOb2RlLkxJTkVfREFTSF9PRkZTRVQgKTtcclxuZXhwb3J0IGNvbnN0IG1hdGVyaWFsUG9pbnRXaWR0aCA9IC8qQF9fUFVSRV9fKi8gbm9kZUltbXV0YWJsZSggTWF0ZXJpYWxOb2RlLCBNYXRlcmlhbE5vZGUuUE9JTlRfV0lEVEggKTtcclxuZXhwb3J0IGNvbnN0IG1hdGVyaWFsRGlzcGVyc2lvbiA9IC8qQF9fUFVSRV9fKi8gbm9kZUltbXV0YWJsZSggTWF0ZXJpYWxOb2RlLCBNYXRlcmlhbE5vZGUuRElTUEVSU0lPTiApO1xyXG5leHBvcnQgY29uc3QgbWF0ZXJpYWxMaWdodE1hcCA9IC8qQF9fUFVSRV9fKi8gbm9kZUltbXV0YWJsZSggTWF0ZXJpYWxOb2RlLCBNYXRlcmlhbE5vZGUuTElHSFRfTUFQICk7XHJcbmV4cG9ydCBjb25zdCBtYXRlcmlhbEFPTWFwID0gLypAX19QVVJFX18qLyBub2RlSW1tdXRhYmxlKCBNYXRlcmlhbE5vZGUsIE1hdGVyaWFsTm9kZS5BT19NQVAgKTtcclxuZXhwb3J0IGNvbnN0IG1hdGVyaWFsQW5pc290cm9weVZlY3RvciA9IC8qQF9fUFVSRV9fKi8gdW5pZm9ybSggbmV3IFZlY3RvcjIoKSApLm9uUmVmZXJlbmNlKCBmdW5jdGlvbiAoIGZyYW1lICkge1xyXG5cclxuXHRyZXR1cm4gZnJhbWUubWF0ZXJpYWw7XHJcblxyXG59ICkub25SZW5kZXJVcGRhdGUoIGZ1bmN0aW9uICggeyBtYXRlcmlhbCB9ICkge1xyXG5cclxuXHR0aGlzLnZhbHVlLnNldCggbWF0ZXJpYWwuYW5pc290cm9weSAqIE1hdGguY29zKCBtYXRlcmlhbC5hbmlzb3Ryb3B5Um90YXRpb24gKSwgbWF0ZXJpYWwuYW5pc290cm9weSAqIE1hdGguc2luKCBtYXRlcmlhbC5hbmlzb3Ryb3B5Um90YXRpb24gKSApO1xyXG5cclxufSApO1xyXG4iLCJpbXBvcnQgeyBjYW1lcmFQcm9qZWN0aW9uTWF0cml4IH0gZnJvbSAnLi9DYW1lcmEuanMnO1xyXG5pbXBvcnQgeyBwb3NpdGlvblZpZXcgfSBmcm9tICcuL1Bvc2l0aW9uLmpzJztcclxuXHJcbmV4cG9ydCBjb25zdCBtb2RlbFZpZXdQcm9qZWN0aW9uID0gLypAX19QVVJFX18qLyBjYW1lcmFQcm9qZWN0aW9uTWF0cml4Lm11bCggcG9zaXRpb25WaWV3ICkudmFyeWluZyggJ3ZfbW9kZWxWaWV3UHJvamVjdGlvbicgKTtcclxuIiwiaW1wb3J0IE5vZGUgZnJvbSAnLi9Ob2RlLmpzJztcclxuaW1wb3J0IHsgbm9kZUltbXV0YWJsZSwgdmFyeWluZyB9IGZyb20gJy4uL3RzbC9UU0xCYXNlLmpzJztcclxuXHJcbi8qKiBAbW9kdWxlIEluZGV4Tm9kZSAqKi9cclxuXHJcbi8qKlxyXG4gKiBUaGlzIGNsYXNzIHJlcHJlc2VudHMgc2hhZGVyIGluZGljZXMgb2YgZGlmZmVyZW50IHR5cGVzLiBUaGUgZm9sbG93aW5nIHByZWRlZmluZWQgbm9kZVxyXG4gKiBvYmplY3RzIGNvdmVyIGZyZXF1ZW50IHVzZSBjYXNlczpcclxuICpcclxuICogLSBgdmVydGV4SW5kZXhgOiBUaGUgaW5kZXggb2YgYSB2ZXJ0ZXggd2l0aGluIGEgbWVzaC5cclxuICogLSBgaW5zdGFuY2VJbmRleGA6IFRoZSBpbmRleCBvZiBlaXRoZXIgYSBtZXNoIGluc3RhbmNlIG9yIGFuIGludm9jYXRpb24gb2YgYSBjb21wdXRlIHNoYWRlci5cclxuICogLSBgZHJhd0luZGV4YDogVGhlIGluZGV4IG9mIGEgZHJhdyBjYWxsLlxyXG4gKiAtIGBpbnZvY2F0aW9uTG9jYWxJbmRleGA6IFRoZSBpbmRleCBvZiBhIGNvbXB1dGUgaW52b2NhdGlvbiB3aXRoaW4gdGhlIHNjb3BlIG9mIGEgd29ya2dyb3VwIGxvYWQuXHJcbiAqIC0gYGludm9jYXRpb25TdWJncm91cEluZGV4YDogVGhlIGluZGV4IG9mIGEgY29tcHV0ZSBpbnZvY2F0aW9uIHdpdGhpbiB0aGUgc2NvcGUgb2YgYSBzdWJncm91cC5cclxuICogLSBgc3ViZ3JvdXBJbmRleGA6IFRoZSBpbmRleCBvZiB0aGUgc3ViZ3JvdXAgdGhlIGN1cnJlbnQgY29tcHV0ZSBpbnZvY2F0aW9uIGJlbG9uZ3MgdG8uXHJcbiAqXHJcbiAqIEBhdWdtZW50cyBOb2RlXHJcbiAqL1xyXG5jbGFzcyBJbmRleE5vZGUgZXh0ZW5kcyBOb2RlIHtcclxuXHJcblx0c3RhdGljIGdldCB0eXBlKCkge1xyXG5cclxuXHRcdHJldHVybiAnSW5kZXhOb2RlJztcclxuXHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBDb25zdHJ1Y3RzIGEgbmV3IGluZGV4IG5vZGUuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0geygndmVydGV4J3wnaW5zdGFuY2UnfCdzdWJncm91cCd8J2ludm9jYXRpb25Mb2NhbCd8J2ludm9jYXRpb25TdWJncm91cCd8J2RyYXcnKX0gc2NvcGUgLSBUaGUgc2NvcGUgb2YgdGhlIGluZGV4IG5vZGUuXHJcblx0ICovXHJcblx0Y29uc3RydWN0b3IoIHNjb3BlICkge1xyXG5cclxuXHRcdHN1cGVyKCAndWludCcgKTtcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIFRoZSBzY29wZSBvZiB0aGUgaW5kZXggbm9kZS5cclxuXHRcdCAqXHJcblx0XHQgKiBAdHlwZSB7U3RyaW5nfVxyXG5cdFx0ICovXHJcblx0XHR0aGlzLnNjb3BlID0gc2NvcGU7XHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBUaGlzIGZsYWcgY2FuIGJlIHVzZWQgZm9yIHR5cGUgdGVzdGluZy5cclxuXHRcdCAqXHJcblx0XHQgKiBAdHlwZSB7Qm9vbGVhbn1cclxuXHRcdCAqIEByZWFkb25seVxyXG5cdFx0ICogQGRlZmF1bHQgdHJ1ZVxyXG5cdFx0ICovXHJcblx0XHR0aGlzLmlzSW5kZXhOb2RlID0gdHJ1ZTtcclxuXHJcblx0fVxyXG5cclxuXHRnZW5lcmF0ZSggYnVpbGRlciApIHtcclxuXHJcblx0XHRjb25zdCBub2RlVHlwZSA9IHRoaXMuZ2V0Tm9kZVR5cGUoIGJ1aWxkZXIgKTtcclxuXHRcdGNvbnN0IHNjb3BlID0gdGhpcy5zY29wZTtcclxuXHJcblx0XHRsZXQgcHJvcGVydHlOYW1lO1xyXG5cclxuXHRcdGlmICggc2NvcGUgPT09IEluZGV4Tm9kZS5WRVJURVggKSB7XHJcblxyXG5cdFx0XHRwcm9wZXJ0eU5hbWUgPSBidWlsZGVyLmdldFZlcnRleEluZGV4KCk7XHJcblxyXG5cdFx0fSBlbHNlIGlmICggc2NvcGUgPT09IEluZGV4Tm9kZS5JTlNUQU5DRSApIHtcclxuXHJcblx0XHRcdHByb3BlcnR5TmFtZSA9IGJ1aWxkZXIuZ2V0SW5zdGFuY2VJbmRleCgpO1xyXG5cclxuXHRcdH0gZWxzZSBpZiAoIHNjb3BlID09PSBJbmRleE5vZGUuRFJBVyApIHtcclxuXHJcblx0XHRcdHByb3BlcnR5TmFtZSA9IGJ1aWxkZXIuZ2V0RHJhd0luZGV4KCk7XHJcblxyXG5cdFx0fSBlbHNlIGlmICggc2NvcGUgPT09IEluZGV4Tm9kZS5JTlZPQ0FUSU9OX0xPQ0FMICkge1xyXG5cclxuXHRcdFx0cHJvcGVydHlOYW1lID0gYnVpbGRlci5nZXRJbnZvY2F0aW9uTG9jYWxJbmRleCgpO1xyXG5cclxuXHRcdH0gZWxzZSBpZiAoIHNjb3BlID09PSBJbmRleE5vZGUuSU5WT0NBVElPTl9TVUJHUk9VUCApIHtcclxuXHJcblx0XHRcdHByb3BlcnR5TmFtZSA9IGJ1aWxkZXIuZ2V0SW52b2NhdGlvblN1Ymdyb3VwSW5kZXgoKTtcclxuXHJcblx0XHR9IGVsc2UgaWYgKCBzY29wZSA9PT0gSW5kZXhOb2RlLlNVQkdST1VQICkge1xyXG5cclxuXHRcdFx0cHJvcGVydHlOYW1lID0gYnVpbGRlci5nZXRTdWJncm91cEluZGV4KCk7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdHRocm93IG5ldyBFcnJvciggJ1RIUkVFLkluZGV4Tm9kZTogVW5rbm93biBzY29wZTogJyArIHNjb3BlICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGxldCBvdXRwdXQ7XHJcblxyXG5cdFx0aWYgKCBidWlsZGVyLnNoYWRlclN0YWdlID09PSAndmVydGV4JyB8fCBidWlsZGVyLnNoYWRlclN0YWdlID09PSAnY29tcHV0ZScgKSB7XHJcblxyXG5cdFx0XHRvdXRwdXQgPSBwcm9wZXJ0eU5hbWU7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdGNvbnN0IG5vZGVWYXJ5aW5nID0gdmFyeWluZyggdGhpcyApO1xyXG5cclxuXHRcdFx0b3V0cHV0ID0gbm9kZVZhcnlpbmcuYnVpbGQoIGJ1aWxkZXIsIG5vZGVUeXBlICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBvdXRwdXQ7XHJcblxyXG5cdH1cclxuXHJcbn1cclxuXHJcbkluZGV4Tm9kZS5WRVJURVggPSAndmVydGV4JztcclxuSW5kZXhOb2RlLklOU1RBTkNFID0gJ2luc3RhbmNlJztcclxuSW5kZXhOb2RlLlNVQkdST1VQID0gJ3N1Ymdyb3VwJztcclxuSW5kZXhOb2RlLklOVk9DQVRJT05fTE9DQUwgPSAnaW52b2NhdGlvbkxvY2FsJztcclxuSW5kZXhOb2RlLklOVk9DQVRJT05fU1VCR1JPVVAgPSAnaW52b2NhdGlvblN1Ymdyb3VwJztcclxuSW5kZXhOb2RlLkRSQVcgPSAnZHJhdyc7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBJbmRleE5vZGU7XHJcblxyXG4vKipcclxuICogVFNMIG9iamVjdCB0aGF0IHJlcHJlc2VudHMgdGhlIGluZGV4IG9mIGEgdmVydGV4IHdpdGhpbiBhIG1lc2guXHJcbiAqXHJcbiAqIEB0eXBlIHtJbmRleE5vZGV9XHJcbiAqL1xyXG5leHBvcnQgY29uc3QgdmVydGV4SW5kZXggPSAvKkBfX1BVUkVfXyovIG5vZGVJbW11dGFibGUoIEluZGV4Tm9kZSwgSW5kZXhOb2RlLlZFUlRFWCApO1xyXG5cclxuLyoqXHJcbiAqIFRTTCBvYmplY3QgdGhhdCByZXByZXNlbnRzIHRoZSBpbmRleCBvZiBlaXRoZXIgYSBtZXNoIGluc3RhbmNlIG9yIGFuIGludm9jYXRpb24gb2YgYSBjb21wdXRlIHNoYWRlci5cclxuICpcclxuICogQHR5cGUge0luZGV4Tm9kZX1cclxuICovXHJcbmV4cG9ydCBjb25zdCBpbnN0YW5jZUluZGV4ID0gLypAX19QVVJFX18qLyBub2RlSW1tdXRhYmxlKCBJbmRleE5vZGUsIEluZGV4Tm9kZS5JTlNUQU5DRSApO1xyXG5cclxuLyoqXHJcbiAqIFRTTCBvYmplY3QgdGhhdCByZXByZXNlbnRzIHRoZSBpbmRleCBvZiB0aGUgc3ViZ3JvdXAgdGhlIGN1cnJlbnQgY29tcHV0ZSBpbnZvY2F0aW9uIGJlbG9uZ3MgdG8uXHJcbiAqXHJcbiAqIEB0eXBlIHtJbmRleE5vZGV9XHJcbiAqL1xyXG5leHBvcnQgY29uc3Qgc3ViZ3JvdXBJbmRleCA9IC8qQF9fUFVSRV9fKi8gbm9kZUltbXV0YWJsZSggSW5kZXhOb2RlLCBJbmRleE5vZGUuU1VCR1JPVVAgKTtcclxuXHJcbi8qKlxyXG4gKiBUU0wgb2JqZWN0IHRoYXQgcmVwcmVzZW50cyB0aGUgaW5kZXggb2YgYSBjb21wdXRlIGludm9jYXRpb24gd2l0aGluIHRoZSBzY29wZSBvZiBhIHN1Ymdyb3VwLlxyXG4gKlxyXG4gKiBAdHlwZSB7SW5kZXhOb2RlfVxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IGludm9jYXRpb25TdWJncm91cEluZGV4ID0gLypAX19QVVJFX18qLyBub2RlSW1tdXRhYmxlKCBJbmRleE5vZGUsIEluZGV4Tm9kZS5JTlZPQ0FUSU9OX1NVQkdST1VQICk7XHJcblxyXG4vKipcclxuICogVFNMIG9iamVjdCB0aGF0IHJlcHJlc2VudHMgdGhlIGluZGV4IG9mIGEgY29tcHV0ZSBpbnZvY2F0aW9uIHdpdGhpbiB0aGUgc2NvcGUgb2YgYSB3b3JrZ3JvdXAgbG9hZC5cclxuICpcclxuICogQHR5cGUge0luZGV4Tm9kZX1cclxuICovXHJcbmV4cG9ydCBjb25zdCBpbnZvY2F0aW9uTG9jYWxJbmRleCA9IC8qQF9fUFVSRV9fKi8gbm9kZUltbXV0YWJsZSggSW5kZXhOb2RlLCBJbmRleE5vZGUuSU5WT0NBVElPTl9MT0NBTCApO1xyXG5cclxuLyoqXHJcbiAqIFRTTCBvYmplY3QgdGhhdCByZXByZXNlbnRzIHRoZSBpbmRleCBvZiBhIGRyYXcgY2FsbC5cclxuICpcclxuICogQHR5cGUge0luZGV4Tm9kZX1cclxuICovXHJcbmV4cG9ydCBjb25zdCBkcmF3SW5kZXggPSAvKkBfX1BVUkVfXyovIG5vZGVJbW11dGFibGUoIEluZGV4Tm9kZSwgSW5kZXhOb2RlLkRSQVcgKTtcclxuIiwiaW1wb3J0IE5vZGUgZnJvbSAnLi4vY29yZS9Ob2RlLmpzJztcclxuaW1wb3J0IHsgdmFyeWluZ1Byb3BlcnR5IH0gZnJvbSAnLi4vY29yZS9Qcm9wZXJ0eU5vZGUuanMnO1xyXG5pbXBvcnQgeyBpbnN0YW5jZWRCdWZmZXJBdHRyaWJ1dGUsIGluc3RhbmNlZER5bmFtaWNCdWZmZXJBdHRyaWJ1dGUgfSBmcm9tICcuL0J1ZmZlckF0dHJpYnV0ZU5vZGUuanMnO1xyXG5pbXBvcnQgeyBub3JtYWxMb2NhbCwgdHJhbnNmb3JtTm9ybWFsIH0gZnJvbSAnLi9Ob3JtYWwuanMnO1xyXG5pbXBvcnQgeyBwb3NpdGlvbkxvY2FsIH0gZnJvbSAnLi9Qb3NpdGlvbi5qcyc7XHJcbmltcG9ydCB7IG5vZGVQcm94eSwgdmVjMywgbWF0NCB9IGZyb20gJy4uL3RzbC9UU0xCYXNlLmpzJztcclxuaW1wb3J0IHsgTm9kZVVwZGF0ZVR5cGUgfSBmcm9tICcuLi9jb3JlL2NvbnN0YW50cy5qcyc7XHJcbmltcG9ydCB7IGJ1ZmZlciB9IGZyb20gJy4uL2FjY2Vzc29ycy9CdWZmZXJOb2RlLmpzJztcclxuaW1wb3J0IHsgaW5zdGFuY2VJbmRleCB9IGZyb20gJy4uL2NvcmUvSW5kZXhOb2RlLmpzJztcclxuXHJcbmltcG9ydCB7IEluc3RhbmNlZEludGVybGVhdmVkQnVmZmVyIH0gZnJvbSAnLi4vLi4vY29yZS9JbnN0YW5jZWRJbnRlcmxlYXZlZEJ1ZmZlci5qcyc7XHJcbmltcG9ydCB7IEluc3RhbmNlZEJ1ZmZlckF0dHJpYnV0ZSB9IGZyb20gJy4uLy4uL2NvcmUvSW5zdGFuY2VkQnVmZmVyQXR0cmlidXRlLmpzJztcclxuaW1wb3J0IHsgRHluYW1pY0RyYXdVc2FnZSB9IGZyb20gJy4uLy4uL2NvbnN0YW50cy5qcyc7XHJcblxyXG5jbGFzcyBJbnN0YW5jZU5vZGUgZXh0ZW5kcyBOb2RlIHtcclxuXHJcblx0c3RhdGljIGdldCB0eXBlKCkge1xyXG5cclxuXHRcdHJldHVybiAnSW5zdGFuY2VOb2RlJztcclxuXHJcblx0fVxyXG5cclxuXHRjb25zdHJ1Y3RvciggY291bnQsIGluc3RhbmNlTWF0cml4LCBpbnN0YW5jZUNvbG9yICkge1xyXG5cclxuXHRcdHN1cGVyKCAndm9pZCcgKTtcclxuXHJcblx0XHR0aGlzLmNvdW50ID0gY291bnQ7XHJcblx0XHR0aGlzLmluc3RhbmNlTWF0cml4ID0gaW5zdGFuY2VNYXRyaXg7XHJcblx0XHR0aGlzLmluc3RhbmNlQ29sb3IgPSBpbnN0YW5jZUNvbG9yO1xyXG5cclxuXHRcdHRoaXMuaW5zdGFuY2VNYXRyaXhOb2RlID0gbnVsbDtcclxuXHJcblx0XHR0aGlzLmluc3RhbmNlQ29sb3JOb2RlID0gbnVsbDtcclxuXHJcblx0XHR0aGlzLnVwZGF0ZVR5cGUgPSBOb2RlVXBkYXRlVHlwZS5GUkFNRTtcclxuXHJcblx0XHR0aGlzLmJ1ZmZlciA9IG51bGw7XHJcblx0XHR0aGlzLmJ1ZmZlckNvbG9yID0gbnVsbDtcclxuXHJcblx0fVxyXG5cclxuXHRzZXR1cCggYnVpbGRlciApIHtcclxuXHJcblx0XHRjb25zdCB7IGNvdW50LCBpbnN0YW5jZU1hdHJpeCwgaW5zdGFuY2VDb2xvciB9ID0gdGhpcztcclxuXHJcblx0XHRsZXQgeyBpbnN0YW5jZU1hdHJpeE5vZGUsIGluc3RhbmNlQ29sb3JOb2RlIH0gPSB0aGlzO1xyXG5cclxuXHRcdGlmICggaW5zdGFuY2VNYXRyaXhOb2RlID09PSBudWxsICkge1xyXG5cclxuXHRcdFx0Ly8gQm90aCBXZWJHUFUgYW5kIFdlYkdMIGJhY2tlbmRzIGhhdmUgVUJPIG1heCBsaW1pdGVkIHRvIDY0a2IuIE1hdHJpeCBjb3VudCBudW1iZXIgYmlnZ2VyIHRoYW4gMTAwMCAoIDE2ICogNCAqIDEwMDAgPSA2NGtiICkgd2lsbCBmYWxsYmFjayB0byBhdHRyaWJ1dGUuXHJcblxyXG5cdFx0XHRpZiAoIGNvdW50IDw9IDEwMDAgKSB7XHJcblxyXG5cdFx0XHRcdGluc3RhbmNlTWF0cml4Tm9kZSA9IGJ1ZmZlciggaW5zdGFuY2VNYXRyaXguYXJyYXksICdtYXQ0JywgTWF0aC5tYXgoIGNvdW50LCAxICkgKS5lbGVtZW50KCBpbnN0YW5jZUluZGV4ICk7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRjb25zdCBidWZmZXIgPSBuZXcgSW5zdGFuY2VkSW50ZXJsZWF2ZWRCdWZmZXIoIGluc3RhbmNlTWF0cml4LmFycmF5LCAxNiwgMSApO1xyXG5cclxuXHRcdFx0XHR0aGlzLmJ1ZmZlciA9IGJ1ZmZlcjtcclxuXHJcblx0XHRcdFx0Y29uc3QgYnVmZmVyRm4gPSBpbnN0YW5jZU1hdHJpeC51c2FnZSA9PT0gRHluYW1pY0RyYXdVc2FnZSA/IGluc3RhbmNlZER5bmFtaWNCdWZmZXJBdHRyaWJ1dGUgOiBpbnN0YW5jZWRCdWZmZXJBdHRyaWJ1dGU7XHJcblxyXG5cdFx0XHRcdGNvbnN0IGluc3RhbmNlQnVmZmVycyA9IFtcclxuXHRcdFx0XHRcdC8vIEYuU2lnbmF0dXJlIC0+IGJ1ZmZlckF0dHJpYnV0ZSggYXJyYXksIHR5cGUsIHN0cmlkZSwgb2Zmc2V0IClcclxuXHRcdFx0XHRcdGJ1ZmZlckZuKCBidWZmZXIsICd2ZWM0JywgMTYsIDAgKSxcclxuXHRcdFx0XHRcdGJ1ZmZlckZuKCBidWZmZXIsICd2ZWM0JywgMTYsIDQgKSxcclxuXHRcdFx0XHRcdGJ1ZmZlckZuKCBidWZmZXIsICd2ZWM0JywgMTYsIDggKSxcclxuXHRcdFx0XHRcdGJ1ZmZlckZuKCBidWZmZXIsICd2ZWM0JywgMTYsIDEyIClcclxuXHRcdFx0XHRdO1xyXG5cclxuXHRcdFx0XHRpbnN0YW5jZU1hdHJpeE5vZGUgPSBtYXQ0KCAuLi5pbnN0YW5jZUJ1ZmZlcnMgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHRoaXMuaW5zdGFuY2VNYXRyaXhOb2RlID0gaW5zdGFuY2VNYXRyaXhOb2RlO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIGluc3RhbmNlQ29sb3IgJiYgaW5zdGFuY2VDb2xvck5vZGUgPT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHRjb25zdCBidWZmZXIgPSBuZXcgSW5zdGFuY2VkQnVmZmVyQXR0cmlidXRlKCBpbnN0YW5jZUNvbG9yLmFycmF5LCAzICk7XHJcblxyXG5cdFx0XHRjb25zdCBidWZmZXJGbiA9IGluc3RhbmNlQ29sb3IudXNhZ2UgPT09IER5bmFtaWNEcmF3VXNhZ2UgPyBpbnN0YW5jZWREeW5hbWljQnVmZmVyQXR0cmlidXRlIDogaW5zdGFuY2VkQnVmZmVyQXR0cmlidXRlO1xyXG5cclxuXHRcdFx0dGhpcy5idWZmZXJDb2xvciA9IGJ1ZmZlcjtcclxuXHJcblx0XHRcdGluc3RhbmNlQ29sb3JOb2RlID0gdmVjMyggYnVmZmVyRm4oIGJ1ZmZlciwgJ3ZlYzMnLCAzLCAwICkgKTtcclxuXHJcblx0XHRcdHRoaXMuaW5zdGFuY2VDb2xvck5vZGUgPSBpbnN0YW5jZUNvbG9yTm9kZTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gUE9TSVRJT05cclxuXHJcblx0XHRjb25zdCBpbnN0YW5jZVBvc2l0aW9uID0gaW5zdGFuY2VNYXRyaXhOb2RlLm11bCggcG9zaXRpb25Mb2NhbCApLnh5ejtcclxuXHRcdHBvc2l0aW9uTG9jYWwuYXNzaWduKCBpbnN0YW5jZVBvc2l0aW9uICk7XHJcblxyXG5cdFx0Ly8gTk9STUFMXHJcblxyXG5cdFx0aWYgKCBidWlsZGVyLmhhc0dlb21ldHJ5QXR0cmlidXRlKCAnbm9ybWFsJyApICkge1xyXG5cclxuXHRcdFx0Y29uc3QgaW5zdGFuY2VOb3JtYWwgPSB0cmFuc2Zvcm1Ob3JtYWwoIG5vcm1hbExvY2FsLCBpbnN0YW5jZU1hdHJpeE5vZGUgKTtcclxuXHJcblx0XHRcdC8vIEFTU0lHTlNcclxuXHJcblx0XHRcdG5vcm1hbExvY2FsLmFzc2lnbiggaW5zdGFuY2VOb3JtYWwgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gQ09MT1JcclxuXHJcblx0XHRpZiAoIHRoaXMuaW5zdGFuY2VDb2xvck5vZGUgIT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHR2YXJ5aW5nUHJvcGVydHkoICd2ZWMzJywgJ3ZJbnN0YW5jZUNvbG9yJyApLmFzc2lnbiggdGhpcy5pbnN0YW5jZUNvbG9yTm9kZSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHR1cGRhdGUoIC8qZnJhbWUqLyApIHtcclxuXHJcblx0XHRpZiAoIHRoaXMuaW5zdGFuY2VNYXRyaXgudXNhZ2UgIT09IER5bmFtaWNEcmF3VXNhZ2UgJiYgdGhpcy5idWZmZXIgIT09IG51bGwgJiYgdGhpcy5pbnN0YW5jZU1hdHJpeC52ZXJzaW9uICE9PSB0aGlzLmJ1ZmZlci52ZXJzaW9uICkge1xyXG5cclxuXHRcdFx0dGhpcy5idWZmZXIudmVyc2lvbiA9IHRoaXMuaW5zdGFuY2VNYXRyaXgudmVyc2lvbjtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCB0aGlzLmluc3RhbmNlQ29sb3IgJiYgdGhpcy5pbnN0YW5jZUNvbG9yLnVzYWdlICE9PSBEeW5hbWljRHJhd1VzYWdlICYmIHRoaXMuYnVmZmVyQ29sb3IgIT09IG51bGwgJiYgdGhpcy5pbnN0YW5jZUNvbG9yLnZlcnNpb24gIT09IHRoaXMuYnVmZmVyQ29sb3IudmVyc2lvbiApIHtcclxuXHJcblx0XHRcdHRoaXMuYnVmZmVyQ29sb3IudmVyc2lvbiA9IHRoaXMuaW5zdGFuY2VDb2xvci52ZXJzaW9uO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgSW5zdGFuY2VOb2RlO1xyXG5cclxuZXhwb3J0IGNvbnN0IGluc3RhbmNlID0gLypAX19QVVJFX18qLyBub2RlUHJveHkoIEluc3RhbmNlTm9kZSApO1xyXG4iLCJpbXBvcnQgSW5zdGFuY2VOb2RlIGZyb20gJy4vSW5zdGFuY2VOb2RlLmpzJztcclxuaW1wb3J0IHsgbm9kZVByb3h5IH0gZnJvbSAnLi4vdHNsL1RTTEJhc2UuanMnO1xyXG5cclxuY2xhc3MgSW5zdGFuY2VkTWVzaE5vZGUgZXh0ZW5kcyBJbnN0YW5jZU5vZGUge1xyXG5cclxuXHRzdGF0aWMgZ2V0IHR5cGUoKSB7XHJcblxyXG5cdFx0cmV0dXJuICdJbnN0YW5jZWRNZXNoTm9kZSc7XHJcblxyXG5cdH1cclxuXHJcblx0Y29uc3RydWN0b3IoIGluc3RhbmNlTWVzaCApIHtcclxuXHJcblx0XHRjb25zdCB7IGNvdW50LCBpbnN0YW5jZU1hdHJpeCwgaW5zdGFuY2VDb2xvciB9ID0gaW5zdGFuY2VNZXNoO1xyXG5cclxuXHRcdHN1cGVyKCBjb3VudCwgaW5zdGFuY2VNYXRyaXgsIGluc3RhbmNlQ29sb3IgKTtcclxuXHJcblx0XHR0aGlzLmluc3RhbmNlTWVzaCA9IGluc3RhbmNlTWVzaDtcclxuXHJcblx0fVxyXG5cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgSW5zdGFuY2VkTWVzaE5vZGU7XHJcblxyXG5leHBvcnQgY29uc3QgaW5zdGFuY2VkTWVzaCA9IC8qQF9fUFVSRV9fKi8gbm9kZVByb3h5KCBJbnN0YW5jZWRNZXNoTm9kZSApO1xyXG4iLCJpbXBvcnQgTm9kZSBmcm9tICcuLi9jb3JlL05vZGUuanMnO1xyXG5pbXBvcnQgeyBub3JtYWxMb2NhbCB9IGZyb20gJy4vTm9ybWFsLmpzJztcclxuaW1wb3J0IHsgcG9zaXRpb25Mb2NhbCB9IGZyb20gJy4vUG9zaXRpb24uanMnO1xyXG5pbXBvcnQgeyBub2RlUHJveHksIHZlYzMsIG1hdDMsIG1hdDQsIGludCwgaXZlYzIsIGZsb2F0LCBGbiB9IGZyb20gJy4uL3RzbC9UU0xCYXNlLmpzJztcclxuaW1wb3J0IHsgdGV4dHVyZUxvYWQgfSBmcm9tICcuL1RleHR1cmVOb2RlLmpzJztcclxuaW1wb3J0IHsgdGV4dHVyZVNpemUgfSBmcm9tICcuL1RleHR1cmVTaXplTm9kZS5qcyc7XHJcbmltcG9ydCB7IHRhbmdlbnRMb2NhbCB9IGZyb20gJy4vVGFuZ2VudC5qcyc7XHJcbmltcG9ydCB7IGluc3RhbmNlSW5kZXgsIGRyYXdJbmRleCB9IGZyb20gJy4uL2NvcmUvSW5kZXhOb2RlLmpzJztcclxuaW1wb3J0IHsgdmFyeWluZ1Byb3BlcnR5IH0gZnJvbSAnLi4vY29yZS9Qcm9wZXJ0eU5vZGUuanMnO1xyXG5cclxuY2xhc3MgQmF0Y2hOb2RlIGV4dGVuZHMgTm9kZSB7XHJcblxyXG5cdHN0YXRpYyBnZXQgdHlwZSgpIHtcclxuXHJcblx0XHRyZXR1cm4gJ0JhdGNoTm9kZSc7XHJcblxyXG5cdH1cclxuXHJcblx0Y29uc3RydWN0b3IoIGJhdGNoTWVzaCApIHtcclxuXHJcblx0XHRzdXBlciggJ3ZvaWQnICk7XHJcblxyXG5cdFx0dGhpcy5iYXRjaE1lc2ggPSBiYXRjaE1lc2g7XHJcblxyXG5cclxuXHRcdHRoaXMuYmF0Y2hpbmdJZE5vZGUgPSBudWxsO1xyXG5cclxuXHR9XHJcblxyXG5cdHNldHVwKCBidWlsZGVyICkge1xyXG5cclxuXHRcdC8vIFBPU0lUSU9OXHJcblxyXG5cdFx0aWYgKCB0aGlzLmJhdGNoaW5nSWROb2RlID09PSBudWxsICkge1xyXG5cclxuXHRcdFx0aWYgKCBidWlsZGVyLmdldERyYXdJbmRleCgpID09PSBudWxsICkge1xyXG5cclxuXHRcdFx0XHR0aGlzLmJhdGNoaW5nSWROb2RlID0gaW5zdGFuY2VJbmRleDtcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdHRoaXMuYmF0Y2hpbmdJZE5vZGUgPSBkcmF3SW5kZXg7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGNvbnN0IGdldEluZGlyZWN0SW5kZXggPSBGbiggKCBbIGlkIF0gKSA9PiB7XHJcblxyXG5cdFx0XHRjb25zdCBzaXplID0gdGV4dHVyZVNpemUoIHRleHR1cmVMb2FkKCB0aGlzLmJhdGNoTWVzaC5faW5kaXJlY3RUZXh0dXJlICksIDAgKTtcclxuXHRcdFx0Y29uc3QgeCA9IGludCggaWQgKS5tb2RJbnQoIGludCggc2l6ZSApICk7XHJcblx0XHRcdGNvbnN0IHkgPSBpbnQoIGlkICkuZGl2KCBpbnQoIHNpemUgKSApO1xyXG5cdFx0XHRyZXR1cm4gdGV4dHVyZUxvYWQoIHRoaXMuYmF0Y2hNZXNoLl9pbmRpcmVjdFRleHR1cmUsIGl2ZWMyKCB4LCB5ICkgKS54O1xyXG5cclxuXHRcdH0gKS5zZXRMYXlvdXQoIHtcclxuXHRcdFx0bmFtZTogJ2dldEluZGlyZWN0SW5kZXgnLFxyXG5cdFx0XHR0eXBlOiAndWludCcsXHJcblx0XHRcdGlucHV0czogW1xyXG5cdFx0XHRcdHsgbmFtZTogJ2lkJywgdHlwZTogJ2ludCcgfVxyXG5cdFx0XHRdXHJcblx0XHR9ICk7XHJcblxyXG5cdFx0Y29uc3QgaW5kaXJlY3RJZCA9IGdldEluZGlyZWN0SW5kZXgoIGludCggdGhpcy5iYXRjaGluZ0lkTm9kZSApICk7XHJcblxyXG5cdFx0Y29uc3QgbWF0cmljZXNUZXh0dXJlID0gdGhpcy5iYXRjaE1lc2guX21hdHJpY2VzVGV4dHVyZTtcclxuXHJcblx0XHRjb25zdCBzaXplID0gdGV4dHVyZVNpemUoIHRleHR1cmVMb2FkKCBtYXRyaWNlc1RleHR1cmUgKSwgMCApO1xyXG5cdFx0Y29uc3QgaiA9IGZsb2F0KCBpbmRpcmVjdElkICkubXVsKCA0ICkudG9JbnQoKS50b1ZhcigpO1xyXG5cclxuXHRcdGNvbnN0IHggPSBqLm1vZEludCggc2l6ZSApO1xyXG5cdFx0Y29uc3QgeSA9IGouZGl2KCBpbnQoIHNpemUgKSApO1xyXG5cdFx0Y29uc3QgYmF0Y2hpbmdNYXRyaXggPSBtYXQ0KFxyXG5cdFx0XHR0ZXh0dXJlTG9hZCggbWF0cmljZXNUZXh0dXJlLCBpdmVjMiggeCwgeSApICksXHJcblx0XHRcdHRleHR1cmVMb2FkKCBtYXRyaWNlc1RleHR1cmUsIGl2ZWMyKCB4LmFkZCggMSApLCB5ICkgKSxcclxuXHRcdFx0dGV4dHVyZUxvYWQoIG1hdHJpY2VzVGV4dHVyZSwgaXZlYzIoIHguYWRkKCAyICksIHkgKSApLFxyXG5cdFx0XHR0ZXh0dXJlTG9hZCggbWF0cmljZXNUZXh0dXJlLCBpdmVjMiggeC5hZGQoIDMgKSwgeSApIClcclxuXHRcdCk7XHJcblxyXG5cclxuXHRcdGNvbnN0IGNvbG9yc1RleHR1cmUgPSB0aGlzLmJhdGNoTWVzaC5fY29sb3JzVGV4dHVyZTtcclxuXHJcblx0XHRpZiAoIGNvbG9yc1RleHR1cmUgIT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHRjb25zdCBnZXRCYXRjaGluZ0NvbG9yID0gRm4oICggWyBpZCBdICkgPT4ge1xyXG5cclxuXHRcdFx0XHRjb25zdCBzaXplID0gdGV4dHVyZVNpemUoIHRleHR1cmVMb2FkKCBjb2xvcnNUZXh0dXJlICksIDAgKS54O1xyXG5cdFx0XHRcdGNvbnN0IGogPSBpZDtcclxuXHRcdFx0XHRjb25zdCB4ID0gai5tb2RJbnQoIHNpemUgKTtcclxuXHRcdFx0XHRjb25zdCB5ID0gai5kaXYoIHNpemUgKTtcclxuXHRcdFx0XHRyZXR1cm4gdGV4dHVyZUxvYWQoIGNvbG9yc1RleHR1cmUsIGl2ZWMyKCB4LCB5ICkgKS5yZ2I7XHJcblxyXG5cdFx0XHR9ICkuc2V0TGF5b3V0KCB7XHJcblx0XHRcdFx0bmFtZTogJ2dldEJhdGNoaW5nQ29sb3InLFxyXG5cdFx0XHRcdHR5cGU6ICd2ZWMzJyxcclxuXHRcdFx0XHRpbnB1dHM6IFtcclxuXHRcdFx0XHRcdHsgbmFtZTogJ2lkJywgdHlwZTogJ2ludCcgfVxyXG5cdFx0XHRcdF1cclxuXHRcdFx0fSApO1xyXG5cclxuXHRcdFx0Y29uc3QgY29sb3IgPSBnZXRCYXRjaGluZ0NvbG9yKCBpbmRpcmVjdElkICk7XHJcblxyXG5cdFx0XHR2YXJ5aW5nUHJvcGVydHkoICd2ZWMzJywgJ3ZCYXRjaENvbG9yJyApLmFzc2lnbiggY29sb3IgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Y29uc3QgYm0gPSBtYXQzKCBiYXRjaGluZ01hdHJpeCApO1xyXG5cclxuXHRcdHBvc2l0aW9uTG9jYWwuYXNzaWduKCBiYXRjaGluZ01hdHJpeC5tdWwoIHBvc2l0aW9uTG9jYWwgKSApO1xyXG5cclxuXHRcdGNvbnN0IHRyYW5zZm9ybWVkTm9ybWFsID0gbm9ybWFsTG9jYWwuZGl2KCB2ZWMzKCBibVsgMCBdLmRvdCggYm1bIDAgXSApLCBibVsgMSBdLmRvdCggYm1bIDEgXSApLCBibVsgMiBdLmRvdCggYm1bIDIgXSApICkgKTtcclxuXHJcblx0XHRjb25zdCBiYXRjaGluZ05vcm1hbCA9IGJtLm11bCggdHJhbnNmb3JtZWROb3JtYWwgKS54eXo7XHJcblxyXG5cdFx0bm9ybWFsTG9jYWwuYXNzaWduKCBiYXRjaGluZ05vcm1hbCApO1xyXG5cclxuXHRcdGlmICggYnVpbGRlci5oYXNHZW9tZXRyeUF0dHJpYnV0ZSggJ3RhbmdlbnQnICkgKSB7XHJcblxyXG5cdFx0XHR0YW5nZW50TG9jYWwubXVsQXNzaWduKCBibSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgQmF0Y2hOb2RlO1xyXG5cclxuZXhwb3J0IGNvbnN0IGJhdGNoID0gLypAX19QVVJFX18qLyBub2RlUHJveHkoIEJhdGNoTm9kZSApO1xyXG4iLCJpbXBvcnQgTm9kZSBmcm9tICcuLi9jb3JlL05vZGUuanMnO1xyXG5pbXBvcnQgeyBOb2RlVXBkYXRlVHlwZSB9IGZyb20gJy4uL2NvcmUvY29uc3RhbnRzLmpzJztcclxuaW1wb3J0IHsgbm9kZU9iamVjdCB9IGZyb20gJy4uL3RzbC9UU0xCYXNlLmpzJztcclxuaW1wb3J0IHsgYXR0cmlidXRlIH0gZnJvbSAnLi4vY29yZS9BdHRyaWJ1dGVOb2RlLmpzJztcclxuaW1wb3J0IHsgcmVmZXJlbmNlLCByZWZlcmVuY2VCdWZmZXIgfSBmcm9tICcuL1JlZmVyZW5jZU5vZGUuanMnO1xyXG5pbXBvcnQgeyBhZGQgfSBmcm9tICcuLi9tYXRoL09wZXJhdG9yTm9kZS5qcyc7XHJcbmltcG9ydCB7IG5vcm1hbExvY2FsIH0gZnJvbSAnLi9Ob3JtYWwuanMnO1xyXG5pbXBvcnQgeyBwb3NpdGlvbkxvY2FsLCBwb3NpdGlvblByZXZpb3VzIH0gZnJvbSAnLi9Qb3NpdGlvbi5qcyc7XHJcbmltcG9ydCB7IHRhbmdlbnRMb2NhbCB9IGZyb20gJy4vVGFuZ2VudC5qcyc7XHJcbmltcG9ydCB7IHVuaWZvcm0gfSBmcm9tICcuLi9jb3JlL1VuaWZvcm1Ob2RlLmpzJztcclxuaW1wb3J0IHsgYnVmZmVyIH0gZnJvbSAnLi9CdWZmZXJOb2RlLmpzJztcclxuXHJcbmNvbnN0IF9mcmFtZUlkID0gbmV3IFdlYWtNYXAoKTtcclxuXHJcbmNsYXNzIFNraW5uaW5nTm9kZSBleHRlbmRzIE5vZGUge1xyXG5cclxuXHRzdGF0aWMgZ2V0IHR5cGUoKSB7XHJcblxyXG5cdFx0cmV0dXJuICdTa2lubmluZ05vZGUnO1xyXG5cclxuXHR9XHJcblxyXG5cdGNvbnN0cnVjdG9yKCBza2lubmVkTWVzaCwgdXNlUmVmZXJlbmNlID0gZmFsc2UgKSB7XHJcblxyXG5cdFx0c3VwZXIoICd2b2lkJyApO1xyXG5cclxuXHRcdHRoaXMuc2tpbm5lZE1lc2ggPSBza2lubmVkTWVzaDtcclxuXHRcdHRoaXMudXNlUmVmZXJlbmNlID0gdXNlUmVmZXJlbmNlO1xyXG5cclxuXHRcdHRoaXMudXBkYXRlVHlwZSA9IE5vZGVVcGRhdGVUeXBlLk9CSkVDVDtcclxuXHJcblx0XHQvL1xyXG5cclxuXHRcdHRoaXMuc2tpbkluZGV4Tm9kZSA9IGF0dHJpYnV0ZSggJ3NraW5JbmRleCcsICd1dmVjNCcgKTtcclxuXHRcdHRoaXMuc2tpbldlaWdodE5vZGUgPSBhdHRyaWJ1dGUoICdza2luV2VpZ2h0JywgJ3ZlYzQnICk7XHJcblxyXG5cdFx0bGV0IGJpbmRNYXRyaXhOb2RlLCBiaW5kTWF0cml4SW52ZXJzZU5vZGUsIGJvbmVNYXRyaWNlc05vZGU7XHJcblxyXG5cdFx0aWYgKCB1c2VSZWZlcmVuY2UgKSB7XHJcblxyXG5cdFx0XHRiaW5kTWF0cml4Tm9kZSA9IHJlZmVyZW5jZSggJ2JpbmRNYXRyaXgnLCAnbWF0NCcgKTtcclxuXHRcdFx0YmluZE1hdHJpeEludmVyc2VOb2RlID0gcmVmZXJlbmNlKCAnYmluZE1hdHJpeEludmVyc2UnLCAnbWF0NCcgKTtcclxuXHRcdFx0Ym9uZU1hdHJpY2VzTm9kZSA9IHJlZmVyZW5jZUJ1ZmZlciggJ3NrZWxldG9uLmJvbmVNYXRyaWNlcycsICdtYXQ0Jywgc2tpbm5lZE1lc2guc2tlbGV0b24uYm9uZXMubGVuZ3RoICk7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdGJpbmRNYXRyaXhOb2RlID0gdW5pZm9ybSggc2tpbm5lZE1lc2guYmluZE1hdHJpeCwgJ21hdDQnICk7XHJcblx0XHRcdGJpbmRNYXRyaXhJbnZlcnNlTm9kZSA9IHVuaWZvcm0oIHNraW5uZWRNZXNoLmJpbmRNYXRyaXhJbnZlcnNlLCAnbWF0NCcgKTtcclxuXHRcdFx0Ym9uZU1hdHJpY2VzTm9kZSA9IGJ1ZmZlciggc2tpbm5lZE1lc2guc2tlbGV0b24uYm9uZU1hdHJpY2VzLCAnbWF0NCcsIHNraW5uZWRNZXNoLnNrZWxldG9uLmJvbmVzLmxlbmd0aCApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLmJpbmRNYXRyaXhOb2RlID0gYmluZE1hdHJpeE5vZGU7XHJcblx0XHR0aGlzLmJpbmRNYXRyaXhJbnZlcnNlTm9kZSA9IGJpbmRNYXRyaXhJbnZlcnNlTm9kZTtcclxuXHRcdHRoaXMuYm9uZU1hdHJpY2VzTm9kZSA9IGJvbmVNYXRyaWNlc05vZGU7XHJcblx0XHR0aGlzLnByZXZpb3VzQm9uZU1hdHJpY2VzTm9kZSA9IG51bGw7XHJcblxyXG5cdH1cclxuXHJcblx0Z2V0U2tpbm5lZFBvc2l0aW9uKCBib25lTWF0cmljZXMgPSB0aGlzLmJvbmVNYXRyaWNlc05vZGUsIHBvc2l0aW9uID0gcG9zaXRpb25Mb2NhbCApIHtcclxuXHJcblx0XHRjb25zdCB7IHNraW5JbmRleE5vZGUsIHNraW5XZWlnaHROb2RlLCBiaW5kTWF0cml4Tm9kZSwgYmluZE1hdHJpeEludmVyc2VOb2RlIH0gPSB0aGlzO1xyXG5cclxuXHRcdGNvbnN0IGJvbmVNYXRYID0gYm9uZU1hdHJpY2VzLmVsZW1lbnQoIHNraW5JbmRleE5vZGUueCApO1xyXG5cdFx0Y29uc3QgYm9uZU1hdFkgPSBib25lTWF0cmljZXMuZWxlbWVudCggc2tpbkluZGV4Tm9kZS55ICk7XHJcblx0XHRjb25zdCBib25lTWF0WiA9IGJvbmVNYXRyaWNlcy5lbGVtZW50KCBza2luSW5kZXhOb2RlLnogKTtcclxuXHRcdGNvbnN0IGJvbmVNYXRXID0gYm9uZU1hdHJpY2VzLmVsZW1lbnQoIHNraW5JbmRleE5vZGUudyApO1xyXG5cclxuXHRcdC8vIFBPU0lUSU9OXHJcblxyXG5cdFx0Y29uc3Qgc2tpblZlcnRleCA9IGJpbmRNYXRyaXhOb2RlLm11bCggcG9zaXRpb24gKTtcclxuXHJcblx0XHRjb25zdCBza2lubmVkID0gYWRkKFxyXG5cdFx0XHRib25lTWF0WC5tdWwoIHNraW5XZWlnaHROb2RlLnggKS5tdWwoIHNraW5WZXJ0ZXggKSxcclxuXHRcdFx0Ym9uZU1hdFkubXVsKCBza2luV2VpZ2h0Tm9kZS55ICkubXVsKCBza2luVmVydGV4ICksXHJcblx0XHRcdGJvbmVNYXRaLm11bCggc2tpbldlaWdodE5vZGUueiApLm11bCggc2tpblZlcnRleCApLFxyXG5cdFx0XHRib25lTWF0Vy5tdWwoIHNraW5XZWlnaHROb2RlLncgKS5tdWwoIHNraW5WZXJ0ZXggKVxyXG5cdFx0KTtcclxuXHJcblx0XHRyZXR1cm4gYmluZE1hdHJpeEludmVyc2VOb2RlLm11bCggc2tpbm5lZCApLnh5ejtcclxuXHJcblx0fVxyXG5cclxuXHRnZXRTa2lubmVkTm9ybWFsKCBib25lTWF0cmljZXMgPSB0aGlzLmJvbmVNYXRyaWNlc05vZGUsIG5vcm1hbCA9IG5vcm1hbExvY2FsICkge1xyXG5cclxuXHRcdGNvbnN0IHsgc2tpbkluZGV4Tm9kZSwgc2tpbldlaWdodE5vZGUsIGJpbmRNYXRyaXhOb2RlLCBiaW5kTWF0cml4SW52ZXJzZU5vZGUgfSA9IHRoaXM7XHJcblxyXG5cdFx0Y29uc3QgYm9uZU1hdFggPSBib25lTWF0cmljZXMuZWxlbWVudCggc2tpbkluZGV4Tm9kZS54ICk7XHJcblx0XHRjb25zdCBib25lTWF0WSA9IGJvbmVNYXRyaWNlcy5lbGVtZW50KCBza2luSW5kZXhOb2RlLnkgKTtcclxuXHRcdGNvbnN0IGJvbmVNYXRaID0gYm9uZU1hdHJpY2VzLmVsZW1lbnQoIHNraW5JbmRleE5vZGUueiApO1xyXG5cdFx0Y29uc3QgYm9uZU1hdFcgPSBib25lTWF0cmljZXMuZWxlbWVudCggc2tpbkluZGV4Tm9kZS53ICk7XHJcblxyXG5cdFx0Ly8gTk9STUFMXHJcblxyXG5cdFx0bGV0IHNraW5NYXRyaXggPSBhZGQoXHJcblx0XHRcdHNraW5XZWlnaHROb2RlLngubXVsKCBib25lTWF0WCApLFxyXG5cdFx0XHRza2luV2VpZ2h0Tm9kZS55Lm11bCggYm9uZU1hdFkgKSxcclxuXHRcdFx0c2tpbldlaWdodE5vZGUuei5tdWwoIGJvbmVNYXRaICksXHJcblx0XHRcdHNraW5XZWlnaHROb2RlLncubXVsKCBib25lTWF0VyApXHJcblx0XHQpO1xyXG5cclxuXHRcdHNraW5NYXRyaXggPSBiaW5kTWF0cml4SW52ZXJzZU5vZGUubXVsKCBza2luTWF0cml4ICkubXVsKCBiaW5kTWF0cml4Tm9kZSApO1xyXG5cclxuXHRcdHJldHVybiBza2luTWF0cml4LnRyYW5zZm9ybURpcmVjdGlvbiggbm9ybWFsICkueHl6O1xyXG5cclxuXHR9XHJcblxyXG5cdGdldFByZXZpb3VzU2tpbm5lZFBvc2l0aW9uKCBidWlsZGVyICkge1xyXG5cclxuXHRcdGNvbnN0IHNraW5uZWRNZXNoID0gYnVpbGRlci5vYmplY3Q7XHJcblxyXG5cdFx0aWYgKCB0aGlzLnByZXZpb3VzQm9uZU1hdHJpY2VzTm9kZSA9PT0gbnVsbCApIHtcclxuXHJcblx0XHRcdHNraW5uZWRNZXNoLnNrZWxldG9uLnByZXZpb3VzQm9uZU1hdHJpY2VzID0gbmV3IEZsb2F0MzJBcnJheSggc2tpbm5lZE1lc2guc2tlbGV0b24uYm9uZU1hdHJpY2VzICk7XHJcblxyXG5cdFx0XHR0aGlzLnByZXZpb3VzQm9uZU1hdHJpY2VzTm9kZSA9IHJlZmVyZW5jZUJ1ZmZlciggJ3NrZWxldG9uLnByZXZpb3VzQm9uZU1hdHJpY2VzJywgJ21hdDQnLCBza2lubmVkTWVzaC5za2VsZXRvbi5ib25lcy5sZW5ndGggKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuZ2V0U2tpbm5lZFBvc2l0aW9uKCB0aGlzLnByZXZpb3VzQm9uZU1hdHJpY2VzTm9kZSwgcG9zaXRpb25QcmV2aW91cyApO1xyXG5cclxuXHR9XHJcblxyXG5cdG5lZWRzUHJldmlvdXNCb25lTWF0cmljZXMoIGJ1aWxkZXIgKSB7XHJcblxyXG5cdFx0Y29uc3QgbXJ0ID0gYnVpbGRlci5yZW5kZXJlci5nZXRNUlQoKTtcclxuXHJcblx0XHRyZXR1cm4gbXJ0ICYmIG1ydC5oYXMoICd2ZWxvY2l0eScgKTtcclxuXHJcblx0fVxyXG5cclxuXHRzZXR1cCggYnVpbGRlciApIHtcclxuXHJcblx0XHRpZiAoIHRoaXMubmVlZHNQcmV2aW91c0JvbmVNYXRyaWNlcyggYnVpbGRlciApICkge1xyXG5cclxuXHRcdFx0cG9zaXRpb25QcmV2aW91cy5hc3NpZ24oIHRoaXMuZ2V0UHJldmlvdXNTa2lubmVkUG9zaXRpb24oIGJ1aWxkZXIgKSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRjb25zdCBza2luUG9zaXRpb24gPSB0aGlzLmdldFNraW5uZWRQb3NpdGlvbigpO1xyXG5cclxuXHJcblx0XHRwb3NpdGlvbkxvY2FsLmFzc2lnbiggc2tpblBvc2l0aW9uICk7XHJcblxyXG5cdFx0aWYgKCBidWlsZGVyLmhhc0dlb21ldHJ5QXR0cmlidXRlKCAnbm9ybWFsJyApICkge1xyXG5cclxuXHRcdFx0Y29uc3Qgc2tpbk5vcm1hbCA9IHRoaXMuZ2V0U2tpbm5lZE5vcm1hbCgpO1xyXG5cclxuXHRcdFx0bm9ybWFsTG9jYWwuYXNzaWduKCBza2luTm9ybWFsICk7XHJcblxyXG5cdFx0XHRpZiAoIGJ1aWxkZXIuaGFzR2VvbWV0cnlBdHRyaWJ1dGUoICd0YW5nZW50JyApICkge1xyXG5cclxuXHRcdFx0XHR0YW5nZW50TG9jYWwuYXNzaWduKCBza2luTm9ybWFsICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdGdlbmVyYXRlKCBidWlsZGVyLCBvdXRwdXQgKSB7XHJcblxyXG5cdFx0aWYgKCBvdXRwdXQgIT09ICd2b2lkJyApIHtcclxuXHJcblx0XHRcdHJldHVybiBwb3NpdGlvbkxvY2FsLmJ1aWxkKCBidWlsZGVyLCBvdXRwdXQgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0dXBkYXRlKCBmcmFtZSApIHtcclxuXHJcblx0XHRjb25zdCBvYmplY3QgPSB0aGlzLnVzZVJlZmVyZW5jZSA/IGZyYW1lLm9iamVjdCA6IHRoaXMuc2tpbm5lZE1lc2g7XHJcblx0XHRjb25zdCBza2VsZXRvbiA9IG9iamVjdC5za2VsZXRvbjtcclxuXHJcblx0XHRpZiAoIF9mcmFtZUlkLmdldCggc2tlbGV0b24gKSA9PT0gZnJhbWUuZnJhbWVJZCApIHJldHVybjtcclxuXHJcblx0XHRfZnJhbWVJZC5zZXQoIHNrZWxldG9uLCBmcmFtZS5mcmFtZUlkICk7XHJcblxyXG5cdFx0aWYgKCB0aGlzLnByZXZpb3VzQm9uZU1hdHJpY2VzTm9kZSAhPT0gbnVsbCApIHNrZWxldG9uLnByZXZpb3VzQm9uZU1hdHJpY2VzLnNldCggc2tlbGV0b24uYm9uZU1hdHJpY2VzICk7XHJcblxyXG5cdFx0c2tlbGV0b24udXBkYXRlKCk7XHJcblxyXG5cdH1cclxuXHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IFNraW5uaW5nTm9kZTtcclxuXHJcbmV4cG9ydCBjb25zdCBza2lubmluZyA9ICggc2tpbm5lZE1lc2ggKSA9PiBub2RlT2JqZWN0KCBuZXcgU2tpbm5pbmdOb2RlKCBza2lubmVkTWVzaCApICk7XHJcbmV4cG9ydCBjb25zdCBza2lubmluZ1JlZmVyZW5jZSA9ICggc2tpbm5lZE1lc2ggKSA9PiBub2RlT2JqZWN0KCBuZXcgU2tpbm5pbmdOb2RlKCBza2lubmVkTWVzaCwgdHJ1ZSApICk7XHJcbiIsImltcG9ydCBOb2RlIGZyb20gJy4uL2NvcmUvTm9kZS5qcyc7XHJcbmltcG9ydCB7IGV4cHJlc3Npb24gfSBmcm9tICcuLi9jb2RlL0V4cHJlc3Npb25Ob2RlLmpzJztcclxuaW1wb3J0IHsgbm9kZU9iamVjdCwgbm9kZUFycmF5IH0gZnJvbSAnLi4vdHNsL1RTTEJhc2UuanMnO1xyXG5cclxuLyoqIEBtb2R1bGUgTG9vcE5vZGUgKiovXHJcblxyXG4vKipcclxuICogVGhpcyBtb2R1bGUgb2ZmZXJzIGEgdmFyaWV0eSBvZiB3YXlzIHRvIGltcGxlbWVudCBsb29wcyBpbiBUU0wuIEluIGl0J3MgYmFzaWMgZm9ybSBpdCdzOlxyXG4gKiBgYGBqc1xyXG4gKiBMb29wKCBjb3VudCwgKCB7IGkgfSApID0+IHtcclxuICpcclxuICogfSApO1xyXG4gKiBgYGBcclxuICogSG93ZXZlciwgaXQgaXMgYWxzbyBwb3NzaWJsZSB0byBkZWZpbmUgYSBzdGFydCBhbmQgZW5kIHJhbmdlcywgZGF0YSB0eXBlcyBhbmQgbG9vcCBjb25kaXRpb25zOlxyXG4gKiBgYGBqc1xyXG4gKiBMb29wKCB7IHN0YXJ0OiBpbnQoIDAgKSwgZW5kOiBpbnQoIDEwICksIHR5cGU6ICdpbnQnLCBjb25kaXRpb246ICc8JyB9LCAoIHsgaSB9ICkgPT4ge1xyXG4gKlxyXG4gKiB9ICk7XHJcbiAqYGBgXHJcbiAqIE5lc3RlZCBsb29wcyBjYW4gYmUgZGVmaW5lZCBpbiBhIGNvbXBhY3RlZCBmb3JtOlxyXG4gKiBgYGBqc1xyXG4gKiBMb29wKCAxMCwgNSwgKCB7IGksIGogfSApID0+IHtcclxuICpcclxuICogfSApO1xyXG4gKiBgYGBcclxuICogTG9vcHMgdGhhdCBzaG91bGQgcnVuIGJhY2t3YXJkcyBjYW4gYmUgZGVmaW5lZCBsaWtlIHNvOlxyXG4gKiBgYGBqc1xyXG4gKiBMb29wKCB7IHN0YXJ0OiAxMCB9LCAoKSA9PiB7fSApO1xyXG4gKiBgYGBcclxuICogVGhlIG1vZHVsZSBhbHNvIHByb3ZpZGVzIGBCcmVhaygpYCBhbmQgYENvbnRpbnVlKClgIFRTTCBleHByZXNzaW9uIGZvciBsb29wIGNvbnRyb2wuXHJcbiAqIEBhdWdtZW50cyBOb2RlXHJcbiAqL1xyXG5jbGFzcyBMb29wTm9kZSBleHRlbmRzIE5vZGUge1xyXG5cclxuXHRzdGF0aWMgZ2V0IHR5cGUoKSB7XHJcblxyXG5cdFx0cmV0dXJuICdMb29wTm9kZSc7XHJcblxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogQ29uc3RydWN0cyBhIG5ldyBsb29wIG5vZGUuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge0FycmF5PEFueT59IHBhcmFtcyAtIERlcGVuZGluZyBvbiB0aGUgbG9vcCB0eXBlLCBhcnJheSBob2xkcyBkaWZmZXJlbnQgcGFyYW1ldGVyaXphdGlvbiB2YWx1ZXMgZm9yIHRoZSBsb29wLlxyXG5cdCAqL1xyXG5cdGNvbnN0cnVjdG9yKCBwYXJhbXMgPSBbXSApIHtcclxuXHJcblx0XHRzdXBlcigpO1xyXG5cclxuXHRcdHRoaXMucGFyYW1zID0gcGFyYW1zO1xyXG5cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFJldHVybnMgYSBsb29wIHZhcmlhYmxlIG5hbWUgYmFzZWQgb24gYW4gaW5kZXguIFRoZSBwYXR0ZXJuIGlzXHJcblx0ICogYDBgID0gYGlgLCBgMWA9IGBqYCwgYDJgPSBga2AgYW5kIHNvIG9uLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4IC0gVGhlIGluZGV4LlxyXG5cdCAqIEByZXR1cm4ge1N0cmluZ30gVGhlIGxvb3AgdmFyaWFibGUgbmFtZS5cclxuXHQgKi9cclxuXHRnZXRWYXJOYW1lKCBpbmRleCApIHtcclxuXHJcblx0XHRyZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZSggJ2knLmNoYXJDb2RlQXQoIDAgKSArIGluZGV4ICk7XHJcblxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogUmV0dXJucyBwcm9wZXJ0aWVzIGFib3V0IHRoaXMgbm9kZS5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7Tm9kZUJ1aWxkZXJ9IGJ1aWxkZXIgLSBUaGUgY3VycmVudCBub2RlIGJ1aWxkZXIuXHJcblx0ICogQHJldHVybiB7T2JqZWN0fSBUaGUgbm9kZSBwcm9wZXJ0aWVzLlxyXG5cdCAqL1xyXG5cdGdldFByb3BlcnRpZXMoIGJ1aWxkZXIgKSB7XHJcblxyXG5cdFx0Y29uc3QgcHJvcGVydGllcyA9IGJ1aWxkZXIuZ2V0Tm9kZVByb3BlcnRpZXMoIHRoaXMgKTtcclxuXHJcblx0XHRpZiAoIHByb3BlcnRpZXMuc3RhY2tOb2RlICE9PSB1bmRlZmluZWQgKSByZXR1cm4gcHJvcGVydGllcztcclxuXHJcblx0XHQvL1xyXG5cclxuXHRcdGNvbnN0IGlucHV0cyA9IHt9O1xyXG5cclxuXHRcdGZvciAoIGxldCBpID0gMCwgbCA9IHRoaXMucGFyYW1zLmxlbmd0aCAtIDE7IGkgPCBsOyBpICsrICkge1xyXG5cclxuXHRcdFx0Y29uc3QgcGFyYW0gPSB0aGlzLnBhcmFtc1sgaSBdO1xyXG5cclxuXHRcdFx0Y29uc3QgbmFtZSA9ICggcGFyYW0uaXNOb2RlICE9PSB0cnVlICYmIHBhcmFtLm5hbWUgKSB8fCB0aGlzLmdldFZhck5hbWUoIGkgKTtcclxuXHRcdFx0Y29uc3QgdHlwZSA9ICggcGFyYW0uaXNOb2RlICE9PSB0cnVlICYmIHBhcmFtLnR5cGUgKSB8fCAnaW50JztcclxuXHJcblx0XHRcdGlucHV0c1sgbmFtZSBdID0gZXhwcmVzc2lvbiggbmFtZSwgdHlwZSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRjb25zdCBzdGFjayA9IGJ1aWxkZXIuYWRkU3RhY2soKTsgLy8gVE9ETzogY2FjaGUoKSBpdFxyXG5cclxuXHRcdHByb3BlcnRpZXMucmV0dXJuc05vZGUgPSB0aGlzLnBhcmFtc1sgdGhpcy5wYXJhbXMubGVuZ3RoIC0gMSBdKCBpbnB1dHMsIHN0YWNrLCBidWlsZGVyICk7XHJcblx0XHRwcm9wZXJ0aWVzLnN0YWNrTm9kZSA9IHN0YWNrO1xyXG5cclxuXHRcdGJ1aWxkZXIucmVtb3ZlU3RhY2soKTtcclxuXHJcblx0XHRyZXR1cm4gcHJvcGVydGllcztcclxuXHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBUaGlzIG1ldGhvZCBpcyBvdmVyd3JpdHRlbiBzaW5jZSB0aGUgbm9kZSB0eXBlIGlzIGluZmVycmVkIGJhc2VkIG9uIHRoZSBsb29wIGNvbmZpZ3VyYXRpb24uXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge05vZGVCdWlsZGVyfSBidWlsZGVyIC0gVGhlIGN1cnJlbnQgbm9kZSBidWlsZGVyLlxyXG5cdCAqIEByZXR1cm4ge1N0cmluZ30gVGhlIG5vZGUgdHlwZS5cclxuXHQgKi9cclxuXHRnZXROb2RlVHlwZSggYnVpbGRlciApIHtcclxuXHJcblx0XHRjb25zdCB7IHJldHVybnNOb2RlIH0gPSB0aGlzLmdldFByb3BlcnRpZXMoIGJ1aWxkZXIgKTtcclxuXHJcblx0XHRyZXR1cm4gcmV0dXJuc05vZGUgPyByZXR1cm5zTm9kZS5nZXROb2RlVHlwZSggYnVpbGRlciApIDogJ3ZvaWQnO1xyXG5cclxuXHR9XHJcblxyXG5cdHNldHVwKCBidWlsZGVyICkge1xyXG5cclxuXHRcdC8vIHNldHVwIHByb3BlcnRpZXNcclxuXHJcblx0XHR0aGlzLmdldFByb3BlcnRpZXMoIGJ1aWxkZXIgKTtcclxuXHJcblx0fVxyXG5cclxuXHRnZW5lcmF0ZSggYnVpbGRlciApIHtcclxuXHJcblx0XHRjb25zdCBwcm9wZXJ0aWVzID0gdGhpcy5nZXRQcm9wZXJ0aWVzKCBidWlsZGVyICk7XHJcblxyXG5cdFx0Y29uc3QgcGFyYW1zID0gdGhpcy5wYXJhbXM7XHJcblx0XHRjb25zdCBzdGFja05vZGUgPSBwcm9wZXJ0aWVzLnN0YWNrTm9kZTtcclxuXHJcblx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSBwYXJhbXMubGVuZ3RoIC0gMTsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRjb25zdCBwYXJhbSA9IHBhcmFtc1sgaSBdO1xyXG5cclxuXHRcdFx0bGV0IHN0YXJ0ID0gbnVsbCwgZW5kID0gbnVsbCwgbmFtZSA9IG51bGwsIHR5cGUgPSBudWxsLCBjb25kaXRpb24gPSBudWxsLCB1cGRhdGUgPSBudWxsO1xyXG5cclxuXHRcdFx0aWYgKCBwYXJhbS5pc05vZGUgKSB7XHJcblxyXG5cdFx0XHRcdHR5cGUgPSAnaW50JztcclxuXHRcdFx0XHRuYW1lID0gdGhpcy5nZXRWYXJOYW1lKCBpICk7XHJcblx0XHRcdFx0c3RhcnQgPSAnMCc7XHJcblx0XHRcdFx0ZW5kID0gcGFyYW0uYnVpbGQoIGJ1aWxkZXIsIHR5cGUgKTtcclxuXHRcdFx0XHRjb25kaXRpb24gPSAnPCc7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHR0eXBlID0gcGFyYW0udHlwZSB8fCAnaW50JztcclxuXHRcdFx0XHRuYW1lID0gcGFyYW0ubmFtZSB8fCB0aGlzLmdldFZhck5hbWUoIGkgKTtcclxuXHRcdFx0XHRzdGFydCA9IHBhcmFtLnN0YXJ0O1xyXG5cdFx0XHRcdGVuZCA9IHBhcmFtLmVuZDtcclxuXHRcdFx0XHRjb25kaXRpb24gPSBwYXJhbS5jb25kaXRpb247XHJcblx0XHRcdFx0dXBkYXRlID0gcGFyYW0udXBkYXRlO1xyXG5cclxuXHRcdFx0XHRpZiAoIHR5cGVvZiBzdGFydCA9PT0gJ251bWJlcicgKSBzdGFydCA9IGJ1aWxkZXIuZ2VuZXJhdGVDb25zdCggdHlwZSwgc3RhcnQgKTtcclxuXHRcdFx0XHRlbHNlIGlmICggc3RhcnQgJiYgc3RhcnQuaXNOb2RlICkgc3RhcnQgPSBzdGFydC5idWlsZCggYnVpbGRlciwgdHlwZSApO1xyXG5cclxuXHRcdFx0XHRpZiAoIHR5cGVvZiBlbmQgPT09ICdudW1iZXInICkgZW5kID0gYnVpbGRlci5nZW5lcmF0ZUNvbnN0KCB0eXBlLCBlbmQgKTtcclxuXHRcdFx0XHRlbHNlIGlmICggZW5kICYmIGVuZC5pc05vZGUgKSBlbmQgPSBlbmQuYnVpbGQoIGJ1aWxkZXIsIHR5cGUgKTtcclxuXHJcblx0XHRcdFx0aWYgKCBzdGFydCAhPT0gdW5kZWZpbmVkICYmIGVuZCA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRcdHN0YXJ0ID0gc3RhcnQgKyAnIC0gMSc7XHJcblx0XHRcdFx0XHRlbmQgPSAnMCc7XHJcblx0XHRcdFx0XHRjb25kaXRpb24gPSAnPj0nO1xyXG5cclxuXHRcdFx0XHR9IGVsc2UgaWYgKCBlbmQgIT09IHVuZGVmaW5lZCAmJiBzdGFydCA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRcdHN0YXJ0ID0gJzAnO1xyXG5cdFx0XHRcdFx0Y29uZGl0aW9uID0gJzwnO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGlmICggY29uZGl0aW9uID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdFx0aWYgKCBOdW1iZXIoIHN0YXJ0ICkgPiBOdW1iZXIoIGVuZCApICkge1xyXG5cclxuXHRcdFx0XHRcdFx0Y29uZGl0aW9uID0gJz49JztcclxuXHJcblx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdFx0Y29uZGl0aW9uID0gJzwnO1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Y29uc3QgaW50ZXJuYWxQYXJhbSA9IHsgc3RhcnQsIGVuZCwgY29uZGl0aW9uIH07XHJcblxyXG5cdFx0XHQvL1xyXG5cclxuXHRcdFx0Y29uc3Qgc3RhcnRTbmlwcGV0ID0gaW50ZXJuYWxQYXJhbS5zdGFydDtcclxuXHRcdFx0Y29uc3QgZW5kU25pcHBldCA9IGludGVybmFsUGFyYW0uZW5kO1xyXG5cclxuXHRcdFx0bGV0IGRlY2xhcmF0aW9uU25pcHBldCA9ICcnO1xyXG5cdFx0XHRsZXQgY29uZGl0aW9uYWxTbmlwcGV0ID0gJyc7XHJcblx0XHRcdGxldCB1cGRhdGVTbmlwcGV0ID0gJyc7XHJcblxyXG5cdFx0XHRpZiAoICEgdXBkYXRlICkge1xyXG5cclxuXHRcdFx0XHRpZiAoIHR5cGUgPT09ICdpbnQnIHx8IHR5cGUgPT09ICd1aW50JyApIHtcclxuXHJcblx0XHRcdFx0XHRpZiAoIGNvbmRpdGlvbi5pbmNsdWRlcyggJzwnICkgKSB1cGRhdGUgPSAnKysnO1xyXG5cdFx0XHRcdFx0ZWxzZSB1cGRhdGUgPSAnLS0nO1xyXG5cclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdGlmICggY29uZGl0aW9uLmluY2x1ZGVzKCAnPCcgKSApIHVwZGF0ZSA9ICcrPSAxLic7XHJcblx0XHRcdFx0XHRlbHNlIHVwZGF0ZSA9ICctPSAxLic7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGRlY2xhcmF0aW9uU25pcHBldCArPSBidWlsZGVyLmdldFZhciggdHlwZSwgbmFtZSApICsgJyA9ICcgKyBzdGFydFNuaXBwZXQ7XHJcblxyXG5cdFx0XHRjb25kaXRpb25hbFNuaXBwZXQgKz0gbmFtZSArICcgJyArIGNvbmRpdGlvbiArICcgJyArIGVuZFNuaXBwZXQ7XHJcblx0XHRcdHVwZGF0ZVNuaXBwZXQgKz0gbmFtZSArICcgJyArIHVwZGF0ZTtcclxuXHJcblx0XHRcdGNvbnN0IGZvclNuaXBwZXQgPSBgZm9yICggJHsgZGVjbGFyYXRpb25TbmlwcGV0IH07ICR7IGNvbmRpdGlvbmFsU25pcHBldCB9OyAkeyB1cGRhdGVTbmlwcGV0IH0gKWA7XHJcblxyXG5cdFx0XHRidWlsZGVyLmFkZEZsb3dDb2RlKCAoIGkgPT09IDAgPyAnXFxuJyA6ICcnICkgKyBidWlsZGVyLnRhYiArIGZvclNuaXBwZXQgKyAnIHtcXG5cXG4nICkuYWRkRmxvd1RhYigpO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRjb25zdCBzdGFja1NuaXBwZXQgPSBzdGFja05vZGUuYnVpbGQoIGJ1aWxkZXIsICd2b2lkJyApO1xyXG5cclxuXHRcdGNvbnN0IHJldHVybnNTbmlwcGV0ID0gcHJvcGVydGllcy5yZXR1cm5zTm9kZSA/IHByb3BlcnRpZXMucmV0dXJuc05vZGUuYnVpbGQoIGJ1aWxkZXIgKSA6ICcnO1xyXG5cclxuXHRcdGJ1aWxkZXIucmVtb3ZlRmxvd1RhYigpLmFkZEZsb3dDb2RlKCAnXFxuJyArIGJ1aWxkZXIudGFiICsgc3RhY2tTbmlwcGV0ICk7XHJcblxyXG5cdFx0Zm9yICggbGV0IGkgPSAwLCBsID0gdGhpcy5wYXJhbXMubGVuZ3RoIC0gMTsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRidWlsZGVyLmFkZEZsb3dDb2RlKCAoIGkgPT09IDAgPyAnJyA6IGJ1aWxkZXIudGFiICkgKyAnfVxcblxcbicgKS5yZW1vdmVGbG93VGFiKCk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGJ1aWxkZXIuYWRkRmxvd1RhYigpO1xyXG5cclxuXHRcdHJldHVybiByZXR1cm5zU25pcHBldDtcclxuXHJcblx0fVxyXG5cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgTG9vcE5vZGU7XHJcblxyXG4vKipcclxuICogVFNMIGZ1bmN0aW9uIGZvciBjcmVhdGluZyBhIGxvb3Agbm9kZS5cclxuICpcclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7Li4uQW55fSBwYXJhbXMgLSBBIGxpc3Qgb2YgcGFyYW1ldGVycy5cclxuICogQHJldHVybnMge0xvb3BOb2RlfVxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IExvb3AgPSAoIC4uLnBhcmFtcyApID0+IG5vZGVPYmplY3QoIG5ldyBMb29wTm9kZSggbm9kZUFycmF5KCBwYXJhbXMsICdpbnQnICkgKSApLmFwcGVuZCgpO1xyXG5cclxuLyoqXHJcbiAqIFRTTCBmdW5jdGlvbiBmb3IgY3JlYXRpbmcgYSBgQ29udGludWUoKWAgZXhwcmVzc2lvbi5cclxuICpcclxuICogQGZ1bmN0aW9uXHJcbiAqIEByZXR1cm5zIHtFeHByZXNzaW9uTm9kZX1cclxuICovXHJcbmV4cG9ydCBjb25zdCBDb250aW51ZSA9ICgpID0+IGV4cHJlc3Npb24oICdjb250aW51ZScgKS5hcHBlbmQoKTtcclxuXHJcbi8qKlxyXG4gKiBUU0wgZnVuY3Rpb24gZm9yIGNyZWF0aW5nIGEgYEJyZWFrKClgIGV4cHJlc3Npb24uXHJcbiAqXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcmV0dXJucyB7RXhwcmVzc2lvbk5vZGV9XHJcbiAqL1xyXG5leHBvcnQgY29uc3QgQnJlYWsgPSAoKSA9PiBleHByZXNzaW9uKCAnYnJlYWsnICkuYXBwZW5kKCk7XHJcblxyXG4vL1xyXG5cclxuZXhwb3J0IGNvbnN0IGxvb3AgPSAoIC4uLnBhcmFtcyApID0+IHsgLy8gQGRlcHJlY2F0ZWQsIHIxNjhcclxuXHJcblx0Y29uc29sZS53YXJuKCAnVFNMLkxvb3BOb2RlOiBsb29wKCkgaGFzIGJlZW4gcmVuYW1lZCB0byBMb29wKCkuJyApO1xyXG5cdHJldHVybiBMb29wKCAuLi5wYXJhbXMgKTtcclxuXHJcbn07XHJcbiIsImltcG9ydCBOb2RlIGZyb20gJy4uL2NvcmUvTm9kZS5qcyc7XHJcbmltcG9ydCB7IE5vZGVVcGRhdGVUeXBlIH0gZnJvbSAnLi4vY29yZS9jb25zdGFudHMuanMnO1xyXG5pbXBvcnQgeyBmbG9hdCwgbm9kZVByb3h5LCBGbiwgaXZlYzIsIGludCB9IGZyb20gJy4uL3RzbC9UU0xCYXNlLmpzJztcclxuaW1wb3J0IHsgdW5pZm9ybSB9IGZyb20gJy4uL2NvcmUvVW5pZm9ybU5vZGUuanMnO1xyXG5pbXBvcnQgeyByZWZlcmVuY2UgfSBmcm9tICcuL1JlZmVyZW5jZU5vZGUuanMnO1xyXG5pbXBvcnQgeyBwb3NpdGlvbkxvY2FsIH0gZnJvbSAnLi9Qb3NpdGlvbi5qcyc7XHJcbmltcG9ydCB7IG5vcm1hbExvY2FsIH0gZnJvbSAnLi9Ob3JtYWwuanMnO1xyXG5pbXBvcnQgeyB0ZXh0dXJlTG9hZCB9IGZyb20gJy4vVGV4dHVyZU5vZGUuanMnO1xyXG5pbXBvcnQgeyBpbnN0YW5jZUluZGV4LCB2ZXJ0ZXhJbmRleCB9IGZyb20gJy4uL2NvcmUvSW5kZXhOb2RlLmpzJztcclxuaW1wb3J0IHsgTG9vcCB9IGZyb20gJy4uL3V0aWxzL0xvb3BOb2RlLmpzJztcclxuXHJcbmltcG9ydCB7IERhdGFBcnJheVRleHR1cmUgfSBmcm9tICcuLi8uLi90ZXh0dXJlcy9EYXRhQXJyYXlUZXh0dXJlLmpzJztcclxuaW1wb3J0IHsgVmVjdG9yMiB9IGZyb20gJy4uLy4uL21hdGgvVmVjdG9yMi5qcyc7XHJcbmltcG9ydCB7IFZlY3RvcjQgfSBmcm9tICcuLi8uLi9tYXRoL1ZlY3RvcjQuanMnO1xyXG5pbXBvcnQgeyBGbG9hdFR5cGUgfSBmcm9tICcuLi8uLi9jb25zdGFudHMuanMnO1xyXG5cclxuY29uc3QgX21vcnBoVGV4dHVyZXMgPSAvKkBfX1BVUkVfXyovIG5ldyBXZWFrTWFwKCk7XHJcbmNvbnN0IF9tb3JwaFZlYzQgPSAvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3I0KCk7XHJcblxyXG5jb25zdCBnZXRNb3JwaCA9IC8qQF9fUFVSRV9fKi8gRm4oICggeyBidWZmZXJNYXAsIGluZmx1ZW5jZSwgc3RyaWRlLCB3aWR0aCwgZGVwdGgsIG9mZnNldCB9ICkgPT4ge1xyXG5cclxuXHRjb25zdCB0ZXhlbEluZGV4ID0gaW50KCB2ZXJ0ZXhJbmRleCApLm11bCggc3RyaWRlICkuYWRkKCBvZmZzZXQgKTtcclxuXHJcblx0Y29uc3QgeSA9IHRleGVsSW5kZXguZGl2KCB3aWR0aCApO1xyXG5cdGNvbnN0IHggPSB0ZXhlbEluZGV4LnN1YiggeS5tdWwoIHdpZHRoICkgKTtcclxuXHJcblx0Y29uc3QgYnVmZmVyQXR0cmliID0gdGV4dHVyZUxvYWQoIGJ1ZmZlck1hcCwgaXZlYzIoIHgsIHkgKSApLmRlcHRoKCBkZXB0aCApO1xyXG5cclxuXHRyZXR1cm4gYnVmZmVyQXR0cmliLm11bCggaW5mbHVlbmNlICk7XHJcblxyXG59ICk7XHJcblxyXG5mdW5jdGlvbiBnZXRFbnRyeSggZ2VvbWV0cnkgKSB7XHJcblxyXG5cdGNvbnN0IGhhc01vcnBoUG9zaXRpb24gPSBnZW9tZXRyeS5tb3JwaEF0dHJpYnV0ZXMucG9zaXRpb24gIT09IHVuZGVmaW5lZDtcclxuXHRjb25zdCBoYXNNb3JwaE5vcm1hbHMgPSBnZW9tZXRyeS5tb3JwaEF0dHJpYnV0ZXMubm9ybWFsICE9PSB1bmRlZmluZWQ7XHJcblx0Y29uc3QgaGFzTW9ycGhDb2xvcnMgPSBnZW9tZXRyeS5tb3JwaEF0dHJpYnV0ZXMuY29sb3IgIT09IHVuZGVmaW5lZDtcclxuXHJcblx0Ly8gaW5zdGVhZCBvZiB1c2luZyBhdHRyaWJ1dGVzLCB0aGUgV2ViR0wgMiBjb2RlIHBhdGggZW5jb2RlcyBtb3JwaCB0YXJnZXRzXHJcblx0Ly8gaW50byBhbiBhcnJheSBvZiBkYXRhIHRleHR1cmVzLiBFYWNoIGxheWVyIHJlcHJlc2VudHMgYSBzaW5nbGUgbW9ycGggdGFyZ2V0LlxyXG5cclxuXHRjb25zdCBtb3JwaEF0dHJpYnV0ZSA9IGdlb21ldHJ5Lm1vcnBoQXR0cmlidXRlcy5wb3NpdGlvbiB8fCBnZW9tZXRyeS5tb3JwaEF0dHJpYnV0ZXMubm9ybWFsIHx8IGdlb21ldHJ5Lm1vcnBoQXR0cmlidXRlcy5jb2xvcjtcclxuXHRjb25zdCBtb3JwaFRhcmdldHNDb3VudCA9ICggbW9ycGhBdHRyaWJ1dGUgIT09IHVuZGVmaW5lZCApID8gbW9ycGhBdHRyaWJ1dGUubGVuZ3RoIDogMDtcclxuXHJcblx0bGV0IGVudHJ5ID0gX21vcnBoVGV4dHVyZXMuZ2V0KCBnZW9tZXRyeSApO1xyXG5cclxuXHRpZiAoIGVudHJ5ID09PSB1bmRlZmluZWQgfHwgZW50cnkuY291bnQgIT09IG1vcnBoVGFyZ2V0c0NvdW50ICkge1xyXG5cclxuXHRcdGlmICggZW50cnkgIT09IHVuZGVmaW5lZCApIGVudHJ5LnRleHR1cmUuZGlzcG9zZSgpO1xyXG5cclxuXHRcdGNvbnN0IG1vcnBoVGFyZ2V0cyA9IGdlb21ldHJ5Lm1vcnBoQXR0cmlidXRlcy5wb3NpdGlvbiB8fCBbXTtcclxuXHRcdGNvbnN0IG1vcnBoTm9ybWFscyA9IGdlb21ldHJ5Lm1vcnBoQXR0cmlidXRlcy5ub3JtYWwgfHwgW107XHJcblx0XHRjb25zdCBtb3JwaENvbG9ycyA9IGdlb21ldHJ5Lm1vcnBoQXR0cmlidXRlcy5jb2xvciB8fCBbXTtcclxuXHJcblx0XHRsZXQgdmVydGV4RGF0YUNvdW50ID0gMDtcclxuXHJcblx0XHRpZiAoIGhhc01vcnBoUG9zaXRpb24gPT09IHRydWUgKSB2ZXJ0ZXhEYXRhQ291bnQgPSAxO1xyXG5cdFx0aWYgKCBoYXNNb3JwaE5vcm1hbHMgPT09IHRydWUgKSB2ZXJ0ZXhEYXRhQ291bnQgPSAyO1xyXG5cdFx0aWYgKCBoYXNNb3JwaENvbG9ycyA9PT0gdHJ1ZSApIHZlcnRleERhdGFDb3VudCA9IDM7XHJcblxyXG5cdFx0bGV0IHdpZHRoID0gZ2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbi5jb3VudCAqIHZlcnRleERhdGFDb3VudDtcclxuXHRcdGxldCBoZWlnaHQgPSAxO1xyXG5cclxuXHRcdGNvbnN0IG1heFRleHR1cmVTaXplID0gNDA5NjsgLy8gQFRPRE86IFVzZSAnY2FwYWJpbGl0aWVzLm1heFRleHR1cmVTaXplJ1xyXG5cclxuXHRcdGlmICggd2lkdGggPiBtYXhUZXh0dXJlU2l6ZSApIHtcclxuXHJcblx0XHRcdGhlaWdodCA9IE1hdGguY2VpbCggd2lkdGggLyBtYXhUZXh0dXJlU2l6ZSApO1xyXG5cdFx0XHR3aWR0aCA9IG1heFRleHR1cmVTaXplO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRjb25zdCBidWZmZXIgPSBuZXcgRmxvYXQzMkFycmF5KCB3aWR0aCAqIGhlaWdodCAqIDQgKiBtb3JwaFRhcmdldHNDb3VudCApO1xyXG5cclxuXHRcdGNvbnN0IGJ1ZmZlclRleHR1cmUgPSBuZXcgRGF0YUFycmF5VGV4dHVyZSggYnVmZmVyLCB3aWR0aCwgaGVpZ2h0LCBtb3JwaFRhcmdldHNDb3VudCApO1xyXG5cdFx0YnVmZmVyVGV4dHVyZS50eXBlID0gRmxvYXRUeXBlO1xyXG5cdFx0YnVmZmVyVGV4dHVyZS5uZWVkc1VwZGF0ZSA9IHRydWU7XHJcblxyXG5cdFx0Ly8gZmlsbCBidWZmZXJcclxuXHJcblx0XHRjb25zdCB2ZXJ0ZXhEYXRhU3RyaWRlID0gdmVydGV4RGF0YUNvdW50ICogNDtcclxuXHJcblx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCBtb3JwaFRhcmdldHNDb3VudDsgaSArKyApIHtcclxuXHJcblx0XHRcdGNvbnN0IG1vcnBoVGFyZ2V0ID0gbW9ycGhUYXJnZXRzWyBpIF07XHJcblx0XHRcdGNvbnN0IG1vcnBoTm9ybWFsID0gbW9ycGhOb3JtYWxzWyBpIF07XHJcblx0XHRcdGNvbnN0IG1vcnBoQ29sb3IgPSBtb3JwaENvbG9yc1sgaSBdO1xyXG5cclxuXHRcdFx0Y29uc3Qgb2Zmc2V0ID0gd2lkdGggKiBoZWlnaHQgKiA0ICogaTtcclxuXHJcblx0XHRcdGZvciAoIGxldCBqID0gMDsgaiA8IG1vcnBoVGFyZ2V0LmNvdW50OyBqICsrICkge1xyXG5cclxuXHRcdFx0XHRjb25zdCBzdHJpZGUgPSBqICogdmVydGV4RGF0YVN0cmlkZTtcclxuXHJcblx0XHRcdFx0aWYgKCBoYXNNb3JwaFBvc2l0aW9uID09PSB0cnVlICkge1xyXG5cclxuXHRcdFx0XHRcdF9tb3JwaFZlYzQuZnJvbUJ1ZmZlckF0dHJpYnV0ZSggbW9ycGhUYXJnZXQsIGogKTtcclxuXHJcblx0XHRcdFx0XHRidWZmZXJbIG9mZnNldCArIHN0cmlkZSArIDAgXSA9IF9tb3JwaFZlYzQueDtcclxuXHRcdFx0XHRcdGJ1ZmZlclsgb2Zmc2V0ICsgc3RyaWRlICsgMSBdID0gX21vcnBoVmVjNC55O1xyXG5cdFx0XHRcdFx0YnVmZmVyWyBvZmZzZXQgKyBzdHJpZGUgKyAyIF0gPSBfbW9ycGhWZWM0Lno7XHJcblx0XHRcdFx0XHRidWZmZXJbIG9mZnNldCArIHN0cmlkZSArIDMgXSA9IDA7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0aWYgKCBoYXNNb3JwaE5vcm1hbHMgPT09IHRydWUgKSB7XHJcblxyXG5cdFx0XHRcdFx0X21vcnBoVmVjNC5mcm9tQnVmZmVyQXR0cmlidXRlKCBtb3JwaE5vcm1hbCwgaiApO1xyXG5cclxuXHRcdFx0XHRcdGJ1ZmZlclsgb2Zmc2V0ICsgc3RyaWRlICsgNCBdID0gX21vcnBoVmVjNC54O1xyXG5cdFx0XHRcdFx0YnVmZmVyWyBvZmZzZXQgKyBzdHJpZGUgKyA1IF0gPSBfbW9ycGhWZWM0Lnk7XHJcblx0XHRcdFx0XHRidWZmZXJbIG9mZnNldCArIHN0cmlkZSArIDYgXSA9IF9tb3JwaFZlYzQuejtcclxuXHRcdFx0XHRcdGJ1ZmZlclsgb2Zmc2V0ICsgc3RyaWRlICsgNyBdID0gMDtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRpZiAoIGhhc01vcnBoQ29sb3JzID09PSB0cnVlICkge1xyXG5cclxuXHRcdFx0XHRcdF9tb3JwaFZlYzQuZnJvbUJ1ZmZlckF0dHJpYnV0ZSggbW9ycGhDb2xvciwgaiApO1xyXG5cclxuXHRcdFx0XHRcdGJ1ZmZlclsgb2Zmc2V0ICsgc3RyaWRlICsgOCBdID0gX21vcnBoVmVjNC54O1xyXG5cdFx0XHRcdFx0YnVmZmVyWyBvZmZzZXQgKyBzdHJpZGUgKyA5IF0gPSBfbW9ycGhWZWM0Lnk7XHJcblx0XHRcdFx0XHRidWZmZXJbIG9mZnNldCArIHN0cmlkZSArIDEwIF0gPSBfbW9ycGhWZWM0Lno7XHJcblx0XHRcdFx0XHRidWZmZXJbIG9mZnNldCArIHN0cmlkZSArIDExIF0gPSAoIG1vcnBoQ29sb3IuaXRlbVNpemUgPT09IDQgKSA/IF9tb3JwaFZlYzQudyA6IDE7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0ZW50cnkgPSB7XHJcblx0XHRcdGNvdW50OiBtb3JwaFRhcmdldHNDb3VudCxcclxuXHRcdFx0dGV4dHVyZTogYnVmZmVyVGV4dHVyZSxcclxuXHRcdFx0c3RyaWRlOiB2ZXJ0ZXhEYXRhQ291bnQsXHJcblx0XHRcdHNpemU6IG5ldyBWZWN0b3IyKCB3aWR0aCwgaGVpZ2h0IClcclxuXHRcdH07XHJcblxyXG5cdFx0X21vcnBoVGV4dHVyZXMuc2V0KCBnZW9tZXRyeSwgZW50cnkgKTtcclxuXHJcblx0XHRmdW5jdGlvbiBkaXNwb3NlVGV4dHVyZSgpIHtcclxuXHJcblx0XHRcdGJ1ZmZlclRleHR1cmUuZGlzcG9zZSgpO1xyXG5cclxuXHRcdFx0X21vcnBoVGV4dHVyZXMuZGVsZXRlKCBnZW9tZXRyeSApO1xyXG5cclxuXHRcdFx0Z2VvbWV0cnkucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ2Rpc3Bvc2UnLCBkaXNwb3NlVGV4dHVyZSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRnZW9tZXRyeS5hZGRFdmVudExpc3RlbmVyKCAnZGlzcG9zZScsIGRpc3Bvc2VUZXh0dXJlICk7XHJcblxyXG5cdH1cclxuXHJcblx0cmV0dXJuIGVudHJ5O1xyXG5cclxufVxyXG5cclxuXHJcbmNsYXNzIE1vcnBoTm9kZSBleHRlbmRzIE5vZGUge1xyXG5cclxuXHRzdGF0aWMgZ2V0IHR5cGUoKSB7XHJcblxyXG5cdFx0cmV0dXJuICdNb3JwaE5vZGUnO1xyXG5cclxuXHR9XHJcblxyXG5cdGNvbnN0cnVjdG9yKCBtZXNoICkge1xyXG5cclxuXHRcdHN1cGVyKCAndm9pZCcgKTtcclxuXHJcblx0XHR0aGlzLm1lc2ggPSBtZXNoO1xyXG5cdFx0dGhpcy5tb3JwaEJhc2VJbmZsdWVuY2UgPSB1bmlmb3JtKCAxICk7XHJcblxyXG5cdFx0dGhpcy51cGRhdGVUeXBlID0gTm9kZVVwZGF0ZVR5cGUuT0JKRUNUO1xyXG5cclxuXHR9XHJcblxyXG5cdHNldHVwKCBidWlsZGVyICkge1xyXG5cclxuXHRcdGNvbnN0IHsgZ2VvbWV0cnkgfSA9IGJ1aWxkZXI7XHJcblxyXG5cdFx0Y29uc3QgaGFzTW9ycGhQb3NpdGlvbiA9IGdlb21ldHJ5Lm1vcnBoQXR0cmlidXRlcy5wb3NpdGlvbiAhPT0gdW5kZWZpbmVkO1xyXG5cdFx0Y29uc3QgaGFzTW9ycGhOb3JtYWxzID0gZ2VvbWV0cnkuaGFzQXR0cmlidXRlKCAnbm9ybWFsJyApICYmIGdlb21ldHJ5Lm1vcnBoQXR0cmlidXRlcy5ub3JtYWwgIT09IHVuZGVmaW5lZDtcclxuXHJcblx0XHRjb25zdCBtb3JwaEF0dHJpYnV0ZSA9IGdlb21ldHJ5Lm1vcnBoQXR0cmlidXRlcy5wb3NpdGlvbiB8fCBnZW9tZXRyeS5tb3JwaEF0dHJpYnV0ZXMubm9ybWFsIHx8IGdlb21ldHJ5Lm1vcnBoQXR0cmlidXRlcy5jb2xvcjtcclxuXHRcdGNvbnN0IG1vcnBoVGFyZ2V0c0NvdW50ID0gKCBtb3JwaEF0dHJpYnV0ZSAhPT0gdW5kZWZpbmVkICkgPyBtb3JwaEF0dHJpYnV0ZS5sZW5ndGggOiAwO1xyXG5cclxuXHRcdC8vIG5vZGVzXHJcblxyXG5cdFx0Y29uc3QgeyB0ZXh0dXJlOiBidWZmZXJNYXAsIHN0cmlkZSwgc2l6ZSB9ID0gZ2V0RW50cnkoIGdlb21ldHJ5ICk7XHJcblxyXG5cdFx0aWYgKCBoYXNNb3JwaFBvc2l0aW9uID09PSB0cnVlICkgcG9zaXRpb25Mb2NhbC5tdWxBc3NpZ24oIHRoaXMubW9ycGhCYXNlSW5mbHVlbmNlICk7XHJcblx0XHRpZiAoIGhhc01vcnBoTm9ybWFscyA9PT0gdHJ1ZSApIG5vcm1hbExvY2FsLm11bEFzc2lnbiggdGhpcy5tb3JwaEJhc2VJbmZsdWVuY2UgKTtcclxuXHJcblx0XHRjb25zdCB3aWR0aCA9IGludCggc2l6ZS53aWR0aCApO1xyXG5cclxuXHRcdExvb3AoIG1vcnBoVGFyZ2V0c0NvdW50LCAoIHsgaSB9ICkgPT4ge1xyXG5cclxuXHRcdFx0Y29uc3QgaW5mbHVlbmNlID0gZmxvYXQoIDAgKS50b1ZhcigpO1xyXG5cclxuXHRcdFx0aWYgKCB0aGlzLm1lc2guY291bnQgPiAxICYmICggdGhpcy5tZXNoLm1vcnBoVGV4dHVyZSAhPT0gbnVsbCAmJiB0aGlzLm1lc2gubW9ycGhUZXh0dXJlICE9PSB1bmRlZmluZWQgKSApIHtcclxuXHJcblx0XHRcdFx0aW5mbHVlbmNlLmFzc2lnbiggdGV4dHVyZUxvYWQoIHRoaXMubWVzaC5tb3JwaFRleHR1cmUsIGl2ZWMyKCBpbnQoIGkgKS5hZGQoIDEgKSwgaW50KCBpbnN0YW5jZUluZGV4ICkgKSApLnIgKTtcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdGluZmx1ZW5jZS5hc3NpZ24oIHJlZmVyZW5jZSggJ21vcnBoVGFyZ2V0SW5mbHVlbmNlcycsICdmbG9hdCcgKS5lbGVtZW50KCBpICkudG9WYXIoKSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKCBoYXNNb3JwaFBvc2l0aW9uID09PSB0cnVlICkge1xyXG5cclxuXHRcdFx0XHRwb3NpdGlvbkxvY2FsLmFkZEFzc2lnbiggZ2V0TW9ycGgoIHtcclxuXHRcdFx0XHRcdGJ1ZmZlck1hcCxcclxuXHRcdFx0XHRcdGluZmx1ZW5jZSxcclxuXHRcdFx0XHRcdHN0cmlkZSxcclxuXHRcdFx0XHRcdHdpZHRoLFxyXG5cdFx0XHRcdFx0ZGVwdGg6IGksXHJcblx0XHRcdFx0XHRvZmZzZXQ6IGludCggMCApXHJcblx0XHRcdFx0fSApICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoIGhhc01vcnBoTm9ybWFscyA9PT0gdHJ1ZSApIHtcclxuXHJcblx0XHRcdFx0bm9ybWFsTG9jYWwuYWRkQXNzaWduKCBnZXRNb3JwaCgge1xyXG5cdFx0XHRcdFx0YnVmZmVyTWFwLFxyXG5cdFx0XHRcdFx0aW5mbHVlbmNlLFxyXG5cdFx0XHRcdFx0c3RyaWRlLFxyXG5cdFx0XHRcdFx0d2lkdGgsXHJcblx0XHRcdFx0XHRkZXB0aDogaSxcclxuXHRcdFx0XHRcdG9mZnNldDogaW50KCAxIClcclxuXHRcdFx0XHR9ICkgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9ICk7XHJcblxyXG5cdH1cclxuXHJcblx0dXBkYXRlKCkge1xyXG5cclxuXHRcdGNvbnN0IG1vcnBoQmFzZUluZmx1ZW5jZSA9IHRoaXMubW9ycGhCYXNlSW5mbHVlbmNlO1xyXG5cclxuXHRcdGlmICggdGhpcy5tZXNoLmdlb21ldHJ5Lm1vcnBoVGFyZ2V0c1JlbGF0aXZlICkge1xyXG5cclxuXHRcdFx0bW9ycGhCYXNlSW5mbHVlbmNlLnZhbHVlID0gMTtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0bW9ycGhCYXNlSW5mbHVlbmNlLnZhbHVlID0gMSAtIHRoaXMubWVzaC5tb3JwaFRhcmdldEluZmx1ZW5jZXMucmVkdWNlKCAoIGEsIGIgKSA9PiBhICsgYiwgMCApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgTW9ycGhOb2RlO1xyXG5cclxuZXhwb3J0IGNvbnN0IG1vcnBoUmVmZXJlbmNlID0gLypAX19QVVJFX18qLyBub2RlUHJveHkoIE1vcnBoTm9kZSApO1xyXG4iLCJpbXBvcnQgTm9kZSBmcm9tICcuLi9jb3JlL05vZGUuanMnO1xyXG5cclxuLyoqXHJcbiAqIEJhc2UgY2xhc3MgZm9yIGxpZ2h0aW5nIG5vZGVzLlxyXG4gKlxyXG4gKiBAYXVnbWVudHMgTm9kZVxyXG4gKi9cclxuY2xhc3MgTGlnaHRpbmdOb2RlIGV4dGVuZHMgTm9kZSB7XHJcblxyXG5cdHN0YXRpYyBnZXQgdHlwZSgpIHtcclxuXHJcblx0XHRyZXR1cm4gJ0xpZ2h0aW5nTm9kZSc7XHJcblxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogQ29uc3RydWN0cyBhIG5ldyBsaWdodGluZyBub2RlLlxyXG5cdCAqL1xyXG5cdGNvbnN0cnVjdG9yKCkge1xyXG5cclxuXHRcdHN1cGVyKCAndmVjMycgKTtcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIFRoaXMgZmxhZyBjYW4gYmUgdXNlZCBmb3IgdHlwZSB0ZXN0aW5nLlxyXG5cdFx0ICpcclxuXHRcdCAqIEB0eXBlIHtCb29sZWFufVxyXG5cdFx0ICogQHJlYWRvbmx5XHJcblx0XHQgKiBAZGVmYXVsdCB0cnVlXHJcblx0XHQgKi9cclxuXHRcdHRoaXMuaXNMaWdodGluZ05vZGUgPSB0cnVlO1xyXG5cclxuXHR9XHJcblxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBMaWdodGluZ05vZGU7XHJcbiIsImltcG9ydCBMaWdodGluZ05vZGUgZnJvbSAnLi9MaWdodGluZ05vZGUuanMnO1xyXG5cclxuLyoqXHJcbiAqIEEgZ2VuZXJpYyBjbGFzcyB0aGF0IGNhbiBiZSB1c2VkIGJ5IG5vZGVzIHdoaWNoIGNvbnRyaWJ1dGVcclxuICogYW1iaWVudCBvY2NsdXNpb24gdG8gdGhlIHNjZW5lLiBFLmcuIGFuIGFtYmllbnQgb2NjbHVzaW9uIG1hcFxyXG4gKiBub2RlIGNhbiBiZSB1c2VkIGFzIGlucHV0IGZvciB0aGlzIG1vZHVsZS4gVXNlZCBpbiB7QGxpbmsgTm9kZU1hdGVyaWFsfS5cclxuICpcclxuICogQGF1Z21lbnRzIExpZ2h0aW5nTm9kZVxyXG4gKi9cclxuY2xhc3MgQU9Ob2RlIGV4dGVuZHMgTGlnaHRpbmdOb2RlIHtcclxuXHJcblx0c3RhdGljIGdldCB0eXBlKCkge1xyXG5cclxuXHRcdHJldHVybiAnQU9Ob2RlJztcclxuXHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBDb25zdHJ1Y3RzIGEgbmV3IEFPIG5vZGUuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge05vZGU8ZmxvYXQ+P30gW2FvTm9kZT1udWxsXSAtIFRoZSBhbWJpZW50IG9jY2x1c2lvbiBub2RlLlxyXG5cdCAqL1xyXG5cdGNvbnN0cnVjdG9yKCBhb05vZGUgPSBudWxsICkge1xyXG5cclxuXHRcdHN1cGVyKCk7XHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBUaGUgYW1iaWVudCBvY2NsdXNpb24gbm9kZS5cclxuXHRcdCAqXHJcblx0XHQgKiBAdHlwZSB7Tm9kZTxmbG9hdD4/fVxyXG5cdFx0ICogQGRlZmF1bHQgbnVsbFxyXG5cdFx0ICovXHJcblx0XHR0aGlzLmFvTm9kZSA9IGFvTm9kZTtcclxuXHJcblx0fVxyXG5cclxuXHRzZXR1cCggYnVpbGRlciApIHtcclxuXHJcblx0XHRidWlsZGVyLmNvbnRleHQuYW1iaWVudE9jY2x1c2lvbi5tdWxBc3NpZ24oIHRoaXMuYW9Ob2RlICk7XHJcblxyXG5cdH1cclxuXHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IEFPTm9kZTtcclxuIiwiaW1wb3J0IENvbnRleHROb2RlIGZyb20gJy4uL2NvcmUvQ29udGV4dE5vZGUuanMnO1xyXG5pbXBvcnQgeyBub2RlUHJveHksIGZsb2F0LCB2ZWMzIH0gZnJvbSAnLi4vdHNsL1RTTEJhc2UuanMnO1xyXG5cclxuLyoqXHJcbiAqIGBMaWdodGluZ0NvbnRleHROb2RlYCByZXByZXNlbnRzIGFuIGV4dGVuc2lvbiBvZiB0aGUge0BsaW5rIG1vZHVsZTpDb250ZXh0Tm9kZX5Db250ZXh0Tm9kZX0gbW9kdWxlXHJcbiAqIGJ5IGFkZGluZyBsaWdodGluZyBzcGVjaWZpYyBjb250ZXh0IGRhdGEuIEl0IHJlcHJlc2VudHMgdGhlIHJ1bnRpbWUgY29udGV4dCBvZlxyXG4gKiB7QGxpbmsgTGlnaHRzTm9kZX0uXHJcbiAqXHJcbiAqIEBhdWdtZW50cyBDb250ZXh0Tm9kZVxyXG4gKi9cclxuY2xhc3MgTGlnaHRpbmdDb250ZXh0Tm9kZSBleHRlbmRzIENvbnRleHROb2RlIHtcclxuXHJcblx0c3RhdGljIGdldCB0eXBlKCkge1xyXG5cclxuXHRcdHJldHVybiAnTGlnaHRpbmdDb250ZXh0Tm9kZSc7XHJcblxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogQ29uc3RydWN0cyBhIG5ldyBsaWdodGluZyBjb250ZXh0IG5vZGUuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge0xpZ2h0c05vZGV9IG5vZGUgLSBUaGUgbGlnaHRzIG5vZGUuXHJcblx0ICogQHBhcmFtIHtMaWdodGluZ01vZGVsP30gW2xpZ2h0aW5nTW9kZWw9bnVsbF0gLSBUaGUgY3VycmVudCBsaWdodGluZyBtb2RlbC5cclxuXHQgKiBAcGFyYW0ge05vZGU8dmVjMz4/fSBbYmFja2Ryb3BOb2RlPW51bGxdIC0gQSBiYWNrZHJvcCBub2RlLlxyXG5cdCAqIEBwYXJhbSB7Tm9kZTxmbG9hdD4/fSBbYmFja2Ryb3BBbHBoYU5vZGU9bnVsbF0gLSBBIGJhY2tkcm9wIGFscGhhIG5vZGUuXHJcblx0ICovXHJcblx0Y29uc3RydWN0b3IoIG5vZGUsIGxpZ2h0aW5nTW9kZWwgPSBudWxsLCBiYWNrZHJvcE5vZGUgPSBudWxsLCBiYWNrZHJvcEFscGhhTm9kZSA9IG51bGwgKSB7XHJcblxyXG5cdFx0c3VwZXIoIG5vZGUgKTtcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIFRoZSBjdXJyZW50IGxpZ2h0aW5nIG1vZGVsLlxyXG5cdFx0ICpcclxuXHRcdCAqIEB0eXBlIHtMaWdodGluZ01vZGVsP31cclxuXHRcdCAqIEBkZWZhdWx0IG51bGxcclxuXHRcdCAqL1xyXG5cdFx0dGhpcy5saWdodGluZ01vZGVsID0gbGlnaHRpbmdNb2RlbDtcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIEEgYmFja2Ryb3Agbm9kZS5cclxuXHRcdCAqXHJcblx0XHQgKiBAdHlwZSB7Tm9kZTx2ZWMzPj99XHJcblx0XHQgKiBAZGVmYXVsdCBudWxsXHJcblx0XHQgKi9cclxuXHRcdHRoaXMuYmFja2Ryb3BOb2RlID0gYmFja2Ryb3BOb2RlO1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogQSBiYWNrZHJvcCBhbHBoYSBub2RlLlxyXG5cdFx0ICpcclxuXHRcdCAqIEB0eXBlIHtOb2RlPGZsb2F0Pj99XHJcblx0XHQgKiBAZGVmYXVsdCBudWxsXHJcblx0XHQgKi9cclxuXHRcdHRoaXMuYmFja2Ryb3BBbHBoYU5vZGUgPSBiYWNrZHJvcEFscGhhTm9kZTtcclxuXHJcblx0XHR0aGlzLl92YWx1ZSA9IG51bGw7XHJcblxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogUmV0dXJucyBhIGxpZ2h0aW5nIGNvbnRleHQgb2JqZWN0LlxyXG5cdCAqXHJcblx0ICogQHJldHVybiB7e1xyXG5cdCAqIHJhZGlhbmNlOiBOb2RlPHZlYzM+LFxyXG5cdCAqIGlycmFkaWFuY2U6IE5vZGU8dmVjMz4sXHJcblx0ICogaWJsSXJyYWRpYW5jZTogTm9kZTx2ZWMzPixcclxuXHQgKiBhbWJpZW50T2NjbHVzaW9uOiBOb2RlPGZsb2F0PixcclxuXHQgKiByZWZsZWN0ZWRMaWdodDoge2RpcmVjdERpZmZ1c2U6IE5vZGU8dmVjMz4sIGRpcmVjdFNwZWN1bGFyOiBOb2RlPHZlYzM+LCBpbmRpcmVjdERpZmZ1c2U6IE5vZGU8dmVjMz4sIGluZGlyZWN0U3BlY3VsYXI6IE5vZGU8dmVjMz59LFxyXG5cdCAqIGJhY2tkcm9wOiBOb2RlPHZlYzM+LFxyXG5cdCAqIGJhY2tkcm9wQWxwaGE6IE5vZGU8ZmxvYXQ+XHJcblx0ICogfX0gVGhlIGxpZ2h0aW5nIGNvbnRleHQgb2JqZWN0LlxyXG5cdCAqL1xyXG5cdGdldENvbnRleHQoKSB7XHJcblxyXG5cdFx0Y29uc3QgeyBiYWNrZHJvcE5vZGUsIGJhY2tkcm9wQWxwaGFOb2RlIH0gPSB0aGlzO1xyXG5cclxuXHRcdGNvbnN0IGRpcmVjdERpZmZ1c2UgPSB2ZWMzKCkudG9WYXIoICdkaXJlY3REaWZmdXNlJyApLFxyXG5cdFx0XHRkaXJlY3RTcGVjdWxhciA9IHZlYzMoKS50b1ZhciggJ2RpcmVjdFNwZWN1bGFyJyApLFxyXG5cdFx0XHRpbmRpcmVjdERpZmZ1c2UgPSB2ZWMzKCkudG9WYXIoICdpbmRpcmVjdERpZmZ1c2UnICksXHJcblx0XHRcdGluZGlyZWN0U3BlY3VsYXIgPSB2ZWMzKCkudG9WYXIoICdpbmRpcmVjdFNwZWN1bGFyJyApO1xyXG5cclxuXHRcdGNvbnN0IHJlZmxlY3RlZExpZ2h0ID0ge1xyXG5cdFx0XHRkaXJlY3REaWZmdXNlLFxyXG5cdFx0XHRkaXJlY3RTcGVjdWxhcixcclxuXHRcdFx0aW5kaXJlY3REaWZmdXNlLFxyXG5cdFx0XHRpbmRpcmVjdFNwZWN1bGFyXHJcblx0XHR9O1xyXG5cclxuXHRcdGNvbnN0IGNvbnRleHQgPSB7XHJcblx0XHRcdHJhZGlhbmNlOiB2ZWMzKCkudG9WYXIoICdyYWRpYW5jZScgKSxcclxuXHRcdFx0aXJyYWRpYW5jZTogdmVjMygpLnRvVmFyKCAnaXJyYWRpYW5jZScgKSxcclxuXHRcdFx0aWJsSXJyYWRpYW5jZTogdmVjMygpLnRvVmFyKCAnaWJsSXJyYWRpYW5jZScgKSxcclxuXHRcdFx0YW1iaWVudE9jY2x1c2lvbjogZmxvYXQoIDEgKS50b1ZhciggJ2FtYmllbnRPY2NsdXNpb24nICksXHJcblx0XHRcdHJlZmxlY3RlZExpZ2h0LFxyXG5cdFx0XHRiYWNrZHJvcDogYmFja2Ryb3BOb2RlLFxyXG5cdFx0XHRiYWNrZHJvcEFscGhhOiBiYWNrZHJvcEFscGhhTm9kZVxyXG5cdFx0fTtcclxuXHJcblx0XHRyZXR1cm4gY29udGV4dDtcclxuXHJcblx0fVxyXG5cclxuXHRzZXR1cCggYnVpbGRlciApIHtcclxuXHJcblx0XHR0aGlzLnZhbHVlID0gdGhpcy5fdmFsdWUgfHwgKCB0aGlzLl92YWx1ZSA9IHRoaXMuZ2V0Q29udGV4dCgpICk7XHJcblx0XHR0aGlzLnZhbHVlLmxpZ2h0aW5nTW9kZWwgPSB0aGlzLmxpZ2h0aW5nTW9kZWwgfHwgYnVpbGRlci5jb250ZXh0LmxpZ2h0aW5nTW9kZWw7XHJcblxyXG5cdFx0cmV0dXJuIHN1cGVyLnNldHVwKCBidWlsZGVyICk7XHJcblxyXG5cdH1cclxuXHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IExpZ2h0aW5nQ29udGV4dE5vZGU7XHJcblxyXG5leHBvcnQgY29uc3QgbGlnaHRpbmdDb250ZXh0ID0gLypAX19QVVJFX18qLyBub2RlUHJveHkoIExpZ2h0aW5nQ29udGV4dE5vZGUgKTtcclxuIiwiaW1wb3J0IExpZ2h0aW5nTm9kZSBmcm9tICcuL0xpZ2h0aW5nTm9kZS5qcyc7XHJcblxyXG4vKipcclxuICogQSBnZW5lcmljIGNsYXNzIHRoYXQgY2FuIGJlIHVzZWQgYnkgbm9kZXMgd2hpY2ggY29udHJpYnV0ZVxyXG4gKiBpcnJhZGlhbmNlIHRvIHRoZSBzY2VuZS4gRS5nLiBhIGxpZ2h0IG1hcCBub2RlIGNhbiBiZSB1c2VkXHJcbiAqIGFzIGlucHV0IGZvciB0aGlzIG1vZHVsZS4gVXNlZCBpbiB7QGxpbmsgTm9kZU1hdGVyaWFsfS5cclxuICpcclxuICogQGF1Z21lbnRzIExpZ2h0aW5nTm9kZVxyXG4gKi9cclxuY2xhc3MgSXJyYWRpYW5jZU5vZGUgZXh0ZW5kcyBMaWdodGluZ05vZGUge1xyXG5cclxuXHRzdGF0aWMgZ2V0IHR5cGUoKSB7XHJcblxyXG5cdFx0cmV0dXJuICdJcnJhZGlhbmNlTm9kZSc7XHJcblxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogQ29uc3RydWN0cyBhIG5ldyBpcnJhZGlhbmNlIG5vZGUuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge05vZGU8dmVjMz59IG5vZGUgLSBBIG5vZGUgY29udHJpYnV0aW5nIGlycmFkaWFuY2UuXHJcblx0ICovXHJcblx0Y29uc3RydWN0b3IoIG5vZGUgKSB7XHJcblxyXG5cdFx0c3VwZXIoKTtcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIEEgbm9kZSBjb250cmlidXRpbmcgaXJyYWRpYW5jZS5cclxuXHRcdCAqXHJcblx0XHQgKiBAdHlwZSB7Tm9kZTx2ZWMzPn1cclxuXHRcdCAqL1xyXG5cdFx0dGhpcy5ub2RlID0gbm9kZTtcclxuXHJcblx0fVxyXG5cclxuXHRzZXR1cCggYnVpbGRlciApIHtcclxuXHJcblx0XHRidWlsZGVyLmNvbnRleHQuaXJyYWRpYW5jZS5hZGRBc3NpZ24oIHRoaXMubm9kZSApO1xyXG5cclxuXHR9XHJcblxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBJcnJhZGlhbmNlTm9kZTtcclxuIiwiaW1wb3J0IE5vZGUgZnJvbSAnLi4vY29yZS9Ob2RlLmpzJztcclxuaW1wb3J0IHsgTm9kZVVwZGF0ZVR5cGUgfSBmcm9tICcuLi9jb3JlL2NvbnN0YW50cy5qcyc7XHJcbmltcG9ydCB7IHVuaWZvcm0gfSBmcm9tICcuLi9jb3JlL1VuaWZvcm1Ob2RlLmpzJztcclxuaW1wb3J0IHsgRm4sIG5vZGVJbW11dGFibGUsIHZlYzIgfSBmcm9tICcuLi90c2wvVFNMQmFzZS5qcyc7XHJcblxyXG5pbXBvcnQgeyBWZWN0b3IyIH0gZnJvbSAnLi4vLi4vbWF0aC9WZWN0b3IyLmpzJztcclxuaW1wb3J0IHsgVmVjdG9yNCB9IGZyb20gJy4uLy4uL21hdGgvVmVjdG9yNC5qcyc7XHJcblxyXG4vKiogQG1vZHVsZSBTY3JlZW5Ob2RlICoqL1xyXG5cclxubGV0IHNjcmVlblNpemVWZWMsIHZpZXdwb3J0VmVjO1xyXG5cclxuLyoqXHJcbiAqIFRoaXMgbm9kZSBwcm92aWRlcyBhIGNvbGxlY3Rpb24gb2Ygc2NyZWVuIHJlbGF0ZWQgbWV0cmljcy5cclxuICogRGVwZW5kaW5nIG9uIHtAbGluayBtb2R1bGU6U2NyZWVuTm9kZX5TY3JlZW5Ob2RlI3Njb3BlfSwgdGhlIG5vZGVzIGNhbiByZXByZXNlbnRcclxuICogcmVzb2x1dGlvbiBvciB2aWV3cG9ydCBkYXRhIGFzIHdlbGwgYXMgZnJhZ21lbnQgb3IgdXYgY29vcmRpbmF0ZXMuXHJcbiAqXHJcbiAqIEBhdWdtZW50cyBOb2RlXHJcbiAqL1xyXG5jbGFzcyBTY3JlZW5Ob2RlIGV4dGVuZHMgTm9kZSB7XHJcblxyXG5cdHN0YXRpYyBnZXQgdHlwZSgpIHtcclxuXHJcblx0XHRyZXR1cm4gJ1NjcmVlbk5vZGUnO1xyXG5cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIENvbnN0cnVjdHMgYSBuZXcgc2NyZWVuIG5vZGUuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0geygnY29vcmRpbmF0ZSd8J3ZpZXdwb3J0J3wnc2l6ZSd8J3V2Jyl9IHNjb3BlIC0gVGhlIG5vZGUncyBzY29wZS5cclxuXHQgKi9cclxuXHRjb25zdHJ1Y3Rvciggc2NvcGUgKSB7XHJcblxyXG5cdFx0c3VwZXIoKTtcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIFRoZSBub2RlIHJlcHJlc2VudHMgZGlmZmVyZW50IG1ldHJpYyBkZXBlbmRpbmcgb24gd2hpY2ggc2NvcGUgaXMgc2VsZWN0ZWQuXHJcblx0XHQgKlxyXG5cdFx0ICogLSBgU2NyZWVuTm9kZS5DT09SRElOQVRFYDogV2luZG93LXJlbGF0aXZlIGNvb3JkaW5hdGVzIG9mIHRoZSBjdXJyZW50IGZyYWdtZW50IGFjY29yZGluZyB0byBXZWJHUFUgc3RhbmRhcmRzLlxyXG5cdFx0ICogLSBgU2NyZWVuTm9kZS5WSUVXUE9SVGA6IFRoZSBjdXJyZW50IHZpZXdwb3J0IGRlZmluZWQgYXMgYSBmb3VyLWRpbWVuc2lvbmFsIHZlY3Rvci5cclxuXHRcdCAqIC0gYFNjcmVlbk5vZGUuU0laRWA6IFRoZSBkaW1lbnNpb25zIG9mIHRoZSBjdXJyZW50IGJvdW5kIGZyYW1lYnVmZmVyLlxyXG5cdFx0ICogLSBgU2NyZWVuTm9kZS5VVmA6IE5vcm1hbGl6ZWQgY29vcmRpbmF0ZXMuXHJcblx0XHQgKlxyXG5cdFx0ICogQHR5cGUgeygnY29vcmRpbmF0ZSd8J3ZpZXdwb3J0J3wnc2l6ZSd8J3V2Jyl9XHJcblx0XHQgKi9cclxuXHRcdHRoaXMuc2NvcGUgPSBzY29wZTtcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIFRoaXMgZmxhZyBjYW4gYmUgdXNlZCBmb3IgdHlwZSB0ZXN0aW5nLlxyXG5cdFx0ICpcclxuXHRcdCAqIEB0eXBlIHtCb29sZWFufVxyXG5cdFx0ICogQHJlYWRvbmx5XHJcblx0XHQgKiBAZGVmYXVsdCB0cnVlXHJcblx0XHQgKi9cclxuXHRcdHRoaXMuaXNWaWV3cG9ydE5vZGUgPSB0cnVlO1xyXG5cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFRoaXMgbWV0aG9kIGlzIG92ZXJ3cml0dGVuIHNpbmNlIHRoZSBub2RlIHR5cGUgZGVwZW5kcyBvbiB0aGUgc2VsZWN0ZWQgc2NvcGUuXHJcblx0ICpcclxuXHQgKiBAcmV0dXJuIHsoJ3ZlYzInfCd2ZWM0Jyl9IFRoZSBub2RlIHR5cGUuXHJcblx0ICovXHJcblx0Z2V0Tm9kZVR5cGUoKSB7XHJcblxyXG5cdFx0aWYgKCB0aGlzLnNjb3BlID09PSBTY3JlZW5Ob2RlLlZJRVdQT1JUICkgcmV0dXJuICd2ZWM0JztcclxuXHRcdGVsc2UgcmV0dXJuICd2ZWMyJztcclxuXHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBUaGlzIG1ldGhvZCBpcyBvdmVyd3JpdHRlbiBzaW5jZSB0aGUgbm9kZSdzIHVwZGF0ZSB0eXBlIGRlcGVuZHMgb24gdGhlIHNlbGVjdGVkIHNjb3BlLlxyXG5cdCAqXHJcblx0ICogQHJldHVybiB7Tm9kZVVwZGF0ZVR5cGV9IFRoZSB1cGRhdGUgdHlwZS5cclxuXHQgKi9cclxuXHRnZXRVcGRhdGVUeXBlKCkge1xyXG5cclxuXHRcdGxldCB1cGRhdGVUeXBlID0gTm9kZVVwZGF0ZVR5cGUuTk9ORTtcclxuXHJcblx0XHRpZiAoIHRoaXMuc2NvcGUgPT09IFNjcmVlbk5vZGUuU0laRSB8fCB0aGlzLnNjb3BlID09PSBTY3JlZW5Ob2RlLlZJRVdQT1JUICkge1xyXG5cclxuXHRcdFx0dXBkYXRlVHlwZSA9IE5vZGVVcGRhdGVUeXBlLlJFTkRFUjtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy51cGRhdGVUeXBlID0gdXBkYXRlVHlwZTtcclxuXHJcblx0XHRyZXR1cm4gdXBkYXRlVHlwZTtcclxuXHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBgU2NyZWVuTm9kZWAgaW1wbGVtZW50cyB7QGxpbmsgTm9kZSN1cGRhdGV9IHRvIHJldHJpZXZlIHZpZXdwb3J0IGFuZCBzaXplIGluZm9ybWF0aW9uXHJcblx0ICogZnJvbSB0aGUgY3VycmVudCByZW5kZXJlci5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7Tm9kZUZyYW1lfSBmcmFtZSAtIEEgcmVmZXJlbmNlIHRvIHRoZSBjdXJyZW50IG5vZGUgZnJhbWUuXHJcblx0ICovXHJcblx0dXBkYXRlKCB7IHJlbmRlcmVyIH0gKSB7XHJcblxyXG5cdFx0Y29uc3QgcmVuZGVyVGFyZ2V0ID0gcmVuZGVyZXIuZ2V0UmVuZGVyVGFyZ2V0KCk7XHJcblxyXG5cdFx0aWYgKCB0aGlzLnNjb3BlID09PSBTY3JlZW5Ob2RlLlZJRVdQT1JUICkge1xyXG5cclxuXHRcdFx0aWYgKCByZW5kZXJUYXJnZXQgIT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHRcdHZpZXdwb3J0VmVjLmNvcHkoIHJlbmRlclRhcmdldC52aWV3cG9ydCApO1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0cmVuZGVyZXIuZ2V0Vmlld3BvcnQoIHZpZXdwb3J0VmVjICk7XHJcblxyXG5cdFx0XHRcdHZpZXdwb3J0VmVjLm11bHRpcGx5U2NhbGFyKCByZW5kZXJlci5nZXRQaXhlbFJhdGlvKCkgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0aWYgKCByZW5kZXJUYXJnZXQgIT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHRcdHNjcmVlblNpemVWZWMud2lkdGggPSByZW5kZXJUYXJnZXQud2lkdGg7XHJcblx0XHRcdFx0c2NyZWVuU2l6ZVZlYy5oZWlnaHQgPSByZW5kZXJUYXJnZXQuaGVpZ2h0O1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0cmVuZGVyZXIuZ2V0RHJhd2luZ0J1ZmZlclNpemUoIHNjcmVlblNpemVWZWMgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0c2V0dXAoIC8qYnVpbGRlciovICkge1xyXG5cclxuXHRcdGNvbnN0IHNjb3BlID0gdGhpcy5zY29wZTtcclxuXHJcblx0XHRsZXQgb3V0cHV0ID0gbnVsbDtcclxuXHJcblx0XHRpZiAoIHNjb3BlID09PSBTY3JlZW5Ob2RlLlNJWkUgKSB7XHJcblxyXG5cdFx0XHRvdXRwdXQgPSB1bmlmb3JtKCBzY3JlZW5TaXplVmVjIHx8ICggc2NyZWVuU2l6ZVZlYyA9IG5ldyBWZWN0b3IyKCkgKSApO1xyXG5cclxuXHRcdH0gZWxzZSBpZiAoIHNjb3BlID09PSBTY3JlZW5Ob2RlLlZJRVdQT1JUICkge1xyXG5cclxuXHRcdFx0b3V0cHV0ID0gdW5pZm9ybSggdmlld3BvcnRWZWMgfHwgKCB2aWV3cG9ydFZlYyA9IG5ldyBWZWN0b3I0KCkgKSApO1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRvdXRwdXQgPSB2ZWMyKCBzY3JlZW5Db29yZGluYXRlLmRpdiggc2NyZWVuU2l6ZSApICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBvdXRwdXQ7XHJcblxyXG5cdH1cclxuXHJcblx0Z2VuZXJhdGUoIGJ1aWxkZXIgKSB7XHJcblxyXG5cdFx0aWYgKCB0aGlzLnNjb3BlID09PSBTY3JlZW5Ob2RlLkNPT1JESU5BVEUgKSB7XHJcblxyXG5cdFx0XHRsZXQgY29vcmQgPSBidWlsZGVyLmdldEZyYWdDb29yZCgpO1xyXG5cclxuXHRcdFx0aWYgKCBidWlsZGVyLmlzRmxpcFkoKSApIHtcclxuXHJcblx0XHRcdFx0Ly8gZm9sbG93IHdlYmdwdSBzdGFuZGFyZHNcclxuXHJcblx0XHRcdFx0Y29uc3Qgc2l6ZSA9IGJ1aWxkZXIuZ2V0Tm9kZVByb3BlcnRpZXMoIHNjcmVlblNpemUgKS5vdXRwdXROb2RlLmJ1aWxkKCBidWlsZGVyICk7XHJcblxyXG5cdFx0XHRcdGNvb3JkID0gYCR7IGJ1aWxkZXIuZ2V0VHlwZSggJ3ZlYzInICkgfSggJHsgY29vcmQgfS54LCAkeyBzaXplIH0ueSAtICR7IGNvb3JkIH0ueSApYDtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHJldHVybiBjb29yZDtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHN1cGVyLmdlbmVyYXRlKCBidWlsZGVyICk7XHJcblxyXG5cdH1cclxuXHJcbn1cclxuXHJcblNjcmVlbk5vZGUuQ09PUkRJTkFURSA9ICdjb29yZGluYXRlJztcclxuU2NyZWVuTm9kZS5WSUVXUE9SVCA9ICd2aWV3cG9ydCc7XHJcblNjcmVlbk5vZGUuU0laRSA9ICdzaXplJztcclxuU2NyZWVuTm9kZS5VViA9ICd1dic7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBTY3JlZW5Ob2RlO1xyXG5cclxuLy8gU2NyZWVuXHJcblxyXG4vKipcclxuICogVFNMIG9iamVjdCB0aGF0IHJlcHJlc2VudHMgbm9ybWFsaXplZCBzY3JlZW4gY29vcmRpbmF0ZXMsIHVuaXRsZXNzIGluIGBbMCwgMV1gLlxyXG4gKlxyXG4gKiBAdHlwZSB7U2NyZWVuTm9kZTx2ZWMyPn1cclxuICovXHJcbmV4cG9ydCBjb25zdCBzY3JlZW5VViA9IC8qQF9fUFVSRV9fKi8gbm9kZUltbXV0YWJsZSggU2NyZWVuTm9kZSwgU2NyZWVuTm9kZS5VViApO1xyXG5cclxuLyoqXHJcbiAqIFRTTCBvYmplY3QgdGhhdCByZXByZXNlbnRzIHRoZSBzY3JlZW4gcmVzb2x1dGlvbiBpbiBwaHlzaWNhbCBwaXhlbCB1bml0cy5cclxuICpcclxuICogQHR5cGUge1NjcmVlbk5vZGU8dmVjMj59XHJcbiAqL1xyXG5leHBvcnQgY29uc3Qgc2NyZWVuU2l6ZSA9IC8qQF9fUFVSRV9fKi8gbm9kZUltbXV0YWJsZSggU2NyZWVuTm9kZSwgU2NyZWVuTm9kZS5TSVpFICk7XHJcblxyXG4vKipcclxuICogVFNMIG9iamVjdCB0aGF0IHJlcHJlc2VudHMgdGhlIGN1cnJlbnQgYHhgL2B5YCBwaXhlbCBwb3NpdGlvbiBvbiB0aGUgc2NyZWVuIGluIHBoeXNpY2FsIHBpeGVsIHVuaXRzLlxyXG4gKlxyXG4gKiBAdHlwZSB7U2NyZWVuTm9kZTx2ZWMyPn1cclxuICovXHJcbmV4cG9ydCBjb25zdCBzY3JlZW5Db29yZGluYXRlID0gLypAX19QVVJFX18qLyBub2RlSW1tdXRhYmxlKCBTY3JlZW5Ob2RlLCBTY3JlZW5Ob2RlLkNPT1JESU5BVEUgKTtcclxuXHJcbi8vIFZpZXdwb3J0XHJcblxyXG4vKipcclxuICogVFNMIG9iamVjdCB0aGF0IHJlcHJlc2VudHMgdGhlIHZpZXdwb3J0IHJlY3RhbmdsZSBhcyBgeGAsIGB5YCwgYHdpZHRoYCBhbmQgYGhlaWdodGAgaW4gcGh5c2ljYWwgcGl4ZWwgdW5pdHMuXHJcbiAqXHJcbiAqIEB0eXBlIHtTY3JlZW5Ob2RlPHZlYzQ+fVxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IHZpZXdwb3J0ID0gLypAX19QVVJFX18qLyBub2RlSW1tdXRhYmxlKCBTY3JlZW5Ob2RlLCBTY3JlZW5Ob2RlLlZJRVdQT1JUICk7XHJcblxyXG4vKipcclxuICogVFNMIG9iamVjdCB0aGF0IHJlcHJlc2VudHMgdGhlIHZpZXdwb3J0IHJlc29sdXRpb24gaW4gcGh5c2ljYWwgcGl4ZWwgdW5pdHMuXHJcbiAqXHJcbiAqIEB0eXBlIHtTY3JlZW5Ob2RlPHZlYzI+fVxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IHZpZXdwb3J0U2l6ZSA9IHZpZXdwb3J0Lnp3O1xyXG5cclxuLyoqXHJcbiAqIFRTTCBvYmplY3QgdGhhdCByZXByZXNlbnRzIHRoZSBjdXJyZW50IGB4YC9geWAgcGl4ZWwgcG9zaXRpb24gb24gdGhlIHZpZXdwb3J0IGluIHBoeXNpY2FsIHBpeGVsIHVuaXRzLlxyXG4gKlxyXG4gKiBAdHlwZSB7U2NyZWVuTm9kZTx2ZWMyPn1cclxuICovXHJcbmV4cG9ydCBjb25zdCB2aWV3cG9ydENvb3JkaW5hdGUgPSAvKkBfX1BVUkVfXyovIHNjcmVlbkNvb3JkaW5hdGUuc3ViKCB2aWV3cG9ydC54eSApO1xyXG5cclxuLyoqXHJcbiAqIFRTTCBvYmplY3QgdGhhdCByZXByZXNlbnRzIG5vcm1hbGl6ZWQgdmlld3BvcnQgY29vcmRpbmF0ZXMsIHVuaXRsZXNzIGluIGBbMCwgMV1gLlxyXG4gKlxyXG4gKiBAdHlwZSB7U2NyZWVuTm9kZTx2ZWMyPn1cclxuICovXHJcbmV4cG9ydCBjb25zdCB2aWV3cG9ydFVWID0gLypAX19QVVJFX18qLyB2aWV3cG9ydENvb3JkaW5hdGUuZGl2KCB2aWV3cG9ydFNpemUgKTtcclxuXHJcbi8vIERlcHJlY2F0ZWRcclxuXHJcbmV4cG9ydCBjb25zdCB2aWV3cG9ydFJlc29sdXRpb24gPSAvKkBfX1BVUkVfXyovICggRm4oICgpID0+IHsgLy8gQGRlcHJlY2F0ZWQsIHIxNjlcclxuXHJcblx0Y29uc29sZS53YXJuKCAnVFNMLlZpZXdwb3J0Tm9kZTogXCJ2aWV3cG9ydFJlc29sdXRpb25cIiBpcyBkZXByZWNhdGVkLiBVc2UgXCJzY3JlZW5TaXplXCIgaW5zdGVhZC4nICk7XHJcblxyXG5cdHJldHVybiBzY3JlZW5TaXplO1xyXG5cclxufSwgJ3ZlYzInICkub25jZSgpICkoKTtcclxuXHJcbmV4cG9ydCBjb25zdCB2aWV3cG9ydFRvcExlZnQgPSAvKkBfX1BVUkVfXyovICggRm4oICgpID0+IHsgLy8gQGRlcHJlY2F0ZWQsIHIxNjhcclxuXHJcblx0Y29uc29sZS53YXJuKCAnVFNMLlZpZXdwb3J0Tm9kZTogXCJ2aWV3cG9ydFRvcExlZnRcIiBpcyBkZXByZWNhdGVkLiBVc2UgXCJzY3JlZW5VVlwiIGluc3RlYWQuJyApO1xyXG5cclxuXHRyZXR1cm4gc2NyZWVuVVY7XHJcblxyXG59LCAndmVjMicgKS5vbmNlKCkgKSgpO1xyXG5cclxuZXhwb3J0IGNvbnN0IHZpZXdwb3J0Qm90dG9tTGVmdCA9IC8qQF9fUFVSRV9fKi8gKCBGbiggKCkgPT4geyAvLyBAZGVwcmVjYXRlZCwgcjE2OFxyXG5cclxuXHRjb25zb2xlLndhcm4oICdUU0wuVmlld3BvcnROb2RlOiBcInZpZXdwb3J0Qm90dG9tTGVmdFwiIGlzIGRlcHJlY2F0ZWQuIFVzZSBcInNjcmVlblVWLmZsaXBZKClcIiBpbnN0ZWFkLicgKTtcclxuXHJcblx0cmV0dXJuIHNjcmVlblVWLmZsaXBZKCk7XHJcblxyXG59LCAndmVjMicgKS5vbmNlKCkgKSgpO1xyXG4iLCJpbXBvcnQgVGV4dHVyZU5vZGUgZnJvbSAnLi4vYWNjZXNzb3JzL1RleHR1cmVOb2RlLmpzJztcclxuaW1wb3J0IHsgTm9kZVVwZGF0ZVR5cGUgfSBmcm9tICcuLi9jb3JlL2NvbnN0YW50cy5qcyc7XHJcbmltcG9ydCB7IG5vZGVQcm94eSB9IGZyb20gJy4uL3RzbC9UU0xCYXNlLmpzJztcclxuaW1wb3J0IHsgc2NyZWVuVVYgfSBmcm9tICcuL1NjcmVlbk5vZGUuanMnO1xyXG5cclxuaW1wb3J0IHsgVmVjdG9yMiB9IGZyb20gJy4uLy4uL21hdGgvVmVjdG9yMi5qcyc7XHJcbmltcG9ydCB7IEZyYW1lYnVmZmVyVGV4dHVyZSB9IGZyb20gJy4uLy4uL3RleHR1cmVzL0ZyYW1lYnVmZmVyVGV4dHVyZS5qcyc7XHJcbmltcG9ydCB7IExpbmVhck1pcG1hcExpbmVhckZpbHRlciB9IGZyb20gJy4uLy4uL2NvbnN0YW50cy5qcyc7XHJcblxyXG4vKiogQG1vZHVsZSBWaWV3cG9ydFRleHR1cmVOb2RlICoqL1xyXG5cclxuY29uc3QgX3NpemUgPSAvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IyKCk7XHJcblxyXG4vKipcclxuICogQSBzcGVjaWFsIHR5cGUgb2YgdGV4dHVyZSBub2RlIHdoaWNoIHJlcHJlc2VudHMgdGhlIGRhdGEgb2YgdGhlIGN1cnJlbnQgdmlld3BvcnRcclxuICogYXMgYSB0ZXh0dXJlLiBUaGUgbW9kdWxlIGV4dHJhY3RzIGRhdGEgZnJvbSB0aGUgY3VycmVudCBib3VuZCBmcmFtZWJ1ZmZlciB3aXRoXHJcbiAqIGEgY29weSBvcGVyYXRpb24gc28gbm8gZXh0cmEgcmVuZGVyIHBhc3MgaXMgcmVxdWlyZWQgdG8gcHJvZHVjZSB0aGUgdGV4dHVyZSBkYXRhXHJcbiAqICh3aGljaCBpcyBnb29kIGZvciBwZXJmb3JtYW5jZSkuIGBWaWV3cG9ydFRleHR1cmVOb2RlYCBjYW4gYmUgdXNlZCBhcyBhbiBpbnB1dCBmb3IgYVxyXG4gKiB2YXJpZXR5IG9mIGVmZmVjdHMgbGlrZSByZWZyYWN0aXZlIG9yIHRyYW5zbWlzc2l2ZSBtYXRlcmlhbHMuXHJcbiAqXHJcbiAqIEBhdWdtZW50cyBtb2R1bGU6VGV4dHVyZU5vZGV+VGV4dHVyZU5vZGVcclxuICovXHJcbmNsYXNzIFZpZXdwb3J0VGV4dHVyZU5vZGUgZXh0ZW5kcyBUZXh0dXJlTm9kZSB7XHJcblxyXG5cdHN0YXRpYyBnZXQgdHlwZSgpIHtcclxuXHJcblx0XHRyZXR1cm4gJ1ZpZXdwb3J0VGV4dHVyZU5vZGUnO1xyXG5cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIENvbnN0cnVjdHMgYSBuZXcgdmlld3BvcnQgdGV4dHVyZSBub2RlLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtOb2RlfSBbdXZOb2RlPXNjcmVlblVWXSAtIFRoZSB1diBub2RlLlxyXG5cdCAqIEBwYXJhbSB7Tm9kZT99IFtsZXZlbE5vZGU9bnVsbF0gLSBUaGUgbGV2ZWwgbm9kZS5cclxuXHQgKiBAcGFyYW0ge1RleHR1cmU/fSBbZnJhbWVidWZmZXJUZXh0dXJlPW51bGxdIC0gQSBmcmFtZWJ1ZmZlciB0ZXh0dXJlIGhvbGRpbmcgdGhlIHZpZXdwb3J0IGRhdGEuIElmIG5vdCBwcm92aWRlZCwgYSBmcmFtZWJ1ZmZlciB0ZXh0dXJlIGlzIGNyZWF0ZWQgYXV0b21hdGljYWxseS5cclxuXHQgKi9cclxuXHRjb25zdHJ1Y3RvciggdXZOb2RlID0gc2NyZWVuVVYsIGxldmVsTm9kZSA9IG51bGwsIGZyYW1lYnVmZmVyVGV4dHVyZSA9IG51bGwgKSB7XHJcblxyXG5cdFx0aWYgKCBmcmFtZWJ1ZmZlclRleHR1cmUgPT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHRmcmFtZWJ1ZmZlclRleHR1cmUgPSBuZXcgRnJhbWVidWZmZXJUZXh0dXJlKCk7XHJcblx0XHRcdGZyYW1lYnVmZmVyVGV4dHVyZS5taW5GaWx0ZXIgPSBMaW5lYXJNaXBtYXBMaW5lYXJGaWx0ZXI7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHN1cGVyKCBmcmFtZWJ1ZmZlclRleHR1cmUsIHV2Tm9kZSwgbGV2ZWxOb2RlICk7XHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBXaGV0aGVyIHRvIGdlbmVyYXRlIG1pcG1hcHMgb3Igbm90LlxyXG5cdFx0ICpcclxuXHRcdCAqIEB0eXBlIHtCb29sZWFufVxyXG5cdFx0ICogQGRlZmF1bHQgZmFsc2VcclxuXHRcdCAqL1xyXG5cdFx0dGhpcy5nZW5lcmF0ZU1pcG1hcHMgPSBmYWxzZTtcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIFRoaXMgZmxhZyBjYW4gYmUgdXNlZCBmb3IgdHlwZSB0ZXN0aW5nLlxyXG5cdFx0ICpcclxuXHRcdCAqIEB0eXBlIHtCb29sZWFufVxyXG5cdFx0ICogQHJlYWRvbmx5XHJcblx0XHQgKiBAZGVmYXVsdCB0cnVlXHJcblx0XHQgKi9cclxuXHRcdHRoaXMuaXNPdXRwdXRUZXh0dXJlTm9kZSA9IHRydWU7XHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBUaGUgYHVwZGF0ZUJlZm9yZVR5cGVgIGlzIHNldCB0byBgTm9kZVVwZGF0ZVR5cGUuRlJBTUVgIHNpbmNlIHRoZSBub2RlIHJlbmRlcnMgdGhlXHJcblx0XHQgKiBzY2VuZSBvbmNlIHBlciBmcmFtZSBpbiBpdHMge0BsaW5rIFZpZXdwb3J0VGV4dHVyZU5vZGUjdXBkYXRlQmVmb3JlfSBtZXRob2QuXHJcblx0XHQgKlxyXG5cdFx0ICogQHR5cGUge1N0cmluZ31cclxuXHRcdCAqIEBkZWZhdWx0ICdmcmFtZSdcclxuXHRcdCAqL1xyXG5cdFx0dGhpcy51cGRhdGVCZWZvcmVUeXBlID0gTm9kZVVwZGF0ZVR5cGUuRlJBTUU7XHJcblxyXG5cdH1cclxuXHJcblx0dXBkYXRlQmVmb3JlKCBmcmFtZSApIHtcclxuXHJcblx0XHRjb25zdCByZW5kZXJlciA9IGZyYW1lLnJlbmRlcmVyO1xyXG5cdFx0cmVuZGVyZXIuZ2V0RHJhd2luZ0J1ZmZlclNpemUoIF9zaXplICk7XHJcblxyXG5cdFx0Ly9cclxuXHJcblx0XHRjb25zdCBmcmFtZWJ1ZmZlclRleHR1cmUgPSB0aGlzLnZhbHVlO1xyXG5cclxuXHRcdGlmICggZnJhbWVidWZmZXJUZXh0dXJlLmltYWdlLndpZHRoICE9PSBfc2l6ZS53aWR0aCB8fCBmcmFtZWJ1ZmZlclRleHR1cmUuaW1hZ2UuaGVpZ2h0ICE9PSBfc2l6ZS5oZWlnaHQgKSB7XHJcblxyXG5cdFx0XHRmcmFtZWJ1ZmZlclRleHR1cmUuaW1hZ2Uud2lkdGggPSBfc2l6ZS53aWR0aDtcclxuXHRcdFx0ZnJhbWVidWZmZXJUZXh0dXJlLmltYWdlLmhlaWdodCA9IF9zaXplLmhlaWdodDtcclxuXHRcdFx0ZnJhbWVidWZmZXJUZXh0dXJlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly9cclxuXHJcblx0XHRjb25zdCBjdXJyZW50R2VuZXJhdGVNaXBtYXBzID0gZnJhbWVidWZmZXJUZXh0dXJlLmdlbmVyYXRlTWlwbWFwcztcclxuXHRcdGZyYW1lYnVmZmVyVGV4dHVyZS5nZW5lcmF0ZU1pcG1hcHMgPSB0aGlzLmdlbmVyYXRlTWlwbWFwcztcclxuXHJcblx0XHRyZW5kZXJlci5jb3B5RnJhbWVidWZmZXJUb1RleHR1cmUoIGZyYW1lYnVmZmVyVGV4dHVyZSApO1xyXG5cclxuXHRcdGZyYW1lYnVmZmVyVGV4dHVyZS5nZW5lcmF0ZU1pcG1hcHMgPSBjdXJyZW50R2VuZXJhdGVNaXBtYXBzO1xyXG5cclxuXHR9XHJcblxyXG5cdGNsb25lKCkge1xyXG5cclxuXHRcdGNvbnN0IHZpZXdwb3J0VGV4dHVyZU5vZGUgPSBuZXcgdGhpcy5jb25zdHJ1Y3RvciggdGhpcy51dk5vZGUsIHRoaXMubGV2ZWxOb2RlLCB0aGlzLnZhbHVlICk7XHJcblx0XHR2aWV3cG9ydFRleHR1cmVOb2RlLmdlbmVyYXRlTWlwbWFwcyA9IHRoaXMuZ2VuZXJhdGVNaXBtYXBzO1xyXG5cclxuXHRcdHJldHVybiB2aWV3cG9ydFRleHR1cmVOb2RlO1xyXG5cclxuXHR9XHJcblxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBWaWV3cG9ydFRleHR1cmVOb2RlO1xyXG5cclxuLyoqXHJcbiAqIFRTTCBmdW5jdGlvbiBmb3IgY3JlYXRpbmcgYSB2aWV3cG9ydCB0ZXh0dXJlIG5vZGUuXHJcbiAqXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0ge05vZGV9IFt1dk5vZGU9c2NyZWVuVVZdIC0gVGhlIHV2IG5vZGUuXHJcbiAqIEBwYXJhbSB7Tm9kZT99IFtsZXZlbE5vZGU9bnVsbF0gLSBUaGUgbGV2ZWwgbm9kZS5cclxuICogQHBhcmFtIHtUZXh0dXJlP30gW2ZyYW1lYnVmZmVyVGV4dHVyZT1udWxsXSAtIEEgZnJhbWVidWZmZXIgdGV4dHVyZSBob2xkaW5nIHRoZSB2aWV3cG9ydCBkYXRhLiBJZiBub3QgcHJvdmlkZWQsIGEgZnJhbWVidWZmZXIgdGV4dHVyZSBpcyBjcmVhdGVkIGF1dG9tYXRpY2FsbHkuXHJcbiAqIEByZXR1cm5zIHtWaWV3cG9ydFRleHR1cmVOb2RlfVxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IHZpZXdwb3J0VGV4dHVyZSA9IC8qQF9fUFVSRV9fKi8gbm9kZVByb3h5KCBWaWV3cG9ydFRleHR1cmVOb2RlICk7XHJcblxyXG4vKipcclxuICogVFNMIGZ1bmN0aW9uIGZvciBjcmVhdGluZyBhIHZpZXdwb3J0IHRleHR1cmUgbm9kZSB3aXRoIGVuYWJsZWQgbWlwbWFwIGdlbmVyYXRpb24uXHJcbiAqXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0ge05vZGV9IFt1dk5vZGU9c2NyZWVuVVZdIC0gVGhlIHV2IG5vZGUuXHJcbiAqIEBwYXJhbSB7Tm9kZT99IFtsZXZlbE5vZGU9bnVsbF0gLSBUaGUgbGV2ZWwgbm9kZS5cclxuICogQHBhcmFtIHtUZXh0dXJlP30gW2ZyYW1lYnVmZmVyVGV4dHVyZT1udWxsXSAtIEEgZnJhbWVidWZmZXIgdGV4dHVyZSBob2xkaW5nIHRoZSB2aWV3cG9ydCBkYXRhLiBJZiBub3QgcHJvdmlkZWQsIGEgZnJhbWVidWZmZXIgdGV4dHVyZSBpcyBjcmVhdGVkIGF1dG9tYXRpY2FsbHkuXHJcbiAqIEByZXR1cm5zIHtWaWV3cG9ydFRleHR1cmVOb2RlfVxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IHZpZXdwb3J0TWlwVGV4dHVyZSA9IC8qQF9fUFVSRV9fKi8gbm9kZVByb3h5KCBWaWV3cG9ydFRleHR1cmVOb2RlLCBudWxsLCBudWxsLCB7IGdlbmVyYXRlTWlwbWFwczogdHJ1ZSB9ICk7XHJcbiIsImltcG9ydCBWaWV3cG9ydFRleHR1cmVOb2RlIGZyb20gJy4vVmlld3BvcnRUZXh0dXJlTm9kZS5qcyc7XHJcbmltcG9ydCB7IG5vZGVQcm94eSB9IGZyb20gJy4uL3RzbC9UU0xCYXNlLmpzJztcclxuaW1wb3J0IHsgc2NyZWVuVVYgfSBmcm9tICcuL1NjcmVlbk5vZGUuanMnO1xyXG5cclxuaW1wb3J0IHsgRGVwdGhUZXh0dXJlIH0gZnJvbSAnLi4vLi4vdGV4dHVyZXMvRGVwdGhUZXh0dXJlLmpzJztcclxuXHJcbi8qKiBAbW9kdWxlIFZpZXdwb3J0RGVwdGhUZXh0dXJlTm9kZSAqKi9cclxuXHJcbmxldCBzaGFyZWREZXB0aGJ1ZmZlciA9IG51bGw7XHJcblxyXG4vKipcclxuICogUmVwcmVzZW50cyB0aGUgZGVwdGggb2YgdGhlIGN1cnJlbnQgdmlld3BvcnQgYXMgYSB0ZXh0dXJlLiBUaGlzIG1vZHVsZVxyXG4gKiBjYW4gYmUgdXNlZCBpbiBjb21iaW5hdGlvbiB3aXRoIHZpZXdwb3J0IHRleHR1cmUgdG8gYWNoaWV2ZSBlZmZlY3RzXHJcbiAqIHRoYXQgcmVxdWlyZSBkZXB0aCBldmFsdWF0aW9uLlxyXG4gKlxyXG4gKiBAYXVnbWVudHMgbW9kdWxlOlZpZXdwb3J0VGV4dHVyZU5vZGV+Vmlld3BvcnRUZXh0dXJlTm9kZVxyXG4gKi9cclxuY2xhc3MgVmlld3BvcnREZXB0aFRleHR1cmVOb2RlIGV4dGVuZHMgVmlld3BvcnRUZXh0dXJlTm9kZSB7XHJcblxyXG5cdHN0YXRpYyBnZXQgdHlwZSgpIHtcclxuXHJcblx0XHRyZXR1cm4gJ1ZpZXdwb3J0RGVwdGhUZXh0dXJlTm9kZSc7XHJcblxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogQ29uc3RydWN0cyBhIG5ldyB2aWV3cG9ydCBkZXB0aCB0ZXh0dXJlIG5vZGUuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge05vZGV9IFt1dk5vZGU9c2NyZWVuVVZdIC0gVGhlIHV2IG5vZGUuXHJcblx0ICogQHBhcmFtIHtOb2RlP30gW2xldmVsTm9kZT1udWxsXSAtIFRoZSBsZXZlbCBub2RlLlxyXG5cdCAqL1xyXG5cdGNvbnN0cnVjdG9yKCB1dk5vZGUgPSBzY3JlZW5VViwgbGV2ZWxOb2RlID0gbnVsbCApIHtcclxuXHJcblx0XHRpZiAoIHNoYXJlZERlcHRoYnVmZmVyID09PSBudWxsICkge1xyXG5cclxuXHRcdFx0c2hhcmVkRGVwdGhidWZmZXIgPSBuZXcgRGVwdGhUZXh0dXJlKCk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHN1cGVyKCB1dk5vZGUsIGxldmVsTm9kZSwgc2hhcmVkRGVwdGhidWZmZXIgKTtcclxuXHJcblx0fVxyXG5cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgVmlld3BvcnREZXB0aFRleHR1cmVOb2RlO1xyXG5cclxuLyoqXHJcbiAqIFRTTCBmdW5jdGlvbiBmb3IgYSB2aWV3cG9ydCBkZXB0aCB0ZXh0dXJlIG5vZGUuXHJcbiAqXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0ge05vZGV9IFt1dk5vZGU9c2NyZWVuVVZdIC0gVGhlIHV2IG5vZGUuXHJcbiAqIEBwYXJhbSB7Tm9kZT99IFtsZXZlbE5vZGU9bnVsbF0gLSBUaGUgbGV2ZWwgbm9kZS5cclxuICogQHJldHVybnMge1ZpZXdwb3J0RGVwdGhUZXh0dXJlTm9kZX1cclxuICovXHJcbmV4cG9ydCBjb25zdCB2aWV3cG9ydERlcHRoVGV4dHVyZSA9IC8qQF9fUFVSRV9fKi8gbm9kZVByb3h5KCBWaWV3cG9ydERlcHRoVGV4dHVyZU5vZGUgKTtcclxuIiwiaW1wb3J0IE5vZGUgZnJvbSAnLi4vY29yZS9Ob2RlLmpzJztcclxuaW1wb3J0IHsgZmxvYXQsIGxvZywgbG9nMiwgbm9kZUltbXV0YWJsZSwgbm9kZVByb3h5IH0gZnJvbSAnLi4vdHNsL1RTTEJhc2UuanMnO1xyXG5pbXBvcnQgeyBjYW1lcmFOZWFyLCBjYW1lcmFGYXIgfSBmcm9tICcuLi9hY2Nlc3NvcnMvQ2FtZXJhLmpzJztcclxuaW1wb3J0IHsgcG9zaXRpb25WaWV3IH0gZnJvbSAnLi4vYWNjZXNzb3JzL1Bvc2l0aW9uLmpzJztcclxuaW1wb3J0IHsgdmlld3BvcnREZXB0aFRleHR1cmUgfSBmcm9tICcuL1ZpZXdwb3J0RGVwdGhUZXh0dXJlTm9kZS5qcyc7XHJcblxyXG4vKiogQG1vZHVsZSBWaWV3cG9ydERlcHRoTm9kZSAqKi9cclxuXHJcbi8qKlxyXG4gKiBUaGlzIG5vZGUgb2ZmZXJzIGEgY29sbGVjdGlvbiBvZiBmZWF0dXJlcyBpbiBjb250ZXh0IG9mIHRoZSBkZXB0aCBsb2dpYyBpbiB0aGUgZnJhZ21lbnQgc2hhZGVyLlxyXG4gKiBEZXBlbmRpbmcgb24ge0BsaW5rIFZpZXdwb3J0RGVwdGhOb2RlI3Njb3BlfSwgaXQgY2FuIGJlIHVzZWQgdG8gZGVmaW5lIGEgZGVwdGggdmFsdWUgZm9yIHRoZSBjdXJyZW50XHJcbiAqIGZyYWdtZW50IG9yIGZvciBkZXB0aCBldmFsdWF0aW9uIHB1cnBvc2VzLlxyXG4gKlxyXG4gKiBAYXVnbWVudHMgTm9kZVxyXG4gKi9cclxuY2xhc3MgVmlld3BvcnREZXB0aE5vZGUgZXh0ZW5kcyBOb2RlIHtcclxuXHJcblx0c3RhdGljIGdldCB0eXBlKCkge1xyXG5cclxuXHRcdHJldHVybiAnVmlld3BvcnREZXB0aE5vZGUnO1xyXG5cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIENvbnN0cnVjdHMgYSBuZXcgdmlld3BvcnQgZGVwdGggbm9kZS5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7KCdkZXB0aCd8J2RlcHRoQmFzZSd8J2xpbmVhckRlcHRoJyl9IHNjb3BlIC0gVGhlIG5vZGUncyBzY29wZS5cclxuXHQgKiBAcGFyYW0ge05vZGU/fSBbdmFsdWVOb2RlPW51bGxdIC0gVGhlIHZhbHVlIG5vZGUuXHJcblx0ICovXHJcblx0Y29uc3RydWN0b3IoIHNjb3BlLCB2YWx1ZU5vZGUgPSBudWxsICkge1xyXG5cclxuXHRcdHN1cGVyKCAnZmxvYXQnICk7XHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBUaGUgbm9kZSBiZWhhdmVzIGRpZmZlcmVudGx5IGRlcGVuZGluZyBvbiB3aGljaCBzY29wZSBpcyBzZWxlY3RlZC5cclxuXHRcdCAqXHJcblx0XHQgKiAtIGBWaWV3cG9ydERlcHRoTm9kZS5ERVBUSF9CQVNFYDogQWxsb3dzIHRvIGRlZmluZSBhIHZhbHVlIGZvciB0aGUgY3VycmVudCBmcmFnbWVudCdzIGRlcHRoLlxyXG5cdFx0ICogLSBgVmlld3BvcnREZXB0aE5vZGUuREVQVEhgOiBSZXByZXNlbnRzIHRoZSBkZXB0aCB2YWx1ZSBmb3IgdGhlIGN1cnJlbnQgZnJhZ21lbnQgKGB2YWx1ZU5vZGVgIGlzIGlnbm9yZWQpLlxyXG5cdFx0ICogLSBgVmlld3BvcnREZXB0aE5vZGUuTElORUFSX0RFUFRIYDogUmVwcmVzZW50cyB0aGUgbGluZWFyIChvcnRob2dyYXBoaWMpIGRlcHRoIHZhbHVlIG9mIHRoZSBjdXJyZW50IGZyYWdtZW50LlxyXG5cdFx0ICogSWYgYSBgdmFsdWVOb2RlYCBpcyBzZXQsIHRoZSBzY29wZSBjYW4gYmUgdXNlZCB0byBjb252ZXJ0IHBlcnNwZWN0aXZlIGRlcHRoIGRhdGEgdG8gbGluZWFyIGRhdGEuXHJcblx0XHQgKlxyXG5cdFx0ICogQHR5cGUgeygnZGVwdGgnfCdkZXB0aEJhc2UnfCdsaW5lYXJEZXB0aCcpfVxyXG5cdFx0ICovXHJcblx0XHR0aGlzLnNjb3BlID0gc2NvcGU7XHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBDYW4gYmUgdXNlZCB0byBkZWZpbmUgYSBjdXN0b20gZGVwdGggdmFsdWUuXHJcblx0XHQgKiBUaGUgcHJvcGVydHkgaXMgaWdub3JlZCBpbiB0aGUgYFZpZXdwb3J0RGVwdGhOb2RlLkRFUFRIYCBzY29wZS5cclxuXHRcdCAqXHJcblx0XHQgKiBAdHlwZSB7Tm9kZT99XHJcblx0XHQgKiBAZGVmYXVsdCBudWxsXHJcblx0XHQgKi9cclxuXHRcdHRoaXMudmFsdWVOb2RlID0gdmFsdWVOb2RlO1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogVGhpcyBmbGFnIGNhbiBiZSB1c2VkIGZvciB0eXBlIHRlc3RpbmcuXHJcblx0XHQgKlxyXG5cdFx0ICogQHR5cGUge0Jvb2xlYW59XHJcblx0XHQgKiBAcmVhZG9ubHlcclxuXHRcdCAqIEBkZWZhdWx0IHRydWVcclxuXHRcdCAqL1xyXG5cdFx0dGhpcy5pc1ZpZXdwb3J0RGVwdGhOb2RlID0gdHJ1ZTtcclxuXHJcblx0fVxyXG5cclxuXHRnZW5lcmF0ZSggYnVpbGRlciApIHtcclxuXHJcblx0XHRjb25zdCB7IHNjb3BlIH0gPSB0aGlzO1xyXG5cclxuXHRcdGlmICggc2NvcGUgPT09IFZpZXdwb3J0RGVwdGhOb2RlLkRFUFRIX0JBU0UgKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gYnVpbGRlci5nZXRGcmFnRGVwdGgoKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHN1cGVyLmdlbmVyYXRlKCBidWlsZGVyICk7XHJcblxyXG5cdH1cclxuXHJcblx0c2V0dXAoIHsgY2FtZXJhIH0gKSB7XHJcblxyXG5cdFx0Y29uc3QgeyBzY29wZSB9ID0gdGhpcztcclxuXHRcdGNvbnN0IHZhbHVlID0gdGhpcy52YWx1ZU5vZGU7XHJcblxyXG5cdFx0bGV0IG5vZGUgPSBudWxsO1xyXG5cclxuXHRcdGlmICggc2NvcGUgPT09IFZpZXdwb3J0RGVwdGhOb2RlLkRFUFRIX0JBU0UgKSB7XHJcblxyXG5cdFx0XHRpZiAoIHZhbHVlICE9PSBudWxsICkge1xyXG5cclxuIFx0XHRcdFx0bm9kZSA9IGRlcHRoQmFzZSgpLmFzc2lnbiggdmFsdWUgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9IGVsc2UgaWYgKCBzY29wZSA9PT0gVmlld3BvcnREZXB0aE5vZGUuREVQVEggKSB7XHJcblxyXG5cdFx0XHRpZiAoIGNhbWVyYS5pc1BlcnNwZWN0aXZlQ2FtZXJhICkge1xyXG5cclxuXHRcdFx0XHRub2RlID0gdmlld1pUb1BlcnNwZWN0aXZlRGVwdGgoIHBvc2l0aW9uVmlldy56LCBjYW1lcmFOZWFyLCBjYW1lcmFGYXIgKTtcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdG5vZGUgPSB2aWV3WlRvT3J0aG9ncmFwaGljRGVwdGgoIHBvc2l0aW9uVmlldy56LCBjYW1lcmFOZWFyLCBjYW1lcmFGYXIgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9IGVsc2UgaWYgKCBzY29wZSA9PT0gVmlld3BvcnREZXB0aE5vZGUuTElORUFSX0RFUFRIICkge1xyXG5cclxuXHRcdFx0aWYgKCB2YWx1ZSAhPT0gbnVsbCApIHtcclxuXHJcblx0XHRcdFx0aWYgKCBjYW1lcmEuaXNQZXJzcGVjdGl2ZUNhbWVyYSApIHtcclxuXHJcblx0XHRcdFx0XHRjb25zdCB2aWV3WiA9IHBlcnNwZWN0aXZlRGVwdGhUb1ZpZXdaKCB2YWx1ZSwgY2FtZXJhTmVhciwgY2FtZXJhRmFyICk7XHJcblxyXG5cdFx0XHRcdFx0bm9kZSA9IHZpZXdaVG9PcnRob2dyYXBoaWNEZXB0aCggdmlld1osIGNhbWVyYU5lYXIsIGNhbWVyYUZhciApO1xyXG5cclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdG5vZGUgPSB2YWx1ZTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0bm9kZSA9IHZpZXdaVG9PcnRob2dyYXBoaWNEZXB0aCggcG9zaXRpb25WaWV3LnosIGNhbWVyYU5lYXIsIGNhbWVyYUZhciApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gbm9kZTtcclxuXHJcblx0fVxyXG5cclxufVxyXG5cclxuVmlld3BvcnREZXB0aE5vZGUuREVQVEhfQkFTRSA9ICdkZXB0aEJhc2UnO1xyXG5WaWV3cG9ydERlcHRoTm9kZS5ERVBUSCA9ICdkZXB0aCc7XHJcblZpZXdwb3J0RGVwdGhOb2RlLkxJTkVBUl9ERVBUSCA9ICdsaW5lYXJEZXB0aCc7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBWaWV3cG9ydERlcHRoTm9kZTtcclxuXHJcbi8vIE5PVEU6IHZpZXdaLCB0aGUgei1jb29yZGluYXRlIGluIGNhbWVyYSBzcGFjZSwgaXMgbmVnYXRpdmUgZm9yIHBvaW50cyBpbiBmcm9udCBvZiB0aGUgY2FtZXJhXHJcblxyXG4vKipcclxuICogVFNMIGZ1bmN0aW9uIGZvciBjb252ZXJ0aW5nIGEgdmlld1ogdmFsdWUgdG8gYW4gb3J0aG9ncmFwaGljIGRlcHRoIHZhbHVlLlxyXG4gKlxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHtOb2RlPGZsb2F0Pn0gdmlld1ogLSBUaGUgdmlld1ogbm9kZS5cclxuICogQHBhcmFtIHtOb2RlPGZsb2F0Pn0gbmVhciAtIFRoZSBjYW1lcmEncyBuZWFyIHZhbHVlLlxyXG4gKiBAcGFyYW0ge05vZGU8ZmxvYXQ+fSBmYXIgLSBUaGUgY2FtZXJhJ3MgZmFyIHZhbHVlLlxyXG4gKiBAcmV0dXJucyB7Tm9kZTxmbG9hdD59XHJcbiAqL1xyXG5leHBvcnQgY29uc3Qgdmlld1pUb09ydGhvZ3JhcGhpY0RlcHRoID0gKCB2aWV3WiwgbmVhciwgZmFyICkgPT4gdmlld1ouYWRkKCBuZWFyICkuZGl2KCBuZWFyLnN1YiggZmFyICkgKTtcclxuXHJcbi8qKlxyXG4gKiBUU0wgZnVuY3Rpb24gZm9yIGNvbnZlcnRpbmcgYW4gb3J0aG9ncmFwaGljIGRlcHRoIHZhbHVlIHRvIGEgdmlld1ogdmFsdWUuXHJcbiAqXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0ge05vZGU8ZmxvYXQ+fSBkZXB0aCAtIFRoZSBvcnRob2dyYXBoaWMgZGVwdGguXHJcbiAqIEBwYXJhbSB7Tm9kZTxmbG9hdD59IG5lYXIgLSBUaGUgY2FtZXJhJ3MgbmVhciB2YWx1ZS5cclxuICogQHBhcmFtIHtOb2RlPGZsb2F0Pn0gZmFyIC0gVGhlIGNhbWVyYSdzIGZhciB2YWx1ZS5cclxuICogQHJldHVybnMge05vZGU8ZmxvYXQ+fVxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IG9ydGhvZ3JhcGhpY0RlcHRoVG9WaWV3WiA9ICggZGVwdGgsIG5lYXIsIGZhciApID0+IG5lYXIuc3ViKCBmYXIgKS5tdWwoIGRlcHRoICkuc3ViKCBuZWFyICk7XHJcblxyXG4vKipcclxuICogVFNMIGZ1bmN0aW9uIGZvciBjb252ZXJ0aW5nIGEgdmlld1ogdmFsdWUgdG8gYSBwZXJzcGVjdGl2ZSBkZXB0aCB2YWx1ZS5cclxuICpcclxuICogTm90ZToge2xpbmsgaHR0cHM6Ly90d2l0dGVyLmNvbS9nb25uYXZpcy9zdGF0dXMvMTM3NzE4Mzc4Njk0OTk1OTY4Mn0uXHJcbiAqXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0ge05vZGU8ZmxvYXQ+fSB2aWV3WiAtIFRoZSB2aWV3WiBub2RlLlxyXG4gKiBAcGFyYW0ge05vZGU8ZmxvYXQ+fSBuZWFyIC0gVGhlIGNhbWVyYSdzIG5lYXIgdmFsdWUuXHJcbiAqIEBwYXJhbSB7Tm9kZTxmbG9hdD59IGZhciAtIFRoZSBjYW1lcmEncyBmYXIgdmFsdWUuXHJcbiAqIEByZXR1cm5zIHtOb2RlPGZsb2F0Pn1cclxuICovXHJcbmV4cG9ydCBjb25zdCB2aWV3WlRvUGVyc3BlY3RpdmVEZXB0aCA9ICggdmlld1osIG5lYXIsIGZhciApID0+IG5lYXIuYWRkKCB2aWV3WiApLm11bCggZmFyICkuZGl2KCBmYXIuc3ViKCBuZWFyICkubXVsKCB2aWV3WiApICk7XHJcblxyXG4vKipcclxuICogVFNMIGZ1bmN0aW9uIGZvciBjb252ZXJ0aW5nIGEgcGVyc3BlY3RpdmUgZGVwdGggdmFsdWUgdG8gYSB2aWV3WiB2YWx1ZS5cclxuICpcclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7Tm9kZTxmbG9hdD59IGRlcHRoIC0gVGhlIHBlcnNwZWN0aXZlIGRlcHRoLlxyXG4gKiBAcGFyYW0ge05vZGU8ZmxvYXQ+fSBuZWFyIC0gVGhlIGNhbWVyYSdzIG5lYXIgdmFsdWUuXHJcbiAqIEBwYXJhbSB7Tm9kZTxmbG9hdD59IGZhciAtIFRoZSBjYW1lcmEncyBmYXIgdmFsdWUuXHJcbiAqIEByZXR1cm5zIHtOb2RlPGZsb2F0Pn1cclxuICovXHJcbmV4cG9ydCBjb25zdCBwZXJzcGVjdGl2ZURlcHRoVG9WaWV3WiA9ICggZGVwdGgsIG5lYXIsIGZhciApID0+IG5lYXIubXVsKCBmYXIgKS5kaXYoIGZhci5zdWIoIG5lYXIgKS5tdWwoIGRlcHRoICkuc3ViKCBmYXIgKSApO1xyXG5cclxuLyoqXHJcbiAqIFRTTCBmdW5jdGlvbiBmb3IgY29udmVydGluZyBhIHZpZXdaIHZhbHVlIHRvIGEgbG9nYXJpdGhtaWMgZGVwdGggdmFsdWUuXHJcbiAqXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0ge05vZGU8ZmxvYXQ+fSB2aWV3WiAtIFRoZSB2aWV3WiBub2RlLlxyXG4gKiBAcGFyYW0ge05vZGU8ZmxvYXQ+fSBuZWFyIC0gVGhlIGNhbWVyYSdzIG5lYXIgdmFsdWUuXHJcbiAqIEBwYXJhbSB7Tm9kZTxmbG9hdD59IGZhciAtIFRoZSBjYW1lcmEncyBmYXIgdmFsdWUuXHJcbiAqIEByZXR1cm5zIHtOb2RlPGZsb2F0Pn1cclxuICovXHJcbmV4cG9ydCBjb25zdCB2aWV3WlRvTG9nYXJpdGhtaWNEZXB0aCA9ICggdmlld1osIG5lYXIsIGZhciApID0+IHtcclxuXHJcblx0Ly8gTk9URTogdmlld1ogbXVzdCBiZSBuZWdhdGl2ZS0tc2VlIGV4cGxhbmF0aW9uIGF0IHRoZSBlbmQgb2YgdGhpcyBjb21tZW50IGJsb2NrLlxyXG5cdC8vIFRoZSBmaW5hbCBsb2dhcml0aG1pYyBkZXB0aCBmb3JtdWxhIHVzZWQgaGVyZSBpcyBhZGFwdGVkIGZyb20gb25lIGRlc2NyaWJlZCBpbiBhblxyXG5cdC8vIGFydGljbGUgYnkgVGhhdGNoZXIgVWxyaWNoIChzZWUgaHR0cDovL3R1bHJpY2guY29tL2dlZWtzdHVmZi9sb2dfZGVwdGhfYnVmZmVyLnR4dCksXHJcblx0Ly8gd2hpY2ggd2FzIGFuIGltcHJvdmVtZW50IHVwb24gYW4gZWFybGllciBmb3JtdWxhIG9uZSBkZXNjcmliZWQgaW4gYW5cclxuXHQvLyBPdXRlcnJhIGFydGljbGUgKGh0dHBzOi8vb3V0ZXJyYS5ibG9nc3BvdC5jb20vMjAwOS8wOC9sb2dhcml0aG1pYy16LWJ1ZmZlci5odG1sKS5cclxuXHQvLyBVbHJpY2gncyBmb3JtdWxhIGlzIHRoZSBmb2xsb3dpbmc6XHJcblx0Ly8gICAgIHogPSBLICogbG9nKCB3IC8gY2FtZXJhTmVhciApIC8gbG9nKCBjYW1lcmFGYXIgLyBjYW1lcmFOZWFyIClcclxuXHQvLyAgICAgd2hlcmUgSyA9IDJeayAtIDEsIGFuZCBrIGlzIHRoZSBudW1iZXIgb2YgYml0cyBpbiB0aGUgZGVwdGggYnVmZmVyLlxyXG5cdC8vIFRoZSBPdXRlcnJhIHZhcmlhbnQgaWdub3JlZCB0aGUgY2FtZXJhIG5lYXIgcGxhbmUgKGl0IGFzc3VtZWQgaXQgd2FzIDApIGFuZCBpbnN0ZWFkXHJcblx0Ly8gb3B0ZWQgZm9yIGEgXCJDLWNvbnN0YW50XCIgZm9yIHJlc29sdXRpb24gYWRqdXN0bWVudCBvZiBvYmplY3RzIG5lYXIgdGhlIGNhbWVyYS5cclxuXHQvLyBPdXRlcnJhIHN0YXRlczogXCJOb3RpY2UgdGhhdCB0aGUgJ0MnIHZhcmlhbnQgZG9lc27igJl0IHVzZSBhIG5lYXIgcGxhbmUgZGlzdGFuY2UsIGl0IGhhcyBpdFxyXG5cdC8vIHNldCBhdCAwXCIgKHF1b3RlIGZyb20gaHR0cHM6Ly9vdXRlcnJhLmJsb2dzcG90LmNvbS8yMDEyLzExL21heGltaXppbmctZGVwdGgtYnVmZmVyLXJhbmdlLWFuZC5odG1sKS5cclxuXHQvLyBVbHJpY2gncyB2YXJpYW50IGhhcyB0aGUgYmVuZWZpdCBvZiBjb25zdGFudCByZWxhdGl2ZSBwcmVjaXNpb24gb3ZlciB0aGUgd2hvbGUgbmVhci1mYXIgcmFuZ2UuXHJcblx0Ly8gSXQgd2FzIGRlYmF0ZWQgaGVyZSB3aGV0aGVyIE91dGVycmEncyBcIkMtY29uc3RhbnRcIiBvciBVbHJpY2gncyBcIm5lYXIgcGxhbmVcIiB2YXJpYW50IHNob3VsZFxyXG5cdC8vIGJlIHVzZWQsIGFuZCB1bHRpbWF0ZWx5IFVscmljaCdzIFwibmVhciBwbGFuZVwiIHZlcnNpb24gd2FzIGNob3Nlbi5cclxuXHQvLyBPdXRlcnJhIGV2ZW50dWFsbHkgbWFkZSBhbm90aGVyIGltcHJvdmVtZW50IHRvIHRoZWlyIG9yaWdpbmFsIFwiQy1jb25zdGFudFwiIHZhcmlhbnQsXHJcblx0Ly8gYnV0IGl0IHN0aWxsIGRvZXMgbm90IGluY29ycG9yYXRlIHRoZSBjYW1lcmEgbmVhciBwbGFuZSAoZm9yIHRoaXMgdmVyc2lvbixcclxuXHQvLyBzZWUgaHR0cHM6Ly9vdXRlcnJhLmJsb2dzcG90LmNvbS8yMDEzLzA3L2xvZ2FyaXRobWljLWRlcHRoLWJ1ZmZlci1vcHRpbWl6YXRpb25zLmh0bWwpLlxyXG5cdC8vIEhlcmUgd2UgbWFrZSA0IGNoYW5nZXMgdG8gVWxyaWNoJ3MgZm9ybXVsYTpcclxuXHQvLyAxLiBDbGFtcCB0aGUgY2FtZXJhIG5lYXIgcGxhbmUgc28gd2UgZG9uJ3QgZGl2aWRlIGJ5IDAuXHJcblx0Ly8gMi4gVXNlIGxvZzIgaW5zdGVhZCBvZiBsb2cgdG8gYXZvaWQgYW4gZXh0cmEgbXVsdGlwbHkgKHNoYWRlcnMgaW1wbGVtZW50IGxvZyB1c2luZyBsb2cyKS5cclxuXHQvLyAzLiBBc3N1bWUgSyBpcyAxIChLID0gbWF4aW11bSB2YWx1ZSBpbiBkZXB0aCBidWZmZXI7IHNlZSBVbHJpY2gncyBmb3JtdWxhIGFib3ZlKS5cclxuXHQvLyA0LiBUbyBtYWludGFpbiBjb25zaXN0ZW5jeSB3aXRoIHRoZSBmdW5jdGlvbnMgXCJ2aWV3WlRvT3J0aG9ncmFwaGljRGVwdGhcIiBhbmQgXCJ2aWV3WlRvUGVyc3BlY3RpdmVEZXB0aFwiLFxyXG5cdC8vICAgIHdlIG1vZGlmeSB0aGUgZm9ybXVsYSBoZXJlIHRvIHVzZSAndmlld1onIGluc3RlYWQgb2YgJ3cnLiBUaGUgb3RoZXIgZnVuY3Rpb25zIGV4cGVjdCBhIG5lZ2F0aXZlIHZpZXdaLFxyXG5cdC8vICAgIHNvIHdlIGRvIHRoZSBzYW1lIGhlcmUsIGhlbmNlIHRoZSAndmlld1oubmVnYXRlKCknIGNhbGwuXHJcblx0Ly8gRm9yIHZpc3VhbCByZXByZXNlbnRhdGlvbiBvZiB0aGlzIGRlcHRoIGN1cnZlLCBzZWUgaHR0cHM6Ly93d3cuZGVzbW9zLmNvbS9jYWxjdWxhdG9yL3V5cWswdmV4MXVcclxuXHRuZWFyID0gbmVhci5tYXgoIDFlLTYgKS50b1ZhcigpO1xyXG5cdGNvbnN0IG51bWVyYXRvciA9IGxvZzIoIHZpZXdaLm5lZ2F0ZSgpLmRpdiggbmVhciApICk7XHJcblx0Y29uc3QgZGVub21pbmF0b3IgPSBsb2cyKCBmYXIuZGl2KCBuZWFyICkgKTtcclxuXHRyZXR1cm4gbnVtZXJhdG9yLmRpdiggZGVub21pbmF0b3IgKTtcclxuXHJcbn07XHJcblxyXG4vKipcclxuICogVFNMIGZ1bmN0aW9uIGZvciBjb252ZXJ0aW5nIGEgbG9nYXJpdGhtaWMgZGVwdGggdmFsdWUgdG8gYSB2aWV3WiB2YWx1ZS5cclxuICpcclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7Tm9kZTxmbG9hdD59IGRlcHRoIC0gVGhlIGxvZ2FyaXRobWljIGRlcHRoLlxyXG4gKiBAcGFyYW0ge05vZGU8ZmxvYXQ+fSBuZWFyIC0gVGhlIGNhbWVyYSdzIG5lYXIgdmFsdWUuXHJcbiAqIEBwYXJhbSB7Tm9kZTxmbG9hdD59IGZhciAtIFRoZSBjYW1lcmEncyBmYXIgdmFsdWUuXHJcbiAqIEByZXR1cm5zIHtOb2RlPGZsb2F0Pn1cclxuICovXHJcbmV4cG9ydCBjb25zdCBsb2dhcml0aG1pY0RlcHRoVG9WaWV3WiA9ICggZGVwdGgsIG5lYXIsIGZhciApID0+IHtcclxuXHJcblx0Ly8gTk9URTogd2UgYWRkIGEgJ25lZ2F0ZSgpJyBjYWxsIHRvIHRoZSByZXR1cm4gdmFsdWUgaGVyZSB0byBtYWludGFpbiBjb25zaXN0ZW5jeSB3aXRoXHJcblx0Ly8gdGhlIGZ1bmN0aW9ucyBcIm9ydGhvZ3JhcGhpY0RlcHRoVG9WaWV3WlwiIGFuZCBcInBlcnNwZWN0aXZlRGVwdGhUb1ZpZXdaXCIgKHRoZXkgcmV0dXJuXHJcblx0Ly8gYSBuZWdhdGl2ZSB2aWV3WikuXHJcblx0Y29uc3QgZXhwb25lbnQgPSBkZXB0aC5tdWwoIGxvZyggZmFyLmRpdiggbmVhciApICkgKTtcclxuXHRyZXR1cm4gZmxvYXQoIE1hdGguRSApLnBvdyggZXhwb25lbnQgKS5tdWwoIG5lYXIgKS5uZWdhdGUoKTtcclxuXHJcbn07XHJcblxyXG4vKipcclxuICogVFNMIGZ1bmN0aW9uIGZvciBkZWZpbmluZyBhIHZhbHVlIGZvciB0aGUgY3VycmVudCBmcmFnbWVudCdzIGRlcHRoLlxyXG4gKlxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHtOb2RlPGZsb2F0Pn0gdmFsdWUgLSBUaGUgZGVwdGggdmFsdWUgdG8gc2V0LlxyXG4gKiBAcmV0dXJucyB7Vmlld3BvcnREZXB0aE5vZGU8ZmxvYXQ+fVxyXG4gKi9cclxuY29uc3QgZGVwdGhCYXNlID0gLypAX19QVVJFX18qLyBub2RlUHJveHkoIFZpZXdwb3J0RGVwdGhOb2RlLCBWaWV3cG9ydERlcHRoTm9kZS5ERVBUSF9CQVNFICk7XHJcblxyXG4vKipcclxuICogVFNMIG9iamVjdCB0aGF0IHJlcHJlc2VudHMgdGhlIGRlcHRoIHZhbHVlIGZvciB0aGUgY3VycmVudCBmcmFnbWVudC5cclxuICpcclxuICogQHR5cGUge1ZpZXdwb3J0RGVwdGhOb2RlfVxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IGRlcHRoID0gLypAX19QVVJFX18qLyBub2RlSW1tdXRhYmxlKCBWaWV3cG9ydERlcHRoTm9kZSwgVmlld3BvcnREZXB0aE5vZGUuREVQVEggKTtcclxuXHJcbi8qKlxyXG4gKiBUU0wgZnVuY3Rpb24gZm9yIGNvbnZlcnRpbmcgYSBwZXJzcGVjdGl2ZSBkZXB0aCB2YWx1ZSB0byBsaW5lYXIgZGVwdGguXHJcbiAqXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0ge05vZGU8ZmxvYXQ+fSB2YWx1ZSAtIFRoZSBwZXJzcGVjdGl2ZSBkZXB0aC5cclxuICogQHJldHVybnMge1ZpZXdwb3J0RGVwdGhOb2RlPGZsb2F0Pn1cclxuICovXHJcbmV4cG9ydCBjb25zdCBsaW5lYXJEZXB0aCA9IC8qQF9fUFVSRV9fKi8gbm9kZVByb3h5KCBWaWV3cG9ydERlcHRoTm9kZSwgVmlld3BvcnREZXB0aE5vZGUuTElORUFSX0RFUFRIICk7XHJcblxyXG4vKipcclxuICogVFNMIG9iamVjdCB0aGF0IHJlcHJlc2VudHMgdGhlIGxpbmVhciAob3J0aG9ncmFwaGljKSBkZXB0aCB2YWx1ZSBvZiB0aGUgY3VycmVudCBmcmFnbWVudFxyXG4gKlxyXG4gKiBAdHlwZSB7Vmlld3BvcnREZXB0aE5vZGV9XHJcbiAqL1xyXG5leHBvcnQgY29uc3Qgdmlld3BvcnRMaW5lYXJEZXB0aCA9IC8qQF9fUFVSRV9fKi8gbGluZWFyRGVwdGgoIHZpZXdwb3J0RGVwdGhUZXh0dXJlKCkgKTtcclxuXHJcbmRlcHRoLmFzc2lnbiA9ICggdmFsdWUgKSA9PiBkZXB0aEJhc2UoIHZhbHVlICk7XHJcbiIsImltcG9ydCBOb2RlIGZyb20gJy4uL2NvcmUvTm9kZS5qcyc7XHJcbmltcG9ydCB7IG5vZGVQcm94eSB9IGZyb20gJy4uL3RzbC9UU0xCYXNlLmpzJztcclxuXHJcbmNsYXNzIEJ1aWx0aW5Ob2RlIGV4dGVuZHMgTm9kZSB7XHJcblxyXG5cdGNvbnN0cnVjdG9yKCBuYW1lICkge1xyXG5cclxuXHRcdHN1cGVyKCAnZmxvYXQnICk7XHJcblxyXG5cdFx0dGhpcy5uYW1lID0gbmFtZTtcclxuXHJcblx0XHR0aGlzLmlzQnVpbHRpbk5vZGUgPSB0cnVlO1xyXG5cclxuXHR9XHJcblxyXG5cdGdlbmVyYXRlKCAvKiBidWlsZGVyICovICkge1xyXG5cclxuXHRcdHJldHVybiB0aGlzLm5hbWU7XHJcblxyXG5cdH1cclxuXHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IEJ1aWx0aW5Ob2RlO1xyXG5cclxuZXhwb3J0IGNvbnN0IGJ1aWx0aW4gPSBub2RlUHJveHkoIEJ1aWx0aW5Ob2RlICk7XHJcbiIsIlxyXG5pbXBvcnQgTm9kZSBmcm9tICcuLi9jb3JlL05vZGUuanMnO1xyXG5pbXBvcnQgeyBub2RlT2JqZWN0LCBGbiwgYm9vbCwgZmxvYXQgfSBmcm9tICcuLi90c2wvVFNMQmFzZS5qcyc7XHJcbmltcG9ydCB7IHBvc2l0aW9uVmlldyB9IGZyb20gJy4vUG9zaXRpb24uanMnO1xyXG5pbXBvcnQgeyBkaWZmdXNlQ29sb3IgfSBmcm9tICcuLi9jb3JlL1Byb3BlcnR5Tm9kZS5qcyc7XHJcbmltcG9ydCB7IExvb3AgfSBmcm9tICcuLi91dGlscy9Mb29wTm9kZS5qcyc7XHJcbmltcG9ydCB7IHNtb290aHN0ZXAgfSBmcm9tICcuLi9tYXRoL01hdGhOb2RlLmpzJztcclxuaW1wb3J0IHsgdW5pZm9ybUFycmF5IH0gZnJvbSAnLi9Vbmlmb3JtQXJyYXlOb2RlLmpzJztcclxuaW1wb3J0IHsgYnVpbHRpbiB9IGZyb20gJy4vQnVpbHRpbk5vZGUuanMnO1xyXG5cclxuY2xhc3MgQ2xpcHBpbmdOb2RlIGV4dGVuZHMgTm9kZSB7XHJcblxyXG5cdHN0YXRpYyBnZXQgdHlwZSgpIHtcclxuXHJcblx0XHRyZXR1cm4gJ0NsaXBwaW5nTm9kZSc7XHJcblxyXG5cdH1cclxuXHJcblx0Y29uc3RydWN0b3IoIHNjb3BlID0gQ2xpcHBpbmdOb2RlLkRFRkFVTFQgKSB7XHJcblxyXG5cdFx0c3VwZXIoKTtcclxuXHJcblx0XHR0aGlzLnNjb3BlID0gc2NvcGU7XHJcblxyXG5cdH1cclxuXHJcblx0c2V0dXAoIGJ1aWxkZXIgKSB7XHJcblxyXG5cdFx0c3VwZXIuc2V0dXAoIGJ1aWxkZXIgKTtcclxuXHJcblx0XHRjb25zdCBjbGlwcGluZ0NvbnRleHQgPSBidWlsZGVyLmNsaXBwaW5nQ29udGV4dDtcclxuXHRcdGNvbnN0IHsgaW50ZXJzZWN0aW9uUGxhbmVzLCB1bmlvblBsYW5lcyB9ID0gY2xpcHBpbmdDb250ZXh0O1xyXG5cclxuXHRcdHRoaXMuaGFyZHdhcmVDbGlwcGluZyA9IGJ1aWxkZXIubWF0ZXJpYWwuaGFyZHdhcmVDbGlwcGluZztcclxuXHJcblx0XHRpZiAoIHRoaXMuc2NvcGUgPT09IENsaXBwaW5nTm9kZS5BTFBIQV9UT19DT1ZFUkFHRSApIHtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzLnNldHVwQWxwaGFUb0NvdmVyYWdlKCBpbnRlcnNlY3Rpb25QbGFuZXMsIHVuaW9uUGxhbmVzICk7XHJcblxyXG5cdFx0fSBlbHNlIGlmICggdGhpcy5zY29wZSA9PT0gQ2xpcHBpbmdOb2RlLkhBUkRXQVJFICkge1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXMuc2V0dXBIYXJkd2FyZUNsaXBwaW5nKCB1bmlvblBsYW5lcywgYnVpbGRlciApO1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcy5zZXR1cERlZmF1bHQoIGludGVyc2VjdGlvblBsYW5lcywgdW5pb25QbGFuZXMgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0c2V0dXBBbHBoYVRvQ292ZXJhZ2UoIGludGVyc2VjdGlvblBsYW5lcywgdW5pb25QbGFuZXMgKSB7XHJcblxyXG5cdFx0cmV0dXJuIEZuKCAoKSA9PiB7XHJcblxyXG5cdFx0XHRjb25zdCBkaXN0YW5jZVRvUGxhbmUgPSBmbG9hdCgpLnRvVmFyKCAnZGlzdGFuY2VUb1BsYW5lJyApO1xyXG5cdFx0XHRjb25zdCBkaXN0YW5jZUdyYWRpZW50ID0gZmxvYXQoKS50b1ZhciggJ2Rpc3RhbmNlVG9HcmFkaWVudCcgKTtcclxuXHJcblx0XHRcdGNvbnN0IGNsaXBPcGFjaXR5ID0gZmxvYXQoIDEgKS50b1ZhciggJ2NsaXBPcGFjaXR5JyApO1xyXG5cclxuXHRcdFx0Y29uc3QgbnVtVW5pb25QbGFuZXMgPSB1bmlvblBsYW5lcy5sZW5ndGg7XHJcblxyXG5cdFx0XHRpZiAoICEgdGhpcy5oYXJkd2FyZUNsaXBwaW5nICYmIG51bVVuaW9uUGxhbmVzID4gMCApIHtcclxuXHJcblx0XHRcdFx0Y29uc3QgY2xpcHBpbmdQbGFuZXMgPSB1bmlmb3JtQXJyYXkoIHVuaW9uUGxhbmVzICk7XHJcblxyXG5cdFx0XHRcdExvb3AoIG51bVVuaW9uUGxhbmVzLCAoIHsgaSB9ICkgPT4ge1xyXG5cclxuXHRcdFx0XHRcdGNvbnN0IHBsYW5lID0gY2xpcHBpbmdQbGFuZXMuZWxlbWVudCggaSApO1xyXG5cclxuXHRcdFx0XHRcdGRpc3RhbmNlVG9QbGFuZS5hc3NpZ24oIHBvc2l0aW9uVmlldy5kb3QoIHBsYW5lLnh5eiApLm5lZ2F0ZSgpLmFkZCggcGxhbmUudyApICk7XHJcblx0XHRcdFx0XHRkaXN0YW5jZUdyYWRpZW50LmFzc2lnbiggZGlzdGFuY2VUb1BsYW5lLmZ3aWR0aCgpLmRpdiggMi4wICkgKTtcclxuXHJcblx0XHRcdFx0XHRjbGlwT3BhY2l0eS5tdWxBc3NpZ24oIHNtb290aHN0ZXAoIGRpc3RhbmNlR3JhZGllbnQubmVnYXRlKCksIGRpc3RhbmNlR3JhZGllbnQsIGRpc3RhbmNlVG9QbGFuZSApICk7XHJcblxyXG5cdFx0XHRcdH0gKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGNvbnN0IG51bUludGVyc2VjdGlvblBsYW5lcyA9IGludGVyc2VjdGlvblBsYW5lcy5sZW5ndGg7XHJcblxyXG5cdFx0XHRpZiAoIG51bUludGVyc2VjdGlvblBsYW5lcyA+IDAgKSB7XHJcblxyXG5cdFx0XHRcdGNvbnN0IGNsaXBwaW5nUGxhbmVzID0gdW5pZm9ybUFycmF5KCBpbnRlcnNlY3Rpb25QbGFuZXMgKTtcclxuXHRcdFx0XHRjb25zdCBpbnRlcnNlY3Rpb25DbGlwT3BhY2l0eSA9IGZsb2F0KCAxICkudG9WYXIoICdpbnRlcnNlY3Rpb25DbGlwT3BhY2l0eScgKTtcclxuXHJcblx0XHRcdFx0TG9vcCggbnVtSW50ZXJzZWN0aW9uUGxhbmVzLCAoIHsgaSB9ICkgPT4ge1xyXG5cclxuXHRcdFx0XHRcdGNvbnN0IHBsYW5lID0gY2xpcHBpbmdQbGFuZXMuZWxlbWVudCggaSApO1xyXG5cclxuXHRcdFx0XHRcdGRpc3RhbmNlVG9QbGFuZS5hc3NpZ24oIHBvc2l0aW9uVmlldy5kb3QoIHBsYW5lLnh5eiApLm5lZ2F0ZSgpLmFkZCggcGxhbmUudyApICk7XHJcblx0XHRcdFx0XHRkaXN0YW5jZUdyYWRpZW50LmFzc2lnbiggZGlzdGFuY2VUb1BsYW5lLmZ3aWR0aCgpLmRpdiggMi4wICkgKTtcclxuXHJcblx0XHRcdFx0XHRpbnRlcnNlY3Rpb25DbGlwT3BhY2l0eS5tdWxBc3NpZ24oIHNtb290aHN0ZXAoIGRpc3RhbmNlR3JhZGllbnQubmVnYXRlKCksIGRpc3RhbmNlR3JhZGllbnQsIGRpc3RhbmNlVG9QbGFuZSApLm9uZU1pbnVzKCkgKTtcclxuXHJcblx0XHRcdFx0fSApO1xyXG5cclxuXHRcdFx0XHRjbGlwT3BhY2l0eS5tdWxBc3NpZ24oIGludGVyc2VjdGlvbkNsaXBPcGFjaXR5Lm9uZU1pbnVzKCkgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGRpZmZ1c2VDb2xvci5hLm11bEFzc2lnbiggY2xpcE9wYWNpdHkgKTtcclxuXHJcblx0XHRcdGRpZmZ1c2VDb2xvci5hLmVxdWFsKCAwLjAgKS5kaXNjYXJkKCk7XHJcblxyXG5cdFx0fSApKCk7XHJcblxyXG5cdH1cclxuXHJcblx0c2V0dXBEZWZhdWx0KCBpbnRlcnNlY3Rpb25QbGFuZXMsIHVuaW9uUGxhbmVzICkge1xyXG5cclxuXHRcdHJldHVybiBGbiggKCkgPT4ge1xyXG5cclxuXHRcdFx0Y29uc3QgbnVtVW5pb25QbGFuZXMgPSB1bmlvblBsYW5lcy5sZW5ndGg7XHJcblxyXG5cdFx0XHRpZiAoICEgdGhpcy5oYXJkd2FyZUNsaXBwaW5nICYmIG51bVVuaW9uUGxhbmVzID4gMCApIHtcclxuXHJcblx0XHRcdFx0Y29uc3QgY2xpcHBpbmdQbGFuZXMgPSB1bmlmb3JtQXJyYXkoIHVuaW9uUGxhbmVzICk7XHJcblxyXG5cdFx0XHRcdExvb3AoIG51bVVuaW9uUGxhbmVzLCAoIHsgaSB9ICkgPT4ge1xyXG5cclxuXHRcdFx0XHRcdGNvbnN0IHBsYW5lID0gY2xpcHBpbmdQbGFuZXMuZWxlbWVudCggaSApO1xyXG5cdFx0XHRcdFx0cG9zaXRpb25WaWV3LmRvdCggcGxhbmUueHl6ICkuZ3JlYXRlclRoYW4oIHBsYW5lLncgKS5kaXNjYXJkKCk7XHJcblxyXG5cdFx0XHRcdH0gKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGNvbnN0IG51bUludGVyc2VjdGlvblBsYW5lcyA9IGludGVyc2VjdGlvblBsYW5lcy5sZW5ndGg7XHJcblxyXG5cdFx0XHRpZiAoIG51bUludGVyc2VjdGlvblBsYW5lcyA+IDAgKSB7XHJcblxyXG5cdFx0XHRcdGNvbnN0IGNsaXBwaW5nUGxhbmVzID0gdW5pZm9ybUFycmF5KCBpbnRlcnNlY3Rpb25QbGFuZXMgKTtcclxuXHRcdFx0XHRjb25zdCBjbGlwcGVkID0gYm9vbCggdHJ1ZSApLnRvVmFyKCAnY2xpcHBlZCcgKTtcclxuXHJcblx0XHRcdFx0TG9vcCggbnVtSW50ZXJzZWN0aW9uUGxhbmVzLCAoIHsgaSB9ICkgPT4ge1xyXG5cclxuXHRcdFx0XHRcdGNvbnN0IHBsYW5lID0gY2xpcHBpbmdQbGFuZXMuZWxlbWVudCggaSApO1xyXG5cdFx0XHRcdFx0Y2xpcHBlZC5hc3NpZ24oIHBvc2l0aW9uVmlldy5kb3QoIHBsYW5lLnh5eiApLmdyZWF0ZXJUaGFuKCBwbGFuZS53ICkuYW5kKCBjbGlwcGVkICkgKTtcclxuXHJcblx0XHRcdFx0fSApO1xyXG5cclxuXHRcdFx0XHRjbGlwcGVkLmRpc2NhcmQoKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9ICkoKTtcclxuXHJcblx0fVxyXG5cclxuXHRzZXR1cEhhcmR3YXJlQ2xpcHBpbmcoIHVuaW9uUGxhbmVzLCBidWlsZGVyICkge1xyXG5cclxuXHRcdGNvbnN0IG51bVVuaW9uUGxhbmVzID0gdW5pb25QbGFuZXMubGVuZ3RoO1xyXG5cclxuXHRcdGJ1aWxkZXIuZW5hYmxlSGFyZHdhcmVDbGlwcGluZyggbnVtVW5pb25QbGFuZXMgKTtcclxuXHJcblx0XHRyZXR1cm4gRm4oICgpID0+IHtcclxuXHJcblx0XHRcdGNvbnN0IGNsaXBwaW5nUGxhbmVzID0gdW5pZm9ybUFycmF5KCB1bmlvblBsYW5lcyApO1xyXG5cdFx0XHRjb25zdCBod19jbGlwX2Rpc3RhbmNlcyA9IGJ1aWx0aW4oIGJ1aWxkZXIuZ2V0Q2xpcERpc3RhbmNlKCkgKTtcclxuXHJcblx0XHRcdExvb3AoIG51bVVuaW9uUGxhbmVzLCAoIHsgaSB9ICkgPT4ge1xyXG5cclxuXHRcdFx0XHRjb25zdCBwbGFuZSA9IGNsaXBwaW5nUGxhbmVzLmVsZW1lbnQoIGkgKTtcclxuXHJcblx0XHRcdFx0Y29uc3QgZGlzdGFuY2UgPSBwb3NpdGlvblZpZXcuZG90KCBwbGFuZS54eXogKS5zdWIoIHBsYW5lLncgKS5uZWdhdGUoKTtcclxuXHRcdFx0XHRod19jbGlwX2Rpc3RhbmNlcy5lbGVtZW50KCBpICkuYXNzaWduKCBkaXN0YW5jZSApO1xyXG5cclxuXHRcdFx0fSApO1xyXG5cclxuXHRcdH0gKSgpO1xyXG5cclxuXHR9XHJcblxyXG59XHJcblxyXG5DbGlwcGluZ05vZGUuQUxQSEFfVE9fQ09WRVJBR0UgPSAnYWxwaGFUb0NvdmVyYWdlJztcclxuQ2xpcHBpbmdOb2RlLkRFRkFVTFQgPSAnZGVmYXVsdCc7XHJcbkNsaXBwaW5nTm9kZS5IQVJEV0FSRSA9ICdoYXJkd2FyZSc7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBDbGlwcGluZ05vZGU7XHJcblxyXG5leHBvcnQgY29uc3QgY2xpcHBpbmcgPSAoKSA9PiBub2RlT2JqZWN0KCBuZXcgQ2xpcHBpbmdOb2RlKCkgKTtcclxuZXhwb3J0IGNvbnN0IGNsaXBwaW5nQWxwaGEgPSAoKSA9PiBub2RlT2JqZWN0KCBuZXcgQ2xpcHBpbmdOb2RlKCBDbGlwcGluZ05vZGUuQUxQSEFfVE9fQ09WRVJBR0UgKSApO1xyXG5leHBvcnQgY29uc3QgaGFyZHdhcmVDbGlwcGluZyA9ICgpID0+IG5vZGVPYmplY3QoIG5ldyBDbGlwcGluZ05vZGUoIENsaXBwaW5nTm9kZS5IQVJEV0FSRSApICk7XHJcbiIsImltcG9ydCB7IGFicywgYWRkLCBjZWlsLCBjbGFtcCwgZEZkeCwgZEZkeSwgZXhwMiwgZmxvYXQsIGZsb29yLCBGbiwgZnJhY3QsIGxlbmd0aCwgbG9nMiwgbWF4LCBtaW4sIG11bCwgc2luLCBzdWIsIHZlYzIsIHZlYzMgfSBmcm9tICcuLi8uLi90c2wvVFNMQmFzZS5qcyc7XHJcblxyXG4vLyBTZWU6IGh0dHBzOi8vY2FzdWFsLWVmZmVjdHMuY29tL3Jlc2VhcmNoL1d5bWFuMjAxN0hhc2hlZC9pbmRleC5odG1sXHJcblxyXG5jb25zdCBBTFBIQV9IQVNIX1NDQUxFID0gMC4wNTsgLy8gRGVyaXZlZCBmcm9tIHRyaWFscyBvbmx5LCBhbmQgbWF5IGJlIGNoYW5nZWQuXHJcblxyXG5jb25zdCBoYXNoMkQgPSAvKkBfX1BVUkVfXyovIEZuKCAoIFsgdmFsdWUgXSApID0+IHtcclxuXHJcblx0cmV0dXJuIGZyYWN0KCBtdWwoIDEuMGU0LCBzaW4oIG11bCggMTcuMCwgdmFsdWUueCApLmFkZCggbXVsKCAwLjEsIHZhbHVlLnkgKSApICkgKS5tdWwoIGFkZCggMC4xLCBhYnMoIHNpbiggbXVsKCAxMy4wLCB2YWx1ZS55ICkuYWRkKCB2YWx1ZS54ICkgKSApICkgKSApO1xyXG5cclxufSApO1xyXG5cclxuY29uc3QgaGFzaDNEID0gLypAX19QVVJFX18qLyBGbiggKCBbIHZhbHVlIF0gKSA9PiB7XHJcblxyXG5cdHJldHVybiBoYXNoMkQoIHZlYzIoIGhhc2gyRCggdmFsdWUueHkgKSwgdmFsdWUueiApICk7XHJcblxyXG59ICk7XHJcblxyXG5jb25zdCBnZXRBbHBoYUhhc2hUaHJlc2hvbGQgPSAvKkBfX1BVUkVfXyovIEZuKCAoIFsgcG9zaXRpb24gXSApID0+IHtcclxuXHJcblx0Ly8gRmluZCB0aGUgZGlzY3JldGl6ZWQgZGVyaXZhdGl2ZXMgb2Ygb3VyIGNvb3JkaW5hdGVzXHJcblx0Y29uc3QgbWF4RGVyaXYgPSBtYXgoXHJcblx0XHRsZW5ndGgoIGRGZHgoIHBvc2l0aW9uLnh5eiApICksXHJcblx0XHRsZW5ndGgoIGRGZHkoIHBvc2l0aW9uLnh5eiApIClcclxuXHQpO1xyXG5cclxuXHRjb25zdCBwaXhTY2FsZSA9IGZsb2F0KCAxICkuZGl2KCBmbG9hdCggQUxQSEFfSEFTSF9TQ0FMRSApLm11bCggbWF4RGVyaXYgKSApLnRvVmFyKCAncGl4U2NhbGUnICk7XHJcblxyXG5cdC8vIEZpbmQgdHdvIG5lYXJlc3QgbG9nLWRpc2NyZXRpemVkIG5vaXNlIHNjYWxlc1xyXG5cdGNvbnN0IHBpeFNjYWxlcyA9IHZlYzIoXHJcblx0XHRleHAyKCBmbG9vciggbG9nMiggcGl4U2NhbGUgKSApICksXHJcblx0XHRleHAyKCBjZWlsKCBsb2cyKCBwaXhTY2FsZSApICkgKVxyXG5cdCk7XHJcblxyXG5cdC8vIENvbXB1dGUgYWxwaGEgdGhyZXNob2xkcyBhdCBvdXIgdHdvIG5vaXNlIHNjYWxlc1xyXG5cdGNvbnN0IGFscGhhID0gdmVjMihcclxuXHRcdGhhc2gzRCggZmxvb3IoIHBpeFNjYWxlcy54Lm11bCggcG9zaXRpb24ueHl6ICkgKSApLFxyXG5cdFx0aGFzaDNEKCBmbG9vciggcGl4U2NhbGVzLnkubXVsKCBwb3NpdGlvbi54eXogKSApICksXHJcblx0KTtcclxuXHJcblx0Ly8gRmFjdG9yIHRvIGludGVycG9sYXRlIGxlcnAgd2l0aFxyXG5cdGNvbnN0IGxlcnBGYWN0b3IgPSBmcmFjdCggbG9nMiggcGl4U2NhbGUgKSApO1xyXG5cclxuXHQvLyBJbnRlcnBvbGF0ZSBhbHBoYSB0aHJlc2hvbGQgZnJvbSBub2lzZSBhdCB0d28gc2NhbGVzXHJcblx0Y29uc3QgeCA9IGFkZCggbXVsKCBsZXJwRmFjdG9yLm9uZU1pbnVzKCksIGFscGhhLnggKSwgbXVsKCBsZXJwRmFjdG9yLCBhbHBoYS55ICkgKTtcclxuXHJcblx0Ly8gUGFzcyBpbnRvIENERiB0byBjb21wdXRlIHVuaWZvcm1seSBkaXN0cmliIHRocmVzaG9sZFxyXG5cdGNvbnN0IGEgPSBtaW4oIGxlcnBGYWN0b3IsIGxlcnBGYWN0b3Iub25lTWludXMoKSApO1xyXG5cdGNvbnN0IGNhc2VzID0gdmVjMyhcclxuXHRcdHgubXVsKCB4ICkuZGl2KCBtdWwoIDIuMCwgYSApLm11bCggc3ViKCAxLjAsIGEgKSApICksXHJcblx0XHR4LnN1YiggbXVsKCAwLjUsIGEgKSApLmRpdiggc3ViKCAxLjAsIGEgKSApLFxyXG5cdFx0c3ViKCAxLjAsIHN1YiggMS4wLCB4ICkubXVsKCBzdWIoIDEuMCwgeCApICkuZGl2KCBtdWwoIDIuMCwgYSApLm11bCggc3ViKCAxLjAsIGEgKSApICkgKSApO1xyXG5cclxuXHQvLyBGaW5kIG91ciBmaW5hbCwgdW5pZm9ybWx5IGRpc3RyaWJ1dGVkIGFscGhhIHRocmVzaG9sZCAozrHPhClcclxuXHRjb25zdCB0aHJlc2hvbGQgPSB4Lmxlc3NUaGFuKCBhLm9uZU1pbnVzKCkgKS5zZWxlY3QoIHgubGVzc1RoYW4oIGEgKS5zZWxlY3QoIGNhc2VzLngsIGNhc2VzLnkgKSwgY2FzZXMueiApO1xyXG5cclxuXHQvLyBBdm9pZHMgzrHPhCA9PSAwLiBDb3VsZCBhbHNvIGRvIM6xz4QgPTEtzrHPhFxyXG5cdHJldHVybiBjbGFtcCggdGhyZXNob2xkLCAxLjBlLTYsIDEuMCApO1xyXG5cclxufSApLnNldExheW91dCgge1xyXG5cdG5hbWU6ICdnZXRBbHBoYUhhc2hUaHJlc2hvbGQnLFxyXG5cdHR5cGU6ICdmbG9hdCcsXHJcblx0aW5wdXRzOiBbXHJcblx0XHR7IG5hbWU6ICdwb3NpdGlvbicsIHR5cGU6ICd2ZWMzJyB9XHJcblx0XVxyXG59ICk7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBnZXRBbHBoYUhhc2hUaHJlc2hvbGQ7XHJcbiIsImltcG9ydCB7IE1hdGVyaWFsIH0gZnJvbSAnLi4vTWF0ZXJpYWwuanMnO1xyXG5pbXBvcnQgeyBOb3JtYWxCbGVuZGluZyB9IGZyb20gJy4uLy4uL2NvbnN0YW50cy5qcyc7XHJcblxyXG5pbXBvcnQgeyBnZXROb2RlQ2hpbGRyZW4sIGdldENhY2hlS2V5IH0gZnJvbSAnLi4vLi4vbm9kZXMvY29yZS9Ob2RlVXRpbHMuanMnO1xyXG5pbXBvcnQgeyBhdHRyaWJ1dGUgfSBmcm9tICcuLi8uLi9ub2Rlcy9jb3JlL0F0dHJpYnV0ZU5vZGUuanMnO1xyXG5pbXBvcnQgeyBvdXRwdXQsIGRpZmZ1c2VDb2xvciwgZW1pc3NpdmUsIHZhcnlpbmdQcm9wZXJ0eSB9IGZyb20gJy4uLy4uL25vZGVzL2NvcmUvUHJvcGVydHlOb2RlLmpzJztcclxuaW1wb3J0IHsgbWF0ZXJpYWxBbHBoYVRlc3QsIG1hdGVyaWFsQ29sb3IsIG1hdGVyaWFsT3BhY2l0eSwgbWF0ZXJpYWxFbWlzc2l2ZSwgbWF0ZXJpYWxOb3JtYWwsIG1hdGVyaWFsTGlnaHRNYXAsIG1hdGVyaWFsQU9NYXAgfSBmcm9tICcuLi8uLi9ub2Rlcy9hY2Nlc3NvcnMvTWF0ZXJpYWxOb2RlLmpzJztcclxuaW1wb3J0IHsgbW9kZWxWaWV3UHJvamVjdGlvbiB9IGZyb20gJy4uLy4uL25vZGVzL2FjY2Vzc29ycy9Nb2RlbFZpZXdQcm9qZWN0aW9uTm9kZS5qcyc7XHJcbmltcG9ydCB7IG5vcm1hbExvY2FsIH0gZnJvbSAnLi4vLi4vbm9kZXMvYWNjZXNzb3JzL05vcm1hbC5qcyc7XHJcbmltcG9ydCB7IGluc3RhbmNlZE1lc2ggfSBmcm9tICcuLi8uLi9ub2Rlcy9hY2Nlc3NvcnMvSW5zdGFuY2VkTWVzaE5vZGUuanMnO1xyXG5pbXBvcnQgeyBiYXRjaCB9IGZyb20gJy4uLy4uL25vZGVzL2FjY2Vzc29ycy9CYXRjaE5vZGUuanMnO1xyXG5pbXBvcnQgeyBtYXRlcmlhbFJlZmVyZW5jZSB9IGZyb20gJy4uLy4uL25vZGVzL2FjY2Vzc29ycy9NYXRlcmlhbFJlZmVyZW5jZU5vZGUuanMnO1xyXG5pbXBvcnQgeyBwb3NpdGlvbkxvY2FsLCBwb3NpdGlvblZpZXcgfSBmcm9tICcuLi8uLi9ub2Rlcy9hY2Nlc3NvcnMvUG9zaXRpb24uanMnO1xyXG5pbXBvcnQgeyBza2lubmluZ1JlZmVyZW5jZSB9IGZyb20gJy4uLy4uL25vZGVzL2FjY2Vzc29ycy9Ta2lubmluZ05vZGUuanMnO1xyXG5pbXBvcnQgeyBtb3JwaFJlZmVyZW5jZSB9IGZyb20gJy4uLy4uL25vZGVzL2FjY2Vzc29ycy9Nb3JwaE5vZGUuanMnO1xyXG5pbXBvcnQgeyBtaXggfSBmcm9tICcuLi8uLi9ub2Rlcy9tYXRoL01hdGhOb2RlLmpzJztcclxuaW1wb3J0IHsgZmxvYXQsIHZlYzMsIHZlYzQgfSBmcm9tICcuLi8uLi9ub2Rlcy90c2wvVFNMQmFzZS5qcyc7XHJcbmltcG9ydCBBT05vZGUgZnJvbSAnLi4vLi4vbm9kZXMvbGlnaHRpbmcvQU9Ob2RlLmpzJztcclxuaW1wb3J0IHsgbGlnaHRpbmdDb250ZXh0IH0gZnJvbSAnLi4vLi4vbm9kZXMvbGlnaHRpbmcvTGlnaHRpbmdDb250ZXh0Tm9kZS5qcyc7XHJcbmltcG9ydCBJcnJhZGlhbmNlTm9kZSBmcm9tICcuLi8uLi9ub2Rlcy9saWdodGluZy9JcnJhZGlhbmNlTm9kZS5qcyc7XHJcbmltcG9ydCB7IGRlcHRoLCB2aWV3WlRvTG9nYXJpdGhtaWNEZXB0aCwgdmlld1pUb09ydGhvZ3JhcGhpY0RlcHRoIH0gZnJvbSAnLi4vLi4vbm9kZXMvZGlzcGxheS9WaWV3cG9ydERlcHRoTm9kZS5qcyc7XHJcbmltcG9ydCB7IGNhbWVyYUZhciwgY2FtZXJhTmVhciB9IGZyb20gJy4uLy4uL25vZGVzL2FjY2Vzc29ycy9DYW1lcmEuanMnO1xyXG5pbXBvcnQgeyBjbGlwcGluZywgY2xpcHBpbmdBbHBoYSwgaGFyZHdhcmVDbGlwcGluZyB9IGZyb20gJy4uLy4uL25vZGVzL2FjY2Vzc29ycy9DbGlwcGluZ05vZGUuanMnO1xyXG5pbXBvcnQgTm9kZU1hdGVyaWFsT2JzZXJ2ZXIgZnJvbSAnLi9tYW5hZ2VyL05vZGVNYXRlcmlhbE9ic2VydmVyLmpzJztcclxuaW1wb3J0IGdldEFscGhhSGFzaFRocmVzaG9sZCBmcm9tICcuLi8uLi9ub2Rlcy9mdW5jdGlvbnMvbWF0ZXJpYWwvZ2V0QWxwaGFIYXNoVGhyZXNob2xkLmpzJztcclxuaW1wb3J0IHsgbW9kZWxWaWV3TWF0cml4IH0gZnJvbSAnLi4vLi4vbm9kZXMvYWNjZXNzb3JzL01vZGVsTm9kZS5qcyc7XHJcblxyXG5jbGFzcyBOb2RlTWF0ZXJpYWwgZXh0ZW5kcyBNYXRlcmlhbCB7XHJcblxyXG5cdHN0YXRpYyBnZXQgdHlwZSgpIHtcclxuXHJcblx0XHRyZXR1cm4gJ05vZGVNYXRlcmlhbCc7XHJcblxyXG5cdH1cclxuXHJcblx0Z2V0IHR5cGUoKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuY29uc3RydWN0b3IudHlwZTtcclxuXHJcblx0fVxyXG5cclxuXHRzZXQgdHlwZSggX3ZhbHVlICkgeyAvKiAqLyB9XHJcblxyXG5cdGNvbnN0cnVjdG9yKCkge1xyXG5cclxuXHRcdHN1cGVyKCk7XHJcblxyXG5cdFx0dGhpcy5pc05vZGVNYXRlcmlhbCA9IHRydWU7XHJcblxyXG5cdFx0dGhpcy5mb3JjZVNpbmdsZVBhc3MgPSBmYWxzZTtcclxuXHJcblx0XHR0aGlzLmZvZyA9IHRydWU7XHJcblx0XHR0aGlzLmxpZ2h0cyA9IGZhbHNlO1xyXG5cdFx0dGhpcy5oYXJkd2FyZUNsaXBwaW5nID0gZmFsc2U7XHJcblxyXG5cdFx0dGhpcy5saWdodHNOb2RlID0gbnVsbDtcclxuXHRcdHRoaXMuZW52Tm9kZSA9IG51bGw7XHJcblx0XHR0aGlzLmFvTm9kZSA9IG51bGw7XHJcblxyXG5cdFx0dGhpcy5jb2xvck5vZGUgPSBudWxsO1xyXG5cdFx0dGhpcy5ub3JtYWxOb2RlID0gbnVsbDtcclxuXHRcdHRoaXMub3BhY2l0eU5vZGUgPSBudWxsO1xyXG5cdFx0dGhpcy5iYWNrZHJvcE5vZGUgPSBudWxsO1xyXG5cdFx0dGhpcy5iYWNrZHJvcEFscGhhTm9kZSA9IG51bGw7XHJcblx0XHR0aGlzLmFscGhhVGVzdE5vZGUgPSBudWxsO1xyXG5cclxuXHRcdHRoaXMucG9zaXRpb25Ob2RlID0gbnVsbDtcclxuXHRcdHRoaXMuZ2VvbWV0cnlOb2RlID0gbnVsbDtcclxuXHJcblx0XHR0aGlzLmRlcHRoTm9kZSA9IG51bGw7XHJcblx0XHR0aGlzLnNoYWRvd1Bvc2l0aW9uTm9kZSA9IG51bGw7XHJcblx0XHR0aGlzLnJlY2VpdmVkU2hhZG93Tm9kZSA9IG51bGw7XHJcblx0XHR0aGlzLmNhc3RTaGFkb3dOb2RlID0gbnVsbDtcclxuXHJcblx0XHR0aGlzLm91dHB1dE5vZGUgPSBudWxsO1xyXG5cdFx0dGhpcy5tcnROb2RlID0gbnVsbDtcclxuXHJcblx0XHR0aGlzLmZyYWdtZW50Tm9kZSA9IG51bGw7XHJcblx0XHR0aGlzLnZlcnRleE5vZGUgPSBudWxsO1xyXG5cclxuXHR9XHJcblxyXG5cdGN1c3RvbVByb2dyYW1DYWNoZUtleSgpIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy50eXBlICsgZ2V0Q2FjaGVLZXkoIHRoaXMgKTtcclxuXHJcblx0fVxyXG5cclxuXHRidWlsZCggYnVpbGRlciApIHtcclxuXHJcblx0XHR0aGlzLnNldHVwKCBidWlsZGVyICk7XHJcblxyXG5cdH1cclxuXHJcblx0c2V0dXBPYnNlcnZlciggYnVpbGRlciApIHtcclxuXHJcblx0XHRyZXR1cm4gbmV3IE5vZGVNYXRlcmlhbE9ic2VydmVyKCBidWlsZGVyICk7XHJcblxyXG5cdH1cclxuXHJcblx0c2V0dXAoIGJ1aWxkZXIgKSB7XHJcblxyXG5cdFx0YnVpbGRlci5jb250ZXh0LnNldHVwTm9ybWFsID0gKCkgPT4gdGhpcy5zZXR1cE5vcm1hbCggYnVpbGRlciApO1xyXG5cdFx0YnVpbGRlci5jb250ZXh0LnNldHVwUG9zaXRpb25WaWV3ID0gKCkgPT4gdGhpcy5zZXR1cFBvc2l0aW9uVmlldyggYnVpbGRlciApO1xyXG5cclxuXHRcdGNvbnN0IHJlbmRlcmVyID0gYnVpbGRlci5yZW5kZXJlcjtcclxuXHRcdGNvbnN0IHJlbmRlclRhcmdldCA9IHJlbmRlcmVyLmdldFJlbmRlclRhcmdldCgpO1xyXG5cclxuXHRcdC8vIDwgVkVSVEVYIFNUQUdFID5cclxuXHJcblx0XHRidWlsZGVyLmFkZFN0YWNrKCk7XHJcblxyXG5cdFx0Y29uc3QgdmVydGV4Tm9kZSA9IHRoaXMudmVydGV4Tm9kZSB8fCB0aGlzLnNldHVwVmVydGV4KCBidWlsZGVyICk7XHJcblxyXG5cdFx0YnVpbGRlci5zdGFjay5vdXRwdXROb2RlID0gdmVydGV4Tm9kZTtcclxuXHJcblx0XHR0aGlzLnNldHVwSGFyZHdhcmVDbGlwcGluZyggYnVpbGRlciApO1xyXG5cclxuXHRcdGlmICggdGhpcy5nZW9tZXRyeU5vZGUgIT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHRidWlsZGVyLnN0YWNrLm91dHB1dE5vZGUgPSBidWlsZGVyLnN0YWNrLm91dHB1dE5vZGUuYnlwYXNzKCB0aGlzLmdlb21ldHJ5Tm9kZSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRidWlsZGVyLmFkZEZsb3coICd2ZXJ0ZXgnLCBidWlsZGVyLnJlbW92ZVN0YWNrKCkgKTtcclxuXHJcblx0XHQvLyA8IEZSQUdNRU5UIFNUQUdFID5cclxuXHJcblx0XHRidWlsZGVyLmFkZFN0YWNrKCk7XHJcblxyXG5cdFx0bGV0IHJlc3VsdE5vZGU7XHJcblxyXG5cdFx0Y29uc3QgY2xpcHBpbmdOb2RlID0gdGhpcy5zZXR1cENsaXBwaW5nKCBidWlsZGVyICk7XHJcblxyXG5cdFx0aWYgKCB0aGlzLmRlcHRoV3JpdGUgPT09IHRydWUgKSB7XHJcblxyXG5cdFx0XHQvLyBvbmx5IHdyaXRlIGRlcHRoIGlmIGRlcHRoIGJ1ZmZlciBpcyBjb25maWd1cmVkXHJcblxyXG5cdFx0XHRpZiAoIHJlbmRlclRhcmdldCAhPT0gbnVsbCApIHtcclxuXHJcblx0XHRcdFx0aWYgKCByZW5kZXJUYXJnZXQuZGVwdGhCdWZmZXIgPT09IHRydWUgKSB0aGlzLnNldHVwRGVwdGgoIGJ1aWxkZXIgKTtcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdGlmICggcmVuZGVyZXIuZGVwdGggPT09IHRydWUgKSB0aGlzLnNldHVwRGVwdGgoIGJ1aWxkZXIgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCB0aGlzLmZyYWdtZW50Tm9kZSA9PT0gbnVsbCApIHtcclxuXHJcblx0XHRcdHRoaXMuc2V0dXBEaWZmdXNlQ29sb3IoIGJ1aWxkZXIgKTtcclxuXHRcdFx0dGhpcy5zZXR1cFZhcmlhbnRzKCBidWlsZGVyICk7XHJcblxyXG5cdFx0XHRjb25zdCBvdXRnb2luZ0xpZ2h0Tm9kZSA9IHRoaXMuc2V0dXBMaWdodGluZyggYnVpbGRlciApO1xyXG5cclxuXHRcdFx0aWYgKCBjbGlwcGluZ05vZGUgIT09IG51bGwgKSBidWlsZGVyLnN0YWNrLmFkZCggY2xpcHBpbmdOb2RlICk7XHJcblxyXG5cdFx0XHQvLyBmb3JjZSB1bnNpZ25lZCBmbG9hdHMgLSB1c2VmdWwgZm9yIFJlbmRlclRhcmdldHNcclxuXHJcblx0XHRcdGNvbnN0IGJhc2ljT3V0cHV0ID0gdmVjNCggb3V0Z29pbmdMaWdodE5vZGUsIGRpZmZ1c2VDb2xvci5hICkubWF4KCAwICk7XHJcblxyXG5cdFx0XHRyZXN1bHROb2RlID0gdGhpcy5zZXR1cE91dHB1dCggYnVpbGRlciwgYmFzaWNPdXRwdXQgKTtcclxuXHJcblx0XHRcdC8vIE9VVFBVVCBOT0RFXHJcblxyXG5cdFx0XHRvdXRwdXQuYXNzaWduKCByZXN1bHROb2RlICk7XHJcblxyXG5cdFx0XHQvL1xyXG5cclxuXHRcdFx0aWYgKCB0aGlzLm91dHB1dE5vZGUgIT09IG51bGwgKSByZXN1bHROb2RlID0gdGhpcy5vdXRwdXROb2RlO1xyXG5cclxuXHRcdFx0Ly8gTVJUXHJcblxyXG5cdFx0XHRpZiAoIHJlbmRlclRhcmdldCAhPT0gbnVsbCApIHtcclxuXHJcblx0XHRcdFx0Y29uc3QgbXJ0ID0gcmVuZGVyZXIuZ2V0TVJUKCk7XHJcblx0XHRcdFx0Y29uc3QgbWF0ZXJpYWxNUlQgPSB0aGlzLm1ydE5vZGU7XHJcblxyXG5cdFx0XHRcdGlmICggbXJ0ICE9PSBudWxsICkge1xyXG5cclxuXHRcdFx0XHRcdHJlc3VsdE5vZGUgPSBtcnQ7XHJcblxyXG5cdFx0XHRcdFx0aWYgKCBtYXRlcmlhbE1SVCAhPT0gbnVsbCApIHtcclxuXHJcblx0XHRcdFx0XHRcdHJlc3VsdE5vZGUgPSBtcnQubWVyZ2UoIG1hdGVyaWFsTVJUICk7XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR9IGVsc2UgaWYgKCBtYXRlcmlhbE1SVCAhPT0gbnVsbCApIHtcclxuXHJcblx0XHRcdFx0XHRyZXN1bHROb2RlID0gbWF0ZXJpYWxNUlQ7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0bGV0IGZyYWdtZW50Tm9kZSA9IHRoaXMuZnJhZ21lbnROb2RlO1xyXG5cclxuXHRcdFx0aWYgKCBmcmFnbWVudE5vZGUuaXNPdXRwdXRTdHJ1Y3ROb2RlICE9PSB0cnVlICkge1xyXG5cclxuXHRcdFx0XHRmcmFnbWVudE5vZGUgPSB2ZWM0KCBmcmFnbWVudE5vZGUgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHJlc3VsdE5vZGUgPSB0aGlzLnNldHVwT3V0cHV0KCBidWlsZGVyLCBmcmFnbWVudE5vZGUgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0YnVpbGRlci5zdGFjay5vdXRwdXROb2RlID0gcmVzdWx0Tm9kZTtcclxuXHJcblx0XHRidWlsZGVyLmFkZEZsb3coICdmcmFnbWVudCcsIGJ1aWxkZXIucmVtb3ZlU3RhY2soKSApO1xyXG5cclxuXHRcdC8vIDwgTU9OSVRPUiA+XHJcblxyXG5cdFx0YnVpbGRlci5tb25pdG9yID0gdGhpcy5zZXR1cE9ic2VydmVyKCBidWlsZGVyICk7XHJcblxyXG5cdH1cclxuXHJcblx0c2V0dXBDbGlwcGluZyggYnVpbGRlciApIHtcclxuXHJcblx0XHRpZiAoIGJ1aWxkZXIuY2xpcHBpbmdDb250ZXh0ID09PSBudWxsICkgcmV0dXJuIG51bGw7XHJcblxyXG5cdFx0Y29uc3QgeyB1bmlvblBsYW5lcywgaW50ZXJzZWN0aW9uUGxhbmVzIH0gPSBidWlsZGVyLmNsaXBwaW5nQ29udGV4dDtcclxuXHJcblx0XHRsZXQgcmVzdWx0ID0gbnVsbDtcclxuXHJcblx0XHRpZiAoIHVuaW9uUGxhbmVzLmxlbmd0aCA+IDAgfHwgaW50ZXJzZWN0aW9uUGxhbmVzLmxlbmd0aCA+IDAgKSB7XHJcblxyXG5cdFx0XHRjb25zdCBzYW1wbGVzID0gYnVpbGRlci5yZW5kZXJlci5zYW1wbGVzO1xyXG5cclxuXHRcdFx0aWYgKCB0aGlzLmFscGhhVG9Db3ZlcmFnZSAmJiBzYW1wbGVzID4gMSApIHtcclxuXHJcblx0XHRcdFx0Ly8gdG8gYmUgYWRkZWQgdG8gZmxvdyB3aGVuIHRoZSBjb2xvci9hbHBoYSB2YWx1ZSBoYXMgYmVlbiBkZXRlcm1pbmVkXHJcblx0XHRcdFx0cmVzdWx0ID0gY2xpcHBpbmdBbHBoYSgpO1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0YnVpbGRlci5zdGFjay5hZGQoIGNsaXBwaW5nKCkgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHJlc3VsdDtcclxuXHJcblx0fVxyXG5cclxuXHRzZXR1cEhhcmR3YXJlQ2xpcHBpbmcoIGJ1aWxkZXIgKSB7XHJcblxyXG5cdFx0dGhpcy5oYXJkd2FyZUNsaXBwaW5nID0gZmFsc2U7XHJcblxyXG5cdFx0aWYgKCBidWlsZGVyLmNsaXBwaW5nQ29udGV4dCA9PT0gbnVsbCApIHJldHVybjtcclxuXHJcblx0XHRjb25zdCBjYW5kaWRhdGVDb3VudCA9IGJ1aWxkZXIuY2xpcHBpbmdDb250ZXh0LnVuaW9uUGxhbmVzLmxlbmd0aDtcclxuXHJcblx0XHQvLyA4IHBsYW5lcyBzdXBwb3J0ZWQgYnkgV2ViR0wgQU5HTEVfY2xpcF9jdWxsX2Rpc3RhbmNlIGFuZCBXZWJHUFUgY2xpcC1kaXN0YW5jZXNcclxuXHJcblx0XHRpZiAoIGNhbmRpZGF0ZUNvdW50ID4gMCAmJiBjYW5kaWRhdGVDb3VudCA8PSA4ICYmIGJ1aWxkZXIuaXNBdmFpbGFibGUoICdjbGlwRGlzdGFuY2UnICkgKSB7XHJcblxyXG5cdFx0XHRidWlsZGVyLnN0YWNrLmFkZCggaGFyZHdhcmVDbGlwcGluZygpICk7XHJcblxyXG5cdFx0XHR0aGlzLmhhcmR3YXJlQ2xpcHBpbmcgPSB0cnVlO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm47XHJcblxyXG5cdH1cclxuXHJcblx0c2V0dXBEZXB0aCggYnVpbGRlciApIHtcclxuXHJcblx0XHRjb25zdCB7IHJlbmRlcmVyLCBjYW1lcmEgfSA9IGJ1aWxkZXI7XHJcblxyXG5cdFx0Ly8gRGVwdGhcclxuXHJcblx0XHRsZXQgZGVwdGhOb2RlID0gdGhpcy5kZXB0aE5vZGU7XHJcblxyXG5cdFx0aWYgKCBkZXB0aE5vZGUgPT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHRjb25zdCBtcnQgPSByZW5kZXJlci5nZXRNUlQoKTtcclxuXHJcblx0XHRcdGlmICggbXJ0ICYmIG1ydC5oYXMoICdkZXB0aCcgKSApIHtcclxuXHJcblx0XHRcdFx0ZGVwdGhOb2RlID0gbXJ0LmdldCggJ2RlcHRoJyApO1xyXG5cclxuXHRcdFx0fSBlbHNlIGlmICggcmVuZGVyZXIubG9nYXJpdGhtaWNEZXB0aEJ1ZmZlciA9PT0gdHJ1ZSApIHtcclxuXHJcblx0XHRcdFx0aWYgKCBjYW1lcmEuaXNQZXJzcGVjdGl2ZUNhbWVyYSApIHtcclxuXHJcblx0XHRcdFx0XHRkZXB0aE5vZGUgPSB2aWV3WlRvTG9nYXJpdGhtaWNEZXB0aCggcG9zaXRpb25WaWV3LnosIGNhbWVyYU5lYXIsIGNhbWVyYUZhciApO1xyXG5cclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdGRlcHRoTm9kZSA9IHZpZXdaVG9PcnRob2dyYXBoaWNEZXB0aCggcG9zaXRpb25WaWV3LnosIGNhbWVyYU5lYXIsIGNhbWVyYUZhciApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggZGVwdGhOb2RlICE9PSBudWxsICkge1xyXG5cclxuXHRcdFx0ZGVwdGguYXNzaWduKCBkZXB0aE5vZGUgKS5hcHBlbmQoKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0c2V0dXBQb3NpdGlvblZpZXcoKSB7XHJcblxyXG5cdFx0cmV0dXJuIG1vZGVsVmlld01hdHJpeC5tdWwoIHBvc2l0aW9uTG9jYWwgKS54eXo7XHJcblxyXG5cdH1cclxuXHJcblx0c2V0dXBWZXJ0ZXgoIGJ1aWxkZXIgKSB7XHJcblxyXG5cdFx0YnVpbGRlci5hZGRTdGFjaygpO1xyXG5cclxuXHRcdHRoaXMuc2V0dXBQb3NpdGlvbiggYnVpbGRlciApO1xyXG5cclxuXHRcdGJ1aWxkZXIuY29udGV4dC52ZXJ0ZXggPSBidWlsZGVyLnJlbW92ZVN0YWNrKCk7XHJcblxyXG5cdFx0cmV0dXJuIG1vZGVsVmlld1Byb2plY3Rpb247XHJcblxyXG5cdH1cclxuXHJcblx0c2V0dXBQb3NpdGlvbiggYnVpbGRlciApIHtcclxuXHJcblx0XHRjb25zdCB7IG9iamVjdCwgZ2VvbWV0cnkgfSA9IGJ1aWxkZXI7XHJcblxyXG5cdFx0aWYgKCBnZW9tZXRyeS5tb3JwaEF0dHJpYnV0ZXMucG9zaXRpb24gfHwgZ2VvbWV0cnkubW9ycGhBdHRyaWJ1dGVzLm5vcm1hbCB8fCBnZW9tZXRyeS5tb3JwaEF0dHJpYnV0ZXMuY29sb3IgKSB7XHJcblxyXG5cdFx0XHRtb3JwaFJlZmVyZW5jZSggb2JqZWN0ICkuYXBwZW5kKCk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggb2JqZWN0LmlzU2tpbm5lZE1lc2ggPT09IHRydWUgKSB7XHJcblxyXG5cdFx0XHRza2lubmluZ1JlZmVyZW5jZSggb2JqZWN0ICkuYXBwZW5kKCk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggdGhpcy5kaXNwbGFjZW1lbnRNYXAgKSB7XHJcblxyXG5cdFx0XHRjb25zdCBkaXNwbGFjZW1lbnRNYXAgPSBtYXRlcmlhbFJlZmVyZW5jZSggJ2Rpc3BsYWNlbWVudE1hcCcsICd0ZXh0dXJlJyApO1xyXG5cdFx0XHRjb25zdCBkaXNwbGFjZW1lbnRTY2FsZSA9IG1hdGVyaWFsUmVmZXJlbmNlKCAnZGlzcGxhY2VtZW50U2NhbGUnLCAnZmxvYXQnICk7XHJcblx0XHRcdGNvbnN0IGRpc3BsYWNlbWVudEJpYXMgPSBtYXRlcmlhbFJlZmVyZW5jZSggJ2Rpc3BsYWNlbWVudEJpYXMnLCAnZmxvYXQnICk7XHJcblxyXG5cdFx0XHRwb3NpdGlvbkxvY2FsLmFkZEFzc2lnbiggbm9ybWFsTG9jYWwubm9ybWFsaXplKCkubXVsKCAoIGRpc3BsYWNlbWVudE1hcC54Lm11bCggZGlzcGxhY2VtZW50U2NhbGUgKS5hZGQoIGRpc3BsYWNlbWVudEJpYXMgKSApICkgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBvYmplY3QuaXNCYXRjaGVkTWVzaCApIHtcclxuXHJcblx0XHRcdGJhdGNoKCBvYmplY3QgKS5hcHBlbmQoKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCAoIG9iamVjdC5pc0luc3RhbmNlZE1lc2ggJiYgb2JqZWN0Lmluc3RhbmNlTWF0cml4ICYmIG9iamVjdC5pbnN0YW5jZU1hdHJpeC5pc0luc3RhbmNlZEJ1ZmZlckF0dHJpYnV0ZSA9PT0gdHJ1ZSApICkge1xyXG5cclxuXHRcdFx0aW5zdGFuY2VkTWVzaCggb2JqZWN0ICkuYXBwZW5kKCk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggdGhpcy5wb3NpdGlvbk5vZGUgIT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHRwb3NpdGlvbkxvY2FsLmFzc2lnbiggdGhpcy5wb3NpdGlvbk5vZGUuY29udGV4dCggeyBpc1Bvc2l0aW9uTm9kZUlucHV0OiB0cnVlIH0gKSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gcG9zaXRpb25Mb2NhbDtcclxuXHJcblx0fVxyXG5cclxuXHRzZXR1cERpZmZ1c2VDb2xvciggeyBvYmplY3QsIGdlb21ldHJ5IH0gKSB7XHJcblxyXG5cdFx0bGV0IGNvbG9yTm9kZSA9IHRoaXMuY29sb3JOb2RlID8gdmVjNCggdGhpcy5jb2xvck5vZGUgKSA6IG1hdGVyaWFsQ29sb3I7XHJcblxyXG5cdFx0Ly8gVkVSVEVYIENPTE9SU1xyXG5cclxuXHRcdGlmICggdGhpcy52ZXJ0ZXhDb2xvcnMgPT09IHRydWUgJiYgZ2VvbWV0cnkuaGFzQXR0cmlidXRlKCAnY29sb3InICkgKSB7XHJcblxyXG5cdFx0XHRjb2xvck5vZGUgPSB2ZWM0KCBjb2xvck5vZGUueHl6Lm11bCggYXR0cmlidXRlKCAnY29sb3InLCAndmVjMycgKSApLCBjb2xvck5vZGUuYSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvLyBJbnN0YW5jZWQgY29sb3JzXHJcblxyXG5cdFx0aWYgKCBvYmplY3QuaW5zdGFuY2VDb2xvciApIHtcclxuXHJcblx0XHRcdGNvbnN0IGluc3RhbmNlQ29sb3IgPSB2YXJ5aW5nUHJvcGVydHkoICd2ZWMzJywgJ3ZJbnN0YW5jZUNvbG9yJyApO1xyXG5cclxuXHRcdFx0Y29sb3JOb2RlID0gaW5zdGFuY2VDb2xvci5tdWwoIGNvbG9yTm9kZSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIG9iamVjdC5pc0JhdGNoZWRNZXNoICYmIG9iamVjdC5fY29sb3JzVGV4dHVyZSApIHtcclxuXHJcblx0XHRcdGNvbnN0IGJhdGNoQ29sb3IgPSB2YXJ5aW5nUHJvcGVydHkoICd2ZWMzJywgJ3ZCYXRjaENvbG9yJyApO1xyXG5cclxuXHRcdFx0Y29sb3JOb2RlID0gYmF0Y2hDb2xvci5tdWwoIGNvbG9yTm9kZSApO1xyXG5cclxuXHRcdH1cclxuXHJcblxyXG5cdFx0Ly8gQ09MT1JcclxuXHJcblx0XHRkaWZmdXNlQ29sb3IuYXNzaWduKCBjb2xvck5vZGUgKTtcclxuXHJcblx0XHQvLyBPUEFDSVRZXHJcblxyXG5cdFx0Y29uc3Qgb3BhY2l0eU5vZGUgPSB0aGlzLm9wYWNpdHlOb2RlID8gZmxvYXQoIHRoaXMub3BhY2l0eU5vZGUgKSA6IG1hdGVyaWFsT3BhY2l0eTtcclxuXHRcdGRpZmZ1c2VDb2xvci5hLmFzc2lnbiggZGlmZnVzZUNvbG9yLmEubXVsKCBvcGFjaXR5Tm9kZSApICk7XHJcblxyXG5cdFx0Ly8gQUxQSEEgVEVTVFxyXG5cclxuXHRcdGlmICggdGhpcy5hbHBoYVRlc3ROb2RlICE9PSBudWxsIHx8IHRoaXMuYWxwaGFUZXN0ID4gMCApIHtcclxuXHJcblx0XHRcdGNvbnN0IGFscGhhVGVzdE5vZGUgPSB0aGlzLmFscGhhVGVzdE5vZGUgIT09IG51bGwgPyBmbG9hdCggdGhpcy5hbHBoYVRlc3ROb2RlICkgOiBtYXRlcmlhbEFscGhhVGVzdDtcclxuXHJcblx0XHRcdGRpZmZ1c2VDb2xvci5hLmxlc3NUaGFuRXF1YWwoIGFscGhhVGVzdE5vZGUgKS5kaXNjYXJkKCk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIEFMUEhBIEhBU0hcclxuXHJcblx0XHRpZiAoIHRoaXMuYWxwaGFIYXNoID09PSB0cnVlICkge1xyXG5cclxuXHRcdFx0ZGlmZnVzZUNvbG9yLmEubGVzc1RoYW4oIGdldEFscGhhSGFzaFRocmVzaG9sZCggcG9zaXRpb25Mb2NhbCApICkuZGlzY2FyZCgpO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIHRoaXMudHJhbnNwYXJlbnQgPT09IGZhbHNlICYmIHRoaXMuYmxlbmRpbmcgPT09IE5vcm1hbEJsZW5kaW5nICYmIHRoaXMuYWxwaGFUb0NvdmVyYWdlID09PSBmYWxzZSApIHtcclxuXHJcblx0XHRcdGRpZmZ1c2VDb2xvci5hLmFzc2lnbiggMS4wICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdHNldHVwVmFyaWFudHMoIC8qYnVpbGRlciovICkge1xyXG5cclxuXHRcdC8vIEludGVyZmFjZSBmdW5jdGlvbi5cclxuXHJcblx0fVxyXG5cclxuXHRzZXR1cE91dGdvaW5nTGlnaHQoKSB7XHJcblxyXG5cdFx0cmV0dXJuICggdGhpcy5saWdodHMgPT09IHRydWUgKSA/IHZlYzMoIDAgKSA6IGRpZmZ1c2VDb2xvci5yZ2I7XHJcblxyXG5cdH1cclxuXHJcblx0c2V0dXBOb3JtYWwoKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMubm9ybWFsTm9kZSA/IHZlYzMoIHRoaXMubm9ybWFsTm9kZSApIDogbWF0ZXJpYWxOb3JtYWw7XHJcblxyXG5cdH1cclxuXHJcblx0c2V0dXBFbnZpcm9ubWVudCggLypidWlsZGVyKi8gKSB7XHJcblxyXG5cdFx0bGV0IG5vZGUgPSBudWxsO1xyXG5cclxuXHRcdGlmICggdGhpcy5lbnZOb2RlICkge1xyXG5cclxuXHRcdFx0bm9kZSA9IHRoaXMuZW52Tm9kZTtcclxuXHJcblx0XHR9IGVsc2UgaWYgKCB0aGlzLmVudk1hcCApIHtcclxuXHJcblx0XHRcdG5vZGUgPSB0aGlzLmVudk1hcC5pc0N1YmVUZXh0dXJlID8gbWF0ZXJpYWxSZWZlcmVuY2UoICdlbnZNYXAnLCAnY3ViZVRleHR1cmUnICkgOiBtYXRlcmlhbFJlZmVyZW5jZSggJ2Vudk1hcCcsICd0ZXh0dXJlJyApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gbm9kZTtcclxuXHJcblx0fVxyXG5cclxuXHRzZXR1cExpZ2h0TWFwKCBidWlsZGVyICkge1xyXG5cclxuXHRcdGxldCBub2RlID0gbnVsbDtcclxuXHJcblx0XHRpZiAoIGJ1aWxkZXIubWF0ZXJpYWwubGlnaHRNYXAgKSB7XHJcblxyXG5cdFx0XHRub2RlID0gbmV3IElycmFkaWFuY2VOb2RlKCBtYXRlcmlhbExpZ2h0TWFwICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBub2RlO1xyXG5cclxuXHR9XHJcblxyXG5cdHNldHVwTGlnaHRzKCBidWlsZGVyICkge1xyXG5cclxuXHRcdGNvbnN0IG1hdGVyaWFsTGlnaHRzTm9kZSA9IFtdO1xyXG5cclxuXHRcdC8vXHJcblxyXG5cdFx0Y29uc3QgZW52Tm9kZSA9IHRoaXMuc2V0dXBFbnZpcm9ubWVudCggYnVpbGRlciApO1xyXG5cclxuXHRcdGlmICggZW52Tm9kZSAmJiBlbnZOb2RlLmlzTGlnaHRpbmdOb2RlICkge1xyXG5cclxuXHRcdFx0bWF0ZXJpYWxMaWdodHNOb2RlLnB1c2goIGVudk5vZGUgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Y29uc3QgbGlnaHRNYXBOb2RlID0gdGhpcy5zZXR1cExpZ2h0TWFwKCBidWlsZGVyICk7XHJcblxyXG5cdFx0aWYgKCBsaWdodE1hcE5vZGUgJiYgbGlnaHRNYXBOb2RlLmlzTGlnaHRpbmdOb2RlICkge1xyXG5cclxuXHRcdFx0bWF0ZXJpYWxMaWdodHNOb2RlLnB1c2goIGxpZ2h0TWFwTm9kZSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIHRoaXMuYW9Ob2RlICE9PSBudWxsIHx8IGJ1aWxkZXIubWF0ZXJpYWwuYW9NYXAgKSB7XHJcblxyXG5cdFx0XHRjb25zdCBhb05vZGUgPSB0aGlzLmFvTm9kZSAhPT0gbnVsbCA/IHRoaXMuYW9Ob2RlIDogbWF0ZXJpYWxBT01hcDtcclxuXHJcblx0XHRcdG1hdGVyaWFsTGlnaHRzTm9kZS5wdXNoKCBuZXcgQU9Ob2RlKCBhb05vZGUgKSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRsZXQgbGlnaHRzTiA9IHRoaXMubGlnaHRzTm9kZSB8fCBidWlsZGVyLmxpZ2h0c05vZGU7XHJcblxyXG5cdFx0aWYgKCBtYXRlcmlhbExpZ2h0c05vZGUubGVuZ3RoID4gMCApIHtcclxuXHJcblx0XHRcdGxpZ2h0c04gPSBidWlsZGVyLnJlbmRlcmVyLmxpZ2h0aW5nLmNyZWF0ZU5vZGUoIFsgLi4ubGlnaHRzTi5nZXRMaWdodHMoKSwgLi4ubWF0ZXJpYWxMaWdodHNOb2RlIF0gKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGxpZ2h0c047XHJcblxyXG5cdH1cclxuXHJcblx0c2V0dXBMaWdodGluZ01vZGVsKCAvKmJ1aWxkZXIqLyApIHtcclxuXHJcblx0XHQvLyBJbnRlcmZhY2UgZnVuY3Rpb24uXHJcblxyXG5cdH1cclxuXHJcblx0c2V0dXBMaWdodGluZyggYnVpbGRlciApIHtcclxuXHJcblx0XHRjb25zdCB7IG1hdGVyaWFsIH0gPSBidWlsZGVyO1xyXG5cdFx0Y29uc3QgeyBiYWNrZHJvcE5vZGUsIGJhY2tkcm9wQWxwaGFOb2RlLCBlbWlzc2l2ZU5vZGUgfSA9IHRoaXM7XHJcblxyXG5cdFx0Ly8gT1VUR09JTkcgTElHSFRcclxuXHJcblx0XHRjb25zdCBsaWdodHMgPSB0aGlzLmxpZ2h0cyA9PT0gdHJ1ZSB8fCB0aGlzLmxpZ2h0c05vZGUgIT09IG51bGw7XHJcblxyXG5cdFx0Y29uc3QgbGlnaHRzTm9kZSA9IGxpZ2h0cyA/IHRoaXMuc2V0dXBMaWdodHMoIGJ1aWxkZXIgKSA6IG51bGw7XHJcblxyXG5cdFx0bGV0IG91dGdvaW5nTGlnaHROb2RlID0gdGhpcy5zZXR1cE91dGdvaW5nTGlnaHQoIGJ1aWxkZXIgKTtcclxuXHJcblx0XHRpZiAoIGxpZ2h0c05vZGUgJiYgbGlnaHRzTm9kZS5nZXRTY29wZSgpLmhhc0xpZ2h0cyApIHtcclxuXHJcblx0XHRcdGNvbnN0IGxpZ2h0aW5nTW9kZWwgPSB0aGlzLnNldHVwTGlnaHRpbmdNb2RlbCggYnVpbGRlciApO1xyXG5cclxuXHRcdFx0b3V0Z29pbmdMaWdodE5vZGUgPSBsaWdodGluZ0NvbnRleHQoIGxpZ2h0c05vZGUsIGxpZ2h0aW5nTW9kZWwsIGJhY2tkcm9wTm9kZSwgYmFja2Ryb3BBbHBoYU5vZGUgKTtcclxuXHJcblx0XHR9IGVsc2UgaWYgKCBiYWNrZHJvcE5vZGUgIT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHRvdXRnb2luZ0xpZ2h0Tm9kZSA9IHZlYzMoIGJhY2tkcm9wQWxwaGFOb2RlICE9PSBudWxsID8gbWl4KCBvdXRnb2luZ0xpZ2h0Tm9kZSwgYmFja2Ryb3BOb2RlLCBiYWNrZHJvcEFscGhhTm9kZSApIDogYmFja2Ryb3BOb2RlICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIEVNSVNTSVZFXHJcblxyXG5cdFx0aWYgKCAoIGVtaXNzaXZlTm9kZSAmJiBlbWlzc2l2ZU5vZGUuaXNOb2RlID09PSB0cnVlICkgfHwgKCBtYXRlcmlhbC5lbWlzc2l2ZSAmJiBtYXRlcmlhbC5lbWlzc2l2ZS5pc0NvbG9yID09PSB0cnVlICkgKSB7XHJcblxyXG5cdFx0XHRlbWlzc2l2ZS5hc3NpZ24oIHZlYzMoIGVtaXNzaXZlTm9kZSA/IGVtaXNzaXZlTm9kZSA6IG1hdGVyaWFsRW1pc3NpdmUgKSApO1xyXG5cclxuXHRcdFx0b3V0Z29pbmdMaWdodE5vZGUgPSBvdXRnb2luZ0xpZ2h0Tm9kZS5hZGQoIGVtaXNzaXZlICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBvdXRnb2luZ0xpZ2h0Tm9kZTtcclxuXHJcblx0fVxyXG5cclxuXHRzZXR1cE91dHB1dCggYnVpbGRlciwgb3V0cHV0Tm9kZSApIHtcclxuXHJcblx0XHQvLyBGT0dcclxuXHJcblx0XHRpZiAoIHRoaXMuZm9nID09PSB0cnVlICkge1xyXG5cclxuXHRcdFx0Y29uc3QgZm9nTm9kZSA9IGJ1aWxkZXIuZm9nTm9kZTtcclxuXHJcblx0XHRcdGlmICggZm9nTm9kZSApIHtcclxuXHJcblx0XHRcdFx0b3V0cHV0LmFzc2lnbiggb3V0cHV0Tm9kZSApO1xyXG5cclxuXHRcdFx0XHRvdXRwdXROb2RlID0gdmVjNCggZm9nTm9kZSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gb3V0cHV0Tm9kZTtcclxuXHJcblx0fVxyXG5cclxuXHRzZXREZWZhdWx0VmFsdWVzKCBtYXRlcmlhbCApIHtcclxuXHJcblx0XHQvLyBUaGlzIGFwcHJvYWNoIGlzIHRvIHJldXNlIHRoZSBuYXRpdmUgcmVmcmVzaFVuaWZvcm1zKlxyXG5cdFx0Ly8gYW5kIHR1cm4gYXZhaWxhYmxlIHRoZSB1c2Ugb2YgZmVhdHVyZXMgbGlrZSB0cmFuc21pc3Npb24gYW5kIGVudmlyb25tZW50IGluIGNvcmVcclxuXHJcblx0XHRmb3IgKCBjb25zdCBwcm9wZXJ0eSBpbiBtYXRlcmlhbCApIHtcclxuXHJcblx0XHRcdGNvbnN0IHZhbHVlID0gbWF0ZXJpYWxbIHByb3BlcnR5IF07XHJcblxyXG5cdFx0XHRpZiAoIHRoaXNbIHByb3BlcnR5IF0gPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0dGhpc1sgcHJvcGVydHkgXSA9IHZhbHVlO1xyXG5cclxuXHRcdFx0XHRpZiAoIHZhbHVlICYmIHZhbHVlLmNsb25lICkgdGhpc1sgcHJvcGVydHkgXSA9IHZhbHVlLmNsb25lKCk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGNvbnN0IGRlc2NyaXB0b3JzID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoIG1hdGVyaWFsLmNvbnN0cnVjdG9yLnByb3RvdHlwZSApO1xyXG5cclxuXHRcdGZvciAoIGNvbnN0IGtleSBpbiBkZXNjcmlwdG9ycyApIHtcclxuXHJcblx0XHRcdGlmICggT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvciggdGhpcy5jb25zdHJ1Y3Rvci5wcm90b3R5cGUsIGtleSApID09PSB1bmRlZmluZWQgJiZcclxuXHRcdFx0ICAgICBkZXNjcmlwdG9yc1sga2V5IF0uZ2V0ICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggdGhpcy5jb25zdHJ1Y3Rvci5wcm90b3R5cGUsIGtleSwgZGVzY3JpcHRvcnNbIGtleSBdICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdHRvSlNPTiggbWV0YSApIHtcclxuXHJcblx0XHRjb25zdCBpc1Jvb3QgPSAoIG1ldGEgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgbWV0YSA9PT0gJ3N0cmluZycgKTtcclxuXHJcblx0XHRpZiAoIGlzUm9vdCApIHtcclxuXHJcblx0XHRcdG1ldGEgPSB7XHJcblx0XHRcdFx0dGV4dHVyZXM6IHt9LFxyXG5cdFx0XHRcdGltYWdlczoge30sXHJcblx0XHRcdFx0bm9kZXM6IHt9XHJcblx0XHRcdH07XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGNvbnN0IGRhdGEgPSBNYXRlcmlhbC5wcm90b3R5cGUudG9KU09OLmNhbGwoIHRoaXMsIG1ldGEgKTtcclxuXHRcdGNvbnN0IG5vZGVDaGlsZHJlbiA9IGdldE5vZGVDaGlsZHJlbiggdGhpcyApO1xyXG5cclxuXHRcdGRhdGEuaW5wdXROb2RlcyA9IHt9O1xyXG5cclxuXHRcdGZvciAoIGNvbnN0IHsgcHJvcGVydHksIGNoaWxkTm9kZSB9IG9mIG5vZGVDaGlsZHJlbiApIHtcclxuXHJcblx0XHRcdGRhdGEuaW5wdXROb2Rlc1sgcHJvcGVydHkgXSA9IGNoaWxkTm9kZS50b0pTT04oIG1ldGEgKS51dWlkO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvLyBUT0RPOiBDb3BpZWQgZnJvbSBPYmplY3QzRC50b0pTT05cclxuXHJcblx0XHRmdW5jdGlvbiBleHRyYWN0RnJvbUNhY2hlKCBjYWNoZSApIHtcclxuXHJcblx0XHRcdGNvbnN0IHZhbHVlcyA9IFtdO1xyXG5cclxuXHRcdFx0Zm9yICggY29uc3Qga2V5IGluIGNhY2hlICkge1xyXG5cclxuXHRcdFx0XHRjb25zdCBkYXRhID0gY2FjaGVbIGtleSBdO1xyXG5cdFx0XHRcdGRlbGV0ZSBkYXRhLm1ldGFkYXRhO1xyXG5cdFx0XHRcdHZhbHVlcy5wdXNoKCBkYXRhICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRyZXR1cm4gdmFsdWVzO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIGlzUm9vdCApIHtcclxuXHJcblx0XHRcdGNvbnN0IHRleHR1cmVzID0gZXh0cmFjdEZyb21DYWNoZSggbWV0YS50ZXh0dXJlcyApO1xyXG5cdFx0XHRjb25zdCBpbWFnZXMgPSBleHRyYWN0RnJvbUNhY2hlKCBtZXRhLmltYWdlcyApO1xyXG5cdFx0XHRjb25zdCBub2RlcyA9IGV4dHJhY3RGcm9tQ2FjaGUoIG1ldGEubm9kZXMgKTtcclxuXHJcblx0XHRcdGlmICggdGV4dHVyZXMubGVuZ3RoID4gMCApIGRhdGEudGV4dHVyZXMgPSB0ZXh0dXJlcztcclxuXHRcdFx0aWYgKCBpbWFnZXMubGVuZ3RoID4gMCApIGRhdGEuaW1hZ2VzID0gaW1hZ2VzO1xyXG5cdFx0XHRpZiAoIG5vZGVzLmxlbmd0aCA+IDAgKSBkYXRhLm5vZGVzID0gbm9kZXM7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBkYXRhO1xyXG5cclxuXHR9XHJcblxyXG5cdGNvcHkoIHNvdXJjZSApIHtcclxuXHJcblx0XHR0aGlzLmxpZ2h0c05vZGUgPSBzb3VyY2UubGlnaHRzTm9kZTtcclxuXHRcdHRoaXMuZW52Tm9kZSA9IHNvdXJjZS5lbnZOb2RlO1xyXG5cclxuXHRcdHRoaXMuY29sb3JOb2RlID0gc291cmNlLmNvbG9yTm9kZTtcclxuXHRcdHRoaXMubm9ybWFsTm9kZSA9IHNvdXJjZS5ub3JtYWxOb2RlO1xyXG5cdFx0dGhpcy5vcGFjaXR5Tm9kZSA9IHNvdXJjZS5vcGFjaXR5Tm9kZTtcclxuXHRcdHRoaXMuYmFja2Ryb3BOb2RlID0gc291cmNlLmJhY2tkcm9wTm9kZTtcclxuXHRcdHRoaXMuYmFja2Ryb3BBbHBoYU5vZGUgPSBzb3VyY2UuYmFja2Ryb3BBbHBoYU5vZGU7XHJcblx0XHR0aGlzLmFscGhhVGVzdE5vZGUgPSBzb3VyY2UuYWxwaGFUZXN0Tm9kZTtcclxuXHJcblx0XHR0aGlzLnBvc2l0aW9uTm9kZSA9IHNvdXJjZS5wb3NpdGlvbk5vZGU7XHJcblx0XHR0aGlzLmdlb21ldHJ5Tm9kZSA9IHNvdXJjZS5nZW9tZXRyeU5vZGU7XHJcblxyXG5cdFx0dGhpcy5kZXB0aE5vZGUgPSBzb3VyY2UuZGVwdGhOb2RlO1xyXG5cdFx0dGhpcy5zaGFkb3dQb3NpdGlvbk5vZGUgPSBzb3VyY2Uuc2hhZG93UG9zaXRpb25Ob2RlO1xyXG5cdFx0dGhpcy5yZWNlaXZlZFNoYWRvd05vZGUgPSBzb3VyY2UucmVjZWl2ZWRTaGFkb3dOb2RlO1xyXG5cdFx0dGhpcy5jYXN0U2hhZG93Tm9kZSA9IHNvdXJjZS5jYXN0U2hhZG93Tm9kZTtcclxuXHJcblx0XHR0aGlzLm91dHB1dE5vZGUgPSBzb3VyY2Uub3V0cHV0Tm9kZTtcclxuXHRcdHRoaXMubXJ0Tm9kZSA9IHNvdXJjZS5tcnROb2RlO1xyXG5cclxuXHRcdHRoaXMuZnJhZ21lbnROb2RlID0gc291cmNlLmZyYWdtZW50Tm9kZTtcclxuXHRcdHRoaXMudmVydGV4Tm9kZSA9IHNvdXJjZS52ZXJ0ZXhOb2RlO1xyXG5cclxuXHRcdHJldHVybiBzdXBlci5jb3B5KCBzb3VyY2UgKTtcclxuXHJcblx0fVxyXG5cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgTm9kZU1hdGVyaWFsO1xyXG4iLCJpbXBvcnQgTm9kZU1hdGVyaWFsIGZyb20gJy4vTm9kZU1hdGVyaWFsLmpzJztcclxuaW1wb3J0IHsgYXR0cmlidXRlIH0gZnJvbSAnLi4vLi4vbm9kZXMvY29yZS9BdHRyaWJ1dGVOb2RlLmpzJztcclxuaW1wb3J0IHsgY2FtZXJhUHJvamVjdGlvbk1hdHJpeCB9IGZyb20gJy4uLy4uL25vZGVzL2FjY2Vzc29ycy9DYW1lcmEuanMnO1xyXG5pbXBvcnQgeyBtYXRlcmlhbENvbG9yLCBtYXRlcmlhbE9wYWNpdHksIG1hdGVyaWFsUG9pbnRXaWR0aCB9IGZyb20gJy4uLy4uL25vZGVzL2FjY2Vzc29ycy9NYXRlcmlhbE5vZGUuanMnOyAvLyBvciBzaG91bGQgdGhpcyBiZSBhIHByb3BlcnR5LCBpbnN0ZWFkP1xyXG5pbXBvcnQgeyBtb2RlbFZpZXdNYXRyaXggfSBmcm9tICcuLi8uLi9ub2Rlcy9hY2Nlc3NvcnMvTW9kZWxOb2RlLmpzJztcclxuaW1wb3J0IHsgcG9zaXRpb25HZW9tZXRyeSB9IGZyb20gJy4uLy4uL25vZGVzL2FjY2Vzc29ycy9Qb3NpdGlvbi5qcyc7XHJcbmltcG9ydCB7IHNtb290aHN0ZXAsIGxlbmd0aFNxIH0gZnJvbSAnLi4vLi4vbm9kZXMvbWF0aC9NYXRoTm9kZS5qcyc7XHJcbmltcG9ydCB7IEZuLCB2ZWM0LCBmbG9hdCB9IGZyb20gJy4uLy4uL25vZGVzL3RzbC9UU0xCYXNlLmpzJztcclxuaW1wb3J0IHsgdXYgfSBmcm9tICcuLi8uLi9ub2Rlcy9hY2Nlc3NvcnMvVVYuanMnO1xyXG5pbXBvcnQgeyB2aWV3cG9ydCB9IGZyb20gJy4uLy4uL25vZGVzL2Rpc3BsYXkvU2NyZWVuTm9kZS5qcyc7XHJcblxyXG5pbXBvcnQgeyBQb2ludHNNYXRlcmlhbCB9IGZyb20gJy4uL1BvaW50c01hdGVyaWFsLmpzJztcclxuXHJcbmNvbnN0IF9kZWZhdWx0VmFsdWVzID0gLypAX19QVVJFX18qLyBuZXcgUG9pbnRzTWF0ZXJpYWwoKTtcclxuXHJcbmNsYXNzIEluc3RhbmNlZFBvaW50c05vZGVNYXRlcmlhbCBleHRlbmRzIE5vZGVNYXRlcmlhbCB7XHJcblxyXG5cdHN0YXRpYyBnZXQgdHlwZSgpIHtcclxuXHJcblx0XHRyZXR1cm4gJ0luc3RhbmNlZFBvaW50c05vZGVNYXRlcmlhbCc7XHJcblxyXG5cdH1cclxuXHJcblx0Y29uc3RydWN0b3IoIHBhcmFtcyA9IHt9ICkge1xyXG5cclxuXHRcdHN1cGVyKCk7XHJcblxyXG5cdFx0dGhpcy5saWdodHMgPSBmYWxzZTtcclxuXHJcblx0XHR0aGlzLnVzZUFscGhhVG9Db3ZlcmFnZSA9IHRydWU7XHJcblxyXG5cdFx0dGhpcy51c2VDb2xvciA9IHBhcmFtcy52ZXJ0ZXhDb2xvcnM7XHJcblxyXG5cdFx0dGhpcy5wb2ludFdpZHRoID0gMTtcclxuXHJcblx0XHR0aGlzLnBvaW50Q29sb3JOb2RlID0gbnVsbDtcclxuXHJcblx0XHR0aGlzLnBvaW50V2lkdGhOb2RlID0gbnVsbDtcclxuXHJcblx0XHR0aGlzLnNldERlZmF1bHRWYWx1ZXMoIF9kZWZhdWx0VmFsdWVzICk7XHJcblxyXG5cdFx0dGhpcy5zZXRWYWx1ZXMoIHBhcmFtcyApO1xyXG5cclxuXHR9XHJcblxyXG5cdHNldHVwKCBidWlsZGVyICkge1xyXG5cclxuXHRcdHRoaXMuc2V0dXBTaGFkZXJzKCBidWlsZGVyICk7XHJcblxyXG5cdFx0c3VwZXIuc2V0dXAoIGJ1aWxkZXIgKTtcclxuXHJcblx0fVxyXG5cclxuXHRzZXR1cFNoYWRlcnMoIHsgcmVuZGVyZXIgfSApIHtcclxuXHJcblx0XHRjb25zdCB1c2VBbHBoYVRvQ292ZXJhZ2UgPSB0aGlzLmFscGhhVG9Db3ZlcmFnZTtcclxuXHRcdGNvbnN0IHVzZUNvbG9yID0gdGhpcy51c2VDb2xvcjtcclxuXHJcblx0XHR0aGlzLnZlcnRleE5vZGUgPSBGbiggKCkgPT4ge1xyXG5cclxuXHRcdFx0Y29uc3QgaW5zdGFuY2VQb3NpdGlvbiA9IGF0dHJpYnV0ZSggJ2luc3RhbmNlUG9zaXRpb24nICkueHl6O1xyXG5cclxuXHRcdFx0Ly8gY2FtZXJhIHNwYWNlXHJcblx0XHRcdGNvbnN0IG12UG9zID0gdmVjNCggbW9kZWxWaWV3TWF0cml4Lm11bCggdmVjNCggaW5zdGFuY2VQb3NpdGlvbiwgMS4wICkgKSApO1xyXG5cclxuXHRcdFx0Y29uc3QgYXNwZWN0ID0gdmlld3BvcnQuei5kaXYoIHZpZXdwb3J0LncgKTtcclxuXHJcblx0XHRcdC8vIGNsaXAgc3BhY2VcclxuXHRcdFx0Y29uc3QgY2xpcFBvcyA9IGNhbWVyYVByb2plY3Rpb25NYXRyaXgubXVsKCBtdlBvcyApO1xyXG5cclxuXHRcdFx0Ly8gb2Zmc2V0IGluIG5kYyBzcGFjZVxyXG5cdFx0XHRjb25zdCBvZmZzZXQgPSBwb3NpdGlvbkdlb21ldHJ5Lnh5LnRvVmFyKCk7XHJcblxyXG5cdFx0XHRvZmZzZXQubXVsQXNzaWduKCB0aGlzLnBvaW50V2lkdGhOb2RlID8gdGhpcy5wb2ludFdpZHRoTm9kZSA6IG1hdGVyaWFsUG9pbnRXaWR0aCApO1xyXG5cclxuXHRcdFx0b2Zmc2V0LmFzc2lnbiggb2Zmc2V0LmRpdiggdmlld3BvcnQueiApICk7XHJcblx0XHRcdG9mZnNldC55LmFzc2lnbiggb2Zmc2V0LnkubXVsKCBhc3BlY3QgKSApO1xyXG5cclxuXHRcdFx0Ly8gYmFjayB0byBjbGlwIHNwYWNlXHJcblx0XHRcdG9mZnNldC5hc3NpZ24oIG9mZnNldC5tdWwoIGNsaXBQb3MudyApICk7XHJcblxyXG5cdFx0XHQvL2NsaXBQb3MueHkgKz0gb2Zmc2V0O1xyXG5cdFx0XHRjbGlwUG9zLmFkZEFzc2lnbiggdmVjNCggb2Zmc2V0LCAwLCAwICkgKTtcclxuXHJcblx0XHRcdHJldHVybiBjbGlwUG9zO1xyXG5cclxuXHRcdH0gKSgpO1xyXG5cclxuXHRcdHRoaXMuZnJhZ21lbnROb2RlID0gRm4oICgpID0+IHtcclxuXHJcblx0XHRcdGNvbnN0IGFscGhhID0gZmxvYXQoIDEgKS50b1ZhcigpO1xyXG5cclxuXHRcdFx0Y29uc3QgbGVuMiA9IGxlbmd0aFNxKCB1digpLm11bCggMiApLnN1YiggMSApICk7XHJcblxyXG5cdFx0XHRpZiAoIHVzZUFscGhhVG9Db3ZlcmFnZSAmJiByZW5kZXJlci5zYW1wbGVzID4gMSApIHtcclxuXHJcblx0XHRcdFx0Y29uc3QgZGxlbiA9IGZsb2F0KCBsZW4yLmZ3aWR0aCgpICkudG9WYXIoKTtcclxuXHJcblx0XHRcdFx0YWxwaGEuYXNzaWduKCBzbW9vdGhzdGVwKCBkbGVuLm9uZU1pbnVzKCksIGRsZW4uYWRkKCAxICksIGxlbjIgKS5vbmVNaW51cygpICk7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRsZW4yLmdyZWF0ZXJUaGFuKCAxLjAgKS5kaXNjYXJkKCk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRsZXQgcG9pbnRDb2xvck5vZGU7XHJcblxyXG5cdFx0XHRpZiAoIHRoaXMucG9pbnRDb2xvck5vZGUgKSB7XHJcblxyXG5cdFx0XHRcdHBvaW50Q29sb3JOb2RlID0gdGhpcy5wb2ludENvbG9yTm9kZTtcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdGlmICggdXNlQ29sb3IgKSB7XHJcblxyXG5cdFx0XHRcdFx0Y29uc3QgaW5zdGFuY2VDb2xvciA9IGF0dHJpYnV0ZSggJ2luc3RhbmNlQ29sb3InICk7XHJcblxyXG5cdFx0XHRcdFx0cG9pbnRDb2xvck5vZGUgPSBpbnN0YW5jZUNvbG9yLm11bCggbWF0ZXJpYWxDb2xvciApO1xyXG5cclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdHBvaW50Q29sb3JOb2RlID0gbWF0ZXJpYWxDb2xvcjtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0YWxwaGEubXVsQXNzaWduKCBtYXRlcmlhbE9wYWNpdHkgKTtcclxuXHJcblx0XHRcdHJldHVybiB2ZWM0KCBwb2ludENvbG9yTm9kZSwgYWxwaGEgKTtcclxuXHJcblx0XHR9ICkoKTtcclxuXHJcblx0fVxyXG5cclxuXHRnZXQgYWxwaGFUb0NvdmVyYWdlKCkge1xyXG5cclxuXHRcdHJldHVybiB0aGlzLnVzZUFscGhhVG9Db3ZlcmFnZTtcclxuXHJcblx0fVxyXG5cclxuXHRzZXQgYWxwaGFUb0NvdmVyYWdlKCB2YWx1ZSApIHtcclxuXHJcblx0XHRpZiAoIHRoaXMudXNlQWxwaGFUb0NvdmVyYWdlICE9PSB2YWx1ZSApIHtcclxuXHJcblx0XHRcdHRoaXMudXNlQWxwaGFUb0NvdmVyYWdlID0gdmFsdWU7XHJcblx0XHRcdHRoaXMubmVlZHNVcGRhdGUgPSB0cnVlO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgSW5zdGFuY2VkUG9pbnRzTm9kZU1hdGVyaWFsO1xyXG4iLCJpbXBvcnQgTm9kZU1hdGVyaWFsIGZyb20gJy4vTm9kZU1hdGVyaWFsLmpzJztcclxuXHJcbmltcG9ydCB7IExpbmVCYXNpY01hdGVyaWFsIH0gZnJvbSAnLi4vTGluZUJhc2ljTWF0ZXJpYWwuanMnO1xyXG5cclxuY29uc3QgX2RlZmF1bHRWYWx1ZXMgPSAvKkBfX1BVUkVfXyovIG5ldyBMaW5lQmFzaWNNYXRlcmlhbCgpO1xyXG5cclxuY2xhc3MgTGluZUJhc2ljTm9kZU1hdGVyaWFsIGV4dGVuZHMgTm9kZU1hdGVyaWFsIHtcclxuXHJcblx0c3RhdGljIGdldCB0eXBlKCkge1xyXG5cclxuXHRcdHJldHVybiAnTGluZUJhc2ljTm9kZU1hdGVyaWFsJztcclxuXHJcblx0fVxyXG5cclxuXHRjb25zdHJ1Y3RvciggcGFyYW1ldGVycyApIHtcclxuXHJcblx0XHRzdXBlcigpO1xyXG5cclxuXHRcdHRoaXMuaXNMaW5lQmFzaWNOb2RlTWF0ZXJpYWwgPSB0cnVlO1xyXG5cclxuXHRcdHRoaXMubGlnaHRzID0gZmFsc2U7XHJcblxyXG5cdFx0dGhpcy5zZXREZWZhdWx0VmFsdWVzKCBfZGVmYXVsdFZhbHVlcyApO1xyXG5cclxuXHRcdHRoaXMuc2V0VmFsdWVzKCBwYXJhbWV0ZXJzICk7XHJcblxyXG5cdH1cclxuXHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IExpbmVCYXNpY05vZGVNYXRlcmlhbDtcclxuIiwiaW1wb3J0IE5vZGVNYXRlcmlhbCBmcm9tICcuL05vZGVNYXRlcmlhbC5qcyc7XHJcbmltcG9ydCB7IGF0dHJpYnV0ZSB9IGZyb20gJy4uLy4uL25vZGVzL2NvcmUvQXR0cmlidXRlTm9kZS5qcyc7XHJcbmltcG9ydCB7IG1hdGVyaWFsTGluZURhc2hPZmZzZXQsIG1hdGVyaWFsTGluZURhc2hTaXplLCBtYXRlcmlhbExpbmVHYXBTaXplLCBtYXRlcmlhbExpbmVTY2FsZSB9IGZyb20gJy4uLy4uL25vZGVzL2FjY2Vzc29ycy9NYXRlcmlhbE5vZGUuanMnO1xyXG5pbXBvcnQgeyBkYXNoU2l6ZSwgZ2FwU2l6ZSB9IGZyb20gJy4uLy4uL25vZGVzL2NvcmUvUHJvcGVydHlOb2RlLmpzJztcclxuaW1wb3J0IHsgdmFyeWluZywgZmxvYXQgfSBmcm9tICcuLi8uLi9ub2Rlcy90c2wvVFNMQmFzZS5qcyc7XHJcblxyXG5pbXBvcnQgeyBMaW5lRGFzaGVkTWF0ZXJpYWwgfSBmcm9tICcuLi9MaW5lRGFzaGVkTWF0ZXJpYWwuanMnO1xyXG5cclxuY29uc3QgX2RlZmF1bHRWYWx1ZXMgPSAvKkBfX1BVUkVfXyovIG5ldyBMaW5lRGFzaGVkTWF0ZXJpYWwoKTtcclxuXHJcbmNsYXNzIExpbmVEYXNoZWROb2RlTWF0ZXJpYWwgZXh0ZW5kcyBOb2RlTWF0ZXJpYWwge1xyXG5cclxuXHRzdGF0aWMgZ2V0IHR5cGUoKSB7XHJcblxyXG5cdFx0cmV0dXJuICdMaW5lRGFzaGVkTm9kZU1hdGVyaWFsJztcclxuXHJcblx0fVxyXG5cclxuXHRjb25zdHJ1Y3RvciggcGFyYW1ldGVycyApIHtcclxuXHJcblx0XHRzdXBlcigpO1xyXG5cclxuXHRcdHRoaXMuaXNMaW5lRGFzaGVkTm9kZU1hdGVyaWFsID0gdHJ1ZTtcclxuXHJcblx0XHR0aGlzLmxpZ2h0cyA9IGZhbHNlO1xyXG5cclxuXHRcdHRoaXMuc2V0RGVmYXVsdFZhbHVlcyggX2RlZmF1bHRWYWx1ZXMgKTtcclxuXHJcblx0XHR0aGlzLmRhc2hPZmZzZXQgPSAwO1xyXG5cclxuXHRcdHRoaXMub2Zmc2V0Tm9kZSA9IG51bGw7XHJcblx0XHR0aGlzLmRhc2hTY2FsZU5vZGUgPSBudWxsO1xyXG5cdFx0dGhpcy5kYXNoU2l6ZU5vZGUgPSBudWxsO1xyXG5cdFx0dGhpcy5nYXBTaXplTm9kZSA9IG51bGw7XHJcblxyXG5cdFx0dGhpcy5zZXRWYWx1ZXMoIHBhcmFtZXRlcnMgKTtcclxuXHJcblx0fVxyXG5cclxuXHRzZXR1cFZhcmlhbnRzKCkge1xyXG5cclxuXHRcdGNvbnN0IG9mZnNldE5vZGUgPSB0aGlzLm9mZnNldE5vZGUgPyBmbG9hdCggdGhpcy5vZmZzZXROb2RlTm9kZSApIDogbWF0ZXJpYWxMaW5lRGFzaE9mZnNldDtcclxuXHRcdGNvbnN0IGRhc2hTY2FsZU5vZGUgPSB0aGlzLmRhc2hTY2FsZU5vZGUgPyBmbG9hdCggdGhpcy5kYXNoU2NhbGVOb2RlICkgOiBtYXRlcmlhbExpbmVTY2FsZTtcclxuXHRcdGNvbnN0IGRhc2hTaXplTm9kZSA9IHRoaXMuZGFzaFNpemVOb2RlID8gZmxvYXQoIHRoaXMuZGFzaFNpemVOb2RlICkgOiBtYXRlcmlhbExpbmVEYXNoU2l6ZTtcclxuXHRcdGNvbnN0IGdhcFNpemVOb2RlID0gdGhpcy5kYXNoU2l6ZU5vZGUgPyBmbG9hdCggdGhpcy5kYXNoR2FwTm9kZSApIDogbWF0ZXJpYWxMaW5lR2FwU2l6ZTtcclxuXHJcblx0XHRkYXNoU2l6ZS5hc3NpZ24oIGRhc2hTaXplTm9kZSApO1xyXG5cdFx0Z2FwU2l6ZS5hc3NpZ24oIGdhcFNpemVOb2RlICk7XHJcblxyXG5cdFx0Y29uc3QgdkxpbmVEaXN0YW5jZSA9IHZhcnlpbmcoIGF0dHJpYnV0ZSggJ2xpbmVEaXN0YW5jZScgKS5tdWwoIGRhc2hTY2FsZU5vZGUgKSApO1xyXG5cdFx0Y29uc3QgdkxpbmVEaXN0YW5jZU9mZnNldCA9IG9mZnNldE5vZGUgPyB2TGluZURpc3RhbmNlLmFkZCggb2Zmc2V0Tm9kZSApIDogdkxpbmVEaXN0YW5jZTtcclxuXHJcblx0XHR2TGluZURpc3RhbmNlT2Zmc2V0Lm1vZCggZGFzaFNpemUuYWRkKCBnYXBTaXplICkgKS5ncmVhdGVyVGhhbiggZGFzaFNpemUgKS5kaXNjYXJkKCk7XHJcblxyXG5cdH1cclxuXHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IExpbmVEYXNoZWROb2RlTWF0ZXJpYWw7XHJcbiIsImltcG9ydCBWaWV3cG9ydFRleHR1cmVOb2RlIGZyb20gJy4vVmlld3BvcnRUZXh0dXJlTm9kZS5qcyc7XHJcbmltcG9ydCB7IG5vZGVQcm94eSB9IGZyb20gJy4uL3RzbC9UU0xCYXNlLmpzJztcclxuaW1wb3J0IHsgc2NyZWVuVVYgfSBmcm9tICcuL1NjcmVlbk5vZGUuanMnO1xyXG5cclxuaW1wb3J0IHsgRnJhbWVidWZmZXJUZXh0dXJlIH0gZnJvbSAnLi4vLi4vdGV4dHVyZXMvRnJhbWVidWZmZXJUZXh0dXJlLmpzJztcclxuXHJcbi8qKiBAbW9kdWxlIFZpZXdwb3J0U2hhcmVkVGV4dHVyZU5vZGUgKiovXHJcblxyXG5sZXQgX3NoYXJlZEZyYW1lYnVmZmVyID0gbnVsbDtcclxuXHJcbi8qKlxyXG4gKiBgVmlld3BvcnRUZXh0dXJlTm9kZWAgY3JlYXRlcyBhbiBpbnRlcm5hbCB0ZXh0dXJlIGZvciBlYWNoIG5vZGUgaW5zdGFuY2UuIFRoaXMgbW9kdWxlXHJcbiAqIHNoYXJlcyBhIHRleHR1cmUgYWNyb3NzIGFsbCBpbnN0YW5jZXMgb2YgYFZpZXdwb3J0U2hhcmVkVGV4dHVyZU5vZGVgLiBJdCBzaG91bGRcclxuICogYmUgdGhlIGZpcnN0IGNob2ljZSB3aGVuIHVzaW5nIGRhdGEgb2YgdGhlIGRlZmF1bHQvc2NyZWVuIGZyYW1lYnVmZmVyIGZvciBwZXJmb3JtYW5jZSByZWFzb25zLlxyXG4gKlxyXG4gKiBAYXVnbWVudHMgbW9kdWxlOlZpZXdwb3J0VGV4dHVyZU5vZGV+Vmlld3BvcnRUZXh0dXJlTm9kZVxyXG4gKi9cclxuY2xhc3MgVmlld3BvcnRTaGFyZWRUZXh0dXJlTm9kZSBleHRlbmRzIFZpZXdwb3J0VGV4dHVyZU5vZGUge1xyXG5cclxuXHRzdGF0aWMgZ2V0IHR5cGUoKSB7XHJcblxyXG5cdFx0cmV0dXJuICdWaWV3cG9ydFNoYXJlZFRleHR1cmVOb2RlJztcclxuXHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBDb25zdHJ1Y3RzIGEgbmV3IHZpZXdwb3J0IHNoYXJlZCB0ZXh0dXJlIG5vZGUuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge05vZGV9IFt1dk5vZGU9c2NyZWVuVVZdIC0gVGhlIHV2IG5vZGUuXHJcblx0ICogQHBhcmFtIHtOb2RlP30gW2xldmVsTm9kZT1udWxsXSAtIFRoZSBsZXZlbCBub2RlLlxyXG5cdCAqL1xyXG5cdGNvbnN0cnVjdG9yKCB1dk5vZGUgPSBzY3JlZW5VViwgbGV2ZWxOb2RlID0gbnVsbCApIHtcclxuXHJcblx0XHRpZiAoIF9zaGFyZWRGcmFtZWJ1ZmZlciA9PT0gbnVsbCApIHtcclxuXHJcblx0XHRcdF9zaGFyZWRGcmFtZWJ1ZmZlciA9IG5ldyBGcmFtZWJ1ZmZlclRleHR1cmUoKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0c3VwZXIoIHV2Tm9kZSwgbGV2ZWxOb2RlLCBfc2hhcmVkRnJhbWVidWZmZXIgKTtcclxuXHJcblx0fVxyXG5cclxuXHR1cGRhdGVSZWZlcmVuY2UoKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IFZpZXdwb3J0U2hhcmVkVGV4dHVyZU5vZGU7XHJcblxyXG4vKipcclxuICogVFNMIGZ1bmN0aW9uIGZvciBjcmVhdGluZyBhIHNoYXJlZCB2aWV3cG9ydCB0ZXh0dXJlIG5vZGUuXHJcbiAqXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0ge05vZGV9IFt1dk5vZGU9c2NyZWVuVVZdIC0gVGhlIHV2IG5vZGUuXHJcbiAqIEBwYXJhbSB7Tm9kZT99IFtsZXZlbE5vZGU9bnVsbF0gLSBUaGUgbGV2ZWwgbm9kZS5cclxuICogQHJldHVybnMge1ZpZXdwb3J0U2hhcmVkVGV4dHVyZU5vZGV9XHJcbiAqL1xyXG5leHBvcnQgY29uc3Qgdmlld3BvcnRTaGFyZWRUZXh0dXJlID0gLypAX19QVVJFX18qLyBub2RlUHJveHkoIFZpZXdwb3J0U2hhcmVkVGV4dHVyZU5vZGUgKTtcclxuIiwiaW1wb3J0IE5vZGVNYXRlcmlhbCBmcm9tICcuL05vZGVNYXRlcmlhbC5qcyc7XHJcbmltcG9ydCB7IGRhc2hTaXplLCBnYXBTaXplLCB2YXJ5aW5nUHJvcGVydHkgfSBmcm9tICcuLi8uLi9ub2Rlcy9jb3JlL1Byb3BlcnR5Tm9kZS5qcyc7XHJcbmltcG9ydCB7IGF0dHJpYnV0ZSB9IGZyb20gJy4uLy4uL25vZGVzL2NvcmUvQXR0cmlidXRlTm9kZS5qcyc7XHJcbmltcG9ydCB7IGNhbWVyYVByb2plY3Rpb25NYXRyaXggfSBmcm9tICcuLi8uLi9ub2Rlcy9hY2Nlc3NvcnMvQ2FtZXJhLmpzJztcclxuaW1wb3J0IHsgbWF0ZXJpYWxDb2xvciwgbWF0ZXJpYWxMaW5lU2NhbGUsIG1hdGVyaWFsTGluZURhc2hTaXplLCBtYXRlcmlhbExpbmVHYXBTaXplLCBtYXRlcmlhbExpbmVEYXNoT2Zmc2V0LCBtYXRlcmlhbExpbmVXaWR0aCwgbWF0ZXJpYWxPcGFjaXR5IH0gZnJvbSAnLi4vLi4vbm9kZXMvYWNjZXNzb3JzL01hdGVyaWFsTm9kZS5qcyc7XHJcbmltcG9ydCB7IG1vZGVsVmlld01hdHJpeCB9IGZyb20gJy4uLy4uL25vZGVzL2FjY2Vzc29ycy9Nb2RlbE5vZGUuanMnO1xyXG5pbXBvcnQgeyBwb3NpdGlvbkdlb21ldHJ5IH0gZnJvbSAnLi4vLi4vbm9kZXMvYWNjZXNzb3JzL1Bvc2l0aW9uLmpzJztcclxuaW1wb3J0IHsgbWl4LCBzbW9vdGhzdGVwIH0gZnJvbSAnLi4vLi4vbm9kZXMvbWF0aC9NYXRoTm9kZS5qcyc7XHJcbmltcG9ydCB7IEZuLCBmbG9hdCwgdmVjMiwgdmVjMywgdmVjNCwgSWYgfSBmcm9tICcuLi8uLi9ub2Rlcy90c2wvVFNMQmFzZS5qcyc7XHJcbmltcG9ydCB7IHV2IH0gZnJvbSAnLi4vLi4vbm9kZXMvYWNjZXNzb3JzL1VWLmpzJztcclxuaW1wb3J0IHsgdmlld3BvcnQgfSBmcm9tICcuLi8uLi9ub2Rlcy9kaXNwbGF5L1NjcmVlbk5vZGUuanMnO1xyXG5pbXBvcnQgeyB2aWV3cG9ydFNoYXJlZFRleHR1cmUgfSBmcm9tICcuLi8uLi9ub2Rlcy9kaXNwbGF5L1ZpZXdwb3J0U2hhcmVkVGV4dHVyZU5vZGUuanMnO1xyXG5cclxuaW1wb3J0IHsgTGluZURhc2hlZE1hdGVyaWFsIH0gZnJvbSAnLi4vTGluZURhc2hlZE1hdGVyaWFsLmpzJztcclxuaW1wb3J0IHsgTm9CbGVuZGluZyB9IGZyb20gJy4uLy4uL2NvbnN0YW50cy5qcyc7XHJcblxyXG5jb25zdCBfZGVmYXVsdFZhbHVlcyA9IC8qQF9fUFVSRV9fKi8gbmV3IExpbmVEYXNoZWRNYXRlcmlhbCgpO1xyXG5cclxuY2xhc3MgTGluZTJOb2RlTWF0ZXJpYWwgZXh0ZW5kcyBOb2RlTWF0ZXJpYWwge1xyXG5cclxuXHRzdGF0aWMgZ2V0IHR5cGUoKSB7XHJcblxyXG5cdFx0cmV0dXJuICdMaW5lMk5vZGVNYXRlcmlhbCc7XHJcblxyXG5cdH1cclxuXHJcblx0Y29uc3RydWN0b3IoIHBhcmFtcyA9IHt9ICkge1xyXG5cclxuXHRcdHN1cGVyKCk7XHJcblxyXG5cdFx0dGhpcy5saWdodHMgPSBmYWxzZTtcclxuXHJcblx0XHR0aGlzLnNldERlZmF1bHRWYWx1ZXMoIF9kZWZhdWx0VmFsdWVzICk7XHJcblxyXG5cdFx0dGhpcy51c2VBbHBoYVRvQ292ZXJhZ2UgPSB0cnVlO1xyXG5cdFx0dGhpcy51c2VDb2xvciA9IHBhcmFtcy52ZXJ0ZXhDb2xvcnM7XHJcblx0XHR0aGlzLnVzZURhc2ggPSBwYXJhbXMuZGFzaGVkO1xyXG5cdFx0dGhpcy51c2VXb3JsZFVuaXRzID0gZmFsc2U7XHJcblxyXG5cdFx0dGhpcy5kYXNoT2Zmc2V0ID0gMDtcclxuXHRcdHRoaXMubGluZVdpZHRoID0gMTtcclxuXHJcblx0XHR0aGlzLmxpbmVDb2xvck5vZGUgPSBudWxsO1xyXG5cclxuXHRcdHRoaXMub2Zmc2V0Tm9kZSA9IG51bGw7XHJcblx0XHR0aGlzLmRhc2hTY2FsZU5vZGUgPSBudWxsO1xyXG5cdFx0dGhpcy5kYXNoU2l6ZU5vZGUgPSBudWxsO1xyXG5cdFx0dGhpcy5nYXBTaXplTm9kZSA9IG51bGw7XHJcblxyXG5cdFx0dGhpcy5ibGVuZGluZyA9IE5vQmxlbmRpbmc7XHJcblxyXG5cdFx0dGhpcy5zZXRWYWx1ZXMoIHBhcmFtcyApO1xyXG5cclxuXHR9XHJcblxyXG5cdHNldHVwKCBidWlsZGVyICkge1xyXG5cclxuXHRcdHRoaXMuc2V0dXBTaGFkZXJzKCBidWlsZGVyICk7XHJcblxyXG5cdFx0c3VwZXIuc2V0dXAoIGJ1aWxkZXIgKTtcclxuXHJcblx0fVxyXG5cclxuXHRzZXR1cFNoYWRlcnMoIHsgcmVuZGVyZXIgfSApIHtcclxuXHJcblx0XHRjb25zdCB1c2VBbHBoYVRvQ292ZXJhZ2UgPSB0aGlzLmFscGhhVG9Db3ZlcmFnZTtcclxuXHRcdGNvbnN0IHVzZUNvbG9yID0gdGhpcy51c2VDb2xvcjtcclxuXHRcdGNvbnN0IHVzZURhc2ggPSB0aGlzLmRhc2hlZDtcclxuXHRcdGNvbnN0IHVzZVdvcmxkVW5pdHMgPSB0aGlzLndvcmxkVW5pdHM7XHJcblxyXG5cdFx0Y29uc3QgdHJpbVNlZ21lbnQgPSBGbiggKCB7IHN0YXJ0LCBlbmQgfSApID0+IHtcclxuXHJcblx0XHRcdGNvbnN0IGEgPSBjYW1lcmFQcm9qZWN0aW9uTWF0cml4LmVsZW1lbnQoIDIgKS5lbGVtZW50KCAyICk7IC8vIDNuZCBlbnRyeSBpbiAzdGggY29sdW1uXHJcblx0XHRcdGNvbnN0IGIgPSBjYW1lcmFQcm9qZWN0aW9uTWF0cml4LmVsZW1lbnQoIDMgKS5lbGVtZW50KCAyICk7IC8vIDNuZCBlbnRyeSBpbiA0dGggY29sdW1uXHJcblx0XHRcdGNvbnN0IG5lYXJFc3RpbWF0ZSA9IGIubXVsKCAtIDAuNSApLmRpdiggYSApO1xyXG5cclxuXHRcdFx0Y29uc3QgYWxwaGEgPSBuZWFyRXN0aW1hdGUuc3ViKCBzdGFydC56ICkuZGl2KCBlbmQuei5zdWIoIHN0YXJ0LnogKSApO1xyXG5cclxuXHRcdFx0cmV0dXJuIHZlYzQoIG1peCggc3RhcnQueHl6LCBlbmQueHl6LCBhbHBoYSApLCBlbmQudyApO1xyXG5cclxuXHRcdH0gKS5zZXRMYXlvdXQoIHtcclxuXHRcdFx0bmFtZTogJ3RyaW1TZWdtZW50JyxcclxuXHRcdFx0dHlwZTogJ3ZlYzQnLFxyXG5cdFx0XHRpbnB1dHM6IFtcclxuXHRcdFx0XHR7IG5hbWU6ICdzdGFydCcsIHR5cGU6ICd2ZWM0JyB9LFxyXG5cdFx0XHRcdHsgbmFtZTogJ2VuZCcsIHR5cGU6ICd2ZWM0JyB9XHJcblx0XHRcdF1cclxuXHRcdH0gKTtcclxuXHJcblx0XHR0aGlzLnZlcnRleE5vZGUgPSBGbiggKCkgPT4ge1xyXG5cclxuXHRcdFx0Y29uc3QgaW5zdGFuY2VTdGFydCA9IGF0dHJpYnV0ZSggJ2luc3RhbmNlU3RhcnQnICk7XHJcblx0XHRcdGNvbnN0IGluc3RhbmNlRW5kID0gYXR0cmlidXRlKCAnaW5zdGFuY2VFbmQnICk7XHJcblxyXG5cdFx0XHQvLyBjYW1lcmEgc3BhY2VcclxuXHJcblx0XHRcdGNvbnN0IHN0YXJ0ID0gdmVjNCggbW9kZWxWaWV3TWF0cml4Lm11bCggdmVjNCggaW5zdGFuY2VTdGFydCwgMS4wICkgKSApLnRvVmFyKCAnc3RhcnQnICk7XHJcblx0XHRcdGNvbnN0IGVuZCA9IHZlYzQoIG1vZGVsVmlld01hdHJpeC5tdWwoIHZlYzQoIGluc3RhbmNlRW5kLCAxLjAgKSApICkudG9WYXIoICdlbmQnICk7XHJcblxyXG5cdFx0XHRpZiAoIHVzZURhc2ggKSB7XHJcblxyXG5cdFx0XHRcdGNvbnN0IGRhc2hTY2FsZU5vZGUgPSB0aGlzLmRhc2hTY2FsZU5vZGUgPyBmbG9hdCggdGhpcy5kYXNoU2NhbGVOb2RlICkgOiBtYXRlcmlhbExpbmVTY2FsZTtcclxuXHRcdFx0XHRjb25zdCBvZmZzZXROb2RlID0gdGhpcy5vZmZzZXROb2RlID8gZmxvYXQoIHRoaXMub2Zmc2V0Tm9kZSApIDogbWF0ZXJpYWxMaW5lRGFzaE9mZnNldDtcclxuXHJcblx0XHRcdFx0Y29uc3QgaW5zdGFuY2VEaXN0YW5jZVN0YXJ0ID0gYXR0cmlidXRlKCAnaW5zdGFuY2VEaXN0YW5jZVN0YXJ0JyApO1xyXG5cdFx0XHRcdGNvbnN0IGluc3RhbmNlRGlzdGFuY2VFbmQgPSBhdHRyaWJ1dGUoICdpbnN0YW5jZURpc3RhbmNlRW5kJyApO1xyXG5cclxuXHRcdFx0XHRsZXQgbGluZURpc3RhbmNlID0gcG9zaXRpb25HZW9tZXRyeS55Lmxlc3NUaGFuKCAwLjUgKS5zZWxlY3QoIGRhc2hTY2FsZU5vZGUubXVsKCBpbnN0YW5jZURpc3RhbmNlU3RhcnQgKSwgZGFzaFNjYWxlTm9kZS5tdWwoIGluc3RhbmNlRGlzdGFuY2VFbmQgKSApO1xyXG5cdFx0XHRcdGxpbmVEaXN0YW5jZSA9IGxpbmVEaXN0YW5jZS5hZGQoIG9mZnNldE5vZGUgKTtcclxuXHJcblx0XHRcdFx0dmFyeWluZ1Byb3BlcnR5KCAnZmxvYXQnLCAnbGluZURpc3RhbmNlJyApLmFzc2lnbiggbGluZURpc3RhbmNlICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoIHVzZVdvcmxkVW5pdHMgKSB7XHJcblxyXG5cdFx0XHRcdHZhcnlpbmdQcm9wZXJ0eSggJ3ZlYzMnLCAnd29ybGRTdGFydCcgKS5hc3NpZ24oIHN0YXJ0Lnh5eiApO1xyXG5cdFx0XHRcdHZhcnlpbmdQcm9wZXJ0eSggJ3ZlYzMnLCAnd29ybGRFbmQnICkuYXNzaWduKCBlbmQueHl6ICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRjb25zdCBhc3BlY3QgPSB2aWV3cG9ydC56LmRpdiggdmlld3BvcnQudyApO1xyXG5cclxuXHRcdFx0Ly8gc3BlY2lhbCBjYXNlIGZvciBwZXJzcGVjdGl2ZSBwcm9qZWN0aW9uLCBhbmQgc2VnbWVudHMgdGhhdCB0ZXJtaW5hdGUgZWl0aGVyIGluLCBvciBiZWhpbmQsIHRoZSBjYW1lcmEgcGxhbmVcclxuXHRcdFx0Ly8gY2xlYXJseSB0aGUgZ3B1IGZpcm13YXJlIGhhcyBhIHdheSBvZiBhZGRyZXNzaW5nIHRoaXMgaXNzdWUgd2hlbiBwcm9qZWN0aW5nIGludG8gbmRjIHNwYWNlXHJcblx0XHRcdC8vIGJ1dCB3ZSBuZWVkIHRvIHBlcmZvcm0gbmRjLXNwYWNlIGNhbGN1bGF0aW9ucyBpbiB0aGUgc2hhZGVyLCBzbyB3ZSBtdXN0IGFkZHJlc3MgdGhpcyBpc3N1ZSBkaXJlY3RseVxyXG5cdFx0XHQvLyBwZXJoYXBzIHRoZXJlIGlzIGEgbW9yZSBlbGVnYW50IHNvbHV0aW9uIC0tIFdlc3RMYW5nbGV5XHJcblxyXG5cdFx0XHRjb25zdCBwZXJzcGVjdGl2ZSA9IGNhbWVyYVByb2plY3Rpb25NYXRyaXguZWxlbWVudCggMiApLmVsZW1lbnQoIDMgKS5lcXVhbCggLSAxLjAgKTsgLy8gNHRoIGVudHJ5IGluIHRoZSAzcmQgY29sdW1uXHJcblxyXG5cdFx0XHRJZiggcGVyc3BlY3RpdmUsICgpID0+IHtcclxuXHJcblx0XHRcdFx0SWYoIHN0YXJ0LnoubGVzc1RoYW4oIDAuMCApLmFuZCggZW5kLnouZ3JlYXRlclRoYW4oIDAuMCApICksICgpID0+IHtcclxuXHJcblx0XHRcdFx0XHRlbmQuYXNzaWduKCB0cmltU2VnbWVudCggeyBzdGFydDogc3RhcnQsIGVuZDogZW5kIH0gKSApO1xyXG5cclxuXHRcdFx0XHR9ICkuRWxzZUlmKCBlbmQuei5sZXNzVGhhbiggMC4wICkuYW5kKCBzdGFydC56LmdyZWF0ZXJUaGFuRXF1YWwoIDAuMCApICksICgpID0+IHtcclxuXHJcblx0XHRcdFx0XHRzdGFydC5hc3NpZ24oIHRyaW1TZWdtZW50KCB7IHN0YXJ0OiBlbmQsIGVuZDogc3RhcnQgfSApICk7XHJcblxyXG5cdFx0XHQgXHR9ICk7XHJcblxyXG5cdFx0XHR9ICk7XHJcblxyXG5cdFx0XHQvLyBjbGlwIHNwYWNlXHJcblx0XHRcdGNvbnN0IGNsaXBTdGFydCA9IGNhbWVyYVByb2plY3Rpb25NYXRyaXgubXVsKCBzdGFydCApO1xyXG5cdFx0XHRjb25zdCBjbGlwRW5kID0gY2FtZXJhUHJvamVjdGlvbk1hdHJpeC5tdWwoIGVuZCApO1xyXG5cclxuXHRcdFx0Ly8gbmRjIHNwYWNlXHJcblx0XHRcdGNvbnN0IG5kY1N0YXJ0ID0gY2xpcFN0YXJ0Lnh5ei5kaXYoIGNsaXBTdGFydC53ICk7XHJcblx0XHRcdGNvbnN0IG5kY0VuZCA9IGNsaXBFbmQueHl6LmRpdiggY2xpcEVuZC53ICk7XHJcblxyXG5cdFx0XHQvLyBkaXJlY3Rpb25cclxuXHRcdFx0Y29uc3QgZGlyID0gbmRjRW5kLnh5LnN1YiggbmRjU3RhcnQueHkgKS50b1ZhcigpO1xyXG5cclxuXHRcdFx0Ly8gYWNjb3VudCBmb3IgY2xpcC1zcGFjZSBhc3BlY3QgcmF0aW9cclxuXHRcdFx0ZGlyLnguYXNzaWduKCBkaXIueC5tdWwoIGFzcGVjdCApICk7XHJcblx0XHRcdGRpci5hc3NpZ24oIGRpci5ub3JtYWxpemUoKSApO1xyXG5cclxuXHRcdFx0Y29uc3QgY2xpcCA9IHZlYzQoKS50b1ZhcigpO1xyXG5cclxuXHRcdFx0aWYgKCB1c2VXb3JsZFVuaXRzICkge1xyXG5cclxuXHRcdFx0XHQvLyBnZXQgdGhlIG9mZnNldCBkaXJlY3Rpb24gYXMgcGVycGVuZGljdWxhciB0byB0aGUgdmlldyB2ZWN0b3JcclxuXHJcblx0XHRcdFx0Y29uc3Qgd29ybGREaXIgPSBlbmQueHl6LnN1Yiggc3RhcnQueHl6ICkubm9ybWFsaXplKCk7XHJcblx0XHRcdFx0Y29uc3QgdG1wRndkID0gbWl4KCBzdGFydC54eXosIGVuZC54eXosIDAuNSApLm5vcm1hbGl6ZSgpO1xyXG5cdFx0XHRcdGNvbnN0IHdvcmxkVXAgPSB3b3JsZERpci5jcm9zcyggdG1wRndkICkubm9ybWFsaXplKCk7XHJcblx0XHRcdFx0Y29uc3Qgd29ybGRGd2QgPSB3b3JsZERpci5jcm9zcyggd29ybGRVcCApO1xyXG5cclxuXHRcdFx0XHRjb25zdCB3b3JsZFBvcyA9IHZhcnlpbmdQcm9wZXJ0eSggJ3ZlYzQnLCAnd29ybGRQb3MnICk7XHJcblxyXG5cdFx0XHRcdHdvcmxkUG9zLmFzc2lnbiggcG9zaXRpb25HZW9tZXRyeS55Lmxlc3NUaGFuKCAwLjUgKS5zZWxlY3QoIHN0YXJ0LCBlbmQgKSApO1xyXG5cclxuXHRcdFx0XHQvLyBoZWlnaHQgb2Zmc2V0XHJcblx0XHRcdFx0Y29uc3QgaHcgPSBtYXRlcmlhbExpbmVXaWR0aC5tdWwoIDAuNSApO1xyXG5cdFx0XHRcdHdvcmxkUG9zLmFkZEFzc2lnbiggdmVjNCggcG9zaXRpb25HZW9tZXRyeS54Lmxlc3NUaGFuKCAwLjAgKS5zZWxlY3QoIHdvcmxkVXAubXVsKCBodyApLCB3b3JsZFVwLm11bCggaHcgKS5uZWdhdGUoKSApLCAwICkgKTtcclxuXHJcblx0XHRcdFx0Ly8gZG9uJ3QgZXh0ZW5kIHRoZSBsaW5lIGlmIHdlJ3JlIHJlbmRlcmluZyBkYXNoZXMgYmVjYXVzZSB3ZVxyXG5cdFx0XHRcdC8vIHdvbid0IGJlIHJlbmRlcmluZyB0aGUgZW5kY2Fwc1xyXG5cdFx0XHRcdGlmICggISB1c2VEYXNoICkge1xyXG5cclxuXHRcdFx0XHRcdC8vIGNhcCBleHRlbnNpb25cclxuXHRcdFx0XHRcdHdvcmxkUG9zLmFkZEFzc2lnbiggdmVjNCggcG9zaXRpb25HZW9tZXRyeS55Lmxlc3NUaGFuKCAwLjUgKS5zZWxlY3QoIHdvcmxkRGlyLm11bCggaHcgKS5uZWdhdGUoKSwgd29ybGREaXIubXVsKCBodyApICksIDAgKSApO1xyXG5cclxuXHRcdFx0XHRcdC8vIGFkZCB3aWR0aCB0byB0aGUgYm94XHJcblx0XHRcdFx0XHR3b3JsZFBvcy5hZGRBc3NpZ24oIHZlYzQoIHdvcmxkRndkLm11bCggaHcgKSwgMCApICk7XHJcblxyXG5cdFx0XHRcdFx0Ly8gZW5kY2Fwc1xyXG5cdFx0XHRcdFx0SWYoIHBvc2l0aW9uR2VvbWV0cnkueS5ncmVhdGVyVGhhbiggMS4wICkub3IoIHBvc2l0aW9uR2VvbWV0cnkueS5sZXNzVGhhbiggMC4wICkgKSwgKCkgPT4ge1xyXG5cclxuXHRcdFx0XHRcdFx0d29ybGRQb3Muc3ViQXNzaWduKCB2ZWM0KCB3b3JsZEZ3ZC5tdWwoIDIuMCApLm11bCggaHcgKSwgMCApICk7XHJcblxyXG5cdFx0XHRcdFx0fSApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdC8vIHByb2plY3QgdGhlIHdvcmxkcG9zXHJcblx0XHRcdFx0Y2xpcC5hc3NpZ24oIGNhbWVyYVByb2plY3Rpb25NYXRyaXgubXVsKCB3b3JsZFBvcyApICk7XHJcblxyXG5cdFx0XHRcdC8vIHNoaWZ0IHRoZSBkZXB0aCBvZiB0aGUgcHJvamVjdGVkIHBvaW50cyBzbyB0aGUgbGluZVxyXG5cdFx0XHRcdC8vIHNlZ21lbnRzIG92ZXJsYXAgbmVhdGx5XHJcblx0XHRcdFx0Y29uc3QgY2xpcFBvc2UgPSB2ZWMzKCkudG9WYXIoKTtcclxuXHJcblx0XHRcdFx0Y2xpcFBvc2UuYXNzaWduKCBwb3NpdGlvbkdlb21ldHJ5LnkubGVzc1RoYW4oIDAuNSApLnNlbGVjdCggbmRjU3RhcnQsIG5kY0VuZCApICk7XHJcblx0XHRcdFx0Y2xpcC56LmFzc2lnbiggY2xpcFBvc2Uuei5tdWwoIGNsaXAudyApICk7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRjb25zdCBvZmZzZXQgPSB2ZWMyKCBkaXIueSwgZGlyLngubmVnYXRlKCkgKS50b1ZhciggJ29mZnNldCcgKTtcclxuXHJcblx0XHRcdFx0Ly8gdW5kbyBhc3BlY3QgcmF0aW8gYWRqdXN0bWVudFxyXG5cdFx0XHRcdGRpci54LmFzc2lnbiggZGlyLnguZGl2KCBhc3BlY3QgKSApO1xyXG5cdFx0XHRcdG9mZnNldC54LmFzc2lnbiggb2Zmc2V0LnguZGl2KCBhc3BlY3QgKSApO1xyXG5cclxuXHRcdFx0XHQvLyBzaWduIGZsaXBcclxuXHRcdFx0XHRvZmZzZXQuYXNzaWduKCBwb3NpdGlvbkdlb21ldHJ5LngubGVzc1RoYW4oIDAuMCApLnNlbGVjdCggb2Zmc2V0Lm5lZ2F0ZSgpLCBvZmZzZXQgKSApO1xyXG5cclxuXHRcdFx0XHQvLyBlbmRjYXBzXHJcblx0XHRcdFx0SWYoIHBvc2l0aW9uR2VvbWV0cnkueS5sZXNzVGhhbiggMC4wICksICgpID0+IHtcclxuXHJcblx0XHRcdFx0XHRvZmZzZXQuYXNzaWduKCBvZmZzZXQuc3ViKCBkaXIgKSApO1xyXG5cclxuXHRcdFx0XHR9ICkuRWxzZUlmKCBwb3NpdGlvbkdlb21ldHJ5LnkuZ3JlYXRlclRoYW4oIDEuMCApLCAoKSA9PiB7XHJcblxyXG5cdFx0XHRcdFx0b2Zmc2V0LmFzc2lnbiggb2Zmc2V0LmFkZCggZGlyICkgKTtcclxuXHJcblx0XHRcdFx0fSApO1xyXG5cclxuXHRcdFx0XHQvLyBhZGp1c3QgZm9yIGxpbmV3aWR0aFxyXG5cdFx0XHRcdG9mZnNldC5hc3NpZ24oIG9mZnNldC5tdWwoIG1hdGVyaWFsTGluZVdpZHRoICkgKTtcclxuXHJcblx0XHRcdFx0Ly8gYWRqdXN0IGZvciBjbGlwLXNwYWNlIHRvIHNjcmVlbi1zcGFjZSBjb252ZXJzaW9uIC8vIG1heWJlIHJlc29sdXRpb24gc2hvdWxkIGJlIGJhc2VkIG9uIHZpZXdwb3J0IC4uLlxyXG5cdFx0XHRcdG9mZnNldC5hc3NpZ24oIG9mZnNldC5kaXYoIHZpZXdwb3J0LncgKSApO1xyXG5cclxuXHRcdFx0XHQvLyBzZWxlY3QgZW5kXHJcblx0XHRcdFx0Y2xpcC5hc3NpZ24oIHBvc2l0aW9uR2VvbWV0cnkueS5sZXNzVGhhbiggMC41ICkuc2VsZWN0KCBjbGlwU3RhcnQsIGNsaXBFbmQgKSApO1xyXG5cclxuXHRcdFx0XHQvLyBiYWNrIHRvIGNsaXAgc3BhY2VcclxuXHRcdFx0XHRvZmZzZXQuYXNzaWduKCBvZmZzZXQubXVsKCBjbGlwLncgKSApO1xyXG5cclxuXHRcdFx0XHRjbGlwLmFzc2lnbiggY2xpcC5hZGQoIHZlYzQoIG9mZnNldCwgMCwgMCApICkgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHJldHVybiBjbGlwO1xyXG5cclxuXHRcdH0gKSgpO1xyXG5cclxuXHRcdGNvbnN0IGNsb3Nlc3RMaW5lVG9MaW5lID0gRm4oICggeyBwMSwgcDIsIHAzLCBwNCB9ICkgPT4ge1xyXG5cclxuXHRcdFx0Y29uc3QgcDEzID0gcDEuc3ViKCBwMyApO1xyXG5cdFx0XHRjb25zdCBwNDMgPSBwNC5zdWIoIHAzICk7XHJcblxyXG5cdFx0XHRjb25zdCBwMjEgPSBwMi5zdWIoIHAxICk7XHJcblxyXG5cdFx0XHRjb25zdCBkMTM0MyA9IHAxMy5kb3QoIHA0MyApO1xyXG5cdFx0XHRjb25zdCBkNDMyMSA9IHA0My5kb3QoIHAyMSApO1xyXG5cdFx0XHRjb25zdCBkMTMyMSA9IHAxMy5kb3QoIHAyMSApO1xyXG5cdFx0XHRjb25zdCBkNDM0MyA9IHA0My5kb3QoIHA0MyApO1xyXG5cdFx0XHRjb25zdCBkMjEyMSA9IHAyMS5kb3QoIHAyMSApO1xyXG5cclxuXHRcdFx0Y29uc3QgZGVub20gPSBkMjEyMS5tdWwoIGQ0MzQzICkuc3ViKCBkNDMyMS5tdWwoIGQ0MzIxICkgKTtcclxuXHRcdFx0Y29uc3QgbnVtZXIgPSBkMTM0My5tdWwoIGQ0MzIxICkuc3ViKCBkMTMyMS5tdWwoIGQ0MzQzICkgKTtcclxuXHJcblx0XHRcdGNvbnN0IG11YSA9IG51bWVyLmRpdiggZGVub20gKS5jbGFtcCgpO1xyXG5cdFx0XHRjb25zdCBtdWIgPSBkMTM0My5hZGQoIGQ0MzIxLm11bCggbXVhICkgKS5kaXYoIGQ0MzQzICkuY2xhbXAoKTtcclxuXHJcblx0XHRcdHJldHVybiB2ZWMyKCBtdWEsIG11YiApO1xyXG5cclxuXHRcdH0gKTtcclxuXHJcblx0XHR0aGlzLmNvbG9yTm9kZSA9IEZuKCAoKSA9PiB7XHJcblxyXG5cdFx0XHRjb25zdCB2VXYgPSB1digpO1xyXG5cclxuXHRcdFx0aWYgKCB1c2VEYXNoICkge1xyXG5cclxuXHRcdFx0XHRjb25zdCBkYXNoU2l6ZU5vZGUgPSB0aGlzLmRhc2hTaXplTm9kZSA/IGZsb2F0KCB0aGlzLmRhc2hTaXplTm9kZSApIDogbWF0ZXJpYWxMaW5lRGFzaFNpemU7XHJcblx0XHRcdFx0Y29uc3QgZ2FwU2l6ZU5vZGUgPSB0aGlzLmdhcFNpemVOb2RlID8gZmxvYXQoIHRoaXMuZ2FwU2l6ZU5vZGUgKSA6IG1hdGVyaWFsTGluZUdhcFNpemU7XHJcblxyXG5cdFx0XHRcdGRhc2hTaXplLmFzc2lnbiggZGFzaFNpemVOb2RlICk7XHJcblx0XHRcdFx0Z2FwU2l6ZS5hc3NpZ24oIGdhcFNpemVOb2RlICk7XHJcblxyXG5cdFx0XHRcdGNvbnN0IHZMaW5lRGlzdGFuY2UgPSB2YXJ5aW5nUHJvcGVydHkoICdmbG9hdCcsICdsaW5lRGlzdGFuY2UnICk7XHJcblxyXG5cdFx0XHRcdHZVdi55Lmxlc3NUaGFuKCAtIDEuMCApLm9yKCB2VXYueS5ncmVhdGVyVGhhbiggMS4wICkgKS5kaXNjYXJkKCk7IC8vIGRpc2NhcmQgZW5kY2Fwc1xyXG5cdFx0XHRcdHZMaW5lRGlzdGFuY2UubW9kKCBkYXNoU2l6ZS5hZGQoIGdhcFNpemUgKSApLmdyZWF0ZXJUaGFuKCBkYXNoU2l6ZSApLmRpc2NhcmQoKTsgLy8gdG9kbyAtIEZJWFxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Y29uc3QgYWxwaGEgPSBmbG9hdCggMSApLnRvVmFyKCAnYWxwaGEnICk7XHJcblxyXG5cdFx0XHRpZiAoIHVzZVdvcmxkVW5pdHMgKSB7XHJcblxyXG5cdFx0XHRcdGNvbnN0IHdvcmxkU3RhcnQgPSB2YXJ5aW5nUHJvcGVydHkoICd2ZWMzJywgJ3dvcmxkU3RhcnQnICk7XHJcblx0XHRcdFx0Y29uc3Qgd29ybGRFbmQgPSB2YXJ5aW5nUHJvcGVydHkoICd2ZWMzJywgJ3dvcmxkRW5kJyApO1xyXG5cclxuXHRcdFx0XHQvLyBGaW5kIHRoZSBjbG9zZXN0IHBvaW50cyBvbiB0aGUgdmlldyByYXkgYW5kIHRoZSBsaW5lIHNlZ21lbnRcclxuXHRcdFx0XHRjb25zdCByYXlFbmQgPSB2YXJ5aW5nUHJvcGVydHkoICd2ZWM0JywgJ3dvcmxkUG9zJyApLnh5ei5ub3JtYWxpemUoKS5tdWwoIDFlNSApO1xyXG5cdFx0XHRcdGNvbnN0IGxpbmVEaXIgPSB3b3JsZEVuZC5zdWIoIHdvcmxkU3RhcnQgKTtcclxuXHRcdFx0XHRjb25zdCBwYXJhbXMgPSBjbG9zZXN0TGluZVRvTGluZSggeyBwMTogd29ybGRTdGFydCwgcDI6IHdvcmxkRW5kLCBwMzogdmVjMyggMC4wLCAwLjAsIDAuMCApLCBwNDogcmF5RW5kIH0gKTtcclxuXHJcblx0XHRcdFx0Y29uc3QgcDEgPSB3b3JsZFN0YXJ0LmFkZCggbGluZURpci5tdWwoIHBhcmFtcy54ICkgKTtcclxuXHRcdFx0XHRjb25zdCBwMiA9IHJheUVuZC5tdWwoIHBhcmFtcy55ICk7XHJcblx0XHRcdFx0Y29uc3QgZGVsdGEgPSBwMS5zdWIoIHAyICk7XHJcblx0XHRcdFx0Y29uc3QgbGVuID0gZGVsdGEubGVuZ3RoKCk7XHJcblx0XHRcdFx0Y29uc3Qgbm9ybSA9IGxlbi5kaXYoIG1hdGVyaWFsTGluZVdpZHRoICk7XHJcblxyXG5cdFx0XHRcdGlmICggISB1c2VEYXNoICkge1xyXG5cclxuXHRcdFx0XHRcdGlmICggdXNlQWxwaGFUb0NvdmVyYWdlICYmIHJlbmRlcmVyLnNhbXBsZXMgPiAxICkge1xyXG5cclxuXHRcdFx0XHRcdFx0Y29uc3QgZG5vcm0gPSBub3JtLmZ3aWR0aCgpO1xyXG5cdFx0XHRcdFx0XHRhbHBoYS5hc3NpZ24oIHNtb290aHN0ZXAoIGRub3JtLm5lZ2F0ZSgpLmFkZCggMC41ICksIGRub3JtLmFkZCggMC41ICksIG5vcm0gKS5vbmVNaW51cygpICk7XHJcblxyXG5cdFx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHRcdG5vcm0uZ3JlYXRlclRoYW4oIDAuNSApLmRpc2NhcmQoKTtcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdC8vIHJvdW5kIGVuZGNhcHNcclxuXHJcblx0XHRcdFx0aWYgKCB1c2VBbHBoYVRvQ292ZXJhZ2UgJiYgcmVuZGVyZXIuc2FtcGxlcyA+IDEgKSB7XHJcblxyXG5cdFx0XHRcdFx0Y29uc3QgYSA9IHZVdi54O1xyXG5cdFx0XHRcdFx0Y29uc3QgYiA9IHZVdi55LmdyZWF0ZXJUaGFuKCAwLjAgKS5zZWxlY3QoIHZVdi55LnN1YiggMS4wICksIHZVdi55LmFkZCggMS4wICkgKTtcclxuXHJcblx0XHRcdFx0XHRjb25zdCBsZW4yID0gYS5tdWwoIGEgKS5hZGQoIGIubXVsKCBiICkgKTtcclxuXHJcblx0XHRcdFx0XHRjb25zdCBkbGVuID0gZmxvYXQoIGxlbjIuZndpZHRoKCkgKS50b1ZhciggJ2RsZW4nICk7XHJcblxyXG5cdFx0XHRcdFx0SWYoIHZVdi55LmFicygpLmdyZWF0ZXJUaGFuKCAxLjAgKSwgKCkgPT4ge1xyXG5cclxuXHRcdFx0XHRcdFx0YWxwaGEuYXNzaWduKCBzbW9vdGhzdGVwKCBkbGVuLm9uZU1pbnVzKCksIGRsZW4uYWRkKCAxICksIGxlbjIgKS5vbmVNaW51cygpICk7XHJcblxyXG5cdFx0XHRcdFx0fSApO1xyXG5cclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdElmKCB2VXYueS5hYnMoKS5ncmVhdGVyVGhhbiggMS4wICksICgpID0+IHtcclxuXHJcblx0XHRcdFx0XHRcdGNvbnN0IGEgPSB2VXYueDtcclxuXHRcdFx0XHRcdFx0Y29uc3QgYiA9IHZVdi55LmdyZWF0ZXJUaGFuKCAwLjAgKS5zZWxlY3QoIHZVdi55LnN1YiggMS4wICksIHZVdi55LmFkZCggMS4wICkgKTtcclxuXHRcdFx0XHRcdFx0Y29uc3QgbGVuMiA9IGEubXVsKCBhICkuYWRkKCBiLm11bCggYiApICk7XHJcblxyXG5cdFx0XHRcdFx0XHRsZW4yLmdyZWF0ZXJUaGFuKCAxLjAgKS5kaXNjYXJkKCk7XHJcblxyXG5cdFx0XHRcdFx0fSApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRsZXQgbGluZUNvbG9yTm9kZTtcclxuXHJcblx0XHRcdGlmICggdGhpcy5saW5lQ29sb3JOb2RlICkge1xyXG5cclxuXHRcdFx0XHRsaW5lQ29sb3JOb2RlID0gdGhpcy5saW5lQ29sb3JOb2RlO1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0aWYgKCB1c2VDb2xvciApIHtcclxuXHJcblx0XHRcdFx0XHRjb25zdCBpbnN0YW5jZUNvbG9yU3RhcnQgPSBhdHRyaWJ1dGUoICdpbnN0YW5jZUNvbG9yU3RhcnQnICk7XHJcblx0XHRcdFx0XHRjb25zdCBpbnN0YW5jZUNvbG9yRW5kID0gYXR0cmlidXRlKCAnaW5zdGFuY2VDb2xvckVuZCcgKTtcclxuXHJcblx0XHRcdFx0XHRjb25zdCBpbnN0YW5jZUNvbG9yID0gcG9zaXRpb25HZW9tZXRyeS55Lmxlc3NUaGFuKCAwLjUgKS5zZWxlY3QoIGluc3RhbmNlQ29sb3JTdGFydCwgaW5zdGFuY2VDb2xvckVuZCApO1xyXG5cclxuXHRcdFx0XHRcdGxpbmVDb2xvck5vZGUgPSBpbnN0YW5jZUNvbG9yLm11bCggbWF0ZXJpYWxDb2xvciApO1xyXG5cclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdGxpbmVDb2xvck5vZGUgPSBtYXRlcmlhbENvbG9yO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRyZXR1cm4gdmVjNCggbGluZUNvbG9yTm9kZSwgYWxwaGEgKTtcclxuXHJcblx0XHR9ICkoKTtcclxuXHJcblx0XHRpZiAoIHRoaXMudHJhbnNwYXJlbnQgKSB7XHJcblxyXG5cdFx0XHRjb25zdCBvcGFjaXR5Tm9kZSA9IHRoaXMub3BhY2l0eU5vZGUgPyBmbG9hdCggdGhpcy5vcGFjaXR5Tm9kZSApIDogbWF0ZXJpYWxPcGFjaXR5O1xyXG5cclxuXHRcdFx0dGhpcy5vdXRwdXROb2RlID0gdmVjNCggdGhpcy5jb2xvck5vZGUucmdiLm11bCggb3BhY2l0eU5vZGUgKS5hZGQoIHZpZXdwb3J0U2hhcmVkVGV4dHVyZSgpLnJnYi5tdWwoIG9wYWNpdHlOb2RlLm9uZU1pbnVzKCkgKSApLCB0aGlzLmNvbG9yTm9kZS5hICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cclxuXHRnZXQgd29ybGRVbml0cygpIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy51c2VXb3JsZFVuaXRzO1xyXG5cclxuXHR9XHJcblxyXG5cdHNldCB3b3JsZFVuaXRzKCB2YWx1ZSApIHtcclxuXHJcblx0XHRpZiAoIHRoaXMudXNlV29ybGRVbml0cyAhPT0gdmFsdWUgKSB7XHJcblxyXG5cdFx0XHR0aGlzLnVzZVdvcmxkVW5pdHMgPSB2YWx1ZTtcclxuXHRcdFx0dGhpcy5uZWVkc1VwZGF0ZSA9IHRydWU7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cclxuXHRnZXQgZGFzaGVkKCkge1xyXG5cclxuXHRcdHJldHVybiB0aGlzLnVzZURhc2g7XHJcblxyXG5cdH1cclxuXHJcblx0c2V0IGRhc2hlZCggdmFsdWUgKSB7XHJcblxyXG5cdFx0aWYgKCB0aGlzLnVzZURhc2ggIT09IHZhbHVlICkge1xyXG5cclxuXHRcdFx0dGhpcy51c2VEYXNoID0gdmFsdWU7XHJcblx0XHRcdHRoaXMubmVlZHNVcGRhdGUgPSB0cnVlO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHJcblx0Z2V0IGFscGhhVG9Db3ZlcmFnZSgpIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy51c2VBbHBoYVRvQ292ZXJhZ2U7XHJcblxyXG5cdH1cclxuXHJcblx0c2V0IGFscGhhVG9Db3ZlcmFnZSggdmFsdWUgKSB7XHJcblxyXG5cdFx0aWYgKCB0aGlzLnVzZUFscGhhVG9Db3ZlcmFnZSAhPT0gdmFsdWUgKSB7XHJcblxyXG5cdFx0XHR0aGlzLnVzZUFscGhhVG9Db3ZlcmFnZSA9IHZhbHVlO1xyXG5cdFx0XHR0aGlzLm5lZWRzVXBkYXRlID0gdHJ1ZTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IExpbmUyTm9kZU1hdGVyaWFsO1xyXG4iLCJpbXBvcnQgeyBub2RlT2JqZWN0IH0gZnJvbSAnLi4vdHNsL1RTTEJhc2UuanMnO1xyXG5cclxuLyoqIEBtb2R1bGUgUGFja2luZyAqKi9cclxuXHJcbi8qKlxyXG4gKiBQYWNrcyBhIGRpcmVjdGlvbiB2ZWN0b3IgaW50byBhIGNvbG9yIHZhbHVlLlxyXG4gKlxyXG4gKiBAbWV0aG9kXHJcbiAqIEBwYXJhbSB7Tm9kZTx2ZWMzPn0gbm9kZSAtIFRoZSBkaXJlY3Rpb24gdG8gcGFjay5cclxuICogQHJldHVybiB7Tm9kZTx2ZWMzPn0gVGhlIGNvbG9yLlxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IGRpcmVjdGlvblRvQ29sb3IgPSAoIG5vZGUgKSA9PiBub2RlT2JqZWN0KCBub2RlICkubXVsKCAwLjUgKS5hZGQoIDAuNSApO1xyXG5cclxuLyoqXHJcbiAqIFVucGFja3MgYSBjb2xvciB2YWx1ZSBpbnRvIGEgZGlyZWN0aW9uIHZlY3Rvci5cclxuICpcclxuICogQG1ldGhvZFxyXG4gKiBAcGFyYW0ge05vZGU8dmVjMz59IG5vZGUgLSBUaGUgY29sb3IgdG8gdW5wYWNrLlxyXG4gKiBAcmV0dXJuIHtOb2RlPHZlYzM+fSBUaGUgZGlyZWN0aW9uLlxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IGNvbG9yVG9EaXJlY3Rpb24gPSAoIG5vZGUgKSA9PiBub2RlT2JqZWN0KCBub2RlICkubXVsKCAyLjAgKS5zdWIoIDEgKTtcclxuIiwiaW1wb3J0IE5vZGVNYXRlcmlhbCBmcm9tICcuL05vZGVNYXRlcmlhbC5qcyc7XHJcbmltcG9ydCB7IGRpZmZ1c2VDb2xvciB9IGZyb20gJy4uLy4uL25vZGVzL2NvcmUvUHJvcGVydHlOb2RlLmpzJztcclxuaW1wb3J0IHsgZGlyZWN0aW9uVG9Db2xvciB9IGZyb20gJy4uLy4uL25vZGVzL3V0aWxzL1BhY2tpbmcuanMnO1xyXG5pbXBvcnQgeyBtYXRlcmlhbE9wYWNpdHkgfSBmcm9tICcuLi8uLi9ub2Rlcy9hY2Nlc3NvcnMvTWF0ZXJpYWxOb2RlLmpzJztcclxuaW1wb3J0IHsgdHJhbnNmb3JtZWROb3JtYWxWaWV3IH0gZnJvbSAnLi4vLi4vbm9kZXMvYWNjZXNzb3JzL05vcm1hbC5qcyc7XHJcbmltcG9ydCB7IGZsb2F0LCB2ZWM0IH0gZnJvbSAnLi4vLi4vbm9kZXMvdHNsL1RTTEJhc2UuanMnO1xyXG5cclxuaW1wb3J0IHsgTWVzaE5vcm1hbE1hdGVyaWFsIH0gZnJvbSAnLi4vTWVzaE5vcm1hbE1hdGVyaWFsLmpzJztcclxuXHJcbmNvbnN0IF9kZWZhdWx0VmFsdWVzID0gLypAX19QVVJFX18qLyBuZXcgTWVzaE5vcm1hbE1hdGVyaWFsKCk7XHJcblxyXG5jbGFzcyBNZXNoTm9ybWFsTm9kZU1hdGVyaWFsIGV4dGVuZHMgTm9kZU1hdGVyaWFsIHtcclxuXHJcblx0c3RhdGljIGdldCB0eXBlKCkge1xyXG5cclxuXHRcdHJldHVybiAnTWVzaE5vcm1hbE5vZGVNYXRlcmlhbCc7XHJcblxyXG5cdH1cclxuXHJcblx0Y29uc3RydWN0b3IoIHBhcmFtZXRlcnMgKSB7XHJcblxyXG5cdFx0c3VwZXIoKTtcclxuXHJcblx0XHR0aGlzLmxpZ2h0cyA9IGZhbHNlO1xyXG5cclxuXHRcdHRoaXMuaXNNZXNoTm9ybWFsTm9kZU1hdGVyaWFsID0gdHJ1ZTtcclxuXHJcblx0XHR0aGlzLnNldERlZmF1bHRWYWx1ZXMoIF9kZWZhdWx0VmFsdWVzICk7XHJcblxyXG5cdFx0dGhpcy5zZXRWYWx1ZXMoIHBhcmFtZXRlcnMgKTtcclxuXHJcblx0fVxyXG5cclxuXHRzZXR1cERpZmZ1c2VDb2xvcigpIHtcclxuXHJcblx0XHRjb25zdCBvcGFjaXR5Tm9kZSA9IHRoaXMub3BhY2l0eU5vZGUgPyBmbG9hdCggdGhpcy5vcGFjaXR5Tm9kZSApIDogbWF0ZXJpYWxPcGFjaXR5O1xyXG5cclxuXHRcdGRpZmZ1c2VDb2xvci5hc3NpZ24oIHZlYzQoIGRpcmVjdGlvblRvQ29sb3IoIHRyYW5zZm9ybWVkTm9ybWFsVmlldyApLCBvcGFjaXR5Tm9kZSApICk7XHJcblxyXG5cdH1cclxuXHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IE1lc2hOb3JtYWxOb2RlTWF0ZXJpYWw7XHJcbiIsImltcG9ydCBUZW1wTm9kZSBmcm9tICcuLi9jb3JlL1RlbXBOb2RlLmpzJztcclxuaW1wb3J0IHsgcG9zaXRpb25Xb3JsZERpcmVjdGlvbiB9IGZyb20gJy4uL2FjY2Vzc29ycy9Qb3NpdGlvbi5qcyc7XHJcbmltcG9ydCB7IG5vZGVQcm94eSwgdmVjMiB9IGZyb20gJy4uL3RzbC9UU0xCYXNlLmpzJztcclxuXHJcbi8qKiBAbW9kdWxlIEVxdWlyZWN0VVZOb2RlICoqL1xyXG5cclxuLyoqXHJcbiAqIENhbiBiZSB1c2VkIHRvIGNvbXB1dGUgdGV4dHVyZSBjb29yZGluYXRlcyBmb3IgcHJvamVjdGluZyBhblxyXG4gKiBlcXVpcmVjdGFuZ3VsYXIgdGV4dHVyZSBvbnRvIGEgbWVzaCBmb3IgdXNpbmcgaXQgYXMgdGhlIHNjZW5lJ3NcclxuICogYmFja2dyb3VuZC5cclxuICpcclxuICogYGBganNcclxuICogc2NlbmUuYmFja2dyb3VuZE5vZGUgPSB0ZXh0dXJlKCBlcXVpcmVjdFRleHR1cmUsIGVxdWlyZWN0VVYoKSApO1xyXG4gKiBgYGBcclxuICpcclxuICogQGF1Z21lbnRzIFRlbXBOb2RlXHJcbiAqL1xyXG5jbGFzcyBFcXVpcmVjdFVWTm9kZSBleHRlbmRzIFRlbXBOb2RlIHtcclxuXHJcblx0c3RhdGljIGdldCB0eXBlKCkge1xyXG5cclxuXHRcdHJldHVybiAnRXF1aXJlY3RVVk5vZGUnO1xyXG5cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIENvbnN0cnVjdHMgYSBuZXcgZXF1aXJlY3QgdXYgbm9kZS5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7Tm9kZTx2ZWMzPn0gW2Rpck5vZGU9cG9zaXRpb25Xb3JsZERpcmVjdGlvbl0gLSBBIGRpcmVjdGlvbiB2ZWN0b3IgZm9yIHNhbXBsaW5nIHdoaWNoIGlzIGJ5IGRlZmF1bHQgYHBvc2l0aW9uV29ybGREaXJlY3Rpb25gLlxyXG5cdCAqL1xyXG5cdGNvbnN0cnVjdG9yKCBkaXJOb2RlID0gcG9zaXRpb25Xb3JsZERpcmVjdGlvbiApIHtcclxuXHJcblx0XHRzdXBlciggJ3ZlYzInICk7XHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBBIGRpcmVjdGlvbiB2ZWN0b3IgZm9yIHNhbXBsaW5nIHdoeSBpcyBieSBkZWZhdWx0IGBwb3NpdGlvbldvcmxkRGlyZWN0aW9uYC5cclxuXHRcdCAqXHJcblx0XHQgKiBAdHlwZSB7Tm9kZTx2ZWMzPn1cclxuXHRcdCAqL1xyXG5cdFx0dGhpcy5kaXJOb2RlID0gZGlyTm9kZTtcclxuXHJcblx0fVxyXG5cclxuXHRzZXR1cCgpIHtcclxuXHJcblx0XHRjb25zdCBkaXIgPSB0aGlzLmRpck5vZGU7XHJcblxyXG5cdFx0Y29uc3QgdSA9IGRpci56LmF0YW4yKCBkaXIueCApLm11bCggMSAvICggTWF0aC5QSSAqIDIgKSApLmFkZCggMC41ICk7XHJcblx0XHRjb25zdCB2ID0gZGlyLnkuY2xhbXAoIC0gMS4wLCAxLjAgKS5hc2luKCkubXVsKCAxIC8gTWF0aC5QSSApLmFkZCggMC41ICk7XHJcblxyXG5cdFx0cmV0dXJuIHZlYzIoIHUsIHYgKTtcclxuXHJcblx0fVxyXG5cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgRXF1aXJlY3RVVk5vZGU7XHJcblxyXG4vKipcclxuICogVFNMIGZ1bmN0aW9uIGZvciBjcmVhdGluZyBhbiBlcXVpcmVjdCB1diBub2RlLlxyXG4gKlxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHtOb2RlPHZlYzM+fSBbZGlyTm9kZT1wb3NpdGlvbldvcmxkRGlyZWN0aW9uXSAtIEEgZGlyZWN0aW9uIHZlY3RvciBmb3Igc2FtcGxpbmcgd2hpY2ggaXMgYnkgZGVmYXVsdCBgcG9zaXRpb25Xb3JsZERpcmVjdGlvbmAuXHJcbiAqIEByZXR1cm5zIHtFcXVpcmVjdFVWTm9kZX1cclxuICovXHJcbmV4cG9ydCBjb25zdCBlcXVpcmVjdFVWID0gLypAX19QVVJFX18qLyBub2RlUHJveHkoIEVxdWlyZWN0VVZOb2RlICk7XHJcbiIsImltcG9ydCB7IGVxdWlyZWN0VVYgfSBmcm9tICcuLi8uLi9ub2Rlcy91dGlscy9FcXVpcmVjdFVWTm9kZS5qcyc7XHJcbmltcG9ydCB7IHRleHR1cmUgYXMgVFNMX1RleHR1cmUgfSBmcm9tICcuLi8uLi9ub2Rlcy9hY2Nlc3NvcnMvVGV4dHVyZU5vZGUuanMnO1xyXG5pbXBvcnQgeyBwb3NpdGlvbldvcmxkRGlyZWN0aW9uIH0gZnJvbSAnLi4vLi4vbm9kZXMvYWNjZXNzb3JzL1Bvc2l0aW9uLmpzJztcclxuaW1wb3J0IE5vZGVNYXRlcmlhbCBmcm9tICcuLi8uLi9tYXRlcmlhbHMvbm9kZXMvTm9kZU1hdGVyaWFsLmpzJztcclxuXHJcbmltcG9ydCB7IFdlYkdMQ3ViZVJlbmRlclRhcmdldCB9IGZyb20gJy4uLy4uL3JlbmRlcmVycy9XZWJHTEN1YmVSZW5kZXJUYXJnZXQuanMnO1xyXG5pbXBvcnQgeyBTY2VuZSB9IGZyb20gJy4uLy4uL3NjZW5lcy9TY2VuZS5qcyc7XHJcbmltcG9ydCB7IEN1YmVDYW1lcmEgfSBmcm9tICcuLi8uLi9jYW1lcmFzL0N1YmVDYW1lcmEuanMnO1xyXG5pbXBvcnQgeyBCb3hHZW9tZXRyeSB9IGZyb20gJy4uLy4uL2dlb21ldHJpZXMvQm94R2VvbWV0cnkuanMnO1xyXG5pbXBvcnQgeyBNZXNoIH0gZnJvbSAnLi4vLi4vb2JqZWN0cy9NZXNoLmpzJztcclxuaW1wb3J0IHsgQmFja1NpZGUsIE5vQmxlbmRpbmcsIExpbmVhckZpbHRlciwgTGluZWFyTWlwbWFwTGluZWFyRmlsdGVyIH0gZnJvbSAnLi4vLi4vY29uc3RhbnRzLmpzJztcclxuXHJcbi8vIEBUT0RPOiBDb25zaWRlciByZW5hbWUgV2ViR0xDdWJlUmVuZGVyVGFyZ2V0IHRvIGp1c3QgQ3ViZVJlbmRlclRhcmdldFxyXG5cclxuY2xhc3MgQ3ViZVJlbmRlclRhcmdldCBleHRlbmRzIFdlYkdMQ3ViZVJlbmRlclRhcmdldCB7XHJcblxyXG5cdGNvbnN0cnVjdG9yKCBzaXplID0gMSwgb3B0aW9ucyA9IHt9ICkge1xyXG5cclxuXHRcdHN1cGVyKCBzaXplLCBvcHRpb25zICk7XHJcblxyXG5cdFx0dGhpcy5pc0N1YmVSZW5kZXJUYXJnZXQgPSB0cnVlO1xyXG5cclxuXHR9XHJcblxyXG5cdGZyb21FcXVpcmVjdGFuZ3VsYXJUZXh0dXJlKCByZW5kZXJlciwgdGV4dHVyZSApIHtcclxuXHJcblx0XHRjb25zdCBjdXJyZW50TWluRmlsdGVyID0gdGV4dHVyZS5taW5GaWx0ZXI7XHJcblx0XHRjb25zdCBjdXJyZW50R2VuZXJhdGVNaXBtYXBzID0gdGV4dHVyZS5nZW5lcmF0ZU1pcG1hcHM7XHJcblxyXG5cdFx0dGV4dHVyZS5nZW5lcmF0ZU1pcG1hcHMgPSB0cnVlO1xyXG5cclxuXHRcdHRoaXMudGV4dHVyZS50eXBlID0gdGV4dHVyZS50eXBlO1xyXG5cdFx0dGhpcy50ZXh0dXJlLmNvbG9yU3BhY2UgPSB0ZXh0dXJlLmNvbG9yU3BhY2U7XHJcblxyXG5cdFx0dGhpcy50ZXh0dXJlLmdlbmVyYXRlTWlwbWFwcyA9IHRleHR1cmUuZ2VuZXJhdGVNaXBtYXBzO1xyXG5cdFx0dGhpcy50ZXh0dXJlLm1pbkZpbHRlciA9IHRleHR1cmUubWluRmlsdGVyO1xyXG5cdFx0dGhpcy50ZXh0dXJlLm1hZ0ZpbHRlciA9IHRleHR1cmUubWFnRmlsdGVyO1xyXG5cclxuXHRcdGNvbnN0IGdlb21ldHJ5ID0gbmV3IEJveEdlb21ldHJ5KCA1LCA1LCA1ICk7XHJcblxyXG5cdFx0Y29uc3QgdXZOb2RlID0gZXF1aXJlY3RVViggcG9zaXRpb25Xb3JsZERpcmVjdGlvbiApO1xyXG5cclxuXHRcdGNvbnN0IG1hdGVyaWFsID0gbmV3IE5vZGVNYXRlcmlhbCgpO1xyXG5cdFx0bWF0ZXJpYWwuY29sb3JOb2RlID0gVFNMX1RleHR1cmUoIHRleHR1cmUsIHV2Tm9kZSwgMCApO1xyXG5cdFx0bWF0ZXJpYWwuc2lkZSA9IEJhY2tTaWRlO1xyXG5cdFx0bWF0ZXJpYWwuYmxlbmRpbmcgPSBOb0JsZW5kaW5nO1xyXG5cclxuXHRcdGNvbnN0IG1lc2ggPSBuZXcgTWVzaCggZ2VvbWV0cnksIG1hdGVyaWFsICk7XHJcblxyXG5cdFx0Y29uc3Qgc2NlbmUgPSBuZXcgU2NlbmUoKTtcclxuXHRcdHNjZW5lLmFkZCggbWVzaCApO1xyXG5cclxuXHRcdC8vIEF2b2lkIGJsdXJyZWQgcG9sZXNcclxuXHRcdGlmICggdGV4dHVyZS5taW5GaWx0ZXIgPT09IExpbmVhck1pcG1hcExpbmVhckZpbHRlciApIHRleHR1cmUubWluRmlsdGVyID0gTGluZWFyRmlsdGVyO1xyXG5cclxuXHRcdGNvbnN0IGNhbWVyYSA9IG5ldyBDdWJlQ2FtZXJhKCAxLCAxMCwgdGhpcyApO1xyXG5cclxuXHRcdGNvbnN0IGN1cnJlbnRNUlQgPSByZW5kZXJlci5nZXRNUlQoKTtcclxuXHRcdHJlbmRlcmVyLnNldE1SVCggbnVsbCApO1xyXG5cclxuXHRcdGNhbWVyYS51cGRhdGUoIHJlbmRlcmVyLCBzY2VuZSApO1xyXG5cclxuXHRcdHJlbmRlcmVyLnNldE1SVCggY3VycmVudE1SVCApO1xyXG5cclxuXHRcdHRleHR1cmUubWluRmlsdGVyID0gY3VycmVudE1pbkZpbHRlcjtcclxuXHRcdHRleHR1cmUuY3VycmVudEdlbmVyYXRlTWlwbWFwcyA9IGN1cnJlbnRHZW5lcmF0ZU1pcG1hcHM7XHJcblxyXG5cdFx0bWVzaC5nZW9tZXRyeS5kaXNwb3NlKCk7XHJcblx0XHRtZXNoLm1hdGVyaWFsLmRpc3Bvc2UoKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fVxyXG5cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgQ3ViZVJlbmRlclRhcmdldDtcclxuIiwiaW1wb3J0IFRlbXBOb2RlIGZyb20gJy4uL2NvcmUvVGVtcE5vZGUuanMnO1xyXG5pbXBvcnQgeyBOb2RlVXBkYXRlVHlwZSB9IGZyb20gJy4uL2NvcmUvY29uc3RhbnRzLmpzJztcclxuaW1wb3J0IHsgbm9kZVByb3h5IH0gZnJvbSAnLi4vdHNsL1RTTEJhc2UuanMnO1xyXG5pbXBvcnQgeyBDdWJlVGV4dHVyZSB9IGZyb20gJy4uLy4uL3RleHR1cmVzL0N1YmVUZXh0dXJlLmpzJztcclxuaW1wb3J0IHsgY3ViZVRleHR1cmUgfSBmcm9tICcuLi9hY2Nlc3NvcnMvQ3ViZVRleHR1cmVOb2RlLmpzJztcclxuaW1wb3J0IEN1YmVSZW5kZXJUYXJnZXQgZnJvbSAnLi4vLi4vcmVuZGVyZXJzL2NvbW1vbi9DdWJlUmVuZGVyVGFyZ2V0LmpzJztcclxuaW1wb3J0IHsgQ3ViZVJlZmxlY3Rpb25NYXBwaW5nLCBDdWJlUmVmcmFjdGlvbk1hcHBpbmcsIEVxdWlyZWN0YW5ndWxhclJlZmxlY3Rpb25NYXBwaW5nLCBFcXVpcmVjdGFuZ3VsYXJSZWZyYWN0aW9uTWFwcGluZyB9IGZyb20gJy4uLy4uL2NvbnN0YW50cy5qcyc7XHJcblxyXG4vKiogQG1vZHVsZSBDdWJlTWFwTm9kZSAqKi9cclxuXHJcbmNvbnN0IF9jYWNoZSA9IG5ldyBXZWFrTWFwKCk7XHJcblxyXG4vKipcclxuICogVGhpcyBub2RlIGNhbiBiZSB1c2VkIHRvIGF1dG9tYXRpY2FsbHkgY29udmVydCBlbnZpcm9ubWVudCBtYXBzIGluIHRoZVxyXG4gKiBlcXVpcmVjdGFuZ3VsYXIgZm9ybWF0IGludG8gdGhlIGN1YmUgbWFwIGZvcm1hdC5cclxuICpcclxuICogQGF1Z21lbnRzIFRlbXBOb2RlXHJcbiAqL1xyXG5jbGFzcyBDdWJlTWFwTm9kZSBleHRlbmRzIFRlbXBOb2RlIHtcclxuXHJcblx0c3RhdGljIGdldCB0eXBlKCkge1xyXG5cclxuXHRcdHJldHVybiAnQ3ViZU1hcE5vZGUnO1xyXG5cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIENvbnN0cnVjdHMgYSBuZXcgY3ViZSBtYXAgbm9kZS5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7Tm9kZX0gZW52Tm9kZSAtIFRoZSBub2RlIHJlcHJlc2VudGluZyB0aGUgZW52aXJvbm1lbnQgbWFwLlxyXG5cdCAqL1xyXG5cdGNvbnN0cnVjdG9yKCBlbnZOb2RlICkge1xyXG5cclxuXHRcdHN1cGVyKCAndmVjMycgKTtcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIFRoZSBub2RlIHJlcHJlc2VudGluZyB0aGUgZW52aXJvbm1lbnQgbWFwLlxyXG5cdFx0ICpcclxuXHRcdCAqIEB0eXBlIHtOb2RlfVxyXG5cdFx0ICovXHJcblx0XHR0aGlzLmVudk5vZGUgPSBlbnZOb2RlO1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogQSByZWZlcmVuY2UgdG8gdGhlIGludGVybmFsIGN1YmUgdGV4dHVyZS5cclxuXHRcdCAqXHJcblx0XHQgKiBAcHJpdmF0ZVxyXG5cdFx0ICogQHR5cGUge0N1YmVUZXh0dXJlfVxyXG5cdFx0ICogQGRlZmF1bHQgbnVsbFxyXG5cdFx0ICovXHJcblx0XHR0aGlzLl9jdWJlVGV4dHVyZSA9IG51bGw7XHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBBIHJlZmVyZW5jZSB0byB0aGUgaW50ZXJuYWwgY3ViZSB0ZXh0dXJlIG5vZGUuXHJcblx0XHQgKlxyXG5cdFx0ICogQHByaXZhdGVcclxuXHRcdCAqIEB0eXBlIHtDdWJlVGV4dHVyZU5vZGV9XHJcblx0XHQgKi9cclxuXHRcdHRoaXMuX2N1YmVUZXh0dXJlTm9kZSA9IGN1YmVUZXh0dXJlKCk7XHJcblxyXG5cdFx0Y29uc3QgZGVmYXVsdFRleHR1cmUgPSBuZXcgQ3ViZVRleHR1cmUoKTtcclxuXHRcdGRlZmF1bHRUZXh0dXJlLmlzUmVuZGVyVGFyZ2V0VGV4dHVyZSA9IHRydWU7XHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBBIGRlZmF1bHQgY3ViZSB0ZXh0dXJlIHRoYXQgYWN0cyBhcyBhIHBsYWNlaG9sZGVyLlxyXG5cdFx0ICogSXQgaXMgdXNlZCB3aGVuIHRoZSBjb252ZXJzaW9uIGZyb20gZXF1aXJlY3Rhbmd1bGFyIHRvIGN1YmVcclxuXHRcdCAqIG1hcCBoYXMgbm90IGZpbmlzaGVkIHlldCBmb3IgYSBnaXZlbiB0ZXh0dXJlLlxyXG5cdFx0ICpcclxuXHRcdCAqIEBwcml2YXRlXHJcblx0XHQgKiBAdHlwZSB7Q3ViZVRleHR1cmV9XHJcblx0XHQgKi9cclxuXHRcdHRoaXMuX2RlZmF1bHRUZXh0dXJlID0gZGVmYXVsdFRleHR1cmU7XHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBUaGUgYHVwZGF0ZUJlZm9yZVR5cGVgIGlzIHNldCB0byBgTm9kZVVwZGF0ZVR5cGUuUkVOREVSYCBzaW5jZSB0aGUgbm9kZSB1cGRhdGVzXHJcblx0XHQgKiB0aGUgdGV4dHVyZSBvbmNlIHBlciByZW5kZXIgaW4gaXRzIHtAbGluayBDdWJlTWFwTm9kZSN1cGRhdGVCZWZvcmV9IG1ldGhvZC5cclxuXHRcdCAqXHJcblx0XHQgKiBAdHlwZSB7U3RyaW5nfVxyXG5cdFx0ICogQGRlZmF1bHQgJ3JlbmRlcidcclxuXHRcdCAqL1xyXG5cdFx0dGhpcy51cGRhdGVCZWZvcmVUeXBlID0gTm9kZVVwZGF0ZVR5cGUuUkVOREVSO1xyXG5cclxuXHR9XHJcblxyXG5cdHVwZGF0ZUJlZm9yZSggZnJhbWUgKSB7XHJcblxyXG5cdFx0Y29uc3QgeyByZW5kZXJlciwgbWF0ZXJpYWwgfSA9IGZyYW1lO1xyXG5cclxuXHRcdGNvbnN0IGVudk5vZGUgPSB0aGlzLmVudk5vZGU7XHJcblxyXG5cdFx0aWYgKCBlbnZOb2RlLmlzVGV4dHVyZU5vZGUgfHwgZW52Tm9kZS5pc01hdGVyaWFsUmVmZXJlbmNlTm9kZSApIHtcclxuXHJcblx0XHRcdGNvbnN0IHRleHR1cmUgPSAoIGVudk5vZGUuaXNUZXh0dXJlTm9kZSApID8gZW52Tm9kZS52YWx1ZSA6IG1hdGVyaWFsWyBlbnZOb2RlLnByb3BlcnR5IF07XHJcblxyXG5cdFx0XHRpZiAoIHRleHR1cmUgJiYgdGV4dHVyZS5pc1RleHR1cmUgKSB7XHJcblxyXG5cdFx0XHRcdGNvbnN0IG1hcHBpbmcgPSB0ZXh0dXJlLm1hcHBpbmc7XHJcblxyXG5cdFx0XHRcdGlmICggbWFwcGluZyA9PT0gRXF1aXJlY3Rhbmd1bGFyUmVmbGVjdGlvbk1hcHBpbmcgfHwgbWFwcGluZyA9PT0gRXF1aXJlY3Rhbmd1bGFyUmVmcmFjdGlvbk1hcHBpbmcgKSB7XHJcblxyXG5cdFx0XHRcdFx0Ly8gY2hlY2sgZm9yIGNvbnZlcnRlZCBjdWJlbWFwIG1hcFxyXG5cclxuXHRcdFx0XHRcdGlmICggX2NhY2hlLmhhcyggdGV4dHVyZSApICkge1xyXG5cclxuXHRcdFx0XHRcdFx0Y29uc3QgY3ViZU1hcCA9IF9jYWNoZS5nZXQoIHRleHR1cmUgKTtcclxuXHJcblx0XHRcdFx0XHRcdG1hcFRleHR1cmVNYXBwaW5nKCBjdWJlTWFwLCB0ZXh0dXJlLm1hcHBpbmcgKTtcclxuXHRcdFx0XHRcdFx0dGhpcy5fY3ViZVRleHR1cmUgPSBjdWJlTWFwO1xyXG5cclxuXHRcdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0XHQvLyBjcmVhdGUgY3ViZSBtYXAgZnJvbSBlcXVpcmVjdGFuZ3VsYXIgbWFwXHJcblxyXG5cdFx0XHRcdFx0XHRjb25zdCBpbWFnZSA9IHRleHR1cmUuaW1hZ2U7XHJcblxyXG5cdFx0XHRcdFx0XHRpZiAoIGlzRXF1aXJlY3Rhbmd1bGFyTWFwUmVhZHkoIGltYWdlICkgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdGNvbnN0IHJlbmRlclRhcmdldCA9IG5ldyBDdWJlUmVuZGVyVGFyZ2V0KCBpbWFnZS5oZWlnaHQgKTtcclxuXHRcdFx0XHRcdFx0XHRyZW5kZXJUYXJnZXQuZnJvbUVxdWlyZWN0YW5ndWxhclRleHR1cmUoIHJlbmRlcmVyLCB0ZXh0dXJlICk7XHJcblxyXG5cdFx0XHRcdFx0XHRcdG1hcFRleHR1cmVNYXBwaW5nKCByZW5kZXJUYXJnZXQudGV4dHVyZSwgdGV4dHVyZS5tYXBwaW5nICk7XHJcblx0XHRcdFx0XHRcdFx0dGhpcy5fY3ViZVRleHR1cmUgPSByZW5kZXJUYXJnZXQudGV4dHVyZTtcclxuXHJcblx0XHRcdFx0XHRcdFx0X2NhY2hlLnNldCggdGV4dHVyZSwgcmVuZGVyVGFyZ2V0LnRleHR1cmUgKTtcclxuXHJcblx0XHRcdFx0XHRcdFx0dGV4dHVyZS5hZGRFdmVudExpc3RlbmVyKCAnZGlzcG9zZScsIG9uVGV4dHVyZURpc3Bvc2UgKTtcclxuXHJcblx0XHRcdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdC8vIGRlZmF1bHQgY3ViZSB0ZXh0dXJlIGFzIGZhbGxiYWNrIHdoZW4gZXF1aXJlY3Rhbmd1bGFyIHRleHR1cmUgaXMgbm90IHlldCBsb2FkZWRcclxuXHJcblx0XHRcdFx0XHRcdFx0dGhpcy5fY3ViZVRleHR1cmUgPSB0aGlzLl9kZWZhdWx0VGV4dHVyZTtcclxuXHJcblx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0Ly9cclxuXHJcblx0XHRcdFx0XHR0aGlzLl9jdWJlVGV4dHVyZU5vZGUudmFsdWUgPSB0aGlzLl9jdWJlVGV4dHVyZTtcclxuXHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHQvLyBlbnZOb2RlIGFscmVhZHkgcmVmZXJzIHRvIGEgY3ViZSBtYXBcclxuXHJcblx0XHRcdFx0XHR0aGlzLl9jdWJlVGV4dHVyZU5vZGUgPSB0aGlzLmVudk5vZGU7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0c2V0dXAoIGJ1aWxkZXIgKSB7XHJcblxyXG5cdFx0dGhpcy51cGRhdGVCZWZvcmUoIGJ1aWxkZXIgKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5fY3ViZVRleHR1cmVOb2RlO1xyXG5cclxuXHR9XHJcblxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBDdWJlTWFwTm9kZTtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIGVxdWlyZWN0YW5ndWxhciBpbWFnZSBoYXMgYmVlbiBmdWxseSBsb2FkZWRcclxuICogYW5kIGlzIHJlYWR5IGZvciBmdXJ0aGVyIHByb2Nlc3NpbmcuXHJcbiAqXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBwYXJhbSB7SW1hZ2V9IGltYWdlIC0gVGhlIGVxdWlyZWN0YW5ndWxhciBpbWFnZSB0byBjaGVjay5cclxuICogQHJldHVybiB7Qm9vbGVhbn0gV2hldGhlciB0aGUgaW1hZ2UgaXMgcmVhZHkgb3Igbm90LlxyXG4gKi9cclxuZnVuY3Rpb24gaXNFcXVpcmVjdGFuZ3VsYXJNYXBSZWFkeSggaW1hZ2UgKSB7XHJcblxyXG5cdGlmICggaW1hZ2UgPT09IG51bGwgfHwgaW1hZ2UgPT09IHVuZGVmaW5lZCApIHJldHVybiBmYWxzZTtcclxuXHJcblx0cmV0dXJuIGltYWdlLmhlaWdodCA+IDA7XHJcblxyXG59XHJcblxyXG4vKipcclxuICogVGhpcyBmdW5jdGlvbiBpcyBleGVjdXRlZCB3aGVuIGBkaXNwb3NlKClgIGlzIGNhbGxlZCBvbiB0aGUgZXF1aXJlY3Rhbmd1bGFyXHJcbiAqIHRleHR1cmUuIEluIHRoaXMgY2FzZSwgdGhlIGdlbmVyYXRlZCBjdWJlIG1hcCB3aXRoIGl0cyByZW5kZXIgdGFyZ2V0XHJcbiAqIGlzIGRlbGV0ZWQgYXMgd2VsbC5cclxuICpcclxuICogQHByaXZhdGVcclxuICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gVGhlIGV2ZW50IG9iamVjdC5cclxuICovXHJcbmZ1bmN0aW9uIG9uVGV4dHVyZURpc3Bvc2UoIGV2ZW50ICkge1xyXG5cclxuXHRjb25zdCB0ZXh0dXJlID0gZXZlbnQudGFyZ2V0O1xyXG5cclxuXHR0ZXh0dXJlLnJlbW92ZUV2ZW50TGlzdGVuZXIoICdkaXNwb3NlJywgb25UZXh0dXJlRGlzcG9zZSApO1xyXG5cclxuXHRjb25zdCByZW5kZXJUYXJnZXQgPSBfY2FjaGUuZ2V0KCB0ZXh0dXJlICk7XHJcblxyXG5cdGlmICggcmVuZGVyVGFyZ2V0ICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0X2NhY2hlLmRlbGV0ZSggdGV4dHVyZSApO1xyXG5cclxuXHRcdHJlbmRlclRhcmdldC5kaXNwb3NlKCk7XHJcblxyXG5cdH1cclxuXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBUaGlzIGZ1bmN0aW9uIG1ha2VzIHN1cmUgdGhlIGdlbmVyYXRlZCBjdWJlIG1hcCB1c2VzIHRoZSBjb3JyZWN0XHJcbiAqIHRleHR1cmUgbWFwcGluZyB0aGF0IGNvcnJlc3BvbmRzIHRvIHRoZSBlcXVpcmVjdGFuZ3VsYXIgb3JpZ2luYWwuXHJcbiAqXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBwYXJhbSB7VGV4dHVyZX0gdGV4dHVyZSAtIFRoZSBjdWJlIHRleHR1cmUuXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBtYXBwaW5nIC0gVGhlIG9yaWdpbmFsIHRleHR1cmUgbWFwcGluZy5cclxuICovXHJcbmZ1bmN0aW9uIG1hcFRleHR1cmVNYXBwaW5nKCB0ZXh0dXJlLCBtYXBwaW5nICkge1xyXG5cclxuXHRpZiAoIG1hcHBpbmcgPT09IEVxdWlyZWN0YW5ndWxhclJlZmxlY3Rpb25NYXBwaW5nICkge1xyXG5cclxuXHRcdHRleHR1cmUubWFwcGluZyA9IEN1YmVSZWZsZWN0aW9uTWFwcGluZztcclxuXHJcblx0fSBlbHNlIGlmICggbWFwcGluZyA9PT0gRXF1aXJlY3Rhbmd1bGFyUmVmcmFjdGlvbk1hcHBpbmcgKSB7XHJcblxyXG5cdFx0dGV4dHVyZS5tYXBwaW5nID0gQ3ViZVJlZnJhY3Rpb25NYXBwaW5nO1xyXG5cclxuXHR9XHJcblxyXG59XHJcblxyXG4vKipcclxuICogVFNMIGZ1bmN0aW9uIGZvciBjcmVhdGluZyBhIGN1YmUgbWFwIG5vZGUuXHJcbiAqXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0ge05vZGV9IGVudk5vZGUgLSBUaGUgbm9kZSByZXByZXNlbnRpbmcgdGhlIGVudmlyb25tZW50IG1hcC5cclxuICogQHJldHVybnMge0N1YmVNYXBOb2RlfVxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IGN1YmVNYXBOb2RlID0gLypAX19QVVJFX18qLyBub2RlUHJveHkoIEN1YmVNYXBOb2RlICk7XHJcbiIsImltcG9ydCBMaWdodGluZ05vZGUgZnJvbSAnLi9MaWdodGluZ05vZGUuanMnO1xyXG5pbXBvcnQgeyBjdWJlTWFwTm9kZSB9IGZyb20gJy4uL3V0aWxzL0N1YmVNYXBOb2RlLmpzJztcclxuXHJcbi8qKlxyXG4gKiBSZXByZXNlbnRzIGEgYmFzaWMgbW9kZWwgZm9yIEltYWdlLWJhc2VkIGxpZ2h0aW5nIChJQkwpLiBUaGUgZW52aXJvbm1lbnRcclxuICogaXMgZGVmaW5lZCB2aWEgZW52aXJvbm1lbnQgbWFwcyBpbiB0aGUgZXF1aXJlY3RhbnVsYXIgb3IgY3ViZSBtYXAgZm9ybWF0LlxyXG4gKiBgQmFzaWNFbnZpcm9ubWVudE5vZGVgIGlzIGludGVuZGVkIGZvciBub24tUEJSIG1hdGVyaWFscyBsaWtlIHtAbGluayBNZXNoQmFzaWNOb2RlTWF0ZXJpYWx9XHJcbiAqIG9yIHtAbGluayBNZXNoUGhvbmdOb2RlTWF0ZXJpYWx9LlxyXG4gKlxyXG4gKiBAYXVnbWVudHMgTGlnaHRpbmdOb2RlXHJcbiAqL1xyXG5jbGFzcyBCYXNpY0Vudmlyb25tZW50Tm9kZSBleHRlbmRzIExpZ2h0aW5nTm9kZSB7XHJcblxyXG5cdHN0YXRpYyBnZXQgdHlwZSgpIHtcclxuXHJcblx0XHRyZXR1cm4gJ0Jhc2ljRW52aXJvbm1lbnROb2RlJztcclxuXHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBDb25zdHJ1Y3RzIGEgbmV3IGJhc2ljIGVudmlyb25tZW50IG5vZGUuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge05vZGV9IFtlbnZOb2RlPW51bGxdIC0gQSBub2RlIHJlcHJlc2VudGluZyB0aGUgZW52aXJvbm1lbnQuXHJcblx0ICovXHJcblx0Y29uc3RydWN0b3IoIGVudk5vZGUgPSBudWxsICkge1xyXG5cclxuXHRcdHN1cGVyKCk7XHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBBIG5vZGUgcmVwcmVzZW50aW5nIHRoZSBlbnZpcm9ubWVudC5cclxuXHRcdCAqXHJcblx0XHQgKiBAdHlwZSB7Tm9kZX1cclxuXHRcdCAqIEBkZWZhdWx0IG51bGxcclxuXHRcdCAqL1xyXG5cdFx0dGhpcy5lbnZOb2RlID0gZW52Tm9kZTtcclxuXHJcblx0fVxyXG5cclxuXHRzZXR1cCggYnVpbGRlciApIHtcclxuXHJcblx0XHQvLyBlbnZpcm9ubWVudCBwcm9wZXJ0eSBpcyB1c2VkIGluIHRoZSBmaW5pc2goKSBtZXRob2Qgb2YgQmFzaWNMaWdodGluZ01vZGVsXHJcblxyXG5cdFx0YnVpbGRlci5jb250ZXh0LmVudmlyb25tZW50ID0gY3ViZU1hcE5vZGUoIHRoaXMuZW52Tm9kZSApO1xyXG5cclxuXHR9XHJcblxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBCYXNpY0Vudmlyb25tZW50Tm9kZTtcclxuIiwiaW1wb3J0IExpZ2h0aW5nTm9kZSBmcm9tICcuL0xpZ2h0aW5nTm9kZS5qcyc7XHJcbmltcG9ydCB7IGZsb2F0IH0gZnJvbSAnLi4vdHNsL1RTTEJhc2UuanMnO1xyXG5cclxuLyoqXHJcbiAqIEEgc3BlY2lmaWMgdmVyc2lvbiBvZiB7QGxpbmsgSXJyYWRpYW5jZU5vZGV9IHRoYXQgaXMgb25seSByZWxldmFudFxyXG4gKiBmb3Ige0BsaW5rIE1lc2hCYXNpY05vZGVNYXRlcmlhbH0uIFNpbmNlIHRoZSBtYXRlcmlhbCBpcyB1bmxpdCwgaXRcclxuICogcmVxdWlyZXMgYSBzcGVjaWFsIHNjYWxpbmcgZmFjdG9yIGZvciB0aGUgbGlnaHQgbWFwLlxyXG4gKlxyXG4gKiBAYXVnbWVudHMgTGlnaHRpbmdOb2RlXHJcbiAqL1xyXG5jbGFzcyBCYXNpY0xpZ2h0TWFwTm9kZSBleHRlbmRzIExpZ2h0aW5nTm9kZSB7XHJcblxyXG5cdHN0YXRpYyBnZXQgdHlwZSgpIHtcclxuXHJcblx0XHRyZXR1cm4gJ0Jhc2ljTGlnaHRNYXBOb2RlJztcclxuXHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBDb25zdHJ1Y3RzIGEgbmV3IGJhc2ljIGxpZ2h0IG1hcCBub2RlLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtOb2RlPHZlYzM+P30gW2xpZ2h0TWFwTm9kZT1udWxsXSAtIFRoZSBsaWdodCBtYXAgbm9kZS5cclxuXHQgKi9cclxuXHRjb25zdHJ1Y3RvciggbGlnaHRNYXBOb2RlID0gbnVsbCApIHtcclxuXHJcblx0XHRzdXBlcigpO1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogVGhlIGxpZ2h0IG1hcCBub2RlLlxyXG5cdFx0ICpcclxuXHRcdCAqIEB0eXBlIHtOb2RlPHZlYzM+P31cclxuXHRcdCAqL1xyXG5cdFx0dGhpcy5saWdodE1hcE5vZGUgPSBsaWdodE1hcE5vZGU7XHJcblxyXG5cdH1cclxuXHJcblx0c2V0dXAoIGJ1aWxkZXIgKSB7XHJcblxyXG5cdFx0Ly8gaXJyYWRpYW5jZUxpZ2h0TWFwIHByb3BlcnR5IGlzIHVzZWQgaW4gdGhlIGluZGlyZWN0RGlmZnVzZSgpIG1ldGhvZCBvZiBCYXNpY0xpZ2h0aW5nTW9kZWxcclxuXHJcblx0XHRjb25zdCBSRUNJUFJPQ0FMX1BJID0gZmxvYXQoIDEgLyBNYXRoLlBJICk7XHJcblxyXG5cdFx0YnVpbGRlci5jb250ZXh0LmlycmFkaWFuY2VMaWdodE1hcCA9IHRoaXMubGlnaHRNYXBOb2RlLm11bCggUkVDSVBST0NBTF9QSSApO1xyXG5cclxuXHR9XHJcblxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBCYXNpY0xpZ2h0TWFwTm9kZTtcclxuIiwiLyoqXHJcbiAqIEFic3RyYWN0IGNsYXNzIGZvciBpbXBsZW1lbnRpbmcgbGlnaHRpbmcgbW9kZWxzLiBUaGUgbW9kdWxlIGRlZmluZXNcclxuICogbXVsdGlwbGUgbWV0aG9kcyB0aGF0IGNvbmNyZXRlIGxpZ2h0aW5nIG1vZGVscyBjYW4gaW1wbGVtZW50LiBUaGVzZVxyXG4gKiBtZXRob2RzIGFyZSBleGVjdXRlZCBhdCBkaWZmZXJlbnQgcG9pbnRzIGR1cmluZyB0aGUgbGlnaHQgZXZhbHVhdGlvblxyXG4gKiBwcm9jZXNzLlxyXG4gKi9cclxuY2xhc3MgTGlnaHRpbmdNb2RlbCB7XHJcblxyXG5cdC8qKlxyXG5cdCAqIFRoaXMgbWV0aG9kIGlzIGludGVuZGVkIGZvciBzZXR0aW5nIHVwIGxpZ2h0aW5nIG1vZGVsIGFuZCBjb250ZXh0IGRhdGFcclxuXHQgKiB3aGljaCBhcmUgbGF0ZXIgdXNlZCBpbiB0aGUgZXZhbHVhdGlvbiBwcm9jZXNzLlxyXG5cdCAqXHJcblx0ICogQGFic3RyYWN0XHJcblx0ICogQHBhcmFtIHtDb250ZXh0Tm9kZX0gaW5wdXQgLSBUaGUgY3VycmVudCBub2RlIGNvbnRleHQuXHJcblx0ICogQHBhcmFtIHtTdGFja05vZGV9IHN0YWNrIC0gVGhlIGN1cnJlbnQgc3RhY2suXHJcblx0ICogQHBhcmFtIHtOb2RlQnVpbGRlcn0gYnVpbGRlciAtIFRoZSBjdXJyZW50IG5vZGUgYnVpbGRlci5cclxuXHQgKi9cclxuXHRzdGFydCggLyppbnB1dCwgc3RhY2ssIGJ1aWxkZXIqLyApIHsgfVxyXG5cclxuXHQvKipcclxuXHQgKiBUaGlzIG1ldGhvZCBpcyBpbnRlbmRlZCBmb3IgZXhlY3V0aW5nIGZpbmFsIHRhc2tzIGxpa2UgZmluYWwgdXBkYXRlc1xyXG5cdCAqIHRvIHRoZSBvdXRnb2luZyBsaWdodC5cclxuXHQgKlxyXG5cdCAqIEBhYnN0cmFjdFxyXG5cdCAqIEBwYXJhbSB7Q29udGV4dE5vZGV9IGlucHV0IC0gVGhlIGN1cnJlbnQgbm9kZSBjb250ZXh0LlxyXG5cdCAqIEBwYXJhbSB7U3RhY2tOb2RlfSBzdGFjayAtIFRoZSBjdXJyZW50IHN0YWNrLlxyXG5cdCAqIEBwYXJhbSB7Tm9kZUJ1aWxkZXJ9IGJ1aWxkZXIgLSBUaGUgY3VycmVudCBub2RlIGJ1aWxkZXIuXHJcblx0ICovXHJcblx0ZmluaXNoKCAvKmlucHV0LCBzdGFjaywgYnVpbGRlciovICkgeyB9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFRoaXMgbWV0aG9kIGlzIGludGVuZGVkIGZvciBpbXBsZW1lbnRpbmcgdGhlIGRpcmVjdCBsaWdodCB0ZXJtIGFuZFxyXG5cdCAqIGV4ZWN1dGVkIGR1cmluZyB0aGUgYnVpbGQgcHJvY2VzcyBvZiBkaXJlY3Rpb25hbCwgcG9pbnQgYW5kIHNwb3QgbGlnaHQgbm9kZXMuXHJcblx0ICpcclxuXHQgKiBAYWJzdHJhY3RcclxuXHQgKiBAcGFyYW0ge09iamVjdH0gaW5wdXQgLSBUaGUgaW5wdXQgZGF0YS5cclxuXHQgKiBAcGFyYW0ge1N0YWNrTm9kZX0gc3RhY2sgLSBUaGUgY3VycmVudCBzdGFjay5cclxuXHQgKiBAcGFyYW0ge05vZGVCdWlsZGVyfSBidWlsZGVyIC0gVGhlIGN1cnJlbnQgbm9kZSBidWlsZGVyLlxyXG5cdCAqL1xyXG5cdGRpcmVjdCggLyppbnB1dCwgc3RhY2ssIGJ1aWxkZXIqLyApIHsgfVxyXG5cclxuXHQvKipcclxuXHQgKiBUaGlzIG1ldGhvZCBpcyBpbnRlbmRlZCBmb3IgaW1wbGVtZW50aW5nIHRoZSBkaXJlY3QgbGlnaHQgdGVybSBmb3JcclxuXHQgKiByZWN0IGFyZWEgbGlnaHQgbm9kZXMuXHJcblx0ICpcclxuXHQgKiBAYWJzdHJhY3RcclxuXHQgKiBAcGFyYW0ge09iamVjdH0gaW5wdXQgLSBUaGUgaW5wdXQgZGF0YS5cclxuXHQgKiBAcGFyYW0ge1N0YWNrTm9kZX0gc3RhY2sgLSBUaGUgY3VycmVudCBzdGFjay5cclxuXHQgKiBAcGFyYW0ge05vZGVCdWlsZGVyfSBidWlsZGVyIC0gVGhlIGN1cnJlbnQgbm9kZSBidWlsZGVyLlxyXG5cdCAqL1xyXG5cdGRpcmVjdFJlY3RBcmVhKCAvKmlucHV0LCBzdGFjaywgYnVpbGRlciovICkge31cclxuXHJcblx0LyoqXHJcblx0ICogVGhpcyBtZXRob2QgaXMgaW50ZW5kZWQgZm9yIGltcGxlbWVudGluZyB0aGUgaW5kaXJlY3QgbGlnaHQgdGVybS5cclxuXHQgKlxyXG5cdCAqIEBhYnN0cmFjdFxyXG5cdCAqIEBwYXJhbSB7Q29udGV4dE5vZGV9IGlucHV0IC0gVGhlIGN1cnJlbnQgbm9kZSBjb250ZXh0LlxyXG5cdCAqIEBwYXJhbSB7U3RhY2tOb2RlfSBzdGFjayAtIFRoZSBjdXJyZW50IHN0YWNrLlxyXG5cdCAqIEBwYXJhbSB7Tm9kZUJ1aWxkZXJ9IGJ1aWxkZXIgLSBUaGUgY3VycmVudCBub2RlIGJ1aWxkZXIuXHJcblx0ICovXHJcblx0aW5kaXJlY3QoIC8qaW5wdXQsIHN0YWNrLCBidWlsZGVyKi8gKSB7IH1cclxuXHJcblx0LyoqXHJcblx0ICogVGhpcyBtZXRob2QgaXMgaW50ZW5kZWQgZm9yIGltcGxlbWVudGluZyB0aGUgYW1iaWVudCBvY2NsdXNpb24gdGVybS5cclxuXHQgKiBVbmxpa2Ugb3RoZXIgbWV0aG9kcywgdGhpcyBtZXRob2QgbXVzdCBiZSBjYWxsZWQgbWFudWFsbHkgYnkgdGhlIGxpZ2h0aW5nXHJcblx0ICogbW9kZWwgaW4gaXRzIGluZGlyZWN0IHRlcm0uXHJcblx0ICpcclxuXHQgKiBAYWJzdHJhY3RcclxuXHQgKiBAcGFyYW0ge0NvbnRleHROb2RlfSBpbnB1dCAtIFRoZSBjdXJyZW50IG5vZGUgY29udGV4dC5cclxuXHQgKiBAcGFyYW0ge1N0YWNrTm9kZX0gc3RhY2sgLSBUaGUgY3VycmVudCBzdGFjay5cclxuXHQgKiBAcGFyYW0ge05vZGVCdWlsZGVyfSBidWlsZGVyIC0gVGhlIGN1cnJlbnQgbm9kZSBidWlsZGVyLlxyXG5cdCAqL1xyXG5cdGFtYmllbnRPY2NsdXNpb24oIC8qaW5wdXQsIHN0YWNrLCBidWlsZGVyKi8gKSB7IH1cclxuXHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IExpZ2h0aW5nTW9kZWw7XHJcbiIsImltcG9ydCBMaWdodGluZ01vZGVsIGZyb20gJy4uL2NvcmUvTGlnaHRpbmdNb2RlbC5qcyc7XHJcbmltcG9ydCB7IGRpZmZ1c2VDb2xvciB9IGZyb20gJy4uL2NvcmUvUHJvcGVydHlOb2RlLmpzJztcclxuaW1wb3J0IHsgTXVsdGlwbHlPcGVyYXRpb24sIE1peE9wZXJhdGlvbiwgQWRkT3BlcmF0aW9uIH0gZnJvbSAnLi4vLi4vY29uc3RhbnRzLmpzJztcclxuaW1wb3J0IHsgbWF0ZXJpYWxTcGVjdWxhclN0cmVuZ3RoLCBtYXRlcmlhbFJlZmxlY3Rpdml0eSB9IGZyb20gJy4uL2FjY2Vzc29ycy9NYXRlcmlhbE5vZGUuanMnO1xyXG5pbXBvcnQgeyBtaXggfSBmcm9tICcuLi9tYXRoL01hdGhOb2RlLmpzJztcclxuaW1wb3J0IHsgdmVjNCB9IGZyb20gJy4uL3RzbC9UU0xCYXNlLmpzJztcclxuXHJcbi8qKlxyXG4gKiBSZXByZXNlbnRzIHRoZSBsaWdodGluZyBtb2RlbCBmb3IgdW5saXQgbWF0ZXJpYWxzLiBUaGUgb25seSBsaWdodCBjb250cmlidXRpb25cclxuICogaXMgYmFrZWQgaW5kaXJlY3QgbGlnaHRpbmcgbW9kdWxhdGVkIHdpdGggYW1iaWVudCBvY2NsdXNpb24gYW5kIHRoZSBtYXRlcmlhbCdzXHJcbiAqIGRpZmZ1c2UgY29sb3IuIEVudmlyb25tZW50IG1hcHBpbmcgaXMgc3VwcG9ydGVkLiBVc2VkIGluIHtAbGluayBNZXNoQmFzaWNOb2RlTWF0ZXJpYWx9LlxyXG4gKlxyXG4gKiBAYXVnbWVudHMgTGlnaHRpbmdNb2RlbFxyXG4gKi9cclxuY2xhc3MgQmFzaWNMaWdodGluZ01vZGVsIGV4dGVuZHMgTGlnaHRpbmdNb2RlbCB7XHJcblxyXG5cdC8qKlxyXG5cdCAqIENvbnN0cnVjdHMgYSBuZXcgYmFzaWMgbGlnaHRpbmcgbW9kZWwuXHJcblx0ICovXHJcblx0Y29uc3RydWN0b3IoKSB7XHJcblxyXG5cdFx0c3VwZXIoKTtcclxuXHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBJbXBsZW1lbnRzIHRoZSBiYWtlZCBpbmRpcmVjdCBsaWdodGluZyB3aXRoIGl0cyBtb2R1bGF0aW9uLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtDb250ZXh0Tm9kZX0gY29udGV4dCAtIFRoZSBjdXJyZW50IG5vZGUgY29udGV4dC5cclxuXHQgKiBAcGFyYW0ge1N0YWNrTm9kZX0gc3RhY2sgLSBUaGUgY3VycmVudCBzdGFjay5cclxuXHQgKiBAcGFyYW0ge05vZGVCdWlsZGVyfSBidWlsZGVyIC0gVGhlIGN1cnJlbnQgbm9kZSBidWlsZGVyLlxyXG5cdCAqL1xyXG5cdGluZGlyZWN0KCBjb250ZXh0LCBzdGFjaywgYnVpbGRlciApIHtcclxuXHJcblx0XHRjb25zdCBhbWJpZW50T2NjbHVzaW9uID0gY29udGV4dC5hbWJpZW50T2NjbHVzaW9uO1xyXG5cdFx0Y29uc3QgcmVmbGVjdGVkTGlnaHQgPSBjb250ZXh0LnJlZmxlY3RlZExpZ2h0O1xyXG5cdFx0Y29uc3QgaXJyYWRpYW5jZUxpZ2h0TWFwID0gYnVpbGRlci5jb250ZXh0LmlycmFkaWFuY2VMaWdodE1hcDtcclxuXHJcblx0XHRyZWZsZWN0ZWRMaWdodC5pbmRpcmVjdERpZmZ1c2UuYXNzaWduKCB2ZWM0KCAwLjAgKSApO1xyXG5cclxuXHRcdC8vIGFjY3VtdWxhdGlvbiAoYmFrZWQgaW5kaXJlY3QgbGlnaHRpbmcgb25seSlcclxuXHJcblx0XHRpZiAoIGlycmFkaWFuY2VMaWdodE1hcCApIHtcclxuXHJcblx0XHRcdHJlZmxlY3RlZExpZ2h0LmluZGlyZWN0RGlmZnVzZS5hZGRBc3NpZ24oIGlycmFkaWFuY2VMaWdodE1hcCApO1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRyZWZsZWN0ZWRMaWdodC5pbmRpcmVjdERpZmZ1c2UuYWRkQXNzaWduKCB2ZWM0KCAxLjAsIDEuMCwgMS4wLCAwLjAgKSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvLyBtb2R1bGF0aW9uXHJcblxyXG5cdFx0cmVmbGVjdGVkTGlnaHQuaW5kaXJlY3REaWZmdXNlLm11bEFzc2lnbiggYW1iaWVudE9jY2x1c2lvbiApO1xyXG5cclxuXHRcdHJlZmxlY3RlZExpZ2h0LmluZGlyZWN0RGlmZnVzZS5tdWxBc3NpZ24oIGRpZmZ1c2VDb2xvci5yZ2IgKTtcclxuXHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBJbXBsZW1lbnRzIHRoZSBlbnZpcm9ubWVudCBtYXBwaW5nLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtDb250ZXh0Tm9kZX0gY29udGV4dCAtIFRoZSBjdXJyZW50IG5vZGUgY29udGV4dC5cclxuXHQgKiBAcGFyYW0ge1N0YWNrTm9kZX0gc3RhY2sgLSBUaGUgY3VycmVudCBzdGFjay5cclxuXHQgKiBAcGFyYW0ge05vZGVCdWlsZGVyfSBidWlsZGVyIC0gVGhlIGN1cnJlbnQgbm9kZSBidWlsZGVyLlxyXG5cdCAqL1xyXG5cdGZpbmlzaCggY29udGV4dCwgc3RhY2ssIGJ1aWxkZXIgKSB7XHJcblxyXG5cdFx0Y29uc3QgbWF0ZXJpYWwgPSBidWlsZGVyLm1hdGVyaWFsO1xyXG5cdFx0Y29uc3Qgb3V0Z29pbmdMaWdodCA9IGNvbnRleHQub3V0Z29pbmdMaWdodDtcclxuXHRcdGNvbnN0IGVudk5vZGUgPSBidWlsZGVyLmNvbnRleHQuZW52aXJvbm1lbnQ7XHJcblxyXG5cdFx0aWYgKCBlbnZOb2RlICkge1xyXG5cclxuXHRcdFx0c3dpdGNoICggbWF0ZXJpYWwuY29tYmluZSApIHtcclxuXHJcblx0XHRcdFx0Y2FzZSBNdWx0aXBseU9wZXJhdGlvbjpcclxuXHRcdFx0XHRcdG91dGdvaW5nTGlnaHQucmdiLmFzc2lnbiggbWl4KCBvdXRnb2luZ0xpZ2h0LnJnYiwgb3V0Z29pbmdMaWdodC5yZ2IubXVsKCBlbnZOb2RlLnJnYiApLCBtYXRlcmlhbFNwZWN1bGFyU3RyZW5ndGgubXVsKCBtYXRlcmlhbFJlZmxlY3Rpdml0eSApICkgKTtcclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRjYXNlIE1peE9wZXJhdGlvbjpcclxuXHRcdFx0XHRcdG91dGdvaW5nTGlnaHQucmdiLmFzc2lnbiggbWl4KCBvdXRnb2luZ0xpZ2h0LnJnYiwgZW52Tm9kZS5yZ2IsIG1hdGVyaWFsU3BlY3VsYXJTdHJlbmd0aC5tdWwoIG1hdGVyaWFsUmVmbGVjdGl2aXR5ICkgKSApO1xyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdGNhc2UgQWRkT3BlcmF0aW9uOlxyXG5cdFx0XHRcdFx0b3V0Z29pbmdMaWdodC5yZ2IuYWRkQXNzaWduKCBlbnZOb2RlLnJnYi5tdWwoIG1hdGVyaWFsU3BlY3VsYXJTdHJlbmd0aC5tdWwoIG1hdGVyaWFsUmVmbGVjdGl2aXR5ICkgKSApO1xyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdGRlZmF1bHQ6XHJcblx0XHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5CYXNpY0xpZ2h0aW5nTW9kZWw6IFVuc3VwcG9ydGVkIC5jb21iaW5lIHZhbHVlOicsIG1hdGVyaWFsLmNvbWJpbmUgKTtcclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgQmFzaWNMaWdodGluZ01vZGVsO1xyXG4iLCJpbXBvcnQgTm9kZU1hdGVyaWFsIGZyb20gJy4vTm9kZU1hdGVyaWFsLmpzJztcclxuaW1wb3J0IHsgbWF0ZXJpYWxMaWdodE1hcCB9IGZyb20gJy4uLy4uL25vZGVzL2FjY2Vzc29ycy9NYXRlcmlhbE5vZGUuanMnO1xyXG5pbXBvcnQgQmFzaWNFbnZpcm9ubWVudE5vZGUgZnJvbSAnLi4vLi4vbm9kZXMvbGlnaHRpbmcvQmFzaWNFbnZpcm9ubWVudE5vZGUuanMnO1xyXG5pbXBvcnQgQmFzaWNMaWdodE1hcE5vZGUgZnJvbSAnLi4vLi4vbm9kZXMvbGlnaHRpbmcvQmFzaWNMaWdodE1hcE5vZGUuanMnO1xyXG5pbXBvcnQgQmFzaWNMaWdodGluZ01vZGVsIGZyb20gJy4uLy4uL25vZGVzL2Z1bmN0aW9ucy9CYXNpY0xpZ2h0aW5nTW9kZWwuanMnO1xyXG5pbXBvcnQgeyBub3JtYWxWaWV3IH0gZnJvbSAnLi4vLi4vbm9kZXMvYWNjZXNzb3JzL05vcm1hbC5qcyc7XHJcbmltcG9ydCB7IGRpZmZ1c2VDb2xvciB9IGZyb20gJy4uLy4uL25vZGVzL2NvcmUvUHJvcGVydHlOb2RlLmpzJztcclxuXHJcbmltcG9ydCB7IE1lc2hCYXNpY01hdGVyaWFsIH0gZnJvbSAnLi4vTWVzaEJhc2ljTWF0ZXJpYWwuanMnO1xyXG5cclxuY29uc3QgX2RlZmF1bHRWYWx1ZXMgPSAvKkBfX1BVUkVfXyovIG5ldyBNZXNoQmFzaWNNYXRlcmlhbCgpO1xyXG5cclxuY2xhc3MgTWVzaEJhc2ljTm9kZU1hdGVyaWFsIGV4dGVuZHMgTm9kZU1hdGVyaWFsIHtcclxuXHJcblx0c3RhdGljIGdldCB0eXBlKCkge1xyXG5cclxuXHRcdHJldHVybiAnTWVzaEJhc2ljTm9kZU1hdGVyaWFsJztcclxuXHJcblx0fVxyXG5cclxuXHRjb25zdHJ1Y3RvciggcGFyYW1ldGVycyApIHtcclxuXHJcblx0XHRzdXBlcigpO1xyXG5cclxuXHRcdHRoaXMuaXNNZXNoQmFzaWNOb2RlTWF0ZXJpYWwgPSB0cnVlO1xyXG5cclxuXHRcdHRoaXMubGlnaHRzID0gdHJ1ZTtcclxuXHJcblx0XHR0aGlzLnNldERlZmF1bHRWYWx1ZXMoIF9kZWZhdWx0VmFsdWVzICk7XHJcblxyXG5cdFx0dGhpcy5zZXRWYWx1ZXMoIHBhcmFtZXRlcnMgKTtcclxuXHJcblx0fVxyXG5cclxuXHRzZXR1cE5vcm1hbCgpIHtcclxuXHJcblx0XHRyZXR1cm4gbm9ybWFsVmlldzsgLy8gc2VlICMyODgzOVxyXG5cclxuXHR9XHJcblxyXG5cdHNldHVwRW52aXJvbm1lbnQoIGJ1aWxkZXIgKSB7XHJcblxyXG5cdFx0Y29uc3QgZW52Tm9kZSA9IHN1cGVyLnNldHVwRW52aXJvbm1lbnQoIGJ1aWxkZXIgKTtcclxuXHJcblx0XHRyZXR1cm4gZW52Tm9kZSA/IG5ldyBCYXNpY0Vudmlyb25tZW50Tm9kZSggZW52Tm9kZSApIDogbnVsbDtcclxuXHJcblx0fVxyXG5cclxuXHRzZXR1cExpZ2h0TWFwKCBidWlsZGVyICkge1xyXG5cclxuXHRcdGxldCBub2RlID0gbnVsbDtcclxuXHJcblx0XHRpZiAoIGJ1aWxkZXIubWF0ZXJpYWwubGlnaHRNYXAgKSB7XHJcblxyXG5cdFx0XHRub2RlID0gbmV3IEJhc2ljTGlnaHRNYXBOb2RlKCBtYXRlcmlhbExpZ2h0TWFwICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBub2RlO1xyXG5cclxuXHR9XHJcblxyXG5cdHNldHVwT3V0Z29pbmdMaWdodCgpIHtcclxuXHJcblx0XHRyZXR1cm4gZGlmZnVzZUNvbG9yLnJnYjtcclxuXHJcblx0fVxyXG5cclxuXHRzZXR1cExpZ2h0aW5nTW9kZWwoKSB7XHJcblxyXG5cdFx0cmV0dXJuIG5ldyBCYXNpY0xpZ2h0aW5nTW9kZWwoKTtcclxuXHJcblx0fVxyXG5cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgTWVzaEJhc2ljTm9kZU1hdGVyaWFsO1xyXG4iLCJpbXBvcnQgeyBGbiB9IGZyb20gJy4uLy4uL3RzbC9UU0xCYXNlLmpzJztcclxuXHJcbmNvbnN0IEZfU2NobGljayA9IC8qQF9fUFVSRV9fKi8gRm4oICggeyBmMCwgZjkwLCBkb3RWSCB9ICkgPT4ge1xyXG5cclxuXHQvLyBPcmlnaW5hbCBhcHByb3hpbWF0aW9uIGJ5IENocmlzdG9waGUgU2NobGljayAnOTRcclxuXHQvLyBmbG9hdCBmcmVzbmVsID0gcG93KCAxLjAgLSBkb3RWSCwgNS4wICk7XHJcblxyXG5cdC8vIE9wdGltaXplZCB2YXJpYW50IChwcmVzZW50ZWQgYnkgRXBpYyBhdCBTSUdHUkFQSCAnMTMpXHJcblx0Ly8gaHR0cHM6Ly9jZG4yLnVucmVhbGVuZ2luZS5jb20vUmVzb3VyY2VzL2ZpbGVzLzIwMTNTaWdncmFwaFByZXNlbnRhdGlvbnNOb3Rlcy0yNjkxNTczOC5wZGZcclxuXHRjb25zdCBmcmVzbmVsID0gZG90VkgubXVsKCAtIDUuNTU0NzMgKS5zdWIoIDYuOTgzMTYgKS5tdWwoIGRvdFZIICkuZXhwMigpO1xyXG5cclxuXHRyZXR1cm4gZjAubXVsKCBmcmVzbmVsLm9uZU1pbnVzKCkgKS5hZGQoIGY5MC5tdWwoIGZyZXNuZWwgKSApO1xyXG5cclxufSApOyAvLyB2YWxpZGF0ZWRcclxuXHJcbmV4cG9ydCBkZWZhdWx0IEZfU2NobGljaztcclxuIiwiaW1wb3J0IHsgRm4gfSBmcm9tICcuLi8uLi90c2wvVFNMQmFzZS5qcyc7XHJcblxyXG5jb25zdCBCUkRGX0xhbWJlcnQgPSAvKkBfX1BVUkVfXyovIEZuKCAoIGlucHV0cyApID0+IHtcclxuXHJcblx0cmV0dXJuIGlucHV0cy5kaWZmdXNlQ29sb3IubXVsKCAxIC8gTWF0aC5QSSApOyAvLyBwdW5jdHVhbCBsaWdodFxyXG5cclxufSApOyAvLyB2YWxpZGF0ZWRcclxuXHJcbmV4cG9ydCBkZWZhdWx0IEJSREZfTGFtYmVydDtcclxuIiwiaW1wb3J0IEJhc2ljTGlnaHRpbmdNb2RlbCBmcm9tICcuL0Jhc2ljTGlnaHRpbmdNb2RlbC5qcyc7XHJcbmltcG9ydCBGX1NjaGxpY2sgZnJvbSAnLi9CU0RGL0ZfU2NobGljay5qcyc7XHJcbmltcG9ydCBCUkRGX0xhbWJlcnQgZnJvbSAnLi9CU0RGL0JSREZfTGFtYmVydC5qcyc7XHJcbmltcG9ydCB7IGRpZmZ1c2VDb2xvciwgc2hpbmluZXNzLCBzcGVjdWxhckNvbG9yIH0gZnJvbSAnLi4vY29yZS9Qcm9wZXJ0eU5vZGUuanMnO1xyXG5pbXBvcnQgeyB0cmFuc2Zvcm1lZE5vcm1hbFZpZXcgfSBmcm9tICcuLi9hY2Nlc3NvcnMvTm9ybWFsLmpzJztcclxuaW1wb3J0IHsgbWF0ZXJpYWxTcGVjdWxhclN0cmVuZ3RoIH0gZnJvbSAnLi4vYWNjZXNzb3JzL01hdGVyaWFsTm9kZS5qcyc7XHJcbmltcG9ydCB7IHBvc2l0aW9uVmlld0RpcmVjdGlvbiB9IGZyb20gJy4uL2FjY2Vzc29ycy9Qb3NpdGlvbi5qcyc7XHJcbmltcG9ydCB7IEZuLCBmbG9hdCB9IGZyb20gJy4uL3RzbC9UU0xCYXNlLmpzJztcclxuXHJcbmNvbnN0IEdfQmxpbm5QaG9uZ19JbXBsaWNpdCA9ICgpID0+IGZsb2F0KCAwLjI1ICk7XHJcblxyXG5jb25zdCBEX0JsaW5uUGhvbmcgPSAvKkBfX1BVUkVfXyovIEZuKCAoIHsgZG90TkggfSApID0+IHtcclxuXHJcblx0cmV0dXJuIHNoaW5pbmVzcy5tdWwoIGZsb2F0KCAwLjUgKSApLmFkZCggMS4wICkubXVsKCBmbG9hdCggMSAvIE1hdGguUEkgKSApLm11bCggZG90TkgucG93KCBzaGluaW5lc3MgKSApO1xyXG5cclxufSApO1xyXG5cclxuY29uc3QgQlJERl9CbGlublBob25nID0gLypAX19QVVJFX18qLyBGbiggKCB7IGxpZ2h0RGlyZWN0aW9uIH0gKSA9PiB7XHJcblxyXG5cdGNvbnN0IGhhbGZEaXIgPSBsaWdodERpcmVjdGlvbi5hZGQoIHBvc2l0aW9uVmlld0RpcmVjdGlvbiApLm5vcm1hbGl6ZSgpO1xyXG5cclxuXHRjb25zdCBkb3ROSCA9IHRyYW5zZm9ybWVkTm9ybWFsVmlldy5kb3QoIGhhbGZEaXIgKS5jbGFtcCgpO1xyXG5cdGNvbnN0IGRvdFZIID0gcG9zaXRpb25WaWV3RGlyZWN0aW9uLmRvdCggaGFsZkRpciApLmNsYW1wKCk7XHJcblxyXG5cdGNvbnN0IEYgPSBGX1NjaGxpY2soIHsgZjA6IHNwZWN1bGFyQ29sb3IsIGY5MDogMS4wLCBkb3RWSCB9ICk7XHJcblx0Y29uc3QgRyA9IEdfQmxpbm5QaG9uZ19JbXBsaWNpdCgpO1xyXG5cdGNvbnN0IEQgPSBEX0JsaW5uUGhvbmcoIHsgZG90TkggfSApO1xyXG5cclxuXHRyZXR1cm4gRi5tdWwoIEcgKS5tdWwoIEQgKTtcclxuXHJcbn0gKTtcclxuXHJcbi8qKlxyXG4gKiBSZXByZXNlbnRzIHRoZSBsaWdodGluZyBtb2RlbCBmb3IgYSBwaG9uZyBtYXRlcmlhbC4gVXNlZCBpbiB7QGxpbmsgTWVzaFBob25nTm9kZU1hdGVyaWFsfS5cclxuICpcclxuICogQGF1Z21lbnRzIEJhc2ljTGlnaHRpbmdNb2RlbFxyXG4gKi9cclxuY2xhc3MgUGhvbmdMaWdodGluZ01vZGVsIGV4dGVuZHMgQmFzaWNMaWdodGluZ01vZGVsIHtcclxuXHJcblx0LyoqXHJcblx0ICogQ29uc3RydWN0cyBhIG5ldyBwaG9uZyBsaWdodGluZyBtb2RlbC5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gW3NwZWN1bGFyPXRydWVdIC0gV2hldGhlciBzcGVjdWxhciBpcyBzdXBwb3J0ZWQgb3Igbm90LlxyXG5cdCAqL1xyXG5cdGNvbnN0cnVjdG9yKCBzcGVjdWxhciA9IHRydWUgKSB7XHJcblxyXG5cdFx0c3VwZXIoKTtcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIFdoZXRoZXIgc3BlY3VsYXIgaXMgc3VwcG9ydGVkIG9yIG5vdC4gU2V0IHRoaXMgdG8gYGZhbHNlYCBpZiB5b3UgYXJlXHJcblx0XHQgKiBsb29raW5nIGZvciBhIExhbWJlcnQtbGlrZSBtYXRlcmlhbCBtZWFuaW5nIGEgbWF0ZXJpYWwgZm9yIG5vbi1zaGlueVxyXG5cdFx0ICogc3VyZmFjZXMsIHdpdGhvdXQgc3BlY3VsYXIgaGlnaGxpZ2h0cy5cclxuXHRcdCAqXHJcblx0XHQgKiBAdHlwZSB7Qm9vbGVhbn1cclxuXHRcdCAqIEBkZWZhdWx0IHRydWVcclxuXHRcdCAqL1xyXG5cdFx0dGhpcy5zcGVjdWxhciA9IHNwZWN1bGFyO1xyXG5cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEltcGxlbWVudHMgdGhlIGRpcmVjdCBsaWdodGluZy4gVGhlIHNwZWN1bGFyIHBvcnRpb24gaXMgb3B0aW9uYWwgYW4gY2FuIGJlIGNvbnRyb2xsZWRcclxuXHQgKiB3aXRoIHRoZSB7QGxpbmsgUGhvbmdMaWdodGluZ01vZGVsI3NwZWN1bGFyfSBmbGFnLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtPYmplY3R9IGlucHV0IC0gVGhlIGlucHV0IGRhdGEuXHJcblx0ICogQHBhcmFtIHtTdGFja05vZGV9IHN0YWNrIC0gVGhlIGN1cnJlbnQgc3RhY2suXHJcblx0ICogQHBhcmFtIHtOb2RlQnVpbGRlcn0gYnVpbGRlciAtIFRoZSBjdXJyZW50IG5vZGUgYnVpbGRlci5cclxuXHQgKi9cclxuXHRkaXJlY3QoIHsgbGlnaHREaXJlY3Rpb24sIGxpZ2h0Q29sb3IsIHJlZmxlY3RlZExpZ2h0IH0gKSB7XHJcblxyXG5cdFx0Y29uc3QgZG90TkwgPSB0cmFuc2Zvcm1lZE5vcm1hbFZpZXcuZG90KCBsaWdodERpcmVjdGlvbiApLmNsYW1wKCk7XHJcblx0XHRjb25zdCBpcnJhZGlhbmNlID0gZG90TkwubXVsKCBsaWdodENvbG9yICk7XHJcblxyXG5cdFx0cmVmbGVjdGVkTGlnaHQuZGlyZWN0RGlmZnVzZS5hZGRBc3NpZ24oIGlycmFkaWFuY2UubXVsKCBCUkRGX0xhbWJlcnQoIHsgZGlmZnVzZUNvbG9yOiBkaWZmdXNlQ29sb3IucmdiIH0gKSApICk7XHJcblxyXG5cdFx0aWYgKCB0aGlzLnNwZWN1bGFyID09PSB0cnVlICkge1xyXG5cclxuXHRcdFx0cmVmbGVjdGVkTGlnaHQuZGlyZWN0U3BlY3VsYXIuYWRkQXNzaWduKCBpcnJhZGlhbmNlLm11bCggQlJERl9CbGlublBob25nKCB7IGxpZ2h0RGlyZWN0aW9uIH0gKSApLm11bCggbWF0ZXJpYWxTcGVjdWxhclN0cmVuZ3RoICkgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogSW1wbGVtZW50cyB0aGUgaW5kaXJlY3QgbGlnaHRpbmcuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge0NvbnRleHROb2RlfSBpbnB1dCAtIFRoZSBjdXJyZW50IG5vZGUgY29udGV4dC5cclxuXHQgKiBAcGFyYW0ge1N0YWNrTm9kZX0gc3RhY2sgLSBUaGUgY3VycmVudCBzdGFjay5cclxuXHQgKiBAcGFyYW0ge05vZGVCdWlsZGVyfSBidWlsZGVyIC0gVGhlIGN1cnJlbnQgbm9kZSBidWlsZGVyLlxyXG5cdCAqL1xyXG5cdGluZGlyZWN0KCB7IGFtYmllbnRPY2NsdXNpb24sIGlycmFkaWFuY2UsIHJlZmxlY3RlZExpZ2h0IH0gKSB7XHJcblxyXG5cdFx0cmVmbGVjdGVkTGlnaHQuaW5kaXJlY3REaWZmdXNlLmFkZEFzc2lnbiggaXJyYWRpYW5jZS5tdWwoIEJSREZfTGFtYmVydCggeyBkaWZmdXNlQ29sb3IgfSApICkgKTtcclxuXHJcblx0XHRyZWZsZWN0ZWRMaWdodC5pbmRpcmVjdERpZmZ1c2UubXVsQXNzaWduKCBhbWJpZW50T2NjbHVzaW9uICk7XHJcblxyXG5cdH1cclxuXHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IFBob25nTGlnaHRpbmdNb2RlbDtcclxuIiwiaW1wb3J0IE5vZGVNYXRlcmlhbCBmcm9tICcuL05vZGVNYXRlcmlhbC5qcyc7XHJcbmltcG9ydCBCYXNpY0Vudmlyb25tZW50Tm9kZSBmcm9tICcuLi8uLi9ub2Rlcy9saWdodGluZy9CYXNpY0Vudmlyb25tZW50Tm9kZS5qcyc7XHJcbmltcG9ydCBQaG9uZ0xpZ2h0aW5nTW9kZWwgZnJvbSAnLi4vLi4vbm9kZXMvZnVuY3Rpb25zL1Bob25nTGlnaHRpbmdNb2RlbC5qcyc7XHJcblxyXG5pbXBvcnQgeyBNZXNoTGFtYmVydE1hdGVyaWFsIH0gZnJvbSAnLi4vTWVzaExhbWJlcnRNYXRlcmlhbC5qcyc7XHJcblxyXG5jb25zdCBfZGVmYXVsdFZhbHVlcyA9IC8qQF9fUFVSRV9fKi8gbmV3IE1lc2hMYW1iZXJ0TWF0ZXJpYWwoKTtcclxuXHJcbmNsYXNzIE1lc2hMYW1iZXJ0Tm9kZU1hdGVyaWFsIGV4dGVuZHMgTm9kZU1hdGVyaWFsIHtcclxuXHJcblx0c3RhdGljIGdldCB0eXBlKCkge1xyXG5cclxuXHRcdHJldHVybiAnTWVzaExhbWJlcnROb2RlTWF0ZXJpYWwnO1xyXG5cclxuXHR9XHJcblxyXG5cdGNvbnN0cnVjdG9yKCBwYXJhbWV0ZXJzICkge1xyXG5cclxuXHRcdHN1cGVyKCk7XHJcblxyXG5cdFx0dGhpcy5pc01lc2hMYW1iZXJ0Tm9kZU1hdGVyaWFsID0gdHJ1ZTtcclxuXHJcblx0XHR0aGlzLmxpZ2h0cyA9IHRydWU7XHJcblxyXG5cdFx0dGhpcy5zZXREZWZhdWx0VmFsdWVzKCBfZGVmYXVsdFZhbHVlcyApO1xyXG5cclxuXHRcdHRoaXMuc2V0VmFsdWVzKCBwYXJhbWV0ZXJzICk7XHJcblxyXG5cdH1cclxuXHJcblx0c2V0dXBFbnZpcm9ubWVudCggYnVpbGRlciApIHtcclxuXHJcblx0XHRjb25zdCBlbnZOb2RlID0gc3VwZXIuc2V0dXBFbnZpcm9ubWVudCggYnVpbGRlciApO1xyXG5cclxuXHRcdHJldHVybiBlbnZOb2RlID8gbmV3IEJhc2ljRW52aXJvbm1lbnROb2RlKCBlbnZOb2RlICkgOiBudWxsO1xyXG5cclxuXHR9XHJcblxyXG5cdHNldHVwTGlnaHRpbmdNb2RlbCggLypidWlsZGVyKi8gKSB7XHJcblxyXG5cdFx0cmV0dXJuIG5ldyBQaG9uZ0xpZ2h0aW5nTW9kZWwoIGZhbHNlICk7IC8vICggc3BlY3VsYXIgKSAtPiBmb3JjZSBsYW1iZXJ0XHJcblxyXG5cdH1cclxuXHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IE1lc2hMYW1iZXJ0Tm9kZU1hdGVyaWFsO1xyXG4iLCJpbXBvcnQgTm9kZU1hdGVyaWFsIGZyb20gJy4vTm9kZU1hdGVyaWFsLmpzJztcclxuaW1wb3J0IHsgc2hpbmluZXNzLCBzcGVjdWxhckNvbG9yIH0gZnJvbSAnLi4vLi4vbm9kZXMvY29yZS9Qcm9wZXJ0eU5vZGUuanMnO1xyXG5pbXBvcnQgeyBtYXRlcmlhbFNoaW5pbmVzcywgbWF0ZXJpYWxTcGVjdWxhciB9IGZyb20gJy4uLy4uL25vZGVzL2FjY2Vzc29ycy9NYXRlcmlhbE5vZGUuanMnO1xyXG5pbXBvcnQgeyBmbG9hdCB9IGZyb20gJy4uLy4uL25vZGVzL3RzbC9UU0xCYXNlLmpzJztcclxuaW1wb3J0IEJhc2ljRW52aXJvbm1lbnROb2RlIGZyb20gJy4uLy4uL25vZGVzL2xpZ2h0aW5nL0Jhc2ljRW52aXJvbm1lbnROb2RlLmpzJztcclxuaW1wb3J0IFBob25nTGlnaHRpbmdNb2RlbCBmcm9tICcuLi8uLi9ub2Rlcy9mdW5jdGlvbnMvUGhvbmdMaWdodGluZ01vZGVsLmpzJztcclxuXHJcbmltcG9ydCB7IE1lc2hQaG9uZ01hdGVyaWFsIH0gZnJvbSAnLi4vTWVzaFBob25nTWF0ZXJpYWwuanMnO1xyXG5cclxuY29uc3QgX2RlZmF1bHRWYWx1ZXMgPSAvKkBfX1BVUkVfXyovIG5ldyBNZXNoUGhvbmdNYXRlcmlhbCgpO1xyXG5cclxuY2xhc3MgTWVzaFBob25nTm9kZU1hdGVyaWFsIGV4dGVuZHMgTm9kZU1hdGVyaWFsIHtcclxuXHJcblx0c3RhdGljIGdldCB0eXBlKCkge1xyXG5cclxuXHRcdHJldHVybiAnTWVzaFBob25nTm9kZU1hdGVyaWFsJztcclxuXHJcblx0fVxyXG5cclxuXHRjb25zdHJ1Y3RvciggcGFyYW1ldGVycyApIHtcclxuXHJcblx0XHRzdXBlcigpO1xyXG5cclxuXHRcdHRoaXMuaXNNZXNoUGhvbmdOb2RlTWF0ZXJpYWwgPSB0cnVlO1xyXG5cclxuXHRcdHRoaXMubGlnaHRzID0gdHJ1ZTtcclxuXHJcblx0XHR0aGlzLnNoaW5pbmVzc05vZGUgPSBudWxsO1xyXG5cdFx0dGhpcy5zcGVjdWxhck5vZGUgPSBudWxsO1xyXG5cclxuXHRcdHRoaXMuc2V0RGVmYXVsdFZhbHVlcyggX2RlZmF1bHRWYWx1ZXMgKTtcclxuXHJcblx0XHR0aGlzLnNldFZhbHVlcyggcGFyYW1ldGVycyApO1xyXG5cclxuXHR9XHJcblxyXG5cdHNldHVwRW52aXJvbm1lbnQoIGJ1aWxkZXIgKSB7XHJcblxyXG5cdFx0Y29uc3QgZW52Tm9kZSA9IHN1cGVyLnNldHVwRW52aXJvbm1lbnQoIGJ1aWxkZXIgKTtcclxuXHJcblx0XHRyZXR1cm4gZW52Tm9kZSA/IG5ldyBCYXNpY0Vudmlyb25tZW50Tm9kZSggZW52Tm9kZSApIDogbnVsbDtcclxuXHJcblx0fVxyXG5cclxuXHRzZXR1cExpZ2h0aW5nTW9kZWwoIC8qYnVpbGRlciovICkge1xyXG5cclxuXHRcdHJldHVybiBuZXcgUGhvbmdMaWdodGluZ01vZGVsKCk7XHJcblxyXG5cdH1cclxuXHJcblx0c2V0dXBWYXJpYW50cygpIHtcclxuXHJcblx0XHQvLyBTSElOSU5FU1NcclxuXHJcblx0XHRjb25zdCBzaGluaW5lc3NOb2RlID0gKCB0aGlzLnNoaW5pbmVzc05vZGUgPyBmbG9hdCggdGhpcy5zaGluaW5lc3NOb2RlICkgOiBtYXRlcmlhbFNoaW5pbmVzcyApLm1heCggMWUtNCApOyAvLyB0byBwcmV2ZW50IHBvdyggMC4wLCAwLjAgKVxyXG5cclxuXHRcdHNoaW5pbmVzcy5hc3NpZ24oIHNoaW5pbmVzc05vZGUgKTtcclxuXHJcblx0XHQvLyBTUEVDVUxBUiBDT0xPUlxyXG5cclxuXHRcdGNvbnN0IHNwZWN1bGFyTm9kZSA9IHRoaXMuc3BlY3VsYXJOb2RlIHx8IG1hdGVyaWFsU3BlY3VsYXI7XHJcblxyXG5cdFx0c3BlY3VsYXJDb2xvci5hc3NpZ24oIHNwZWN1bGFyTm9kZSApO1xyXG5cclxuXHR9XHJcblxyXG5cdGNvcHkoIHNvdXJjZSApIHtcclxuXHJcblx0XHR0aGlzLnNoaW5pbmVzc05vZGUgPSBzb3VyY2Uuc2hpbmluZXNzTm9kZTtcclxuXHRcdHRoaXMuc3BlY3VsYXJOb2RlID0gc291cmNlLnNwZWN1bGFyTm9kZTtcclxuXHJcblx0XHRyZXR1cm4gc3VwZXIuY29weSggc291cmNlICk7XHJcblxyXG5cdH1cclxuXHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IE1lc2hQaG9uZ05vZGVNYXRlcmlhbDtcclxuIiwiaW1wb3J0IHsgbm9ybWFsVmlldyB9IGZyb20gJy4uLy4uL2FjY2Vzc29ycy9Ob3JtYWwuanMnO1xyXG5pbXBvcnQgeyBmbG9hdCwgRm4gfSBmcm9tICcuLi8uLi90c2wvVFNMQmFzZS5qcyc7XHJcblxyXG5jb25zdCBnZXRHZW9tZXRyeVJvdWdobmVzcyA9IC8qQF9fUFVSRV9fKi8gRm4oICggYnVpbGRlciApID0+IHtcclxuXHJcblx0aWYgKCBidWlsZGVyLmdlb21ldHJ5Lmhhc0F0dHJpYnV0ZSggJ25vcm1hbCcgKSA9PT0gZmFsc2UgKSB7XHJcblxyXG5cdFx0cmV0dXJuIGZsb2F0KCAwICk7XHJcblxyXG5cdH1cclxuXHJcblx0Y29uc3QgZHh5ID0gbm9ybWFsVmlldy5kRmR4KCkuYWJzKCkubWF4KCBub3JtYWxWaWV3LmRGZHkoKS5hYnMoKSApO1xyXG5cdGNvbnN0IGdlb21ldHJ5Um91Z2huZXNzID0gZHh5LngubWF4KCBkeHkueSApLm1heCggZHh5LnogKTtcclxuXHJcblx0cmV0dXJuIGdlb21ldHJ5Um91Z2huZXNzO1xyXG5cclxufSApO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgZ2V0R2VvbWV0cnlSb3VnaG5lc3M7XHJcbiIsImltcG9ydCBnZXRHZW9tZXRyeVJvdWdobmVzcyBmcm9tICcuL2dldEdlb21ldHJ5Um91Z2huZXNzLmpzJztcclxuaW1wb3J0IHsgRm4gfSBmcm9tICcuLi8uLi90c2wvVFNMQmFzZS5qcyc7XHJcblxyXG5jb25zdCBnZXRSb3VnaG5lc3MgPSAvKkBfX1BVUkVfXyovIEZuKCAoIGlucHV0cyApID0+IHtcclxuXHJcblx0Y29uc3QgeyByb3VnaG5lc3MgfSA9IGlucHV0cztcclxuXHJcblx0Y29uc3QgZ2VvbWV0cnlSb3VnaG5lc3MgPSBnZXRHZW9tZXRyeVJvdWdobmVzcygpO1xyXG5cclxuXHRsZXQgcm91Z2huZXNzRmFjdG9yID0gcm91Z2huZXNzLm1heCggMC4wNTI1ICk7IC8vIDAuMDUyNSBjb3JyZXNwb25kcyB0byB0aGUgYmFzZSBtaXAgb2YgYSAyNTYgY3ViZW1hcC5cclxuXHRyb3VnaG5lc3NGYWN0b3IgPSByb3VnaG5lc3NGYWN0b3IuYWRkKCBnZW9tZXRyeVJvdWdobmVzcyApO1xyXG5cdHJvdWdobmVzc0ZhY3RvciA9IHJvdWdobmVzc0ZhY3Rvci5taW4oIDEuMCApO1xyXG5cclxuXHRyZXR1cm4gcm91Z2huZXNzRmFjdG9yO1xyXG5cclxufSApO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgZ2V0Um91Z2huZXNzO1xyXG4iLCJpbXBvcnQgeyBkaXYgfSBmcm9tICcuLi8uLi9tYXRoL09wZXJhdG9yTm9kZS5qcyc7XHJcbmltcG9ydCB7IEVQU0lMT04gfSBmcm9tICcuLi8uLi9tYXRoL01hdGhOb2RlLmpzJztcclxuaW1wb3J0IHsgRm4gfSBmcm9tICcuLi8uLi90c2wvVFNMQmFzZS5qcyc7XHJcblxyXG4vLyBNb3ZpbmcgRnJvc3RiaXRlIHRvIFBoeXNpY2FsbHkgQmFzZWQgUmVuZGVyaW5nIDMuMCAtIHBhZ2UgMTIsIGxpc3RpbmcgMlxyXG4vLyBodHRwczovL3NlYmxhZ2FyZGUuZmlsZXMud29yZHByZXNzLmNvbS8yMDE1LzA3L2NvdXJzZV9ub3Rlc19tb3ZpbmdfZnJvc3RiaXRlX3RvX3Bicl92MzIucGRmXHJcbmNvbnN0IFZfR0dYX1NtaXRoQ29ycmVsYXRlZCA9IC8qQF9fUFVSRV9fKi8gRm4oICggeyBhbHBoYSwgZG90TkwsIGRvdE5WIH0gKSA9PiB7XHJcblxyXG5cdGNvbnN0IGEyID0gYWxwaGEucG93MigpO1xyXG5cclxuXHRjb25zdCBndiA9IGRvdE5MLm11bCggYTIuYWRkKCBhMi5vbmVNaW51cygpLm11bCggZG90TlYucG93MigpICkgKS5zcXJ0KCkgKTtcclxuXHRjb25zdCBnbCA9IGRvdE5WLm11bCggYTIuYWRkKCBhMi5vbmVNaW51cygpLm11bCggZG90TkwucG93MigpICkgKS5zcXJ0KCkgKTtcclxuXHJcblx0cmV0dXJuIGRpdiggMC41LCBndi5hZGQoIGdsICkubWF4KCBFUFNJTE9OICkgKTtcclxuXHJcbn0gKS5zZXRMYXlvdXQoIHtcclxuXHRuYW1lOiAnVl9HR1hfU21pdGhDb3JyZWxhdGVkJyxcclxuXHR0eXBlOiAnZmxvYXQnLFxyXG5cdGlucHV0czogW1xyXG5cdFx0eyBuYW1lOiAnYWxwaGEnLCB0eXBlOiAnZmxvYXQnIH0sXHJcblx0XHR7IG5hbWU6ICdkb3ROTCcsIHR5cGU6ICdmbG9hdCcgfSxcclxuXHRcdHsgbmFtZTogJ2RvdE5WJywgdHlwZTogJ2Zsb2F0JyB9XHJcblx0XVxyXG59ICk7IC8vIHZhbGlkYXRlZFxyXG5cclxuZXhwb3J0IGRlZmF1bHQgVl9HR1hfU21pdGhDb3JyZWxhdGVkO1xyXG4iLCJpbXBvcnQgeyBkaXYgfSBmcm9tICcuLi8uLi9tYXRoL09wZXJhdG9yTm9kZS5qcyc7XHJcbmltcG9ydCB7IEZuLCB2ZWMzIH0gZnJvbSAnLi4vLi4vdHNsL1RTTEJhc2UuanMnO1xyXG5cclxuLy8gaHR0cHM6Ly9nb29nbGUuZ2l0aHViLmlvL2ZpbGFtZW50L0ZpbGFtZW50Lm1kLmh0bWwjbWF0ZXJpYWxzeXN0ZW0vYW5pc290cm9waWNtb2RlbC9hbmlzb3Ryb3BpY3NwZWN1bGFyYnJkZlxyXG5cclxuY29uc3QgVl9HR1hfU21pdGhDb3JyZWxhdGVkX0FuaXNvdHJvcGljID0gLypAX19QVVJFX18qLyBGbiggKCB7IGFscGhhVCwgYWxwaGFCLCBkb3RUViwgZG90QlYsIGRvdFRMLCBkb3RCTCwgZG90TlYsIGRvdE5MIH0gKSA9PiB7XHJcblxyXG5cdGNvbnN0IGd2ID0gZG90TkwubXVsKCB2ZWMzKCBhbHBoYVQubXVsKCBkb3RUViApLCBhbHBoYUIubXVsKCBkb3RCViApLCBkb3ROViApLmxlbmd0aCgpICk7XHJcblx0Y29uc3QgZ2wgPSBkb3ROVi5tdWwoIHZlYzMoIGFscGhhVC5tdWwoIGRvdFRMICksIGFscGhhQi5tdWwoIGRvdEJMICksIGRvdE5MICkubGVuZ3RoKCkgKTtcclxuXHRjb25zdCB2ID0gZGl2KCAwLjUsIGd2LmFkZCggZ2wgKSApO1xyXG5cclxuXHRyZXR1cm4gdi5zYXR1cmF0ZSgpO1xyXG5cclxufSApLnNldExheW91dCgge1xyXG5cdG5hbWU6ICdWX0dHWF9TbWl0aENvcnJlbGF0ZWRfQW5pc290cm9waWMnLFxyXG5cdHR5cGU6ICdmbG9hdCcsXHJcblx0aW5wdXRzOiBbXHJcblx0XHR7IG5hbWU6ICdhbHBoYVQnLCB0eXBlOiAnZmxvYXQnLCBxdWFsaWZpZXI6ICdpbicgfSxcclxuXHRcdHsgbmFtZTogJ2FscGhhQicsIHR5cGU6ICdmbG9hdCcsIHF1YWxpZmllcjogJ2luJyB9LFxyXG5cdFx0eyBuYW1lOiAnZG90VFYnLCB0eXBlOiAnZmxvYXQnLCBxdWFsaWZpZXI6ICdpbicgfSxcclxuXHRcdHsgbmFtZTogJ2RvdEJWJywgdHlwZTogJ2Zsb2F0JywgcXVhbGlmaWVyOiAnaW4nIH0sXHJcblx0XHR7IG5hbWU6ICdkb3RUTCcsIHR5cGU6ICdmbG9hdCcsIHF1YWxpZmllcjogJ2luJyB9LFxyXG5cdFx0eyBuYW1lOiAnZG90QkwnLCB0eXBlOiAnZmxvYXQnLCBxdWFsaWZpZXI6ICdpbicgfSxcclxuXHRcdHsgbmFtZTogJ2RvdE5WJywgdHlwZTogJ2Zsb2F0JywgcXVhbGlmaWVyOiAnaW4nIH0sXHJcblx0XHR7IG5hbWU6ICdkb3ROTCcsIHR5cGU6ICdmbG9hdCcsIHF1YWxpZmllcjogJ2luJyB9XHJcblx0XVxyXG59ICk7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBWX0dHWF9TbWl0aENvcnJlbGF0ZWRfQW5pc290cm9waWM7XHJcbiIsImltcG9ydCB7IEZuIH0gZnJvbSAnLi4vLi4vdHNsL1RTTEJhc2UuanMnO1xyXG5cclxuLy8gTWljcm9mYWNldCBNb2RlbHMgZm9yIFJlZnJhY3Rpb24gdGhyb3VnaCBSb3VnaCBTdXJmYWNlcyAtIGVxdWF0aW9uICgzMylcclxuLy8gaHR0cDovL2dyYXBoaWNyYW50cy5ibG9nc3BvdC5jb20vMjAxMy8wOC9zcGVjdWxhci1icmRmLXJlZmVyZW5jZS5odG1sXHJcbi8vIGFscGhhIGlzIFwicm91Z2huZXNzIHNxdWFyZWRcIiBpbiBEaXNuZXnigJlzIHJlcGFyYW1ldGVyaXphdGlvblxyXG5jb25zdCBEX0dHWCA9IC8qQF9fUFVSRV9fKi8gRm4oICggeyBhbHBoYSwgZG90TkggfSApID0+IHtcclxuXHJcblx0Y29uc3QgYTIgPSBhbHBoYS5wb3cyKCk7XHJcblxyXG5cdGNvbnN0IGRlbm9tID0gZG90TkgucG93MigpLm11bCggYTIub25lTWludXMoKSApLm9uZU1pbnVzKCk7IC8vIGF2b2lkIGFscGhhID0gMCB3aXRoIGRvdE5IID0gMVxyXG5cclxuXHRyZXR1cm4gYTIuZGl2KCBkZW5vbS5wb3cyKCkgKS5tdWwoIDEgLyBNYXRoLlBJICk7XHJcblxyXG59ICkuc2V0TGF5b3V0KCB7XHJcblx0bmFtZTogJ0RfR0dYJyxcclxuXHR0eXBlOiAnZmxvYXQnLFxyXG5cdGlucHV0czogW1xyXG5cdFx0eyBuYW1lOiAnYWxwaGEnLCB0eXBlOiAnZmxvYXQnIH0sXHJcblx0XHR7IG5hbWU6ICdkb3ROSCcsIHR5cGU6ICdmbG9hdCcgfVxyXG5cdF1cclxufSApOyAvLyB2YWxpZGF0ZWRcclxuXHJcbmV4cG9ydCBkZWZhdWx0IERfR0dYO1xyXG4iLCJpbXBvcnQgeyBGbiwgZmxvYXQsIHZlYzMgfSBmcm9tICcuLi8uLi90c2wvVFNMQmFzZS5qcyc7XHJcblxyXG5jb25zdCBSRUNJUFJPQ0FMX1BJID0gLypAX19QVVJFX18qLyBmbG9hdCggMSAvIE1hdGguUEkgKTtcclxuXHJcbi8vIGh0dHBzOi8vZ29vZ2xlLmdpdGh1Yi5pby9maWxhbWVudC9GaWxhbWVudC5tZC5odG1sI21hdGVyaWFsc3lzdGVtL2FuaXNvdHJvcGljbW9kZWwvYW5pc290cm9waWNzcGVjdWxhcmJyZGZcclxuXHJcbmNvbnN0IERfR0dYX0FuaXNvdHJvcGljID0gLypAX19QVVJFX18qLyBGbiggKCB7IGFscGhhVCwgYWxwaGFCLCBkb3ROSCwgZG90VEgsIGRvdEJIIH0gKSA9PiB7XHJcblxyXG5cdGNvbnN0IGEyID0gYWxwaGFULm11bCggYWxwaGFCICk7XHJcblx0Y29uc3QgdiA9IHZlYzMoIGFscGhhQi5tdWwoIGRvdFRIICksIGFscGhhVC5tdWwoIGRvdEJIICksIGEyLm11bCggZG90TkggKSApO1xyXG5cdGNvbnN0IHYyID0gdi5kb3QoIHYgKTtcclxuXHRjb25zdCB3MiA9IGEyLmRpdiggdjIgKTtcclxuXHJcblx0cmV0dXJuIFJFQ0lQUk9DQUxfUEkubXVsKCBhMi5tdWwoIHcyLnBvdzIoKSApICk7XHJcblxyXG59ICkuc2V0TGF5b3V0KCB7XHJcblx0bmFtZTogJ0RfR0dYX0FuaXNvdHJvcGljJyxcclxuXHR0eXBlOiAnZmxvYXQnLFxyXG5cdGlucHV0czogW1xyXG5cdFx0eyBuYW1lOiAnYWxwaGFUJywgdHlwZTogJ2Zsb2F0JywgcXVhbGlmaWVyOiAnaW4nIH0sXHJcblx0XHR7IG5hbWU6ICdhbHBoYUInLCB0eXBlOiAnZmxvYXQnLCBxdWFsaWZpZXI6ICdpbicgfSxcclxuXHRcdHsgbmFtZTogJ2RvdE5IJywgdHlwZTogJ2Zsb2F0JywgcXVhbGlmaWVyOiAnaW4nIH0sXHJcblx0XHR7IG5hbWU6ICdkb3RUSCcsIHR5cGU6ICdmbG9hdCcsIHF1YWxpZmllcjogJ2luJyB9LFxyXG5cdFx0eyBuYW1lOiAnZG90QkgnLCB0eXBlOiAnZmxvYXQnLCBxdWFsaWZpZXI6ICdpbicgfVxyXG5cdF1cclxufSApO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgRF9HR1hfQW5pc290cm9waWM7XHJcbiIsImltcG9ydCBGX1NjaGxpY2sgZnJvbSAnLi9GX1NjaGxpY2suanMnO1xyXG5pbXBvcnQgVl9HR1hfU21pdGhDb3JyZWxhdGVkIGZyb20gJy4vVl9HR1hfU21pdGhDb3JyZWxhdGVkLmpzJztcclxuaW1wb3J0IFZfR0dYX1NtaXRoQ29ycmVsYXRlZF9Bbmlzb3Ryb3BpYyBmcm9tICcuL1ZfR0dYX1NtaXRoQ29ycmVsYXRlZF9Bbmlzb3Ryb3BpYy5qcyc7XHJcbmltcG9ydCBEX0dHWCBmcm9tICcuL0RfR0dYLmpzJztcclxuaW1wb3J0IERfR0dYX0FuaXNvdHJvcGljIGZyb20gJy4vRF9HR1hfQW5pc290cm9waWMuanMnO1xyXG5pbXBvcnQgeyB0cmFuc2Zvcm1lZE5vcm1hbFZpZXcgfSBmcm9tICcuLi8uLi9hY2Nlc3NvcnMvTm9ybWFsLmpzJztcclxuaW1wb3J0IHsgcG9zaXRpb25WaWV3RGlyZWN0aW9uIH0gZnJvbSAnLi4vLi4vYWNjZXNzb3JzL1Bvc2l0aW9uLmpzJztcclxuaW1wb3J0IHsgaXJpZGVzY2VuY2UsIGFscGhhVCwgYW5pc290cm9weVQsIGFuaXNvdHJvcHlCIH0gZnJvbSAnLi4vLi4vY29yZS9Qcm9wZXJ0eU5vZGUuanMnO1xyXG5pbXBvcnQgeyBGbiwgZGVmaW5lZCB9IGZyb20gJy4uLy4uL3RzbC9UU0xCYXNlLmpzJztcclxuXHJcbi8vIEdHWCBEaXN0cmlidXRpb24sIFNjaGxpY2sgRnJlc25lbCwgR0dYX1NtaXRoQ29ycmVsYXRlZCBWaXNpYmlsaXR5XHJcbmNvbnN0IEJSREZfR0dYID0gLypAX19QVVJFX18qLyBGbiggKCBpbnB1dHMgKSA9PiB7XHJcblxyXG5cdGNvbnN0IHsgbGlnaHREaXJlY3Rpb24sIGYwLCBmOTAsIHJvdWdobmVzcywgZiwgVVNFX0lSSURFU0NFTkNFLCBVU0VfQU5JU09UUk9QWSB9ID0gaW5wdXRzO1xyXG5cclxuXHRjb25zdCBub3JtYWxWaWV3ID0gaW5wdXRzLm5vcm1hbFZpZXcgfHwgdHJhbnNmb3JtZWROb3JtYWxWaWV3O1xyXG5cclxuXHRjb25zdCBhbHBoYSA9IHJvdWdobmVzcy5wb3cyKCk7IC8vIFVFNCdzIHJvdWdobmVzc1xyXG5cclxuXHRjb25zdCBoYWxmRGlyID0gbGlnaHREaXJlY3Rpb24uYWRkKCBwb3NpdGlvblZpZXdEaXJlY3Rpb24gKS5ub3JtYWxpemUoKTtcclxuXHJcblx0Y29uc3QgZG90TkwgPSBub3JtYWxWaWV3LmRvdCggbGlnaHREaXJlY3Rpb24gKS5jbGFtcCgpO1xyXG5cdGNvbnN0IGRvdE5WID0gbm9ybWFsVmlldy5kb3QoIHBvc2l0aW9uVmlld0RpcmVjdGlvbiApLmNsYW1wKCk7IC8vIEAgVE9ETzogTW92ZSB0byBjb3JlIGRvdE5WXHJcblx0Y29uc3QgZG90TkggPSBub3JtYWxWaWV3LmRvdCggaGFsZkRpciApLmNsYW1wKCk7XHJcblx0Y29uc3QgZG90VkggPSBwb3NpdGlvblZpZXdEaXJlY3Rpb24uZG90KCBoYWxmRGlyICkuY2xhbXAoKTtcclxuXHJcblx0bGV0IEYgPSBGX1NjaGxpY2soIHsgZjAsIGY5MCwgZG90VkggfSApO1xyXG5cdGxldCBWLCBEO1xyXG5cclxuXHRpZiAoIGRlZmluZWQoIFVTRV9JUklERVNDRU5DRSApICkge1xyXG5cclxuXHRcdEYgPSBpcmlkZXNjZW5jZS5taXgoIEYsIGYgKTtcclxuXHJcblx0fVxyXG5cclxuXHRpZiAoIGRlZmluZWQoIFVTRV9BTklTT1RST1BZICkgKSB7XHJcblxyXG5cdFx0Y29uc3QgZG90VEwgPSBhbmlzb3Ryb3B5VC5kb3QoIGxpZ2h0RGlyZWN0aW9uICk7XHJcblx0XHRjb25zdCBkb3RUViA9IGFuaXNvdHJvcHlULmRvdCggcG9zaXRpb25WaWV3RGlyZWN0aW9uICk7XHJcblx0XHRjb25zdCBkb3RUSCA9IGFuaXNvdHJvcHlULmRvdCggaGFsZkRpciApO1xyXG5cdFx0Y29uc3QgZG90QkwgPSBhbmlzb3Ryb3B5Qi5kb3QoIGxpZ2h0RGlyZWN0aW9uICk7XHJcblx0XHRjb25zdCBkb3RCViA9IGFuaXNvdHJvcHlCLmRvdCggcG9zaXRpb25WaWV3RGlyZWN0aW9uICk7XHJcblx0XHRjb25zdCBkb3RCSCA9IGFuaXNvdHJvcHlCLmRvdCggaGFsZkRpciApO1xyXG5cclxuXHRcdFYgPSBWX0dHWF9TbWl0aENvcnJlbGF0ZWRfQW5pc290cm9waWMoIHsgYWxwaGFULCBhbHBoYUI6IGFscGhhLCBkb3RUViwgZG90QlYsIGRvdFRMLCBkb3RCTCwgZG90TlYsIGRvdE5MIH0gKTtcclxuXHRcdEQgPSBEX0dHWF9Bbmlzb3Ryb3BpYyggeyBhbHBoYVQsIGFscGhhQjogYWxwaGEsIGRvdE5ILCBkb3RUSCwgZG90QkggfSApO1xyXG5cclxuXHR9IGVsc2Uge1xyXG5cclxuXHRcdFYgPSBWX0dHWF9TbWl0aENvcnJlbGF0ZWQoIHsgYWxwaGEsIGRvdE5MLCBkb3ROViB9ICk7XHJcblx0XHREID0gRF9HR1goIHsgYWxwaGEsIGRvdE5IIH0gKTtcclxuXHJcblx0fVxyXG5cclxuXHRyZXR1cm4gRi5tdWwoIFYgKS5tdWwoIEQgKTtcclxuXHJcbn0gKTsgLy8gdmFsaWRhdGVkXHJcblxyXG5leHBvcnQgZGVmYXVsdCBCUkRGX0dHWDtcclxuIiwiaW1wb3J0IHsgRm4sIHZlYzIsIHZlYzQgfSBmcm9tICcuLi8uLi90c2wvVFNMQmFzZS5qcyc7XHJcblxyXG4vLyBBbmFseXRpY2FsIGFwcHJveGltYXRpb24gb2YgdGhlIERGRyBMVVQsIG9uZSBoYWxmIG9mIHRoZVxyXG4vLyBzcGxpdC1zdW0gYXBwcm94aW1hdGlvbiB1c2VkIGluIGluZGlyZWN0IHNwZWN1bGFyIGxpZ2h0aW5nLlxyXG4vLyB2aWEgJ2Vudmlyb25tZW50QlJERicgZnJvbSBcIlBoeXNpY2FsbHkgQmFzZWQgU2hhZGluZyBvbiBNb2JpbGVcIlxyXG4vLyBodHRwczovL3d3dy51bnJlYWxlbmdpbmUuY29tL2Jsb2cvcGh5c2ljYWxseS1iYXNlZC1zaGFkaW5nLW9uLW1vYmlsZVxyXG5jb25zdCBERkdBcHByb3ggPSAvKkBfX1BVUkVfXyovIEZuKCAoIHsgcm91Z2huZXNzLCBkb3ROViB9ICkgPT4ge1xyXG5cclxuXHRjb25zdCBjMCA9IHZlYzQoIC0gMSwgLSAwLjAyNzUsIC0gMC41NzIsIDAuMDIyICk7XHJcblxyXG5cdGNvbnN0IGMxID0gdmVjNCggMSwgMC4wNDI1LCAxLjA0LCAtIDAuMDQgKTtcclxuXHJcblx0Y29uc3QgciA9IHJvdWdobmVzcy5tdWwoIGMwICkuYWRkKCBjMSApO1xyXG5cclxuXHRjb25zdCBhMDA0ID0gci54Lm11bCggci54ICkubWluKCBkb3ROVi5tdWwoIC0gOS4yOCApLmV4cDIoKSApLm11bCggci54ICkuYWRkKCByLnkgKTtcclxuXHJcblx0Y29uc3QgZmFiID0gdmVjMiggLSAxLjA0LCAxLjA0ICkubXVsKCBhMDA0ICkuYWRkKCByLnp3ICk7XHJcblxyXG5cdHJldHVybiBmYWI7XHJcblxyXG59ICkuc2V0TGF5b3V0KCB7XHJcblx0bmFtZTogJ0RGR0FwcHJveCcsXHJcblx0dHlwZTogJ3ZlYzInLFxyXG5cdGlucHV0czogW1xyXG5cdFx0eyBuYW1lOiAncm91Z2huZXNzJywgdHlwZTogJ2Zsb2F0JyB9LFxyXG5cdFx0eyBuYW1lOiAnZG90TlYnLCB0eXBlOiAndmVjMycgfVxyXG5cdF1cclxufSApO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgREZHQXBwcm94O1xyXG4iLCJpbXBvcnQgREZHQXBwcm94IGZyb20gJy4vREZHQXBwcm94LmpzJztcclxuaW1wb3J0IHsgRm4gfSBmcm9tICcuLi8uLi90c2wvVFNMQmFzZS5qcyc7XHJcblxyXG5jb25zdCBFbnZpcm9ubWVudEJSREYgPSAvKkBfX1BVUkVfXyovIEZuKCAoIGlucHV0cyApID0+IHtcclxuXHJcblx0Y29uc3QgeyBkb3ROViwgc3BlY3VsYXJDb2xvciwgc3BlY3VsYXJGOTAsIHJvdWdobmVzcyB9ID0gaW5wdXRzO1xyXG5cclxuXHRjb25zdCBmYWIgPSBERkdBcHByb3goIHsgZG90TlYsIHJvdWdobmVzcyB9ICk7XHJcblx0cmV0dXJuIHNwZWN1bGFyQ29sb3IubXVsKCBmYWIueCApLmFkZCggc3BlY3VsYXJGOTAubXVsKCBmYWIueSApICk7XHJcblxyXG59ICk7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBFbnZpcm9ubWVudEJSREY7XHJcbiIsImltcG9ydCB7IEZuLCB2ZWMzIH0gZnJvbSAnLi4vLi4vdHNsL1RTTEJhc2UuanMnO1xyXG5cclxuY29uc3QgU2NobGlja190b19GMCA9IC8qQF9fUFVSRV9fKi8gRm4oICggeyBmLCBmOTAsIGRvdFZIIH0gKSA9PiB7XHJcblxyXG5cdGNvbnN0IHggPSBkb3RWSC5vbmVNaW51cygpLnNhdHVyYXRlKCk7XHJcblx0Y29uc3QgeDIgPSB4Lm11bCggeCApO1xyXG5cdGNvbnN0IHg1ID0geC5tdWwoIHgyLCB4MiApLmNsYW1wKCAwLCAuOTk5OSApO1xyXG5cclxuXHRyZXR1cm4gZi5zdWIoIHZlYzMoIGY5MCApLm11bCggeDUgKSApLmRpdiggeDUub25lTWludXMoKSApO1xyXG5cclxufSApLnNldExheW91dCgge1xyXG5cdG5hbWU6ICdTY2hsaWNrX3RvX0YwJyxcclxuXHR0eXBlOiAndmVjMycsXHJcblx0aW5wdXRzOiBbXHJcblx0XHR7IG5hbWU6ICdmJywgdHlwZTogJ3ZlYzMnIH0sXHJcblx0XHR7IG5hbWU6ICdmOTAnLCB0eXBlOiAnZmxvYXQnIH0sXHJcblx0XHR7IG5hbWU6ICdkb3RWSCcsIHR5cGU6ICdmbG9hdCcgfVxyXG5cdF1cclxufSApO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgU2NobGlja190b19GMDtcclxuIiwiaW1wb3J0IHsgdHJhbnNmb3JtZWROb3JtYWxWaWV3IH0gZnJvbSAnLi4vLi4vYWNjZXNzb3JzL05vcm1hbC5qcyc7XHJcbmltcG9ydCB7IHBvc2l0aW9uVmlld0RpcmVjdGlvbiB9IGZyb20gJy4uLy4uL2FjY2Vzc29ycy9Qb3NpdGlvbi5qcyc7XHJcbmltcG9ydCB7IHNoZWVuLCBzaGVlblJvdWdobmVzcyB9IGZyb20gJy4uLy4uL2NvcmUvUHJvcGVydHlOb2RlLmpzJztcclxuaW1wb3J0IHsgRm4sIGZsb2F0IH0gZnJvbSAnLi4vLi4vdHNsL1RTTEJhc2UuanMnO1xyXG5cclxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2dvb2dsZS9maWxhbWVudC9ibG9iL21hc3Rlci9zaGFkZXJzL3NyYy9icmRmLmZzXHJcbmNvbnN0IERfQ2hhcmxpZSA9IC8qQF9fUFVSRV9fKi8gRm4oICggeyByb3VnaG5lc3MsIGRvdE5IIH0gKSA9PiB7XHJcblxyXG5cdGNvbnN0IGFscGhhID0gcm91Z2huZXNzLnBvdzIoKTtcclxuXHJcblx0Ly8gRXN0ZXZleiBhbmQgS3VsbGEgMjAxNywgXCJQcm9kdWN0aW9uIEZyaWVuZGx5IE1pY3JvZmFjZXQgU2hlZW4gQlJERlwiXHJcblx0Y29uc3QgaW52QWxwaGEgPSBmbG9hdCggMS4wICkuZGl2KCBhbHBoYSApO1xyXG5cdGNvbnN0IGNvczJoID0gZG90TkgucG93MigpO1xyXG5cdGNvbnN0IHNpbjJoID0gY29zMmgub25lTWludXMoKS5tYXgoIDAuMDA3ODEyNSApOyAvLyAyXigtMTQvMiksIHNvIHNpbjJoXjIgPiAwIGluIGZwMTZcclxuXHJcblx0cmV0dXJuIGZsb2F0KCAyLjAgKS5hZGQoIGludkFscGhhICkubXVsKCBzaW4yaC5wb3coIGludkFscGhhLm11bCggMC41ICkgKSApLmRpdiggMi4wICogTWF0aC5QSSApO1xyXG5cclxufSApLnNldExheW91dCgge1xyXG5cdG5hbWU6ICdEX0NoYXJsaWUnLFxyXG5cdHR5cGU6ICdmbG9hdCcsXHJcblx0aW5wdXRzOiBbXHJcblx0XHR7IG5hbWU6ICdyb3VnaG5lc3MnLCB0eXBlOiAnZmxvYXQnIH0sXHJcblx0XHR7IG5hbWU6ICdkb3ROSCcsIHR5cGU6ICdmbG9hdCcgfVxyXG5cdF1cclxufSApO1xyXG5cclxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2dvb2dsZS9maWxhbWVudC9ibG9iL21hc3Rlci9zaGFkZXJzL3NyYy9icmRmLmZzXHJcbmNvbnN0IFZfTmV1YmVsdCA9IC8qQF9fUFVSRV9fKi8gRm4oICggeyBkb3ROViwgZG90TkwgfSApID0+IHtcclxuXHJcblx0Ly8gTmV1YmVsdCBhbmQgUGV0dGluZW8gMjAxMywgXCJDcmFmdGluZyBhIE5leHQtZ2VuIE1hdGVyaWFsIFBpcGVsaW5lIGZvciBUaGUgT3JkZXI6IDE4ODZcIlxyXG5cdHJldHVybiBmbG9hdCggMS4wICkuZGl2KCBmbG9hdCggNC4wICkubXVsKCBkb3ROTC5hZGQoIGRvdE5WICkuc3ViKCBkb3ROTC5tdWwoIGRvdE5WICkgKSApICk7XHJcblxyXG59ICkuc2V0TGF5b3V0KCB7XHJcblx0bmFtZTogJ1ZfTmV1YmVsdCcsXHJcblx0dHlwZTogJ2Zsb2F0JyxcclxuXHRpbnB1dHM6IFtcclxuXHRcdHsgbmFtZTogJ2RvdE5WJywgdHlwZTogJ2Zsb2F0JyB9LFxyXG5cdFx0eyBuYW1lOiAnZG90TkwnLCB0eXBlOiAnZmxvYXQnIH1cclxuXHRdXHJcbn0gKTtcclxuXHJcbmNvbnN0IEJSREZfU2hlZW4gPSAvKkBfX1BVUkVfXyovIEZuKCAoIHsgbGlnaHREaXJlY3Rpb24gfSApID0+IHtcclxuXHJcblx0Y29uc3QgaGFsZkRpciA9IGxpZ2h0RGlyZWN0aW9uLmFkZCggcG9zaXRpb25WaWV3RGlyZWN0aW9uICkubm9ybWFsaXplKCk7XHJcblxyXG5cdGNvbnN0IGRvdE5MID0gdHJhbnNmb3JtZWROb3JtYWxWaWV3LmRvdCggbGlnaHREaXJlY3Rpb24gKS5jbGFtcCgpO1xyXG5cdGNvbnN0IGRvdE5WID0gdHJhbnNmb3JtZWROb3JtYWxWaWV3LmRvdCggcG9zaXRpb25WaWV3RGlyZWN0aW9uICkuY2xhbXAoKTtcclxuXHRjb25zdCBkb3ROSCA9IHRyYW5zZm9ybWVkTm9ybWFsVmlldy5kb3QoIGhhbGZEaXIgKS5jbGFtcCgpO1xyXG5cclxuXHRjb25zdCBEID0gRF9DaGFybGllKCB7IHJvdWdobmVzczogc2hlZW5Sb3VnaG5lc3MsIGRvdE5IIH0gKTtcclxuXHRjb25zdCBWID0gVl9OZXViZWx0KCB7IGRvdE5WLCBkb3ROTCB9ICk7XHJcblxyXG5cdHJldHVybiBzaGVlbi5tdWwoIEQgKS5tdWwoIFYgKTtcclxuXHJcbn0gKTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IEJSREZfU2hlZW47XHJcbiIsImltcG9ydCB7IEZuLCBJZiwgbWF0MywgdmVjMiwgdmVjMyB9IGZyb20gJy4uLy4uL3RzbC9UU0xCYXNlLmpzJztcclxuaW1wb3J0IHsgbWF4IH0gZnJvbSAnLi4vLi4vbWF0aC9NYXRoTm9kZS5qcyc7XHJcblxyXG4vLyBSZWN0IEFyZWEgTGlnaHRcclxuXHJcbi8vIFJlYWwtVGltZSBQb2x5Z29uYWwtTGlnaHQgU2hhZGluZyB3aXRoIExpbmVhcmx5IFRyYW5zZm9ybWVkIENvc2luZXNcclxuLy8gYnkgRXJpYyBIZWl0eiwgSm9uYXRoYW4gRHVwdXksIFN0ZXBoZW4gSGlsbCBhbmQgRGF2aWQgTmV1YmVsdFxyXG4vLyBjb2RlOiBodHRwczovL2dpdGh1Yi5jb20vc2VsZnNoYWRvdy9sdGNfY29kZS9cclxuXHJcbmNvbnN0IExUQ19VdiA9IC8qQF9fUFVSRV9fKi8gRm4oICggeyBOLCBWLCByb3VnaG5lc3MgfSApID0+IHtcclxuXHJcblx0Y29uc3QgTFVUX1NJWkUgPSA2NC4wO1xyXG5cdGNvbnN0IExVVF9TQ0FMRSA9ICggTFVUX1NJWkUgLSAxLjAgKSAvIExVVF9TSVpFO1xyXG5cdGNvbnN0IExVVF9CSUFTID0gMC41IC8gTFVUX1NJWkU7XHJcblxyXG5cdGNvbnN0IGRvdE5WID0gTi5kb3QoIFYgKS5zYXR1cmF0ZSgpO1xyXG5cclxuXHQvLyB0ZXh0dXJlIHBhcmFtZXRlcml6ZWQgYnkgc3FydCggR0dYIGFscGhhICkgYW5kIHNxcnQoIDEgLSBjb3MoIHRoZXRhICkgKVxyXG5cdGNvbnN0IHV2ID0gdmVjMiggcm91Z2huZXNzLCBkb3ROVi5vbmVNaW51cygpLnNxcnQoKSApO1xyXG5cclxuXHR1di5hc3NpZ24oIHV2Lm11bCggTFVUX1NDQUxFICkuYWRkKCBMVVRfQklBUyApICk7XHJcblxyXG5cdHJldHVybiB1djtcclxuXHJcbn0gKS5zZXRMYXlvdXQoIHtcclxuXHRuYW1lOiAnTFRDX1V2JyxcclxuXHR0eXBlOiAndmVjMicsXHJcblx0aW5wdXRzOiBbXHJcblx0XHR7IG5hbWU6ICdOJywgdHlwZTogJ3ZlYzMnIH0sXHJcblx0XHR7IG5hbWU6ICdWJywgdHlwZTogJ3ZlYzMnIH0sXHJcblx0XHR7IG5hbWU6ICdyb3VnaG5lc3MnLCB0eXBlOiAnZmxvYXQnIH1cclxuXHRdXHJcbn0gKTtcclxuXHJcbmNvbnN0IExUQ19DbGlwcGVkU3BoZXJlRm9ybUZhY3RvciA9IC8qQF9fUFVSRV9fKi8gRm4oICggeyBmIH0gKSA9PiB7XHJcblxyXG5cdC8vIFJlYWwtVGltZSBBcmVhIExpZ2h0aW5nOiBhIEpvdXJuZXkgZnJvbSBSZXNlYXJjaCB0byBQcm9kdWN0aW9uIChwLjEwMilcclxuXHQvLyBBbiBhcHByb3hpbWF0aW9uIG9mIHRoZSBmb3JtIGZhY3RvciBvZiBhIGhvcml6b24tY2xpcHBlZCByZWN0YW5nbGUuXHJcblxyXG5cdGNvbnN0IGwgPSBmLmxlbmd0aCgpO1xyXG5cclxuXHRyZXR1cm4gbWF4KCBsLm11bCggbCApLmFkZCggZi56ICkuZGl2KCBsLmFkZCggMS4wICkgKSwgMCApO1xyXG5cclxufSApLnNldExheW91dCgge1xyXG5cdG5hbWU6ICdMVENfQ2xpcHBlZFNwaGVyZUZvcm1GYWN0b3InLFxyXG5cdHR5cGU6ICdmbG9hdCcsXHJcblx0aW5wdXRzOiBbXHJcblx0XHR7IG5hbWU6ICdmJywgdHlwZTogJ3ZlYzMnIH1cclxuXHRdXHJcbn0gKTtcclxuXHJcbmNvbnN0IExUQ19FZGdlVmVjdG9yRm9ybUZhY3RvciA9IC8qQF9fUFVSRV9fKi8gRm4oICggeyB2MSwgdjIgfSApID0+IHtcclxuXHJcblx0Y29uc3QgeCA9IHYxLmRvdCggdjIgKTtcclxuXHRjb25zdCB5ID0geC5hYnMoKS50b1ZhcigpO1xyXG5cclxuXHQvLyByYXRpb25hbCBwb2x5bm9taWFsIGFwcHJveGltYXRpb24gdG8gdGhldGEgLyBzaW4oIHRoZXRhICkgLyAyUElcclxuXHRjb25zdCBhID0geS5tdWwoIDAuMDE0NTIwNiApLmFkZCggMC40OTY1MTU1ICkubXVsKCB5ICkuYWRkKCAwLjg1NDM5ODUgKS50b1ZhcigpO1xyXG5cdGNvbnN0IGIgPSB5LmFkZCggNC4xNjE2NzI0ICkubXVsKCB5ICkuYWRkKCAzLjQxNzU5NDAgKS50b1ZhcigpO1xyXG5cdGNvbnN0IHYgPSBhLmRpdiggYiApO1xyXG5cclxuXHRjb25zdCB0aGV0YV9zaW50aGV0YSA9IHguZ3JlYXRlclRoYW4oIDAuMCApLnNlbGVjdCggdiwgbWF4KCB4Lm11bCggeCApLm9uZU1pbnVzKCksIDFlLTcgKS5pbnZlcnNlU3FydCgpLm11bCggMC41ICkuc3ViKCB2ICkgKTtcclxuXHJcblx0cmV0dXJuIHYxLmNyb3NzKCB2MiApLm11bCggdGhldGFfc2ludGhldGEgKTtcclxuXHJcbn0gKS5zZXRMYXlvdXQoIHtcclxuXHRuYW1lOiAnTFRDX0VkZ2VWZWN0b3JGb3JtRmFjdG9yJyxcclxuXHR0eXBlOiAndmVjMycsXHJcblx0aW5wdXRzOiBbXHJcblx0XHR7IG5hbWU6ICd2MScsIHR5cGU6ICd2ZWMzJyB9LFxyXG5cdFx0eyBuYW1lOiAndjInLCB0eXBlOiAndmVjMycgfVxyXG5cdF1cclxufSApO1xyXG5cclxuY29uc3QgTFRDX0V2YWx1YXRlID0gLypAX19QVVJFX18qLyBGbiggKCB7IE4sIFYsIFAsIG1JbnYsIHAwLCBwMSwgcDIsIHAzIH0gKSA9PiB7XHJcblxyXG5cdC8vIGJhaWwgaWYgcG9pbnQgaXMgb24gYmFjayBzaWRlIG9mIHBsYW5lIG9mIGxpZ2h0XHJcblx0Ly8gYXNzdW1lcyBjY3cgd2luZGluZyBvcmRlciBvZiBsaWdodCB2ZXJ0aWNlc1xyXG5cdGNvbnN0IHYxID0gcDEuc3ViKCBwMCApLnRvVmFyKCk7XHJcblx0Y29uc3QgdjIgPSBwMy5zdWIoIHAwICkudG9WYXIoKTtcclxuXHJcblx0Y29uc3QgbGlnaHROb3JtYWwgPSB2MS5jcm9zcyggdjIgKTtcclxuXHRjb25zdCByZXN1bHQgPSB2ZWMzKCkudG9WYXIoKTtcclxuXHJcblx0SWYoIGxpZ2h0Tm9ybWFsLmRvdCggUC5zdWIoIHAwICkgKS5ncmVhdGVyVGhhbkVxdWFsKCAwLjAgKSwgKCkgPT4ge1xyXG5cclxuXHRcdC8vIGNvbnN0cnVjdCBvcnRob25vcm1hbCBiYXNpcyBhcm91bmQgTlxyXG5cdFx0Y29uc3QgVDEgPSBWLnN1YiggTi5tdWwoIFYuZG90KCBOICkgKSApLm5vcm1hbGl6ZSgpO1xyXG5cdFx0Y29uc3QgVDIgPSBOLmNyb3NzKCBUMSApLm5lZ2F0ZSgpOyAvLyBuZWdhdGVkIGZyb20gcGFwZXI7IHBvc3NpYmx5IGR1ZSB0byBhIGRpZmZlcmVudCBoYW5kZWRuZXNzIG9mIHdvcmxkIGNvb3JkaW5hdGUgc3lzdGVtXHJcblxyXG5cdFx0Ly8gY29tcHV0ZSB0cmFuc2Zvcm1cclxuXHRcdGNvbnN0IG1hdCA9IG1JbnYubXVsKCBtYXQzKCBUMSwgVDIsIE4gKS50cmFuc3Bvc2UoKSApLnRvVmFyKCk7XHJcblxyXG5cdFx0Ly8gdHJhbnNmb3JtIHJlY3RcclxuXHRcdC8vICYgcHJvamVjdCByZWN0IG9udG8gc3BoZXJlXHJcblx0XHRjb25zdCBjb29yZHMwID0gbWF0Lm11bCggcDAuc3ViKCBQICkgKS5ub3JtYWxpemUoKS50b1ZhcigpO1xyXG5cdFx0Y29uc3QgY29vcmRzMSA9IG1hdC5tdWwoIHAxLnN1YiggUCApICkubm9ybWFsaXplKCkudG9WYXIoKTtcclxuXHRcdGNvbnN0IGNvb3JkczIgPSBtYXQubXVsKCBwMi5zdWIoIFAgKSApLm5vcm1hbGl6ZSgpLnRvVmFyKCk7XHJcblx0XHRjb25zdCBjb29yZHMzID0gbWF0Lm11bCggcDMuc3ViKCBQICkgKS5ub3JtYWxpemUoKS50b1ZhcigpO1xyXG5cclxuXHRcdC8vIGNhbGN1bGF0ZSB2ZWN0b3IgZm9ybSBmYWN0b3JcclxuXHRcdGNvbnN0IHZlY3RvckZvcm1GYWN0b3IgPSB2ZWMzKCAwICkudG9WYXIoKTtcclxuXHRcdHZlY3RvckZvcm1GYWN0b3IuYWRkQXNzaWduKCBMVENfRWRnZVZlY3RvckZvcm1GYWN0b3IoIHsgdjE6IGNvb3JkczAsIHYyOiBjb29yZHMxIH0gKSApO1xyXG5cdFx0dmVjdG9yRm9ybUZhY3Rvci5hZGRBc3NpZ24oIExUQ19FZGdlVmVjdG9yRm9ybUZhY3RvciggeyB2MTogY29vcmRzMSwgdjI6IGNvb3JkczIgfSApICk7XHJcblx0XHR2ZWN0b3JGb3JtRmFjdG9yLmFkZEFzc2lnbiggTFRDX0VkZ2VWZWN0b3JGb3JtRmFjdG9yKCB7IHYxOiBjb29yZHMyLCB2MjogY29vcmRzMyB9ICkgKTtcclxuXHRcdHZlY3RvckZvcm1GYWN0b3IuYWRkQXNzaWduKCBMVENfRWRnZVZlY3RvckZvcm1GYWN0b3IoIHsgdjE6IGNvb3JkczMsIHYyOiBjb29yZHMwIH0gKSApO1xyXG5cclxuXHRcdC8vIGFkanVzdCBmb3IgaG9yaXpvbiBjbGlwcGluZ1xyXG5cdFx0cmVzdWx0LmFzc2lnbiggdmVjMyggTFRDX0NsaXBwZWRTcGhlcmVGb3JtRmFjdG9yKCB7IGY6IHZlY3RvckZvcm1GYWN0b3IgfSApICkgKTtcclxuXHJcblx0fSApO1xyXG5cclxuXHRyZXR1cm4gcmVzdWx0O1xyXG5cclxufSApLnNldExheW91dCgge1xyXG5cdG5hbWU6ICdMVENfRXZhbHVhdGUnLFxyXG5cdHR5cGU6ICd2ZWMzJyxcclxuXHRpbnB1dHM6IFtcclxuXHRcdHsgbmFtZTogJ04nLCB0eXBlOiAndmVjMycgfSxcclxuXHRcdHsgbmFtZTogJ1YnLCB0eXBlOiAndmVjMycgfSxcclxuXHRcdHsgbmFtZTogJ1AnLCB0eXBlOiAndmVjMycgfSxcclxuXHRcdHsgbmFtZTogJ21JbnYnLCB0eXBlOiAnbWF0MycgfSxcclxuXHRcdHsgbmFtZTogJ3AwJywgdHlwZTogJ3ZlYzMnIH0sXHJcblx0XHR7IG5hbWU6ICdwMScsIHR5cGU6ICd2ZWMzJyB9LFxyXG5cdFx0eyBuYW1lOiAncDInLCB0eXBlOiAndmVjMycgfSxcclxuXHRcdHsgbmFtZTogJ3AzJywgdHlwZTogJ3ZlYzMnIH1cclxuXHRdXHJcbn0gKTtcclxuXHJcblxyXG5leHBvcnQgeyBMVENfRXZhbHVhdGUsIExUQ19VdiB9O1xyXG4iLCJpbXBvcnQgeyBhZGQsIG11bCwgZGl2IH0gZnJvbSAnLi4vbWF0aC9PcGVyYXRvck5vZGUuanMnO1xyXG5pbXBvcnQgeyBmbG9vciwgY2VpbCwgZnJhY3QsIHBvdyB9IGZyb20gJy4uL21hdGgvTWF0aE5vZGUuanMnO1xyXG5pbXBvcnQgeyBGbiwgZmxvYXQsIHZlYzIsIHZlYzQsIGludCB9IGZyb20gJy4uL3RzbC9UU0xCYXNlLmpzJztcclxuXHJcbi8vIE1pcHBlZCBCaWN1YmljIFRleHR1cmUgRmlsdGVyaW5nIGJ5IE44XHJcbi8vIGh0dHBzOi8vd3d3LnNoYWRlcnRveS5jb20vdmlldy9EbDJTRFdcclxuXHJcbmNvbnN0IGJDID0gMS4wIC8gNi4wO1xyXG5cclxuY29uc3QgdzAgPSAoIGEgKSA9PiBtdWwoIGJDLCBtdWwoIGEsIG11bCggYSwgYS5uZWdhdGUoKS5hZGQoIDMuMCApICkuc3ViKCAzLjAgKSApLmFkZCggMS4wICkgKTtcclxuXHJcbmNvbnN0IHcxID0gKCBhICkgPT4gbXVsKCBiQywgbXVsKCBhLCBtdWwoIGEsIG11bCggMy4wLCBhICkuc3ViKCA2LjAgKSApICkuYWRkKCA0LjAgKSApO1xyXG5cclxuY29uc3QgdzIgPSAoIGEgKSA9PiBtdWwoIGJDLCBtdWwoIGEsIG11bCggYSwgbXVsKCAtIDMuMCwgYSApLmFkZCggMy4wICkgKS5hZGQoIDMuMCApICkuYWRkKCAxLjAgKSApO1xyXG5cclxuY29uc3QgdzMgPSAoIGEgKSA9PiBtdWwoIGJDLCBwb3coIGEsIDMgKSApO1xyXG5cclxuY29uc3QgZzAgPSAoIGEgKSA9PiB3MCggYSApLmFkZCggdzEoIGEgKSApO1xyXG5cclxuY29uc3QgZzEgPSAoIGEgKSA9PiB3MiggYSApLmFkZCggdzMoIGEgKSApO1xyXG5cclxuLy8gaDAgYW5kIGgxIGFyZSB0aGUgdHdvIG9mZnNldCBmdW5jdGlvbnNcclxuY29uc3QgaDAgPSAoIGEgKSA9PiBhZGQoIC0gMS4wLCB3MSggYSApLmRpdiggdzAoIGEgKS5hZGQoIHcxKCBhICkgKSApICk7XHJcblxyXG5jb25zdCBoMSA9ICggYSApID0+IGFkZCggMS4wLCB3MyggYSApLmRpdiggdzIoIGEgKS5hZGQoIHczKCBhICkgKSApICk7XHJcblxyXG5jb25zdCBiaWN1YmljID0gKCB0ZXh0dXJlTm9kZSwgdGV4ZWxTaXplLCBsb2QgKSA9PiB7XHJcblxyXG5cdGNvbnN0IHV2ID0gdGV4dHVyZU5vZGUudXZOb2RlO1xyXG5cdGNvbnN0IHV2U2NhbGVkID0gbXVsKCB1diwgdGV4ZWxTaXplLnp3ICkuYWRkKCAwLjUgKTtcclxuXHJcblx0Y29uc3QgaXV2ID0gZmxvb3IoIHV2U2NhbGVkICk7XHJcblx0Y29uc3QgZnV2ID0gZnJhY3QoIHV2U2NhbGVkICk7XHJcblxyXG5cdGNvbnN0IGcweCA9IGcwKCBmdXYueCApO1xyXG5cdGNvbnN0IGcxeCA9IGcxKCBmdXYueCApO1xyXG5cdGNvbnN0IGgweCA9IGgwKCBmdXYueCApO1xyXG5cdGNvbnN0IGgxeCA9IGgxKCBmdXYueCApO1xyXG5cdGNvbnN0IGgweSA9IGgwKCBmdXYueSApO1xyXG5cdGNvbnN0IGgxeSA9IGgxKCBmdXYueSApO1xyXG5cclxuXHRjb25zdCBwMCA9IHZlYzIoIGl1di54LmFkZCggaDB4ICksIGl1di55LmFkZCggaDB5ICkgKS5zdWIoIDAuNSApLm11bCggdGV4ZWxTaXplLnh5ICk7XHJcblx0Y29uc3QgcDEgPSB2ZWMyKCBpdXYueC5hZGQoIGgxeCApLCBpdXYueS5hZGQoIGgweSApICkuc3ViKCAwLjUgKS5tdWwoIHRleGVsU2l6ZS54eSApO1xyXG5cdGNvbnN0IHAyID0gdmVjMiggaXV2LnguYWRkKCBoMHggKSwgaXV2LnkuYWRkKCBoMXkgKSApLnN1YiggMC41ICkubXVsKCB0ZXhlbFNpemUueHkgKTtcclxuXHRjb25zdCBwMyA9IHZlYzIoIGl1di54LmFkZCggaDF4ICksIGl1di55LmFkZCggaDF5ICkgKS5zdWIoIDAuNSApLm11bCggdGV4ZWxTaXplLnh5ICk7XHJcblxyXG5cdGNvbnN0IGEgPSBnMCggZnV2LnkgKS5tdWwoIGFkZCggZzB4Lm11bCggdGV4dHVyZU5vZGUuc2FtcGxlKCBwMCApLmxldmVsKCBsb2QgKSApLCBnMXgubXVsKCB0ZXh0dXJlTm9kZS5zYW1wbGUoIHAxICkubGV2ZWwoIGxvZCApICkgKSApO1xyXG5cdGNvbnN0IGIgPSBnMSggZnV2LnkgKS5tdWwoIGFkZCggZzB4Lm11bCggdGV4dHVyZU5vZGUuc2FtcGxlKCBwMiApLmxldmVsKCBsb2QgKSApLCBnMXgubXVsKCB0ZXh0dXJlTm9kZS5zYW1wbGUoIHAzICkubGV2ZWwoIGxvZCApICkgKSApO1xyXG5cclxuXHRyZXR1cm4gYS5hZGQoIGIgKTtcclxuXHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgdGV4dHVyZUJpY3ViaWMgPSAvKkBfX1BVUkVfXyovIEZuKCAoIFsgdGV4dHVyZU5vZGUsIGxvZE5vZGUgPSBmbG9hdCggMyApIF0gKSA9PiB7XHJcblxyXG5cdGNvbnN0IGZMb2RTaXplID0gdmVjMiggdGV4dHVyZU5vZGUuc2l6ZSggaW50KCBsb2ROb2RlICkgKSApO1xyXG5cdGNvbnN0IGNMb2RTaXplID0gdmVjMiggdGV4dHVyZU5vZGUuc2l6ZSggaW50KCBsb2ROb2RlLmFkZCggMS4wICkgKSApICk7XHJcblx0Y29uc3QgZkxvZFNpemVJbnYgPSBkaXYoIDEuMCwgZkxvZFNpemUgKTtcclxuXHRjb25zdCBjTG9kU2l6ZUludiA9IGRpdiggMS4wLCBjTG9kU2l6ZSApO1xyXG5cdGNvbnN0IGZTYW1wbGUgPSBiaWN1YmljKCB0ZXh0dXJlTm9kZSwgdmVjNCggZkxvZFNpemVJbnYsIGZMb2RTaXplICksIGZsb29yKCBsb2ROb2RlICkgKTtcclxuXHRjb25zdCBjU2FtcGxlID0gYmljdWJpYyggdGV4dHVyZU5vZGUsIHZlYzQoIGNMb2RTaXplSW52LCBjTG9kU2l6ZSApLCBjZWlsKCBsb2ROb2RlICkgKTtcclxuXHJcblx0cmV0dXJuIGZyYWN0KCBsb2ROb2RlICkubWl4KCBmU2FtcGxlLCBjU2FtcGxlICk7XHJcblxyXG59ICk7XHJcbiIsImltcG9ydCBCUkRGX0xhbWJlcnQgZnJvbSAnLi9CU0RGL0JSREZfTGFtYmVydC5qcyc7XHJcbmltcG9ydCBCUkRGX0dHWCBmcm9tICcuL0JTREYvQlJERl9HR1guanMnO1xyXG5pbXBvcnQgREZHQXBwcm94IGZyb20gJy4vQlNERi9ERkdBcHByb3guanMnO1xyXG5pbXBvcnQgRW52aXJvbm1lbnRCUkRGIGZyb20gJy4vQlNERi9FbnZpcm9ubWVudEJSREYuanMnO1xyXG5pbXBvcnQgRl9TY2hsaWNrIGZyb20gJy4vQlNERi9GX1NjaGxpY2suanMnO1xyXG5pbXBvcnQgU2NobGlja190b19GMCBmcm9tICcuL0JTREYvU2NobGlja190b19GMC5qcyc7XHJcbmltcG9ydCBCUkRGX1NoZWVuIGZyb20gJy4vQlNERi9CUkRGX1NoZWVuLmpzJztcclxuaW1wb3J0IHsgTFRDX0V2YWx1YXRlLCBMVENfVXYgfSBmcm9tICcuL0JTREYvTFRDLmpzJztcclxuaW1wb3J0IExpZ2h0aW5nTW9kZWwgZnJvbSAnLi4vY29yZS9MaWdodGluZ01vZGVsLmpzJztcclxuaW1wb3J0IHsgZGlmZnVzZUNvbG9yLCBzcGVjdWxhckNvbG9yLCBzcGVjdWxhckY5MCwgcm91Z2huZXNzLCBjbGVhcmNvYXQsIGNsZWFyY29hdFJvdWdobmVzcywgc2hlZW4sIHNoZWVuUm91Z2huZXNzLCBpcmlkZXNjZW5jZSwgaXJpZGVzY2VuY2VJT1IsIGlyaWRlc2NlbmNlVGhpY2tuZXNzLCBpb3IsIHRoaWNrbmVzcywgdHJhbnNtaXNzaW9uLCBhdHRlbnVhdGlvbkRpc3RhbmNlLCBhdHRlbnVhdGlvbkNvbG9yLCBkaXNwZXJzaW9uIH0gZnJvbSAnLi4vY29yZS9Qcm9wZXJ0eU5vZGUuanMnO1xyXG5pbXBvcnQgeyB0cmFuc2Zvcm1lZE5vcm1hbFZpZXcsIHRyYW5zZm9ybWVkQ2xlYXJjb2F0Tm9ybWFsVmlldywgdHJhbnNmb3JtZWROb3JtYWxXb3JsZCB9IGZyb20gJy4uL2FjY2Vzc29ycy9Ob3JtYWwuanMnO1xyXG5pbXBvcnQgeyBwb3NpdGlvblZpZXdEaXJlY3Rpb24sIHBvc2l0aW9uVmlldywgcG9zaXRpb25Xb3JsZCB9IGZyb20gJy4uL2FjY2Vzc29ycy9Qb3NpdGlvbi5qcyc7XHJcbmltcG9ydCB7IEZuLCBmbG9hdCwgdmVjMiwgdmVjMywgdmVjNCwgbWF0MywgSWYgfSBmcm9tICcuLi90c2wvVFNMQmFzZS5qcyc7XHJcbmltcG9ydCB7IHNlbGVjdCB9IGZyb20gJy4uL21hdGgvQ29uZGl0aW9uYWxOb2RlLmpzJztcclxuaW1wb3J0IHsgbWl4LCBub3JtYWxpemUsIHJlZnJhY3QsIGxlbmd0aCwgY2xhbXAsIGxvZzIsIGxvZywgZXhwLCBzbW9vdGhzdGVwIH0gZnJvbSAnLi4vbWF0aC9NYXRoTm9kZS5qcyc7XHJcbmltcG9ydCB7IGRpdiB9IGZyb20gJy4uL21hdGgvT3BlcmF0b3JOb2RlLmpzJztcclxuaW1wb3J0IHsgY2FtZXJhUG9zaXRpb24sIGNhbWVyYVByb2plY3Rpb25NYXRyaXgsIGNhbWVyYVZpZXdNYXRyaXggfSBmcm9tICcuLi9hY2Nlc3NvcnMvQ2FtZXJhLmpzJztcclxuaW1wb3J0IHsgbW9kZWxXb3JsZE1hdHJpeCB9IGZyb20gJy4uL2FjY2Vzc29ycy9Nb2RlbE5vZGUuanMnO1xyXG5pbXBvcnQgeyBzY3JlZW5TaXplIH0gZnJvbSAnLi4vZGlzcGxheS9TY3JlZW5Ob2RlLmpzJztcclxuaW1wb3J0IHsgdmlld3BvcnRNaXBUZXh0dXJlIH0gZnJvbSAnLi4vZGlzcGxheS9WaWV3cG9ydFRleHR1cmVOb2RlLmpzJztcclxuaW1wb3J0IHsgdGV4dHVyZUJpY3ViaWMgfSBmcm9tICcuLi9hY2Nlc3NvcnMvVGV4dHVyZUJpY3ViaWMuanMnO1xyXG5pbXBvcnQgeyBMb29wIH0gZnJvbSAnLi4vdXRpbHMvTG9vcE5vZGUuanMnO1xyXG5pbXBvcnQgeyBCYWNrU2lkZSB9IGZyb20gJy4uLy4uL2NvbnN0YW50cy5qcyc7XHJcblxyXG4vL1xyXG4vLyBUcmFuc21pc3Npb25cclxuLy9cclxuXHJcbmNvbnN0IGdldFZvbHVtZVRyYW5zbWlzc2lvblJheSA9IC8qQF9fUFVSRV9fKi8gRm4oICggWyBuLCB2LCB0aGlja25lc3MsIGlvciwgbW9kZWxNYXRyaXggXSApID0+IHtcclxuXHJcblx0Ly8gRGlyZWN0aW9uIG9mIHJlZnJhY3RlZCBsaWdodC5cclxuXHRjb25zdCByZWZyYWN0aW9uVmVjdG9yID0gdmVjMyggcmVmcmFjdCggdi5uZWdhdGUoKSwgbm9ybWFsaXplKCBuICksIGRpdiggMS4wLCBpb3IgKSApICk7XHJcblxyXG5cdC8vIENvbXB1dGUgcm90YXRpb24taW5kZXBlbmRlbnQgc2NhbGluZyBvZiB0aGUgbW9kZWwgbWF0cml4LlxyXG5cdGNvbnN0IG1vZGVsU2NhbGUgPSB2ZWMzKFxyXG5cdFx0bGVuZ3RoKCBtb2RlbE1hdHJpeFsgMCBdLnh5eiApLFxyXG5cdFx0bGVuZ3RoKCBtb2RlbE1hdHJpeFsgMSBdLnh5eiApLFxyXG5cdFx0bGVuZ3RoKCBtb2RlbE1hdHJpeFsgMiBdLnh5eiApXHJcblx0KTtcclxuXHJcblx0Ly8gVGhlIHRoaWNrbmVzcyBpcyBzcGVjaWZpZWQgaW4gbG9jYWwgc3BhY2UuXHJcblx0cmV0dXJuIG5vcm1hbGl6ZSggcmVmcmFjdGlvblZlY3RvciApLm11bCggdGhpY2tuZXNzLm11bCggbW9kZWxTY2FsZSApICk7XHJcblxyXG59ICkuc2V0TGF5b3V0KCB7XHJcblx0bmFtZTogJ2dldFZvbHVtZVRyYW5zbWlzc2lvblJheScsXHJcblx0dHlwZTogJ3ZlYzMnLFxyXG5cdGlucHV0czogW1xyXG5cdFx0eyBuYW1lOiAnbicsIHR5cGU6ICd2ZWMzJyB9LFxyXG5cdFx0eyBuYW1lOiAndicsIHR5cGU6ICd2ZWMzJyB9LFxyXG5cdFx0eyBuYW1lOiAndGhpY2tuZXNzJywgdHlwZTogJ2Zsb2F0JyB9LFxyXG5cdFx0eyBuYW1lOiAnaW9yJywgdHlwZTogJ2Zsb2F0JyB9LFxyXG5cdFx0eyBuYW1lOiAnbW9kZWxNYXRyaXgnLCB0eXBlOiAnbWF0NCcgfVxyXG5cdF1cclxufSApO1xyXG5cclxuY29uc3QgYXBwbHlJb3JUb1JvdWdobmVzcyA9IC8qQF9fUFVSRV9fKi8gRm4oICggWyByb3VnaG5lc3MsIGlvciBdICkgPT4ge1xyXG5cclxuXHQvLyBTY2FsZSByb3VnaG5lc3Mgd2l0aCBJT1Igc28gdGhhdCBhbiBJT1Igb2YgMS4wIHJlc3VsdHMgaW4gbm8gbWljcm9mYWNldCByZWZyYWN0aW9uIGFuZFxyXG5cdC8vIGFuIElPUiBvZiAxLjUgcmVzdWx0cyBpbiB0aGUgZGVmYXVsdCBhbW91bnQgb2YgbWljcm9mYWNldCByZWZyYWN0aW9uLlxyXG5cdHJldHVybiByb3VnaG5lc3MubXVsKCBjbGFtcCggaW9yLm11bCggMi4wICkuc3ViKCAyLjAgKSwgMC4wLCAxLjAgKSApO1xyXG5cclxufSApLnNldExheW91dCgge1xyXG5cdG5hbWU6ICdhcHBseUlvclRvUm91Z2huZXNzJyxcclxuXHR0eXBlOiAnZmxvYXQnLFxyXG5cdGlucHV0czogW1xyXG5cdFx0eyBuYW1lOiAncm91Z2huZXNzJywgdHlwZTogJ2Zsb2F0JyB9LFxyXG5cdFx0eyBuYW1lOiAnaW9yJywgdHlwZTogJ2Zsb2F0JyB9XHJcblx0XVxyXG59ICk7XHJcblxyXG5jb25zdCB2aWV3cG9ydEJhY2tTaWRlVGV4dHVyZSA9IC8qQF9fUFVSRV9fKi8gdmlld3BvcnRNaXBUZXh0dXJlKCk7XHJcbmNvbnN0IHZpZXdwb3J0RnJvbnRTaWRlVGV4dHVyZSA9IC8qQF9fUFVSRV9fKi8gdmlld3BvcnRNaXBUZXh0dXJlKCk7XHJcblxyXG5jb25zdCBnZXRUcmFuc21pc3Npb25TYW1wbGUgPSAvKkBfX1BVUkVfXyovIEZuKCAoIFsgZnJhZ0Nvb3JkLCByb3VnaG5lc3MsIGlvciBdLCB7IG1hdGVyaWFsIH0gKSA9PiB7XHJcblxyXG5cdGNvbnN0IHZUZXh0dXJlID0gbWF0ZXJpYWwuc2lkZSA9PT0gQmFja1NpZGUgPyB2aWV3cG9ydEJhY2tTaWRlVGV4dHVyZSA6IHZpZXdwb3J0RnJvbnRTaWRlVGV4dHVyZTtcclxuXHJcblx0Y29uc3QgdHJhbnNtaXNzaW9uU2FtcGxlID0gdlRleHR1cmUuc2FtcGxlKCBmcmFnQ29vcmQgKTtcclxuXHQvL2NvbnN0IHRyYW5zbWlzc2lvblNhbXBsZSA9IHZpZXdwb3J0TWlwVGV4dHVyZSggZnJhZ0Nvb3JkICk7XHJcblxyXG5cdGNvbnN0IGxvZCA9IGxvZzIoIHNjcmVlblNpemUueCApLm11bCggYXBwbHlJb3JUb1JvdWdobmVzcyggcm91Z2huZXNzLCBpb3IgKSApO1xyXG5cclxuXHRyZXR1cm4gdGV4dHVyZUJpY3ViaWMoIHRyYW5zbWlzc2lvblNhbXBsZSwgbG9kICk7XHJcblxyXG59ICk7XHJcblxyXG5jb25zdCB2b2x1bWVBdHRlbnVhdGlvbiA9IC8qQF9fUFVSRV9fKi8gRm4oICggWyB0cmFuc21pc3Npb25EaXN0YW5jZSwgYXR0ZW51YXRpb25Db2xvciwgYXR0ZW51YXRpb25EaXN0YW5jZSBdICkgPT4ge1xyXG5cclxuXHRJZiggYXR0ZW51YXRpb25EaXN0YW5jZS5ub3RFcXVhbCggMCApLCAoKSA9PiB7XHJcblxyXG5cdFx0Ly8gQ29tcHV0ZSBsaWdodCBhdHRlbnVhdGlvbiB1c2luZyBCZWVyJ3MgbGF3LlxyXG5cdFx0Y29uc3QgYXR0ZW51YXRpb25Db2VmZmljaWVudCA9IGxvZyggYXR0ZW51YXRpb25Db2xvciApLm5lZ2F0ZSgpLmRpdiggYXR0ZW51YXRpb25EaXN0YW5jZSApO1xyXG5cdFx0Y29uc3QgdHJhbnNtaXR0YW5jZSA9IGV4cCggYXR0ZW51YXRpb25Db2VmZmljaWVudC5uZWdhdGUoKS5tdWwoIHRyYW5zbWlzc2lvbkRpc3RhbmNlICkgKTtcclxuXHJcblx0XHRyZXR1cm4gdHJhbnNtaXR0YW5jZTtcclxuXHJcblx0fSApO1xyXG5cclxuXHQvLyBBdHRlbnVhdGlvbiBkaXN0YW5jZSBpcyAr4oieLCBpLmUuIHRoZSB0cmFuc21pdHRlZCBjb2xvciBpcyBub3QgYXR0ZW51YXRlZCBhdCBhbGwuXHJcblx0cmV0dXJuIHZlYzMoIDEuMCApO1xyXG5cclxufSApLnNldExheW91dCgge1xyXG5cdG5hbWU6ICd2b2x1bWVBdHRlbnVhdGlvbicsXHJcblx0dHlwZTogJ3ZlYzMnLFxyXG5cdGlucHV0czogW1xyXG5cdFx0eyBuYW1lOiAndHJhbnNtaXNzaW9uRGlzdGFuY2UnLCB0eXBlOiAnZmxvYXQnIH0sXHJcblx0XHR7IG5hbWU6ICdhdHRlbnVhdGlvbkNvbG9yJywgdHlwZTogJ3ZlYzMnIH0sXHJcblx0XHR7IG5hbWU6ICdhdHRlbnVhdGlvbkRpc3RhbmNlJywgdHlwZTogJ2Zsb2F0JyB9XHJcblx0XVxyXG59ICk7XHJcblxyXG5jb25zdCBnZXRJQkxWb2x1bWVSZWZyYWN0aW9uID0gLypAX19QVVJFX18qLyBGbiggKCBbIG4sIHYsIHJvdWdobmVzcywgZGlmZnVzZUNvbG9yLCBzcGVjdWxhckNvbG9yLCBzcGVjdWxhckY5MCwgcG9zaXRpb24sIG1vZGVsTWF0cml4LCB2aWV3TWF0cml4LCBwcm9qTWF0cml4LCBpb3IsIHRoaWNrbmVzcywgYXR0ZW51YXRpb25Db2xvciwgYXR0ZW51YXRpb25EaXN0YW5jZSwgZGlzcGVyc2lvbiBdICkgPT4ge1xyXG5cclxuXHRsZXQgdHJhbnNtaXR0ZWRMaWdodCwgdHJhbnNtaXR0YW5jZTtcclxuXHJcblx0aWYgKCBkaXNwZXJzaW9uICkge1xyXG5cclxuXHRcdHRyYW5zbWl0dGVkTGlnaHQgPSB2ZWM0KCkudG9WYXIoKTtcclxuXHRcdHRyYW5zbWl0dGFuY2UgPSB2ZWMzKCkudG9WYXIoKTtcclxuXHJcblx0XHRjb25zdCBoYWxmU3ByZWFkID0gaW9yLnN1YiggMS4wICkubXVsKCBkaXNwZXJzaW9uLm11bCggMC4wMjUgKSApO1xyXG5cdFx0Y29uc3QgaW9ycyA9IHZlYzMoIGlvci5zdWIoIGhhbGZTcHJlYWQgKSwgaW9yLCBpb3IuYWRkKCBoYWxmU3ByZWFkICkgKTtcclxuXHJcblx0XHRMb29wKCB7IHN0YXJ0OiAwLCBlbmQ6IDMgfSwgKCB7IGkgfSApID0+IHtcclxuXHJcblx0XHRcdGNvbnN0IGlvciA9IGlvcnMuZWxlbWVudCggaSApO1xyXG5cclxuXHRcdFx0Y29uc3QgdHJhbnNtaXNzaW9uUmF5ID0gZ2V0Vm9sdW1lVHJhbnNtaXNzaW9uUmF5KCBuLCB2LCB0aGlja25lc3MsIGlvciwgbW9kZWxNYXRyaXggKTtcclxuXHRcdFx0Y29uc3QgcmVmcmFjdGVkUmF5RXhpdCA9IHBvc2l0aW9uLmFkZCggdHJhbnNtaXNzaW9uUmF5ICk7XHJcblxyXG5cdFx0XHQvLyBQcm9qZWN0IHJlZnJhY3RlZCB2ZWN0b3Igb24gdGhlIGZyYW1lYnVmZmVyLCB3aGlsZSBtYXBwaW5nIHRvIG5vcm1hbGl6ZWQgZGV2aWNlIGNvb3JkaW5hdGVzLlxyXG5cdFx0XHRjb25zdCBuZGNQb3MgPSBwcm9qTWF0cml4Lm11bCggdmlld01hdHJpeC5tdWwoIHZlYzQoIHJlZnJhY3RlZFJheUV4aXQsIDEuMCApICkgKTtcclxuXHRcdFx0Y29uc3QgcmVmcmFjdGlvbkNvb3JkcyA9IHZlYzIoIG5kY1Bvcy54eS5kaXYoIG5kY1Bvcy53ICkgKS50b1ZhcigpO1xyXG5cdFx0XHRyZWZyYWN0aW9uQ29vcmRzLmFkZEFzc2lnbiggMS4wICk7XHJcblx0XHRcdHJlZnJhY3Rpb25Db29yZHMuZGl2QXNzaWduKCAyLjAgKTtcclxuXHRcdFx0cmVmcmFjdGlvbkNvb3Jkcy5hc3NpZ24oIHZlYzIoIHJlZnJhY3Rpb25Db29yZHMueCwgcmVmcmFjdGlvbkNvb3Jkcy55Lm9uZU1pbnVzKCkgKSApOyAvLyB3ZWJncHVcclxuXHJcblx0XHRcdC8vIFNhbXBsZSBmcmFtZWJ1ZmZlciB0byBnZXQgcGl4ZWwgdGhlIHJlZnJhY3RlZCByYXkgaGl0cy5cclxuXHRcdFx0Y29uc3QgdHJhbnNtaXNzaW9uU2FtcGxlID0gZ2V0VHJhbnNtaXNzaW9uU2FtcGxlKCByZWZyYWN0aW9uQ29vcmRzLCByb3VnaG5lc3MsIGlvciApO1xyXG5cclxuXHRcdFx0dHJhbnNtaXR0ZWRMaWdodC5lbGVtZW50KCBpICkuYXNzaWduKCB0cmFuc21pc3Npb25TYW1wbGUuZWxlbWVudCggaSApICk7XHJcblx0XHRcdHRyYW5zbWl0dGVkTGlnaHQuYS5hZGRBc3NpZ24oIHRyYW5zbWlzc2lvblNhbXBsZS5hICk7XHJcblxyXG5cdFx0XHR0cmFuc21pdHRhbmNlLmVsZW1lbnQoIGkgKS5hc3NpZ24oIGRpZmZ1c2VDb2xvci5lbGVtZW50KCBpICkubXVsKCB2b2x1bWVBdHRlbnVhdGlvbiggbGVuZ3RoKCB0cmFuc21pc3Npb25SYXkgKSwgYXR0ZW51YXRpb25Db2xvciwgYXR0ZW51YXRpb25EaXN0YW5jZSApLmVsZW1lbnQoIGkgKSApICk7XHJcblxyXG5cdFx0fSApO1xyXG5cclxuXHRcdHRyYW5zbWl0dGVkTGlnaHQuYS5kaXZBc3NpZ24oIDMuMCApO1xyXG5cclxuXHR9IGVsc2Uge1xyXG5cclxuXHRcdGNvbnN0IHRyYW5zbWlzc2lvblJheSA9IGdldFZvbHVtZVRyYW5zbWlzc2lvblJheSggbiwgdiwgdGhpY2tuZXNzLCBpb3IsIG1vZGVsTWF0cml4ICk7XHJcblx0XHRjb25zdCByZWZyYWN0ZWRSYXlFeGl0ID0gcG9zaXRpb24uYWRkKCB0cmFuc21pc3Npb25SYXkgKTtcclxuXHJcblx0XHQvLyBQcm9qZWN0IHJlZnJhY3RlZCB2ZWN0b3Igb24gdGhlIGZyYW1lYnVmZmVyLCB3aGlsZSBtYXBwaW5nIHRvIG5vcm1hbGl6ZWQgZGV2aWNlIGNvb3JkaW5hdGVzLlxyXG5cdFx0Y29uc3QgbmRjUG9zID0gcHJvak1hdHJpeC5tdWwoIHZpZXdNYXRyaXgubXVsKCB2ZWM0KCByZWZyYWN0ZWRSYXlFeGl0LCAxLjAgKSApICk7XHJcblx0XHRjb25zdCByZWZyYWN0aW9uQ29vcmRzID0gdmVjMiggbmRjUG9zLnh5LmRpdiggbmRjUG9zLncgKSApLnRvVmFyKCk7XHJcblx0XHRyZWZyYWN0aW9uQ29vcmRzLmFkZEFzc2lnbiggMS4wICk7XHJcblx0XHRyZWZyYWN0aW9uQ29vcmRzLmRpdkFzc2lnbiggMi4wICk7XHJcblx0XHRyZWZyYWN0aW9uQ29vcmRzLmFzc2lnbiggdmVjMiggcmVmcmFjdGlvbkNvb3Jkcy54LCByZWZyYWN0aW9uQ29vcmRzLnkub25lTWludXMoKSApICk7IC8vIHdlYmdwdVxyXG5cclxuXHRcdC8vIFNhbXBsZSBmcmFtZWJ1ZmZlciB0byBnZXQgcGl4ZWwgdGhlIHJlZnJhY3RlZCByYXkgaGl0cy5cclxuXHRcdHRyYW5zbWl0dGVkTGlnaHQgPSBnZXRUcmFuc21pc3Npb25TYW1wbGUoIHJlZnJhY3Rpb25Db29yZHMsIHJvdWdobmVzcywgaW9yICk7XHJcblx0XHR0cmFuc21pdHRhbmNlID0gZGlmZnVzZUNvbG9yLm11bCggdm9sdW1lQXR0ZW51YXRpb24oIGxlbmd0aCggdHJhbnNtaXNzaW9uUmF5ICksIGF0dGVudWF0aW9uQ29sb3IsIGF0dGVudWF0aW9uRGlzdGFuY2UgKSApO1xyXG5cclxuXHR9XHJcblxyXG5cdGNvbnN0IGF0dGVudWF0ZWRDb2xvciA9IHRyYW5zbWl0dGFuY2UucmdiLm11bCggdHJhbnNtaXR0ZWRMaWdodC5yZ2IgKTtcclxuXHRjb25zdCBkb3ROViA9IG4uZG90KCB2ICkuY2xhbXAoKTtcclxuXHJcblx0Ly8gR2V0IHRoZSBzcGVjdWxhciBjb21wb25lbnQuXHJcblx0Y29uc3QgRiA9IHZlYzMoIEVudmlyb25tZW50QlJERiggeyAvLyBuLCB2LCBzcGVjdWxhckNvbG9yLCBzcGVjdWxhckY5MCwgcm91Z2huZXNzXHJcblx0XHRkb3ROVixcclxuXHRcdHNwZWN1bGFyQ29sb3IsXHJcblx0XHRzcGVjdWxhckY5MCxcclxuXHRcdHJvdWdobmVzc1xyXG5cdH0gKSApO1xyXG5cclxuXHQvLyBBcyBsZXNzIGxpZ2h0IGlzIHRyYW5zbWl0dGVkLCB0aGUgb3BhY2l0eSBzaG91bGQgYmUgaW5jcmVhc2VkLiBUaGlzIHNpbXBsZSBhcHByb3hpbWF0aW9uIGRvZXMgYSBkZWNlbnQgam9iXHJcblx0Ly8gb2YgbW9kdWxhdGluZyBhIENTUyBiYWNrZ3JvdW5kLCBhbmQgaGFzIG5vIGVmZmVjdCB3aGVuIHRoZSBidWZmZXIgaXMgb3BhcXVlLCBkdWUgdG8gYSBzb2xpZCBvYmplY3Qgb3IgY2xlYXIgY29sb3IuXHJcblx0Y29uc3QgdHJhbnNtaXR0YW5jZUZhY3RvciA9IHRyYW5zbWl0dGFuY2Uuci5hZGQoIHRyYW5zbWl0dGFuY2UuZywgdHJhbnNtaXR0YW5jZS5iICkuZGl2KCAzLjAgKTtcclxuXHJcblx0cmV0dXJuIHZlYzQoIEYub25lTWludXMoKS5tdWwoIGF0dGVudWF0ZWRDb2xvciApLCB0cmFuc21pdHRlZExpZ2h0LmEub25lTWludXMoKS5tdWwoIHRyYW5zbWl0dGFuY2VGYWN0b3IgKS5vbmVNaW51cygpICk7XHJcblxyXG59ICk7XHJcblxyXG4vL1xyXG4vLyBJcmlkZXNjZW5jZVxyXG4vL1xyXG5cclxuLy8gWFlaIHRvIGxpbmVhci1zUkdCIGNvbG9yIHNwYWNlXHJcbmNvbnN0IFhZWl9UT19SRUM3MDkgPSAvKkBfX1BVUkVfXyovIG1hdDMoXHJcblx0My4yNDA0NTQyLCAtIDAuOTY5MjY2MCwgMC4wNTU2NDM0LFxyXG5cdC0gMS41MzcxMzg1LCAxLjg3NjAxMDgsIC0gMC4yMDQwMjU5LFxyXG5cdC0gMC40OTg1MzE0LCAwLjA0MTU1NjAsIDEuMDU3MjI1MlxyXG4pO1xyXG5cclxuLy8gQXNzdW1lIGFpciBpbnRlcmZhY2UgZm9yIHRvcFxyXG4vLyBOb3RlOiBXZSBkb24ndCBoYW5kbGUgdGhlIGNhc2UgZnJlc25lbDAgPT0gMVxyXG5jb25zdCBGcmVzbmVsMFRvSW9yID0gKCBmcmVzbmVsMCApID0+IHtcclxuXHJcblx0Y29uc3Qgc3FydEYwID0gZnJlc25lbDAuc3FydCgpO1xyXG5cdHJldHVybiB2ZWMzKCAxLjAgKS5hZGQoIHNxcnRGMCApLmRpdiggdmVjMyggMS4wICkuc3ViKCBzcXJ0RjAgKSApO1xyXG5cclxufTtcclxuXHJcbi8vIGlvciBpcyBhIHZhbHVlIGJldHdlZW4gMS4wIGFuZCAzLjAuIDEuMCBpcyBhaXIgaW50ZXJmYWNlXHJcbmNvbnN0IElvclRvRnJlc25lbDAgPSAoIHRyYW5zbWl0dGVkSW9yLCBpbmNpZGVudElvciApID0+IHtcclxuXHJcblx0cmV0dXJuIHRyYW5zbWl0dGVkSW9yLnN1YiggaW5jaWRlbnRJb3IgKS5kaXYoIHRyYW5zbWl0dGVkSW9yLmFkZCggaW5jaWRlbnRJb3IgKSApLnBvdzIoKTtcclxuXHJcbn07XHJcblxyXG4vLyBGcmVzbmVsIGVxdWF0aW9ucyBmb3IgZGllbGVjdHJpYy9kaWVsZWN0cmljIGludGVyZmFjZXMuXHJcbi8vIFJlZjogaHR0cHM6Ly9iZWxjb3VyLmdpdGh1Yi5pby9ibG9nL3Jlc2VhcmNoLzIwMTcvMDUvMDEvYnJkZi10aGluLWZpbG0uaHRtbFxyXG4vLyBFdmFsdWF0aW9uIFhZWiBzZW5zaXRpdml0eSBjdXJ2ZXMgaW4gRm91cmllciBzcGFjZVxyXG5jb25zdCBldmFsU2Vuc2l0aXZpdHkgPSAoIE9QRCwgc2hpZnQgKSA9PiB7XHJcblxyXG5cdGNvbnN0IHBoYXNlID0gT1BELm11bCggMi4wICogTWF0aC5QSSAqIDEuMGUtOSApO1xyXG5cdGNvbnN0IHZhbCA9IHZlYzMoIDUuNDg1NmUtMTMsIDQuNDIwMWUtMTMsIDUuMjQ4MWUtMTMgKTtcclxuXHRjb25zdCBwb3MgPSB2ZWMzKCAxLjY4MTBlKzA2LCAxLjc5NTNlKzA2LCAyLjIwODRlKzA2ICk7XHJcblx0Y29uc3QgVkFSID0gdmVjMyggNC4zMjc4ZSswOSwgOS4zMDQ2ZSswOSwgNi42MTIxZSswOSApO1xyXG5cclxuXHRjb25zdCB4ID0gZmxvYXQoIDkuNzQ3MGUtMTQgKiBNYXRoLnNxcnQoIDIuMCAqIE1hdGguUEkgKiA0LjUyODJlKzA5ICkgKS5tdWwoIHBoYXNlLm11bCggMi4yMzk5ZSswNiApLmFkZCggc2hpZnQueCApLmNvcygpICkubXVsKCBwaGFzZS5wb3cyKCkubXVsKCAtIDQuNTI4MmUrMDkgKS5leHAoKSApO1xyXG5cclxuXHRsZXQgeHl6ID0gdmFsLm11bCggVkFSLm11bCggMi4wICogTWF0aC5QSSApLnNxcnQoKSApLm11bCggcG9zLm11bCggcGhhc2UgKS5hZGQoIHNoaWZ0ICkuY29zKCkgKS5tdWwoIHBoYXNlLnBvdzIoKS5uZWdhdGUoKS5tdWwoIFZBUiApLmV4cCgpICk7XHJcblx0eHl6ID0gdmVjMyggeHl6LnguYWRkKCB4ICksIHh5ei55LCB4eXoueiApLmRpdiggMS4wNjg1ZS03ICk7XHJcblxyXG5cdGNvbnN0IHJnYiA9IFhZWl9UT19SRUM3MDkubXVsKCB4eXogKTtcclxuXHJcblx0cmV0dXJuIHJnYjtcclxuXHJcbn07XHJcblxyXG5jb25zdCBldmFsSXJpZGVzY2VuY2UgPSAvKkBfX1BVUkVfXyovIEZuKCAoIHsgb3V0c2lkZUlPUiwgZXRhMiwgY29zVGhldGExLCB0aGluRmlsbVRoaWNrbmVzcywgYmFzZUYwIH0gKSA9PiB7XHJcblxyXG5cdC8vIEZvcmNlIGlyaWRlc2NlbmNlSU9SIC0+IG91dHNpZGVJT1Igd2hlbiB0aGluRmlsbVRoaWNrbmVzcyAtPiAwLjBcclxuXHRjb25zdCBpcmlkZXNjZW5jZUlPUiA9IG1peCggb3V0c2lkZUlPUiwgZXRhMiwgc21vb3Roc3RlcCggMC4wLCAwLjAzLCB0aGluRmlsbVRoaWNrbmVzcyApICk7XHJcblx0Ly8gRXZhbHVhdGUgdGhlIGNvc1RoZXRhIG9uIHRoZSBiYXNlIGxheWVyIChTbmVsbCBsYXcpXHJcblx0Y29uc3Qgc2luVGhldGEyU3EgPSBvdXRzaWRlSU9SLmRpdiggaXJpZGVzY2VuY2VJT1IgKS5wb3cyKCkubXVsKCBjb3NUaGV0YTEucG93MigpLm9uZU1pbnVzKCkgKTtcclxuXHJcblx0Ly8gSGFuZGxlIFRJUjpcclxuXHRjb25zdCBjb3NUaGV0YTJTcSA9IHNpblRoZXRhMlNxLm9uZU1pbnVzKCk7XHJcblxyXG5cdElmKCBjb3NUaGV0YTJTcS5sZXNzVGhhbiggMCApLCAoKSA9PiB7XHJcblxyXG5cdFx0cmV0dXJuIHZlYzMoIDEuMCApO1xyXG5cclxuXHR9ICk7XHJcblxyXG5cdGNvbnN0IGNvc1RoZXRhMiA9IGNvc1RoZXRhMlNxLnNxcnQoKTtcclxuXHJcblx0Ly8gRmlyc3QgaW50ZXJmYWNlXHJcblx0Y29uc3QgUjAgPSBJb3JUb0ZyZXNuZWwwKCBpcmlkZXNjZW5jZUlPUiwgb3V0c2lkZUlPUiApO1xyXG5cdGNvbnN0IFIxMiA9IEZfU2NobGljayggeyBmMDogUjAsIGY5MDogMS4wLCBkb3RWSDogY29zVGhldGExIH0gKTtcclxuXHQvL2NvbnN0IFIyMSA9IFIxMjtcclxuXHRjb25zdCBUMTIxID0gUjEyLm9uZU1pbnVzKCk7XHJcblx0Y29uc3QgcGhpMTIgPSBpcmlkZXNjZW5jZUlPUi5sZXNzVGhhbiggb3V0c2lkZUlPUiApLnNlbGVjdCggTWF0aC5QSSwgMC4wICk7XHJcblx0Y29uc3QgcGhpMjEgPSBmbG9hdCggTWF0aC5QSSApLnN1YiggcGhpMTIgKTtcclxuXHJcblx0Ly8gU2Vjb25kIGludGVyZmFjZVxyXG5cdGNvbnN0IGJhc2VJT1IgPSBGcmVzbmVsMFRvSW9yKCBiYXNlRjAuY2xhbXAoIDAuMCwgMC45OTk5ICkgKTsgLy8gZ3VhcmQgYWdhaW5zdCAxLjBcclxuXHRjb25zdCBSMSA9IElvclRvRnJlc25lbDAoIGJhc2VJT1IsIGlyaWRlc2NlbmNlSU9SLnRvVmVjMygpICk7XHJcblx0Y29uc3QgUjIzID0gRl9TY2hsaWNrKCB7IGYwOiBSMSwgZjkwOiAxLjAsIGRvdFZIOiBjb3NUaGV0YTIgfSApO1xyXG5cdGNvbnN0IHBoaTIzID0gdmVjMyhcclxuXHRcdGJhc2VJT1IueC5sZXNzVGhhbiggaXJpZGVzY2VuY2VJT1IgKS5zZWxlY3QoIE1hdGguUEksIDAuMCApLFxyXG5cdFx0YmFzZUlPUi55Lmxlc3NUaGFuKCBpcmlkZXNjZW5jZUlPUiApLnNlbGVjdCggTWF0aC5QSSwgMC4wICksXHJcblx0XHRiYXNlSU9SLnoubGVzc1RoYW4oIGlyaWRlc2NlbmNlSU9SICkuc2VsZWN0KCBNYXRoLlBJLCAwLjAgKVxyXG5cdCk7XHJcblxyXG5cdC8vIFBoYXNlIHNoaWZ0XHJcblx0Y29uc3QgT1BEID0gaXJpZGVzY2VuY2VJT1IubXVsKCB0aGluRmlsbVRoaWNrbmVzcywgY29zVGhldGEyLCAyLjAgKTtcclxuXHRjb25zdCBwaGkgPSB2ZWMzKCBwaGkyMSApLmFkZCggcGhpMjMgKTtcclxuXHJcblx0Ly8gQ29tcG91bmQgdGVybXNcclxuXHRjb25zdCBSMTIzID0gUjEyLm11bCggUjIzICkuY2xhbXAoIDFlLTUsIDAuOTk5OSApO1xyXG5cdGNvbnN0IHIxMjMgPSBSMTIzLnNxcnQoKTtcclxuXHRjb25zdCBScyA9IFQxMjEucG93MigpLm11bCggUjIzICkuZGl2KCB2ZWMzKCAxLjAgKS5zdWIoIFIxMjMgKSApO1xyXG5cclxuXHQvLyBSZWZsZWN0YW5jZSB0ZXJtIGZvciBtID0gMCAoREMgdGVybSBhbXBsaXR1ZGUpXHJcblx0Y29uc3QgQzAgPSBSMTIuYWRkKCBScyApO1xyXG5cdGNvbnN0IEkgPSBDMC50b1ZhcigpO1xyXG5cclxuXHQvLyBSZWZsZWN0YW5jZSB0ZXJtIGZvciBtID4gMCAocGFpcnMgb2YgZGlyYWNzKVxyXG5cdGNvbnN0IENtID0gUnMuc3ViKCBUMTIxICkudG9WYXIoKTtcclxuXHJcblx0TG9vcCggeyBzdGFydDogMSwgZW5kOiAyLCBjb25kaXRpb246ICc8PScsIG5hbWU6ICdtJyB9LCAoIHsgbSB9ICkgPT4ge1xyXG5cclxuXHRcdENtLm11bEFzc2lnbiggcjEyMyApO1xyXG5cdFx0Y29uc3QgU20gPSBldmFsU2Vuc2l0aXZpdHkoIGZsb2F0KCBtICkubXVsKCBPUEQgKSwgZmxvYXQoIG0gKS5tdWwoIHBoaSApICkubXVsKCAyLjAgKTtcclxuXHRcdEkuYWRkQXNzaWduKCBDbS5tdWwoIFNtICkgKTtcclxuXHJcblx0fSApO1xyXG5cclxuXHQvLyBTaW5jZSBvdXQgb2YgZ2FtdXQgY29sb3JzIG1pZ2h0IGJlIHByb2R1Y2VkLCBuZWdhdGl2ZSBjb2xvciB2YWx1ZXMgYXJlIGNsYW1wZWQgdG8gMC5cclxuXHRyZXR1cm4gSS5tYXgoIHZlYzMoIDAuMCApICk7XHJcblxyXG59ICkuc2V0TGF5b3V0KCB7XHJcblx0bmFtZTogJ2V2YWxJcmlkZXNjZW5jZScsXHJcblx0dHlwZTogJ3ZlYzMnLFxyXG5cdGlucHV0czogW1xyXG5cdFx0eyBuYW1lOiAnb3V0c2lkZUlPUicsIHR5cGU6ICdmbG9hdCcgfSxcclxuXHRcdHsgbmFtZTogJ2V0YTInLCB0eXBlOiAnZmxvYXQnIH0sXHJcblx0XHR7IG5hbWU6ICdjb3NUaGV0YTEnLCB0eXBlOiAnZmxvYXQnIH0sXHJcblx0XHR7IG5hbWU6ICd0aGluRmlsbVRoaWNrbmVzcycsIHR5cGU6ICdmbG9hdCcgfSxcclxuXHRcdHsgbmFtZTogJ2Jhc2VGMCcsIHR5cGU6ICd2ZWMzJyB9XHJcblx0XVxyXG59ICk7XHJcblxyXG4vL1xyXG4vL1x0U2hlZW5cclxuLy9cclxuXHJcbi8vIFRoaXMgaXMgYSBjdXJ2ZS1maXQgYXBwcm94aW1hdGlvbiB0byB0aGUgXCJDaGFybGllIHNoZWVuXCIgQlJERiBpbnRlZ3JhdGVkIG92ZXIgdGhlIGhlbWlzcGhlcmUgZnJvbVxyXG4vLyBFc3RldmV6IGFuZCBLdWxsYSAyMDE3LCBcIlByb2R1Y3Rpb24gRnJpZW5kbHkgTWljcm9mYWNldCBTaGVlbiBCUkRGXCIuIFRoZSBhbmFseXNpcyBjYW4gYmUgZm91bmRcclxuLy8gaW4gdGhlIFNoZWVuIHNlY3Rpb24gb2YgaHR0cHM6Ly9kcml2ZS5nb29nbGUuY29tL2ZpbGUvZC8xVDBEMVZTeVI0QWxscUlKVFFBcmFFSXpqbGI1aDRGS0gvdmlldz91c3A9c2hhcmluZ1xyXG5jb25zdCBJQkxTaGVlbkJSREYgPSAvKkBfX1BVUkVfXyovIEZuKCAoIHsgbm9ybWFsLCB2aWV3RGlyLCByb3VnaG5lc3MgfSApID0+IHtcclxuXHJcblx0Y29uc3QgZG90TlYgPSBub3JtYWwuZG90KCB2aWV3RGlyICkuc2F0dXJhdGUoKTtcclxuXHJcblx0Y29uc3QgcjIgPSByb3VnaG5lc3MucG93MigpO1xyXG5cclxuXHRjb25zdCBhID0gc2VsZWN0KFxyXG5cdFx0cm91Z2huZXNzLmxlc3NUaGFuKCAwLjI1ICksXHJcblx0XHRmbG9hdCggLSAzMzkuMiApLm11bCggcjIgKS5hZGQoIGZsb2F0KCAxNjEuNCApLm11bCggcm91Z2huZXNzICkgKS5zdWIoIDI1LjkgKSxcclxuXHRcdGZsb2F0KCAtIDguNDggKS5tdWwoIHIyICkuYWRkKCBmbG9hdCggMTQuMyApLm11bCggcm91Z2huZXNzICkgKS5zdWIoIDkuOTUgKVxyXG5cdCk7XHJcblxyXG5cdGNvbnN0IGIgPSBzZWxlY3QoXHJcblx0XHRyb3VnaG5lc3MubGVzc1RoYW4oIDAuMjUgKSxcclxuXHRcdGZsb2F0KCA0NC4wICkubXVsKCByMiApLnN1YiggZmxvYXQoIDIzLjcgKS5tdWwoIHJvdWdobmVzcyApICkuYWRkKCAzLjI2ICksXHJcblx0XHRmbG9hdCggMS45NyApLm11bCggcjIgKS5zdWIoIGZsb2F0KCAzLjI3ICkubXVsKCByb3VnaG5lc3MgKSApLmFkZCggMC43MiApXHJcblx0KTtcclxuXHJcblx0Y29uc3QgREcgPSBzZWxlY3QoIHJvdWdobmVzcy5sZXNzVGhhbiggMC4yNSApLCAwLjAsIGZsb2F0KCAwLjEgKS5tdWwoIHJvdWdobmVzcyApLnN1YiggMC4wMjUgKSApLmFkZCggYS5tdWwoIGRvdE5WICkuYWRkKCBiICkuZXhwKCkgKTtcclxuXHJcblx0cmV0dXJuIERHLm11bCggMS4wIC8gTWF0aC5QSSApLnNhdHVyYXRlKCk7XHJcblxyXG59ICk7XHJcblxyXG5jb25zdCBjbGVhcmNvYXRGMCA9IHZlYzMoIDAuMDQgKTtcclxuY29uc3QgY2xlYXJjb2F0RjkwID0gZmxvYXQoIDEgKTtcclxuXHJcblxyXG4vKipcclxuICogUmVwcmVzZW50cyB0aGUgbGlnaHRpbmcgbW9kZWwgZm9yIGEgUEJSIG1hdGVyaWFsLlxyXG4gKlxyXG4gKiBAYXVnbWVudHMgTGlnaHRpbmdNb2RlbFxyXG4gKi9cclxuY2xhc3MgUGh5c2ljYWxMaWdodGluZ01vZGVsIGV4dGVuZHMgTGlnaHRpbmdNb2RlbCB7XHJcblxyXG5cdC8qKlxyXG5cdCAqIENvbnN0cnVjdHMgYSBuZXcgcGh5c2ljYWwgbGlnaHRpbmcgbW9kZWwuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IFtjbGVhcmNvYXQ9ZmFsc2VdIC0gV2hldGhlciBjbGVhcmNvYXQgaXMgc3VwcG9ydGVkIG9yIG5vdC5cclxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IFtzaGVlbj1mYWxzZV0gLSBXaGV0aGVyIHNoZWVuIGlzIHN1cHBvcnRlZCBvciBub3QuXHJcblx0ICogQHBhcmFtIHtCb29sZWFufSBbaXJpZGVzY2VuY2U9ZmFsc2VdIC0gV2hldGhlciBpcmlkZXNjZW5jZSBpcyBzdXBwb3J0ZWQgb3Igbm90LlxyXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gW2FuaXNvdHJvcHk9ZmFsc2VdIC0gV2hldGhlciBhbmlzb3Ryb3B5IGlzIHN1cHBvcnRlZCBvciBub3QuXHJcblx0ICogQHBhcmFtIHtCb29sZWFufSBbdHJhbnNtaXNzaW9uPWZhbHNlXSAtIFdoZXRoZXIgdHJhbnNtaXNzaW9uIGlzIHN1cHBvcnRlZCBvciBub3QuXHJcblx0ICogQHBhcmFtIHtCb29sZWFufSBbZGlzcGVyc2lvbj1mYWxzZV0gLSBXaGV0aGVyIGRpc3BlcnNpb24gaXMgc3VwcG9ydGVkIG9yIG5vdC5cclxuXHQgKi9cclxuXHRjb25zdHJ1Y3RvciggY2xlYXJjb2F0ID0gZmFsc2UsIHNoZWVuID0gZmFsc2UsIGlyaWRlc2NlbmNlID0gZmFsc2UsIGFuaXNvdHJvcHkgPSBmYWxzZSwgdHJhbnNtaXNzaW9uID0gZmFsc2UsIGRpc3BlcnNpb24gPSBmYWxzZSApIHtcclxuXHJcblx0XHRzdXBlcigpO1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogV2hldGhlciBjbGVhcmNvYXQgaXMgc3VwcG9ydGVkIG9yIG5vdC5cclxuXHRcdCAqXHJcblx0XHQgKiBAdHlwZSB7Qm9vbGVhbn1cclxuXHRcdCAqIEBkZWZhdWx0IGZhbHNlXHJcblx0XHQgKi9cclxuXHRcdHRoaXMuY2xlYXJjb2F0ID0gY2xlYXJjb2F0O1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogV2hldGhlciBzaGVlbiBpcyBzdXBwb3J0ZWQgb3Igbm90LlxyXG5cdFx0ICpcclxuXHRcdCAqIEB0eXBlIHtCb29sZWFufVxyXG5cdFx0ICogQGRlZmF1bHQgZmFsc2VcclxuXHRcdCAqL1xyXG5cdFx0dGhpcy5zaGVlbiA9IHNoZWVuO1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogV2hldGhlciBpcmlkZXNjZW5jZSBpcyBzdXBwb3J0ZWQgb3Igbm90LlxyXG5cdFx0ICpcclxuXHRcdCAqIEB0eXBlIHtCb29sZWFufVxyXG5cdFx0ICogQGRlZmF1bHQgZmFsc2VcclxuXHRcdCAqL1xyXG5cdFx0dGhpcy5pcmlkZXNjZW5jZSA9IGlyaWRlc2NlbmNlO1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogV2hldGhlciBhbmlzb3Ryb3B5IGlzIHN1cHBvcnRlZCBvciBub3QuXHJcblx0XHQgKlxyXG5cdFx0ICogQHR5cGUge0Jvb2xlYW59XHJcblx0XHQgKiBAZGVmYXVsdCBmYWxzZVxyXG5cdFx0ICovXHJcblx0XHR0aGlzLmFuaXNvdHJvcHkgPSBhbmlzb3Ryb3B5O1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogV2hldGhlciB0cmFuc21pc3Npb24gaXMgc3VwcG9ydGVkIG9yIG5vdC5cclxuXHRcdCAqXHJcblx0XHQgKiBAdHlwZSB7Qm9vbGVhbn1cclxuXHRcdCAqIEBkZWZhdWx0IGZhbHNlXHJcblx0XHQgKi9cclxuXHRcdHRoaXMudHJhbnNtaXNzaW9uID0gdHJhbnNtaXNzaW9uO1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogV2hldGhlciBkaXNwZXJzaW9uIGlzIHN1cHBvcnRlZCBvciBub3QuXHJcblx0XHQgKlxyXG5cdFx0ICogQHR5cGUge0Jvb2xlYW59XHJcblx0XHQgKiBAZGVmYXVsdCBmYWxzZVxyXG5cdFx0ICovXHJcblx0XHR0aGlzLmRpc3BlcnNpb24gPSBkaXNwZXJzaW9uO1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogVGhlIGNsZWFyIGNvYXQgcmFkaWFuY2UuXHJcblx0XHQgKlxyXG5cdFx0ICogQHR5cGUge05vZGU/fVxyXG5cdFx0ICogQGRlZmF1bHQgbnVsbFxyXG5cdFx0ICovXHJcblx0XHR0aGlzLmNsZWFyY29hdFJhZGlhbmNlID0gbnVsbDtcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIFRoZSBjbGVhciBjb2F0IHNwZWN1bGFyIGRpcmVjdC5cclxuXHRcdCAqXHJcblx0XHQgKiBAdHlwZSB7Tm9kZT99XHJcblx0XHQgKiBAZGVmYXVsdCBudWxsXHJcblx0XHQgKi9cclxuXHRcdHRoaXMuY2xlYXJjb2F0U3BlY3VsYXJEaXJlY3QgPSBudWxsO1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogVGhlIGNsZWFyIGNvYXQgc3BlY3VsYXIgaW5kaXJlY3QuXHJcblx0XHQgKlxyXG5cdFx0ICogQHR5cGUge05vZGU/fVxyXG5cdFx0ICogQGRlZmF1bHQgbnVsbFxyXG5cdFx0ICovXHJcblx0XHR0aGlzLmNsZWFyY29hdFNwZWN1bGFySW5kaXJlY3QgPSBudWxsO1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogVGhlIHNoZWVuIHNwZWN1bGFyIGRpcmVjdC5cclxuXHRcdCAqXHJcblx0XHQgKiBAdHlwZSB7Tm9kZT99XHJcblx0XHQgKiBAZGVmYXVsdCBudWxsXHJcblx0XHQgKi9cclxuXHRcdHRoaXMuc2hlZW5TcGVjdWxhckRpcmVjdCA9IG51bGw7XHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBUaGUgc2hlZW4gc3BlY3VsYXIgaW5kaXJlY3QuXHJcblx0XHQgKlxyXG5cdFx0ICogQHR5cGUge05vZGU/fVxyXG5cdFx0ICogQGRlZmF1bHQgbnVsbFxyXG5cdFx0ICovXHJcblx0XHR0aGlzLnNoZWVuU3BlY3VsYXJJbmRpcmVjdCA9IG51bGw7XHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBUaGUgaXJpZGVzY2VuY2UgRnJlc25lbC5cclxuXHRcdCAqXHJcblx0XHQgKiBAdHlwZSB7Tm9kZT99XHJcblx0XHQgKiBAZGVmYXVsdCBudWxsXHJcblx0XHQgKi9cclxuXHRcdHRoaXMuaXJpZGVzY2VuY2VGcmVzbmVsID0gbnVsbDtcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIFRoZSBpcmlkZXNjZW5jZSBGMC5cclxuXHRcdCAqXHJcblx0XHQgKiBAdHlwZSB7Tm9kZT99XHJcblx0XHQgKiBAZGVmYXVsdCBudWxsXHJcblx0XHQgKi9cclxuXHRcdHRoaXMuaXJpZGVzY2VuY2VGMCA9IG51bGw7XHJcblxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogRGVwZW5kaW5nIG9uIHdoYXQgZmVhdHVyZXMgYXJlIHJlcXVlc3RlZCwgdGhlIG1ldGhvZCBwcmVwYXJlcyBjZXJ0YWluIG5vZGUgdmFyaWFibGVzXHJcblx0ICogd2hpY2ggYXJlIGxhdGVyIHVzZWQgZm9yIGxpZ2h0aW5nIGNvbXB1dGF0aW9ucy5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7Q29udGV4dE5vZGV9IGNvbnRleHQgLSBUaGUgY3VycmVudCBub2RlIGNvbnRleHQuXHJcblx0ICovXHJcblx0c3RhcnQoIGNvbnRleHQgKSB7XHJcblxyXG5cdFx0aWYgKCB0aGlzLmNsZWFyY29hdCA9PT0gdHJ1ZSApIHtcclxuXHJcblx0XHRcdHRoaXMuY2xlYXJjb2F0UmFkaWFuY2UgPSB2ZWMzKCkudG9WYXIoICdjbGVhcmNvYXRSYWRpYW5jZScgKTtcclxuXHRcdFx0dGhpcy5jbGVhcmNvYXRTcGVjdWxhckRpcmVjdCA9IHZlYzMoKS50b1ZhciggJ2NsZWFyY29hdFNwZWN1bGFyRGlyZWN0JyApO1xyXG5cdFx0XHR0aGlzLmNsZWFyY29hdFNwZWN1bGFySW5kaXJlY3QgPSB2ZWMzKCkudG9WYXIoICdjbGVhcmNvYXRTcGVjdWxhckluZGlyZWN0JyApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIHRoaXMuc2hlZW4gPT09IHRydWUgKSB7XHJcblxyXG5cdFx0XHR0aGlzLnNoZWVuU3BlY3VsYXJEaXJlY3QgPSB2ZWMzKCkudG9WYXIoICdzaGVlblNwZWN1bGFyRGlyZWN0JyApO1xyXG5cdFx0XHR0aGlzLnNoZWVuU3BlY3VsYXJJbmRpcmVjdCA9IHZlYzMoKS50b1ZhciggJ3NoZWVuU3BlY3VsYXJJbmRpcmVjdCcgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCB0aGlzLmlyaWRlc2NlbmNlID09PSB0cnVlICkge1xyXG5cclxuXHRcdFx0Y29uc3QgZG90TlZpID0gdHJhbnNmb3JtZWROb3JtYWxWaWV3LmRvdCggcG9zaXRpb25WaWV3RGlyZWN0aW9uICkuY2xhbXAoKTtcclxuXHJcblx0XHRcdHRoaXMuaXJpZGVzY2VuY2VGcmVzbmVsID0gZXZhbElyaWRlc2NlbmNlKCB7XHJcblx0XHRcdFx0b3V0c2lkZUlPUjogZmxvYXQoIDEuMCApLFxyXG5cdFx0XHRcdGV0YTI6IGlyaWRlc2NlbmNlSU9SLFxyXG5cdFx0XHRcdGNvc1RoZXRhMTogZG90TlZpLFxyXG5cdFx0XHRcdHRoaW5GaWxtVGhpY2tuZXNzOiBpcmlkZXNjZW5jZVRoaWNrbmVzcyxcclxuXHRcdFx0XHRiYXNlRjA6IHNwZWN1bGFyQ29sb3JcclxuXHRcdFx0fSApO1xyXG5cclxuXHRcdFx0dGhpcy5pcmlkZXNjZW5jZUYwID0gU2NobGlja190b19GMCggeyBmOiB0aGlzLmlyaWRlc2NlbmNlRnJlc25lbCwgZjkwOiAxLjAsIGRvdFZIOiBkb3ROVmkgfSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIHRoaXMudHJhbnNtaXNzaW9uID09PSB0cnVlICkge1xyXG5cclxuXHRcdFx0Y29uc3QgcG9zaXRpb24gPSBwb3NpdGlvbldvcmxkO1xyXG5cdFx0XHRjb25zdCB2ID0gY2FtZXJhUG9zaXRpb24uc3ViKCBwb3NpdGlvbldvcmxkICkubm9ybWFsaXplKCk7IC8vIFRPRE86IENyZWF0ZSBOb2RlIGZvciB0aGlzLCBzYW1lIGlzc3VlIGluIE1hdGVyaWFsWFxyXG5cdFx0XHRjb25zdCBuID0gdHJhbnNmb3JtZWROb3JtYWxXb3JsZDtcclxuXHJcblx0XHRcdGNvbnRleHQuYmFja2Ryb3AgPSBnZXRJQkxWb2x1bWVSZWZyYWN0aW9uKFxyXG5cdFx0XHRcdG4sXHJcblx0XHRcdFx0dixcclxuXHRcdFx0XHRyb3VnaG5lc3MsXHJcblx0XHRcdFx0ZGlmZnVzZUNvbG9yLFxyXG5cdFx0XHRcdHNwZWN1bGFyQ29sb3IsXHJcblx0XHRcdFx0c3BlY3VsYXJGOTAsIC8vIHNwZWN1bGFyRjkwXHJcblx0XHRcdFx0cG9zaXRpb24sIC8vIHBvc2l0aW9uV29ybGRcclxuXHRcdFx0XHRtb2RlbFdvcmxkTWF0cml4LCAvLyBtb2RlbE1hdHJpeFxyXG5cdFx0XHRcdGNhbWVyYVZpZXdNYXRyaXgsIC8vIHZpZXdNYXRyaXhcclxuXHRcdFx0XHRjYW1lcmFQcm9qZWN0aW9uTWF0cml4LCAvLyBwcm9qTWF0cml4XHJcblx0XHRcdFx0aW9yLFxyXG5cdFx0XHRcdHRoaWNrbmVzcyxcclxuXHRcdFx0XHRhdHRlbnVhdGlvbkNvbG9yLFxyXG5cdFx0XHRcdGF0dGVudWF0aW9uRGlzdGFuY2UsXHJcblx0XHRcdFx0dGhpcy5kaXNwZXJzaW9uID8gZGlzcGVyc2lvbiA6IG51bGxcclxuXHRcdFx0KTtcclxuXHJcblx0XHRcdGNvbnRleHQuYmFja2Ryb3BBbHBoYSA9IHRyYW5zbWlzc2lvbjtcclxuXHJcblx0XHRcdGRpZmZ1c2VDb2xvci5hLm11bEFzc2lnbiggbWl4KCAxLCBjb250ZXh0LmJhY2tkcm9wLmEsIHRyYW5zbWlzc2lvbiApICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdC8vIEZkZXotQWfDvGVyYSdzIFwiTXVsdGlwbGUtU2NhdHRlcmluZyBNaWNyb2ZhY2V0IE1vZGVsIGZvciBSZWFsLVRpbWUgSW1hZ2UgQmFzZWQgTGlnaHRpbmdcIlxyXG5cdC8vIEFwcHJveGltYXRlcyBtdWx0aS1zY2F0dGVyaW5nIGluIG9yZGVyIHRvIHByZXNlcnZlIGVuZXJneS5cclxuXHQvLyBodHRwOi8vd3d3LmpjZ3Qub3JnL3B1Ymxpc2hlZC8wMDA4LzAxLzAzL1xyXG5cclxuXHRjb21wdXRlTXVsdGlzY2F0dGVyaW5nKCBzaW5nbGVTY2F0dGVyLCBtdWx0aVNjYXR0ZXIsIHNwZWN1bGFyRjkwICkge1xyXG5cclxuXHRcdGNvbnN0IGRvdE5WID0gdHJhbnNmb3JtZWROb3JtYWxWaWV3LmRvdCggcG9zaXRpb25WaWV3RGlyZWN0aW9uICkuY2xhbXAoKTsgLy8gQCBUT0RPOiBNb3ZlIHRvIGNvcmUgZG90TlZcclxuXHJcblx0XHRjb25zdCBmYWIgPSBERkdBcHByb3goIHsgcm91Z2huZXNzLCBkb3ROViB9ICk7XHJcblxyXG5cdFx0Y29uc3QgRnIgPSB0aGlzLmlyaWRlc2NlbmNlRjAgPyBpcmlkZXNjZW5jZS5taXgoIHNwZWN1bGFyQ29sb3IsIHRoaXMuaXJpZGVzY2VuY2VGMCApIDogc3BlY3VsYXJDb2xvcjtcclxuXHJcblx0XHRjb25zdCBGc3NFc3MgPSBGci5tdWwoIGZhYi54ICkuYWRkKCBzcGVjdWxhckY5MC5tdWwoIGZhYi55ICkgKTtcclxuXHJcblx0XHRjb25zdCBFc3MgPSBmYWIueC5hZGQoIGZhYi55ICk7XHJcblx0XHRjb25zdCBFbXMgPSBFc3Mub25lTWludXMoKTtcclxuXHJcblx0XHRjb25zdCBGYXZnID0gc3BlY3VsYXJDb2xvci5hZGQoIHNwZWN1bGFyQ29sb3Iub25lTWludXMoKS5tdWwoIDAuMDQ3NjE5ICkgKTsgLy8gMS8yMVxyXG5cdFx0Y29uc3QgRm1zID0gRnNzRXNzLm11bCggRmF2ZyApLmRpdiggRW1zLm11bCggRmF2ZyApLm9uZU1pbnVzKCkgKTtcclxuXHJcblx0XHRzaW5nbGVTY2F0dGVyLmFkZEFzc2lnbiggRnNzRXNzICk7XHJcblx0XHRtdWx0aVNjYXR0ZXIuYWRkQXNzaWduKCBGbXMubXVsKCBFbXMgKSApO1xyXG5cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEltcGxlbWVudHMgdGhlIGRpcmVjdCBsaWdodC5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dCAtIFRoZSBpbnB1dCBkYXRhLlxyXG5cdCAqIEBwYXJhbSB7U3RhY2tOb2RlfSBzdGFjayAtIFRoZSBjdXJyZW50IHN0YWNrLlxyXG5cdCAqIEBwYXJhbSB7Tm9kZUJ1aWxkZXJ9IGJ1aWxkZXIgLSBUaGUgY3VycmVudCBub2RlIGJ1aWxkZXIuXHJcblx0ICovXHJcblx0ZGlyZWN0KCB7IGxpZ2h0RGlyZWN0aW9uLCBsaWdodENvbG9yLCByZWZsZWN0ZWRMaWdodCB9ICkge1xyXG5cclxuXHRcdGNvbnN0IGRvdE5MID0gdHJhbnNmb3JtZWROb3JtYWxWaWV3LmRvdCggbGlnaHREaXJlY3Rpb24gKS5jbGFtcCgpO1xyXG5cdFx0Y29uc3QgaXJyYWRpYW5jZSA9IGRvdE5MLm11bCggbGlnaHRDb2xvciApO1xyXG5cclxuXHRcdGlmICggdGhpcy5zaGVlbiA9PT0gdHJ1ZSApIHtcclxuXHJcblx0XHRcdHRoaXMuc2hlZW5TcGVjdWxhckRpcmVjdC5hZGRBc3NpZ24oIGlycmFkaWFuY2UubXVsKCBCUkRGX1NoZWVuKCB7IGxpZ2h0RGlyZWN0aW9uIH0gKSApICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggdGhpcy5jbGVhcmNvYXQgPT09IHRydWUgKSB7XHJcblxyXG5cdFx0XHRjb25zdCBkb3ROTGNjID0gdHJhbnNmb3JtZWRDbGVhcmNvYXROb3JtYWxWaWV3LmRvdCggbGlnaHREaXJlY3Rpb24gKS5jbGFtcCgpO1xyXG5cdFx0XHRjb25zdCBjY0lycmFkaWFuY2UgPSBkb3ROTGNjLm11bCggbGlnaHRDb2xvciApO1xyXG5cclxuXHRcdFx0dGhpcy5jbGVhcmNvYXRTcGVjdWxhckRpcmVjdC5hZGRBc3NpZ24oIGNjSXJyYWRpYW5jZS5tdWwoIEJSREZfR0dYKCB7IGxpZ2h0RGlyZWN0aW9uLCBmMDogY2xlYXJjb2F0RjAsIGY5MDogY2xlYXJjb2F0RjkwLCByb3VnaG5lc3M6IGNsZWFyY29hdFJvdWdobmVzcywgbm9ybWFsVmlldzogdHJhbnNmb3JtZWRDbGVhcmNvYXROb3JtYWxWaWV3IH0gKSApICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJlZmxlY3RlZExpZ2h0LmRpcmVjdERpZmZ1c2UuYWRkQXNzaWduKCBpcnJhZGlhbmNlLm11bCggQlJERl9MYW1iZXJ0KCB7IGRpZmZ1c2VDb2xvcjogZGlmZnVzZUNvbG9yLnJnYiB9ICkgKSApO1xyXG5cclxuXHRcdHJlZmxlY3RlZExpZ2h0LmRpcmVjdFNwZWN1bGFyLmFkZEFzc2lnbiggaXJyYWRpYW5jZS5tdWwoIEJSREZfR0dYKCB7IGxpZ2h0RGlyZWN0aW9uLCBmMDogc3BlY3VsYXJDb2xvciwgZjkwOiAxLCByb3VnaG5lc3MsIGlyaWRlc2NlbmNlOiB0aGlzLmlyaWRlc2NlbmNlLCBmOiB0aGlzLmlyaWRlc2NlbmNlRnJlc25lbCwgVVNFX0lSSURFU0NFTkNFOiB0aGlzLmlyaWRlc2NlbmNlLCBVU0VfQU5JU09UUk9QWTogdGhpcy5hbmlzb3Ryb3B5IH0gKSApICk7XHJcblxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogVGhpcyBtZXRob2QgaXMgaW50ZW5kZWQgZm9yIGltcGxlbWVudGluZyB0aGUgZGlyZWN0IGxpZ2h0IHRlcm0gZm9yXHJcblx0ICogcmVjdCBhcmVhIGxpZ2h0IG5vZGVzLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtPYmplY3R9IGlucHV0IC0gVGhlIGlucHV0IGRhdGEuXHJcblx0ICogQHBhcmFtIHtTdGFja05vZGV9IHN0YWNrIC0gVGhlIGN1cnJlbnQgc3RhY2suXHJcblx0ICogQHBhcmFtIHtOb2RlQnVpbGRlcn0gYnVpbGRlciAtIFRoZSBjdXJyZW50IG5vZGUgYnVpbGRlci5cclxuXHQgKi9cclxuXHRkaXJlY3RSZWN0QXJlYSggeyBsaWdodENvbG9yLCBsaWdodFBvc2l0aW9uLCBoYWxmV2lkdGgsIGhhbGZIZWlnaHQsIHJlZmxlY3RlZExpZ2h0LCBsdGNfMSwgbHRjXzIgfSApIHtcclxuXHJcblx0XHRjb25zdCBwMCA9IGxpZ2h0UG9zaXRpb24uYWRkKCBoYWxmV2lkdGggKS5zdWIoIGhhbGZIZWlnaHQgKTsgLy8gY291bnRlcmNsb2Nrd2lzZTsgbGlnaHQgc2hpbmVzIGluIGxvY2FsIG5lZyB6IGRpcmVjdGlvblxyXG5cdFx0Y29uc3QgcDEgPSBsaWdodFBvc2l0aW9uLnN1YiggaGFsZldpZHRoICkuc3ViKCBoYWxmSGVpZ2h0ICk7XHJcblx0XHRjb25zdCBwMiA9IGxpZ2h0UG9zaXRpb24uc3ViKCBoYWxmV2lkdGggKS5hZGQoIGhhbGZIZWlnaHQgKTtcclxuXHRcdGNvbnN0IHAzID0gbGlnaHRQb3NpdGlvbi5hZGQoIGhhbGZXaWR0aCApLmFkZCggaGFsZkhlaWdodCApO1xyXG5cclxuXHRcdGNvbnN0IE4gPSB0cmFuc2Zvcm1lZE5vcm1hbFZpZXc7XHJcblx0XHRjb25zdCBWID0gcG9zaXRpb25WaWV3RGlyZWN0aW9uO1xyXG5cdFx0Y29uc3QgUCA9IHBvc2l0aW9uVmlldy50b1ZhcigpO1xyXG5cclxuXHRcdGNvbnN0IHV2ID0gTFRDX1V2KCB7IE4sIFYsIHJvdWdobmVzcyB9ICk7XHJcblxyXG5cdFx0Y29uc3QgdDEgPSBsdGNfMS5zYW1wbGUoIHV2ICkudG9WYXIoKTtcclxuXHRcdGNvbnN0IHQyID0gbHRjXzIuc2FtcGxlKCB1diApLnRvVmFyKCk7XHJcblxyXG5cdFx0Y29uc3QgbUludiA9IG1hdDMoXHJcblx0XHRcdHZlYzMoIHQxLngsIDAsIHQxLnkgKSxcclxuXHRcdFx0dmVjMyggMCwgMSwgMCApLFxyXG5cdFx0XHR2ZWMzKCB0MS56LCAwLCB0MS53IClcclxuXHRcdCkudG9WYXIoKTtcclxuXHJcblx0XHQvLyBMVEMgRnJlc25lbCBBcHByb3hpbWF0aW9uIGJ5IFN0ZXBoZW4gSGlsbFxyXG5cdFx0Ly8gaHR0cDovL2Jsb2cuc2VsZnNoYWRvdy5jb20vcHVibGljYXRpb25zL3MyMDE2LWFkdmFuY2VzL3MyMDE2X2x0Y19mcmVzbmVsLnBkZlxyXG5cdFx0Y29uc3QgZnJlc25lbCA9IHNwZWN1bGFyQ29sb3IubXVsKCB0Mi54ICkuYWRkKCBzcGVjdWxhckNvbG9yLm9uZU1pbnVzKCkubXVsKCB0Mi55ICkgKS50b1ZhcigpO1xyXG5cclxuXHRcdHJlZmxlY3RlZExpZ2h0LmRpcmVjdFNwZWN1bGFyLmFkZEFzc2lnbiggbGlnaHRDb2xvci5tdWwoIGZyZXNuZWwgKS5tdWwoIExUQ19FdmFsdWF0ZSggeyBOLCBWLCBQLCBtSW52LCBwMCwgcDEsIHAyLCBwMyB9ICkgKSApO1xyXG5cclxuXHRcdHJlZmxlY3RlZExpZ2h0LmRpcmVjdERpZmZ1c2UuYWRkQXNzaWduKCBsaWdodENvbG9yLm11bCggZGlmZnVzZUNvbG9yICkubXVsKCBMVENfRXZhbHVhdGUoIHsgTiwgViwgUCwgbUludjogbWF0MyggMSwgMCwgMCwgMCwgMSwgMCwgMCwgMCwgMSApLCBwMCwgcDEsIHAyLCBwMyB9ICkgKSApO1xyXG5cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEltcGxlbWVudHMgdGhlIGluZGlyZWN0IGxpZ2h0aW5nLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtDb250ZXh0Tm9kZX0gY29udGV4dCAtIFRoZSBjdXJyZW50IG5vZGUgY29udGV4dC5cclxuXHQgKiBAcGFyYW0ge1N0YWNrTm9kZX0gc3RhY2sgLSBUaGUgY3VycmVudCBzdGFjay5cclxuXHQgKiBAcGFyYW0ge05vZGVCdWlsZGVyfSBidWlsZGVyIC0gVGhlIGN1cnJlbnQgbm9kZSBidWlsZGVyLlxyXG5cdCAqL1xyXG5cdGluZGlyZWN0KCBjb250ZXh0LCBzdGFjaywgYnVpbGRlciApIHtcclxuXHJcblx0XHR0aGlzLmluZGlyZWN0RGlmZnVzZSggY29udGV4dCwgc3RhY2ssIGJ1aWxkZXIgKTtcclxuXHRcdHRoaXMuaW5kaXJlY3RTcGVjdWxhciggY29udGV4dCwgc3RhY2ssIGJ1aWxkZXIgKTtcclxuXHRcdHRoaXMuYW1iaWVudE9jY2x1c2lvbiggY29udGV4dCwgc3RhY2ssIGJ1aWxkZXIgKTtcclxuXHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBJbXBsZW1lbnRzIHRoZSBpbmRpcmVjdCBkaWZmdXNlIHRlcm0uXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge0NvbnRleHROb2RlfSBpbnB1dCAtIFRoZSBjdXJyZW50IG5vZGUgY29udGV4dC5cclxuXHQgKiBAcGFyYW0ge1N0YWNrTm9kZX0gc3RhY2sgLSBUaGUgY3VycmVudCBzdGFjay5cclxuXHQgKiBAcGFyYW0ge05vZGVCdWlsZGVyfSBidWlsZGVyIC0gVGhlIGN1cnJlbnQgbm9kZSBidWlsZGVyLlxyXG5cdCAqL1xyXG5cdGluZGlyZWN0RGlmZnVzZSggeyBpcnJhZGlhbmNlLCByZWZsZWN0ZWRMaWdodCB9ICkge1xyXG5cclxuXHRcdHJlZmxlY3RlZExpZ2h0LmluZGlyZWN0RGlmZnVzZS5hZGRBc3NpZ24oIGlycmFkaWFuY2UubXVsKCBCUkRGX0xhbWJlcnQoIHsgZGlmZnVzZUNvbG9yIH0gKSApICk7XHJcblxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogSW1wbGVtZW50cyB0aGUgaW5kaXJlY3Qgc3BlY3VsYXIgdGVybS5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7Q29udGV4dE5vZGV9IGlucHV0IC0gVGhlIGN1cnJlbnQgbm9kZSBjb250ZXh0LlxyXG5cdCAqIEBwYXJhbSB7U3RhY2tOb2RlfSBzdGFjayAtIFRoZSBjdXJyZW50IHN0YWNrLlxyXG5cdCAqIEBwYXJhbSB7Tm9kZUJ1aWxkZXJ9IGJ1aWxkZXIgLSBUaGUgY3VycmVudCBub2RlIGJ1aWxkZXIuXHJcblx0ICovXHJcblx0aW5kaXJlY3RTcGVjdWxhciggeyByYWRpYW5jZSwgaWJsSXJyYWRpYW5jZSwgcmVmbGVjdGVkTGlnaHQgfSApIHtcclxuXHJcblx0XHRpZiAoIHRoaXMuc2hlZW4gPT09IHRydWUgKSB7XHJcblxyXG5cdFx0XHR0aGlzLnNoZWVuU3BlY3VsYXJJbmRpcmVjdC5hZGRBc3NpZ24oIGlibElycmFkaWFuY2UubXVsKFxyXG5cdFx0XHRcdHNoZWVuLFxyXG5cdFx0XHRcdElCTFNoZWVuQlJERigge1xyXG5cdFx0XHRcdFx0bm9ybWFsOiB0cmFuc2Zvcm1lZE5vcm1hbFZpZXcsXHJcblx0XHRcdFx0XHR2aWV3RGlyOiBwb3NpdGlvblZpZXdEaXJlY3Rpb24sXHJcblx0XHRcdFx0XHRyb3VnaG5lc3M6IHNoZWVuUm91Z2huZXNzXHJcblx0XHRcdFx0fSApXHJcblx0XHRcdCkgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCB0aGlzLmNsZWFyY29hdCA9PT0gdHJ1ZSApIHtcclxuXHJcblx0XHRcdGNvbnN0IGRvdE5WY2MgPSB0cmFuc2Zvcm1lZENsZWFyY29hdE5vcm1hbFZpZXcuZG90KCBwb3NpdGlvblZpZXdEaXJlY3Rpb24gKS5jbGFtcCgpO1xyXG5cclxuXHRcdFx0Y29uc3QgY2xlYXJjb2F0RW52ID0gRW52aXJvbm1lbnRCUkRGKCB7XHJcblx0XHRcdFx0ZG90TlY6IGRvdE5WY2MsXHJcblx0XHRcdFx0c3BlY3VsYXJDb2xvcjogY2xlYXJjb2F0RjAsXHJcblx0XHRcdFx0c3BlY3VsYXJGOTA6IGNsZWFyY29hdEY5MCxcclxuXHRcdFx0XHRyb3VnaG5lc3M6IGNsZWFyY29hdFJvdWdobmVzc1xyXG5cdFx0XHR9ICk7XHJcblxyXG5cdFx0XHR0aGlzLmNsZWFyY29hdFNwZWN1bGFySW5kaXJlY3QuYWRkQXNzaWduKCB0aGlzLmNsZWFyY29hdFJhZGlhbmNlLm11bCggY2xlYXJjb2F0RW52ICkgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gQm90aCBpbmRpcmVjdCBzcGVjdWxhciBhbmQgaW5kaXJlY3QgZGlmZnVzZSBsaWdodCBhY2N1bXVsYXRlIGhlcmVcclxuXHJcblx0XHRjb25zdCBzaW5nbGVTY2F0dGVyaW5nID0gdmVjMygpLnRvVmFyKCAnc2luZ2xlU2NhdHRlcmluZycgKTtcclxuXHRcdGNvbnN0IG11bHRpU2NhdHRlcmluZyA9IHZlYzMoKS50b1ZhciggJ211bHRpU2NhdHRlcmluZycgKTtcclxuXHRcdGNvbnN0IGNvc2luZVdlaWdodGVkSXJyYWRpYW5jZSA9IGlibElycmFkaWFuY2UubXVsKCAxIC8gTWF0aC5QSSApO1xyXG5cclxuXHRcdHRoaXMuY29tcHV0ZU11bHRpc2NhdHRlcmluZyggc2luZ2xlU2NhdHRlcmluZywgbXVsdGlTY2F0dGVyaW5nLCBzcGVjdWxhckY5MCApO1xyXG5cclxuXHRcdGNvbnN0IHRvdGFsU2NhdHRlcmluZyA9IHNpbmdsZVNjYXR0ZXJpbmcuYWRkKCBtdWx0aVNjYXR0ZXJpbmcgKTtcclxuXHJcblx0XHRjb25zdCBkaWZmdXNlID0gZGlmZnVzZUNvbG9yLm11bCggdG90YWxTY2F0dGVyaW5nLnIubWF4KCB0b3RhbFNjYXR0ZXJpbmcuZyApLm1heCggdG90YWxTY2F0dGVyaW5nLmIgKS5vbmVNaW51cygpICk7XHJcblxyXG5cdFx0cmVmbGVjdGVkTGlnaHQuaW5kaXJlY3RTcGVjdWxhci5hZGRBc3NpZ24oIHJhZGlhbmNlLm11bCggc2luZ2xlU2NhdHRlcmluZyApICk7XHJcblx0XHRyZWZsZWN0ZWRMaWdodC5pbmRpcmVjdFNwZWN1bGFyLmFkZEFzc2lnbiggbXVsdGlTY2F0dGVyaW5nLm11bCggY29zaW5lV2VpZ2h0ZWRJcnJhZGlhbmNlICkgKTtcclxuXHJcblx0XHRyZWZsZWN0ZWRMaWdodC5pbmRpcmVjdERpZmZ1c2UuYWRkQXNzaWduKCBkaWZmdXNlLm11bCggY29zaW5lV2VpZ2h0ZWRJcnJhZGlhbmNlICkgKTtcclxuXHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBJbXBsZW1lbnRzIHRoZSBhbWJpZW50IG9jY2x1c2lvbiB0ZXJtLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtDb250ZXh0Tm9kZX0gaW5wdXQgLSBUaGUgY3VycmVudCBub2RlIGNvbnRleHQuXHJcblx0ICogQHBhcmFtIHtTdGFja05vZGV9IHN0YWNrIC0gVGhlIGN1cnJlbnQgc3RhY2suXHJcblx0ICogQHBhcmFtIHtOb2RlQnVpbGRlcn0gYnVpbGRlciAtIFRoZSBjdXJyZW50IG5vZGUgYnVpbGRlci5cclxuXHQgKi9cclxuXHRhbWJpZW50T2NjbHVzaW9uKCB7IGFtYmllbnRPY2NsdXNpb24sIHJlZmxlY3RlZExpZ2h0IH0gKSB7XHJcblxyXG5cdFx0Y29uc3QgZG90TlYgPSB0cmFuc2Zvcm1lZE5vcm1hbFZpZXcuZG90KCBwb3NpdGlvblZpZXdEaXJlY3Rpb24gKS5jbGFtcCgpOyAvLyBAIFRPRE86IE1vdmUgdG8gY29yZSBkb3ROVlxyXG5cclxuXHRcdGNvbnN0IGFvTlYgPSBkb3ROVi5hZGQoIGFtYmllbnRPY2NsdXNpb24gKTtcclxuXHRcdGNvbnN0IGFvRXhwID0gcm91Z2huZXNzLm11bCggLSAxNi4wICkub25lTWludXMoKS5uZWdhdGUoKS5leHAyKCk7XHJcblxyXG5cdFx0Y29uc3QgYW9Ob2RlID0gYW1iaWVudE9jY2x1c2lvbi5zdWIoIGFvTlYucG93KCBhb0V4cCApLm9uZU1pbnVzKCkgKS5jbGFtcCgpO1xyXG5cclxuXHRcdGlmICggdGhpcy5jbGVhcmNvYXQgPT09IHRydWUgKSB7XHJcblxyXG5cdFx0XHR0aGlzLmNsZWFyY29hdFNwZWN1bGFySW5kaXJlY3QubXVsQXNzaWduKCBhbWJpZW50T2NjbHVzaW9uICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggdGhpcy5zaGVlbiA9PT0gdHJ1ZSApIHtcclxuXHJcblx0XHRcdHRoaXMuc2hlZW5TcGVjdWxhckluZGlyZWN0Lm11bEFzc2lnbiggYW1iaWVudE9jY2x1c2lvbiApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZWZsZWN0ZWRMaWdodC5pbmRpcmVjdERpZmZ1c2UubXVsQXNzaWduKCBhbWJpZW50T2NjbHVzaW9uICk7XHJcblx0XHRyZWZsZWN0ZWRMaWdodC5pbmRpcmVjdFNwZWN1bGFyLm11bEFzc2lnbiggYW9Ob2RlICk7XHJcblxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogVXNlZCBmb3IgZmluYWwgbGlnaHRpbmcgYWNjdW11bGF0aW9ucyBkZXBlbmRpbmcgb24gdGhlIHJlcXVlc3RlZCBmZWF0dXJlcy5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7Q29udGV4dE5vZGV9IGNvbnRleHQgLSBUaGUgY3VycmVudCBub2RlIGNvbnRleHQuXHJcblx0ICogQHBhcmFtIHtTdGFja05vZGV9IHN0YWNrIC0gVGhlIGN1cnJlbnQgc3RhY2suXHJcblx0ICogQHBhcmFtIHtOb2RlQnVpbGRlcn0gYnVpbGRlciAtIFRoZSBjdXJyZW50IG5vZGUgYnVpbGRlci5cclxuXHQgKi9cclxuXHRmaW5pc2goIGNvbnRleHQgKSB7XHJcblxyXG5cdFx0Y29uc3QgeyBvdXRnb2luZ0xpZ2h0IH0gPSBjb250ZXh0O1xyXG5cclxuXHRcdGlmICggdGhpcy5jbGVhcmNvYXQgPT09IHRydWUgKSB7XHJcblxyXG5cdFx0XHRjb25zdCBkb3ROVmNjID0gdHJhbnNmb3JtZWRDbGVhcmNvYXROb3JtYWxWaWV3LmRvdCggcG9zaXRpb25WaWV3RGlyZWN0aW9uICkuY2xhbXAoKTtcclxuXHJcblx0XHRcdGNvbnN0IEZjYyA9IEZfU2NobGljaygge1xyXG5cdFx0XHRcdGRvdFZIOiBkb3ROVmNjLFxyXG5cdFx0XHRcdGYwOiBjbGVhcmNvYXRGMCxcclxuXHRcdFx0XHRmOTA6IGNsZWFyY29hdEY5MFxyXG5cdFx0XHR9ICk7XHJcblxyXG5cdFx0XHRjb25zdCBjbGVhcmNvYXRMaWdodCA9IG91dGdvaW5nTGlnaHQubXVsKCBjbGVhcmNvYXQubXVsKCBGY2MgKS5vbmVNaW51cygpICkuYWRkKCB0aGlzLmNsZWFyY29hdFNwZWN1bGFyRGlyZWN0LmFkZCggdGhpcy5jbGVhcmNvYXRTcGVjdWxhckluZGlyZWN0ICkubXVsKCBjbGVhcmNvYXQgKSApO1xyXG5cclxuXHRcdFx0b3V0Z29pbmdMaWdodC5hc3NpZ24oIGNsZWFyY29hdExpZ2h0ICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggdGhpcy5zaGVlbiA9PT0gdHJ1ZSApIHtcclxuXHJcblx0XHRcdGNvbnN0IHNoZWVuRW5lcmd5Q29tcCA9IHNoZWVuLnIubWF4KCBzaGVlbi5nICkubWF4KCBzaGVlbi5iICkubXVsKCAwLjE1NyApLm9uZU1pbnVzKCk7XHJcblx0XHRcdGNvbnN0IHNoZWVuTGlnaHQgPSBvdXRnb2luZ0xpZ2h0Lm11bCggc2hlZW5FbmVyZ3lDb21wICkuYWRkKCB0aGlzLnNoZWVuU3BlY3VsYXJEaXJlY3QsIHRoaXMuc2hlZW5TcGVjdWxhckluZGlyZWN0ICk7XHJcblxyXG5cdFx0XHRvdXRnb2luZ0xpZ2h0LmFzc2lnbiggc2hlZW5MaWdodCApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgUGh5c2ljYWxMaWdodGluZ01vZGVsO1xyXG4iLCJpbXBvcnQgeyBGbiwgaW50LCBmbG9hdCwgdmVjMiwgdmVjMywgdmVjNCwgSWYgfSBmcm9tICcuLi90c2wvVFNMQmFzZS5qcyc7XHJcbmltcG9ydCB7IGNvcywgc2luLCBhYnMsIG1heCwgZXhwMiwgbG9nMiwgY2xhbXAsIGZyYWN0LCBtaXgsIGZsb29yLCBub3JtYWxpemUsIGNyb3NzLCBhbGwgfSBmcm9tICcuLi9tYXRoL01hdGhOb2RlLmpzJztcclxuaW1wb3J0IHsgbXVsIH0gZnJvbSAnLi4vbWF0aC9PcGVyYXRvck5vZGUuanMnO1xyXG5pbXBvcnQgeyBzZWxlY3QgfSBmcm9tICcuLi9tYXRoL0NvbmRpdGlvbmFsTm9kZS5qcyc7XHJcbmltcG9ydCB7IExvb3AsIEJyZWFrIH0gZnJvbSAnLi4vdXRpbHMvTG9vcE5vZGUuanMnO1xyXG5cclxuLy8gVGhlc2UgZGVmaW5lcyBtdXN0IG1hdGNoIHdpdGggUE1SRU1HZW5lcmF0b3JcclxuXHJcbmNvbnN0IGN1YmVVVl9yMCA9IC8qQF9fUFVSRV9fKi8gZmxvYXQoIDEuMCApO1xyXG5jb25zdCBjdWJlVVZfbTAgPSAvKkBfX1BVUkVfXyovIGZsb2F0KCAtIDIuMCApO1xyXG5jb25zdCBjdWJlVVZfcjEgPSAvKkBfX1BVUkVfXyovIGZsb2F0KCAwLjggKTtcclxuY29uc3QgY3ViZVVWX20xID0gLypAX19QVVJFX18qLyBmbG9hdCggLSAxLjAgKTtcclxuY29uc3QgY3ViZVVWX3I0ID0gLypAX19QVVJFX18qLyBmbG9hdCggMC40ICk7XHJcbmNvbnN0IGN1YmVVVl9tNCA9IC8qQF9fUFVSRV9fKi8gZmxvYXQoIDIuMCApO1xyXG5jb25zdCBjdWJlVVZfcjUgPSAvKkBfX1BVUkVfXyovIGZsb2F0KCAwLjMwNSApO1xyXG5jb25zdCBjdWJlVVZfbTUgPSAvKkBfX1BVUkVfXyovIGZsb2F0KCAzLjAgKTtcclxuY29uc3QgY3ViZVVWX3I2ID0gLypAX19QVVJFX18qLyBmbG9hdCggMC4yMSApO1xyXG5jb25zdCBjdWJlVVZfbTYgPSAvKkBfX1BVUkVfXyovIGZsb2F0KCA0LjAgKTtcclxuXHJcbmNvbnN0IGN1YmVVVl9taW5NaXBMZXZlbCA9IC8qQF9fUFVSRV9fKi8gZmxvYXQoIDQuMCApO1xyXG5jb25zdCBjdWJlVVZfbWluVGlsZVNpemUgPSAvKkBfX1BVUkVfXyovIGZsb2F0KCAxNi4wICk7XHJcblxyXG4vLyBUaGVzZSBzaGFkZXIgZnVuY3Rpb25zIGNvbnZlcnQgYmV0d2VlbiB0aGUgVVYgY29vcmRpbmF0ZXMgb2YgYSBzaW5nbGUgZmFjZSBvZlxyXG4vLyBhIGN1YmVtYXAsIHRoZSAwLTUgaW50ZWdlciBpbmRleCBvZiBhIGN1YmUgZmFjZSwgYW5kIHRoZSBkaXJlY3Rpb24gdmVjdG9yIGZvclxyXG4vLyBzYW1wbGluZyBhIHRleHR1cmVDdWJlIChub3QgZ2VuZXJhbGx5IG5vcm1hbGl6ZWQgKS5cclxuXHJcbmNvbnN0IGdldEZhY2UgPSAvKkBfX1BVUkVfXyovIEZuKCAoIFsgZGlyZWN0aW9uIF0gKSA9PiB7XHJcblxyXG5cdGNvbnN0IGFic0RpcmVjdGlvbiA9IHZlYzMoIGFicyggZGlyZWN0aW9uICkgKS50b1ZhcigpO1xyXG5cdGNvbnN0IGZhY2UgPSBmbG9hdCggLSAxLjAgKS50b1ZhcigpO1xyXG5cclxuXHRJZiggYWJzRGlyZWN0aW9uLnguZ3JlYXRlclRoYW4oIGFic0RpcmVjdGlvbi56ICksICgpID0+IHtcclxuXHJcblx0XHRJZiggYWJzRGlyZWN0aW9uLnguZ3JlYXRlclRoYW4oIGFic0RpcmVjdGlvbi55ICksICgpID0+IHtcclxuXHJcblx0XHRcdGZhY2UuYXNzaWduKCBzZWxlY3QoIGRpcmVjdGlvbi54LmdyZWF0ZXJUaGFuKCAwLjAgKSwgMC4wLCAzLjAgKSApO1xyXG5cclxuXHRcdH0gKS5FbHNlKCAoKSA9PiB7XHJcblxyXG5cdFx0XHRmYWNlLmFzc2lnbiggc2VsZWN0KCBkaXJlY3Rpb24ueS5ncmVhdGVyVGhhbiggMC4wICksIDEuMCwgNC4wICkgKTtcclxuXHJcblx0XHR9ICk7XHJcblxyXG5cdH0gKS5FbHNlKCAoKSA9PiB7XHJcblxyXG5cdFx0SWYoIGFic0RpcmVjdGlvbi56LmdyZWF0ZXJUaGFuKCBhYnNEaXJlY3Rpb24ueSApLCAoKSA9PiB7XHJcblxyXG5cdFx0XHRmYWNlLmFzc2lnbiggc2VsZWN0KCBkaXJlY3Rpb24uei5ncmVhdGVyVGhhbiggMC4wICksIDIuMCwgNS4wICkgKTtcclxuXHJcblx0XHR9ICkuRWxzZSggKCkgPT4ge1xyXG5cclxuXHRcdFx0ZmFjZS5hc3NpZ24oIHNlbGVjdCggZGlyZWN0aW9uLnkuZ3JlYXRlclRoYW4oIDAuMCApLCAxLjAsIDQuMCApICk7XHJcblxyXG5cdFx0fSApO1xyXG5cclxuXHR9ICk7XHJcblxyXG5cdHJldHVybiBmYWNlO1xyXG5cclxufSApLnNldExheW91dCgge1xyXG5cdG5hbWU6ICdnZXRGYWNlJyxcclxuXHR0eXBlOiAnZmxvYXQnLFxyXG5cdGlucHV0czogW1xyXG5cdFx0eyBuYW1lOiAnZGlyZWN0aW9uJywgdHlwZTogJ3ZlYzMnIH1cclxuXHRdXHJcbn0gKTtcclxuXHJcbi8vIFJIIGNvb3JkaW5hdGUgc3lzdGVtOyBQTVJFTSBmYWNlLWluZGV4aW5nIGNvbnZlbnRpb25cclxuY29uc3QgZ2V0VVYgPSAvKkBfX1BVUkVfXyovIEZuKCAoIFsgZGlyZWN0aW9uLCBmYWNlIF0gKSA9PiB7XHJcblxyXG5cdGNvbnN0IHV2ID0gdmVjMigpLnRvVmFyKCk7XHJcblxyXG5cdElmKCBmYWNlLmVxdWFsKCAwLjAgKSwgKCkgPT4ge1xyXG5cclxuXHRcdHV2LmFzc2lnbiggdmVjMiggZGlyZWN0aW9uLnosIGRpcmVjdGlvbi55ICkuZGl2KCBhYnMoIGRpcmVjdGlvbi54ICkgKSApOyAvLyBwb3MgeFxyXG5cclxuXHR9ICkuRWxzZUlmKCBmYWNlLmVxdWFsKCAxLjAgKSwgKCkgPT4ge1xyXG5cclxuXHRcdHV2LmFzc2lnbiggdmVjMiggZGlyZWN0aW9uLngubmVnYXRlKCksIGRpcmVjdGlvbi56Lm5lZ2F0ZSgpICkuZGl2KCBhYnMoIGRpcmVjdGlvbi55ICkgKSApOyAvLyBwb3MgeVxyXG5cclxuXHR9ICkuRWxzZUlmKCBmYWNlLmVxdWFsKCAyLjAgKSwgKCkgPT4ge1xyXG5cclxuXHRcdHV2LmFzc2lnbiggdmVjMiggZGlyZWN0aW9uLngubmVnYXRlKCksIGRpcmVjdGlvbi55ICkuZGl2KCBhYnMoIGRpcmVjdGlvbi56ICkgKSApOyAvLyBwb3MgelxyXG5cclxuXHR9ICkuRWxzZUlmKCBmYWNlLmVxdWFsKCAzLjAgKSwgKCkgPT4ge1xyXG5cclxuXHRcdHV2LmFzc2lnbiggdmVjMiggZGlyZWN0aW9uLnoubmVnYXRlKCksIGRpcmVjdGlvbi55ICkuZGl2KCBhYnMoIGRpcmVjdGlvbi54ICkgKSApOyAvLyBuZWcgeFxyXG5cclxuXHR9ICkuRWxzZUlmKCBmYWNlLmVxdWFsKCA0LjAgKSwgKCkgPT4ge1xyXG5cclxuXHRcdHV2LmFzc2lnbiggdmVjMiggZGlyZWN0aW9uLngubmVnYXRlKCksIGRpcmVjdGlvbi56ICkuZGl2KCBhYnMoIGRpcmVjdGlvbi55ICkgKSApOyAvLyBuZWcgeVxyXG5cclxuXHR9ICkuRWxzZSggKCkgPT4ge1xyXG5cclxuXHRcdHV2LmFzc2lnbiggdmVjMiggZGlyZWN0aW9uLngsIGRpcmVjdGlvbi55ICkuZGl2KCBhYnMoIGRpcmVjdGlvbi56ICkgKSApOyAvLyBuZWcgelxyXG5cclxuXHR9ICk7XHJcblxyXG5cdHJldHVybiBtdWwoIDAuNSwgdXYuYWRkKCAxLjAgKSApO1xyXG5cclxufSApLnNldExheW91dCgge1xyXG5cdG5hbWU6ICdnZXRVVicsXHJcblx0dHlwZTogJ3ZlYzInLFxyXG5cdGlucHV0czogW1xyXG5cdFx0eyBuYW1lOiAnZGlyZWN0aW9uJywgdHlwZTogJ3ZlYzMnIH0sXHJcblx0XHR7IG5hbWU6ICdmYWNlJywgdHlwZTogJ2Zsb2F0JyB9XHJcblx0XVxyXG59ICk7XHJcblxyXG5jb25zdCByb3VnaG5lc3NUb01pcCA9IC8qQF9fUFVSRV9fKi8gRm4oICggWyByb3VnaG5lc3MgXSApID0+IHtcclxuXHJcblx0Y29uc3QgbWlwID0gZmxvYXQoIDAuMCApLnRvVmFyKCk7XHJcblxyXG5cdElmKCByb3VnaG5lc3MuZ3JlYXRlclRoYW5FcXVhbCggY3ViZVVWX3IxICksICgpID0+IHtcclxuXHJcblx0XHRtaXAuYXNzaWduKCBjdWJlVVZfcjAuc3ViKCByb3VnaG5lc3MgKS5tdWwoIGN1YmVVVl9tMS5zdWIoIGN1YmVVVl9tMCApICkuZGl2KCBjdWJlVVZfcjAuc3ViKCBjdWJlVVZfcjEgKSApLmFkZCggY3ViZVVWX20wICkgKTtcclxuXHJcblx0fSApLkVsc2VJZiggcm91Z2huZXNzLmdyZWF0ZXJUaGFuRXF1YWwoIGN1YmVVVl9yNCApLCAoKSA9PiB7XHJcblxyXG5cdFx0bWlwLmFzc2lnbiggY3ViZVVWX3IxLnN1Yiggcm91Z2huZXNzICkubXVsKCBjdWJlVVZfbTQuc3ViKCBjdWJlVVZfbTEgKSApLmRpdiggY3ViZVVWX3IxLnN1YiggY3ViZVVWX3I0ICkgKS5hZGQoIGN1YmVVVl9tMSApICk7XHJcblxyXG5cdH0gKS5FbHNlSWYoIHJvdWdobmVzcy5ncmVhdGVyVGhhbkVxdWFsKCBjdWJlVVZfcjUgKSwgKCkgPT4ge1xyXG5cclxuXHRcdG1pcC5hc3NpZ24oIGN1YmVVVl9yNC5zdWIoIHJvdWdobmVzcyApLm11bCggY3ViZVVWX201LnN1YiggY3ViZVVWX200ICkgKS5kaXYoIGN1YmVVVl9yNC5zdWIoIGN1YmVVVl9yNSApICkuYWRkKCBjdWJlVVZfbTQgKSApO1xyXG5cclxuXHR9ICkuRWxzZUlmKCByb3VnaG5lc3MuZ3JlYXRlclRoYW5FcXVhbCggY3ViZVVWX3I2ICksICgpID0+IHtcclxuXHJcblx0XHRtaXAuYXNzaWduKCBjdWJlVVZfcjUuc3ViKCByb3VnaG5lc3MgKS5tdWwoIGN1YmVVVl9tNi5zdWIoIGN1YmVVVl9tNSApICkuZGl2KCBjdWJlVVZfcjUuc3ViKCBjdWJlVVZfcjYgKSApLmFkZCggY3ViZVVWX201ICkgKTtcclxuXHJcblx0fSApLkVsc2UoICgpID0+IHtcclxuXHJcblx0XHRtaXAuYXNzaWduKCBmbG9hdCggLSAyLjAgKS5tdWwoIGxvZzIoIG11bCggMS4xNiwgcm91Z2huZXNzICkgKSApICk7IC8vIDEuMTYgPSAxLjc5XjAuMjVcclxuXHJcblx0fSApO1xyXG5cclxuXHRyZXR1cm4gbWlwO1xyXG5cclxufSApLnNldExheW91dCgge1xyXG5cdG5hbWU6ICdyb3VnaG5lc3NUb01pcCcsXHJcblx0dHlwZTogJ2Zsb2F0JyxcclxuXHRpbnB1dHM6IFtcclxuXHRcdHsgbmFtZTogJ3JvdWdobmVzcycsIHR5cGU6ICdmbG9hdCcgfVxyXG5cdF1cclxufSApO1xyXG5cclxuLy8gUkggY29vcmRpbmF0ZSBzeXN0ZW07IFBNUkVNIGZhY2UtaW5kZXhpbmcgY29udmVudGlvblxyXG5leHBvcnQgY29uc3QgZ2V0RGlyZWN0aW9uID0gLypAX19QVVJFX18qLyBGbiggKCBbIHV2X2ltbXV0YWJsZSwgZmFjZSBdICkgPT4ge1xyXG5cclxuXHRjb25zdCB1diA9IHV2X2ltbXV0YWJsZS50b1ZhcigpO1xyXG5cdHV2LmFzc2lnbiggbXVsKCAyLjAsIHV2ICkuc3ViKCAxLjAgKSApO1xyXG5cdGNvbnN0IGRpcmVjdGlvbiA9IHZlYzMoIHV2LCAxLjAgKS50b1ZhcigpO1xyXG5cclxuXHRJZiggZmFjZS5lcXVhbCggMC4wICksICgpID0+IHtcclxuXHJcblx0XHRkaXJlY3Rpb24uYXNzaWduKCBkaXJlY3Rpb24uenl4ICk7IC8vICggMSwgdiwgdSApIHBvcyB4XHJcblxyXG5cdH0gKS5FbHNlSWYoIGZhY2UuZXF1YWwoIDEuMCApLCAoKSA9PiB7XHJcblxyXG5cdFx0ZGlyZWN0aW9uLmFzc2lnbiggZGlyZWN0aW9uLnh6eSApO1xyXG5cdFx0ZGlyZWN0aW9uLnh6Lm11bEFzc2lnbiggLSAxLjAgKTsgLy8gKCAtdSwgMSwgLXYgKSBwb3MgeVxyXG5cclxuXHR9ICkuRWxzZUlmKCBmYWNlLmVxdWFsKCAyLjAgKSwgKCkgPT4ge1xyXG5cclxuXHRcdGRpcmVjdGlvbi54Lm11bEFzc2lnbiggLSAxLjAgKTsgLy8gKCAtdSwgdiwgMSApIHBvcyB6XHJcblxyXG5cdH0gKS5FbHNlSWYoIGZhY2UuZXF1YWwoIDMuMCApLCAoKSA9PiB7XHJcblxyXG5cdFx0ZGlyZWN0aW9uLmFzc2lnbiggZGlyZWN0aW9uLnp5eCApO1xyXG5cdFx0ZGlyZWN0aW9uLnh6Lm11bEFzc2lnbiggLSAxLjAgKTsgLy8gKCAtMSwgdiwgLXUgKSBuZWcgeFxyXG5cclxuXHR9ICkuRWxzZUlmKCBmYWNlLmVxdWFsKCA0LjAgKSwgKCkgPT4ge1xyXG5cclxuXHRcdGRpcmVjdGlvbi5hc3NpZ24oIGRpcmVjdGlvbi54enkgKTtcclxuXHRcdGRpcmVjdGlvbi54eS5tdWxBc3NpZ24oIC0gMS4wICk7IC8vICggLXUsIC0xLCB2ICkgbmVnIHlcclxuXHJcblx0fSApLkVsc2VJZiggZmFjZS5lcXVhbCggNS4wICksICgpID0+IHtcclxuXHJcblx0XHRkaXJlY3Rpb24uei5tdWxBc3NpZ24oIC0gMS4wICk7IC8vICggdSwgdiwgLTEgKSBuZWcgelNcclxuXHJcblx0fSApO1xyXG5cclxuXHRyZXR1cm4gZGlyZWN0aW9uO1xyXG5cclxufSApLnNldExheW91dCgge1xyXG5cdG5hbWU6ICdnZXREaXJlY3Rpb24nLFxyXG5cdHR5cGU6ICd2ZWMzJyxcclxuXHRpbnB1dHM6IFtcclxuXHRcdHsgbmFtZTogJ3V2JywgdHlwZTogJ3ZlYzInIH0sXHJcblx0XHR7IG5hbWU6ICdmYWNlJywgdHlwZTogJ2Zsb2F0JyB9XHJcblx0XVxyXG59ICk7XHJcblxyXG4vL1xyXG5cclxuZXhwb3J0IGNvbnN0IHRleHR1cmVDdWJlVVYgPSAvKkBfX1BVUkVfXyovIEZuKCAoIFsgZW52TWFwLCBzYW1wbGVEaXJfaW1tdXRhYmxlLCByb3VnaG5lc3NfaW1tdXRhYmxlLCBDVUJFVVZfVEVYRUxfV0lEVEgsIENVQkVVVl9URVhFTF9IRUlHSFQsIENVQkVVVl9NQVhfTUlQIF0gKSA9PiB7XHJcblxyXG5cdGNvbnN0IHJvdWdobmVzcyA9IGZsb2F0KCByb3VnaG5lc3NfaW1tdXRhYmxlICk7XHJcblx0Y29uc3Qgc2FtcGxlRGlyID0gdmVjMyggc2FtcGxlRGlyX2ltbXV0YWJsZSApO1xyXG5cclxuXHRjb25zdCBtaXAgPSBjbGFtcCggcm91Z2huZXNzVG9NaXAoIHJvdWdobmVzcyApLCBjdWJlVVZfbTAsIENVQkVVVl9NQVhfTUlQICk7XHJcblx0Y29uc3QgbWlwRiA9IGZyYWN0KCBtaXAgKTtcclxuXHRjb25zdCBtaXBJbnQgPSBmbG9vciggbWlwICk7XHJcblx0Y29uc3QgY29sb3IwID0gdmVjMyggYmlsaW5lYXJDdWJlVVYoIGVudk1hcCwgc2FtcGxlRGlyLCBtaXBJbnQsIENVQkVVVl9URVhFTF9XSURUSCwgQ1VCRVVWX1RFWEVMX0hFSUdIVCwgQ1VCRVVWX01BWF9NSVAgKSApLnRvVmFyKCk7XHJcblxyXG5cdElmKCBtaXBGLm5vdEVxdWFsKCAwLjAgKSwgKCkgPT4ge1xyXG5cclxuXHRcdGNvbnN0IGNvbG9yMSA9IHZlYzMoIGJpbGluZWFyQ3ViZVVWKCBlbnZNYXAsIHNhbXBsZURpciwgbWlwSW50LmFkZCggMS4wICksIENVQkVVVl9URVhFTF9XSURUSCwgQ1VCRVVWX1RFWEVMX0hFSUdIVCwgQ1VCRVVWX01BWF9NSVAgKSApLnRvVmFyKCk7XHJcblxyXG5cdFx0Y29sb3IwLmFzc2lnbiggbWl4KCBjb2xvcjAsIGNvbG9yMSwgbWlwRiApICk7XHJcblxyXG5cdH0gKTtcclxuXHJcblx0cmV0dXJuIGNvbG9yMDtcclxuXHJcbn0gKTtcclxuXHJcbmNvbnN0IGJpbGluZWFyQ3ViZVVWID0gLypAX19QVVJFX18qLyBGbiggKCBbIGVudk1hcCwgZGlyZWN0aW9uX2ltbXV0YWJsZSwgbWlwSW50X2ltbXV0YWJsZSwgQ1VCRVVWX1RFWEVMX1dJRFRILCBDVUJFVVZfVEVYRUxfSEVJR0hULCBDVUJFVVZfTUFYX01JUCBdICkgPT4ge1xyXG5cclxuXHRjb25zdCBtaXBJbnQgPSBmbG9hdCggbWlwSW50X2ltbXV0YWJsZSApLnRvVmFyKCk7XHJcblx0Y29uc3QgZGlyZWN0aW9uID0gdmVjMyggZGlyZWN0aW9uX2ltbXV0YWJsZSApO1xyXG5cdGNvbnN0IGZhY2UgPSBmbG9hdCggZ2V0RmFjZSggZGlyZWN0aW9uICkgKS50b1ZhcigpO1xyXG5cdGNvbnN0IGZpbHRlckludCA9IGZsb2F0KCBtYXgoIGN1YmVVVl9taW5NaXBMZXZlbC5zdWIoIG1pcEludCApLCAwLjAgKSApLnRvVmFyKCk7XHJcblx0bWlwSW50LmFzc2lnbiggbWF4KCBtaXBJbnQsIGN1YmVVVl9taW5NaXBMZXZlbCApICk7XHJcblx0Y29uc3QgZmFjZVNpemUgPSBmbG9hdCggZXhwMiggbWlwSW50ICkgKS50b1ZhcigpO1xyXG5cdGNvbnN0IHV2ID0gdmVjMiggZ2V0VVYoIGRpcmVjdGlvbiwgZmFjZSApLm11bCggZmFjZVNpemUuc3ViKCAyLjAgKSApLmFkZCggMS4wICkgKS50b1ZhcigpO1xyXG5cclxuXHRJZiggZmFjZS5ncmVhdGVyVGhhbiggMi4wICksICgpID0+IHtcclxuXHJcblx0XHR1di55LmFkZEFzc2lnbiggZmFjZVNpemUgKTtcclxuXHRcdGZhY2Uuc3ViQXNzaWduKCAzLjAgKTtcclxuXHJcblx0fSApO1xyXG5cclxuXHR1di54LmFkZEFzc2lnbiggZmFjZS5tdWwoIGZhY2VTaXplICkgKTtcclxuXHR1di54LmFkZEFzc2lnbiggZmlsdGVySW50Lm11bCggbXVsKCAzLjAsIGN1YmVVVl9taW5UaWxlU2l6ZSApICkgKTtcclxuXHR1di55LmFkZEFzc2lnbiggbXVsKCA0LjAsIGV4cDIoIENVQkVVVl9NQVhfTUlQICkuc3ViKCBmYWNlU2l6ZSApICkgKTtcclxuXHR1di54Lm11bEFzc2lnbiggQ1VCRVVWX1RFWEVMX1dJRFRIICk7XHJcblx0dXYueS5tdWxBc3NpZ24oIENVQkVVVl9URVhFTF9IRUlHSFQgKTtcclxuXHJcblx0cmV0dXJuIGVudk1hcC5zYW1wbGUoIHV2ICkuZ3JhZCggdmVjMigpLCB2ZWMyKCkgKTsgLy8gZGlzYWJsZSBhbmlzb3Ryb3BpYyBmaWx0ZXJpbmdcclxuXHJcbn0gKTtcclxuXHJcbmNvbnN0IGdldFNhbXBsZSA9IC8qQF9fUFVSRV9fKi8gRm4oICggeyBlbnZNYXAsIG1pcEludCwgb3V0cHV0RGlyZWN0aW9uLCB0aGV0YSwgYXhpcywgQ1VCRVVWX1RFWEVMX1dJRFRILCBDVUJFVVZfVEVYRUxfSEVJR0hULCBDVUJFVVZfTUFYX01JUCB9ICkgPT4ge1xyXG5cclxuXHRjb25zdCBjb3NUaGV0YSA9IGNvcyggdGhldGEgKTtcclxuXHJcblx0Ly8gUm9kcmlndWVzJyBheGlzLWFuZ2xlIHJvdGF0aW9uXHJcblx0Y29uc3Qgc2FtcGxlRGlyZWN0aW9uID0gb3V0cHV0RGlyZWN0aW9uLm11bCggY29zVGhldGEgKVxyXG5cdFx0LmFkZCggYXhpcy5jcm9zcyggb3V0cHV0RGlyZWN0aW9uICkubXVsKCBzaW4oIHRoZXRhICkgKSApXHJcblx0XHQuYWRkKCBheGlzLm11bCggYXhpcy5kb3QoIG91dHB1dERpcmVjdGlvbiApLm11bCggY29zVGhldGEub25lTWludXMoKSApICkgKTtcclxuXHJcblx0cmV0dXJuIGJpbGluZWFyQ3ViZVVWKCBlbnZNYXAsIHNhbXBsZURpcmVjdGlvbiwgbWlwSW50LCBDVUJFVVZfVEVYRUxfV0lEVEgsIENVQkVVVl9URVhFTF9IRUlHSFQsIENVQkVVVl9NQVhfTUlQICk7XHJcblxyXG59ICk7XHJcblxyXG5leHBvcnQgY29uc3QgYmx1ciA9IC8qQF9fUFVSRV9fKi8gRm4oICggeyBuLCBsYXRpdHVkaW5hbCwgcG9sZUF4aXMsIG91dHB1dERpcmVjdGlvbiwgd2VpZ2h0cywgc2FtcGxlcywgZFRoZXRhLCBtaXBJbnQsIGVudk1hcCwgQ1VCRVVWX1RFWEVMX1dJRFRILCBDVUJFVVZfVEVYRUxfSEVJR0hULCBDVUJFVVZfTUFYX01JUCB9ICkgPT4ge1xyXG5cclxuXHRjb25zdCBheGlzID0gdmVjMyggc2VsZWN0KCBsYXRpdHVkaW5hbCwgcG9sZUF4aXMsIGNyb3NzKCBwb2xlQXhpcywgb3V0cHV0RGlyZWN0aW9uICkgKSApLnRvVmFyKCk7XHJcblxyXG5cdElmKCBhbGwoIGF4aXMuZXF1YWxzKCB2ZWMzKCAwLjAgKSApICksICgpID0+IHtcclxuXHJcblx0XHRheGlzLmFzc2lnbiggdmVjMyggb3V0cHV0RGlyZWN0aW9uLnosIDAuMCwgb3V0cHV0RGlyZWN0aW9uLngubmVnYXRlKCkgKSApO1xyXG5cclxuXHR9ICk7XHJcblxyXG5cdGF4aXMuYXNzaWduKCBub3JtYWxpemUoIGF4aXMgKSApO1xyXG5cclxuXHRjb25zdCBnbF9GcmFnQ29sb3IgPSB2ZWMzKCkudG9WYXIoKTtcclxuXHRnbF9GcmFnQ29sb3IuYWRkQXNzaWduKCB3ZWlnaHRzLmVsZW1lbnQoIGludCggMCApICkubXVsKCBnZXRTYW1wbGUoIHsgdGhldGE6IDAuMCwgYXhpcywgb3V0cHV0RGlyZWN0aW9uLCBtaXBJbnQsIGVudk1hcCwgQ1VCRVVWX1RFWEVMX1dJRFRILCBDVUJFVVZfVEVYRUxfSEVJR0hULCBDVUJFVVZfTUFYX01JUCB9ICkgKSApO1xyXG5cclxuXHRMb29wKCB7IHN0YXJ0OiBpbnQoIDEgKSwgZW5kOiBuIH0sICggeyBpIH0gKSA9PiB7XHJcblxyXG5cdFx0SWYoIGkuZ3JlYXRlclRoYW5FcXVhbCggc2FtcGxlcyApLCAoKSA9PiB7XHJcblxyXG5cdFx0XHRCcmVhaygpO1xyXG5cclxuXHRcdH0gKTtcclxuXHJcblx0XHRjb25zdCB0aGV0YSA9IGZsb2F0KCBkVGhldGEubXVsKCBmbG9hdCggaSApICkgKS50b1ZhcigpO1xyXG5cdFx0Z2xfRnJhZ0NvbG9yLmFkZEFzc2lnbiggd2VpZ2h0cy5lbGVtZW50KCBpICkubXVsKCBnZXRTYW1wbGUoIHsgdGhldGE6IHRoZXRhLm11bCggLSAxLjAgKSwgYXhpcywgb3V0cHV0RGlyZWN0aW9uLCBtaXBJbnQsIGVudk1hcCwgQ1VCRVVWX1RFWEVMX1dJRFRILCBDVUJFVVZfVEVYRUxfSEVJR0hULCBDVUJFVVZfTUFYX01JUCB9ICkgKSApO1xyXG5cdFx0Z2xfRnJhZ0NvbG9yLmFkZEFzc2lnbiggd2VpZ2h0cy5lbGVtZW50KCBpICkubXVsKCBnZXRTYW1wbGUoIHsgdGhldGEsIGF4aXMsIG91dHB1dERpcmVjdGlvbiwgbWlwSW50LCBlbnZNYXAsIENVQkVVVl9URVhFTF9XSURUSCwgQ1VCRVVWX1RFWEVMX0hFSUdIVCwgQ1VCRVVWX01BWF9NSVAgfSApICkgKTtcclxuXHJcblx0fSApO1xyXG5cclxuXHRyZXR1cm4gdmVjNCggZ2xfRnJhZ0NvbG9yLCAxICk7XHJcblxyXG59ICk7XHJcbiIsImltcG9ydCBUZW1wTm9kZSBmcm9tICcuLi9jb3JlL1RlbXBOb2RlLmpzJztcclxuaW1wb3J0IHsgdGV4dHVyZSB9IGZyb20gJy4uL2FjY2Vzc29ycy9UZXh0dXJlTm9kZS5qcyc7XHJcbmltcG9ydCB7IHRleHR1cmVDdWJlVVYgfSBmcm9tICcuL1BNUkVNVXRpbHMuanMnO1xyXG5pbXBvcnQgeyB1bmlmb3JtIH0gZnJvbSAnLi4vY29yZS9Vbmlmb3JtTm9kZS5qcyc7XHJcbmltcG9ydCB7IE5vZGVVcGRhdGVUeXBlIH0gZnJvbSAnLi4vY29yZS9jb25zdGFudHMuanMnO1xyXG5pbXBvcnQgeyBub2RlUHJveHksIHZlYzMgfSBmcm9tICcuLi90c2wvVFNMQmFzZS5qcyc7XHJcblxyXG5pbXBvcnQgeyBXZWJHTENvb3JkaW5hdGVTeXN0ZW0gfSBmcm9tICcuLi8uLi9jb25zdGFudHMuanMnO1xyXG5pbXBvcnQgeyBUZXh0dXJlIH0gZnJvbSAnLi4vLi4vdGV4dHVyZXMvVGV4dHVyZS5qcyc7XHJcblxyXG4vKiogQG1vZHVsZSBQTVJFTU5vZGUgKiovXHJcblxyXG5sZXQgX2dlbmVyYXRvciA9IG51bGw7XHJcblxyXG5jb25zdCBfY2FjaGUgPSBuZXcgV2Vha01hcCgpO1xyXG5cclxuLyoqXHJcbiAqIEdlbmVyYXRlcyB0aGUgY3ViZVVWIHNpemUgYmFzZWQgb24gdGhlIGdpdmVuIGltYWdlIGhlaWdodC5cclxuICpcclxuICogQHByaXZhdGVcclxuICogQHBhcmFtIHtOdW1iZXJ9IGltYWdlSGVpZ2h0IC0gVGhlIGltYWdlIGhlaWdodC5cclxuICogQHJldHVybiB7e3RleGVsV2lkdGg6IE51bWJlcix0ZXhlbEhlaWdodDogTnVtYmVyLCBtYXhNaXA6IE51bWJlcn19IFRoZSByZXN1bHQgb2JqZWN0LlxyXG4gKi9cclxuZnVuY3Rpb24gX2dlbmVyYXRlQ3ViZVVWU2l6ZSggaW1hZ2VIZWlnaHQgKSB7XHJcblxyXG5cdGNvbnN0IG1heE1pcCA9IE1hdGgubG9nMiggaW1hZ2VIZWlnaHQgKSAtIDI7XHJcblxyXG5cdGNvbnN0IHRleGVsSGVpZ2h0ID0gMS4wIC8gaW1hZ2VIZWlnaHQ7XHJcblxyXG5cdGNvbnN0IHRleGVsV2lkdGggPSAxLjAgLyAoIDMgKiBNYXRoLm1heCggTWF0aC5wb3coIDIsIG1heE1pcCApLCA3ICogMTYgKSApO1xyXG5cclxuXHRyZXR1cm4geyB0ZXhlbFdpZHRoLCB0ZXhlbEhlaWdodCwgbWF4TWlwIH07XHJcblxyXG59XHJcblxyXG4vKipcclxuICogR2VuZXJhdGVzIGEgUE1SRU0gZnJvbSB0aGUgZ2l2ZW4gdGV4dHVyZSAuXHJcbiAqXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBwYXJhbSB7VGV4dHVyZX0gdGV4dHVyZSAtIFRoZSB0ZXh0dXJlIHRvIGNyZWF0ZSB0aGUgUE1SRU0gZm9yLlxyXG4gKiBAcmV0dXJuIHtUZXh0dXJlfSBUaGUgUE1SRU0uXHJcbiAqL1xyXG5mdW5jdGlvbiBfZ2V0UE1SRU1Gcm9tVGV4dHVyZSggdGV4dHVyZSApIHtcclxuXHJcblx0bGV0IGNhY2hlVGV4dHVyZSA9IF9jYWNoZS5nZXQoIHRleHR1cmUgKTtcclxuXHJcblx0Y29uc3QgcG1yZW1WZXJzaW9uID0gY2FjaGVUZXh0dXJlICE9PSB1bmRlZmluZWQgPyBjYWNoZVRleHR1cmUucG1yZW1WZXJzaW9uIDogLSAxO1xyXG5cclxuXHRpZiAoIHBtcmVtVmVyc2lvbiAhPT0gdGV4dHVyZS5wbXJlbVZlcnNpb24gKSB7XHJcblxyXG5cdFx0Y29uc3QgaW1hZ2UgPSB0ZXh0dXJlLmltYWdlO1xyXG5cclxuXHRcdGlmICggdGV4dHVyZS5pc0N1YmVUZXh0dXJlICkge1xyXG5cclxuXHRcdFx0aWYgKCBpc0N1YmVNYXBSZWFkeSggaW1hZ2UgKSApIHtcclxuXHJcblx0XHRcdFx0Y2FjaGVUZXh0dXJlID0gX2dlbmVyYXRvci5mcm9tQ3ViZW1hcCggdGV4dHVyZSwgY2FjaGVUZXh0dXJlICk7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRyZXR1cm4gbnVsbDtcclxuXHJcblx0XHRcdH1cclxuXHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdGlmICggaXNFcXVpcmVjdGFuZ3VsYXJNYXBSZWFkeSggaW1hZ2UgKSApIHtcclxuXHJcblx0XHRcdFx0Y2FjaGVUZXh0dXJlID0gX2dlbmVyYXRvci5mcm9tRXF1aXJlY3Rhbmd1bGFyKCB0ZXh0dXJlLCBjYWNoZVRleHR1cmUgKTtcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdHJldHVybiBudWxsO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRjYWNoZVRleHR1cmUucG1yZW1WZXJzaW9uID0gdGV4dHVyZS5wbXJlbVZlcnNpb247XHJcblxyXG5cdFx0X2NhY2hlLnNldCggdGV4dHVyZSwgY2FjaGVUZXh0dXJlICk7XHJcblxyXG5cdH1cclxuXHJcblx0cmV0dXJuIGNhY2hlVGV4dHVyZS50ZXh0dXJlO1xyXG5cclxufVxyXG5cclxuLyoqXHJcbiAqIFRoaXMgbm9kZSByZXByZXNlbnRzIGEgUE1SRU0gd2hpY2ggaXMgYSBzcGVjaWFsIHR5cGUgb2YgcHJlcHJvY2Vzc2VkXHJcbiAqIGVudmlyb25tZW50IG1hcCBpbnRlbmRlZCBmb3IgUEJSIG1hdGVyaWFscy5cclxuICpcclxuICogYGBganNcclxuICogY29uc3QgbWF0ZXJpYWwgPSBuZXcgTWVzaFN0YW5kYXJkTm9kZU1hdGVyaWFsKCk7XHJcbiAqIG1hdGVyaWFsLmVudk5vZGUgPSBwbXJlbVRleHR1cmUoIGVudk1hcCApO1xyXG4gKiBgYGBcclxuICpcclxuICogQGF1Z21lbnRzIFRlbXBOb2RlXHJcbiAqL1xyXG5jbGFzcyBQTVJFTU5vZGUgZXh0ZW5kcyBUZW1wTm9kZSB7XHJcblxyXG5cdHN0YXRpYyBnZXQgdHlwZSgpIHtcclxuXHJcblx0XHRyZXR1cm4gJ1BNUkVNTm9kZSc7XHJcblxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogQ29uc3RydWN0cyBhIG5ldyBmdW5jdGlvbiBvdmVybG9hZGluZyBub2RlLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtUZXh0dXJlfSB2YWx1ZSAtIFRoZSBpbnB1dCB0ZXh0dXJlLlxyXG5cdCAqIEBwYXJhbSB7Tm9kZTx2ZWMyPn0gW3V2Tm9kZT1udWxsXSAtIFRoZSB1diBub2RlLlxyXG5cdCAqIEBwYXJhbSB7Tm9kZTxmbG9hdD59IFtsZXZlbE5vZGU9bnVsbF0gLSBUaGUgbGV2ZWwgbm9kZS5cclxuXHQgKi9cclxuXHRjb25zdHJ1Y3RvciggdmFsdWUsIHV2Tm9kZSA9IG51bGwsIGxldmVsTm9kZSA9IG51bGwgKSB7XHJcblxyXG5cdFx0c3VwZXIoICd2ZWMzJyApO1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogUmVmZXJlbmNlIHRvIHRoZSBpbnB1dCB0ZXh0dXJlLlxyXG5cdFx0ICpcclxuXHRcdCAqIEBwcml2YXRlXHJcblx0XHQgKiBAdHlwZSB7VGV4dHVyZX1cclxuXHRcdCAqL1xyXG5cdFx0dGhpcy5fdmFsdWUgPSB2YWx1ZTtcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIFJlZmVyZW5jZSB0byB0aGUgZ2VuZXJhdGVkIFBNUkVNLlxyXG5cdFx0ICpcclxuXHRcdCAqIEBwcml2YXRlXHJcblx0XHQgKiBAdHlwZSB7VGV4dHVyZSB8IG51bGx9XHJcblx0XHQgKiBAZGVmYXVsdCBudWxsXHJcblx0XHQgKi9cclxuXHRcdHRoaXMuX3BtcmVtID0gbnVsbDtcclxuXHJcblx0XHQvKipcclxuXHRcdCAqICBUaGUgdXYgbm9kZS5cclxuXHRcdCAqXHJcblx0XHQgKiBAdHlwZSB7Tm9kZTx2ZWMyPn1cclxuXHRcdCAqL1xyXG5cdFx0dGhpcy51dk5vZGUgPSB1dk5vZGU7XHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiAgVGhlIGxldmVsIG5vZGUuXHJcblx0XHQgKlxyXG5cdFx0ICogQHR5cGUge05vZGU8ZmxvYXQ+fVxyXG5cdFx0ICovXHJcblx0XHR0aGlzLmxldmVsTm9kZSA9IGxldmVsTm9kZTtcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIFJlZmVyZW5jZSB0byBhIFBNUkVNIGdlbmVyYXRvci5cclxuXHRcdCAqXHJcblx0XHQgKiBAcHJpdmF0ZVxyXG5cdFx0ICogQHR5cGUge1BNUkVNR2VuZXJhdG9yfVxyXG5cdFx0ICogQGRlZmF1bHQgbnVsbFxyXG5cdFx0ICovXHJcblx0XHR0aGlzLl9nZW5lcmF0b3IgPSBudWxsO1xyXG5cclxuXHRcdGNvbnN0IGRlZmF1bHRUZXh0dXJlID0gbmV3IFRleHR1cmUoKTtcclxuXHRcdGRlZmF1bHRUZXh0dXJlLmlzUmVuZGVyVGFyZ2V0VGV4dHVyZSA9IHRydWU7XHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBUaGUgdGV4dHVyZSBub2RlIGhvbGRpbmcgdGhlIGdlbmVyYXRlZCBQTVJFTS5cclxuXHRcdCAqXHJcblx0XHQgKiBAcHJpdmF0ZVxyXG5cdFx0ICogQHR5cGUge1RleHR1cmVOb2RlfVxyXG5cdFx0ICovXHJcblx0XHR0aGlzLl90ZXh0dXJlID0gdGV4dHVyZSggZGVmYXVsdFRleHR1cmUgKTtcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIEEgdW5pZm9ybSByZXByZXNlbnRpbmcgdGhlIFBNUkVNJ3Mgd2lkdGguXHJcblx0XHQgKlxyXG5cdFx0ICogQHByaXZhdGVcclxuXHRcdCAqIEB0eXBlIHtVbmlmb3JtTm9kZTxmbG9hdD59XHJcblx0XHQgKi9cclxuXHRcdHRoaXMuX3dpZHRoID0gdW5pZm9ybSggMCApO1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogQSB1bmlmb3JtIHJlcHJlc2VudGluZyB0aGUgUE1SRU0ncyBoZWlnaHQuXHJcblx0XHQgKlxyXG5cdFx0ICogQHByaXZhdGVcclxuXHRcdCAqIEB0eXBlIHtVbmlmb3JtTm9kZTxmbG9hdD59XHJcblx0XHQgKi9cclxuXHRcdHRoaXMuX2hlaWdodCA9IHVuaWZvcm0oIDAgKTtcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIEEgdW5pZm9ybSByZXByZXNlbnRpbmcgdGhlIFBNUkVNJ3MgbWF4IE1pcC5cclxuXHRcdCAqXHJcblx0XHQgKiBAcHJpdmF0ZVxyXG5cdFx0ICogQHR5cGUge1VuaWZvcm1Ob2RlPGZsb2F0Pn1cclxuXHRcdCAqL1xyXG5cdFx0dGhpcy5fbWF4TWlwID0gdW5pZm9ybSggMCApO1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogVGhlIGB1cGRhdGVCZWZvcmVUeXBlYCBpcyBzZXQgdG8gYE5vZGVVcGRhdGVUeXBlLlJFTkRFUmAuXHJcblx0XHQgKlxyXG5cdFx0ICogQHR5cGUge1N0cmluZ31cclxuXHRcdCAqIEBkZWZhdWx0ICdyZW5kZXInXHJcblx0XHQgKi9cclxuXHRcdHRoaXMudXBkYXRlQmVmb3JlVHlwZSA9IE5vZGVVcGRhdGVUeXBlLlJFTkRFUjtcclxuXHJcblx0fVxyXG5cclxuXHRzZXQgdmFsdWUoIHZhbHVlICkge1xyXG5cclxuXHRcdHRoaXMuX3ZhbHVlID0gdmFsdWU7XHJcblx0XHR0aGlzLl9wbXJlbSA9IG51bGw7XHJcblxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogVGhlIG5vZGUncyB0ZXh0dXJlIHZhbHVlLlxyXG5cdCAqXHJcblx0ICogQHR5cGUge1RleHR1cmV9XHJcblx0ICovXHJcblx0Z2V0IHZhbHVlKCkge1xyXG5cclxuXHRcdHJldHVybiB0aGlzLl92YWx1ZTtcclxuXHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBVc2VzIHRoZSBnaXZlbiBQTVJFTSB0ZXh0dXJlIHRvIHVwZGF0ZSBpbnRlcm5hbCB2YWx1ZXMuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge1RleHR1cmV9IHRleHR1cmUgLSBUaGUgUE1SRU0gdGV4dHVyZS5cclxuXHQgKi9cclxuXHR1cGRhdGVGcm9tVGV4dHVyZSggdGV4dHVyZSApIHtcclxuXHJcblx0XHRjb25zdCBjdWJlVVZTaXplID0gX2dlbmVyYXRlQ3ViZVVWU2l6ZSggdGV4dHVyZS5pbWFnZS5oZWlnaHQgKTtcclxuXHJcblx0XHR0aGlzLl90ZXh0dXJlLnZhbHVlID0gdGV4dHVyZTtcclxuXHRcdHRoaXMuX3dpZHRoLnZhbHVlID0gY3ViZVVWU2l6ZS50ZXhlbFdpZHRoO1xyXG5cdFx0dGhpcy5faGVpZ2h0LnZhbHVlID0gY3ViZVVWU2l6ZS50ZXhlbEhlaWdodDtcclxuXHRcdHRoaXMuX21heE1pcC52YWx1ZSA9IGN1YmVVVlNpemUubWF4TWlwO1xyXG5cclxuXHR9XHJcblxyXG5cdHVwZGF0ZUJlZm9yZSgpIHtcclxuXHJcblx0XHRsZXQgcG1yZW0gPSB0aGlzLl9wbXJlbTtcclxuXHJcblx0XHRjb25zdCBwbXJlbVZlcnNpb24gPSBwbXJlbSA/IHBtcmVtLnBtcmVtVmVyc2lvbiA6IC0gMTtcclxuXHRcdGNvbnN0IHRleHR1cmUgPSB0aGlzLl92YWx1ZTtcclxuXHJcblx0XHRpZiAoIHBtcmVtVmVyc2lvbiAhPT0gdGV4dHVyZS5wbXJlbVZlcnNpb24gKSB7XHJcblxyXG5cdFx0XHRpZiAoIHRleHR1cmUuaXNQTVJFTVRleHR1cmUgPT09IHRydWUgKSB7XHJcblxyXG5cdFx0XHRcdHBtcmVtID0gdGV4dHVyZTtcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdHBtcmVtID0gX2dldFBNUkVNRnJvbVRleHR1cmUoIHRleHR1cmUgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICggcG1yZW0gIT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHRcdHRoaXMuX3BtcmVtID0gcG1yZW07XHJcblxyXG5cdFx0XHRcdHRoaXMudXBkYXRlRnJvbVRleHR1cmUoIHBtcmVtICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdHNldHVwKCBidWlsZGVyICkge1xyXG5cclxuXHRcdGlmICggX2dlbmVyYXRvciA9PT0gbnVsbCApIHtcclxuXHJcblx0XHRcdF9nZW5lcmF0b3IgPSBidWlsZGVyLmNyZWF0ZVBNUkVNR2VuZXJhdG9yKCk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vXHJcblxyXG5cdFx0dGhpcy51cGRhdGVCZWZvcmUoIGJ1aWxkZXIgKTtcclxuXHJcblx0XHQvL1xyXG5cclxuXHRcdGxldCB1dk5vZGUgPSB0aGlzLnV2Tm9kZTtcclxuXHJcblx0XHRpZiAoIHV2Tm9kZSA9PT0gbnVsbCAmJiBidWlsZGVyLmNvbnRleHQuZ2V0VVYgKSB7XHJcblxyXG5cdFx0XHR1dk5vZGUgPSBidWlsZGVyLmNvbnRleHQuZ2V0VVYoIHRoaXMgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly9cclxuXHJcblx0XHRjb25zdCB0ZXh0dXJlID0gdGhpcy52YWx1ZTtcclxuXHJcblx0XHRpZiAoIGJ1aWxkZXIucmVuZGVyZXIuY29vcmRpbmF0ZVN5c3RlbSA9PT0gV2ViR0xDb29yZGluYXRlU3lzdGVtICYmIHRleHR1cmUuaXNQTVJFTVRleHR1cmUgIT09IHRydWUgJiYgdGV4dHVyZS5pc1JlbmRlclRhcmdldFRleHR1cmUgPT09IHRydWUgKSB7XHJcblxyXG5cdFx0XHR1dk5vZGUgPSB2ZWMzKCB1dk5vZGUueC5uZWdhdGUoKSwgdXZOb2RlLnl6ICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHV2Tm9kZSA9IHZlYzMoIHV2Tm9kZS54LCB1dk5vZGUueS5uZWdhdGUoKSwgdXZOb2RlLnogKTtcclxuXHJcblx0XHQvL1xyXG5cclxuXHRcdGxldCBsZXZlbE5vZGUgPSB0aGlzLmxldmVsTm9kZTtcclxuXHJcblx0XHRpZiAoIGxldmVsTm9kZSA9PT0gbnVsbCAmJiBidWlsZGVyLmNvbnRleHQuZ2V0VGV4dHVyZUxldmVsICkge1xyXG5cclxuXHRcdFx0bGV2ZWxOb2RlID0gYnVpbGRlci5jb250ZXh0LmdldFRleHR1cmVMZXZlbCggdGhpcyApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvL1xyXG5cclxuXHRcdHJldHVybiB0ZXh0dXJlQ3ViZVVWKCB0aGlzLl90ZXh0dXJlLCB1dk5vZGUsIGxldmVsTm9kZSwgdGhpcy5fd2lkdGgsIHRoaXMuX2hlaWdodCwgdGhpcy5fbWF4TWlwICk7XHJcblxyXG5cdH1cclxuXHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IFBNUkVNTm9kZTtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZ2l2ZW4gY3ViZSBtYXAgaW1hZ2UgaGFzIGJlZW4gZnVsbHkgbG9hZGVkLlxyXG4gKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAcGFyYW0ge0FycmF5PChJbWFnZXxPYmplY3QpPn0gaW1hZ2UgLSBUaGUgY3ViZSBtYXAgaW1hZ2UuXHJcbiAqIEByZXR1cm4ge0Jvb2xlYW59IFdoZXRoZXIgdGhlIGdpdmVuIGN1YmUgbWFwIGlzIHJlYWR5IG9yIG5vdC5cclxuICovXHJcbmZ1bmN0aW9uIGlzQ3ViZU1hcFJlYWR5KCBpbWFnZSApIHtcclxuXHJcblx0aWYgKCBpbWFnZSA9PT0gbnVsbCB8fCBpbWFnZSA9PT0gdW5kZWZpbmVkICkgcmV0dXJuIGZhbHNlO1xyXG5cclxuXHRsZXQgY291bnQgPSAwO1xyXG5cdGNvbnN0IGxlbmd0aCA9IDY7XHJcblxyXG5cdGZvciAoIGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSArKyApIHtcclxuXHJcblx0XHRpZiAoIGltYWdlWyBpIF0gIT09IHVuZGVmaW5lZCApIGNvdW50ICsrO1xyXG5cclxuXHR9XHJcblxyXG5cdHJldHVybiBjb3VudCA9PT0gbGVuZ3RoO1xyXG5cclxuXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZ2l2ZW4gZXF1aXJlY3Rhbmd1bGFyIGltYWdlIGhhcyBiZWVuIGZ1bGx5IGxvYWRlZC5cclxuICpcclxuICogQHByaXZhdGVcclxuICogQHBhcmFtIHsoSW1hZ2V8T2JqZWN0KX0gaW1hZ2UgLSBUaGUgZXF1aXJlY3Rhbmd1bGFyIGltYWdlLlxyXG4gKiBAcmV0dXJuIHtCb29sZWFufSBXaGV0aGVyIHRoZSBnaXZlbiBjdWJlIG1hcCBpcyByZWFkeSBvciBub3QuXHJcbiAqL1xyXG5mdW5jdGlvbiBpc0VxdWlyZWN0YW5ndWxhck1hcFJlYWR5KCBpbWFnZSApIHtcclxuXHJcblx0aWYgKCBpbWFnZSA9PT0gbnVsbCB8fCBpbWFnZSA9PT0gdW5kZWZpbmVkICkgcmV0dXJuIGZhbHNlO1xyXG5cclxuXHRyZXR1cm4gaW1hZ2UuaGVpZ2h0ID4gMDtcclxuXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBUU0wgZnVuY3Rpb24gZm9yIGNyZWF0aW5nIGEgUE1SRU0gbm9kZS5cclxuICpcclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7VGV4dHVyZX0gdmFsdWUgLSBUaGUgaW5wdXQgdGV4dHVyZS5cclxuICogQHBhcmFtIHtOb2RlPHZlYzI+fSBbdXZOb2RlPW51bGxdIC0gVGhlIHV2IG5vZGUuXHJcbiAqIEBwYXJhbSB7Tm9kZTxmbG9hdD59IFtsZXZlbE5vZGU9bnVsbF0gLSBUaGUgbGV2ZWwgbm9kZS5cclxuICogQHJldHVybnMge1BNUkVNTm9kZX1cclxuICovXHJcbmV4cG9ydCBjb25zdCBwbXJlbVRleHR1cmUgPSAvKkBfX1BVUkVfXyovIG5vZGVQcm94eSggUE1SRU1Ob2RlICk7XHJcbiIsImltcG9ydCBMaWdodGluZ05vZGUgZnJvbSAnLi9MaWdodGluZ05vZGUuanMnO1xyXG5pbXBvcnQgeyBjYWNoZSB9IGZyb20gJy4uL2NvcmUvQ2FjaGVOb2RlLmpzJztcclxuaW1wb3J0IHsgcm91Z2huZXNzLCBjbGVhcmNvYXRSb3VnaG5lc3MgfSBmcm9tICcuLi9jb3JlL1Byb3BlcnR5Tm9kZS5qcyc7XHJcbmltcG9ydCB7IGNhbWVyYVZpZXdNYXRyaXggfSBmcm9tICcuLi9hY2Nlc3NvcnMvQ2FtZXJhLmpzJztcclxuaW1wb3J0IHsgdHJhbnNmb3JtZWRDbGVhcmNvYXROb3JtYWxWaWV3LCB0cmFuc2Zvcm1lZE5vcm1hbFZpZXcsIHRyYW5zZm9ybWVkTm9ybWFsV29ybGQgfSBmcm9tICcuLi9hY2Nlc3NvcnMvTm9ybWFsLmpzJztcclxuaW1wb3J0IHsgcG9zaXRpb25WaWV3RGlyZWN0aW9uIH0gZnJvbSAnLi4vYWNjZXNzb3JzL1Bvc2l0aW9uLmpzJztcclxuaW1wb3J0IHsgZmxvYXQgfSBmcm9tICcuLi90c2wvVFNMQmFzZS5qcyc7XHJcbmltcG9ydCB7IHJlZmVyZW5jZSB9IGZyb20gJy4uL2FjY2Vzc29ycy9SZWZlcmVuY2VOb2RlLmpzJztcclxuaW1wb3J0IHsgdHJhbnNmb3JtZWRCZW50Tm9ybWFsVmlldyB9IGZyb20gJy4uL2FjY2Vzc29ycy9BY2Nlc3NvcnNVdGlscy5qcyc7XHJcbmltcG9ydCB7IHBtcmVtVGV4dHVyZSB9IGZyb20gJy4uL3BtcmVtL1BNUkVNTm9kZS5qcyc7XHJcblxyXG5jb25zdCBfZW52Tm9kZUNhY2hlID0gbmV3IFdlYWtNYXAoKTtcclxuXHJcbi8qKlxyXG4gKiBSZXByZXNlbnRzIGEgcGh5c2ljYWwgbW9kZWwgZm9yIEltYWdlLWJhc2VkIGxpZ2h0aW5nIChJQkwpLiBUaGUgZW52aXJvbm1lbnRcclxuICogaXMgZGVmaW5lZCB2aWEgZW52aXJvbm1lbnQgbWFwcyBpbiB0aGUgZXF1aXJlY3RhbnVsYXIsIGN1YmUgbWFwIG9yIGN1YmVVViAoUE1SRU0pIGZvcm1hdC5cclxuICogYEVudmlyb25tZW50Tm9kZWAgaXMgaW50ZW5kZWQgZm9yIFBCUiBtYXRlcmlhbHMgbGlrZSB7QGxpbmsgTWVzaFN0YW5kYXJkTm9kZU1hdGVyaWFsfS5cclxuICpcclxuICogQGF1Z21lbnRzIExpZ2h0aW5nTm9kZVxyXG4gKi9cclxuY2xhc3MgRW52aXJvbm1lbnROb2RlIGV4dGVuZHMgTGlnaHRpbmdOb2RlIHtcclxuXHJcblx0c3RhdGljIGdldCB0eXBlKCkge1xyXG5cclxuXHRcdHJldHVybiAnRW52aXJvbm1lbnROb2RlJztcclxuXHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBDb25zdHJ1Y3RzIGEgbmV3IGVudmlyb25tZW50IG5vZGUuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge05vZGV9IFtlbnZOb2RlPW51bGxdIC0gQSBub2RlIHJlcHJlc2VudGluZyB0aGUgZW52aXJvbm1lbnQuXHJcblx0ICovXHJcblx0Y29uc3RydWN0b3IoIGVudk5vZGUgPSBudWxsICkge1xyXG5cclxuXHRcdHN1cGVyKCk7XHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBBIG5vZGUgcmVwcmVzZW50aW5nIHRoZSBlbnZpcm9ubWVudC5cclxuXHRcdCAqXHJcblx0XHQgKiBAdHlwZSB7Tm9kZT99XHJcblx0XHQgKiBAZGVmYXVsdCBudWxsXHJcblx0XHQgKi9cclxuXHRcdHRoaXMuZW52Tm9kZSA9IGVudk5vZGU7XHJcblxyXG5cdH1cclxuXHJcblx0c2V0dXAoIGJ1aWxkZXIgKSB7XHJcblxyXG5cdFx0Y29uc3QgeyBtYXRlcmlhbCB9ID0gYnVpbGRlcjtcclxuXHJcblx0XHRsZXQgZW52Tm9kZSA9IHRoaXMuZW52Tm9kZTtcclxuXHJcblx0XHRpZiAoIGVudk5vZGUuaXNUZXh0dXJlTm9kZSB8fCBlbnZOb2RlLmlzTWF0ZXJpYWxSZWZlcmVuY2VOb2RlICkge1xyXG5cclxuXHRcdFx0Y29uc3QgdmFsdWUgPSAoIGVudk5vZGUuaXNUZXh0dXJlTm9kZSApID8gZW52Tm9kZS52YWx1ZSA6IG1hdGVyaWFsWyBlbnZOb2RlLnByb3BlcnR5IF07XHJcblxyXG5cdFx0XHRsZXQgY2FjaGVFbnZOb2RlID0gX2Vudk5vZGVDYWNoZS5nZXQoIHZhbHVlICk7XHJcblxyXG5cdFx0XHRpZiAoIGNhY2hlRW52Tm9kZSA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRjYWNoZUVudk5vZGUgPSBwbXJlbVRleHR1cmUoIHZhbHVlICk7XHJcblxyXG5cdFx0XHRcdF9lbnZOb2RlQ2FjaGUuc2V0KCB2YWx1ZSwgY2FjaGVFbnZOb2RlICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRlbnZOb2RlXHQ9IGNhY2hlRW52Tm9kZTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly9cclxuXHJcblx0XHRjb25zdCBlbnZNYXAgPSBtYXRlcmlhbC5lbnZNYXA7XHJcblx0XHRjb25zdCBpbnRlbnNpdHkgPSBlbnZNYXAgPyByZWZlcmVuY2UoICdlbnZNYXBJbnRlbnNpdHknLCAnZmxvYXQnLCBidWlsZGVyLm1hdGVyaWFsICkgOiByZWZlcmVuY2UoICdlbnZpcm9ubWVudEludGVuc2l0eScsICdmbG9hdCcsIGJ1aWxkZXIuc2NlbmUgKTsgLy8gQFRPRE86IEFkZCBtYXRlcmlhbEVudkludGVuc2l0eSBpbiBNYXRlcmlhbE5vZGVcclxuXHJcblx0XHRjb25zdCB1c2VBbmlzb3Ryb3B5ID0gbWF0ZXJpYWwudXNlQW5pc290cm9weSA9PT0gdHJ1ZSB8fCBtYXRlcmlhbC5hbmlzb3Ryb3B5ID4gMDtcclxuXHRcdGNvbnN0IHJhZGlhbmNlTm9ybWFsVmlldyA9IHVzZUFuaXNvdHJvcHkgPyB0cmFuc2Zvcm1lZEJlbnROb3JtYWxWaWV3IDogdHJhbnNmb3JtZWROb3JtYWxWaWV3O1xyXG5cclxuXHRcdGNvbnN0IHJhZGlhbmNlID0gZW52Tm9kZS5jb250ZXh0KCBjcmVhdGVSYWRpYW5jZUNvbnRleHQoIHJvdWdobmVzcywgcmFkaWFuY2VOb3JtYWxWaWV3ICkgKS5tdWwoIGludGVuc2l0eSApO1xyXG5cdFx0Y29uc3QgaXJyYWRpYW5jZSA9IGVudk5vZGUuY29udGV4dCggY3JlYXRlSXJyYWRpYW5jZUNvbnRleHQoIHRyYW5zZm9ybWVkTm9ybWFsV29ybGQgKSApLm11bCggTWF0aC5QSSApLm11bCggaW50ZW5zaXR5ICk7XHJcblxyXG5cdFx0Y29uc3QgaXNvbGF0ZVJhZGlhbmNlID0gY2FjaGUoIHJhZGlhbmNlICk7XHJcblx0XHRjb25zdCBpc29sYXRlSXJyYWRpYW5jZSA9IGNhY2hlKCBpcnJhZGlhbmNlICk7XHJcblxyXG5cdFx0Ly9cclxuXHJcblx0XHRidWlsZGVyLmNvbnRleHQucmFkaWFuY2UuYWRkQXNzaWduKCBpc29sYXRlUmFkaWFuY2UgKTtcclxuXHJcblx0XHRidWlsZGVyLmNvbnRleHQuaWJsSXJyYWRpYW5jZS5hZGRBc3NpZ24oIGlzb2xhdGVJcnJhZGlhbmNlICk7XHJcblxyXG5cdFx0Ly9cclxuXHJcblx0XHRjb25zdCBjbGVhcmNvYXRSYWRpYW5jZSA9IGJ1aWxkZXIuY29udGV4dC5saWdodGluZ01vZGVsLmNsZWFyY29hdFJhZGlhbmNlO1xyXG5cclxuXHRcdGlmICggY2xlYXJjb2F0UmFkaWFuY2UgKSB7XHJcblxyXG5cdFx0XHRjb25zdCBjbGVhcmNvYXRSYWRpYW5jZUNvbnRleHQgPSBlbnZOb2RlLmNvbnRleHQoIGNyZWF0ZVJhZGlhbmNlQ29udGV4dCggY2xlYXJjb2F0Um91Z2huZXNzLCB0cmFuc2Zvcm1lZENsZWFyY29hdE5vcm1hbFZpZXcgKSApLm11bCggaW50ZW5zaXR5ICk7XHJcblx0XHRcdGNvbnN0IGlzb2xhdGVDbGVhcmNvYXRSYWRpYW5jZSA9IGNhY2hlKCBjbGVhcmNvYXRSYWRpYW5jZUNvbnRleHQgKTtcclxuXHJcblx0XHRcdGNsZWFyY29hdFJhZGlhbmNlLmFkZEFzc2lnbiggaXNvbGF0ZUNsZWFyY29hdFJhZGlhbmNlICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBFbnZpcm9ubWVudE5vZGU7XHJcblxyXG5jb25zdCBjcmVhdGVSYWRpYW5jZUNvbnRleHQgPSAoIHJvdWdobmVzc05vZGUsIG5vcm1hbFZpZXdOb2RlICkgPT4ge1xyXG5cclxuXHRsZXQgcmVmbGVjdFZlYyA9IG51bGw7XHJcblxyXG5cdHJldHVybiB7XHJcblx0XHRnZXRVVjogKCkgPT4ge1xyXG5cclxuXHRcdFx0aWYgKCByZWZsZWN0VmVjID09PSBudWxsICkge1xyXG5cclxuXHRcdFx0XHRyZWZsZWN0VmVjID0gcG9zaXRpb25WaWV3RGlyZWN0aW9uLm5lZ2F0ZSgpLnJlZmxlY3QoIG5vcm1hbFZpZXdOb2RlICk7XHJcblxyXG5cdFx0XHRcdC8vIE1peGluZyB0aGUgcmVmbGVjdGlvbiB3aXRoIHRoZSBub3JtYWwgaXMgbW9yZSBhY2N1cmF0ZSBhbmQga2VlcHMgcm91Z2ggb2JqZWN0cyBmcm9tIGdhdGhlcmluZyBsaWdodCBmcm9tIGJlaGluZCB0aGVpciB0YW5nZW50IHBsYW5lLlxyXG5cdFx0XHRcdHJlZmxlY3RWZWMgPSByb3VnaG5lc3NOb2RlLm11bCggcm91Z2huZXNzTm9kZSApLm1peCggcmVmbGVjdFZlYywgbm9ybWFsVmlld05vZGUgKS5ub3JtYWxpemUoKTtcclxuXHJcblx0XHRcdFx0cmVmbGVjdFZlYyA9IHJlZmxlY3RWZWMudHJhbnNmb3JtRGlyZWN0aW9uKCBjYW1lcmFWaWV3TWF0cml4ICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRyZXR1cm4gcmVmbGVjdFZlYztcclxuXHJcblx0XHR9LFxyXG5cdFx0Z2V0VGV4dHVyZUxldmVsOiAoKSA9PiB7XHJcblxyXG5cdFx0XHRyZXR1cm4gcm91Z2huZXNzTm9kZTtcclxuXHJcblx0XHR9XHJcblx0fTtcclxuXHJcbn07XHJcblxyXG5jb25zdCBjcmVhdGVJcnJhZGlhbmNlQ29udGV4dCA9ICggbm9ybWFsV29ybGROb2RlICkgPT4ge1xyXG5cclxuXHRyZXR1cm4ge1xyXG5cdFx0Z2V0VVY6ICgpID0+IHtcclxuXHJcblx0XHRcdHJldHVybiBub3JtYWxXb3JsZE5vZGU7XHJcblxyXG5cdFx0fSxcclxuXHRcdGdldFRleHR1cmVMZXZlbDogKCkgPT4ge1xyXG5cclxuXHRcdFx0cmV0dXJuIGZsb2F0KCAxLjAgKTtcclxuXHJcblx0XHR9XHJcblx0fTtcclxuXHJcbn07XHJcbiIsImltcG9ydCBOb2RlTWF0ZXJpYWwgZnJvbSAnLi9Ob2RlTWF0ZXJpYWwuanMnO1xyXG5pbXBvcnQgeyBkaWZmdXNlQ29sb3IsIG1ldGFsbmVzcywgcm91Z2huZXNzLCBzcGVjdWxhckNvbG9yLCBzcGVjdWxhckY5MCB9IGZyb20gJy4uLy4uL25vZGVzL2NvcmUvUHJvcGVydHlOb2RlLmpzJztcclxuaW1wb3J0IHsgbWl4IH0gZnJvbSAnLi4vLi4vbm9kZXMvbWF0aC9NYXRoTm9kZS5qcyc7XHJcbmltcG9ydCB7IG1hdGVyaWFsUm91Z2huZXNzLCBtYXRlcmlhbE1ldGFsbmVzcyB9IGZyb20gJy4uLy4uL25vZGVzL2FjY2Vzc29ycy9NYXRlcmlhbE5vZGUuanMnO1xyXG5pbXBvcnQgZ2V0Um91Z2huZXNzIGZyb20gJy4uLy4uL25vZGVzL2Z1bmN0aW9ucy9tYXRlcmlhbC9nZXRSb3VnaG5lc3MuanMnO1xyXG5pbXBvcnQgUGh5c2ljYWxMaWdodGluZ01vZGVsIGZyb20gJy4uLy4uL25vZGVzL2Z1bmN0aW9ucy9QaHlzaWNhbExpZ2h0aW5nTW9kZWwuanMnO1xyXG5pbXBvcnQgRW52aXJvbm1lbnROb2RlIGZyb20gJy4uLy4uL25vZGVzL2xpZ2h0aW5nL0Vudmlyb25tZW50Tm9kZS5qcyc7XHJcbmltcG9ydCB7IGZsb2F0LCB2ZWMzLCB2ZWM0IH0gZnJvbSAnLi4vLi4vbm9kZXMvdHNsL1RTTEJhc2UuanMnO1xyXG5cclxuaW1wb3J0IHsgTWVzaFN0YW5kYXJkTWF0ZXJpYWwgfSBmcm9tICcuLi9NZXNoU3RhbmRhcmRNYXRlcmlhbC5qcyc7XHJcblxyXG5jb25zdCBfZGVmYXVsdFZhbHVlcyA9IC8qQF9fUFVSRV9fKi8gbmV3IE1lc2hTdGFuZGFyZE1hdGVyaWFsKCk7XHJcblxyXG5jbGFzcyBNZXNoU3RhbmRhcmROb2RlTWF0ZXJpYWwgZXh0ZW5kcyBOb2RlTWF0ZXJpYWwge1xyXG5cclxuXHRzdGF0aWMgZ2V0IHR5cGUoKSB7XHJcblxyXG5cdFx0cmV0dXJuICdNZXNoU3RhbmRhcmROb2RlTWF0ZXJpYWwnO1xyXG5cclxuXHR9XHJcblxyXG5cdGNvbnN0cnVjdG9yKCBwYXJhbWV0ZXJzICkge1xyXG5cclxuXHRcdHN1cGVyKCk7XHJcblxyXG5cdFx0dGhpcy5pc01lc2hTdGFuZGFyZE5vZGVNYXRlcmlhbCA9IHRydWU7XHJcblxyXG5cdFx0dGhpcy5saWdodHMgPSB0cnVlO1xyXG5cclxuXHRcdHRoaXMuZW1pc3NpdmVOb2RlID0gbnVsbDtcclxuXHJcblx0XHR0aGlzLm1ldGFsbmVzc05vZGUgPSBudWxsO1xyXG5cdFx0dGhpcy5yb3VnaG5lc3NOb2RlID0gbnVsbDtcclxuXHJcblx0XHR0aGlzLnNldERlZmF1bHRWYWx1ZXMoIF9kZWZhdWx0VmFsdWVzICk7XHJcblxyXG5cdFx0dGhpcy5zZXRWYWx1ZXMoIHBhcmFtZXRlcnMgKTtcclxuXHJcblx0fVxyXG5cclxuXHRzZXR1cEVudmlyb25tZW50KCBidWlsZGVyICkge1xyXG5cclxuXHRcdGxldCBlbnZOb2RlID0gc3VwZXIuc2V0dXBFbnZpcm9ubWVudCggYnVpbGRlciApO1xyXG5cclxuXHRcdGlmICggZW52Tm9kZSA9PT0gbnVsbCAmJiBidWlsZGVyLmVudmlyb25tZW50Tm9kZSApIHtcclxuXHJcblx0XHRcdGVudk5vZGUgPSBidWlsZGVyLmVudmlyb25tZW50Tm9kZTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGVudk5vZGUgPyBuZXcgRW52aXJvbm1lbnROb2RlKCBlbnZOb2RlICkgOiBudWxsO1xyXG5cclxuXHR9XHJcblxyXG5cdHNldHVwTGlnaHRpbmdNb2RlbCggLypidWlsZGVyKi8gKSB7XHJcblxyXG5cdFx0cmV0dXJuIG5ldyBQaHlzaWNhbExpZ2h0aW5nTW9kZWwoKTtcclxuXHJcblx0fVxyXG5cclxuXHRzZXR1cFNwZWN1bGFyKCkge1xyXG5cclxuXHRcdGNvbnN0IHNwZWN1bGFyQ29sb3JOb2RlID0gbWl4KCB2ZWMzKCAwLjA0ICksIGRpZmZ1c2VDb2xvci5yZ2IsIG1ldGFsbmVzcyApO1xyXG5cclxuXHRcdHNwZWN1bGFyQ29sb3IuYXNzaWduKCBzcGVjdWxhckNvbG9yTm9kZSApO1xyXG5cdFx0c3BlY3VsYXJGOTAuYXNzaWduKCAxLjAgKTtcclxuXHJcblx0fVxyXG5cclxuXHRzZXR1cFZhcmlhbnRzKCkge1xyXG5cclxuXHRcdC8vIE1FVEFMTkVTU1xyXG5cclxuXHRcdGNvbnN0IG1ldGFsbmVzc05vZGUgPSB0aGlzLm1ldGFsbmVzc05vZGUgPyBmbG9hdCggdGhpcy5tZXRhbG5lc3NOb2RlICkgOiBtYXRlcmlhbE1ldGFsbmVzcztcclxuXHJcblx0XHRtZXRhbG5lc3MuYXNzaWduKCBtZXRhbG5lc3NOb2RlICk7XHJcblxyXG5cdFx0Ly8gUk9VR0hORVNTXHJcblxyXG5cdFx0bGV0IHJvdWdobmVzc05vZGUgPSB0aGlzLnJvdWdobmVzc05vZGUgPyBmbG9hdCggdGhpcy5yb3VnaG5lc3NOb2RlICkgOiBtYXRlcmlhbFJvdWdobmVzcztcclxuXHRcdHJvdWdobmVzc05vZGUgPSBnZXRSb3VnaG5lc3MoIHsgcm91Z2huZXNzOiByb3VnaG5lc3NOb2RlIH0gKTtcclxuXHJcblx0XHRyb3VnaG5lc3MuYXNzaWduKCByb3VnaG5lc3NOb2RlICk7XHJcblxyXG5cdFx0Ly8gU1BFQ1VMQVIgQ09MT1JcclxuXHJcblx0XHR0aGlzLnNldHVwU3BlY3VsYXIoKTtcclxuXHJcblx0XHQvLyBESUZGVVNFIENPTE9SXHJcblxyXG5cdFx0ZGlmZnVzZUNvbG9yLmFzc2lnbiggdmVjNCggZGlmZnVzZUNvbG9yLnJnYi5tdWwoIG1ldGFsbmVzc05vZGUub25lTWludXMoKSApLCBkaWZmdXNlQ29sb3IuYSApICk7XHJcblxyXG5cdH1cclxuXHJcblx0Y29weSggc291cmNlICkge1xyXG5cclxuXHRcdHRoaXMuZW1pc3NpdmVOb2RlID0gc291cmNlLmVtaXNzaXZlTm9kZTtcclxuXHJcblx0XHR0aGlzLm1ldGFsbmVzc05vZGUgPSBzb3VyY2UubWV0YWxuZXNzTm9kZTtcclxuXHRcdHRoaXMucm91Z2huZXNzTm9kZSA9IHNvdXJjZS5yb3VnaG5lc3NOb2RlO1xyXG5cclxuXHRcdHJldHVybiBzdXBlci5jb3B5KCBzb3VyY2UgKTtcclxuXHJcblx0fVxyXG5cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgTWVzaFN0YW5kYXJkTm9kZU1hdGVyaWFsO1xyXG4iLCJpbXBvcnQgeyBjbGVhcmNvYXQsIGNsZWFyY29hdFJvdWdobmVzcywgc2hlZW4sIHNoZWVuUm91Z2huZXNzLCBpcmlkZXNjZW5jZSwgaXJpZGVzY2VuY2VJT1IsIGlyaWRlc2NlbmNlVGhpY2tuZXNzLCBzcGVjdWxhckNvbG9yLCBzcGVjdWxhckY5MCwgZGlmZnVzZUNvbG9yLCBtZXRhbG5lc3MsIHJvdWdobmVzcywgYW5pc290cm9weSwgYWxwaGFULCBhbmlzb3Ryb3B5VCwgYW5pc290cm9weUIsIGlvciwgdHJhbnNtaXNzaW9uLCB0aGlja25lc3MsIGF0dGVudWF0aW9uRGlzdGFuY2UsIGF0dGVudWF0aW9uQ29sb3IsIGRpc3BlcnNpb24gfSBmcm9tICcuLi8uLi9ub2Rlcy9jb3JlL1Byb3BlcnR5Tm9kZS5qcyc7XHJcbmltcG9ydCB7IG1hdGVyaWFsQ2xlYXJjb2F0LCBtYXRlcmlhbENsZWFyY29hdFJvdWdobmVzcywgbWF0ZXJpYWxDbGVhcmNvYXROb3JtYWwsIG1hdGVyaWFsU2hlZW4sIG1hdGVyaWFsU2hlZW5Sb3VnaG5lc3MsIG1hdGVyaWFsSXJpZGVzY2VuY2UsIG1hdGVyaWFsSXJpZGVzY2VuY2VJT1IsIG1hdGVyaWFsSXJpZGVzY2VuY2VUaGlja25lc3MsIG1hdGVyaWFsU3BlY3VsYXJJbnRlbnNpdHksIG1hdGVyaWFsU3BlY3VsYXJDb2xvciwgbWF0ZXJpYWxBbmlzb3Ryb3B5LCBtYXRlcmlhbElPUiwgbWF0ZXJpYWxUcmFuc21pc3Npb24sIG1hdGVyaWFsVGhpY2tuZXNzLCBtYXRlcmlhbEF0dGVudWF0aW9uRGlzdGFuY2UsIG1hdGVyaWFsQXR0ZW51YXRpb25Db2xvciwgbWF0ZXJpYWxEaXNwZXJzaW9uIH0gZnJvbSAnLi4vLi4vbm9kZXMvYWNjZXNzb3JzL01hdGVyaWFsTm9kZS5qcyc7XHJcbmltcG9ydCB7IGZsb2F0LCB2ZWMyLCB2ZWMzLCBJZiB9IGZyb20gJy4uLy4uL25vZGVzL3RzbC9UU0xCYXNlLmpzJztcclxuaW1wb3J0IGdldFJvdWdobmVzcyBmcm9tICcuLi8uLi9ub2Rlcy9mdW5jdGlvbnMvbWF0ZXJpYWwvZ2V0Um91Z2huZXNzLmpzJztcclxuaW1wb3J0IHsgVEJOVmlld01hdHJpeCB9IGZyb20gJy4uLy4uL25vZGVzL2FjY2Vzc29ycy9BY2Nlc3NvcnNVdGlscy5qcyc7XHJcbmltcG9ydCBQaHlzaWNhbExpZ2h0aW5nTW9kZWwgZnJvbSAnLi4vLi4vbm9kZXMvZnVuY3Rpb25zL1BoeXNpY2FsTGlnaHRpbmdNb2RlbC5qcyc7XHJcbmltcG9ydCBNZXNoU3RhbmRhcmROb2RlTWF0ZXJpYWwgZnJvbSAnLi9NZXNoU3RhbmRhcmROb2RlTWF0ZXJpYWwuanMnO1xyXG5pbXBvcnQgeyBtaXgsIHBvdzIsIG1pbiB9IGZyb20gJy4uLy4uL25vZGVzL21hdGgvTWF0aE5vZGUuanMnO1xyXG5cclxuaW1wb3J0IHsgTWVzaFBoeXNpY2FsTWF0ZXJpYWwgfSBmcm9tICcuLi9NZXNoUGh5c2ljYWxNYXRlcmlhbC5qcyc7XHJcblxyXG5jb25zdCBfZGVmYXVsdFZhbHVlcyA9IC8qQF9fUFVSRV9fKi8gbmV3IE1lc2hQaHlzaWNhbE1hdGVyaWFsKCk7XHJcblxyXG5jbGFzcyBNZXNoUGh5c2ljYWxOb2RlTWF0ZXJpYWwgZXh0ZW5kcyBNZXNoU3RhbmRhcmROb2RlTWF0ZXJpYWwge1xyXG5cclxuXHRzdGF0aWMgZ2V0IHR5cGUoKSB7XHJcblxyXG5cdFx0cmV0dXJuICdNZXNoUGh5c2ljYWxOb2RlTWF0ZXJpYWwnO1xyXG5cclxuXHR9XHJcblxyXG5cdGNvbnN0cnVjdG9yKCBwYXJhbWV0ZXJzICkge1xyXG5cclxuXHRcdHN1cGVyKCk7XHJcblxyXG5cdFx0dGhpcy5pc01lc2hQaHlzaWNhbE5vZGVNYXRlcmlhbCA9IHRydWU7XHJcblxyXG5cdFx0dGhpcy5jbGVhcmNvYXROb2RlID0gbnVsbDtcclxuXHRcdHRoaXMuY2xlYXJjb2F0Um91Z2huZXNzTm9kZSA9IG51bGw7XHJcblx0XHR0aGlzLmNsZWFyY29hdE5vcm1hbE5vZGUgPSBudWxsO1xyXG5cclxuXHRcdHRoaXMuc2hlZW5Ob2RlID0gbnVsbDtcclxuXHRcdHRoaXMuc2hlZW5Sb3VnaG5lc3NOb2RlID0gbnVsbDtcclxuXHJcblx0XHR0aGlzLmlyaWRlc2NlbmNlTm9kZSA9IG51bGw7XHJcblx0XHR0aGlzLmlyaWRlc2NlbmNlSU9STm9kZSA9IG51bGw7XHJcblx0XHR0aGlzLmlyaWRlc2NlbmNlVGhpY2tuZXNzTm9kZSA9IG51bGw7XHJcblxyXG5cdFx0dGhpcy5zcGVjdWxhckludGVuc2l0eU5vZGUgPSBudWxsO1xyXG5cdFx0dGhpcy5zcGVjdWxhckNvbG9yTm9kZSA9IG51bGw7XHJcblxyXG5cdFx0dGhpcy5pb3JOb2RlID0gbnVsbDtcclxuXHRcdHRoaXMudHJhbnNtaXNzaW9uTm9kZSA9IG51bGw7XHJcblx0XHR0aGlzLnRoaWNrbmVzc05vZGUgPSBudWxsO1xyXG5cdFx0dGhpcy5hdHRlbnVhdGlvbkRpc3RhbmNlTm9kZSA9IG51bGw7XHJcblx0XHR0aGlzLmF0dGVudWF0aW9uQ29sb3JOb2RlID0gbnVsbDtcclxuXHRcdHRoaXMuZGlzcGVyc2lvbk5vZGUgPSBudWxsO1xyXG5cclxuXHRcdHRoaXMuYW5pc290cm9weU5vZGUgPSBudWxsO1xyXG5cclxuXHRcdHRoaXMuc2V0RGVmYXVsdFZhbHVlcyggX2RlZmF1bHRWYWx1ZXMgKTtcclxuXHJcblx0XHR0aGlzLnNldFZhbHVlcyggcGFyYW1ldGVycyApO1xyXG5cclxuXHR9XHJcblxyXG5cdGdldCB1c2VDbGVhcmNvYXQoKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuY2xlYXJjb2F0ID4gMCB8fCB0aGlzLmNsZWFyY29hdE5vZGUgIT09IG51bGw7XHJcblxyXG5cdH1cclxuXHJcblx0Z2V0IHVzZUlyaWRlc2NlbmNlKCkge1xyXG5cclxuXHRcdHJldHVybiB0aGlzLmlyaWRlc2NlbmNlID4gMCB8fCB0aGlzLmlyaWRlc2NlbmNlTm9kZSAhPT0gbnVsbDtcclxuXHJcblx0fVxyXG5cclxuXHRnZXQgdXNlU2hlZW4oKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuc2hlZW4gPiAwIHx8IHRoaXMuc2hlZW5Ob2RlICE9PSBudWxsO1xyXG5cclxuXHR9XHJcblxyXG5cdGdldCB1c2VBbmlzb3Ryb3B5KCkge1xyXG5cclxuXHRcdHJldHVybiB0aGlzLmFuaXNvdHJvcHkgPiAwIHx8IHRoaXMuYW5pc290cm9weU5vZGUgIT09IG51bGw7XHJcblxyXG5cdH1cclxuXHJcblx0Z2V0IHVzZVRyYW5zbWlzc2lvbigpIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy50cmFuc21pc3Npb24gPiAwIHx8IHRoaXMudHJhbnNtaXNzaW9uTm9kZSAhPT0gbnVsbDtcclxuXHJcblx0fVxyXG5cclxuXHRnZXQgdXNlRGlzcGVyc2lvbigpIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5kaXNwZXJzaW9uID4gMCB8fCB0aGlzLmRpc3BlcnNpb25Ob2RlICE9PSBudWxsO1xyXG5cclxuXHR9XHJcblxyXG5cdHNldHVwU3BlY3VsYXIoKSB7XHJcblxyXG5cdFx0Y29uc3QgaW9yTm9kZSA9IHRoaXMuaW9yTm9kZSA/IGZsb2F0KCB0aGlzLmlvck5vZGUgKSA6IG1hdGVyaWFsSU9SO1xyXG5cclxuXHRcdGlvci5hc3NpZ24oIGlvck5vZGUgKTtcclxuXHRcdHNwZWN1bGFyQ29sb3IuYXNzaWduKCBtaXgoIG1pbiggcG93MiggaW9yLnN1YiggMS4wICkuZGl2KCBpb3IuYWRkKCAxLjAgKSApICkubXVsKCBtYXRlcmlhbFNwZWN1bGFyQ29sb3IgKSwgdmVjMyggMS4wICkgKS5tdWwoIG1hdGVyaWFsU3BlY3VsYXJJbnRlbnNpdHkgKSwgZGlmZnVzZUNvbG9yLnJnYiwgbWV0YWxuZXNzICkgKTtcclxuXHRcdHNwZWN1bGFyRjkwLmFzc2lnbiggbWl4KCBtYXRlcmlhbFNwZWN1bGFySW50ZW5zaXR5LCAxLjAsIG1ldGFsbmVzcyApICk7XHJcblxyXG5cdH1cclxuXHJcblx0c2V0dXBMaWdodGluZ01vZGVsKCAvKmJ1aWxkZXIqLyApIHtcclxuXHJcblx0XHRyZXR1cm4gbmV3IFBoeXNpY2FsTGlnaHRpbmdNb2RlbCggdGhpcy51c2VDbGVhcmNvYXQsIHRoaXMudXNlU2hlZW4sIHRoaXMudXNlSXJpZGVzY2VuY2UsIHRoaXMudXNlQW5pc290cm9weSwgdGhpcy51c2VUcmFuc21pc3Npb24sIHRoaXMudXNlRGlzcGVyc2lvbiApO1xyXG5cclxuXHR9XHJcblxyXG5cdHNldHVwVmFyaWFudHMoIGJ1aWxkZXIgKSB7XHJcblxyXG5cdFx0c3VwZXIuc2V0dXBWYXJpYW50cyggYnVpbGRlciApO1xyXG5cclxuXHRcdC8vIENMRUFSQ09BVFxyXG5cclxuXHRcdGlmICggdGhpcy51c2VDbGVhcmNvYXQgKSB7XHJcblxyXG5cdFx0XHRjb25zdCBjbGVhcmNvYXROb2RlID0gdGhpcy5jbGVhcmNvYXROb2RlID8gZmxvYXQoIHRoaXMuY2xlYXJjb2F0Tm9kZSApIDogbWF0ZXJpYWxDbGVhcmNvYXQ7XHJcblx0XHRcdGNvbnN0IGNsZWFyY29hdFJvdWdobmVzc05vZGUgPSB0aGlzLmNsZWFyY29hdFJvdWdobmVzc05vZGUgPyBmbG9hdCggdGhpcy5jbGVhcmNvYXRSb3VnaG5lc3NOb2RlICkgOiBtYXRlcmlhbENsZWFyY29hdFJvdWdobmVzcztcclxuXHJcblx0XHRcdGNsZWFyY29hdC5hc3NpZ24oIGNsZWFyY29hdE5vZGUgKTtcclxuXHRcdFx0Y2xlYXJjb2F0Um91Z2huZXNzLmFzc2lnbiggZ2V0Um91Z2huZXNzKCB7IHJvdWdobmVzczogY2xlYXJjb2F0Um91Z2huZXNzTm9kZSB9ICkgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gU0hFRU5cclxuXHJcblx0XHRpZiAoIHRoaXMudXNlU2hlZW4gKSB7XHJcblxyXG5cdFx0XHRjb25zdCBzaGVlbk5vZGUgPSB0aGlzLnNoZWVuTm9kZSA/IHZlYzMoIHRoaXMuc2hlZW5Ob2RlICkgOiBtYXRlcmlhbFNoZWVuO1xyXG5cdFx0XHRjb25zdCBzaGVlblJvdWdobmVzc05vZGUgPSB0aGlzLnNoZWVuUm91Z2huZXNzTm9kZSA/IGZsb2F0KCB0aGlzLnNoZWVuUm91Z2huZXNzTm9kZSApIDogbWF0ZXJpYWxTaGVlblJvdWdobmVzcztcclxuXHJcblx0XHRcdHNoZWVuLmFzc2lnbiggc2hlZW5Ob2RlICk7XHJcblx0XHRcdHNoZWVuUm91Z2huZXNzLmFzc2lnbiggc2hlZW5Sb3VnaG5lc3NOb2RlICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIElSSURFU0NFTkNFXHJcblxyXG5cdFx0aWYgKCB0aGlzLnVzZUlyaWRlc2NlbmNlICkge1xyXG5cclxuXHRcdFx0Y29uc3QgaXJpZGVzY2VuY2VOb2RlID0gdGhpcy5pcmlkZXNjZW5jZU5vZGUgPyBmbG9hdCggdGhpcy5pcmlkZXNjZW5jZU5vZGUgKSA6IG1hdGVyaWFsSXJpZGVzY2VuY2U7XHJcblx0XHRcdGNvbnN0IGlyaWRlc2NlbmNlSU9STm9kZSA9IHRoaXMuaXJpZGVzY2VuY2VJT1JOb2RlID8gZmxvYXQoIHRoaXMuaXJpZGVzY2VuY2VJT1JOb2RlICkgOiBtYXRlcmlhbElyaWRlc2NlbmNlSU9SO1xyXG5cdFx0XHRjb25zdCBpcmlkZXNjZW5jZVRoaWNrbmVzc05vZGUgPSB0aGlzLmlyaWRlc2NlbmNlVGhpY2tuZXNzTm9kZSA/IGZsb2F0KCB0aGlzLmlyaWRlc2NlbmNlVGhpY2tuZXNzTm9kZSApIDogbWF0ZXJpYWxJcmlkZXNjZW5jZVRoaWNrbmVzcztcclxuXHJcblx0XHRcdGlyaWRlc2NlbmNlLmFzc2lnbiggaXJpZGVzY2VuY2VOb2RlICk7XHJcblx0XHRcdGlyaWRlc2NlbmNlSU9SLmFzc2lnbiggaXJpZGVzY2VuY2VJT1JOb2RlICk7XHJcblx0XHRcdGlyaWRlc2NlbmNlVGhpY2tuZXNzLmFzc2lnbiggaXJpZGVzY2VuY2VUaGlja25lc3NOb2RlICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIEFOSVNPVFJPUFlcclxuXHJcblx0XHRpZiAoIHRoaXMudXNlQW5pc290cm9weSApIHtcclxuXHJcblx0XHRcdGNvbnN0IGFuaXNvdHJvcHlWID0gKCB0aGlzLmFuaXNvdHJvcHlOb2RlID8gdmVjMiggdGhpcy5hbmlzb3Ryb3B5Tm9kZSApIDogbWF0ZXJpYWxBbmlzb3Ryb3B5ICkudG9WYXIoKTtcclxuXHJcblx0XHRcdGFuaXNvdHJvcHkuYXNzaWduKCBhbmlzb3Ryb3B5Vi5sZW5ndGgoKSApO1xyXG5cclxuXHRcdFx0SWYoIGFuaXNvdHJvcHkuZXF1YWwoIDAuMCApLCAoKSA9PiB7XHJcblxyXG5cdFx0XHRcdGFuaXNvdHJvcHlWLmFzc2lnbiggdmVjMiggMS4wLCAwLjAgKSApO1xyXG5cclxuXHRcdFx0fSApLkVsc2UoICgpID0+IHtcclxuXHJcblx0XHRcdFx0YW5pc290cm9weVYuZGl2QXNzaWduKCB2ZWMyKCBhbmlzb3Ryb3B5ICkgKTtcclxuXHRcdFx0XHRhbmlzb3Ryb3B5LmFzc2lnbiggYW5pc290cm9weS5zYXR1cmF0ZSgpICk7XHJcblxyXG5cdFx0XHR9ICk7XHJcblxyXG5cdFx0XHQvLyBSb3VnaG5lc3MgYWxvbmcgdGhlIGFuaXNvdHJvcHkgYml0YW5nZW50IGlzIHRoZSBtYXRlcmlhbCByb3VnaG5lc3MsIHdoaWxlIHRoZSB0YW5nZW50IHJvdWdobmVzcyBpbmNyZWFzZXMgd2l0aCBhbmlzb3Ryb3B5LlxyXG5cdFx0XHRhbHBoYVQuYXNzaWduKCBhbmlzb3Ryb3B5LnBvdzIoKS5taXgoIHJvdWdobmVzcy5wb3cyKCksIDEuMCApICk7XHJcblxyXG5cdFx0XHRhbmlzb3Ryb3B5VC5hc3NpZ24oIFRCTlZpZXdNYXRyaXhbIDAgXS5tdWwoIGFuaXNvdHJvcHlWLnggKS5hZGQoIFRCTlZpZXdNYXRyaXhbIDEgXS5tdWwoIGFuaXNvdHJvcHlWLnkgKSApICk7XHJcblx0XHRcdGFuaXNvdHJvcHlCLmFzc2lnbiggVEJOVmlld01hdHJpeFsgMSBdLm11bCggYW5pc290cm9weVYueCApLnN1YiggVEJOVmlld01hdHJpeFsgMCBdLm11bCggYW5pc290cm9weVYueSApICkgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gVFJBTlNNSVNTSU9OXHJcblxyXG5cdFx0aWYgKCB0aGlzLnVzZVRyYW5zbWlzc2lvbiApIHtcclxuXHJcblx0XHRcdGNvbnN0IHRyYW5zbWlzc2lvbk5vZGUgPSB0aGlzLnRyYW5zbWlzc2lvbk5vZGUgPyBmbG9hdCggdGhpcy50cmFuc21pc3Npb25Ob2RlICkgOiBtYXRlcmlhbFRyYW5zbWlzc2lvbjtcclxuXHRcdFx0Y29uc3QgdGhpY2tuZXNzTm9kZSA9IHRoaXMudGhpY2tuZXNzTm9kZSA/IGZsb2F0KCB0aGlzLnRoaWNrbmVzc05vZGUgKSA6IG1hdGVyaWFsVGhpY2tuZXNzO1xyXG5cdFx0XHRjb25zdCBhdHRlbnVhdGlvbkRpc3RhbmNlTm9kZSA9IHRoaXMuYXR0ZW51YXRpb25EaXN0YW5jZU5vZGUgPyBmbG9hdCggdGhpcy5hdHRlbnVhdGlvbkRpc3RhbmNlTm9kZSApIDogbWF0ZXJpYWxBdHRlbnVhdGlvbkRpc3RhbmNlO1xyXG5cdFx0XHRjb25zdCBhdHRlbnVhdGlvbkNvbG9yTm9kZSA9IHRoaXMuYXR0ZW51YXRpb25Db2xvck5vZGUgPyB2ZWMzKCB0aGlzLmF0dGVudWF0aW9uQ29sb3JOb2RlICkgOiBtYXRlcmlhbEF0dGVudWF0aW9uQ29sb3I7XHJcblxyXG5cdFx0XHR0cmFuc21pc3Npb24uYXNzaWduKCB0cmFuc21pc3Npb25Ob2RlICk7XHJcblx0XHRcdHRoaWNrbmVzcy5hc3NpZ24oIHRoaWNrbmVzc05vZGUgKTtcclxuXHRcdFx0YXR0ZW51YXRpb25EaXN0YW5jZS5hc3NpZ24oIGF0dGVudWF0aW9uRGlzdGFuY2VOb2RlICk7XHJcblx0XHRcdGF0dGVudWF0aW9uQ29sb3IuYXNzaWduKCBhdHRlbnVhdGlvbkNvbG9yTm9kZSApO1xyXG5cclxuXHRcdFx0aWYgKCB0aGlzLnVzZURpc3BlcnNpb24gKSB7XHJcblxyXG5cdFx0XHRcdGNvbnN0IGRpc3BlcnNpb25Ob2RlID0gdGhpcy5kaXNwZXJzaW9uTm9kZSA/IGZsb2F0KCB0aGlzLmRpc3BlcnNpb25Ob2RlICkgOiBtYXRlcmlhbERpc3BlcnNpb247XHJcblxyXG5cdFx0XHRcdGRpc3BlcnNpb24uYXNzaWduKCBkaXNwZXJzaW9uTm9kZSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHRzZXR1cENsZWFyY29hdE5vcm1hbCgpIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5jbGVhcmNvYXROb3JtYWxOb2RlID8gdmVjMyggdGhpcy5jbGVhcmNvYXROb3JtYWxOb2RlICkgOiBtYXRlcmlhbENsZWFyY29hdE5vcm1hbDtcclxuXHJcblx0fVxyXG5cclxuXHRzZXR1cCggYnVpbGRlciApIHtcclxuXHJcblx0XHRidWlsZGVyLmNvbnRleHQuc2V0dXBDbGVhcmNvYXROb3JtYWwgPSAoKSA9PiB0aGlzLnNldHVwQ2xlYXJjb2F0Tm9ybWFsKCBidWlsZGVyICk7XHJcblxyXG5cdFx0c3VwZXIuc2V0dXAoIGJ1aWxkZXIgKTtcclxuXHJcblx0fVxyXG5cclxuXHRjb3B5KCBzb3VyY2UgKSB7XHJcblxyXG5cdFx0dGhpcy5jbGVhcmNvYXROb2RlID0gc291cmNlLmNsZWFyY29hdE5vZGU7XHJcblx0XHR0aGlzLmNsZWFyY29hdFJvdWdobmVzc05vZGUgPSBzb3VyY2UuY2xlYXJjb2F0Um91Z2huZXNzTm9kZTtcclxuXHRcdHRoaXMuY2xlYXJjb2F0Tm9ybWFsTm9kZSA9IHNvdXJjZS5jbGVhcmNvYXROb3JtYWxOb2RlO1xyXG5cclxuXHRcdHRoaXMuc2hlZW5Ob2RlID0gc291cmNlLnNoZWVuTm9kZTtcclxuXHRcdHRoaXMuc2hlZW5Sb3VnaG5lc3NOb2RlID0gc291cmNlLnNoZWVuUm91Z2huZXNzTm9kZTtcclxuXHJcblx0XHR0aGlzLmlyaWRlc2NlbmNlTm9kZSA9IHNvdXJjZS5pcmlkZXNjZW5jZU5vZGU7XHJcblx0XHR0aGlzLmlyaWRlc2NlbmNlSU9STm9kZSA9IHNvdXJjZS5pcmlkZXNjZW5jZUlPUk5vZGU7XHJcblx0XHR0aGlzLmlyaWRlc2NlbmNlVGhpY2tuZXNzTm9kZSA9IHNvdXJjZS5pcmlkZXNjZW5jZVRoaWNrbmVzc05vZGU7XHJcblxyXG5cdFx0dGhpcy5zcGVjdWxhckludGVuc2l0eU5vZGUgPSBzb3VyY2Uuc3BlY3VsYXJJbnRlbnNpdHlOb2RlO1xyXG5cdFx0dGhpcy5zcGVjdWxhckNvbG9yTm9kZSA9IHNvdXJjZS5zcGVjdWxhckNvbG9yTm9kZTtcclxuXHJcblx0XHR0aGlzLnRyYW5zbWlzc2lvbk5vZGUgPSBzb3VyY2UudHJhbnNtaXNzaW9uTm9kZTtcclxuXHRcdHRoaXMudGhpY2tuZXNzTm9kZSA9IHNvdXJjZS50aGlja25lc3NOb2RlO1xyXG5cdFx0dGhpcy5hdHRlbnVhdGlvbkRpc3RhbmNlTm9kZSA9IHNvdXJjZS5hdHRlbnVhdGlvbkRpc3RhbmNlTm9kZTtcclxuXHRcdHRoaXMuYXR0ZW51YXRpb25Db2xvck5vZGUgPSBzb3VyY2UuYXR0ZW51YXRpb25Db2xvck5vZGU7XHJcblx0XHR0aGlzLmRpc3BlcnNpb25Ob2RlID0gc291cmNlLmRpc3BlcnNpb25Ob2RlO1xyXG5cclxuXHRcdHRoaXMuYW5pc290cm9weU5vZGUgPSBzb3VyY2UuYW5pc290cm9weU5vZGU7XHJcblxyXG5cdFx0cmV0dXJuIHN1cGVyLmNvcHkoIHNvdXJjZSApO1xyXG5cclxuXHR9XHJcblxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBNZXNoUGh5c2ljYWxOb2RlTWF0ZXJpYWw7XHJcbiIsImltcG9ydCBNZXNoUGh5c2ljYWxOb2RlTWF0ZXJpYWwgZnJvbSAnLi9NZXNoUGh5c2ljYWxOb2RlTWF0ZXJpYWwuanMnO1xyXG5pbXBvcnQgUGh5c2ljYWxMaWdodGluZ01vZGVsIGZyb20gJy4uLy4uL25vZGVzL2Z1bmN0aW9ucy9QaHlzaWNhbExpZ2h0aW5nTW9kZWwuanMnO1xyXG5pbXBvcnQgeyB0cmFuc2Zvcm1lZE5vcm1hbFZpZXcgfSBmcm9tICcuLi8uLi9ub2Rlcy9hY2Nlc3NvcnMvTm9ybWFsLmpzJztcclxuaW1wb3J0IHsgcG9zaXRpb25WaWV3RGlyZWN0aW9uIH0gZnJvbSAnLi4vLi4vbm9kZXMvYWNjZXNzb3JzL1Bvc2l0aW9uLmpzJztcclxuaW1wb3J0IHsgZmxvYXQsIHZlYzMgfSBmcm9tICcuLi8uLi9ub2Rlcy90c2wvVFNMQmFzZS5qcyc7XHJcblxyXG5jbGFzcyBTU1NMaWdodGluZ01vZGVsIGV4dGVuZHMgUGh5c2ljYWxMaWdodGluZ01vZGVsIHtcclxuXHJcblx0Y29uc3RydWN0b3IoIHVzZUNsZWFyY29hdCwgdXNlU2hlZW4sIHVzZUlyaWRlc2NlbmNlLCB1c2VTU1MgKSB7XHJcblxyXG5cdFx0c3VwZXIoIHVzZUNsZWFyY29hdCwgdXNlU2hlZW4sIHVzZUlyaWRlc2NlbmNlICk7XHJcblxyXG5cdFx0dGhpcy51c2VTU1MgPSB1c2VTU1M7XHJcblxyXG5cdH1cclxuXHJcblx0ZGlyZWN0KCB7IGxpZ2h0RGlyZWN0aW9uLCBsaWdodENvbG9yLCByZWZsZWN0ZWRMaWdodCB9LCBzdGFjaywgYnVpbGRlciApIHtcclxuXHJcblx0XHRpZiAoIHRoaXMudXNlU1NTID09PSB0cnVlICkge1xyXG5cclxuXHRcdFx0Y29uc3QgbWF0ZXJpYWwgPSBidWlsZGVyLm1hdGVyaWFsO1xyXG5cclxuXHRcdFx0Y29uc3QgeyB0aGlja25lc3NDb2xvck5vZGUsIHRoaWNrbmVzc0Rpc3RvcnRpb25Ob2RlLCB0aGlja25lc3NBbWJpZW50Tm9kZSwgdGhpY2tuZXNzQXR0ZW51YXRpb25Ob2RlLCB0aGlja25lc3NQb3dlck5vZGUsIHRoaWNrbmVzc1NjYWxlTm9kZSB9ID0gbWF0ZXJpYWw7XHJcblxyXG5cdFx0XHRjb25zdCBzY2F0dGVyaW5nSGFsZiA9IGxpZ2h0RGlyZWN0aW9uLmFkZCggdHJhbnNmb3JtZWROb3JtYWxWaWV3Lm11bCggdGhpY2tuZXNzRGlzdG9ydGlvbk5vZGUgKSApLm5vcm1hbGl6ZSgpO1xyXG5cdFx0XHRjb25zdCBzY2F0dGVyaW5nRG90ID0gZmxvYXQoIHBvc2l0aW9uVmlld0RpcmVjdGlvbi5kb3QoIHNjYXR0ZXJpbmdIYWxmLm5lZ2F0ZSgpICkuc2F0dXJhdGUoKS5wb3coIHRoaWNrbmVzc1Bvd2VyTm9kZSApLm11bCggdGhpY2tuZXNzU2NhbGVOb2RlICkgKTtcclxuXHRcdFx0Y29uc3Qgc2NhdHRlcmluZ0lsbHUgPSB2ZWMzKCBzY2F0dGVyaW5nRG90LmFkZCggdGhpY2tuZXNzQW1iaWVudE5vZGUgKS5tdWwoIHRoaWNrbmVzc0NvbG9yTm9kZSApICk7XHJcblxyXG5cdFx0XHRyZWZsZWN0ZWRMaWdodC5kaXJlY3REaWZmdXNlLmFkZEFzc2lnbiggc2NhdHRlcmluZ0lsbHUubXVsKCB0aGlja25lc3NBdHRlbnVhdGlvbk5vZGUubXVsKCBsaWdodENvbG9yICkgKSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRzdXBlci5kaXJlY3QoIHsgbGlnaHREaXJlY3Rpb24sIGxpZ2h0Q29sb3IsIHJlZmxlY3RlZExpZ2h0IH0sIHN0YWNrLCBidWlsZGVyICk7XHJcblxyXG5cdH1cclxuXHJcbn1cclxuXHJcbmNsYXNzIE1lc2hTU1NOb2RlTWF0ZXJpYWwgZXh0ZW5kcyBNZXNoUGh5c2ljYWxOb2RlTWF0ZXJpYWwge1xyXG5cclxuXHRzdGF0aWMgZ2V0IHR5cGUoKSB7XHJcblxyXG5cdFx0cmV0dXJuICdNZXNoU1NTTm9kZU1hdGVyaWFsJztcclxuXHJcblx0fVxyXG5cclxuXHRjb25zdHJ1Y3RvciggcGFyYW1ldGVycyApIHtcclxuXHJcblx0XHRzdXBlciggcGFyYW1ldGVycyApO1xyXG5cclxuXHRcdHRoaXMudGhpY2tuZXNzQ29sb3JOb2RlID0gbnVsbDtcclxuXHRcdHRoaXMudGhpY2tuZXNzRGlzdG9ydGlvbk5vZGUgPSBmbG9hdCggMC4xICk7XHJcblx0XHR0aGlzLnRoaWNrbmVzc0FtYmllbnROb2RlID0gZmxvYXQoIDAuMCApO1xyXG5cdFx0dGhpcy50aGlja25lc3NBdHRlbnVhdGlvbk5vZGUgPSBmbG9hdCggLjEgKTtcclxuXHRcdHRoaXMudGhpY2tuZXNzUG93ZXJOb2RlID0gZmxvYXQoIDIuMCApO1xyXG5cdFx0dGhpcy50aGlja25lc3NTY2FsZU5vZGUgPSBmbG9hdCggMTAuMCApO1xyXG5cclxuXHR9XHJcblxyXG5cdGdldCB1c2VTU1MoKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMudGhpY2tuZXNzQ29sb3JOb2RlICE9PSBudWxsO1xyXG5cclxuXHR9XHJcblxyXG5cdHNldHVwTGlnaHRpbmdNb2RlbCggLypidWlsZGVyKi8gKSB7XHJcblxyXG5cdFx0cmV0dXJuIG5ldyBTU1NMaWdodGluZ01vZGVsKCB0aGlzLnVzZUNsZWFyY29hdCwgdGhpcy51c2VTaGVlbiwgdGhpcy51c2VJcmlkZXNjZW5jZSwgdGhpcy51c2VTU1MgKTtcclxuXHJcblx0fVxyXG5cclxuXHRjb3B5KCBzb3VyY2UgKSB7XHJcblxyXG5cdFx0dGhpcy50aGlja25lc3NDb2xvck5vZGUgPSBzb3VyY2UudGhpY2tuZXNzQ29sb3JOb2RlO1xyXG5cdFx0dGhpcy50aGlja25lc3NEaXN0b3J0aW9uTm9kZSA9IHNvdXJjZS50aGlja25lc3NEaXN0b3J0aW9uTm9kZTtcclxuXHRcdHRoaXMudGhpY2tuZXNzQW1iaWVudE5vZGUgPSBzb3VyY2UudGhpY2tuZXNzQW1iaWVudE5vZGU7XHJcblx0XHR0aGlzLnRoaWNrbmVzc0F0dGVudWF0aW9uTm9kZSA9IHNvdXJjZS50aGlja25lc3NBdHRlbnVhdGlvbk5vZGU7XHJcblx0XHR0aGlzLnRoaWNrbmVzc1Bvd2VyTm9kZSA9IHNvdXJjZS50aGlja25lc3NQb3dlck5vZGU7XHJcblx0XHR0aGlzLnRoaWNrbmVzc1NjYWxlTm9kZSA9IHNvdXJjZS50aGlja25lc3NTY2FsZU5vZGU7XHJcblxyXG5cdFx0cmV0dXJuIHN1cGVyLmNvcHkoIHNvdXJjZSApO1xyXG5cclxuXHR9XHJcblxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBNZXNoU1NTTm9kZU1hdGVyaWFsO1xyXG4iLCJpbXBvcnQgTGlnaHRpbmdNb2RlbCBmcm9tICcuLi9jb3JlL0xpZ2h0aW5nTW9kZWwuanMnO1xyXG5pbXBvcnQgQlJERl9MYW1iZXJ0IGZyb20gJy4vQlNERi9CUkRGX0xhbWJlcnQuanMnO1xyXG5pbXBvcnQgeyBkaWZmdXNlQ29sb3IgfSBmcm9tICcuLi9jb3JlL1Byb3BlcnR5Tm9kZS5qcyc7XHJcbmltcG9ydCB7IG5vcm1hbEdlb21ldHJ5IH0gZnJvbSAnLi4vYWNjZXNzb3JzL05vcm1hbC5qcyc7XHJcbmltcG9ydCB7IEZuLCBmbG9hdCwgdmVjMiwgdmVjMyB9IGZyb20gJy4uL3RzbC9UU0xCYXNlLmpzJztcclxuaW1wb3J0IHsgbWl4LCBzbW9vdGhzdGVwIH0gZnJvbSAnLi4vbWF0aC9NYXRoTm9kZS5qcyc7XHJcbmltcG9ydCB7IG1hdGVyaWFsUmVmZXJlbmNlIH0gZnJvbSAnLi4vYWNjZXNzb3JzL01hdGVyaWFsUmVmZXJlbmNlTm9kZS5qcyc7XHJcblxyXG5jb25zdCBnZXRHcmFkaWVudElycmFkaWFuY2UgPSAvKkBfX1BVUkVfXyovIEZuKCAoIHsgbm9ybWFsLCBsaWdodERpcmVjdGlvbiwgYnVpbGRlciB9ICkgPT4ge1xyXG5cclxuXHQvLyBkb3ROTCB3aWxsIGJlIGZyb20gLTEuMCB0byAxLjBcclxuXHRjb25zdCBkb3ROTCA9IG5vcm1hbC5kb3QoIGxpZ2h0RGlyZWN0aW9uICk7XHJcblx0Y29uc3QgY29vcmQgPSB2ZWMyKCBkb3ROTC5tdWwoIDAuNSApLmFkZCggMC41ICksIDAuMCApO1xyXG5cclxuXHRpZiAoIGJ1aWxkZXIubWF0ZXJpYWwuZ3JhZGllbnRNYXAgKSB7XHJcblxyXG5cdFx0Y29uc3QgZ3JhZGllbnRNYXAgPSBtYXRlcmlhbFJlZmVyZW5jZSggJ2dyYWRpZW50TWFwJywgJ3RleHR1cmUnICkuY29udGV4dCggeyBnZXRVVjogKCkgPT4gY29vcmQgfSApO1xyXG5cclxuXHRcdHJldHVybiB2ZWMzKCBncmFkaWVudE1hcC5yICk7XHJcblxyXG5cdH0gZWxzZSB7XHJcblxyXG5cdFx0Y29uc3QgZncgPSBjb29yZC5md2lkdGgoKS5tdWwoIDAuNSApO1xyXG5cclxuXHRcdHJldHVybiBtaXgoIHZlYzMoIDAuNyApLCB2ZWMzKCAxLjAgKSwgc21vb3Roc3RlcCggZmxvYXQoIDAuNyApLnN1YiggZncueCApLCBmbG9hdCggMC43ICkuYWRkKCBmdy54ICksIGNvb3JkLnggKSApO1xyXG5cclxuXHR9XHJcblxyXG59ICk7XHJcblxyXG4vKipcclxuICogUmVwcmVzZW50cyB0aGUgbGlnaHRpbmcgbW9kZWwgZm9yIGEgdG9vbiBtYXRlcmlhbC4gVXNlZCBpbiB7QGxpbmsgTWVzaFRvb25Ob2RlTWF0ZXJpYWx9LlxyXG4gKlxyXG4gKiBAYXVnbWVudHMgTGlnaHRpbmdNb2RlbFxyXG4gKi9cclxuY2xhc3MgVG9vbkxpZ2h0aW5nTW9kZWwgZXh0ZW5kcyBMaWdodGluZ01vZGVsIHtcclxuXHJcblx0LyoqXHJcblx0ICogSW1wbGVtZW50cyB0aGUgZGlyZWN0IGxpZ2h0aW5nLiBJbnN0ZWFkIG9mIHVzaW5nIGEgY29udmVudGlvbmFsIHNtb290aCBpcnJhZGlhbmNlLCB0aGUgaXJyYWRpYW5jZSBpc1xyXG5cdCAqIHJlZHVjZWQgdG8gYSBzbWFsbCBudW1iZXIgb2YgZGlzY3JldGUgc2hhZGVzIHRvIGNyZWF0ZSBhIGNvbWljLWxpa2UsIGZsYXQgbG9vay5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dCAtIFRoZSBpbnB1dCBkYXRhLlxyXG5cdCAqIEBwYXJhbSB7U3RhY2tOb2RlfSBzdGFjayAtIFRoZSBjdXJyZW50IHN0YWNrLlxyXG5cdCAqIEBwYXJhbSB7Tm9kZUJ1aWxkZXJ9IGJ1aWxkZXIgLSBUaGUgY3VycmVudCBub2RlIGJ1aWxkZXIuXHJcblx0ICovXHJcblx0ZGlyZWN0KCB7IGxpZ2h0RGlyZWN0aW9uLCBsaWdodENvbG9yLCByZWZsZWN0ZWRMaWdodCB9LCBzdGFjaywgYnVpbGRlciApIHtcclxuXHJcblx0XHRjb25zdCBpcnJhZGlhbmNlID0gZ2V0R3JhZGllbnRJcnJhZGlhbmNlKCB7IG5vcm1hbDogbm9ybWFsR2VvbWV0cnksIGxpZ2h0RGlyZWN0aW9uLCBidWlsZGVyIH0gKS5tdWwoIGxpZ2h0Q29sb3IgKTtcclxuXHJcblx0XHRyZWZsZWN0ZWRMaWdodC5kaXJlY3REaWZmdXNlLmFkZEFzc2lnbiggaXJyYWRpYW5jZS5tdWwoIEJSREZfTGFtYmVydCggeyBkaWZmdXNlQ29sb3I6IGRpZmZ1c2VDb2xvci5yZ2IgfSApICkgKTtcclxuXHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBJbXBsZW1lbnRzIHRoZSBpbmRpcmVjdCBsaWdodGluZy5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7Q29udGV4dE5vZGV9IGlucHV0IC0gVGhlIGN1cnJlbnQgbm9kZSBjb250ZXh0LlxyXG5cdCAqIEBwYXJhbSB7U3RhY2tOb2RlfSBzdGFjayAtIFRoZSBjdXJyZW50IHN0YWNrLlxyXG5cdCAqIEBwYXJhbSB7Tm9kZUJ1aWxkZXJ9IGJ1aWxkZXIgLSBUaGUgY3VycmVudCBub2RlIGJ1aWxkZXIuXHJcblx0ICovXHJcblx0aW5kaXJlY3QoIHsgYW1iaWVudE9jY2x1c2lvbiwgaXJyYWRpYW5jZSwgcmVmbGVjdGVkTGlnaHQgfSApIHtcclxuXHJcblx0XHRyZWZsZWN0ZWRMaWdodC5pbmRpcmVjdERpZmZ1c2UuYWRkQXNzaWduKCBpcnJhZGlhbmNlLm11bCggQlJERl9MYW1iZXJ0KCB7IGRpZmZ1c2VDb2xvciB9ICkgKSApO1xyXG5cclxuXHRcdHJlZmxlY3RlZExpZ2h0LmluZGlyZWN0RGlmZnVzZS5tdWxBc3NpZ24oIGFtYmllbnRPY2NsdXNpb24gKTtcclxuXHJcblx0fVxyXG5cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgVG9vbkxpZ2h0aW5nTW9kZWw7XHJcbiIsImltcG9ydCBOb2RlTWF0ZXJpYWwgZnJvbSAnLi9Ob2RlTWF0ZXJpYWwuanMnO1xyXG5pbXBvcnQgVG9vbkxpZ2h0aW5nTW9kZWwgZnJvbSAnLi4vLi4vbm9kZXMvZnVuY3Rpb25zL1Rvb25MaWdodGluZ01vZGVsLmpzJztcclxuXHJcbmltcG9ydCB7IE1lc2hUb29uTWF0ZXJpYWwgfSBmcm9tICcuLi9NZXNoVG9vbk1hdGVyaWFsLmpzJztcclxuXHJcbmNvbnN0IF9kZWZhdWx0VmFsdWVzID0gLypAX19QVVJFX18qLyBuZXcgTWVzaFRvb25NYXRlcmlhbCgpO1xyXG5cclxuY2xhc3MgTWVzaFRvb25Ob2RlTWF0ZXJpYWwgZXh0ZW5kcyBOb2RlTWF0ZXJpYWwge1xyXG5cclxuXHRzdGF0aWMgZ2V0IHR5cGUoKSB7XHJcblxyXG5cdFx0cmV0dXJuICdNZXNoVG9vbk5vZGVNYXRlcmlhbCc7XHJcblxyXG5cdH1cclxuXHJcblx0Y29uc3RydWN0b3IoIHBhcmFtZXRlcnMgKSB7XHJcblxyXG5cdFx0c3VwZXIoKTtcclxuXHJcblx0XHR0aGlzLmlzTWVzaFRvb25Ob2RlTWF0ZXJpYWwgPSB0cnVlO1xyXG5cclxuXHRcdHRoaXMubGlnaHRzID0gdHJ1ZTtcclxuXHJcblx0XHR0aGlzLnNldERlZmF1bHRWYWx1ZXMoIF9kZWZhdWx0VmFsdWVzICk7XHJcblxyXG5cdFx0dGhpcy5zZXRWYWx1ZXMoIHBhcmFtZXRlcnMgKTtcclxuXHJcblx0fVxyXG5cclxuXHRzZXR1cExpZ2h0aW5nTW9kZWwoIC8qYnVpbGRlciovICkge1xyXG5cclxuXHRcdHJldHVybiBuZXcgVG9vbkxpZ2h0aW5nTW9kZWwoKTtcclxuXHJcblx0fVxyXG5cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgTWVzaFRvb25Ob2RlTWF0ZXJpYWw7XHJcbiIsImltcG9ydCBUZW1wTm9kZSBmcm9tICcuLi9jb3JlL1RlbXBOb2RlLmpzJztcclxuaW1wb3J0IHsgdHJhbnNmb3JtZWROb3JtYWxWaWV3IH0gZnJvbSAnLi4vYWNjZXNzb3JzL05vcm1hbC5qcyc7XHJcbmltcG9ydCB7IHBvc2l0aW9uVmlld0RpcmVjdGlvbiB9IGZyb20gJy4uL2FjY2Vzc29ycy9Qb3NpdGlvbi5qcyc7XHJcbmltcG9ydCB7IG5vZGVJbW11dGFibGUsIHZlYzIsIHZlYzMgfSBmcm9tICcuLi90c2wvVFNMQmFzZS5qcyc7XHJcblxyXG4vKiogQG1vZHVsZSBNYXRjYXBVVk5vZGUgKiovXHJcblxyXG4vKipcclxuICogQ2FuIGJlIHVzZWQgdG8gY29tcHV0ZSB0ZXh0dXJlIGNvb3JkaW5hdGVzIGZvciBwcm9qZWN0aW5nIGFcclxuICogbWF0Y2FwIG9udG8gYSBtZXNoLiBVc2VkIGJ5IHtAbGluayBNZXNoTWF0Y2FwTm9kZU1hdGVyaWFsfS5cclxuICpcclxuICogQGF1Z21lbnRzIFRlbXBOb2RlXHJcbiAqL1xyXG5jbGFzcyBNYXRjYXBVVk5vZGUgZXh0ZW5kcyBUZW1wTm9kZSB7XHJcblxyXG5cdHN0YXRpYyBnZXQgdHlwZSgpIHtcclxuXHJcblx0XHRyZXR1cm4gJ01hdGNhcFVWTm9kZSc7XHJcblxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogQ29uc3RydWN0cyBhIG5ldyBtYXRjYXAgdXYgbm9kZS5cclxuXHQgKi9cclxuXHRjb25zdHJ1Y3RvcigpIHtcclxuXHJcblx0XHRzdXBlciggJ3ZlYzInICk7XHJcblxyXG5cdH1cclxuXHJcblx0c2V0dXAoKSB7XHJcblxyXG5cdFx0Y29uc3QgeCA9IHZlYzMoIHBvc2l0aW9uVmlld0RpcmVjdGlvbi56LCAwLCBwb3NpdGlvblZpZXdEaXJlY3Rpb24ueC5uZWdhdGUoKSApLm5vcm1hbGl6ZSgpO1xyXG5cdFx0Y29uc3QgeSA9IHBvc2l0aW9uVmlld0RpcmVjdGlvbi5jcm9zcyggeCApO1xyXG5cclxuXHRcdHJldHVybiB2ZWMyKCB4LmRvdCggdHJhbnNmb3JtZWROb3JtYWxWaWV3ICksIHkuZG90KCB0cmFuc2Zvcm1lZE5vcm1hbFZpZXcgKSApLm11bCggMC40OTUgKS5hZGQoIDAuNSApOyAvLyAwLjQ5NSB0byByZW1vdmUgYXJ0aWZhY3RzIGNhdXNlZCBieSB1bmRlcnNpemVkIG1hdGNhcCBkaXNrc1xyXG5cclxuXHR9XHJcblxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBNYXRjYXBVVk5vZGU7XHJcblxyXG4vKipcclxuICogVFNMIGZ1bmN0aW9uIGZvciBjcmVhdGluZyBhIG1hdGNhcCB1diBub2RlLlxyXG4gKlxyXG4gKiBAZnVuY3Rpb25cclxuICogQHJldHVybnMge01hdGNhcFVWTm9kZX1cclxuICovXHJcbmV4cG9ydCBjb25zdCBtYXRjYXBVViA9IC8qQF9fUFVSRV9fKi8gbm9kZUltbXV0YWJsZSggTWF0Y2FwVVZOb2RlICk7XHJcbiIsImltcG9ydCBOb2RlTWF0ZXJpYWwgZnJvbSAnLi9Ob2RlTWF0ZXJpYWwuanMnO1xyXG5pbXBvcnQgeyBtYXRlcmlhbFJlZmVyZW5jZSB9IGZyb20gJy4uLy4uL25vZGVzL2FjY2Vzc29ycy9NYXRlcmlhbFJlZmVyZW5jZU5vZGUuanMnO1xyXG5pbXBvcnQgeyBkaWZmdXNlQ29sb3IgfSBmcm9tICcuLi8uLi9ub2Rlcy9jb3JlL1Byb3BlcnR5Tm9kZS5qcyc7XHJcbmltcG9ydCB7IHZlYzMgfSBmcm9tICcuLi8uLi9ub2Rlcy90c2wvVFNMQmFzZS5qcyc7XHJcbmltcG9ydCB7IG1peCB9IGZyb20gJy4uLy4uL25vZGVzL21hdGgvTWF0aE5vZGUuanMnO1xyXG5pbXBvcnQgeyBtYXRjYXBVViB9IGZyb20gJy4uLy4uL25vZGVzL3V0aWxzL01hdGNhcFVWTm9kZS5qcyc7XHJcblxyXG5pbXBvcnQgeyBNZXNoTWF0Y2FwTWF0ZXJpYWwgfSBmcm9tICcuLi9NZXNoTWF0Y2FwTWF0ZXJpYWwuanMnO1xyXG5cclxuY29uc3QgX2RlZmF1bHRWYWx1ZXMgPSAvKkBfX1BVUkVfXyovIG5ldyBNZXNoTWF0Y2FwTWF0ZXJpYWwoKTtcclxuXHJcbmNsYXNzIE1lc2hNYXRjYXBOb2RlTWF0ZXJpYWwgZXh0ZW5kcyBOb2RlTWF0ZXJpYWwge1xyXG5cclxuXHRzdGF0aWMgZ2V0IHR5cGUoKSB7XHJcblxyXG5cdFx0cmV0dXJuICdNZXNoTWF0Y2FwTm9kZU1hdGVyaWFsJztcclxuXHJcblx0fVxyXG5cclxuXHRjb25zdHJ1Y3RvciggcGFyYW1ldGVycyApIHtcclxuXHJcblx0XHRzdXBlcigpO1xyXG5cclxuXHRcdHRoaXMubGlnaHRzID0gZmFsc2U7XHJcblxyXG5cdFx0dGhpcy5pc01lc2hNYXRjYXBOb2RlTWF0ZXJpYWwgPSB0cnVlO1xyXG5cclxuXHRcdHRoaXMuc2V0RGVmYXVsdFZhbHVlcyggX2RlZmF1bHRWYWx1ZXMgKTtcclxuXHJcblx0XHR0aGlzLnNldFZhbHVlcyggcGFyYW1ldGVycyApO1xyXG5cclxuXHR9XHJcblxyXG5cdHNldHVwVmFyaWFudHMoIGJ1aWxkZXIgKSB7XHJcblxyXG5cdFx0Y29uc3QgdXYgPSBtYXRjYXBVVjtcclxuXHJcblx0XHRsZXQgbWF0Y2FwQ29sb3I7XHJcblxyXG5cdFx0aWYgKCBidWlsZGVyLm1hdGVyaWFsLm1hdGNhcCApIHtcclxuXHJcblx0XHRcdG1hdGNhcENvbG9yID0gbWF0ZXJpYWxSZWZlcmVuY2UoICdtYXRjYXAnLCAndGV4dHVyZScgKS5jb250ZXh0KCB7IGdldFVWOiAoKSA9PiB1diB9ICk7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdG1hdGNhcENvbG9yID0gdmVjMyggbWl4KCAwLjIsIDAuOCwgdXYueSApICk7IC8vIGRlZmF1bHQgaWYgbWF0Y2FwIGlzIG1pc3NpbmdcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0ZGlmZnVzZUNvbG9yLnJnYi5tdWxBc3NpZ24oIG1hdGNhcENvbG9yLnJnYiApO1xyXG5cclxuXHR9XHJcblxyXG59XHJcblxyXG5cclxuZXhwb3J0IGRlZmF1bHQgTWVzaE1hdGNhcE5vZGVNYXRlcmlhbDtcclxuIiwiaW1wb3J0IE5vZGVNYXRlcmlhbCBmcm9tICcuL05vZGVNYXRlcmlhbC5qcyc7XHJcblxyXG5pbXBvcnQgeyBQb2ludHNNYXRlcmlhbCB9IGZyb20gJy4uL1BvaW50c01hdGVyaWFsLmpzJztcclxuXHJcbmNvbnN0IF9kZWZhdWx0VmFsdWVzID0gLypAX19QVVJFX18qLyBuZXcgUG9pbnRzTWF0ZXJpYWwoKTtcclxuXHJcbmNsYXNzIFBvaW50c05vZGVNYXRlcmlhbCBleHRlbmRzIE5vZGVNYXRlcmlhbCB7XHJcblxyXG5cdHN0YXRpYyBnZXQgdHlwZSgpIHtcclxuXHJcblx0XHRyZXR1cm4gJ1BvaW50c05vZGVNYXRlcmlhbCc7XHJcblxyXG5cdH1cclxuXHJcblx0Y29uc3RydWN0b3IoIHBhcmFtZXRlcnMgKSB7XHJcblxyXG5cdFx0c3VwZXIoKTtcclxuXHJcblx0XHR0aGlzLmlzUG9pbnRzTm9kZU1hdGVyaWFsID0gdHJ1ZTtcclxuXHJcblx0XHR0aGlzLmxpZ2h0cyA9IGZhbHNlO1xyXG5cdFx0dGhpcy50cmFuc3BhcmVudCA9IHRydWU7XHJcblxyXG5cdFx0dGhpcy5zaXplTm9kZSA9IG51bGw7XHJcblxyXG5cdFx0dGhpcy5zZXREZWZhdWx0VmFsdWVzKCBfZGVmYXVsdFZhbHVlcyApO1xyXG5cclxuXHRcdHRoaXMuc2V0VmFsdWVzKCBwYXJhbWV0ZXJzICk7XHJcblxyXG5cdH1cclxuXHJcblx0Y29weSggc291cmNlICkge1xyXG5cclxuXHRcdHRoaXMuc2l6ZU5vZGUgPSBzb3VyY2Uuc2l6ZU5vZGU7XHJcblxyXG5cdFx0cmV0dXJuIHN1cGVyLmNvcHkoIHNvdXJjZSApO1xyXG5cclxuXHR9XHJcblxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBQb2ludHNOb2RlTWF0ZXJpYWw7XHJcbiIsImltcG9ydCBUZW1wTm9kZSBmcm9tICcuLi9jb3JlL1RlbXBOb2RlLmpzJztcclxuaW1wb3J0IHsgbm9kZVByb3h5LCB2ZWM0LCBtYXQyLCBtYXQ0IH0gZnJvbSAnLi4vdHNsL1RTTEJhc2UuanMnO1xyXG5pbXBvcnQgeyBjb3MsIHNpbiB9IGZyb20gJy4uL21hdGgvTWF0aE5vZGUuanMnO1xyXG5cclxuLyoqIEBtb2R1bGUgUm90YXRlTm9kZSAqKi9cclxuXHJcbi8qKlxyXG4gKiBBcHBsaWVzIGEgcm90YXRpb24gdG8gdGhlIGdpdmVuIHBvc2l0aW9uIG5vZGUuXHJcbiAqXHJcbiAqIEBhdWdtZW50cyBUZW1wTm9kZVxyXG4gKi9cclxuY2xhc3MgUm90YXRlTm9kZSBleHRlbmRzIFRlbXBOb2RlIHtcclxuXHJcblx0c3RhdGljIGdldCB0eXBlKCkge1xyXG5cclxuXHRcdHJldHVybiAnUm90YXRlTm9kZSc7XHJcblxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogQ29uc3RydWN0cyBhIG5ldyByb3RhdGUgbm9kZS5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7Tm9kZX0gcG9zaXRpb25Ob2RlIC0gVGhlIHBvc2l0aW9uIG5vZGUuXHJcblx0ICogQHBhcmFtIHtOb2RlfSByb3RhdGlvbk5vZGUgLSBSZXByZXNlbnRzIHRoZSByb3RhdGlvbiB0aGF0IGlzIGFwcGxpZWQgdG8gdGhlIHBvc2l0aW9uIG5vZGUuIERlcGVuZGluZ1xyXG5cdCAqIG9uIHdoZXRoZXIgdGhlIHBvc2l0aW9uIGRhdGEgYXJlIDJEIG9yIDNELCB0aGUgcm90YXRpb24gaXMgZXhwcmVzc2VkIGEgc2luZ2xlIGZsb2F0IHZhbHVlIG9yIGFuIEV1bGVyIHZhbHVlLlxyXG5cdCAqL1xyXG5cdGNvbnN0cnVjdG9yKCBwb3NpdGlvbk5vZGUsIHJvdGF0aW9uTm9kZSApIHtcclxuXHJcblx0XHRzdXBlcigpO1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogVGhlIHBvc2l0aW9uIG5vZGUuXHJcblx0XHQgKlxyXG5cdFx0ICogQHR5cGUge05vZGV9XHJcblx0XHQgKi9cclxuXHRcdHRoaXMucG9zaXRpb25Ob2RlID0gcG9zaXRpb25Ob2RlO1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogIFJlcHJlc2VudHMgdGhlIHJvdGF0aW9uIHRoYXQgaXMgYXBwbGllZCB0byB0aGUgcG9zaXRpb24gbm9kZS5cclxuXHRcdCAqICBEZXBlbmRpbmcgb24gd2hldGhlciB0aGUgcG9zaXRpb24gZGF0YSBhcmUgMkQgb3IgM0QsIHRoZSByb3RhdGlvbiBpcyBleHByZXNzZWQgYSBzaW5nbGUgZmxvYXQgdmFsdWUgb3IgYW4gRXVsZXIgdmFsdWUuXHJcblx0XHQgKlxyXG5cdFx0ICogQHR5cGUge05vZGV9XHJcblx0XHQgKi9cclxuXHRcdHRoaXMucm90YXRpb25Ob2RlID0gcm90YXRpb25Ob2RlO1xyXG5cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFRoZSB0eXBlIG9mIHRoZSB7QGxpbmsgUm90YXRlTm9kZSNwb3NpdGlvbk5vZGV9IGRlZmluZXMgdGhlIG5vZGUncyB0eXBlLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtOb2RlQnVpbGRlcn0gYnVpbGRlciAtIFRoZSBjdXJyZW50IG5vZGUgYnVpbGRlci5cclxuXHQgKiBAcmV0dXJuIHtTdHJpbmd9IFRoZSBub2RlJ3MgdHlwZS5cclxuXHQgKi9cclxuXHRnZXROb2RlVHlwZSggYnVpbGRlciApIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5wb3NpdGlvbk5vZGUuZ2V0Tm9kZVR5cGUoIGJ1aWxkZXIgKTtcclxuXHJcblx0fVxyXG5cclxuXHRzZXR1cCggYnVpbGRlciApIHtcclxuXHJcblx0XHRjb25zdCB7IHJvdGF0aW9uTm9kZSwgcG9zaXRpb25Ob2RlIH0gPSB0aGlzO1xyXG5cclxuXHRcdGNvbnN0IG5vZGVUeXBlID0gdGhpcy5nZXROb2RlVHlwZSggYnVpbGRlciApO1xyXG5cclxuXHRcdGlmICggbm9kZVR5cGUgPT09ICd2ZWMyJyApIHtcclxuXHJcblx0XHRcdGNvbnN0IGNvc0FuZ2xlID0gcm90YXRpb25Ob2RlLmNvcygpO1xyXG5cdFx0XHRjb25zdCBzaW5BbmdsZSA9IHJvdGF0aW9uTm9kZS5zaW4oKTtcclxuXHJcblx0XHRcdGNvbnN0IHJvdGF0aW9uTWF0cml4ID0gbWF0MihcclxuXHRcdFx0XHRjb3NBbmdsZSwgc2luQW5nbGUsXHJcblx0XHRcdFx0c2luQW5nbGUubmVnYXRlKCksIGNvc0FuZ2xlXHJcblx0XHRcdCk7XHJcblxyXG5cdFx0XHRyZXR1cm4gcm90YXRpb25NYXRyaXgubXVsKCBwb3NpdGlvbk5vZGUgKTtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0Y29uc3Qgcm90YXRpb24gPSByb3RhdGlvbk5vZGU7XHJcblx0XHRcdGNvbnN0IHJvdGF0aW9uWE1hdHJpeCA9IG1hdDQoIHZlYzQoIDEuMCwgMC4wLCAwLjAsIDAuMCApLCB2ZWM0KCAwLjAsIGNvcyggcm90YXRpb24ueCApLCBzaW4oIHJvdGF0aW9uLnggKS5uZWdhdGUoKSwgMC4wICksIHZlYzQoIDAuMCwgc2luKCByb3RhdGlvbi54ICksIGNvcyggcm90YXRpb24ueCApLCAwLjAgKSwgdmVjNCggMC4wLCAwLjAsIDAuMCwgMS4wICkgKTtcclxuXHRcdFx0Y29uc3Qgcm90YXRpb25ZTWF0cml4ID0gbWF0NCggdmVjNCggY29zKCByb3RhdGlvbi55ICksIDAuMCwgc2luKCByb3RhdGlvbi55ICksIDAuMCApLCB2ZWM0KCAwLjAsIDEuMCwgMC4wLCAwLjAgKSwgdmVjNCggc2luKCByb3RhdGlvbi55ICkubmVnYXRlKCksIDAuMCwgY29zKCByb3RhdGlvbi55ICksIDAuMCApLCB2ZWM0KCAwLjAsIDAuMCwgMC4wLCAxLjAgKSApO1xyXG5cdFx0XHRjb25zdCByb3RhdGlvblpNYXRyaXggPSBtYXQ0KCB2ZWM0KCBjb3MoIHJvdGF0aW9uLnogKSwgc2luKCByb3RhdGlvbi56ICkubmVnYXRlKCksIDAuMCwgMC4wICksIHZlYzQoIHNpbiggcm90YXRpb24ueiApLCBjb3MoIHJvdGF0aW9uLnogKSwgMC4wLCAwLjAgKSwgdmVjNCggMC4wLCAwLjAsIDEuMCwgMC4wICksIHZlYzQoIDAuMCwgMC4wLCAwLjAsIDEuMCApICk7XHJcblxyXG5cdFx0XHRyZXR1cm4gcm90YXRpb25YTWF0cml4Lm11bCggcm90YXRpb25ZTWF0cml4ICkubXVsKCByb3RhdGlvblpNYXRyaXggKS5tdWwoIHZlYzQoIHBvc2l0aW9uTm9kZSwgMS4wICkgKS54eXo7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBSb3RhdGVOb2RlO1xyXG5cclxuLyoqXHJcbiAqIFRTTCBmdW5jdGlvbiBmb3IgY3JlYXRpbmcgYSByb3RhdGUgbm9kZS5cclxuICpcclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7Tm9kZX0gcG9zaXRpb25Ob2RlIC0gVGhlIHBvc2l0aW9uIG5vZGUuXHJcbiAqIEBwYXJhbSB7Tm9kZX0gcm90YXRpb25Ob2RlIC0gUmVwcmVzZW50cyB0aGUgcm90YXRpb24gdGhhdCBpcyBhcHBsaWVkIHRvIHRoZSBwb3NpdGlvbiBub2RlLiBEZXBlbmRpbmdcclxuICogb24gd2hldGhlciB0aGUgcG9zaXRpb24gZGF0YSBhcmUgMkQgb3IgM0QsIHRoZSByb3RhdGlvbiBpcyBleHByZXNzZWQgYSBzaW5nbGUgZmxvYXQgdmFsdWUgb3IgYW4gRXVsZXIgdmFsdWUuXHJcbiAqIEByZXR1cm5zIHtSb3RhdGVOb2RlfVxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IHJvdGF0ZSA9IC8qQF9fUFVSRV9fKi8gbm9kZVByb3h5KCBSb3RhdGVOb2RlICk7XHJcbiIsImltcG9ydCBOb2RlTWF0ZXJpYWwgZnJvbSAnLi9Ob2RlTWF0ZXJpYWwuanMnO1xyXG5pbXBvcnQgeyBjYW1lcmFQcm9qZWN0aW9uTWF0cml4IH0gZnJvbSAnLi4vLi4vbm9kZXMvYWNjZXNzb3JzL0NhbWVyYS5qcyc7XHJcbmltcG9ydCB7IG1hdGVyaWFsUm90YXRpb24gfSBmcm9tICcuLi8uLi9ub2Rlcy9hY2Nlc3NvcnMvTWF0ZXJpYWxOb2RlLmpzJztcclxuaW1wb3J0IHsgbW9kZWxWaWV3TWF0cml4LCBtb2RlbFdvcmxkTWF0cml4IH0gZnJvbSAnLi4vLi4vbm9kZXMvYWNjZXNzb3JzL01vZGVsTm9kZS5qcyc7XHJcbmltcG9ydCB7IHBvc2l0aW9uR2VvbWV0cnksIHBvc2l0aW9uTG9jYWwgfSBmcm9tICcuLi8uLi9ub2Rlcy9hY2Nlc3NvcnMvUG9zaXRpb24uanMnO1xyXG5pbXBvcnQgeyByb3RhdGUgfSBmcm9tICcuLi8uLi9ub2Rlcy91dGlscy9Sb3RhdGVOb2RlLmpzJztcclxuaW1wb3J0IHsgZmxvYXQsIHZlYzIsIHZlYzQgfSBmcm9tICcuLi8uLi9ub2Rlcy90c2wvVFNMQmFzZS5qcyc7XHJcblxyXG5pbXBvcnQgeyBTcHJpdGVNYXRlcmlhbCB9IGZyb20gJy4uL1Nwcml0ZU1hdGVyaWFsLmpzJztcclxuaW1wb3J0IHsgcmVmZXJlbmNlIH0gZnJvbSAnLi4vLi4vbm9kZXMvYWNjZXNzb3JzL1JlZmVyZW5jZUJhc2VOb2RlLmpzJztcclxuXHJcbmNvbnN0IF9kZWZhdWx0VmFsdWVzID0gLypAX19QVVJFX18qLyBuZXcgU3ByaXRlTWF0ZXJpYWwoKTtcclxuXHJcbmNsYXNzIFNwcml0ZU5vZGVNYXRlcmlhbCBleHRlbmRzIE5vZGVNYXRlcmlhbCB7XHJcblxyXG5cdHN0YXRpYyBnZXQgdHlwZSgpIHtcclxuXHJcblx0XHRyZXR1cm4gJ1Nwcml0ZU5vZGVNYXRlcmlhbCc7XHJcblxyXG5cdH1cclxuXHJcblx0Y29uc3RydWN0b3IoIHBhcmFtZXRlcnMgKSB7XHJcblxyXG5cdFx0c3VwZXIoKTtcclxuXHJcblx0XHR0aGlzLmlzU3ByaXRlTm9kZU1hdGVyaWFsID0gdHJ1ZTtcclxuXHJcblx0XHR0aGlzLmxpZ2h0cyA9IGZhbHNlO1xyXG5cdFx0dGhpcy5fdXNlU2l6ZUF0dGVudWF0aW9uID0gdHJ1ZTtcclxuXHJcblx0XHR0aGlzLnBvc2l0aW9uTm9kZSA9IG51bGw7XHJcblx0XHR0aGlzLnJvdGF0aW9uTm9kZSA9IG51bGw7XHJcblx0XHR0aGlzLnNjYWxlTm9kZSA9IG51bGw7XHJcblxyXG5cdFx0dGhpcy5zZXREZWZhdWx0VmFsdWVzKCBfZGVmYXVsdFZhbHVlcyApO1xyXG5cclxuXHRcdHRoaXMuc2V0VmFsdWVzKCBwYXJhbWV0ZXJzICk7XHJcblxyXG5cdH1cclxuXHJcblx0c2V0dXBQb3NpdGlvblZpZXcoIGJ1aWxkZXIgKSB7XHJcblxyXG5cdFx0Y29uc3QgeyBvYmplY3QsIGNhbWVyYSB9ID0gYnVpbGRlcjtcclxuXHJcblx0XHRjb25zdCBzaXplQXR0ZW51YXRpb24gPSB0aGlzLnNpemVBdHRlbnVhdGlvbjtcclxuXHJcblx0XHQvLyA8IFZFUlRFWCBTVEFHRSA+XHJcblxyXG5cdFx0Y29uc3QgeyByb3RhdGlvbk5vZGUsIHNjYWxlTm9kZSB9ID0gdGhpcztcclxuXHJcblx0XHRjb25zdCBtdlBvc2l0aW9uID0gbW9kZWxWaWV3TWF0cml4Lm11bCggcG9zaXRpb25Mb2NhbCApO1xyXG5cclxuXHRcdGxldCBzY2FsZSA9IHZlYzIoIG1vZGVsV29ybGRNYXRyaXhbIDAgXS54eXoubGVuZ3RoKCksIG1vZGVsV29ybGRNYXRyaXhbIDEgXS54eXoubGVuZ3RoKCkgKTtcclxuXHJcblx0XHRpZiAoIHNjYWxlTm9kZSAhPT0gbnVsbCApIHtcclxuXHJcblx0XHRcdHNjYWxlID0gc2NhbGUubXVsKCBzY2FsZU5vZGUgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cclxuXHRcdGlmICggISBzaXplQXR0ZW51YXRpb24gKSB7XHJcblxyXG5cdFx0XHRpZiAoIGNhbWVyYS5pc1BlcnNwZWN0aXZlQ2FtZXJhICkge1xyXG5cclxuXHRcdFx0XHRzY2FsZSA9IHNjYWxlLm11bCggbXZQb3NpdGlvbi56Lm5lZ2F0ZSgpICk7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRjb25zdCBvcnRob1NjYWxlID0gZmxvYXQoIDIuMCApLmRpdiggY2FtZXJhUHJvamVjdGlvbk1hdHJpeC5lbGVtZW50KCAxICkuZWxlbWVudCggMSApICk7XHJcblx0XHRcdFx0c2NhbGUgPSBzY2FsZS5tdWwoIG9ydGhvU2NhbGUubXVsKCAyICkgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0bGV0IGFsaWduZWRQb3NpdGlvbiA9IHBvc2l0aW9uR2VvbWV0cnkueHk7XHJcblxyXG5cdFx0aWYgKCBvYmplY3QuY2VudGVyICYmIG9iamVjdC5jZW50ZXIuaXNWZWN0b3IyID09PSB0cnVlICkge1xyXG5cclxuXHRcdFx0Y29uc3QgY2VudGVyID0gcmVmZXJlbmNlKCAnY2VudGVyJywgJ3ZlYzInICk7XHJcblxyXG5cdFx0XHRhbGlnbmVkUG9zaXRpb24gPSBhbGlnbmVkUG9zaXRpb24uc3ViKCBjZW50ZXIuc3ViKCAwLjUgKSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRhbGlnbmVkUG9zaXRpb24gPSBhbGlnbmVkUG9zaXRpb24ubXVsKCBzY2FsZSApO1xyXG5cclxuXHRcdGNvbnN0IHJvdGF0aW9uID0gZmxvYXQoIHJvdGF0aW9uTm9kZSB8fCBtYXRlcmlhbFJvdGF0aW9uICk7XHJcblxyXG5cdFx0Y29uc3Qgcm90YXRlZFBvc2l0aW9uID0gcm90YXRlKCBhbGlnbmVkUG9zaXRpb24sIHJvdGF0aW9uICk7XHJcblxyXG5cdFx0cmV0dXJuIHZlYzQoIG12UG9zaXRpb24ueHkuYWRkKCByb3RhdGVkUG9zaXRpb24gKSwgbXZQb3NpdGlvbi56dyApO1xyXG5cclxuXHR9XHJcblxyXG5cdGNvcHkoIHNvdXJjZSApIHtcclxuXHJcblx0XHR0aGlzLnBvc2l0aW9uTm9kZSA9IHNvdXJjZS5wb3NpdGlvbk5vZGU7XHJcblx0XHR0aGlzLnJvdGF0aW9uTm9kZSA9IHNvdXJjZS5yb3RhdGlvbk5vZGU7XHJcblx0XHR0aGlzLnNjYWxlTm9kZSA9IHNvdXJjZS5zY2FsZU5vZGU7XHJcblxyXG5cdFx0cmV0dXJuIHN1cGVyLmNvcHkoIHNvdXJjZSApO1xyXG5cclxuXHR9XHJcblxyXG5cdGdldCBzaXplQXR0ZW51YXRpb24oKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuX3VzZVNpemVBdHRlbnVhdGlvbjtcclxuXHJcblx0fVxyXG5cclxuXHRzZXQgc2l6ZUF0dGVudWF0aW9uKCB2YWx1ZSApIHtcclxuXHJcblx0XHRpZiAoIHRoaXMuX3VzZVNpemVBdHRlbnVhdGlvbiAhPT0gdmFsdWUgKSB7XHJcblxyXG5cdFx0XHR0aGlzLl91c2VTaXplQXR0ZW51YXRpb24gPSB2YWx1ZTtcclxuXHRcdFx0dGhpcy5uZWVkc1VwZGF0ZSA9IHRydWU7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBTcHJpdGVOb2RlTWF0ZXJpYWw7XHJcbiIsImltcG9ydCBMaWdodGluZ01vZGVsIGZyb20gJy4uL2NvcmUvTGlnaHRpbmdNb2RlbC5qcyc7XHJcbmltcG9ydCB7IGRpZmZ1c2VDb2xvciB9IGZyb20gJy4uL2NvcmUvUHJvcGVydHlOb2RlLmpzJztcclxuaW1wb3J0IHsgZmxvYXQgfSBmcm9tICcuLi90c2wvVFNMQmFzZS5qcyc7XHJcblxyXG4vKipcclxuICogUmVwcmVzZW50cyBsaWdodGluZyBtb2RlbCBmb3IgYSBzaGFkb3cgbWF0ZXJpYWwuIFVzZWQgaW4ge0BsaW5rIFNoYWRvd05vZGVNYXRlcmlhbH0uXHJcbiAqXHJcbiAqIEBhdWdtZW50cyBMaWdodGluZ01vZGVsXHJcbiAqL1xyXG5jbGFzcyBTaGFkb3dNYXNrTW9kZWwgZXh0ZW5kcyBMaWdodGluZ01vZGVsIHtcclxuXHJcblx0LyoqXHJcblx0ICogQ29uc3RydWN0cyBhIG5ldyBzaGFkb3cgbWFzayBtb2RlbC5cclxuXHQgKi9cclxuXHRjb25zdHJ1Y3RvcigpIHtcclxuXHJcblx0XHRzdXBlcigpO1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogVGhlIHNoYWRvdyBtYXNrIG5vZGUuXHJcblx0XHQgKlxyXG5cdFx0ICogQHR5cGUge05vZGV9XHJcblx0XHQgKi9cclxuXHRcdHRoaXMuc2hhZG93Tm9kZSA9IGZsb2F0KCAxICkudG9WYXIoICdzaGFkb3dNYXNrJyApO1xyXG5cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIE9ubHkgdXNlZCB0byBzYXZlIHRoZSBzaGFkb3cgbWFzay5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dCAtIFRoZSBpbnB1dCBkYXRhLlxyXG5cdCAqL1xyXG5cdGRpcmVjdCggeyBzaGFkb3dNYXNrIH0gKSB7XHJcblxyXG5cdFx0dGhpcy5zaGFkb3dOb2RlLm11bEFzc2lnbiggc2hhZG93TWFzayApO1xyXG5cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFVzZXMgdGhlIHNoYWRvdyBtYXNrIHRvIHByb2R1Y2UgdGhlIGZpbmFsIGNvbG9yLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtDb250ZXh0Tm9kZX0gY29udGV4dCAtIFRoZSBjdXJyZW50IG5vZGUgY29udGV4dC5cclxuXHQgKi9cclxuXHRmaW5pc2goIGNvbnRleHQgKSB7XHJcblxyXG5cdFx0ZGlmZnVzZUNvbG9yLmEubXVsQXNzaWduKCB0aGlzLnNoYWRvd05vZGUub25lTWludXMoKSApO1xyXG5cclxuXHRcdGNvbnRleHQub3V0Z29pbmdMaWdodC5yZ2IuYXNzaWduKCBkaWZmdXNlQ29sb3IucmdiICk7IC8vIFRPRE86IE9wdGltaXplIExpZ2h0c05vZGUgdG8gYXZvaWQgdGhpcyBhc3NpZ25tZW50XHJcblxyXG5cdH1cclxuXHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IFNoYWRvd01hc2tNb2RlbDtcclxuIiwiaW1wb3J0IE5vZGVNYXRlcmlhbCBmcm9tICcuL05vZGVNYXRlcmlhbC5qcyc7XHJcbmltcG9ydCBTaGFkb3dNYXNrTW9kZWwgZnJvbSAnLi4vLi4vbm9kZXMvZnVuY3Rpb25zL1NoYWRvd01hc2tNb2RlbC5qcyc7XHJcblxyXG5pbXBvcnQgeyBTaGFkb3dNYXRlcmlhbCB9IGZyb20gJy4uL1NoYWRvd01hdGVyaWFsLmpzJztcclxuXHJcbmNvbnN0IF9kZWZhdWx0VmFsdWVzID0gLypAX19QVVJFX18qLyBuZXcgU2hhZG93TWF0ZXJpYWwoKTtcclxuXHJcbmNsYXNzIFNoYWRvd05vZGVNYXRlcmlhbCBleHRlbmRzIE5vZGVNYXRlcmlhbCB7XHJcblxyXG5cdHN0YXRpYyBnZXQgdHlwZSgpIHtcclxuXHJcblx0XHRyZXR1cm4gJ1NoYWRvd05vZGVNYXRlcmlhbCc7XHJcblxyXG5cdH1cclxuXHJcblx0Y29uc3RydWN0b3IoIHBhcmFtZXRlcnMgKSB7XHJcblxyXG5cdFx0c3VwZXIoKTtcclxuXHJcblx0XHR0aGlzLmlzU2hhZG93Tm9kZU1hdGVyaWFsID0gdHJ1ZTtcclxuXHJcblx0XHR0aGlzLmxpZ2h0cyA9IHRydWU7XHJcblxyXG5cdFx0dGhpcy5zZXREZWZhdWx0VmFsdWVzKCBfZGVmYXVsdFZhbHVlcyApO1xyXG5cclxuXHRcdHRoaXMuc2V0VmFsdWVzKCBwYXJhbWV0ZXJzICk7XHJcblxyXG5cdH1cclxuXHJcblx0c2V0dXBMaWdodGluZ01vZGVsKCAvKmJ1aWxkZXIqLyApIHtcclxuXHJcblx0XHRyZXR1cm4gbmV3IFNoYWRvd01hc2tNb2RlbCgpO1xyXG5cclxuXHR9XHJcblxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBTaGFkb3dOb2RlTWF0ZXJpYWw7XHJcbiIsImltcG9ydCBUZXh0dXJlTm9kZSBmcm9tICcuL1RleHR1cmVOb2RlLmpzJztcclxuaW1wb3J0IHsgbm9kZVByb3h5LCB2ZWMzLCBGbiwgSWYgfSBmcm9tICcuLi90c2wvVFNMQmFzZS5qcyc7XHJcblxyXG5jb25zdCBub3JtYWwgPSBGbiggKCB7IHRleHR1cmUsIHV2IH0gKSA9PiB7XHJcblxyXG5cdGNvbnN0IGVwc2lsb24gPSAwLjAwMDE7XHJcblxyXG5cdGNvbnN0IHJldCA9IHZlYzMoKS50b1ZhcigpO1xyXG5cclxuXHRJZiggdXYueC5sZXNzVGhhbiggZXBzaWxvbiApLCAoKSA9PiB7XHJcblxyXG5cdFx0cmV0LmFzc2lnbiggdmVjMyggMSwgMCwgMCApICk7XHJcblxyXG5cdH0gKS5FbHNlSWYoIHV2LnkubGVzc1RoYW4oIGVwc2lsb24gKSwgKCkgPT4ge1xyXG5cclxuXHRcdHJldC5hc3NpZ24oIHZlYzMoIDAsIDEsIDAgKSApO1xyXG5cclxuXHR9ICkuRWxzZUlmKCB1di56Lmxlc3NUaGFuKCBlcHNpbG9uICksICgpID0+IHtcclxuXHJcblx0XHRyZXQuYXNzaWduKCB2ZWMzKCAwLCAwLCAxICkgKTtcclxuXHJcblx0fSApLkVsc2VJZiggdXYueC5ncmVhdGVyVGhhbiggMSAtIGVwc2lsb24gKSwgKCkgPT4ge1xyXG5cclxuXHRcdHJldC5hc3NpZ24oIHZlYzMoIC0gMSwgMCwgMCApICk7XHJcblxyXG5cdH0gKS5FbHNlSWYoIHV2LnkuZ3JlYXRlclRoYW4oIDEgLSBlcHNpbG9uICksICgpID0+IHtcclxuXHJcblx0XHRyZXQuYXNzaWduKCB2ZWMzKCAwLCAtIDEsIDAgKSApO1xyXG5cclxuXHR9ICkuRWxzZUlmKCB1di56LmdyZWF0ZXJUaGFuKCAxIC0gZXBzaWxvbiApLCAoKSA9PiB7XHJcblxyXG5cdFx0cmV0LmFzc2lnbiggdmVjMyggMCwgMCwgLSAxICkgKTtcclxuXHJcblx0fSApLkVsc2UoICgpID0+IHtcclxuXHJcblx0XHRjb25zdCBzdGVwID0gMC4wMTtcclxuXHJcblx0XHRjb25zdCB4ID0gdGV4dHVyZS5zYW1wbGUoIHV2LmFkZCggdmVjMyggLSBzdGVwLCAwLjAsIDAuMCApICkgKS5yLnN1YiggdGV4dHVyZS5zYW1wbGUoIHV2LmFkZCggdmVjMyggc3RlcCwgMC4wLCAwLjAgKSApICkuciApO1xyXG5cdFx0Y29uc3QgeSA9IHRleHR1cmUuc2FtcGxlKCB1di5hZGQoIHZlYzMoIDAuMCwgLSBzdGVwLCAwLjAgKSApICkuci5zdWIoIHRleHR1cmUuc2FtcGxlKCB1di5hZGQoIHZlYzMoIDAuMCwgc3RlcCwgMC4wICkgKSApLnIgKTtcclxuXHRcdGNvbnN0IHogPSB0ZXh0dXJlLnNhbXBsZSggdXYuYWRkKCB2ZWMzKCAwLjAsIDAuMCwgLSBzdGVwICkgKSApLnIuc3ViKCB0ZXh0dXJlLnNhbXBsZSggdXYuYWRkKCB2ZWMzKCAwLjAsIDAuMCwgc3RlcCApICkgKS5yICk7XHJcblxyXG5cdFx0cmV0LmFzc2lnbiggdmVjMyggeCwgeSwgeiApICk7XHJcblxyXG5cdH0gKTtcclxuXHJcblx0cmV0dXJuIHJldC5ub3JtYWxpemUoKTtcclxuXHJcbn0gKTtcclxuXHJcblxyXG5jbGFzcyBUZXh0dXJlM0ROb2RlIGV4dGVuZHMgVGV4dHVyZU5vZGUge1xyXG5cclxuXHRzdGF0aWMgZ2V0IHR5cGUoKSB7XHJcblxyXG5cdFx0cmV0dXJuICdUZXh0dXJlM0ROb2RlJztcclxuXHJcblx0fVxyXG5cclxuXHRjb25zdHJ1Y3RvciggdmFsdWUsIHV2Tm9kZSA9IG51bGwsIGxldmVsTm9kZSA9IG51bGwgKSB7XHJcblxyXG5cdFx0c3VwZXIoIHZhbHVlLCB1dk5vZGUsIGxldmVsTm9kZSApO1xyXG5cclxuXHRcdHRoaXMuaXNUZXh0dXJlM0ROb2RlID0gdHJ1ZTtcclxuXHJcblx0fVxyXG5cclxuXHRnZXRJbnB1dFR5cGUoIC8qYnVpbGRlciovICkge1xyXG5cclxuXHRcdHJldHVybiAndGV4dHVyZTNEJztcclxuXHJcblx0fVxyXG5cclxuXHRnZXREZWZhdWx0VVYoKSB7XHJcblxyXG5cdFx0cmV0dXJuIHZlYzMoIDAuNSwgMC41LCAwLjUgKTtcclxuXHJcblx0fVxyXG5cclxuXHRzZXRVcGRhdGVNYXRyaXgoIC8qdXBkYXRlTWF0cml4Ki8gKSB7IH0gLy8gSWdub3JlIC51cGRhdGVNYXRyaXggZm9yIDNkIFRleHR1cmVOb2RlXHJcblxyXG5cdHNldHVwVVYoIGJ1aWxkZXIsIHV2Tm9kZSApIHtcclxuXHJcblx0XHRyZXR1cm4gdXZOb2RlO1xyXG5cclxuXHR9XHJcblxyXG5cdGdlbmVyYXRlVVYoIGJ1aWxkZXIsIHV2Tm9kZSApIHtcclxuXHJcblx0XHRyZXR1cm4gdXZOb2RlLmJ1aWxkKCBidWlsZGVyLCAndmVjMycgKTtcclxuXHJcblx0fVxyXG5cclxuXHRub3JtYWwoIHV2Tm9kZSApIHtcclxuXHJcblx0XHRyZXR1cm4gbm9ybWFsKCB7IHRleHR1cmU6IHRoaXMsIHV2OiB1dk5vZGUgfSApO1xyXG5cclxuXHR9XHJcblxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBUZXh0dXJlM0ROb2RlO1xyXG5cclxuZXhwb3J0IGNvbnN0IHRleHR1cmUzRCA9IC8qQF9fUFVSRV9fKi8gbm9kZVByb3h5KCBUZXh0dXJlM0ROb2RlICk7XHJcbiIsImltcG9ydCBOb2RlTWF0ZXJpYWwgZnJvbSAnLi9Ob2RlTWF0ZXJpYWwuanMnO1xyXG5pbXBvcnQgeyBwcm9wZXJ0eSB9IGZyb20gJy4uLy4uL25vZGVzL2NvcmUvUHJvcGVydHlOb2RlLmpzJztcclxuaW1wb3J0IHsgbWF0ZXJpYWxSZWZlcmVuY2UgfSBmcm9tICcuLi8uLi9ub2Rlcy9hY2Nlc3NvcnMvTWF0ZXJpYWxSZWZlcmVuY2VOb2RlLmpzJztcclxuaW1wb3J0IHsgbW9kZWxXb3JsZE1hdHJpeEludmVyc2UgfSBmcm9tICcuLi8uLi9ub2Rlcy9hY2Nlc3NvcnMvTW9kZWxOb2RlLmpzJztcclxuaW1wb3J0IHsgY2FtZXJhUG9zaXRpb24gfSBmcm9tICcuLi8uLi9ub2Rlcy9hY2Nlc3NvcnMvQ2FtZXJhLmpzJztcclxuaW1wb3J0IHsgcG9zaXRpb25HZW9tZXRyeSB9IGZyb20gJy4uLy4uL25vZGVzL2FjY2Vzc29ycy9Qb3NpdGlvbi5qcyc7XHJcbmltcG9ydCB7IEZuLCB2YXJ5aW5nLCBmbG9hdCwgdmVjMiwgdmVjMywgdmVjNCB9IGZyb20gJy4uLy4uL25vZGVzL3RzbC9UU0xCYXNlLmpzJztcclxuaW1wb3J0IHsgbWluLCBtYXggfSBmcm9tICcuLi8uLi9ub2Rlcy9tYXRoL01hdGhOb2RlLmpzJztcclxuaW1wb3J0IHsgTG9vcCwgQnJlYWsgfSBmcm9tICcuLi8uLi9ub2Rlcy91dGlscy9Mb29wTm9kZS5qcyc7XHJcbmltcG9ydCB7IHRleHR1cmUzRCB9IGZyb20gJy4uLy4uL25vZGVzL2FjY2Vzc29ycy9UZXh0dXJlM0ROb2RlLmpzJztcclxuXHJcbmNsYXNzIFZvbHVtZU5vZGVNYXRlcmlhbCBleHRlbmRzIE5vZGVNYXRlcmlhbCB7XHJcblxyXG5cdHN0YXRpYyBnZXQgdHlwZSgpIHtcclxuXHJcblx0XHRyZXR1cm4gJ1ZvbHVtZU5vZGVNYXRlcmlhbCc7XHJcblxyXG5cdH1cclxuXHJcblx0Y29uc3RydWN0b3IoIHBhcmFtcyA9IHt9ICkge1xyXG5cclxuXHRcdHN1cGVyKCk7XHJcblxyXG5cdFx0dGhpcy5saWdodHMgPSBmYWxzZTtcclxuXHRcdHRoaXMuaXNWb2x1bWVOb2RlTWF0ZXJpYWwgPSB0cnVlO1xyXG5cdFx0dGhpcy50ZXN0Tm9kZSA9IG51bGw7XHJcblxyXG5cdFx0dGhpcy5zZXRWYWx1ZXMoIHBhcmFtcyApO1xyXG5cclxuXHR9XHJcblxyXG5cdHNldHVwKCBidWlsZGVyICkge1xyXG5cclxuXHRcdGNvbnN0IG1hcCA9IHRleHR1cmUzRCggdGhpcy5tYXAsIG51bGwsIDAgKTtcclxuXHJcblx0XHRjb25zdCBoaXRCb3ggPSBGbiggKCB7IG9yaWcsIGRpciB9ICkgPT4ge1xyXG5cclxuXHRcdFx0Y29uc3QgYm94X21pbiA9IHZlYzMoIC0gMC41ICk7XHJcblx0XHRcdGNvbnN0IGJveF9tYXggPSB2ZWMzKCAwLjUgKTtcclxuXHJcblx0XHRcdGNvbnN0IGludl9kaXIgPSBkaXIucmVjaXByb2NhbCgpO1xyXG5cclxuXHRcdFx0Y29uc3QgdG1pbl90bXAgPSBib3hfbWluLnN1Yiggb3JpZyApLm11bCggaW52X2RpciApO1xyXG5cdFx0XHRjb25zdCB0bWF4X3RtcCA9IGJveF9tYXguc3ViKCBvcmlnICkubXVsKCBpbnZfZGlyICk7XHJcblxyXG5cdFx0XHRjb25zdCB0bWluID0gbWluKCB0bWluX3RtcCwgdG1heF90bXAgKTtcclxuXHRcdFx0Y29uc3QgdG1heCA9IG1heCggdG1pbl90bXAsIHRtYXhfdG1wICk7XHJcblxyXG5cdFx0XHRjb25zdCB0MCA9IG1heCggdG1pbi54LCBtYXgoIHRtaW4ueSwgdG1pbi56ICkgKTtcclxuXHRcdFx0Y29uc3QgdDEgPSBtaW4oIHRtYXgueCwgbWluKCB0bWF4LnksIHRtYXgueiApICk7XHJcblxyXG5cdFx0XHRyZXR1cm4gdmVjMiggdDAsIHQxICk7XHJcblxyXG5cdFx0fSApO1xyXG5cclxuXHRcdHRoaXMuZnJhZ21lbnROb2RlID0gRm4oICgpID0+IHtcclxuXHJcblx0XHRcdGNvbnN0IHZPcmlnaW4gPSB2YXJ5aW5nKCB2ZWMzKCBtb2RlbFdvcmxkTWF0cml4SW52ZXJzZS5tdWwoIHZlYzQoIGNhbWVyYVBvc2l0aW9uLCAxLjAgKSApICkgKTtcclxuXHRcdFx0Y29uc3QgdkRpcmVjdGlvbiA9IHZhcnlpbmcoIHBvc2l0aW9uR2VvbWV0cnkuc3ViKCB2T3JpZ2luICkgKTtcclxuXHJcblx0XHRcdGNvbnN0IHJheURpciA9IHZEaXJlY3Rpb24ubm9ybWFsaXplKCk7XHJcblx0XHRcdGNvbnN0IGJvdW5kcyA9IHZlYzIoIGhpdEJveCggeyBvcmlnOiB2T3JpZ2luLCBkaXI6IHJheURpciB9ICkgKS50b1ZhcigpO1xyXG5cclxuXHRcdFx0Ym91bmRzLnguZ3JlYXRlclRoYW4oIGJvdW5kcy55ICkuZGlzY2FyZCgpO1xyXG5cclxuXHRcdFx0Ym91bmRzLmFzc2lnbiggdmVjMiggbWF4KCBib3VuZHMueCwgMC4wICksIGJvdW5kcy55ICkgKTtcclxuXHJcblx0XHRcdGNvbnN0IHAgPSB2ZWMzKCB2T3JpZ2luLmFkZCggYm91bmRzLngubXVsKCByYXlEaXIgKSApICkudG9WYXIoKTtcclxuXHRcdFx0Y29uc3QgaW5jID0gdmVjMyggcmF5RGlyLmFicygpLnJlY2lwcm9jYWwoKSApLnRvVmFyKCk7XHJcblx0XHRcdGNvbnN0IGRlbHRhID0gZmxvYXQoIG1pbiggaW5jLngsIG1pbiggaW5jLnksIGluYy56ICkgKSApLnRvVmFyKCAnZGVsdGEnICk7IC8vIHVzZWQgJ2RlbHRhJyBuYW1lIGluIGxvb3BcclxuXHJcblx0XHRcdGRlbHRhLmRpdkFzc2lnbiggbWF0ZXJpYWxSZWZlcmVuY2UoICdzdGVwcycsICdmbG9hdCcgKSApO1xyXG5cclxuXHRcdFx0Y29uc3QgYWMgPSB2ZWM0KCBtYXRlcmlhbFJlZmVyZW5jZSggJ2Jhc2UnLCAnY29sb3InICksIDAuMCApLnRvVmFyKCk7XHJcblxyXG5cdFx0XHRMb29wKCB7IHR5cGU6ICdmbG9hdCcsIHN0YXJ0OiBib3VuZHMueCwgZW5kOiBib3VuZHMueSwgdXBkYXRlOiAnKz0gZGVsdGEnIH0sICgpID0+IHtcclxuXHJcblx0XHRcdFx0Y29uc3QgZCA9IHByb3BlcnR5KCAnZmxvYXQnLCAnZCcgKS5hc3NpZ24oIG1hcC5zYW1wbGUoIHAuYWRkKCAwLjUgKSApLnIgKTtcclxuXHJcblx0XHRcdFx0aWYgKCB0aGlzLnRlc3ROb2RlICE9PSBudWxsICkge1xyXG5cclxuXHRcdFx0XHRcdHRoaXMudGVzdE5vZGUoIHsgbWFwOiBtYXAsIG1hcFZhbHVlOiBkLCBwcm9iZTogcCwgZmluYWxDb2xvcjogYWMgfSApLmFwcGVuZCgpO1xyXG5cclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdC8vIGRlZmF1bHQgdG8gc2hvdyBzdXJmYWNlIG9mIG1lc2hcclxuXHRcdFx0XHRcdGFjLmEuYXNzaWduKCAxICk7XHJcblx0XHRcdFx0XHRCcmVhaygpO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHAuYWRkQXNzaWduKCByYXlEaXIubXVsKCBkZWx0YSApICk7XHJcblxyXG5cdFx0XHR9ICk7XHJcblxyXG5cdFx0XHRhYy5hLmVxdWFsKCAwICkuZGlzY2FyZCgpO1xyXG5cclxuXHRcdFx0cmV0dXJuIHZlYzQoIGFjICk7XHJcblxyXG5cdFx0fSApKCk7XHJcblxyXG5cdFx0c3VwZXIuc2V0dXAoIGJ1aWxkZXIgKTtcclxuXHJcblx0fVxyXG5cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgVm9sdW1lTm9kZU1hdGVyaWFsO1xyXG4iLCJjbGFzcyBBbmltYXRpb24ge1xyXG5cclxuXHRjb25zdHJ1Y3Rvciggbm9kZXMsIGluZm8gKSB7XHJcblxyXG5cdFx0dGhpcy5ub2RlcyA9IG5vZGVzO1xyXG5cdFx0dGhpcy5pbmZvID0gaW5mbztcclxuXHJcblx0XHR0aGlzLl9jb250ZXh0ID0gc2VsZjtcclxuXHRcdHRoaXMuX2FuaW1hdGlvbkxvb3AgPSBudWxsO1xyXG5cdFx0dGhpcy5fcmVxdWVzdElkID0gbnVsbDtcclxuXHJcblx0fVxyXG5cclxuXHRzdGFydCgpIHtcclxuXHJcblx0XHRjb25zdCB1cGRhdGUgPSAoIHRpbWUsIGZyYW1lICkgPT4ge1xyXG5cclxuXHRcdFx0dGhpcy5fcmVxdWVzdElkID0gdGhpcy5fY29udGV4dC5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoIHVwZGF0ZSApO1xyXG5cclxuXHRcdFx0aWYgKCB0aGlzLmluZm8uYXV0b1Jlc2V0ID09PSB0cnVlICkgdGhpcy5pbmZvLnJlc2V0KCk7XHJcblxyXG5cdFx0XHR0aGlzLm5vZGVzLm5vZGVGcmFtZS51cGRhdGUoKTtcclxuXHJcblx0XHRcdHRoaXMuaW5mby5mcmFtZSA9IHRoaXMubm9kZXMubm9kZUZyYW1lLmZyYW1lSWQ7XHJcblxyXG5cdFx0XHRpZiAoIHRoaXMuX2FuaW1hdGlvbkxvb3AgIT09IG51bGwgKSB0aGlzLl9hbmltYXRpb25Mb29wKCB0aW1lLCBmcmFtZSApO1xyXG5cclxuXHRcdH07XHJcblxyXG5cdFx0dXBkYXRlKCk7XHJcblxyXG5cdH1cclxuXHJcblx0c3RvcCgpIHtcclxuXHJcblx0XHR0aGlzLl9jb250ZXh0LmNhbmNlbEFuaW1hdGlvbkZyYW1lKCB0aGlzLl9yZXF1ZXN0SWQgKTtcclxuXHJcblx0XHR0aGlzLl9yZXF1ZXN0SWQgPSBudWxsO1xyXG5cclxuXHR9XHJcblxyXG5cdHNldEFuaW1hdGlvbkxvb3AoIGNhbGxiYWNrICkge1xyXG5cclxuXHRcdHRoaXMuX2FuaW1hdGlvbkxvb3AgPSBjYWxsYmFjaztcclxuXHJcblx0fVxyXG5cclxuXHRzZXRDb250ZXh0KCBjb250ZXh0ICkge1xyXG5cclxuXHRcdHRoaXMuX2NvbnRleHQgPSBjb250ZXh0O1xyXG5cclxuXHR9XHJcblxyXG5cdGRpc3Bvc2UoKSB7XHJcblxyXG5cdFx0dGhpcy5zdG9wKCk7XHJcblxyXG5cdH1cclxuXHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IEFuaW1hdGlvbjtcclxuIiwiZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ2hhaW5NYXAge1xyXG5cclxuXHRjb25zdHJ1Y3RvcigpIHtcclxuXHJcblx0XHR0aGlzLndlYWtNYXAgPSBuZXcgV2Vha01hcCgpO1xyXG5cclxuXHR9XHJcblxyXG5cdGdldCgga2V5cyApIHtcclxuXHJcblx0XHRsZXQgbWFwID0gdGhpcy53ZWFrTWFwO1xyXG5cclxuXHRcdGZvciAoIGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpICsrICkge1xyXG5cclxuXHRcdFx0bWFwID0gbWFwLmdldCgga2V5c1sgaSBdICk7XHJcblxyXG5cdFx0XHRpZiAoIG1hcCA9PT0gdW5kZWZpbmVkICkgcmV0dXJuIHVuZGVmaW5lZDtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIG1hcC5nZXQoIGtleXNbIGtleXMubGVuZ3RoIC0gMSBdICk7XHJcblxyXG5cdH1cclxuXHJcblx0c2V0KCBrZXlzLCB2YWx1ZSApIHtcclxuXHJcblx0XHRsZXQgbWFwID0gdGhpcy53ZWFrTWFwO1xyXG5cclxuXHRcdGZvciAoIGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpICsrICkge1xyXG5cclxuXHRcdFx0Y29uc3Qga2V5ID0ga2V5c1sgaSBdO1xyXG5cclxuXHRcdFx0aWYgKCBtYXAuaGFzKCBrZXkgKSA9PT0gZmFsc2UgKSBtYXAuc2V0KCBrZXksIG5ldyBXZWFrTWFwKCkgKTtcclxuXHJcblx0XHRcdG1hcCA9IG1hcC5nZXQoIGtleSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gbWFwLnNldCgga2V5c1sga2V5cy5sZW5ndGggLSAxIF0sIHZhbHVlICk7XHJcblxyXG5cdH1cclxuXHJcblx0ZGVsZXRlKCBrZXlzICkge1xyXG5cclxuXHRcdGxldCBtYXAgPSB0aGlzLndlYWtNYXA7XHJcblxyXG5cdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRtYXAgPSBtYXAuZ2V0KCBrZXlzWyBpIF0gKTtcclxuXHJcblx0XHRcdGlmICggbWFwID09PSB1bmRlZmluZWQgKSByZXR1cm4gZmFsc2U7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBtYXAuZGVsZXRlKCBrZXlzWyBrZXlzLmxlbmd0aCAtIDEgXSApO1xyXG5cclxuXHR9XHJcblxyXG59XHJcbiIsImltcG9ydCB7IGhhc2hTdHJpbmcgfSBmcm9tICcuLi8uLi9ub2Rlcy9jb3JlL05vZGVVdGlscy5qcyc7XHJcblxyXG5sZXQgX2lkID0gMDtcclxuXHJcbmZ1bmN0aW9uIGdldEtleXMoIG9iaiApIHtcclxuXHJcblx0Y29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKCBvYmogKTtcclxuXHJcblx0bGV0IHByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKCBvYmogKTtcclxuXHJcblx0d2hpbGUgKCBwcm90byApIHtcclxuXHJcblx0XHRjb25zdCBkZXNjcmlwdG9ycyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKCBwcm90byApO1xyXG5cclxuXHRcdGZvciAoIGNvbnN0IGtleSBpbiBkZXNjcmlwdG9ycyApIHtcclxuXHJcblx0XHRcdGlmICggZGVzY3JpcHRvcnNbIGtleSBdICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdGNvbnN0IGRlc2NyaXB0b3IgPSBkZXNjcmlwdG9yc1sga2V5IF07XHJcblxyXG5cdFx0XHRcdGlmICggZGVzY3JpcHRvciAmJiB0eXBlb2YgZGVzY3JpcHRvci5nZXQgPT09ICdmdW5jdGlvbicgKSB7XHJcblxyXG5cdFx0XHRcdFx0a2V5cy5wdXNoKCBrZXkgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRwcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZiggcHJvdG8gKTtcclxuXHJcblx0fVxyXG5cclxuXHRyZXR1cm4ga2V5cztcclxuXHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJlbmRlck9iamVjdCB7XHJcblxyXG5cdGNvbnN0cnVjdG9yKCBub2RlcywgZ2VvbWV0cmllcywgcmVuZGVyZXIsIG9iamVjdCwgbWF0ZXJpYWwsIHNjZW5lLCBjYW1lcmEsIGxpZ2h0c05vZGUsIHJlbmRlckNvbnRleHQsIGNsaXBwaW5nQ29udGV4dCApIHtcclxuXHJcblx0XHR0aGlzLl9ub2RlcyA9IG5vZGVzO1xyXG5cdFx0dGhpcy5fZ2VvbWV0cmllcyA9IGdlb21ldHJpZXM7XHJcblxyXG5cdFx0dGhpcy5pZCA9IF9pZCArKztcclxuXHJcblx0XHR0aGlzLnJlbmRlcmVyID0gcmVuZGVyZXI7XHJcblx0XHR0aGlzLm9iamVjdCA9IG9iamVjdDtcclxuXHRcdHRoaXMubWF0ZXJpYWwgPSBtYXRlcmlhbDtcclxuXHRcdHRoaXMuc2NlbmUgPSBzY2VuZTtcclxuXHRcdHRoaXMuY2FtZXJhID0gY2FtZXJhO1xyXG5cdFx0dGhpcy5saWdodHNOb2RlID0gbGlnaHRzTm9kZTtcclxuXHRcdHRoaXMuY29udGV4dCA9IHJlbmRlckNvbnRleHQ7XHJcblxyXG5cdFx0dGhpcy5nZW9tZXRyeSA9IG9iamVjdC5nZW9tZXRyeTtcclxuXHRcdHRoaXMudmVyc2lvbiA9IG1hdGVyaWFsLnZlcnNpb247XHJcblxyXG5cdFx0dGhpcy5kcmF3UmFuZ2UgPSBudWxsO1xyXG5cclxuXHRcdHRoaXMuYXR0cmlidXRlcyA9IG51bGw7XHJcblx0XHR0aGlzLnBpcGVsaW5lID0gbnVsbDtcclxuXHRcdHRoaXMudmVydGV4QnVmZmVycyA9IG51bGw7XHJcblx0XHR0aGlzLmRyYXdQYXJhbXMgPSBudWxsO1xyXG5cclxuXHRcdHRoaXMuYnVuZGxlID0gbnVsbDtcclxuXHJcblx0XHR0aGlzLmNsaXBwaW5nQ29udGV4dCA9IGNsaXBwaW5nQ29udGV4dDtcclxuXHRcdHRoaXMuY2xpcHBpbmdDb250ZXh0Q2FjaGVLZXkgPSBjbGlwcGluZ0NvbnRleHQgIT09IG51bGwgPyBjbGlwcGluZ0NvbnRleHQuY2FjaGVLZXkgOiAnJztcclxuXHJcblx0XHR0aGlzLmluaXRpYWxOb2Rlc0NhY2hlS2V5ID0gdGhpcy5nZXREeW5hbWljQ2FjaGVLZXkoKTtcclxuXHRcdHRoaXMuaW5pdGlhbENhY2hlS2V5ID0gdGhpcy5nZXRDYWNoZUtleSgpO1xyXG5cclxuXHRcdHRoaXMuX25vZGVCdWlsZGVyU3RhdGUgPSBudWxsO1xyXG5cdFx0dGhpcy5fYmluZGluZ3MgPSBudWxsO1xyXG5cdFx0dGhpcy5fbW9uaXRvciA9IG51bGw7XHJcblxyXG5cdFx0dGhpcy5vbkRpc3Bvc2UgPSBudWxsO1xyXG5cclxuXHRcdHRoaXMuaXNSZW5kZXJPYmplY3QgPSB0cnVlO1xyXG5cclxuXHRcdHRoaXMub25NYXRlcmlhbERpc3Bvc2UgPSAoKSA9PiB7XHJcblxyXG5cdFx0XHR0aGlzLmRpc3Bvc2UoKTtcclxuXHJcblx0XHR9O1xyXG5cclxuXHRcdHRoaXMubWF0ZXJpYWwuYWRkRXZlbnRMaXN0ZW5lciggJ2Rpc3Bvc2UnLCB0aGlzLm9uTWF0ZXJpYWxEaXNwb3NlICk7XHJcblxyXG5cdH1cclxuXHJcblx0dXBkYXRlQ2xpcHBpbmcoIHBhcmVudCApIHtcclxuXHJcblx0XHR0aGlzLmNsaXBwaW5nQ29udGV4dCA9IHBhcmVudDtcclxuXHJcblx0fVxyXG5cclxuXHRnZXQgY2xpcHBpbmdOZWVkc1VwZGF0ZSgpIHtcclxuXHJcblx0XHRpZiAoIHRoaXMuY2xpcHBpbmdDb250ZXh0ID09PSBudWxsIHx8IHRoaXMuY2xpcHBpbmdDb250ZXh0LmNhY2hlS2V5ID09PSB0aGlzLmNsaXBwaW5nQ29udGV4dENhY2hlS2V5ICkgcmV0dXJuIGZhbHNlO1xyXG5cclxuXHRcdHRoaXMuY2xpcHBpbmdDb250ZXh0Q2FjaGVLZXkgPSB0aGlzLmNsaXBwaW5nQ29udGV4dC5jYWNoZUtleTtcclxuXHJcblx0XHRyZXR1cm4gdHJ1ZTtcclxuXHJcblx0fVxyXG5cclxuXHRnZXQgaGFyZHdhcmVDbGlwcGluZ1BsYW5lcygpIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5tYXRlcmlhbC5oYXJkd2FyZUNsaXBwaW5nID09PSB0cnVlID8gdGhpcy5jbGlwcGluZ0NvbnRleHQudW5pb25DbGlwcGluZ0NvdW50IDogMDtcclxuXHJcblx0fVxyXG5cclxuXHRnZXROb2RlQnVpbGRlclN0YXRlKCkge1xyXG5cclxuXHRcdHJldHVybiB0aGlzLl9ub2RlQnVpbGRlclN0YXRlIHx8ICggdGhpcy5fbm9kZUJ1aWxkZXJTdGF0ZSA9IHRoaXMuX25vZGVzLmdldEZvclJlbmRlciggdGhpcyApICk7XHJcblxyXG5cdH1cclxuXHJcblx0Z2V0TW9uaXRvcigpIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5fbW9uaXRvciB8fCAoIHRoaXMuX21vbml0b3IgPSB0aGlzLmdldE5vZGVCdWlsZGVyU3RhdGUoKS5tb25pdG9yICk7XHJcblxyXG5cdH1cclxuXHJcblx0Z2V0QmluZGluZ3MoKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuX2JpbmRpbmdzIHx8ICggdGhpcy5fYmluZGluZ3MgPSB0aGlzLmdldE5vZGVCdWlsZGVyU3RhdGUoKS5jcmVhdGVCaW5kaW5ncygpICk7XHJcblxyXG5cdH1cclxuXHJcblx0Z2V0SW5kZXgoKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuX2dlb21ldHJpZXMuZ2V0SW5kZXgoIHRoaXMgKTtcclxuXHJcblx0fVxyXG5cclxuXHRnZXRJbmRpcmVjdCgpIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5fZ2VvbWV0cmllcy5nZXRJbmRpcmVjdCggdGhpcyApO1xyXG5cclxuXHR9XHJcblxyXG5cdGdldENoYWluQXJyYXkoKSB7XHJcblxyXG5cdFx0cmV0dXJuIFsgdGhpcy5vYmplY3QsIHRoaXMubWF0ZXJpYWwsIHRoaXMuY29udGV4dCwgdGhpcy5saWdodHNOb2RlIF07XHJcblxyXG5cdH1cclxuXHJcblx0c2V0R2VvbWV0cnkoIGdlb21ldHJ5ICkge1xyXG5cclxuXHRcdHRoaXMuZ2VvbWV0cnkgPSBnZW9tZXRyeTtcclxuXHRcdHRoaXMuYXR0cmlidXRlcyA9IG51bGw7XHJcblxyXG5cdH1cclxuXHJcblx0Z2V0QXR0cmlidXRlcygpIHtcclxuXHJcblx0XHRpZiAoIHRoaXMuYXR0cmlidXRlcyAhPT0gbnVsbCApIHJldHVybiB0aGlzLmF0dHJpYnV0ZXM7XHJcblxyXG5cdFx0Y29uc3Qgbm9kZUF0dHJpYnV0ZXMgPSB0aGlzLmdldE5vZGVCdWlsZGVyU3RhdGUoKS5ub2RlQXR0cmlidXRlcztcclxuXHRcdGNvbnN0IGdlb21ldHJ5ID0gdGhpcy5nZW9tZXRyeTtcclxuXHJcblx0XHRjb25zdCBhdHRyaWJ1dGVzID0gW107XHJcblx0XHRjb25zdCB2ZXJ0ZXhCdWZmZXJzID0gbmV3IFNldCgpO1xyXG5cclxuXHRcdGZvciAoIGNvbnN0IG5vZGVBdHRyaWJ1dGUgb2Ygbm9kZUF0dHJpYnV0ZXMgKSB7XHJcblxyXG5cdFx0XHRjb25zdCBhdHRyaWJ1dGUgPSBub2RlQXR0cmlidXRlLm5vZGUgJiYgbm9kZUF0dHJpYnV0ZS5ub2RlLmF0dHJpYnV0ZSA/IG5vZGVBdHRyaWJ1dGUubm9kZS5hdHRyaWJ1dGUgOiBnZW9tZXRyeS5nZXRBdHRyaWJ1dGUoIG5vZGVBdHRyaWJ1dGUubmFtZSApO1xyXG5cclxuXHRcdFx0aWYgKCBhdHRyaWJ1dGUgPT09IHVuZGVmaW5lZCApIGNvbnRpbnVlO1xyXG5cclxuXHRcdFx0YXR0cmlidXRlcy5wdXNoKCBhdHRyaWJ1dGUgKTtcclxuXHJcblx0XHRcdGNvbnN0IGJ1ZmZlckF0dHJpYnV0ZSA9IGF0dHJpYnV0ZS5pc0ludGVybGVhdmVkQnVmZmVyQXR0cmlidXRlID8gYXR0cmlidXRlLmRhdGEgOiBhdHRyaWJ1dGU7XHJcblx0XHRcdHZlcnRleEJ1ZmZlcnMuYWRkKCBidWZmZXJBdHRyaWJ1dGUgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5hdHRyaWJ1dGVzID0gYXR0cmlidXRlcztcclxuXHRcdHRoaXMudmVydGV4QnVmZmVycyA9IEFycmF5LmZyb20oIHZlcnRleEJ1ZmZlcnMudmFsdWVzKCkgKTtcclxuXHJcblx0XHRyZXR1cm4gYXR0cmlidXRlcztcclxuXHJcblx0fVxyXG5cclxuXHRnZXRWZXJ0ZXhCdWZmZXJzKCkge1xyXG5cclxuXHRcdGlmICggdGhpcy52ZXJ0ZXhCdWZmZXJzID09PSBudWxsICkgdGhpcy5nZXRBdHRyaWJ1dGVzKCk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMudmVydGV4QnVmZmVycztcclxuXHJcblx0fVxyXG5cclxuXHRnZXREcmF3UGFyYW1ldGVycygpIHtcclxuXHJcblx0XHRjb25zdCB7IG9iamVjdCwgbWF0ZXJpYWwsIGdlb21ldHJ5LCBncm91cCwgZHJhd1JhbmdlIH0gPSB0aGlzO1xyXG5cclxuXHRcdGNvbnN0IGRyYXdQYXJhbXMgPSB0aGlzLmRyYXdQYXJhbXMgfHwgKCB0aGlzLmRyYXdQYXJhbXMgPSB7XHJcblx0XHRcdHZlcnRleENvdW50OiAwLFxyXG5cdFx0XHRmaXJzdFZlcnRleDogMCxcclxuXHRcdFx0aW5zdGFuY2VDb3VudDogMCxcclxuXHRcdFx0Zmlyc3RJbnN0YW5jZTogMFxyXG5cdFx0fSApO1xyXG5cclxuXHRcdGNvbnN0IGluZGV4ID0gdGhpcy5nZXRJbmRleCgpO1xyXG5cdFx0Y29uc3QgaGFzSW5kZXggPSAoIGluZGV4ICE9PSBudWxsICk7XHJcblx0XHRjb25zdCBpbnN0YW5jZUNvdW50ID0gZ2VvbWV0cnkuaXNJbnN0YW5jZWRCdWZmZXJHZW9tZXRyeSA/IGdlb21ldHJ5Lmluc3RhbmNlQ291bnQgOiAoIG9iamVjdC5jb3VudCA+IDEgPyBvYmplY3QuY291bnQgOiAxICk7XHJcblxyXG5cdFx0aWYgKCBpbnN0YW5jZUNvdW50ID09PSAwICkgcmV0dXJuIG51bGw7XHJcblxyXG5cdFx0ZHJhd1BhcmFtcy5pbnN0YW5jZUNvdW50ID0gaW5zdGFuY2VDb3VudDtcclxuXHJcblx0XHRpZiAoIG9iamVjdC5pc0JhdGNoZWRNZXNoID09PSB0cnVlICkgcmV0dXJuIGRyYXdQYXJhbXM7XHJcblxyXG5cdFx0bGV0IHJhbmdlRmFjdG9yID0gMTtcclxuXHJcblx0XHRpZiAoIG1hdGVyaWFsLndpcmVmcmFtZSA9PT0gdHJ1ZSAmJiAhIG9iamVjdC5pc1BvaW50cyAmJiAhIG9iamVjdC5pc0xpbmVTZWdtZW50cyAmJiAhIG9iamVjdC5pc0xpbmUgJiYgISBvYmplY3QuaXNMaW5lTG9vcCApIHtcclxuXHJcblx0XHRcdHJhbmdlRmFjdG9yID0gMjtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0bGV0IGZpcnN0VmVydGV4ID0gZHJhd1JhbmdlLnN0YXJ0ICogcmFuZ2VGYWN0b3I7XHJcblx0XHRsZXQgbGFzdFZlcnRleCA9ICggZHJhd1JhbmdlLnN0YXJ0ICsgZHJhd1JhbmdlLmNvdW50ICkgKiByYW5nZUZhY3RvcjtcclxuXHJcblx0XHRpZiAoIGdyb3VwICE9PSBudWxsICkge1xyXG5cclxuXHRcdFx0Zmlyc3RWZXJ0ZXggPSBNYXRoLm1heCggZmlyc3RWZXJ0ZXgsIGdyb3VwLnN0YXJ0ICogcmFuZ2VGYWN0b3IgKTtcclxuXHRcdFx0bGFzdFZlcnRleCA9IE1hdGgubWluKCBsYXN0VmVydGV4LCAoIGdyb3VwLnN0YXJ0ICsgZ3JvdXAuY291bnQgKSAqIHJhbmdlRmFjdG9yICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGNvbnN0IHBvc2l0aW9uID0gZ2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbjtcclxuXHRcdGxldCBpdGVtQ291bnQgPSBJbmZpbml0eTtcclxuXHJcblx0XHRpZiAoIGhhc0luZGV4ICkge1xyXG5cclxuXHRcdFx0aXRlbUNvdW50ID0gaW5kZXguY291bnQ7XHJcblxyXG5cdFx0fSBlbHNlIGlmICggcG9zaXRpb24gIT09IHVuZGVmaW5lZCAmJiBwb3NpdGlvbiAhPT0gbnVsbCApIHtcclxuXHJcblx0XHRcdGl0ZW1Db3VudCA9IHBvc2l0aW9uLmNvdW50O1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRmaXJzdFZlcnRleCA9IE1hdGgubWF4KCBmaXJzdFZlcnRleCwgMCApO1xyXG5cdFx0bGFzdFZlcnRleCA9IE1hdGgubWluKCBsYXN0VmVydGV4LCBpdGVtQ291bnQgKTtcclxuXHJcblx0XHRjb25zdCBjb3VudCA9IGxhc3RWZXJ0ZXggLSBmaXJzdFZlcnRleDtcclxuXHJcblx0XHRpZiAoIGNvdW50IDwgMCB8fCBjb3VudCA9PT0gSW5maW5pdHkgKSByZXR1cm4gbnVsbDtcclxuXHJcblx0XHRkcmF3UGFyYW1zLnZlcnRleENvdW50ID0gY291bnQ7XHJcblx0XHRkcmF3UGFyYW1zLmZpcnN0VmVydGV4ID0gZmlyc3RWZXJ0ZXg7XHJcblxyXG5cdFx0cmV0dXJuIGRyYXdQYXJhbXM7XHJcblxyXG5cdH1cclxuXHJcblx0Z2V0R2VvbWV0cnlDYWNoZUtleSgpIHtcclxuXHJcblx0XHRjb25zdCB7IGdlb21ldHJ5IH0gPSB0aGlzO1xyXG5cclxuXHRcdGxldCBjYWNoZUtleSA9ICcnO1xyXG5cclxuXHRcdGZvciAoIGNvbnN0IG5hbWUgb2YgT2JqZWN0LmtleXMoIGdlb21ldHJ5LmF0dHJpYnV0ZXMgKS5zb3J0KCkgKSB7XHJcblxyXG5cdFx0XHRjb25zdCBhdHRyaWJ1dGUgPSBnZW9tZXRyeS5hdHRyaWJ1dGVzWyBuYW1lIF07XHJcblxyXG5cdFx0XHRjYWNoZUtleSArPSBuYW1lICsgJywnO1xyXG5cclxuXHRcdFx0aWYgKCBhdHRyaWJ1dGUuZGF0YSApIGNhY2hlS2V5ICs9IGF0dHJpYnV0ZS5kYXRhLnN0cmlkZSArICcsJztcclxuXHRcdFx0aWYgKCBhdHRyaWJ1dGUub2Zmc2V0ICkgY2FjaGVLZXkgKz0gYXR0cmlidXRlLm9mZnNldCArICcsJztcclxuXHRcdFx0aWYgKCBhdHRyaWJ1dGUuaXRlbVNpemUgKSBjYWNoZUtleSArPSBhdHRyaWJ1dGUuaXRlbVNpemUgKyAnLCc7XHJcblx0XHRcdGlmICggYXR0cmlidXRlLm5vcm1hbGl6ZWQgKSBjYWNoZUtleSArPSAnbiwnO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIGdlb21ldHJ5LmluZGV4ICkge1xyXG5cclxuXHRcdFx0Y2FjaGVLZXkgKz0gJ2luZGV4LCc7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBjYWNoZUtleTtcclxuXHJcblx0fVxyXG5cclxuXHRnZXRNYXRlcmlhbENhY2hlS2V5KCkge1xyXG5cclxuXHRcdGNvbnN0IHsgb2JqZWN0LCBtYXRlcmlhbCB9ID0gdGhpcztcclxuXHJcblx0XHRsZXQgY2FjaGVLZXkgPSBtYXRlcmlhbC5jdXN0b21Qcm9ncmFtQ2FjaGVLZXkoKTtcclxuXHJcblx0XHRmb3IgKCBjb25zdCBwcm9wZXJ0eSBvZiBnZXRLZXlzKCBtYXRlcmlhbCApICkge1xyXG5cclxuXHRcdFx0aWYgKCAvXihpc1tBLVpdfF8pfF4odmlzaWJsZXx2ZXJzaW9ufHV1aWR8bmFtZXxvcGFjaXR5fHVzZXJEYXRhKSQvLnRlc3QoIHByb3BlcnR5ICkgKSBjb250aW51ZTtcclxuXHJcblx0XHRcdGNvbnN0IHZhbHVlID0gbWF0ZXJpYWxbIHByb3BlcnR5IF07XHJcblxyXG5cdFx0XHRsZXQgdmFsdWVLZXk7XHJcblxyXG5cdFx0XHRpZiAoIHZhbHVlICE9PSBudWxsICkge1xyXG5cclxuXHRcdFx0XHQvLyBzb21lIG1hdGVyaWFsIHZhbHVlcyByZXF1aXJlIGEgZm9ybWF0dGluZ1xyXG5cclxuXHRcdFx0XHRjb25zdCB0eXBlID0gdHlwZW9mIHZhbHVlO1xyXG5cclxuXHRcdFx0XHRpZiAoIHR5cGUgPT09ICdudW1iZXInICkge1xyXG5cclxuXHRcdFx0XHRcdHZhbHVlS2V5ID0gdmFsdWUgIT09IDAgPyAnMScgOiAnMCc7IC8vIENvbnZlcnQgdG8gb24vb2ZmLCBpbXBvcnRhbnQgZm9yIGNsZWFyY29hdCwgdHJhbnNtaXNzaW9uLCBldGNcclxuXHJcblx0XHRcdFx0fSBlbHNlIGlmICggdHlwZSA9PT0gJ29iamVjdCcgKSB7XHJcblxyXG5cdFx0XHRcdFx0dmFsdWVLZXkgPSAneyc7XHJcblxyXG5cdFx0XHRcdFx0aWYgKCB2YWx1ZS5pc1RleHR1cmUgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHR2YWx1ZUtleSArPSB2YWx1ZS5tYXBwaW5nO1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHR2YWx1ZUtleSArPSAnfSc7XHJcblxyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0dmFsdWVLZXkgPSBTdHJpbmcoIHZhbHVlICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdHZhbHVlS2V5ID0gU3RyaW5nKCB2YWx1ZSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Y2FjaGVLZXkgKz0gLypwcm9wZXJ0eSArICc6JyArKi8gdmFsdWVLZXkgKyAnLCc7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGNhY2hlS2V5ICs9IHRoaXMuY2xpcHBpbmdDb250ZXh0Q2FjaGVLZXkgKyAnLCc7XHJcblxyXG5cdFx0aWYgKCBvYmplY3QuZ2VvbWV0cnkgKSB7XHJcblxyXG5cdFx0XHRjYWNoZUtleSArPSB0aGlzLmdldEdlb21ldHJ5Q2FjaGVLZXkoKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBvYmplY3Quc2tlbGV0b24gKSB7XHJcblxyXG5cdFx0XHRjYWNoZUtleSArPSBvYmplY3Quc2tlbGV0b24uYm9uZXMubGVuZ3RoICsgJywnO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIG9iamVjdC5tb3JwaFRhcmdldEluZmx1ZW5jZXMgKSB7XHJcblxyXG5cdFx0XHRjYWNoZUtleSArPSBvYmplY3QubW9ycGhUYXJnZXRJbmZsdWVuY2VzLmxlbmd0aCArICcsJztcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBvYmplY3QuaXNCYXRjaGVkTWVzaCApIHtcclxuXHJcblx0XHRcdGNhY2hlS2V5ICs9IG9iamVjdC5fbWF0cmljZXNUZXh0dXJlLnV1aWQgKyAnLCc7XHJcblxyXG5cdFx0XHRpZiAoIG9iamVjdC5fY29sb3JzVGV4dHVyZSAhPT0gbnVsbCApIHtcclxuXHJcblx0XHRcdFx0Y2FjaGVLZXkgKz0gb2JqZWN0Ll9jb2xvcnNUZXh0dXJlLnV1aWQgKyAnLCc7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggb2JqZWN0LmNvdW50ID4gMSApIHtcclxuXHJcblx0XHRcdC8vIFRPRE86IGh0dHBzOi8vZ2l0aHViLmNvbS9tcmRvb2IvdGhyZWUuanMvcHVsbC8yOTA2NiNpc3N1ZWNvbW1lbnQtMjI2OTQwMDg1MFxyXG5cclxuXHRcdFx0Y2FjaGVLZXkgKz0gb2JqZWN0LnV1aWQgKyAnLCc7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGNhY2hlS2V5ICs9IG9iamVjdC5yZWNlaXZlU2hhZG93ICsgJywnO1xyXG5cclxuXHRcdHJldHVybiBoYXNoU3RyaW5nKCBjYWNoZUtleSApO1xyXG5cclxuXHR9XHJcblxyXG5cdGdldCBuZWVkc0dlb21ldHJ5VXBkYXRlKCkge1xyXG5cclxuXHRcdHJldHVybiB0aGlzLmdlb21ldHJ5LmlkICE9PSB0aGlzLm9iamVjdC5nZW9tZXRyeS5pZDtcclxuXHJcblx0fVxyXG5cclxuXHRnZXQgbmVlZHNVcGRhdGUoKSB7XHJcblxyXG5cdFx0cmV0dXJuIC8qdGhpcy5vYmplY3Quc3RhdGljICE9PSB0cnVlICYmKi8gKCB0aGlzLmluaXRpYWxOb2Rlc0NhY2hlS2V5ICE9PSB0aGlzLmdldER5bmFtaWNDYWNoZUtleSgpIHx8IHRoaXMuY2xpcHBpbmdOZWVkc1VwZGF0ZSApO1xyXG5cclxuXHR9XHJcblxyXG5cdGdldER5bmFtaWNDYWNoZUtleSgpIHtcclxuXHJcblx0XHQvLyBFbnZpcm9ubWVudCBOb2RlcyBDYWNoZSBLZXlcclxuXHJcblx0XHRsZXQgY2FjaGVLZXkgPSB0aGlzLl9ub2Rlcy5nZXRDYWNoZUtleSggdGhpcy5zY2VuZSwgdGhpcy5saWdodHNOb2RlICk7XHJcblxyXG5cdFx0aWYgKCB0aGlzLm9iamVjdC5yZWNlaXZlU2hhZG93ICkge1xyXG5cclxuXHRcdFx0Y2FjaGVLZXkgKz0gMTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGNhY2hlS2V5O1xyXG5cclxuXHR9XHJcblxyXG5cdGdldENhY2hlS2V5KCkge1xyXG5cclxuXHRcdHJldHVybiB0aGlzLmdldE1hdGVyaWFsQ2FjaGVLZXkoKSArIHRoaXMuZ2V0RHluYW1pY0NhY2hlS2V5KCk7XHJcblxyXG5cdH1cclxuXHJcblx0ZGlzcG9zZSgpIHtcclxuXHJcblx0XHR0aGlzLm1hdGVyaWFsLnJlbW92ZUV2ZW50TGlzdGVuZXIoICdkaXNwb3NlJywgdGhpcy5vbk1hdGVyaWFsRGlzcG9zZSApO1xyXG5cclxuXHRcdHRoaXMub25EaXNwb3NlKCk7XHJcblxyXG5cdH1cclxuXHJcbn1cclxuIiwiaW1wb3J0IENoYWluTWFwIGZyb20gJy4vQ2hhaW5NYXAuanMnO1xyXG5pbXBvcnQgUmVuZGVyT2JqZWN0IGZyb20gJy4vUmVuZGVyT2JqZWN0LmpzJztcclxuXHJcbmNvbnN0IGNoYWluQXJyYXkgPSBbXTtcclxuXHJcbmNsYXNzIFJlbmRlck9iamVjdHMge1xyXG5cclxuXHRjb25zdHJ1Y3RvciggcmVuZGVyZXIsIG5vZGVzLCBnZW9tZXRyaWVzLCBwaXBlbGluZXMsIGJpbmRpbmdzLCBpbmZvICkge1xyXG5cclxuXHRcdHRoaXMucmVuZGVyZXIgPSByZW5kZXJlcjtcclxuXHRcdHRoaXMubm9kZXMgPSBub2RlcztcclxuXHRcdHRoaXMuZ2VvbWV0cmllcyA9IGdlb21ldHJpZXM7XHJcblx0XHR0aGlzLnBpcGVsaW5lcyA9IHBpcGVsaW5lcztcclxuXHRcdHRoaXMuYmluZGluZ3MgPSBiaW5kaW5ncztcclxuXHRcdHRoaXMuaW5mbyA9IGluZm87XHJcblxyXG5cdFx0dGhpcy5jaGFpbk1hcHMgPSB7fTtcclxuXHJcblx0fVxyXG5cclxuXHRnZXQoIG9iamVjdCwgbWF0ZXJpYWwsIHNjZW5lLCBjYW1lcmEsIGxpZ2h0c05vZGUsIHJlbmRlckNvbnRleHQsIGNsaXBwaW5nQ29udGV4dCwgcGFzc0lkICkge1xyXG5cclxuXHRcdGNvbnN0IGNoYWluTWFwID0gdGhpcy5nZXRDaGFpbk1hcCggcGFzc0lkICk7XHJcblxyXG5cdFx0Ly8gcmV1c2UgY2hhaW5BcnJheVxyXG5cdFx0Y2hhaW5BcnJheVsgMCBdID0gb2JqZWN0O1xyXG5cdFx0Y2hhaW5BcnJheVsgMSBdID0gbWF0ZXJpYWw7XHJcblx0XHRjaGFpbkFycmF5WyAyIF0gPSByZW5kZXJDb250ZXh0O1xyXG5cdFx0Y2hhaW5BcnJheVsgMyBdID0gbGlnaHRzTm9kZTtcclxuXHJcblx0XHRsZXQgcmVuZGVyT2JqZWN0ID0gY2hhaW5NYXAuZ2V0KCBjaGFpbkFycmF5ICk7XHJcblxyXG5cdFx0aWYgKCByZW5kZXJPYmplY3QgPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdHJlbmRlck9iamVjdCA9IHRoaXMuY3JlYXRlUmVuZGVyT2JqZWN0KCB0aGlzLm5vZGVzLCB0aGlzLmdlb21ldHJpZXMsIHRoaXMucmVuZGVyZXIsIG9iamVjdCwgbWF0ZXJpYWwsIHNjZW5lLCBjYW1lcmEsIGxpZ2h0c05vZGUsIHJlbmRlckNvbnRleHQsIGNsaXBwaW5nQ29udGV4dCwgcGFzc0lkICk7XHJcblxyXG5cdFx0XHRjaGFpbk1hcC5zZXQoIGNoYWluQXJyYXksIHJlbmRlck9iamVjdCApO1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRyZW5kZXJPYmplY3QudXBkYXRlQ2xpcHBpbmcoIGNsaXBwaW5nQ29udGV4dCApO1xyXG5cclxuXHRcdFx0aWYgKCByZW5kZXJPYmplY3QubmVlZHNHZW9tZXRyeVVwZGF0ZSApIHtcclxuXHJcblx0XHRcdFx0cmVuZGVyT2JqZWN0LnNldEdlb21ldHJ5KCBvYmplY3QuZ2VvbWV0cnkgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICggcmVuZGVyT2JqZWN0LnZlcnNpb24gIT09IG1hdGVyaWFsLnZlcnNpb24gfHwgcmVuZGVyT2JqZWN0Lm5lZWRzVXBkYXRlICkge1xyXG5cclxuXHRcdFx0XHRpZiAoIHJlbmRlck9iamVjdC5pbml0aWFsQ2FjaGVLZXkgIT09IHJlbmRlck9iamVjdC5nZXRDYWNoZUtleSgpICkge1xyXG5cclxuXHRcdFx0XHRcdHJlbmRlck9iamVjdC5kaXNwb3NlKCk7XHJcblxyXG5cdFx0XHRcdFx0cmVuZGVyT2JqZWN0ID0gdGhpcy5nZXQoIG9iamVjdCwgbWF0ZXJpYWwsIHNjZW5lLCBjYW1lcmEsIGxpZ2h0c05vZGUsIHJlbmRlckNvbnRleHQsIGNsaXBwaW5nQ29udGV4dCwgcGFzc0lkICk7XHJcblxyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0cmVuZGVyT2JqZWN0LnZlcnNpb24gPSBtYXRlcmlhbC52ZXJzaW9uO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiByZW5kZXJPYmplY3Q7XHJcblxyXG5cdH1cclxuXHJcblx0Z2V0Q2hhaW5NYXAoIHBhc3NJZCA9ICdkZWZhdWx0JyApIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5jaGFpbk1hcHNbIHBhc3NJZCBdIHx8ICggdGhpcy5jaGFpbk1hcHNbIHBhc3NJZCBdID0gbmV3IENoYWluTWFwKCkgKTtcclxuXHJcblx0fVxyXG5cclxuXHRkaXNwb3NlKCkge1xyXG5cclxuXHRcdHRoaXMuY2hhaW5NYXBzID0ge307XHJcblxyXG5cdH1cclxuXHJcblx0Y3JlYXRlUmVuZGVyT2JqZWN0KCBub2RlcywgZ2VvbWV0cmllcywgcmVuZGVyZXIsIG9iamVjdCwgbWF0ZXJpYWwsIHNjZW5lLCBjYW1lcmEsIGxpZ2h0c05vZGUsIHJlbmRlckNvbnRleHQsIGNsaXBwaW5nQ29udGV4dCwgcGFzc0lkICkge1xyXG5cclxuXHRcdGNvbnN0IGNoYWluTWFwID0gdGhpcy5nZXRDaGFpbk1hcCggcGFzc0lkICk7XHJcblxyXG5cdFx0Y29uc3QgcmVuZGVyT2JqZWN0ID0gbmV3IFJlbmRlck9iamVjdCggbm9kZXMsIGdlb21ldHJpZXMsIHJlbmRlcmVyLCBvYmplY3QsIG1hdGVyaWFsLCBzY2VuZSwgY2FtZXJhLCBsaWdodHNOb2RlLCByZW5kZXJDb250ZXh0LCBjbGlwcGluZ0NvbnRleHQgKTtcclxuXHJcblx0XHRyZW5kZXJPYmplY3Qub25EaXNwb3NlID0gKCkgPT4ge1xyXG5cclxuXHRcdFx0dGhpcy5waXBlbGluZXMuZGVsZXRlKCByZW5kZXJPYmplY3QgKTtcclxuXHRcdFx0dGhpcy5iaW5kaW5ncy5kZWxldGUoIHJlbmRlck9iamVjdCApO1xyXG5cdFx0XHR0aGlzLm5vZGVzLmRlbGV0ZSggcmVuZGVyT2JqZWN0ICk7XHJcblxyXG5cdFx0XHRjaGFpbk1hcC5kZWxldGUoIHJlbmRlck9iamVjdC5nZXRDaGFpbkFycmF5KCkgKTtcclxuXHJcblx0XHR9O1xyXG5cclxuXHRcdHJldHVybiByZW5kZXJPYmplY3Q7XHJcblxyXG5cdH1cclxuXHJcblxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBSZW5kZXJPYmplY3RzO1xyXG4iLCJjbGFzcyBEYXRhTWFwIHtcclxuXHJcblx0Y29uc3RydWN0b3IoKSB7XHJcblxyXG5cdFx0dGhpcy5kYXRhID0gbmV3IFdlYWtNYXAoKTtcclxuXHJcblx0fVxyXG5cclxuXHRnZXQoIG9iamVjdCApIHtcclxuXHJcblx0XHRsZXQgbWFwID0gdGhpcy5kYXRhLmdldCggb2JqZWN0ICk7XHJcblxyXG5cdFx0aWYgKCBtYXAgPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdG1hcCA9IHt9O1xyXG5cdFx0XHR0aGlzLmRhdGEuc2V0KCBvYmplY3QsIG1hcCApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gbWFwO1xyXG5cclxuXHR9XHJcblxyXG5cdGRlbGV0ZSggb2JqZWN0ICkge1xyXG5cclxuXHRcdGxldCBtYXA7XHJcblxyXG5cdFx0aWYgKCB0aGlzLmRhdGEuaGFzKCBvYmplY3QgKSApIHtcclxuXHJcblx0XHRcdG1hcCA9IHRoaXMuZGF0YS5nZXQoIG9iamVjdCApO1xyXG5cclxuXHRcdFx0dGhpcy5kYXRhLmRlbGV0ZSggb2JqZWN0ICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBtYXA7XHJcblxyXG5cdH1cclxuXHJcblx0aGFzKCBvYmplY3QgKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuZGF0YS5oYXMoIG9iamVjdCApO1xyXG5cclxuXHR9XHJcblxyXG5cdGRpc3Bvc2UoKSB7XHJcblxyXG5cdFx0dGhpcy5kYXRhID0gbmV3IFdlYWtNYXAoKTtcclxuXHJcblx0fVxyXG5cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgRGF0YU1hcDtcclxuIiwiZXhwb3J0IGNvbnN0IEF0dHJpYnV0ZVR5cGUgPSB7XHJcblx0VkVSVEVYOiAxLFxyXG5cdElOREVYOiAyLFxyXG5cdFNUT1JBR0U6IDMsXHJcblx0SU5ESVJFQ1Q6IDRcclxufTtcclxuXHJcbi8vIHNpemUgb2YgYSBjaHVuayBpbiBieXRlcyAoU1REMTQwIGxheW91dClcclxuXHJcbmV4cG9ydCBjb25zdCBHUFVfQ0hVTktfQllURVMgPSAxNjtcclxuXHJcbi8vIEBUT0RPOiBNb3ZlIHRvIHNyYy9jb25zdGFudHMuanNcclxuXHJcbmV4cG9ydCBjb25zdCBCbGVuZENvbG9yRmFjdG9yID0gMjExO1xyXG5leHBvcnQgY29uc3QgT25lTWludXNCbGVuZENvbG9yRmFjdG9yID0gMjEyO1xyXG4iLCJpbXBvcnQgRGF0YU1hcCBmcm9tICcuL0RhdGFNYXAuanMnO1xyXG5pbXBvcnQgeyBBdHRyaWJ1dGVUeXBlIH0gZnJvbSAnLi9Db25zdGFudHMuanMnO1xyXG5cclxuaW1wb3J0IHsgRHluYW1pY0RyYXdVc2FnZSB9IGZyb20gJy4uLy4uL2NvbnN0YW50cy5qcyc7XHJcblxyXG5jbGFzcyBBdHRyaWJ1dGVzIGV4dGVuZHMgRGF0YU1hcCB7XHJcblxyXG5cdGNvbnN0cnVjdG9yKCBiYWNrZW5kICkge1xyXG5cclxuXHRcdHN1cGVyKCk7XHJcblxyXG5cdFx0dGhpcy5iYWNrZW5kID0gYmFja2VuZDtcclxuXHJcblx0fVxyXG5cclxuXHRkZWxldGUoIGF0dHJpYnV0ZSApIHtcclxuXHJcblx0XHRjb25zdCBhdHRyaWJ1dGVEYXRhID0gc3VwZXIuZGVsZXRlKCBhdHRyaWJ1dGUgKTtcclxuXHJcblx0XHRpZiAoIGF0dHJpYnV0ZURhdGEgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdHRoaXMuYmFja2VuZC5kZXN0cm95QXR0cmlidXRlKCBhdHRyaWJ1dGUgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGF0dHJpYnV0ZURhdGE7XHJcblxyXG5cdH1cclxuXHJcblx0dXBkYXRlKCBhdHRyaWJ1dGUsIHR5cGUgKSB7XHJcblxyXG5cdFx0Y29uc3QgZGF0YSA9IHRoaXMuZ2V0KCBhdHRyaWJ1dGUgKTtcclxuXHJcblx0XHRpZiAoIGRhdGEudmVyc2lvbiA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0aWYgKCB0eXBlID09PSBBdHRyaWJ1dGVUeXBlLlZFUlRFWCApIHtcclxuXHJcblx0XHRcdFx0dGhpcy5iYWNrZW5kLmNyZWF0ZUF0dHJpYnV0ZSggYXR0cmlidXRlICk7XHJcblxyXG5cdFx0XHR9IGVsc2UgaWYgKCB0eXBlID09PSBBdHRyaWJ1dGVUeXBlLklOREVYICkge1xyXG5cclxuXHRcdFx0XHR0aGlzLmJhY2tlbmQuY3JlYXRlSW5kZXhBdHRyaWJ1dGUoIGF0dHJpYnV0ZSApO1xyXG5cclxuXHRcdFx0fSBlbHNlIGlmICggdHlwZSA9PT0gQXR0cmlidXRlVHlwZS5TVE9SQUdFICkge1xyXG5cclxuXHRcdFx0XHR0aGlzLmJhY2tlbmQuY3JlYXRlU3RvcmFnZUF0dHJpYnV0ZSggYXR0cmlidXRlICk7XHJcblxyXG5cdFx0XHR9IGVsc2UgaWYgKCB0eXBlID09PSBBdHRyaWJ1dGVUeXBlLklORElSRUNUICkge1xyXG5cclxuXHRcdFx0XHR0aGlzLmJhY2tlbmQuY3JlYXRlSW5kaXJlY3RTdG9yYWdlQXR0cmlidXRlKCBhdHRyaWJ1dGUgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGRhdGEudmVyc2lvbiA9IHRoaXMuX2dldEJ1ZmZlckF0dHJpYnV0ZSggYXR0cmlidXRlICkudmVyc2lvbjtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0Y29uc3QgYnVmZmVyQXR0cmlidXRlID0gdGhpcy5fZ2V0QnVmZmVyQXR0cmlidXRlKCBhdHRyaWJ1dGUgKTtcclxuXHJcblx0XHRcdGlmICggZGF0YS52ZXJzaW9uIDwgYnVmZmVyQXR0cmlidXRlLnZlcnNpb24gfHwgYnVmZmVyQXR0cmlidXRlLnVzYWdlID09PSBEeW5hbWljRHJhd1VzYWdlICkge1xyXG5cclxuXHRcdFx0XHR0aGlzLmJhY2tlbmQudXBkYXRlQXR0cmlidXRlKCBhdHRyaWJ1dGUgKTtcclxuXHJcblx0XHRcdFx0ZGF0YS52ZXJzaW9uID0gYnVmZmVyQXR0cmlidXRlLnZlcnNpb247XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdF9nZXRCdWZmZXJBdHRyaWJ1dGUoIGF0dHJpYnV0ZSApIHtcclxuXHJcblx0XHRpZiAoIGF0dHJpYnV0ZS5pc0ludGVybGVhdmVkQnVmZmVyQXR0cmlidXRlICkgYXR0cmlidXRlID0gYXR0cmlidXRlLmRhdGE7XHJcblxyXG5cdFx0cmV0dXJuIGF0dHJpYnV0ZTtcclxuXHJcblx0fVxyXG5cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgQXR0cmlidXRlcztcclxuIiwiaW1wb3J0IERhdGFNYXAgZnJvbSAnLi9EYXRhTWFwLmpzJztcclxuaW1wb3J0IHsgQXR0cmlidXRlVHlwZSB9IGZyb20gJy4vQ29uc3RhbnRzLmpzJztcclxuXHJcbmltcG9ydCB7IFVpbnQxNkJ1ZmZlckF0dHJpYnV0ZSwgVWludDMyQnVmZmVyQXR0cmlidXRlIH0gZnJvbSAnLi4vLi4vY29yZS9CdWZmZXJBdHRyaWJ1dGUuanMnO1xyXG5cclxuZnVuY3Rpb24gYXJyYXlOZWVkc1VpbnQzMiggYXJyYXkgKSB7XHJcblxyXG5cdC8vIGFzc3VtZXMgbGFyZ2VyIHZhbHVlcyB1c3VhbGx5IG9uIGxhc3RcclxuXHJcblx0Zm9yICggbGV0IGkgPSBhcnJheS5sZW5ndGggLSAxOyBpID49IDA7IC0tIGkgKSB7XHJcblxyXG5cdFx0aWYgKCBhcnJheVsgaSBdID49IDY1NTM1ICkgcmV0dXJuIHRydWU7IC8vIGFjY291bnQgZm9yIFBSSU1JVElWRV9SRVNUQVJUX0ZJWEVEX0lOREVYLCAjMjQ1NjVcclxuXHJcblx0fVxyXG5cclxuXHRyZXR1cm4gZmFsc2U7XHJcblxyXG59XHJcblxyXG5mdW5jdGlvbiBnZXRXaXJlZnJhbWVWZXJzaW9uKCBnZW9tZXRyeSApIHtcclxuXHJcblx0cmV0dXJuICggZ2VvbWV0cnkuaW5kZXggIT09IG51bGwgKSA/IGdlb21ldHJ5LmluZGV4LnZlcnNpb24gOiBnZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uLnZlcnNpb247XHJcblxyXG59XHJcblxyXG5mdW5jdGlvbiBnZXRXaXJlZnJhbWVJbmRleCggZ2VvbWV0cnkgKSB7XHJcblxyXG5cdGNvbnN0IGluZGljZXMgPSBbXTtcclxuXHJcblx0Y29uc3QgZ2VvbWV0cnlJbmRleCA9IGdlb21ldHJ5LmluZGV4O1xyXG5cdGNvbnN0IGdlb21ldHJ5UG9zaXRpb24gPSBnZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uO1xyXG5cclxuXHRpZiAoIGdlb21ldHJ5SW5kZXggIT09IG51bGwgKSB7XHJcblxyXG5cdFx0Y29uc3QgYXJyYXkgPSBnZW9tZXRyeUluZGV4LmFycmF5O1xyXG5cclxuXHRcdGZvciAoIGxldCBpID0gMCwgbCA9IGFycmF5Lmxlbmd0aDsgaSA8IGw7IGkgKz0gMyApIHtcclxuXHJcblx0XHRcdGNvbnN0IGEgPSBhcnJheVsgaSArIDAgXTtcclxuXHRcdFx0Y29uc3QgYiA9IGFycmF5WyBpICsgMSBdO1xyXG5cdFx0XHRjb25zdCBjID0gYXJyYXlbIGkgKyAyIF07XHJcblxyXG5cdFx0XHRpbmRpY2VzLnB1c2goIGEsIGIsIGIsIGMsIGMsIGEgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH0gZWxzZSB7XHJcblxyXG5cdFx0Y29uc3QgYXJyYXkgPSBnZW9tZXRyeVBvc2l0aW9uLmFycmF5O1xyXG5cclxuXHRcdGZvciAoIGxldCBpID0gMCwgbCA9ICggYXJyYXkubGVuZ3RoIC8gMyApIC0gMTsgaSA8IGw7IGkgKz0gMyApIHtcclxuXHJcblx0XHRcdGNvbnN0IGEgPSBpICsgMDtcclxuXHRcdFx0Y29uc3QgYiA9IGkgKyAxO1xyXG5cdFx0XHRjb25zdCBjID0gaSArIDI7XHJcblxyXG5cdFx0XHRpbmRpY2VzLnB1c2goIGEsIGIsIGIsIGMsIGMsIGEgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0Y29uc3QgYXR0cmlidXRlID0gbmV3ICggYXJyYXlOZWVkc1VpbnQzMiggaW5kaWNlcyApID8gVWludDMyQnVmZmVyQXR0cmlidXRlIDogVWludDE2QnVmZmVyQXR0cmlidXRlICkoIGluZGljZXMsIDEgKTtcclxuXHRhdHRyaWJ1dGUudmVyc2lvbiA9IGdldFdpcmVmcmFtZVZlcnNpb24oIGdlb21ldHJ5ICk7XHJcblxyXG5cdHJldHVybiBhdHRyaWJ1dGU7XHJcblxyXG59XHJcblxyXG5jbGFzcyBHZW9tZXRyaWVzIGV4dGVuZHMgRGF0YU1hcCB7XHJcblxyXG5cdGNvbnN0cnVjdG9yKCBhdHRyaWJ1dGVzLCBpbmZvICkge1xyXG5cclxuXHRcdHN1cGVyKCk7XHJcblxyXG5cdFx0dGhpcy5hdHRyaWJ1dGVzID0gYXR0cmlidXRlcztcclxuXHRcdHRoaXMuaW5mbyA9IGluZm87XHJcblxyXG5cdFx0dGhpcy53aXJlZnJhbWVzID0gbmV3IFdlYWtNYXAoKTtcclxuXHJcblx0XHR0aGlzLmF0dHJpYnV0ZUNhbGwgPSBuZXcgV2Vha01hcCgpO1xyXG5cclxuXHR9XHJcblxyXG5cdGhhcyggcmVuZGVyT2JqZWN0ICkge1xyXG5cclxuXHRcdGNvbnN0IGdlb21ldHJ5ID0gcmVuZGVyT2JqZWN0Lmdlb21ldHJ5O1xyXG5cclxuXHRcdHJldHVybiBzdXBlci5oYXMoIGdlb21ldHJ5ICkgJiYgdGhpcy5nZXQoIGdlb21ldHJ5ICkuaW5pdGlhbGl6ZWQgPT09IHRydWU7XHJcblxyXG5cdH1cclxuXHJcblx0dXBkYXRlRm9yUmVuZGVyKCByZW5kZXJPYmplY3QgKSB7XHJcblxyXG5cdFx0aWYgKCB0aGlzLmhhcyggcmVuZGVyT2JqZWN0ICkgPT09IGZhbHNlICkgdGhpcy5pbml0R2VvbWV0cnkoIHJlbmRlck9iamVjdCApO1xyXG5cclxuXHRcdHRoaXMudXBkYXRlQXR0cmlidXRlcyggcmVuZGVyT2JqZWN0ICk7XHJcblxyXG5cdH1cclxuXHJcblx0aW5pdEdlb21ldHJ5KCByZW5kZXJPYmplY3QgKSB7XHJcblxyXG5cdFx0Y29uc3QgZ2VvbWV0cnkgPSByZW5kZXJPYmplY3QuZ2VvbWV0cnk7XHJcblx0XHRjb25zdCBnZW9tZXRyeURhdGEgPSB0aGlzLmdldCggZ2VvbWV0cnkgKTtcclxuXHJcblx0XHRnZW9tZXRyeURhdGEuaW5pdGlhbGl6ZWQgPSB0cnVlO1xyXG5cclxuXHRcdHRoaXMuaW5mby5tZW1vcnkuZ2VvbWV0cmllcyArKztcclxuXHJcblx0XHRjb25zdCBvbkRpc3Bvc2UgPSAoKSA9PiB7XHJcblxyXG5cdFx0XHR0aGlzLmluZm8ubWVtb3J5Lmdlb21ldHJpZXMgLS07XHJcblxyXG5cdFx0XHRjb25zdCBpbmRleCA9IGdlb21ldHJ5LmluZGV4O1xyXG5cdFx0XHRjb25zdCBnZW9tZXRyeUF0dHJpYnV0ZXMgPSByZW5kZXJPYmplY3QuZ2V0QXR0cmlidXRlcygpO1xyXG5cclxuXHRcdFx0aWYgKCBpbmRleCAhPT0gbnVsbCApIHtcclxuXHJcblx0XHRcdFx0dGhpcy5hdHRyaWJ1dGVzLmRlbGV0ZSggaW5kZXggKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGZvciAoIGNvbnN0IGdlb21ldHJ5QXR0cmlidXRlIG9mIGdlb21ldHJ5QXR0cmlidXRlcyApIHtcclxuXHJcblx0XHRcdFx0dGhpcy5hdHRyaWJ1dGVzLmRlbGV0ZSggZ2VvbWV0cnlBdHRyaWJ1dGUgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGNvbnN0IHdpcmVmcmFtZUF0dHJpYnV0ZSA9IHRoaXMud2lyZWZyYW1lcy5nZXQoIGdlb21ldHJ5ICk7XHJcblxyXG5cdFx0XHRpZiAoIHdpcmVmcmFtZUF0dHJpYnV0ZSAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHR0aGlzLmF0dHJpYnV0ZXMuZGVsZXRlKCB3aXJlZnJhbWVBdHRyaWJ1dGUgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGdlb21ldHJ5LnJlbW92ZUV2ZW50TGlzdGVuZXIoICdkaXNwb3NlJywgb25EaXNwb3NlICk7XHJcblxyXG5cdFx0fTtcclxuXHJcblx0XHRnZW9tZXRyeS5hZGRFdmVudExpc3RlbmVyKCAnZGlzcG9zZScsIG9uRGlzcG9zZSApO1xyXG5cclxuXHR9XHJcblxyXG5cdHVwZGF0ZUF0dHJpYnV0ZXMoIHJlbmRlck9iamVjdCApIHtcclxuXHJcblx0XHQvLyBhdHRyaWJ1dGVzXHJcblxyXG5cdFx0Y29uc3QgYXR0cmlidXRlcyA9IHJlbmRlck9iamVjdC5nZXRBdHRyaWJ1dGVzKCk7XHJcblxyXG5cdFx0Zm9yICggY29uc3QgYXR0cmlidXRlIG9mIGF0dHJpYnV0ZXMgKSB7XHJcblxyXG5cdFx0XHRpZiAoIGF0dHJpYnV0ZS5pc1N0b3JhZ2VCdWZmZXJBdHRyaWJ1dGUgfHwgYXR0cmlidXRlLmlzU3RvcmFnZUluc3RhbmNlZEJ1ZmZlckF0dHJpYnV0ZSApIHtcclxuXHJcblx0XHRcdFx0dGhpcy51cGRhdGVBdHRyaWJ1dGUoIGF0dHJpYnV0ZSwgQXR0cmlidXRlVHlwZS5TVE9SQUdFICk7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHR0aGlzLnVwZGF0ZUF0dHJpYnV0ZSggYXR0cmlidXRlLCBBdHRyaWJ1dGVUeXBlLlZFUlRFWCApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvLyBpbmRleGVzXHJcblxyXG5cdFx0Y29uc3QgaW5kZXggPSB0aGlzLmdldEluZGV4KCByZW5kZXJPYmplY3QgKTtcclxuXHJcblx0XHRpZiAoIGluZGV4ICE9PSBudWxsICkge1xyXG5cclxuXHRcdFx0dGhpcy51cGRhdGVBdHRyaWJ1dGUoIGluZGV4LCBBdHRyaWJ1dGVUeXBlLklOREVYICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIGluZGlyZWN0XHJcblxyXG5cdFx0Y29uc3QgaW5kaXJlY3QgPSByZW5kZXJPYmplY3QuZ2VvbWV0cnkuaW5kaXJlY3Q7XHJcblxyXG5cdFx0aWYgKCBpbmRpcmVjdCAhPT0gbnVsbCApIHtcclxuXHJcblx0XHRcdHRoaXMudXBkYXRlQXR0cmlidXRlKCBpbmRpcmVjdCwgQXR0cmlidXRlVHlwZS5JTkRJUkVDVCApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHR1cGRhdGVBdHRyaWJ1dGUoIGF0dHJpYnV0ZSwgdHlwZSApIHtcclxuXHJcblx0XHRjb25zdCBjYWxsSWQgPSB0aGlzLmluZm8ucmVuZGVyLmNhbGxzO1xyXG5cclxuXHRcdGlmICggISBhdHRyaWJ1dGUuaXNJbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZSApIHtcclxuXHJcblx0XHRcdGlmICggdGhpcy5hdHRyaWJ1dGVDYWxsLmdldCggYXR0cmlidXRlICkgIT09IGNhbGxJZCApIHtcclxuXHJcblx0XHRcdFx0dGhpcy5hdHRyaWJ1dGVzLnVwZGF0ZSggYXR0cmlidXRlLCB0eXBlICk7XHJcblxyXG5cdFx0XHRcdHRoaXMuYXR0cmlidXRlQ2FsbC5zZXQoIGF0dHJpYnV0ZSwgY2FsbElkICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdGlmICggdGhpcy5hdHRyaWJ1dGVDYWxsLmdldCggYXR0cmlidXRlICkgPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0dGhpcy5hdHRyaWJ1dGVzLnVwZGF0ZSggYXR0cmlidXRlLCB0eXBlICk7XHJcblxyXG5cdFx0XHRcdHRoaXMuYXR0cmlidXRlQ2FsbC5zZXQoIGF0dHJpYnV0ZSwgY2FsbElkICk7XHJcblxyXG5cdFx0XHR9IGVsc2UgaWYgKCB0aGlzLmF0dHJpYnV0ZUNhbGwuZ2V0KCBhdHRyaWJ1dGUuZGF0YSApICE9PSBjYWxsSWQgKSB7XHJcblxyXG5cdFx0XHRcdHRoaXMuYXR0cmlidXRlcy51cGRhdGUoIGF0dHJpYnV0ZSwgdHlwZSApO1xyXG5cclxuXHRcdFx0XHR0aGlzLmF0dHJpYnV0ZUNhbGwuc2V0KCBhdHRyaWJ1dGUuZGF0YSwgY2FsbElkICk7XHJcblxyXG5cdFx0XHRcdHRoaXMuYXR0cmlidXRlQ2FsbC5zZXQoIGF0dHJpYnV0ZSwgY2FsbElkICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdGdldEluZGlyZWN0KCByZW5kZXJPYmplY3QgKSB7XHJcblxyXG5cdFx0cmV0dXJuIHJlbmRlck9iamVjdC5nZW9tZXRyeS5pbmRpcmVjdDtcclxuXHJcblx0fVxyXG5cclxuXHRnZXRJbmRleCggcmVuZGVyT2JqZWN0ICkge1xyXG5cclxuXHRcdGNvbnN0IHsgZ2VvbWV0cnksIG1hdGVyaWFsIH0gPSByZW5kZXJPYmplY3Q7XHJcblxyXG5cdFx0bGV0IGluZGV4ID0gZ2VvbWV0cnkuaW5kZXg7XHJcblxyXG5cdFx0aWYgKCBtYXRlcmlhbC53aXJlZnJhbWUgPT09IHRydWUgKSB7XHJcblxyXG5cdFx0XHRjb25zdCB3aXJlZnJhbWVzID0gdGhpcy53aXJlZnJhbWVzO1xyXG5cclxuXHRcdFx0bGV0IHdpcmVmcmFtZUF0dHJpYnV0ZSA9IHdpcmVmcmFtZXMuZ2V0KCBnZW9tZXRyeSApO1xyXG5cclxuXHRcdFx0aWYgKCB3aXJlZnJhbWVBdHRyaWJ1dGUgPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0d2lyZWZyYW1lQXR0cmlidXRlID0gZ2V0V2lyZWZyYW1lSW5kZXgoIGdlb21ldHJ5ICk7XHJcblxyXG5cdFx0XHRcdHdpcmVmcmFtZXMuc2V0KCBnZW9tZXRyeSwgd2lyZWZyYW1lQXR0cmlidXRlICk7XHJcblxyXG5cdFx0XHR9IGVsc2UgaWYgKCB3aXJlZnJhbWVBdHRyaWJ1dGUudmVyc2lvbiAhPT0gZ2V0V2lyZWZyYW1lVmVyc2lvbiggZ2VvbWV0cnkgKSApIHtcclxuXHJcblx0XHRcdFx0dGhpcy5hdHRyaWJ1dGVzLmRlbGV0ZSggd2lyZWZyYW1lQXR0cmlidXRlICk7XHJcblxyXG5cdFx0XHRcdHdpcmVmcmFtZUF0dHJpYnV0ZSA9IGdldFdpcmVmcmFtZUluZGV4KCBnZW9tZXRyeSApO1xyXG5cclxuXHRcdFx0XHR3aXJlZnJhbWVzLnNldCggZ2VvbWV0cnksIHdpcmVmcmFtZUF0dHJpYnV0ZSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aW5kZXggPSB3aXJlZnJhbWVBdHRyaWJ1dGU7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBpbmRleDtcclxuXHJcblx0fVxyXG5cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgR2VvbWV0cmllcztcclxuIiwiY2xhc3MgSW5mbyB7XHJcblxyXG5cdGNvbnN0cnVjdG9yKCkge1xyXG5cclxuXHRcdHRoaXMuYXV0b1Jlc2V0ID0gdHJ1ZTtcclxuXHJcblx0XHR0aGlzLmZyYW1lID0gMDtcclxuXHRcdHRoaXMuY2FsbHMgPSAwO1xyXG5cclxuXHRcdHRoaXMucmVuZGVyID0ge1xyXG5cdFx0XHRjYWxsczogMCxcclxuXHRcdFx0ZnJhbWVDYWxsczogMCxcclxuXHRcdFx0ZHJhd0NhbGxzOiAwLFxyXG5cdFx0XHR0cmlhbmdsZXM6IDAsXHJcblx0XHRcdHBvaW50czogMCxcclxuXHRcdFx0bGluZXM6IDAsXHJcblx0XHRcdHRpbWVzdGFtcDogMCxcclxuXHRcdFx0cHJldmlvdXNGcmFtZUNhbGxzOiAwLFxyXG5cdFx0XHR0aW1lc3RhbXBDYWxsczogMFxyXG5cdFx0fTtcclxuXHJcblx0XHR0aGlzLmNvbXB1dGUgPSB7XHJcblx0XHRcdGNhbGxzOiAwLFxyXG5cdFx0XHRmcmFtZUNhbGxzOiAwLFxyXG5cdFx0XHR0aW1lc3RhbXA6IDAsXHJcblx0XHRcdHByZXZpb3VzRnJhbWVDYWxsczogMCxcclxuXHRcdFx0dGltZXN0YW1wQ2FsbHM6IDBcclxuXHRcdH07XHJcblxyXG5cdFx0dGhpcy5tZW1vcnkgPSB7XHJcblx0XHRcdGdlb21ldHJpZXM6IDAsXHJcblx0XHRcdHRleHR1cmVzOiAwXHJcblx0XHR9O1xyXG5cclxuXHR9XHJcblxyXG5cdHVwZGF0ZSggb2JqZWN0LCBjb3VudCwgaW5zdGFuY2VDb3VudCApIHtcclxuXHJcblx0XHR0aGlzLnJlbmRlci5kcmF3Q2FsbHMgKys7XHJcblxyXG5cdFx0aWYgKCBvYmplY3QuaXNNZXNoIHx8IG9iamVjdC5pc1Nwcml0ZSApIHtcclxuXHJcblx0XHRcdHRoaXMucmVuZGVyLnRyaWFuZ2xlcyArPSBpbnN0YW5jZUNvdW50ICogKCBjb3VudCAvIDMgKTtcclxuXHJcblx0XHR9IGVsc2UgaWYgKCBvYmplY3QuaXNQb2ludHMgKSB7XHJcblxyXG5cdFx0XHR0aGlzLnJlbmRlci5wb2ludHMgKz0gaW5zdGFuY2VDb3VudCAqIGNvdW50O1xyXG5cclxuXHRcdH0gZWxzZSBpZiAoIG9iamVjdC5pc0xpbmVTZWdtZW50cyApIHtcclxuXHJcblx0XHRcdHRoaXMucmVuZGVyLmxpbmVzICs9IGluc3RhbmNlQ291bnQgKiAoIGNvdW50IC8gMiApO1xyXG5cclxuXHRcdH0gZWxzZSBpZiAoIG9iamVjdC5pc0xpbmUgKSB7XHJcblxyXG5cdFx0XHR0aGlzLnJlbmRlci5saW5lcyArPSBpbnN0YW5jZUNvdW50ICogKCBjb3VudCAtIDEgKTtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLldlYkdQVUluZm86IFVua25vd24gb2JqZWN0IHR5cGUuJyApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHR1cGRhdGVUaW1lc3RhbXAoIHR5cGUsIHRpbWUgKSB7XHJcblxyXG5cdFx0aWYgKCB0aGlzWyB0eXBlIF0udGltZXN0YW1wQ2FsbHMgPT09IDAgKSB7XHJcblxyXG5cdFx0XHR0aGlzWyB0eXBlIF0udGltZXN0YW1wID0gMDtcclxuXHJcblx0XHR9XHJcblxyXG5cclxuXHRcdHRoaXNbIHR5cGUgXS50aW1lc3RhbXAgKz0gdGltZTtcclxuXHJcblx0XHR0aGlzWyB0eXBlIF0udGltZXN0YW1wQ2FsbHMgKys7XHJcblxyXG5cclxuXHRcdGlmICggdGhpc1sgdHlwZSBdLnRpbWVzdGFtcENhbGxzID49IHRoaXNbIHR5cGUgXS5wcmV2aW91c0ZyYW1lQ2FsbHMgKSB7XHJcblxyXG5cdFx0XHR0aGlzWyB0eXBlIF0udGltZXN0YW1wQ2FsbHMgPSAwO1xyXG5cclxuXHRcdH1cclxuXHJcblxyXG5cdH1cclxuXHJcblx0cmVzZXQoKSB7XHJcblxyXG5cdFx0Y29uc3QgcHJldmlvdXNSZW5kZXJGcmFtZUNhbGxzID0gdGhpcy5yZW5kZXIuZnJhbWVDYWxscztcclxuXHRcdHRoaXMucmVuZGVyLnByZXZpb3VzRnJhbWVDYWxscyA9IHByZXZpb3VzUmVuZGVyRnJhbWVDYWxscztcclxuXHJcblx0XHRjb25zdCBwcmV2aW91c0NvbXB1dGVGcmFtZUNhbGxzID0gdGhpcy5jb21wdXRlLmZyYW1lQ2FsbHM7XHJcblx0XHR0aGlzLmNvbXB1dGUucHJldmlvdXNGcmFtZUNhbGxzID0gcHJldmlvdXNDb21wdXRlRnJhbWVDYWxscztcclxuXHJcblxyXG5cdFx0dGhpcy5yZW5kZXIuZHJhd0NhbGxzID0gMDtcclxuXHRcdHRoaXMucmVuZGVyLmZyYW1lQ2FsbHMgPSAwO1xyXG5cdFx0dGhpcy5jb21wdXRlLmZyYW1lQ2FsbHMgPSAwO1xyXG5cclxuXHRcdHRoaXMucmVuZGVyLnRyaWFuZ2xlcyA9IDA7XHJcblx0XHR0aGlzLnJlbmRlci5wb2ludHMgPSAwO1xyXG5cdFx0dGhpcy5yZW5kZXIubGluZXMgPSAwO1xyXG5cclxuXHJcblx0fVxyXG5cclxuXHRkaXNwb3NlKCkge1xyXG5cclxuXHRcdHRoaXMucmVzZXQoKTtcclxuXHJcblx0XHR0aGlzLmNhbGxzID0gMDtcclxuXHJcblx0XHR0aGlzLnJlbmRlci5jYWxscyA9IDA7XHJcblx0XHR0aGlzLmNvbXB1dGUuY2FsbHMgPSAwO1xyXG5cclxuXHRcdHRoaXMucmVuZGVyLnRpbWVzdGFtcCA9IDA7XHJcblx0XHR0aGlzLmNvbXB1dGUudGltZXN0YW1wID0gMDtcclxuXHRcdHRoaXMubWVtb3J5Lmdlb21ldHJpZXMgPSAwO1xyXG5cdFx0dGhpcy5tZW1vcnkudGV4dHVyZXMgPSAwO1xyXG5cclxuXHR9XHJcblxyXG59XHJcblxyXG5cclxuZXhwb3J0IGRlZmF1bHQgSW5mbztcclxuIiwiY2xhc3MgUGlwZWxpbmUge1xyXG5cclxuXHRjb25zdHJ1Y3RvciggY2FjaGVLZXkgKSB7XHJcblxyXG5cdFx0dGhpcy5jYWNoZUtleSA9IGNhY2hlS2V5O1xyXG5cclxuXHRcdHRoaXMudXNlZFRpbWVzID0gMDtcclxuXHJcblx0fVxyXG5cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgUGlwZWxpbmU7XHJcbiIsImltcG9ydCBQaXBlbGluZSBmcm9tICcuL1BpcGVsaW5lLmpzJztcclxuXHJcbmNsYXNzIFJlbmRlclBpcGVsaW5lIGV4dGVuZHMgUGlwZWxpbmUge1xyXG5cclxuXHRjb25zdHJ1Y3RvciggY2FjaGVLZXksIHZlcnRleFByb2dyYW0sIGZyYWdtZW50UHJvZ3JhbSApIHtcclxuXHJcblx0XHRzdXBlciggY2FjaGVLZXkgKTtcclxuXHJcblx0XHR0aGlzLnZlcnRleFByb2dyYW0gPSB2ZXJ0ZXhQcm9ncmFtO1xyXG5cdFx0dGhpcy5mcmFnbWVudFByb2dyYW0gPSBmcmFnbWVudFByb2dyYW07XHJcblxyXG5cdH1cclxuXHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IFJlbmRlclBpcGVsaW5lO1xyXG4iLCJpbXBvcnQgUGlwZWxpbmUgZnJvbSAnLi9QaXBlbGluZS5qcyc7XHJcblxyXG5jbGFzcyBDb21wdXRlUGlwZWxpbmUgZXh0ZW5kcyBQaXBlbGluZSB7XHJcblxyXG5cdGNvbnN0cnVjdG9yKCBjYWNoZUtleSwgY29tcHV0ZVByb2dyYW0gKSB7XHJcblxyXG5cdFx0c3VwZXIoIGNhY2hlS2V5ICk7XHJcblxyXG5cdFx0dGhpcy5jb21wdXRlUHJvZ3JhbSA9IGNvbXB1dGVQcm9ncmFtO1xyXG5cclxuXHRcdHRoaXMuaXNDb21wdXRlUGlwZWxpbmUgPSB0cnVlO1xyXG5cclxuXHR9XHJcblxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBDb21wdXRlUGlwZWxpbmU7XHJcbiIsImxldCBfaWQgPSAwO1xyXG5cclxuY2xhc3MgUHJvZ3JhbW1hYmxlU3RhZ2Uge1xyXG5cclxuXHRjb25zdHJ1Y3RvciggY29kZSwgdHlwZSwgdHJhbnNmb3JtcyA9IG51bGwsIGF0dHJpYnV0ZXMgPSBudWxsICkge1xyXG5cclxuXHRcdHRoaXMuaWQgPSBfaWQgKys7XHJcblxyXG5cdFx0dGhpcy5jb2RlID0gY29kZTtcclxuXHRcdHRoaXMuc3RhZ2UgPSB0eXBlO1xyXG5cdFx0dGhpcy50cmFuc2Zvcm1zID0gdHJhbnNmb3JtcztcclxuXHRcdHRoaXMuYXR0cmlidXRlcyA9IGF0dHJpYnV0ZXM7XHJcblxyXG5cdFx0dGhpcy51c2VkVGltZXMgPSAwO1xyXG5cclxuXHR9XHJcblxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBQcm9ncmFtbWFibGVTdGFnZTtcclxuIiwiaW1wb3J0IERhdGFNYXAgZnJvbSAnLi9EYXRhTWFwLmpzJztcclxuaW1wb3J0IFJlbmRlclBpcGVsaW5lIGZyb20gJy4vUmVuZGVyUGlwZWxpbmUuanMnO1xyXG5pbXBvcnQgQ29tcHV0ZVBpcGVsaW5lIGZyb20gJy4vQ29tcHV0ZVBpcGVsaW5lLmpzJztcclxuaW1wb3J0IFByb2dyYW1tYWJsZVN0YWdlIGZyb20gJy4vUHJvZ3JhbW1hYmxlU3RhZ2UuanMnO1xyXG5cclxuY2xhc3MgUGlwZWxpbmVzIGV4dGVuZHMgRGF0YU1hcCB7XHJcblxyXG5cdGNvbnN0cnVjdG9yKCBiYWNrZW5kLCBub2RlcyApIHtcclxuXHJcblx0XHRzdXBlcigpO1xyXG5cclxuXHRcdHRoaXMuYmFja2VuZCA9IGJhY2tlbmQ7XHJcblx0XHR0aGlzLm5vZGVzID0gbm9kZXM7XHJcblxyXG5cdFx0dGhpcy5iaW5kaW5ncyA9IG51bGw7IC8vIHNldCBieSB0aGUgYmluZGluZ3NcclxuXHJcblx0XHR0aGlzLmNhY2hlcyA9IG5ldyBNYXAoKTtcclxuXHRcdHRoaXMucHJvZ3JhbXMgPSB7XHJcblx0XHRcdHZlcnRleDogbmV3IE1hcCgpLFxyXG5cdFx0XHRmcmFnbWVudDogbmV3IE1hcCgpLFxyXG5cdFx0XHRjb21wdXRlOiBuZXcgTWFwKClcclxuXHRcdH07XHJcblxyXG5cdH1cclxuXHJcblx0Z2V0Rm9yQ29tcHV0ZSggY29tcHV0ZU5vZGUsIGJpbmRpbmdzICkge1xyXG5cclxuXHRcdGNvbnN0IHsgYmFja2VuZCB9ID0gdGhpcztcclxuXHJcblx0XHRjb25zdCBkYXRhID0gdGhpcy5nZXQoIGNvbXB1dGVOb2RlICk7XHJcblxyXG5cdFx0aWYgKCB0aGlzLl9uZWVkc0NvbXB1dGVVcGRhdGUoIGNvbXB1dGVOb2RlICkgKSB7XHJcblxyXG5cdFx0XHRjb25zdCBwcmV2aW91c1BpcGVsaW5lID0gZGF0YS5waXBlbGluZTtcclxuXHJcblx0XHRcdGlmICggcHJldmlvdXNQaXBlbGluZSApIHtcclxuXHJcblx0XHRcdFx0cHJldmlvdXNQaXBlbGluZS51c2VkVGltZXMgLS07XHJcblx0XHRcdFx0cHJldmlvdXNQaXBlbGluZS5jb21wdXRlUHJvZ3JhbS51c2VkVGltZXMgLS07XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBnZXQgc2hhZGVyXHJcblxyXG5cdFx0XHRjb25zdCBub2RlQnVpbGRlclN0YXRlID0gdGhpcy5ub2Rlcy5nZXRGb3JDb21wdXRlKCBjb21wdXRlTm9kZSApO1xyXG5cclxuXHRcdFx0Ly8gcHJvZ3JhbW1hYmxlIHN0YWdlXHJcblxyXG5cdFx0XHRsZXQgc3RhZ2VDb21wdXRlID0gdGhpcy5wcm9ncmFtcy5jb21wdXRlLmdldCggbm9kZUJ1aWxkZXJTdGF0ZS5jb21wdXRlU2hhZGVyICk7XHJcblxyXG5cdFx0XHRpZiAoIHN0YWdlQ29tcHV0ZSA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRpZiAoIHByZXZpb3VzUGlwZWxpbmUgJiYgcHJldmlvdXNQaXBlbGluZS5jb21wdXRlUHJvZ3JhbS51c2VkVGltZXMgPT09IDAgKSB0aGlzLl9yZWxlYXNlUHJvZ3JhbSggcHJldmlvdXNQaXBlbGluZS5jb21wdXRlUHJvZ3JhbSApO1xyXG5cclxuXHRcdFx0XHRzdGFnZUNvbXB1dGUgPSBuZXcgUHJvZ3JhbW1hYmxlU3RhZ2UoIG5vZGVCdWlsZGVyU3RhdGUuY29tcHV0ZVNoYWRlciwgJ2NvbXB1dGUnLCBub2RlQnVpbGRlclN0YXRlLnRyYW5zZm9ybXMsIG5vZGVCdWlsZGVyU3RhdGUubm9kZUF0dHJpYnV0ZXMgKTtcclxuXHRcdFx0XHR0aGlzLnByb2dyYW1zLmNvbXB1dGUuc2V0KCBub2RlQnVpbGRlclN0YXRlLmNvbXB1dGVTaGFkZXIsIHN0YWdlQ29tcHV0ZSApO1xyXG5cclxuXHRcdFx0XHRiYWNrZW5kLmNyZWF0ZVByb2dyYW0oIHN0YWdlQ29tcHV0ZSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gZGV0ZXJtaW5lIGNvbXB1dGUgcGlwZWxpbmVcclxuXHJcblx0XHRcdGNvbnN0IGNhY2hlS2V5ID0gdGhpcy5fZ2V0Q29tcHV0ZUNhY2hlS2V5KCBjb21wdXRlTm9kZSwgc3RhZ2VDb21wdXRlICk7XHJcblxyXG5cdFx0XHRsZXQgcGlwZWxpbmUgPSB0aGlzLmNhY2hlcy5nZXQoIGNhY2hlS2V5ICk7XHJcblxyXG5cdFx0XHRpZiAoIHBpcGVsaW5lID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdGlmICggcHJldmlvdXNQaXBlbGluZSAmJiBwcmV2aW91c1BpcGVsaW5lLnVzZWRUaW1lcyA9PT0gMCApIHRoaXMuX3JlbGVhc2VQaXBlbGluZSggcHJldmlvdXNQaXBlbGluZSApO1xyXG5cclxuXHRcdFx0XHRwaXBlbGluZSA9IHRoaXMuX2dldENvbXB1dGVQaXBlbGluZSggY29tcHV0ZU5vZGUsIHN0YWdlQ29tcHV0ZSwgY2FjaGVLZXksIGJpbmRpbmdzICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBrZWVwIHRyYWNrIG9mIGFsbCB1c2VkIHRpbWVzXHJcblxyXG5cdFx0XHRwaXBlbGluZS51c2VkVGltZXMgKys7XHJcblx0XHRcdHN0YWdlQ29tcHV0ZS51c2VkVGltZXMgKys7XHJcblxyXG5cdFx0XHQvL1xyXG5cclxuXHRcdFx0ZGF0YS52ZXJzaW9uID0gY29tcHV0ZU5vZGUudmVyc2lvbjtcclxuXHRcdFx0ZGF0YS5waXBlbGluZSA9IHBpcGVsaW5lO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gZGF0YS5waXBlbGluZTtcclxuXHJcblx0fVxyXG5cclxuXHRnZXRGb3JSZW5kZXIoIHJlbmRlck9iamVjdCwgcHJvbWlzZXMgPSBudWxsICkge1xyXG5cclxuXHRcdGNvbnN0IHsgYmFja2VuZCB9ID0gdGhpcztcclxuXHJcblx0XHRjb25zdCBkYXRhID0gdGhpcy5nZXQoIHJlbmRlck9iamVjdCApO1xyXG5cclxuXHRcdGlmICggdGhpcy5fbmVlZHNSZW5kZXJVcGRhdGUoIHJlbmRlck9iamVjdCApICkge1xyXG5cclxuXHRcdFx0Y29uc3QgcHJldmlvdXNQaXBlbGluZSA9IGRhdGEucGlwZWxpbmU7XHJcblxyXG5cdFx0XHRpZiAoIHByZXZpb3VzUGlwZWxpbmUgKSB7XHJcblxyXG5cdFx0XHRcdHByZXZpb3VzUGlwZWxpbmUudXNlZFRpbWVzIC0tO1xyXG5cdFx0XHRcdHByZXZpb3VzUGlwZWxpbmUudmVydGV4UHJvZ3JhbS51c2VkVGltZXMgLS07XHJcblx0XHRcdFx0cHJldmlvdXNQaXBlbGluZS5mcmFnbWVudFByb2dyYW0udXNlZFRpbWVzIC0tO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gZ2V0IHNoYWRlclxyXG5cclxuXHRcdFx0Y29uc3Qgbm9kZUJ1aWxkZXJTdGF0ZSA9IHJlbmRlck9iamVjdC5nZXROb2RlQnVpbGRlclN0YXRlKCk7XHJcblxyXG5cdFx0XHQvLyBwcm9ncmFtbWFibGUgc3RhZ2VzXHJcblxyXG5cdFx0XHRsZXQgc3RhZ2VWZXJ0ZXggPSB0aGlzLnByb2dyYW1zLnZlcnRleC5nZXQoIG5vZGVCdWlsZGVyU3RhdGUudmVydGV4U2hhZGVyICk7XHJcblxyXG5cdFx0XHRpZiAoIHN0YWdlVmVydGV4ID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdGlmICggcHJldmlvdXNQaXBlbGluZSAmJiBwcmV2aW91c1BpcGVsaW5lLnZlcnRleFByb2dyYW0udXNlZFRpbWVzID09PSAwICkgdGhpcy5fcmVsZWFzZVByb2dyYW0oIHByZXZpb3VzUGlwZWxpbmUudmVydGV4UHJvZ3JhbSApO1xyXG5cclxuXHRcdFx0XHRzdGFnZVZlcnRleCA9IG5ldyBQcm9ncmFtbWFibGVTdGFnZSggbm9kZUJ1aWxkZXJTdGF0ZS52ZXJ0ZXhTaGFkZXIsICd2ZXJ0ZXgnICk7XHJcblx0XHRcdFx0dGhpcy5wcm9ncmFtcy52ZXJ0ZXguc2V0KCBub2RlQnVpbGRlclN0YXRlLnZlcnRleFNoYWRlciwgc3RhZ2VWZXJ0ZXggKTtcclxuXHJcblx0XHRcdFx0YmFja2VuZC5jcmVhdGVQcm9ncmFtKCBzdGFnZVZlcnRleCApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0bGV0IHN0YWdlRnJhZ21lbnQgPSB0aGlzLnByb2dyYW1zLmZyYWdtZW50LmdldCggbm9kZUJ1aWxkZXJTdGF0ZS5mcmFnbWVudFNoYWRlciApO1xyXG5cclxuXHRcdFx0aWYgKCBzdGFnZUZyYWdtZW50ID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdGlmICggcHJldmlvdXNQaXBlbGluZSAmJiBwcmV2aW91c1BpcGVsaW5lLmZyYWdtZW50UHJvZ3JhbS51c2VkVGltZXMgPT09IDAgKSB0aGlzLl9yZWxlYXNlUHJvZ3JhbSggcHJldmlvdXNQaXBlbGluZS5mcmFnbWVudFByb2dyYW0gKTtcclxuXHJcblx0XHRcdFx0c3RhZ2VGcmFnbWVudCA9IG5ldyBQcm9ncmFtbWFibGVTdGFnZSggbm9kZUJ1aWxkZXJTdGF0ZS5mcmFnbWVudFNoYWRlciwgJ2ZyYWdtZW50JyApO1xyXG5cdFx0XHRcdHRoaXMucHJvZ3JhbXMuZnJhZ21lbnQuc2V0KCBub2RlQnVpbGRlclN0YXRlLmZyYWdtZW50U2hhZGVyLCBzdGFnZUZyYWdtZW50ICk7XHJcblxyXG5cdFx0XHRcdGJhY2tlbmQuY3JlYXRlUHJvZ3JhbSggc3RhZ2VGcmFnbWVudCApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gZGV0ZXJtaW5lIHJlbmRlciBwaXBlbGluZVxyXG5cclxuXHRcdFx0Y29uc3QgY2FjaGVLZXkgPSB0aGlzLl9nZXRSZW5kZXJDYWNoZUtleSggcmVuZGVyT2JqZWN0LCBzdGFnZVZlcnRleCwgc3RhZ2VGcmFnbWVudCApO1xyXG5cclxuXHRcdFx0bGV0IHBpcGVsaW5lID0gdGhpcy5jYWNoZXMuZ2V0KCBjYWNoZUtleSApO1xyXG5cclxuXHRcdFx0aWYgKCBwaXBlbGluZSA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRpZiAoIHByZXZpb3VzUGlwZWxpbmUgJiYgcHJldmlvdXNQaXBlbGluZS51c2VkVGltZXMgPT09IDAgKSB0aGlzLl9yZWxlYXNlUGlwZWxpbmUoIHByZXZpb3VzUGlwZWxpbmUgKTtcclxuXHJcblx0XHRcdFx0cGlwZWxpbmUgPSB0aGlzLl9nZXRSZW5kZXJQaXBlbGluZSggcmVuZGVyT2JqZWN0LCBzdGFnZVZlcnRleCwgc3RhZ2VGcmFnbWVudCwgY2FjaGVLZXksIHByb21pc2VzICk7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRyZW5kZXJPYmplY3QucGlwZWxpbmUgPSBwaXBlbGluZTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIGtlZXAgdHJhY2sgb2YgYWxsIHVzZWQgdGltZXNcclxuXHJcblx0XHRcdHBpcGVsaW5lLnVzZWRUaW1lcyArKztcclxuXHRcdFx0c3RhZ2VWZXJ0ZXgudXNlZFRpbWVzICsrO1xyXG5cdFx0XHRzdGFnZUZyYWdtZW50LnVzZWRUaW1lcyArKztcclxuXHJcblx0XHRcdC8vXHJcblxyXG5cdFx0XHRkYXRhLnBpcGVsaW5lID0gcGlwZWxpbmU7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBkYXRhLnBpcGVsaW5lO1xyXG5cclxuXHR9XHJcblxyXG5cdGRlbGV0ZSggb2JqZWN0ICkge1xyXG5cclxuXHRcdGNvbnN0IHBpcGVsaW5lID0gdGhpcy5nZXQoIG9iamVjdCApLnBpcGVsaW5lO1xyXG5cclxuXHRcdGlmICggcGlwZWxpbmUgKSB7XHJcblxyXG5cdFx0XHQvLyBwaXBlbGluZVxyXG5cclxuXHRcdFx0cGlwZWxpbmUudXNlZFRpbWVzIC0tO1xyXG5cclxuXHRcdFx0aWYgKCBwaXBlbGluZS51c2VkVGltZXMgPT09IDAgKSB0aGlzLl9yZWxlYXNlUGlwZWxpbmUoIHBpcGVsaW5lICk7XHJcblxyXG5cdFx0XHQvLyBwcm9ncmFtc1xyXG5cclxuXHRcdFx0aWYgKCBwaXBlbGluZS5pc0NvbXB1dGVQaXBlbGluZSApIHtcclxuXHJcblx0XHRcdFx0cGlwZWxpbmUuY29tcHV0ZVByb2dyYW0udXNlZFRpbWVzIC0tO1xyXG5cclxuXHRcdFx0XHRpZiAoIHBpcGVsaW5lLmNvbXB1dGVQcm9ncmFtLnVzZWRUaW1lcyA9PT0gMCApIHRoaXMuX3JlbGVhc2VQcm9ncmFtKCBwaXBlbGluZS5jb21wdXRlUHJvZ3JhbSApO1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0cGlwZWxpbmUuZnJhZ21lbnRQcm9ncmFtLnVzZWRUaW1lcyAtLTtcclxuXHRcdFx0XHRwaXBlbGluZS52ZXJ0ZXhQcm9ncmFtLnVzZWRUaW1lcyAtLTtcclxuXHJcblx0XHRcdFx0aWYgKCBwaXBlbGluZS52ZXJ0ZXhQcm9ncmFtLnVzZWRUaW1lcyA9PT0gMCApIHRoaXMuX3JlbGVhc2VQcm9ncmFtKCBwaXBlbGluZS52ZXJ0ZXhQcm9ncmFtICk7XHJcblx0XHRcdFx0aWYgKCBwaXBlbGluZS5mcmFnbWVudFByb2dyYW0udXNlZFRpbWVzID09PSAwICkgdGhpcy5fcmVsZWFzZVByb2dyYW0oIHBpcGVsaW5lLmZyYWdtZW50UHJvZ3JhbSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gc3VwZXIuZGVsZXRlKCBvYmplY3QgKTtcclxuXHJcblx0fVxyXG5cclxuXHRkaXNwb3NlKCkge1xyXG5cclxuXHRcdHN1cGVyLmRpc3Bvc2UoKTtcclxuXHJcblx0XHR0aGlzLmNhY2hlcyA9IG5ldyBNYXAoKTtcclxuXHRcdHRoaXMucHJvZ3JhbXMgPSB7XHJcblx0XHRcdHZlcnRleDogbmV3IE1hcCgpLFxyXG5cdFx0XHRmcmFnbWVudDogbmV3IE1hcCgpLFxyXG5cdFx0XHRjb21wdXRlOiBuZXcgTWFwKClcclxuXHRcdH07XHJcblxyXG5cdH1cclxuXHJcblx0dXBkYXRlRm9yUmVuZGVyKCByZW5kZXJPYmplY3QgKSB7XHJcblxyXG5cdFx0dGhpcy5nZXRGb3JSZW5kZXIoIHJlbmRlck9iamVjdCApO1xyXG5cclxuXHR9XHJcblxyXG5cdF9nZXRDb21wdXRlUGlwZWxpbmUoIGNvbXB1dGVOb2RlLCBzdGFnZUNvbXB1dGUsIGNhY2hlS2V5LCBiaW5kaW5ncyApIHtcclxuXHJcblx0XHQvLyBjaGVjayBmb3IgZXhpc3RpbmcgcGlwZWxpbmVcclxuXHJcblx0XHRjYWNoZUtleSA9IGNhY2hlS2V5IHx8IHRoaXMuX2dldENvbXB1dGVDYWNoZUtleSggY29tcHV0ZU5vZGUsIHN0YWdlQ29tcHV0ZSApO1xyXG5cclxuXHRcdGxldCBwaXBlbGluZSA9IHRoaXMuY2FjaGVzLmdldCggY2FjaGVLZXkgKTtcclxuXHJcblx0XHRpZiAoIHBpcGVsaW5lID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRwaXBlbGluZSA9IG5ldyBDb21wdXRlUGlwZWxpbmUoIGNhY2hlS2V5LCBzdGFnZUNvbXB1dGUgKTtcclxuXHJcblx0XHRcdHRoaXMuY2FjaGVzLnNldCggY2FjaGVLZXksIHBpcGVsaW5lICk7XHJcblxyXG5cdFx0XHR0aGlzLmJhY2tlbmQuY3JlYXRlQ29tcHV0ZVBpcGVsaW5lKCBwaXBlbGluZSwgYmluZGluZ3MgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHBpcGVsaW5lO1xyXG5cclxuXHR9XHJcblxyXG5cdF9nZXRSZW5kZXJQaXBlbGluZSggcmVuZGVyT2JqZWN0LCBzdGFnZVZlcnRleCwgc3RhZ2VGcmFnbWVudCwgY2FjaGVLZXksIHByb21pc2VzICkge1xyXG5cclxuXHRcdC8vIGNoZWNrIGZvciBleGlzdGluZyBwaXBlbGluZVxyXG5cclxuXHRcdGNhY2hlS2V5ID0gY2FjaGVLZXkgfHwgdGhpcy5fZ2V0UmVuZGVyQ2FjaGVLZXkoIHJlbmRlck9iamVjdCwgc3RhZ2VWZXJ0ZXgsIHN0YWdlRnJhZ21lbnQgKTtcclxuXHJcblx0XHRsZXQgcGlwZWxpbmUgPSB0aGlzLmNhY2hlcy5nZXQoIGNhY2hlS2V5ICk7XHJcblxyXG5cdFx0aWYgKCBwaXBlbGluZSA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0cGlwZWxpbmUgPSBuZXcgUmVuZGVyUGlwZWxpbmUoIGNhY2hlS2V5LCBzdGFnZVZlcnRleCwgc3RhZ2VGcmFnbWVudCApO1xyXG5cclxuXHRcdFx0dGhpcy5jYWNoZXMuc2V0KCBjYWNoZUtleSwgcGlwZWxpbmUgKTtcclxuXHJcblx0XHRcdHJlbmRlck9iamVjdC5waXBlbGluZSA9IHBpcGVsaW5lO1xyXG5cclxuXHRcdFx0dGhpcy5iYWNrZW5kLmNyZWF0ZVJlbmRlclBpcGVsaW5lKCByZW5kZXJPYmplY3QsIHByb21pc2VzICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBwaXBlbGluZTtcclxuXHJcblx0fVxyXG5cclxuXHRfZ2V0Q29tcHV0ZUNhY2hlS2V5KCBjb21wdXRlTm9kZSwgc3RhZ2VDb21wdXRlICkge1xyXG5cclxuXHRcdHJldHVybiBjb21wdXRlTm9kZS5pZCArICcsJyArIHN0YWdlQ29tcHV0ZS5pZDtcclxuXHJcblx0fVxyXG5cclxuXHRfZ2V0UmVuZGVyQ2FjaGVLZXkoIHJlbmRlck9iamVjdCwgc3RhZ2VWZXJ0ZXgsIHN0YWdlRnJhZ21lbnQgKSB7XHJcblxyXG5cdFx0cmV0dXJuIHN0YWdlVmVydGV4LmlkICsgJywnICsgc3RhZ2VGcmFnbWVudC5pZCArICcsJyArIHRoaXMuYmFja2VuZC5nZXRSZW5kZXJDYWNoZUtleSggcmVuZGVyT2JqZWN0ICk7XHJcblxyXG5cdH1cclxuXHJcblx0X3JlbGVhc2VQaXBlbGluZSggcGlwZWxpbmUgKSB7XHJcblxyXG5cdFx0dGhpcy5jYWNoZXMuZGVsZXRlKCBwaXBlbGluZS5jYWNoZUtleSApO1xyXG5cclxuXHR9XHJcblxyXG5cdF9yZWxlYXNlUHJvZ3JhbSggcHJvZ3JhbSApIHtcclxuXHJcblx0XHRjb25zdCBjb2RlID0gcHJvZ3JhbS5jb2RlO1xyXG5cdFx0Y29uc3Qgc3RhZ2UgPSBwcm9ncmFtLnN0YWdlO1xyXG5cclxuXHRcdHRoaXMucHJvZ3JhbXNbIHN0YWdlIF0uZGVsZXRlKCBjb2RlICk7XHJcblxyXG5cdH1cclxuXHJcblx0X25lZWRzQ29tcHV0ZVVwZGF0ZSggY29tcHV0ZU5vZGUgKSB7XHJcblxyXG5cdFx0Y29uc3QgZGF0YSA9IHRoaXMuZ2V0KCBjb21wdXRlTm9kZSApO1xyXG5cclxuXHRcdHJldHVybiBkYXRhLnBpcGVsaW5lID09PSB1bmRlZmluZWQgfHwgZGF0YS52ZXJzaW9uICE9PSBjb21wdXRlTm9kZS52ZXJzaW9uO1xyXG5cclxuXHR9XHJcblxyXG5cdF9uZWVkc1JlbmRlclVwZGF0ZSggcmVuZGVyT2JqZWN0ICkge1xyXG5cclxuXHRcdGNvbnN0IGRhdGEgPSB0aGlzLmdldCggcmVuZGVyT2JqZWN0ICk7XHJcblxyXG5cdFx0cmV0dXJuIGRhdGEucGlwZWxpbmUgPT09IHVuZGVmaW5lZCB8fCB0aGlzLmJhY2tlbmQubmVlZHNSZW5kZXJVcGRhdGUoIHJlbmRlck9iamVjdCApO1xyXG5cclxuXHR9XHJcblxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBQaXBlbGluZXM7XHJcbiIsImltcG9ydCBEYXRhTWFwIGZyb20gJy4vRGF0YU1hcC5qcyc7XHJcbmltcG9ydCB7IEF0dHJpYnV0ZVR5cGUgfSBmcm9tICcuL0NvbnN0YW50cy5qcyc7XHJcblxyXG5jbGFzcyBCaW5kaW5ncyBleHRlbmRzIERhdGFNYXAge1xyXG5cclxuXHRjb25zdHJ1Y3RvciggYmFja2VuZCwgbm9kZXMsIHRleHR1cmVzLCBhdHRyaWJ1dGVzLCBwaXBlbGluZXMsIGluZm8gKSB7XHJcblxyXG5cdFx0c3VwZXIoKTtcclxuXHJcblx0XHR0aGlzLmJhY2tlbmQgPSBiYWNrZW5kO1xyXG5cdFx0dGhpcy50ZXh0dXJlcyA9IHRleHR1cmVzO1xyXG5cdFx0dGhpcy5waXBlbGluZXMgPSBwaXBlbGluZXM7XHJcblx0XHR0aGlzLmF0dHJpYnV0ZXMgPSBhdHRyaWJ1dGVzO1xyXG5cdFx0dGhpcy5ub2RlcyA9IG5vZGVzO1xyXG5cdFx0dGhpcy5pbmZvID0gaW5mbztcclxuXHJcblx0XHR0aGlzLnBpcGVsaW5lcy5iaW5kaW5ncyA9IHRoaXM7IC8vIGFzc2lnbiBiaW5kaW5ncyB0byBwaXBlbGluZXNcclxuXHJcblx0fVxyXG5cclxuXHRnZXRGb3JSZW5kZXIoIHJlbmRlck9iamVjdCApIHtcclxuXHJcblx0XHRjb25zdCBiaW5kaW5ncyA9IHJlbmRlck9iamVjdC5nZXRCaW5kaW5ncygpO1xyXG5cclxuXHRcdGZvciAoIGNvbnN0IGJpbmRHcm91cCBvZiBiaW5kaW5ncyApIHtcclxuXHJcblx0XHRcdGNvbnN0IGdyb3VwRGF0YSA9IHRoaXMuZ2V0KCBiaW5kR3JvdXAgKTtcclxuXHJcblx0XHRcdGlmICggZ3JvdXBEYXRhLmJpbmRHcm91cCA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHQvLyBlYWNoIG9iamVjdCBkZWZpbmVzIGFuIGFycmF5IG9mIGJpbmRpbmdzICh1Ym9zLCB0ZXh0dXJlcywgc2FtcGxlcnMgZXRjLilcclxuXHJcblx0XHRcdFx0dGhpcy5faW5pdCggYmluZEdyb3VwICk7XHJcblxyXG5cdFx0XHRcdHRoaXMuYmFja2VuZC5jcmVhdGVCaW5kaW5ncyggYmluZEdyb3VwLCBiaW5kaW5ncywgMCApO1xyXG5cclxuXHRcdFx0XHRncm91cERhdGEuYmluZEdyb3VwID0gYmluZEdyb3VwO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gYmluZGluZ3M7XHJcblxyXG5cdH1cclxuXHJcblx0Z2V0Rm9yQ29tcHV0ZSggY29tcHV0ZU5vZGUgKSB7XHJcblxyXG5cdFx0Y29uc3QgYmluZGluZ3MgPSB0aGlzLm5vZGVzLmdldEZvckNvbXB1dGUoIGNvbXB1dGVOb2RlICkuYmluZGluZ3M7XHJcblxyXG5cdFx0Zm9yICggY29uc3QgYmluZEdyb3VwIG9mIGJpbmRpbmdzICkge1xyXG5cclxuXHRcdFx0Y29uc3QgZ3JvdXBEYXRhID0gdGhpcy5nZXQoIGJpbmRHcm91cCApO1xyXG5cclxuXHRcdFx0aWYgKCBncm91cERhdGEuYmluZEdyb3VwID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdHRoaXMuX2luaXQoIGJpbmRHcm91cCApO1xyXG5cclxuXHRcdFx0XHR0aGlzLmJhY2tlbmQuY3JlYXRlQmluZGluZ3MoIGJpbmRHcm91cCwgYmluZGluZ3MsIDAgKTtcclxuXHJcblx0XHRcdFx0Z3JvdXBEYXRhLmJpbmRHcm91cCA9IGJpbmRHcm91cDtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGJpbmRpbmdzO1xyXG5cclxuXHR9XHJcblxyXG5cdHVwZGF0ZUZvckNvbXB1dGUoIGNvbXB1dGVOb2RlICkge1xyXG5cclxuXHRcdHRoaXMuX3VwZGF0ZUJpbmRpbmdzKCB0aGlzLmdldEZvckNvbXB1dGUoIGNvbXB1dGVOb2RlICkgKTtcclxuXHJcblx0fVxyXG5cclxuXHR1cGRhdGVGb3JSZW5kZXIoIHJlbmRlck9iamVjdCApIHtcclxuXHJcblx0XHR0aGlzLl91cGRhdGVCaW5kaW5ncyggdGhpcy5nZXRGb3JSZW5kZXIoIHJlbmRlck9iamVjdCApICk7XHJcblxyXG5cdH1cclxuXHJcblx0X3VwZGF0ZUJpbmRpbmdzKCBiaW5kaW5ncyApIHtcclxuXHJcblx0XHRmb3IgKCBjb25zdCBiaW5kR3JvdXAgb2YgYmluZGluZ3MgKSB7XHJcblxyXG5cdFx0XHR0aGlzLl91cGRhdGUoIGJpbmRHcm91cCwgYmluZGluZ3MgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0X2luaXQoIGJpbmRHcm91cCApIHtcclxuXHJcblx0XHRmb3IgKCBjb25zdCBiaW5kaW5nIG9mIGJpbmRHcm91cC5iaW5kaW5ncyApIHtcclxuXHJcblx0XHRcdGlmICggYmluZGluZy5pc1NhbXBsZWRUZXh0dXJlICkge1xyXG5cclxuXHRcdFx0XHR0aGlzLnRleHR1cmVzLnVwZGF0ZVRleHR1cmUoIGJpbmRpbmcudGV4dHVyZSApO1xyXG5cclxuXHRcdFx0fSBlbHNlIGlmICggYmluZGluZy5pc1N0b3JhZ2VCdWZmZXIgKSB7XHJcblxyXG5cdFx0XHRcdGNvbnN0IGF0dHJpYnV0ZSA9IGJpbmRpbmcuYXR0cmlidXRlO1xyXG5cdFx0XHRcdGNvbnN0IGF0dHJpYnV0ZVR5cGUgPSBhdHRyaWJ1dGUuaXNJbmRpcmVjdFN0b3JhZ2VCdWZmZXJBdHRyaWJ1dGUgPyBBdHRyaWJ1dGVUeXBlLklORElSRUNUIDogQXR0cmlidXRlVHlwZS5TVE9SQUdFO1xyXG5cclxuXHRcdFx0XHR0aGlzLmF0dHJpYnV0ZXMudXBkYXRlKCBhdHRyaWJ1dGUsIGF0dHJpYnV0ZVR5cGUgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0X3VwZGF0ZSggYmluZEdyb3VwLCBiaW5kaW5ncyApIHtcclxuXHJcblx0XHRjb25zdCB7IGJhY2tlbmQgfSA9IHRoaXM7XHJcblxyXG5cdFx0bGV0IG5lZWRzQmluZGluZ3NVcGRhdGUgPSBmYWxzZTtcclxuXHRcdGxldCBjYWNoZUJpbmRpbmdzID0gdHJ1ZTtcclxuXHRcdGxldCBjYWNoZUluZGV4ID0gMDtcclxuXHRcdGxldCB2ZXJzaW9uID0gMDtcclxuXHJcblx0XHQvLyBpdGVyYXRlIG92ZXIgYWxsIGJpbmRpbmdzIGFuZCBjaGVjayBpZiBidWZmZXIgdXBkYXRlcyBvciBhIG5ldyBiaW5kaW5nIGdyb3VwIGlzIHJlcXVpcmVkXHJcblxyXG5cdFx0Zm9yICggY29uc3QgYmluZGluZyBvZiBiaW5kR3JvdXAuYmluZGluZ3MgKSB7XHJcblxyXG5cdFx0XHRpZiAoIGJpbmRpbmcuaXNOb2RlVW5pZm9ybXNHcm91cCApIHtcclxuXHJcblx0XHRcdFx0Y29uc3QgdXBkYXRlZCA9IHRoaXMubm9kZXMudXBkYXRlR3JvdXAoIGJpbmRpbmcgKTtcclxuXHJcblx0XHRcdFx0aWYgKCAhIHVwZGF0ZWQgKSBjb250aW51ZTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICggYmluZGluZy5pc1VuaWZvcm1CdWZmZXIgKSB7XHJcblxyXG5cdFx0XHRcdGNvbnN0IHVwZGF0ZWQgPSBiaW5kaW5nLnVwZGF0ZSgpO1xyXG5cclxuXHRcdFx0XHRpZiAoIHVwZGF0ZWQgKSB7XHJcblxyXG5cdFx0XHRcdFx0YmFja2VuZC51cGRhdGVCaW5kaW5nKCBiaW5kaW5nICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH0gZWxzZSBpZiAoIGJpbmRpbmcuaXNTYW1wbGVyICkge1xyXG5cclxuXHRcdFx0XHRiaW5kaW5nLnVwZGF0ZSgpO1xyXG5cclxuXHRcdFx0fSBlbHNlIGlmICggYmluZGluZy5pc1NhbXBsZWRUZXh0dXJlICkge1xyXG5cclxuXHRcdFx0XHRjb25zdCB0ZXh0dXJlc1RleHR1cmVEYXRhID0gdGhpcy50ZXh0dXJlcy5nZXQoIGJpbmRpbmcudGV4dHVyZSApO1xyXG5cclxuXHRcdFx0XHRpZiAoIGJpbmRpbmcubmVlZHNCaW5kaW5nc1VwZGF0ZSggdGV4dHVyZXNUZXh0dXJlRGF0YS5nZW5lcmF0aW9uICkgKSBuZWVkc0JpbmRpbmdzVXBkYXRlID0gdHJ1ZTtcclxuXHJcblx0XHRcdFx0Y29uc3QgdXBkYXRlZCA9IGJpbmRpbmcudXBkYXRlKCk7XHJcblxyXG5cdFx0XHRcdGNvbnN0IHRleHR1cmUgPSBiaW5kaW5nLnRleHR1cmU7XHJcblxyXG5cdFx0XHRcdGlmICggdXBkYXRlZCApIHtcclxuXHJcblx0XHRcdFx0XHR0aGlzLnRleHR1cmVzLnVwZGF0ZVRleHR1cmUoIHRleHR1cmUgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRjb25zdCB0ZXh0dXJlRGF0YSA9IGJhY2tlbmQuZ2V0KCB0ZXh0dXJlICk7XHJcblxyXG5cdFx0XHRcdGlmICggdGV4dHVyZURhdGEuZXh0ZXJuYWxUZXh0dXJlICE9PSB1bmRlZmluZWQgfHwgdGV4dHVyZXNUZXh0dXJlRGF0YS5pc0RlZmF1bHRUZXh0dXJlICkge1xyXG5cclxuXHRcdFx0XHRcdGNhY2hlQmluZGluZ3MgPSBmYWxzZTtcclxuXHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHRjYWNoZUluZGV4ID0gY2FjaGVJbmRleCAqIDEwICsgdGV4dHVyZS5pZDtcclxuXHRcdFx0XHRcdHZlcnNpb24gKz0gdGV4dHVyZS52ZXJzaW9uO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGlmICggYmFja2VuZC5pc1dlYkdQVUJhY2tlbmQgPT09IHRydWUgJiYgdGV4dHVyZURhdGEudGV4dHVyZSA9PT0gdW5kZWZpbmVkICYmIHRleHR1cmVEYXRhLmV4dGVybmFsVGV4dHVyZSA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRcdC8vIFRPRE86IFJlbW92ZSB0aGlzIG9uY2Ugd2UgZm91bmQgd2h5IHVwZGF0ZWQgPT09IGZhbHNlIGlzbid0IGJvdW5kIHRvIGEgdGV4dHVyZSBpbiB0aGUgV2ViR1BVIGJhY2tlbmRcclxuXHRcdFx0XHRcdGNvbnNvbGUuZXJyb3IoICdCaW5kaW5ncy5fdXBkYXRlOiBiaW5kaW5nIHNob3VsZCBiZSBhdmFpbGFibGU6JywgYmluZGluZywgdXBkYXRlZCwgdGV4dHVyZSwgYmluZGluZy50ZXh0dXJlTm9kZS52YWx1ZSwgbmVlZHNCaW5kaW5nc1VwZGF0ZSApO1xyXG5cclxuXHRcdFx0XHRcdHRoaXMudGV4dHVyZXMudXBkYXRlVGV4dHVyZSggdGV4dHVyZSApO1xyXG5cdFx0XHRcdFx0bmVlZHNCaW5kaW5nc1VwZGF0ZSA9IHRydWU7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0aWYgKCB0ZXh0dXJlLmlzU3RvcmFnZVRleHR1cmUgPT09IHRydWUgKSB7XHJcblxyXG5cdFx0XHRcdFx0Y29uc3QgdGV4dHVyZURhdGEgPSB0aGlzLmdldCggdGV4dHVyZSApO1xyXG5cclxuXHRcdFx0XHRcdGlmICggYmluZGluZy5zdG9yZSA9PT0gdHJ1ZSApIHtcclxuXHJcblx0XHRcdFx0XHRcdHRleHR1cmVEYXRhLm5lZWRzTWlwbWFwID0gdHJ1ZTtcclxuXHJcblx0XHRcdFx0XHR9IGVsc2UgaWYgKCB0aGlzLnRleHR1cmVzLm5lZWRzTWlwbWFwcyggdGV4dHVyZSApICYmIHRleHR1cmVEYXRhLm5lZWRzTWlwbWFwID09PSB0cnVlICkge1xyXG5cclxuXHRcdFx0XHRcdFx0dGhpcy5iYWNrZW5kLmdlbmVyYXRlTWlwbWFwcyggdGV4dHVyZSApO1xyXG5cclxuXHRcdFx0XHRcdFx0dGV4dHVyZURhdGEubmVlZHNNaXBtYXAgPSBmYWxzZTtcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBuZWVkc0JpbmRpbmdzVXBkYXRlID09PSB0cnVlICkge1xyXG5cclxuXHRcdFx0dGhpcy5iYWNrZW5kLnVwZGF0ZUJpbmRpbmdzKCBiaW5kR3JvdXAsIGJpbmRpbmdzLCBjYWNoZUJpbmRpbmdzID8gY2FjaGVJbmRleCA6IDAsIHZlcnNpb24gKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IEJpbmRpbmdzO1xyXG4iLCJpbXBvcnQgeyBEb3VibGVTaWRlIH0gZnJvbSAnLi4vLi4vY29uc3RhbnRzLmpzJztcclxuXHJcbmZ1bmN0aW9uIHBhaW50ZXJTb3J0U3RhYmxlKCBhLCBiICkge1xyXG5cclxuXHRpZiAoIGEuZ3JvdXBPcmRlciAhPT0gYi5ncm91cE9yZGVyICkge1xyXG5cclxuXHRcdHJldHVybiBhLmdyb3VwT3JkZXIgLSBiLmdyb3VwT3JkZXI7XHJcblxyXG5cdH0gZWxzZSBpZiAoIGEucmVuZGVyT3JkZXIgIT09IGIucmVuZGVyT3JkZXIgKSB7XHJcblxyXG5cdFx0cmV0dXJuIGEucmVuZGVyT3JkZXIgLSBiLnJlbmRlck9yZGVyO1xyXG5cclxuXHR9IGVsc2UgaWYgKCBhLm1hdGVyaWFsLmlkICE9PSBiLm1hdGVyaWFsLmlkICkge1xyXG5cclxuXHRcdHJldHVybiBhLm1hdGVyaWFsLmlkIC0gYi5tYXRlcmlhbC5pZDtcclxuXHJcblx0fSBlbHNlIGlmICggYS56ICE9PSBiLnogKSB7XHJcblxyXG5cdFx0cmV0dXJuIGEueiAtIGIuejtcclxuXHJcblx0fSBlbHNlIHtcclxuXHJcblx0XHRyZXR1cm4gYS5pZCAtIGIuaWQ7XHJcblxyXG5cdH1cclxuXHJcbn1cclxuXHJcbmZ1bmN0aW9uIHJldmVyc2VQYWludGVyU29ydFN0YWJsZSggYSwgYiApIHtcclxuXHJcblx0aWYgKCBhLmdyb3VwT3JkZXIgIT09IGIuZ3JvdXBPcmRlciApIHtcclxuXHJcblx0XHRyZXR1cm4gYS5ncm91cE9yZGVyIC0gYi5ncm91cE9yZGVyO1xyXG5cclxuXHR9IGVsc2UgaWYgKCBhLnJlbmRlck9yZGVyICE9PSBiLnJlbmRlck9yZGVyICkge1xyXG5cclxuXHRcdHJldHVybiBhLnJlbmRlck9yZGVyIC0gYi5yZW5kZXJPcmRlcjtcclxuXHJcblx0fSBlbHNlIGlmICggYS56ICE9PSBiLnogKSB7XHJcblxyXG5cdFx0cmV0dXJuIGIueiAtIGEuejtcclxuXHJcblx0fSBlbHNlIHtcclxuXHJcblx0XHRyZXR1cm4gYS5pZCAtIGIuaWQ7XHJcblxyXG5cdH1cclxuXHJcbn1cclxuXHJcbmZ1bmN0aW9uIG5lZWRzRG91YmxlUGFzcyggbWF0ZXJpYWwgKSB7XHJcblxyXG5cdGNvbnN0IGhhc1RyYW5zbWlzc2lvbiA9IG1hdGVyaWFsLnRyYW5zbWlzc2lvbiA+IDAgfHwgbWF0ZXJpYWwudHJhbnNtaXNzaW9uTm9kZTtcclxuXHJcblx0cmV0dXJuIGhhc1RyYW5zbWlzc2lvbiAmJiBtYXRlcmlhbC5zaWRlID09PSBEb3VibGVTaWRlICYmIG1hdGVyaWFsLmZvcmNlU2luZ2xlUGFzcyA9PT0gZmFsc2U7XHJcblxyXG59XHJcblxyXG5jbGFzcyBSZW5kZXJMaXN0IHtcclxuXHJcblx0Y29uc3RydWN0b3IoIGxpZ2h0aW5nLCBzY2VuZSwgY2FtZXJhICkge1xyXG5cclxuXHRcdHRoaXMucmVuZGVySXRlbXMgPSBbXTtcclxuXHRcdHRoaXMucmVuZGVySXRlbXNJbmRleCA9IDA7XHJcblxyXG5cdFx0dGhpcy5vcGFxdWUgPSBbXTtcclxuXHRcdHRoaXMudHJhbnNwYXJlbnREb3VibGVQYXNzID0gW107XHJcblx0XHR0aGlzLnRyYW5zcGFyZW50ID0gW107XHJcblx0XHR0aGlzLmJ1bmRsZXMgPSBbXTtcclxuXHJcblx0XHR0aGlzLmxpZ2h0c05vZGUgPSBsaWdodGluZy5nZXROb2RlKCBzY2VuZSwgY2FtZXJhICk7XHJcblx0XHR0aGlzLmxpZ2h0c0FycmF5ID0gW107XHJcblxyXG5cdFx0dGhpcy5zY2VuZSA9IHNjZW5lO1xyXG5cdFx0dGhpcy5jYW1lcmEgPSBjYW1lcmE7XHJcblxyXG5cdFx0dGhpcy5vY2NsdXNpb25RdWVyeUNvdW50ID0gMDtcclxuXHJcblx0fVxyXG5cclxuXHRiZWdpbigpIHtcclxuXHJcblx0XHR0aGlzLnJlbmRlckl0ZW1zSW5kZXggPSAwO1xyXG5cclxuXHRcdHRoaXMub3BhcXVlLmxlbmd0aCA9IDA7XHJcblx0XHR0aGlzLnRyYW5zcGFyZW50RG91YmxlUGFzcy5sZW5ndGggPSAwO1xyXG5cdFx0dGhpcy50cmFuc3BhcmVudC5sZW5ndGggPSAwO1xyXG5cdFx0dGhpcy5idW5kbGVzLmxlbmd0aCA9IDA7XHJcblxyXG5cdFx0dGhpcy5saWdodHNBcnJheS5sZW5ndGggPSAwO1xyXG5cclxuXHRcdHRoaXMub2NjbHVzaW9uUXVlcnlDb3VudCA9IDA7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHJcblx0Z2V0TmV4dFJlbmRlckl0ZW0oIG9iamVjdCwgZ2VvbWV0cnksIG1hdGVyaWFsLCBncm91cE9yZGVyLCB6LCBncm91cCwgY2xpcHBpbmdDb250ZXh0ICkge1xyXG5cclxuXHRcdGxldCByZW5kZXJJdGVtID0gdGhpcy5yZW5kZXJJdGVtc1sgdGhpcy5yZW5kZXJJdGVtc0luZGV4IF07XHJcblxyXG5cdFx0aWYgKCByZW5kZXJJdGVtID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRyZW5kZXJJdGVtID0ge1xyXG5cdFx0XHRcdGlkOiBvYmplY3QuaWQsXHJcblx0XHRcdFx0b2JqZWN0OiBvYmplY3QsXHJcblx0XHRcdFx0Z2VvbWV0cnk6IGdlb21ldHJ5LFxyXG5cdFx0XHRcdG1hdGVyaWFsOiBtYXRlcmlhbCxcclxuXHRcdFx0XHRncm91cE9yZGVyOiBncm91cE9yZGVyLFxyXG5cdFx0XHRcdHJlbmRlck9yZGVyOiBvYmplY3QucmVuZGVyT3JkZXIsXHJcblx0XHRcdFx0ejogeixcclxuXHRcdFx0XHRncm91cDogZ3JvdXAsXHJcblx0XHRcdFx0Y2xpcHBpbmdDb250ZXh0OiBjbGlwcGluZ0NvbnRleHRcclxuXHRcdFx0fTtcclxuXHJcblx0XHRcdHRoaXMucmVuZGVySXRlbXNbIHRoaXMucmVuZGVySXRlbXNJbmRleCBdID0gcmVuZGVySXRlbTtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0cmVuZGVySXRlbS5pZCA9IG9iamVjdC5pZDtcclxuXHRcdFx0cmVuZGVySXRlbS5vYmplY3QgPSBvYmplY3Q7XHJcblx0XHRcdHJlbmRlckl0ZW0uZ2VvbWV0cnkgPSBnZW9tZXRyeTtcclxuXHRcdFx0cmVuZGVySXRlbS5tYXRlcmlhbCA9IG1hdGVyaWFsO1xyXG5cdFx0XHRyZW5kZXJJdGVtLmdyb3VwT3JkZXIgPSBncm91cE9yZGVyO1xyXG5cdFx0XHRyZW5kZXJJdGVtLnJlbmRlck9yZGVyID0gb2JqZWN0LnJlbmRlck9yZGVyO1xyXG5cdFx0XHRyZW5kZXJJdGVtLnogPSB6O1xyXG5cdFx0XHRyZW5kZXJJdGVtLmdyb3VwID0gZ3JvdXA7XHJcblx0XHRcdHJlbmRlckl0ZW0uY2xpcHBpbmdDb250ZXh0ID0gY2xpcHBpbmdDb250ZXh0O1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLnJlbmRlckl0ZW1zSW5kZXggKys7XHJcblxyXG5cdFx0cmV0dXJuIHJlbmRlckl0ZW07XHJcblxyXG5cdH1cclxuXHJcblx0cHVzaCggb2JqZWN0LCBnZW9tZXRyeSwgbWF0ZXJpYWwsIGdyb3VwT3JkZXIsIHosIGdyb3VwLCBjbGlwcGluZ0NvbnRleHQgKSB7XHJcblxyXG5cdFx0Y29uc3QgcmVuZGVySXRlbSA9IHRoaXMuZ2V0TmV4dFJlbmRlckl0ZW0oIG9iamVjdCwgZ2VvbWV0cnksIG1hdGVyaWFsLCBncm91cE9yZGVyLCB6LCBncm91cCwgY2xpcHBpbmdDb250ZXh0ICk7XHJcblxyXG5cdFx0aWYgKCBvYmplY3Qub2NjbHVzaW9uVGVzdCA9PT0gdHJ1ZSApIHRoaXMub2NjbHVzaW9uUXVlcnlDb3VudCArKztcclxuXHJcblx0XHRpZiAoIG1hdGVyaWFsLnRyYW5zcGFyZW50ID09PSB0cnVlIHx8IG1hdGVyaWFsLnRyYW5zbWlzc2lvbiA+IDAgKSB7XHJcblxyXG5cdFx0XHRpZiAoIG5lZWRzRG91YmxlUGFzcyggbWF0ZXJpYWwgKSApIHRoaXMudHJhbnNwYXJlbnREb3VibGVQYXNzLnB1c2goIHJlbmRlckl0ZW0gKTtcclxuXHJcblx0XHRcdHRoaXMudHJhbnNwYXJlbnQucHVzaCggcmVuZGVySXRlbSApO1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHR0aGlzLm9wYXF1ZS5wdXNoKCByZW5kZXJJdGVtICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdHVuc2hpZnQoIG9iamVjdCwgZ2VvbWV0cnksIG1hdGVyaWFsLCBncm91cE9yZGVyLCB6LCBncm91cCwgY2xpcHBpbmdDb250ZXh0ICkge1xyXG5cclxuXHRcdGNvbnN0IHJlbmRlckl0ZW0gPSB0aGlzLmdldE5leHRSZW5kZXJJdGVtKCBvYmplY3QsIGdlb21ldHJ5LCBtYXRlcmlhbCwgZ3JvdXBPcmRlciwgeiwgZ3JvdXAsIGNsaXBwaW5nQ29udGV4dCApO1xyXG5cclxuXHRcdGlmICggbWF0ZXJpYWwudHJhbnNwYXJlbnQgPT09IHRydWUgfHwgbWF0ZXJpYWwudHJhbnNtaXNzaW9uID4gMCApIHtcclxuXHJcblx0XHRcdGlmICggbmVlZHNEb3VibGVQYXNzKCBtYXRlcmlhbCApICkgdGhpcy50cmFuc3BhcmVudERvdWJsZVBhc3MudW5zaGlmdCggcmVuZGVySXRlbSApO1xyXG5cclxuXHRcdFx0dGhpcy50cmFuc3BhcmVudC51bnNoaWZ0KCByZW5kZXJJdGVtICk7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdHRoaXMub3BhcXVlLnVuc2hpZnQoIHJlbmRlckl0ZW0gKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0cHVzaEJ1bmRsZSggZ3JvdXAgKSB7XHJcblxyXG5cdFx0dGhpcy5idW5kbGVzLnB1c2goIGdyb3VwICk7XHJcblxyXG5cdH1cclxuXHJcblx0cHVzaExpZ2h0KCBsaWdodCApIHtcclxuXHJcblx0XHR0aGlzLmxpZ2h0c0FycmF5LnB1c2goIGxpZ2h0ICk7XHJcblxyXG5cdH1cclxuXHJcblx0c29ydCggY3VzdG9tT3BhcXVlU29ydCwgY3VzdG9tVHJhbnNwYXJlbnRTb3J0ICkge1xyXG5cclxuXHRcdGlmICggdGhpcy5vcGFxdWUubGVuZ3RoID4gMSApIHRoaXMub3BhcXVlLnNvcnQoIGN1c3RvbU9wYXF1ZVNvcnQgfHwgcGFpbnRlclNvcnRTdGFibGUgKTtcclxuXHRcdGlmICggdGhpcy50cmFuc3BhcmVudERvdWJsZVBhc3MubGVuZ3RoID4gMSApIHRoaXMudHJhbnNwYXJlbnREb3VibGVQYXNzLnNvcnQoIGN1c3RvbVRyYW5zcGFyZW50U29ydCB8fCByZXZlcnNlUGFpbnRlclNvcnRTdGFibGUgKTtcclxuXHRcdGlmICggdGhpcy50cmFuc3BhcmVudC5sZW5ndGggPiAxICkgdGhpcy50cmFuc3BhcmVudC5zb3J0KCBjdXN0b21UcmFuc3BhcmVudFNvcnQgfHwgcmV2ZXJzZVBhaW50ZXJTb3J0U3RhYmxlICk7XHJcblxyXG5cdH1cclxuXHJcblx0ZmluaXNoKCkge1xyXG5cclxuXHRcdC8vIHVwZGF0ZSBsaWdodHNcclxuXHJcblx0XHR0aGlzLmxpZ2h0c05vZGUuc2V0TGlnaHRzKCB0aGlzLmxpZ2h0c0FycmF5ICk7XHJcblxyXG5cdFx0Ly8gQ2xlYXIgcmVmZXJlbmNlcyBmcm9tIGluYWN0aXZlIHJlbmRlckl0ZW1zIGluIHRoZSBsaXN0XHJcblxyXG5cdFx0Zm9yICggbGV0IGkgPSB0aGlzLnJlbmRlckl0ZW1zSW5kZXgsIGlsID0gdGhpcy5yZW5kZXJJdGVtcy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcclxuXHJcblx0XHRcdGNvbnN0IHJlbmRlckl0ZW0gPSB0aGlzLnJlbmRlckl0ZW1zWyBpIF07XHJcblxyXG5cdFx0XHRpZiAoIHJlbmRlckl0ZW0uaWQgPT09IG51bGwgKSBicmVhaztcclxuXHJcblx0XHRcdHJlbmRlckl0ZW0uaWQgPSBudWxsO1xyXG5cdFx0XHRyZW5kZXJJdGVtLm9iamVjdCA9IG51bGw7XHJcblx0XHRcdHJlbmRlckl0ZW0uZ2VvbWV0cnkgPSBudWxsO1xyXG5cdFx0XHRyZW5kZXJJdGVtLm1hdGVyaWFsID0gbnVsbDtcclxuXHRcdFx0cmVuZGVySXRlbS5ncm91cE9yZGVyID0gbnVsbDtcclxuXHRcdFx0cmVuZGVySXRlbS5yZW5kZXJPcmRlciA9IG51bGw7XHJcblx0XHRcdHJlbmRlckl0ZW0ueiA9IG51bGw7XHJcblx0XHRcdHJlbmRlckl0ZW0uZ3JvdXAgPSBudWxsO1xyXG5cdFx0XHRyZW5kZXJJdGVtLmNsaXBwaW5nQ29udGV4dCA9IG51bGw7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBSZW5kZXJMaXN0O1xyXG4iLCJpbXBvcnQgQ2hhaW5NYXAgZnJvbSAnLi9DaGFpbk1hcC5qcyc7XHJcbmltcG9ydCBSZW5kZXJMaXN0IGZyb20gJy4vUmVuZGVyTGlzdC5qcyc7XHJcblxyXG5jbGFzcyBSZW5kZXJMaXN0cyB7XHJcblxyXG5cdGNvbnN0cnVjdG9yKCBsaWdodGluZyApIHtcclxuXHJcblx0XHR0aGlzLmxpZ2h0aW5nID0gbGlnaHRpbmc7XHJcblxyXG5cdFx0dGhpcy5saXN0cyA9IG5ldyBDaGFpbk1hcCgpO1xyXG5cclxuXHR9XHJcblxyXG5cdGdldCggc2NlbmUsIGNhbWVyYSApIHtcclxuXHJcblx0XHRjb25zdCBsaXN0cyA9IHRoaXMubGlzdHM7XHJcblx0XHRjb25zdCBrZXlzID0gWyBzY2VuZSwgY2FtZXJhIF07XHJcblxyXG5cdFx0bGV0IGxpc3QgPSBsaXN0cy5nZXQoIGtleXMgKTtcclxuXHJcblx0XHRpZiAoIGxpc3QgPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdGxpc3QgPSBuZXcgUmVuZGVyTGlzdCggdGhpcy5saWdodGluZywgc2NlbmUsIGNhbWVyYSApO1xyXG5cdFx0XHRsaXN0cy5zZXQoIGtleXMsIGxpc3QgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGxpc3Q7XHJcblxyXG5cdH1cclxuXHJcblx0ZGlzcG9zZSgpIHtcclxuXHJcblx0XHR0aGlzLmxpc3RzID0gbmV3IENoYWluTWFwKCk7XHJcblxyXG5cdH1cclxuXHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IFJlbmRlckxpc3RzO1xyXG4iLCJpbXBvcnQgeyBWZWN0b3I0IH0gZnJvbSAnLi4vLi4vbWF0aC9WZWN0b3I0LmpzJztcclxuaW1wb3J0IHsgaGFzaEFycmF5IH0gZnJvbSAnLi4vLi4vbm9kZXMvY29yZS9Ob2RlVXRpbHMuanMnO1xyXG5cclxubGV0IGlkID0gMDtcclxuXHJcbmNsYXNzIFJlbmRlckNvbnRleHQge1xyXG5cclxuXHRjb25zdHJ1Y3RvcigpIHtcclxuXHJcblx0XHR0aGlzLmlkID0gaWQgKys7XHJcblxyXG5cdFx0dGhpcy5jb2xvciA9IHRydWU7XHJcblx0XHR0aGlzLmNsZWFyQ29sb3IgPSB0cnVlO1xyXG5cdFx0dGhpcy5jbGVhckNvbG9yVmFsdWUgPSB7IHI6IDAsIGc6IDAsIGI6IDAsIGE6IDEgfTtcclxuXHJcblx0XHR0aGlzLmRlcHRoID0gdHJ1ZTtcclxuXHRcdHRoaXMuY2xlYXJEZXB0aCA9IHRydWU7XHJcblx0XHR0aGlzLmNsZWFyRGVwdGhWYWx1ZSA9IDE7XHJcblxyXG5cdFx0dGhpcy5zdGVuY2lsID0gZmFsc2U7XHJcblx0XHR0aGlzLmNsZWFyU3RlbmNpbCA9IHRydWU7XHJcblx0XHR0aGlzLmNsZWFyU3RlbmNpbFZhbHVlID0gMTtcclxuXHJcblx0XHR0aGlzLnZpZXdwb3J0ID0gZmFsc2U7XHJcblx0XHR0aGlzLnZpZXdwb3J0VmFsdWUgPSBuZXcgVmVjdG9yNCgpO1xyXG5cclxuXHRcdHRoaXMuc2Npc3NvciA9IGZhbHNlO1xyXG5cdFx0dGhpcy5zY2lzc29yVmFsdWUgPSBuZXcgVmVjdG9yNCgpO1xyXG5cclxuXHRcdHRoaXMudGV4dHVyZXMgPSBudWxsO1xyXG5cdFx0dGhpcy5kZXB0aFRleHR1cmUgPSBudWxsO1xyXG5cdFx0dGhpcy5hY3RpdmVDdWJlRmFjZSA9IDA7XHJcblx0XHR0aGlzLnNhbXBsZUNvdW50ID0gMTtcclxuXHJcblx0XHR0aGlzLndpZHRoID0gMDtcclxuXHRcdHRoaXMuaGVpZ2h0ID0gMDtcclxuXHJcblx0XHR0aGlzLmlzUmVuZGVyQ29udGV4dCA9IHRydWU7XHJcblxyXG5cdH1cclxuXHJcblx0Z2V0Q2FjaGVLZXkoKSB7XHJcblxyXG5cdFx0cmV0dXJuIGdldENhY2hlS2V5KCB0aGlzICk7XHJcblxyXG5cdH1cclxuXHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRDYWNoZUtleSggcmVuZGVyQ29udGV4dCApIHtcclxuXHJcblx0Y29uc3QgeyB0ZXh0dXJlcywgYWN0aXZlQ3ViZUZhY2UgfSA9IHJlbmRlckNvbnRleHQ7XHJcblxyXG5cdGNvbnN0IHZhbHVlcyA9IFsgYWN0aXZlQ3ViZUZhY2UgXTtcclxuXHJcblx0Zm9yICggY29uc3QgdGV4dHVyZSBvZiB0ZXh0dXJlcyApIHtcclxuXHJcblx0XHR2YWx1ZXMucHVzaCggdGV4dHVyZS5pZCApO1xyXG5cclxuXHR9XHJcblxyXG5cdHJldHVybiBoYXNoQXJyYXkoIHZhbHVlcyApO1xyXG5cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgUmVuZGVyQ29udGV4dDtcclxuIiwiaW1wb3J0IENoYWluTWFwIGZyb20gJy4vQ2hhaW5NYXAuanMnO1xyXG5pbXBvcnQgUmVuZGVyQ29udGV4dCBmcm9tICcuL1JlbmRlckNvbnRleHQuanMnO1xyXG5cclxuY2xhc3MgUmVuZGVyQ29udGV4dHMge1xyXG5cclxuXHRjb25zdHJ1Y3RvcigpIHtcclxuXHJcblx0XHR0aGlzLmNoYWluTWFwcyA9IHt9O1xyXG5cclxuXHR9XHJcblxyXG5cdGdldCggc2NlbmUsIGNhbWVyYSwgcmVuZGVyVGFyZ2V0ID0gbnVsbCApIHtcclxuXHJcblx0XHRjb25zdCBjaGFpbktleSA9IFsgc2NlbmUsIGNhbWVyYSBdO1xyXG5cclxuXHRcdGxldCBhdHRhY2htZW50U3RhdGU7XHJcblxyXG5cdFx0aWYgKCByZW5kZXJUYXJnZXQgPT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHRhdHRhY2htZW50U3RhdGUgPSAnZGVmYXVsdCc7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdGNvbnN0IGZvcm1hdCA9IHJlbmRlclRhcmdldC50ZXh0dXJlLmZvcm1hdDtcclxuXHRcdFx0Y29uc3QgY291bnQgPSByZW5kZXJUYXJnZXQudGV4dHVyZXMubGVuZ3RoO1xyXG5cclxuXHRcdFx0YXR0YWNobWVudFN0YXRlID0gYCR7IGNvdW50IH06JHsgZm9ybWF0IH06JHsgcmVuZGVyVGFyZ2V0LnNhbXBsZXMgfTokeyByZW5kZXJUYXJnZXQuZGVwdGhCdWZmZXIgfTokeyByZW5kZXJUYXJnZXQuc3RlbmNpbEJ1ZmZlciB9YDtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Y29uc3QgY2hhaW5NYXAgPSB0aGlzLmdldENoYWluTWFwKCBhdHRhY2htZW50U3RhdGUgKTtcclxuXHJcblx0XHRsZXQgcmVuZGVyU3RhdGUgPSBjaGFpbk1hcC5nZXQoIGNoYWluS2V5ICk7XHJcblxyXG5cdFx0aWYgKCByZW5kZXJTdGF0ZSA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0cmVuZGVyU3RhdGUgPSBuZXcgUmVuZGVyQ29udGV4dCgpO1xyXG5cclxuXHRcdFx0Y2hhaW5NYXAuc2V0KCBjaGFpbktleSwgcmVuZGVyU3RhdGUgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCByZW5kZXJUYXJnZXQgIT09IG51bGwgKSByZW5kZXJTdGF0ZS5zYW1wbGVDb3VudCA9IHJlbmRlclRhcmdldC5zYW1wbGVzID09PSAwID8gMSA6IHJlbmRlclRhcmdldC5zYW1wbGVzO1xyXG5cclxuXHRcdHJldHVybiByZW5kZXJTdGF0ZTtcclxuXHJcblx0fVxyXG5cclxuXHRnZXRDaGFpbk1hcCggYXR0YWNobWVudFN0YXRlICkge1xyXG5cclxuXHRcdHJldHVybiB0aGlzLmNoYWluTWFwc1sgYXR0YWNobWVudFN0YXRlIF0gfHwgKCB0aGlzLmNoYWluTWFwc1sgYXR0YWNobWVudFN0YXRlIF0gPSBuZXcgQ2hhaW5NYXAoKSApO1xyXG5cclxuXHR9XHJcblxyXG5cdGRpc3Bvc2UoKSB7XHJcblxyXG5cdFx0dGhpcy5jaGFpbk1hcHMgPSB7fTtcclxuXHJcblx0fVxyXG5cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgUmVuZGVyQ29udGV4dHM7XHJcbiIsImltcG9ydCBEYXRhTWFwIGZyb20gJy4vRGF0YU1hcC5qcyc7XHJcblxyXG5pbXBvcnQgeyBWZWN0b3IzIH0gZnJvbSAnLi4vLi4vbWF0aC9WZWN0b3IzLmpzJztcclxuaW1wb3J0IHsgRGVwdGhUZXh0dXJlIH0gZnJvbSAnLi4vLi4vdGV4dHVyZXMvRGVwdGhUZXh0dXJlLmpzJztcclxuaW1wb3J0IHsgRGVwdGhTdGVuY2lsRm9ybWF0LCBEZXB0aEZvcm1hdCwgVW5zaWduZWRJbnRUeXBlLCBVbnNpZ25lZEludDI0OFR5cGUsIEVxdWlyZWN0YW5ndWxhclJlZmxlY3Rpb25NYXBwaW5nLCBFcXVpcmVjdGFuZ3VsYXJSZWZyYWN0aW9uTWFwcGluZywgQ3ViZVJlZmxlY3Rpb25NYXBwaW5nLCBDdWJlUmVmcmFjdGlvbk1hcHBpbmcsIFVuc2lnbmVkQnl0ZVR5cGUgfSBmcm9tICcuLi8uLi9jb25zdGFudHMuanMnO1xyXG5cclxuY29uc3QgX3NpemUgPSAvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IzKCk7XHJcblxyXG5jbGFzcyBUZXh0dXJlcyBleHRlbmRzIERhdGFNYXAge1xyXG5cclxuXHRjb25zdHJ1Y3RvciggcmVuZGVyZXIsIGJhY2tlbmQsIGluZm8gKSB7XHJcblxyXG5cdFx0c3VwZXIoKTtcclxuXHJcblx0XHR0aGlzLnJlbmRlcmVyID0gcmVuZGVyZXI7XHJcblx0XHR0aGlzLmJhY2tlbmQgPSBiYWNrZW5kO1xyXG5cdFx0dGhpcy5pbmZvID0gaW5mbztcclxuXHJcblx0fVxyXG5cclxuXHR1cGRhdGVSZW5kZXJUYXJnZXQoIHJlbmRlclRhcmdldCwgYWN0aXZlTWlwbWFwTGV2ZWwgPSAwICkge1xyXG5cclxuXHRcdGNvbnN0IHJlbmRlclRhcmdldERhdGEgPSB0aGlzLmdldCggcmVuZGVyVGFyZ2V0ICk7XHJcblxyXG5cdFx0Y29uc3Qgc2FtcGxlQ291bnQgPSByZW5kZXJUYXJnZXQuc2FtcGxlcyA9PT0gMCA/IDEgOiByZW5kZXJUYXJnZXQuc2FtcGxlcztcclxuXHRcdGNvbnN0IGRlcHRoVGV4dHVyZU1pcHMgPSByZW5kZXJUYXJnZXREYXRhLmRlcHRoVGV4dHVyZU1pcHMgfHwgKCByZW5kZXJUYXJnZXREYXRhLmRlcHRoVGV4dHVyZU1pcHMgPSB7fSApO1xyXG5cclxuXHRcdGNvbnN0IHRleHR1cmVzID0gcmVuZGVyVGFyZ2V0LnRleHR1cmVzO1xyXG5cclxuXHRcdGNvbnN0IHNpemUgPSB0aGlzLmdldFNpemUoIHRleHR1cmVzWyAwIF0gKTtcclxuXHJcblx0XHRjb25zdCBtaXBXaWR0aCA9IHNpemUud2lkdGggPj4gYWN0aXZlTWlwbWFwTGV2ZWw7XHJcblx0XHRjb25zdCBtaXBIZWlnaHQgPSBzaXplLmhlaWdodCA+PiBhY3RpdmVNaXBtYXBMZXZlbDtcclxuXHJcblx0XHRsZXQgZGVwdGhUZXh0dXJlID0gcmVuZGVyVGFyZ2V0LmRlcHRoVGV4dHVyZSB8fCBkZXB0aFRleHR1cmVNaXBzWyBhY3RpdmVNaXBtYXBMZXZlbCBdO1xyXG5cdFx0Y29uc3QgdXNlRGVwdGhUZXh0dXJlID0gcmVuZGVyVGFyZ2V0LmRlcHRoQnVmZmVyID09PSB0cnVlIHx8IHJlbmRlclRhcmdldC5zdGVuY2lsQnVmZmVyID09PSB0cnVlO1xyXG5cclxuXHRcdGxldCB0ZXh0dXJlTmVlZHNVcGRhdGUgPSBmYWxzZTtcclxuXHJcblx0XHRpZiAoIGRlcHRoVGV4dHVyZSA9PT0gdW5kZWZpbmVkICYmIHVzZURlcHRoVGV4dHVyZSApIHtcclxuXHJcblx0XHRcdGRlcHRoVGV4dHVyZSA9IG5ldyBEZXB0aFRleHR1cmUoKTtcclxuXHRcdFx0ZGVwdGhUZXh0dXJlLmZvcm1hdCA9IHJlbmRlclRhcmdldC5zdGVuY2lsQnVmZmVyID8gRGVwdGhTdGVuY2lsRm9ybWF0IDogRGVwdGhGb3JtYXQ7XHJcblx0XHRcdGRlcHRoVGV4dHVyZS50eXBlID0gcmVuZGVyVGFyZ2V0LnN0ZW5jaWxCdWZmZXIgPyBVbnNpZ25lZEludDI0OFR5cGUgOiBVbnNpZ25lZEludFR5cGU7IC8vIEZsb2F0VHlwZVxyXG5cdFx0XHRkZXB0aFRleHR1cmUuaW1hZ2Uud2lkdGggPSBtaXBXaWR0aDtcclxuXHRcdFx0ZGVwdGhUZXh0dXJlLmltYWdlLmhlaWdodCA9IG1pcEhlaWdodDtcclxuXHJcblx0XHRcdGRlcHRoVGV4dHVyZU1pcHNbIGFjdGl2ZU1pcG1hcExldmVsIF0gPSBkZXB0aFRleHR1cmU7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggcmVuZGVyVGFyZ2V0RGF0YS53aWR0aCAhPT0gc2l6ZS53aWR0aCB8fCBzaXplLmhlaWdodCAhPT0gcmVuZGVyVGFyZ2V0RGF0YS5oZWlnaHQgKSB7XHJcblxyXG5cdFx0XHR0ZXh0dXJlTmVlZHNVcGRhdGUgPSB0cnVlO1xyXG5cclxuXHRcdFx0aWYgKCBkZXB0aFRleHR1cmUgKSB7XHJcblxyXG5cdFx0XHRcdGRlcHRoVGV4dHVyZS5uZWVkc1VwZGF0ZSA9IHRydWU7XHJcblx0XHRcdFx0ZGVwdGhUZXh0dXJlLmltYWdlLndpZHRoID0gbWlwV2lkdGg7XHJcblx0XHRcdFx0ZGVwdGhUZXh0dXJlLmltYWdlLmhlaWdodCA9IG1pcEhlaWdodDtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmVuZGVyVGFyZ2V0RGF0YS53aWR0aCA9IHNpemUud2lkdGg7XHJcblx0XHRyZW5kZXJUYXJnZXREYXRhLmhlaWdodCA9IHNpemUuaGVpZ2h0O1xyXG5cdFx0cmVuZGVyVGFyZ2V0RGF0YS50ZXh0dXJlcyA9IHRleHR1cmVzO1xyXG5cdFx0cmVuZGVyVGFyZ2V0RGF0YS5kZXB0aFRleHR1cmUgPSBkZXB0aFRleHR1cmUgfHwgbnVsbDtcclxuXHRcdHJlbmRlclRhcmdldERhdGEuZGVwdGggPSByZW5kZXJUYXJnZXQuZGVwdGhCdWZmZXI7XHJcblx0XHRyZW5kZXJUYXJnZXREYXRhLnN0ZW5jaWwgPSByZW5kZXJUYXJnZXQuc3RlbmNpbEJ1ZmZlcjtcclxuXHRcdHJlbmRlclRhcmdldERhdGEucmVuZGVyVGFyZ2V0ID0gcmVuZGVyVGFyZ2V0O1xyXG5cclxuXHRcdGlmICggcmVuZGVyVGFyZ2V0RGF0YS5zYW1wbGVDb3VudCAhPT0gc2FtcGxlQ291bnQgKSB7XHJcblxyXG5cdFx0XHR0ZXh0dXJlTmVlZHNVcGRhdGUgPSB0cnVlO1xyXG5cclxuXHRcdFx0aWYgKCBkZXB0aFRleHR1cmUgKSB7XHJcblxyXG5cdFx0XHRcdGRlcHRoVGV4dHVyZS5uZWVkc1VwZGF0ZSA9IHRydWU7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRyZW5kZXJUYXJnZXREYXRhLnNhbXBsZUNvdW50ID0gc2FtcGxlQ291bnQ7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vXHJcblxyXG5cdFx0Y29uc3Qgb3B0aW9ucyA9IHsgc2FtcGxlQ291bnQgfTtcclxuXHJcblx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCB0ZXh0dXJlcy5sZW5ndGg7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRjb25zdCB0ZXh0dXJlID0gdGV4dHVyZXNbIGkgXTtcclxuXHJcblx0XHRcdGlmICggdGV4dHVyZU5lZWRzVXBkYXRlICkgdGV4dHVyZS5uZWVkc1VwZGF0ZSA9IHRydWU7XHJcblxyXG5cdFx0XHR0aGlzLnVwZGF0ZVRleHR1cmUoIHRleHR1cmUsIG9wdGlvbnMgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBkZXB0aFRleHR1cmUgKSB7XHJcblxyXG5cdFx0XHR0aGlzLnVwZGF0ZVRleHR1cmUoIGRlcHRoVGV4dHVyZSwgb3B0aW9ucyApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvLyBkaXNwb3NlIGhhbmRsZXJcclxuXHJcblx0XHRpZiAoIHJlbmRlclRhcmdldERhdGEuaW5pdGlhbGl6ZWQgIT09IHRydWUgKSB7XHJcblxyXG5cdFx0XHRyZW5kZXJUYXJnZXREYXRhLmluaXRpYWxpemVkID0gdHJ1ZTtcclxuXHJcblx0XHRcdC8vIGRpc3Bvc2VcclxuXHJcblx0XHRcdGNvbnN0IG9uRGlzcG9zZSA9ICgpID0+IHtcclxuXHJcblx0XHRcdFx0cmVuZGVyVGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoICdkaXNwb3NlJywgb25EaXNwb3NlICk7XHJcblxyXG5cdFx0XHRcdGZvciAoIGxldCBpID0gMDsgaSA8IHRleHR1cmVzLmxlbmd0aDsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0XHR0aGlzLl9kZXN0cm95VGV4dHVyZSggdGV4dHVyZXNbIGkgXSApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGlmICggZGVwdGhUZXh0dXJlICkge1xyXG5cclxuXHRcdFx0XHRcdHRoaXMuX2Rlc3Ryb3lUZXh0dXJlKCBkZXB0aFRleHR1cmUgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR0aGlzLmRlbGV0ZSggcmVuZGVyVGFyZ2V0ICk7XHJcblxyXG5cdFx0XHR9O1xyXG5cclxuXHRcdFx0cmVuZGVyVGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoICdkaXNwb3NlJywgb25EaXNwb3NlICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdHVwZGF0ZVRleHR1cmUoIHRleHR1cmUsIG9wdGlvbnMgPSB7fSApIHtcclxuXHJcblx0XHRjb25zdCB0ZXh0dXJlRGF0YSA9IHRoaXMuZ2V0KCB0ZXh0dXJlICk7XHJcblx0XHRpZiAoIHRleHR1cmVEYXRhLmluaXRpYWxpemVkID09PSB0cnVlICYmIHRleHR1cmVEYXRhLnZlcnNpb24gPT09IHRleHR1cmUudmVyc2lvbiApIHJldHVybjtcclxuXHJcblx0XHRjb25zdCBpc1JlbmRlclRhcmdldCA9IHRleHR1cmUuaXNSZW5kZXJUYXJnZXRUZXh0dXJlIHx8IHRleHR1cmUuaXNEZXB0aFRleHR1cmUgfHwgdGV4dHVyZS5pc0ZyYW1lYnVmZmVyVGV4dHVyZTtcclxuXHRcdGNvbnN0IGJhY2tlbmQgPSB0aGlzLmJhY2tlbmQ7XHJcblxyXG5cdFx0aWYgKCBpc1JlbmRlclRhcmdldCAmJiB0ZXh0dXJlRGF0YS5pbml0aWFsaXplZCA9PT0gdHJ1ZSApIHtcclxuXHJcblx0XHRcdC8vIGl0J3MgYW4gdXBkYXRlXHJcblxyXG5cdFx0XHRiYWNrZW5kLmRlc3Ryb3lTYW1wbGVyKCB0ZXh0dXJlICk7XHJcblx0XHRcdGJhY2tlbmQuZGVzdHJveVRleHR1cmUoIHRleHR1cmUgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly9cclxuXHJcblx0XHRpZiAoIHRleHR1cmUuaXNGcmFtZWJ1ZmZlclRleHR1cmUgKSB7XHJcblxyXG5cdFx0XHRjb25zdCByZW5kZXJUYXJnZXQgPSB0aGlzLnJlbmRlcmVyLmdldFJlbmRlclRhcmdldCgpO1xyXG5cclxuXHRcdFx0aWYgKCByZW5kZXJUYXJnZXQgKSB7XHJcblxyXG5cdFx0XHRcdHRleHR1cmUudHlwZSA9IHJlbmRlclRhcmdldC50ZXh0dXJlLnR5cGU7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHR0ZXh0dXJlLnR5cGUgPSBVbnNpZ25lZEJ5dGVUeXBlO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvL1xyXG5cclxuXHRcdGNvbnN0IHsgd2lkdGgsIGhlaWdodCwgZGVwdGggfSA9IHRoaXMuZ2V0U2l6ZSggdGV4dHVyZSApO1xyXG5cclxuXHRcdG9wdGlvbnMud2lkdGggPSB3aWR0aDtcclxuXHRcdG9wdGlvbnMuaGVpZ2h0ID0gaGVpZ2h0O1xyXG5cdFx0b3B0aW9ucy5kZXB0aCA9IGRlcHRoO1xyXG5cdFx0b3B0aW9ucy5uZWVkc01pcG1hcHMgPSB0aGlzLm5lZWRzTWlwbWFwcyggdGV4dHVyZSApO1xyXG5cdFx0b3B0aW9ucy5sZXZlbHMgPSBvcHRpb25zLm5lZWRzTWlwbWFwcyA/IHRoaXMuZ2V0TWlwTGV2ZWxzKCB0ZXh0dXJlLCB3aWR0aCwgaGVpZ2h0ICkgOiAxO1xyXG5cclxuXHRcdC8vXHJcblxyXG5cdFx0aWYgKCBpc1JlbmRlclRhcmdldCB8fCB0ZXh0dXJlLmlzU3RvcmFnZVRleHR1cmUgPT09IHRydWUgKSB7XHJcblxyXG5cdFx0XHRiYWNrZW5kLmNyZWF0ZVNhbXBsZXIoIHRleHR1cmUgKTtcclxuXHRcdFx0YmFja2VuZC5jcmVhdGVUZXh0dXJlKCB0ZXh0dXJlLCBvcHRpb25zICk7XHJcblxyXG5cdFx0XHR0ZXh0dXJlRGF0YS5nZW5lcmF0aW9uID0gdGV4dHVyZS52ZXJzaW9uO1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRjb25zdCBuZWVkc0NyZWF0ZSA9IHRleHR1cmVEYXRhLmluaXRpYWxpemVkICE9PSB0cnVlO1xyXG5cclxuXHRcdFx0aWYgKCBuZWVkc0NyZWF0ZSApIGJhY2tlbmQuY3JlYXRlU2FtcGxlciggdGV4dHVyZSApO1xyXG5cclxuXHRcdFx0aWYgKCB0ZXh0dXJlLnZlcnNpb24gPiAwICkge1xyXG5cclxuXHRcdFx0XHRjb25zdCBpbWFnZSA9IHRleHR1cmUuaW1hZ2U7XHJcblxyXG5cdFx0XHRcdGlmICggaW1hZ2UgPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5SZW5kZXJlcjogVGV4dHVyZSBtYXJrZWQgZm9yIHVwZGF0ZSBidXQgaW1hZ2UgaXMgdW5kZWZpbmVkLicgKTtcclxuXHJcblx0XHRcdFx0fSBlbHNlIGlmICggaW1hZ2UuY29tcGxldGUgPT09IGZhbHNlICkge1xyXG5cclxuXHRcdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLlJlbmRlcmVyOiBUZXh0dXJlIG1hcmtlZCBmb3IgdXBkYXRlIGJ1dCBpbWFnZSBpcyBpbmNvbXBsZXRlLicgKTtcclxuXHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHRpZiAoIHRleHR1cmUuaW1hZ2VzICkge1xyXG5cclxuXHRcdFx0XHRcdFx0Y29uc3QgaW1hZ2VzID0gW107XHJcblxyXG5cdFx0XHRcdFx0XHRmb3IgKCBjb25zdCBpbWFnZSBvZiB0ZXh0dXJlLmltYWdlcyApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0aW1hZ2VzLnB1c2goIGltYWdlICk7XHJcblxyXG5cdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0XHRvcHRpb25zLmltYWdlcyA9IGltYWdlcztcclxuXHJcblx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdFx0b3B0aW9ucy5pbWFnZSA9IGltYWdlO1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRpZiAoIHRleHR1cmVEYXRhLmlzRGVmYXVsdFRleHR1cmUgPT09IHVuZGVmaW5lZCB8fCB0ZXh0dXJlRGF0YS5pc0RlZmF1bHRUZXh0dXJlID09PSB0cnVlICkge1xyXG5cclxuXHRcdFx0XHRcdFx0YmFja2VuZC5jcmVhdGVUZXh0dXJlKCB0ZXh0dXJlLCBvcHRpb25zICk7XHJcblxyXG5cdFx0XHRcdFx0XHR0ZXh0dXJlRGF0YS5pc0RlZmF1bHRUZXh0dXJlID0gZmFsc2U7XHJcblx0XHRcdFx0XHRcdHRleHR1cmVEYXRhLmdlbmVyYXRpb24gPSB0ZXh0dXJlLnZlcnNpb247XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdGlmICggdGV4dHVyZS5zb3VyY2UuZGF0YVJlYWR5ID09PSB0cnVlICkgYmFja2VuZC51cGRhdGVUZXh0dXJlKCB0ZXh0dXJlLCBvcHRpb25zICk7XHJcblxyXG5cdFx0XHRcdFx0aWYgKCBvcHRpb25zLm5lZWRzTWlwbWFwcyAmJiB0ZXh0dXJlLm1pcG1hcHMubGVuZ3RoID09PSAwICkgYmFja2VuZC5nZW5lcmF0ZU1pcG1hcHMoIHRleHR1cmUgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0Ly8gYXN5bmMgdXBkYXRlXHJcblxyXG5cdFx0XHRcdGJhY2tlbmQuY3JlYXRlRGVmYXVsdFRleHR1cmUoIHRleHR1cmUgKTtcclxuXHJcblx0XHRcdFx0dGV4dHVyZURhdGEuaXNEZWZhdWx0VGV4dHVyZSA9IHRydWU7XHJcblx0XHRcdFx0dGV4dHVyZURhdGEuZ2VuZXJhdGlvbiA9IHRleHR1cmUudmVyc2lvbjtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gZGlzcG9zZSBoYW5kbGVyXHJcblxyXG5cdFx0aWYgKCB0ZXh0dXJlRGF0YS5pbml0aWFsaXplZCAhPT0gdHJ1ZSApIHtcclxuXHJcblx0XHRcdHRleHR1cmVEYXRhLmluaXRpYWxpemVkID0gdHJ1ZTtcclxuXHRcdFx0dGV4dHVyZURhdGEuZ2VuZXJhdGlvbiA9IHRleHR1cmUudmVyc2lvbjtcclxuXHJcblx0XHRcdC8vXHJcblxyXG5cdFx0XHR0aGlzLmluZm8ubWVtb3J5LnRleHR1cmVzICsrO1xyXG5cclxuXHRcdFx0Ly8gZGlzcG9zZVxyXG5cclxuXHRcdFx0Y29uc3Qgb25EaXNwb3NlID0gKCkgPT4ge1xyXG5cclxuXHRcdFx0XHR0ZXh0dXJlLnJlbW92ZUV2ZW50TGlzdGVuZXIoICdkaXNwb3NlJywgb25EaXNwb3NlICk7XHJcblxyXG5cdFx0XHRcdHRoaXMuX2Rlc3Ryb3lUZXh0dXJlKCB0ZXh0dXJlICk7XHJcblxyXG5cdFx0XHRcdHRoaXMuaW5mby5tZW1vcnkudGV4dHVyZXMgLS07XHJcblxyXG5cdFx0XHR9O1xyXG5cclxuXHRcdFx0dGV4dHVyZS5hZGRFdmVudExpc3RlbmVyKCAnZGlzcG9zZScsIG9uRGlzcG9zZSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvL1xyXG5cclxuXHRcdHRleHR1cmVEYXRhLnZlcnNpb24gPSB0ZXh0dXJlLnZlcnNpb247XHJcblxyXG5cdH1cclxuXHJcblx0Z2V0U2l6ZSggdGV4dHVyZSwgdGFyZ2V0ID0gX3NpemUgKSB7XHJcblxyXG5cdFx0bGV0IGltYWdlID0gdGV4dHVyZS5pbWFnZXMgPyB0ZXh0dXJlLmltYWdlc1sgMCBdIDogdGV4dHVyZS5pbWFnZTtcclxuXHJcblx0XHRpZiAoIGltYWdlICkge1xyXG5cclxuXHRcdFx0aWYgKCBpbWFnZS5pbWFnZSAhPT0gdW5kZWZpbmVkICkgaW1hZ2UgPSBpbWFnZS5pbWFnZTtcclxuXHJcblx0XHRcdHRhcmdldC53aWR0aCA9IGltYWdlLndpZHRoIHx8IDE7XHJcblx0XHRcdHRhcmdldC5oZWlnaHQgPSBpbWFnZS5oZWlnaHQgfHwgMTtcclxuXHRcdFx0dGFyZ2V0LmRlcHRoID0gdGV4dHVyZS5pc0N1YmVUZXh0dXJlID8gNiA6ICggaW1hZ2UuZGVwdGggfHwgMSApO1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHR0YXJnZXQud2lkdGggPSB0YXJnZXQuaGVpZ2h0ID0gdGFyZ2V0LmRlcHRoID0gMTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRhcmdldDtcclxuXHJcblx0fVxyXG5cclxuXHRnZXRNaXBMZXZlbHMoIHRleHR1cmUsIHdpZHRoLCBoZWlnaHQgKSB7XHJcblxyXG5cdFx0bGV0IG1pcExldmVsQ291bnQ7XHJcblxyXG5cdFx0aWYgKCB0ZXh0dXJlLmlzQ29tcHJlc3NlZFRleHR1cmUgKSB7XHJcblxyXG5cdFx0XHRpZiAoIHRleHR1cmUubWlwbWFwcyApIHtcclxuXHJcblx0XHRcdFx0bWlwTGV2ZWxDb3VudCA9IHRleHR1cmUubWlwbWFwcy5sZW5ndGg7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRtaXBMZXZlbENvdW50ID0gMTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0bWlwTGV2ZWxDb3VudCA9IE1hdGguZmxvb3IoIE1hdGgubG9nMiggTWF0aC5tYXgoIHdpZHRoLCBoZWlnaHQgKSApICkgKyAxO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gbWlwTGV2ZWxDb3VudDtcclxuXHJcblx0fVxyXG5cclxuXHRuZWVkc01pcG1hcHMoIHRleHR1cmUgKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuaXNFbnZpcm9ubWVudFRleHR1cmUoIHRleHR1cmUgKSB8fCB0ZXh0dXJlLmlzQ29tcHJlc3NlZFRleHR1cmUgPT09IHRydWUgfHwgdGV4dHVyZS5nZW5lcmF0ZU1pcG1hcHM7XHJcblxyXG5cdH1cclxuXHJcblx0aXNFbnZpcm9ubWVudFRleHR1cmUoIHRleHR1cmUgKSB7XHJcblxyXG5cdFx0Y29uc3QgbWFwcGluZyA9IHRleHR1cmUubWFwcGluZztcclxuXHJcblx0XHRyZXR1cm4gKCBtYXBwaW5nID09PSBFcXVpcmVjdGFuZ3VsYXJSZWZsZWN0aW9uTWFwcGluZyB8fCBtYXBwaW5nID09PSBFcXVpcmVjdGFuZ3VsYXJSZWZyYWN0aW9uTWFwcGluZyApIHx8ICggbWFwcGluZyA9PT0gQ3ViZVJlZmxlY3Rpb25NYXBwaW5nIHx8IG1hcHBpbmcgPT09IEN1YmVSZWZyYWN0aW9uTWFwcGluZyApO1xyXG5cclxuXHR9XHJcblxyXG5cdF9kZXN0cm95VGV4dHVyZSggdGV4dHVyZSApIHtcclxuXHJcblx0XHR0aGlzLmJhY2tlbmQuZGVzdHJveVNhbXBsZXIoIHRleHR1cmUgKTtcclxuXHRcdHRoaXMuYmFja2VuZC5kZXN0cm95VGV4dHVyZSggdGV4dHVyZSApO1xyXG5cclxuXHRcdHRoaXMuZGVsZXRlKCB0ZXh0dXJlICk7XHJcblxyXG5cdH1cclxuXHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IFRleHR1cmVzO1xyXG4iLCJpbXBvcnQgeyBDb2xvciB9IGZyb20gJy4uLy4uL21hdGgvQ29sb3IuanMnO1xyXG5cclxuY2xhc3MgQ29sb3I0IGV4dGVuZHMgQ29sb3Ige1xyXG5cclxuXHRjb25zdHJ1Y3RvciggciwgZywgYiwgYSA9IDEgKSB7XHJcblxyXG5cdFx0c3VwZXIoIHIsIGcsIGIgKTtcclxuXHJcblx0XHR0aGlzLmEgPSBhO1xyXG5cclxuXHR9XHJcblxyXG5cdHNldCggciwgZywgYiwgYSA9IDEgKSB7XHJcblxyXG5cdFx0dGhpcy5hID0gYTtcclxuXHJcblx0XHRyZXR1cm4gc3VwZXIuc2V0KCByLCBnLCBiICk7XHJcblxyXG5cdH1cclxuXHJcblx0Y29weSggY29sb3IgKSB7XHJcblxyXG5cdFx0aWYgKCBjb2xvci5hICE9PSB1bmRlZmluZWQgKSB0aGlzLmEgPSBjb2xvci5hO1xyXG5cclxuXHRcdHJldHVybiBzdXBlci5jb3B5KCBjb2xvciApO1xyXG5cclxuXHR9XHJcblxyXG5cdGNsb25lKCkge1xyXG5cclxuXHRcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvciggdGhpcy5yLCB0aGlzLmcsIHRoaXMuYiwgdGhpcy5hICk7XHJcblxyXG5cdH1cclxuXHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IENvbG9yNDtcclxuIiwiaW1wb3J0IHsgbm9kZU9iamVjdCB9IGZyb20gJy4uL3RzbC9UU0xCYXNlLmpzJztcclxuaW1wb3J0IFByb3BlcnR5Tm9kZSBmcm9tICcuL1Byb3BlcnR5Tm9kZS5qcyc7XHJcblxyXG4vKiogQG1vZHVsZSBQYXJhbWV0ZXJOb2RlICoqL1xyXG5cclxuLyoqXHJcbiAqIFNwZWNpYWwgdmVyc2lvbiBvZiB7QGxpbmsgUHJvcGVydHlOb2RlfSB3aGljaCBpcyB1c2VkIGZvciBwYXJhbWV0ZXJzLlxyXG4gKlxyXG4gKiBAYXVnbWVudHMgUHJvcGVydHlOb2RlXHJcbiAqL1xyXG5jbGFzcyBQYXJhbWV0ZXJOb2RlIGV4dGVuZHMgUHJvcGVydHlOb2RlIHtcclxuXHJcblx0c3RhdGljIGdldCB0eXBlKCkge1xyXG5cclxuXHRcdHJldHVybiAnUGFyYW1ldGVyTm9kZSc7XHJcblxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogQ29uc3RydWN0cyBhIG5ldyBwYXJhbWV0ZXIgbm9kZS5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBub2RlVHlwZSAtIFRoZSB0eXBlIG9mIHRoZSBub2RlLlxyXG5cdCAqIEBwYXJhbSB7U3RyaW5nP30gW25hbWU9bnVsbF0gLSBUaGUgbmFtZSBvZiB0aGUgcGFyYW1ldGVyIGluIHRoZSBzaGFkZXIuXHJcblx0ICovXHJcblx0Y29uc3RydWN0b3IoIG5vZGVUeXBlLCBuYW1lID0gbnVsbCApIHtcclxuXHJcblx0XHRzdXBlciggbm9kZVR5cGUsIG5hbWUgKTtcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIFRoaXMgZmxhZyBjYW4gYmUgdXNlZCBmb3IgdHlwZSB0ZXN0aW5nLlxyXG5cdFx0ICpcclxuXHRcdCAqIEB0eXBlIHtCb29sZWFufVxyXG5cdFx0ICogQHJlYWRvbmx5XHJcblx0XHQgKiBAZGVmYXVsdCB0cnVlXHJcblx0XHQgKi9cclxuXHRcdHRoaXMuaXNQYXJhbWV0ZXJOb2RlID0gdHJ1ZTtcclxuXHJcblx0fVxyXG5cclxuXHRnZXRIYXNoKCkge1xyXG5cclxuXHRcdHJldHVybiB0aGlzLnV1aWQ7XHJcblxyXG5cdH1cclxuXHJcblx0Z2VuZXJhdGUoKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMubmFtZTtcclxuXHJcblx0fVxyXG5cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgUGFyYW1ldGVyTm9kZTtcclxuXHJcbi8qKlxyXG4gKiBUU0wgZnVuY3Rpb24gZm9yIGNyZWF0aW5nIGEgcGFyYW1ldGVyIG5vZGUuXHJcbiAqXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZSAtIFRoZSB0eXBlIG9mIHRoZSBub2RlLlxyXG4gKiBAcGFyYW0ge1N0cmluZz99IG5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgcGFyYW1ldGVyIGluIHRoZSBzaGFkZXIuXHJcbiAqIEByZXR1cm5zIHtQYXJhbWV0ZXJOb2RlfVxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IHBhcmFtZXRlciA9ICggdHlwZSwgbmFtZSApID0+IG5vZGVPYmplY3QoIG5ldyBQYXJhbWV0ZXJOb2RlKCB0eXBlLCBuYW1lICkgKTtcclxuIiwiaW1wb3J0IE5vZGUgZnJvbSAnLi9Ob2RlLmpzJztcclxuaW1wb3J0IHsgc2VsZWN0IH0gZnJvbSAnLi4vbWF0aC9Db25kaXRpb25hbE5vZGUuanMnO1xyXG5pbXBvcnQgeyBTaGFkZXJOb2RlLCBub2RlUHJveHksIGdldEN1cnJlbnRTdGFjaywgc2V0Q3VycmVudFN0YWNrIH0gZnJvbSAnLi4vdHNsL1RTTEJhc2UuanMnO1xyXG5cclxuLyoqIEBtb2R1bGUgU3RhY2tOb2RlICoqL1xyXG5cclxuLyoqXHJcbiAqIFN0YWNrIGlzIGEgaGVscGVyIGZvciBOb2RlcyB0aGF0IG5lZWQgdG8gcHJvZHVjZSBzdGFjay1iYXNlZCBjb2RlIGluc3RlYWQgb2YgY29udGludW91cyBmbG93LlxyXG4gKiBUaGV5IGFyZSB1c3VhbGx5IG5lZWRlZCBpbiBjYXNlcyBsaWtlIGBJZmAsIGBFbHNlYC5cclxuICpcclxuICogQGF1Z21lbnRzIE5vZGVcclxuICovXHJcbmNsYXNzIFN0YWNrTm9kZSBleHRlbmRzIE5vZGUge1xyXG5cclxuXHRzdGF0aWMgZ2V0IHR5cGUoKSB7XHJcblxyXG5cdFx0cmV0dXJuICdTdGFja05vZGUnO1xyXG5cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIENvbnN0cnVjdHMgYSBuZXcgc3RhY2sgbm9kZS5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7U3RhY2tOb2RlP30gW3BhcmVudD1udWxsXSAtIFRoZSBwYXJlbnQgc3RhY2sgbm9kZS5cclxuXHQgKi9cclxuXHRjb25zdHJ1Y3RvciggcGFyZW50ID0gbnVsbCApIHtcclxuXHJcblx0XHRzdXBlcigpO1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogTGlzdCBvZiBub2Rlcy5cclxuXHRcdCAqXHJcblx0XHQgKiBAdHlwZSB7QXJyYXk8Tm9kZT59XHJcblx0XHQgKi9cclxuXHRcdHRoaXMubm9kZXMgPSBbXTtcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIFRoZSBvdXRwdXQgbm9kZS5cclxuXHRcdCAqXHJcblx0XHQgKiBAdHlwZSB7Tm9kZT99XHJcblx0XHQgKiBAZGVmYXVsdCBudWxsXHJcblx0XHQgKi9cclxuXHRcdHRoaXMub3V0cHV0Tm9kZSA9IG51bGw7XHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBUaGUgcGFyZW50IHN0YWNrIG5vZGUuXHJcblx0XHQgKlxyXG5cdFx0ICogQHR5cGUge1N0YWNrTm9kZX1cclxuXHRcdCAqIEBkZWZhdWx0IG51bGxcclxuXHRcdCAqL1xyXG5cdFx0dGhpcy5wYXJlbnQgPSBwYXJlbnQ7XHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBUaGUgY3VycmVudCBjb25kaXRpb25hbCBub2RlLlxyXG5cdFx0ICpcclxuXHRcdCAqIEBwcml2YXRlXHJcblx0XHQgKiBAdHlwZSB7Q29uZGl0aW9uYWxOb2RlfVxyXG5cdFx0ICogQGRlZmF1bHQgbnVsbFxyXG5cdFx0ICovXHJcblx0XHR0aGlzLl9jdXJyZW50Q29uZCA9IG51bGw7XHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBUaGlzIGZsYWcgY2FuIGJlIHVzZWQgZm9yIHR5cGUgdGVzdGluZy5cclxuXHRcdCAqXHJcblx0XHQgKiBAdHlwZSB7Qm9vbGVhbn1cclxuXHRcdCAqIEByZWFkb25seVxyXG5cdFx0ICogQGRlZmF1bHQgdHJ1ZVxyXG5cdFx0ICovXHJcblx0XHR0aGlzLmlzU3RhY2tOb2RlID0gdHJ1ZTtcclxuXHJcblx0fVxyXG5cclxuXHRnZXROb2RlVHlwZSggYnVpbGRlciApIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5vdXRwdXROb2RlID8gdGhpcy5vdXRwdXROb2RlLmdldE5vZGVUeXBlKCBidWlsZGVyICkgOiAndm9pZCc7XHJcblxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogQWRkcyBhIG5vZGUgdG8gdGhpcyBzdGFjay5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7Tm9kZX0gbm9kZSAtIFRoZSBub2RlIHRvIGFkZC5cclxuXHQgKiBAcmV0dXJuIHtTdGFja05vZGV9IEEgcmVmZXJlbmNlIHRvIHRoaXMgc3RhY2sgbm9kZS5cclxuXHQgKi9cclxuXHRhZGQoIG5vZGUgKSB7XHJcblxyXG5cdFx0dGhpcy5ub2Rlcy5wdXNoKCBub2RlICk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogUmVwcmVzZW50IGFuIGBpZmAgc3RhdGVtZW50IGluIFRTTC5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7Tm9kZX0gYm9vbE5vZGUgLSBSZXByZXNlbnRzIHRoZSBjb25kaXRpb24uXHJcblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gbWV0aG9kIC0gVFNMIGNvZGUgd2hpY2ggaXMgZXhlY3V0ZWQgaWYgdGhlIGNvbmRpdGlvbiBldmFsdWF0ZXMgdG8gYHRydWVgLlxyXG5cdCAqIEByZXR1cm4ge1N0YWNrTm9kZX0gQSByZWZlcmVuY2UgdG8gdGhpcyBzdGFjayBub2RlLlxyXG5cdCAqL1xyXG5cdElmKCBib29sTm9kZSwgbWV0aG9kICkge1xyXG5cclxuXHRcdGNvbnN0IG1ldGhvZE5vZGUgPSBuZXcgU2hhZGVyTm9kZSggbWV0aG9kICk7XHJcblx0XHR0aGlzLl9jdXJyZW50Q29uZCA9IHNlbGVjdCggYm9vbE5vZGUsIG1ldGhvZE5vZGUgKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5hZGQoIHRoaXMuX2N1cnJlbnRDb25kICk7XHJcblxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogUmVwcmVzZW50IGFuIGBlbHNlaWZgIHN0YXRlbWVudCBpbiBUU0wuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge05vZGV9IGJvb2xOb2RlIC0gUmVwcmVzZW50cyB0aGUgY29uZGl0aW9uLlxyXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IG1ldGhvZCAtIFRTTCBjb2RlIHdoaWNoIGlzIGV4ZWN1dGVkIGlmIHRoZSBjb25kaXRpb24gZXZhbHVhdGVzIHRvIGB0cnVlYC5cclxuXHQgKiBAcmV0dXJuIHtTdGFja05vZGV9IEEgcmVmZXJlbmNlIHRvIHRoaXMgc3RhY2sgbm9kZS5cclxuXHQgKi9cclxuXHRFbHNlSWYoIGJvb2xOb2RlLCBtZXRob2QgKSB7XHJcblxyXG5cdFx0Y29uc3QgbWV0aG9kTm9kZSA9IG5ldyBTaGFkZXJOb2RlKCBtZXRob2QgKTtcclxuXHRcdGNvbnN0IGlmTm9kZSA9IHNlbGVjdCggYm9vbE5vZGUsIG1ldGhvZE5vZGUgKTtcclxuXHJcblx0XHR0aGlzLl9jdXJyZW50Q29uZC5lbHNlTm9kZSA9IGlmTm9kZTtcclxuXHRcdHRoaXMuX2N1cnJlbnRDb25kID0gaWZOb2RlO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFJlcHJlc2VudCBhbiBgZWxzZWAgc3RhdGVtZW50IGluIFRTTC5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IG1ldGhvZCAtIFRTTCBjb2RlIHdoaWNoIGlzIGV4ZWN1dGVkIGluIHRoZSBgZWxzZWAgY2FzZS5cclxuXHQgKiBAcmV0dXJuIHtTdGFja05vZGV9IEEgcmVmZXJlbmNlIHRvIHRoaXMgc3RhY2sgbm9kZS5cclxuXHQgKi9cclxuXHRFbHNlKCBtZXRob2QgKSB7XHJcblxyXG5cdFx0dGhpcy5fY3VycmVudENvbmQuZWxzZU5vZGUgPSBuZXcgU2hhZGVyTm9kZSggbWV0aG9kICk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHJcblx0YnVpbGQoIGJ1aWxkZXIsIC4uLnBhcmFtcyApIHtcclxuXHJcblx0XHRjb25zdCBwcmV2aW91c1N0YWNrID0gZ2V0Q3VycmVudFN0YWNrKCk7XHJcblxyXG5cdFx0c2V0Q3VycmVudFN0YWNrKCB0aGlzICk7XHJcblxyXG5cdFx0Zm9yICggY29uc3Qgbm9kZSBvZiB0aGlzLm5vZGVzICkge1xyXG5cclxuXHRcdFx0bm9kZS5idWlsZCggYnVpbGRlciwgJ3ZvaWQnICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHNldEN1cnJlbnRTdGFjayggcHJldmlvdXNTdGFjayApO1xyXG5cclxuXHRcdHJldHVybiB0aGlzLm91dHB1dE5vZGUgPyB0aGlzLm91dHB1dE5vZGUuYnVpbGQoIGJ1aWxkZXIsIC4uLnBhcmFtcyApIDogc3VwZXIuYnVpbGQoIGJ1aWxkZXIsIC4uLnBhcmFtcyApO1xyXG5cclxuXHR9XHJcblxyXG5cdC8vXHJcblxyXG5cdGVsc2UoIC4uLnBhcmFtcyApIHsgLy8gQGRlcHJlY2F0ZWQsIHIxNjhcclxuXHJcblx0XHRjb25zb2xlLndhcm4oICdUU0wuU3RhY2tOb2RlOiAuZWxzZSgpIGhhcyBiZWVuIHJlbmFtZWQgdG8gLkVsc2UoKS4nICk7XHJcblx0XHRyZXR1cm4gdGhpcy5FbHNlKCAuLi5wYXJhbXMgKTtcclxuXHJcblx0fVxyXG5cclxuXHRlbHNlaWYoIC4uLnBhcmFtcyApIHsgLy8gQGRlcHJlY2F0ZWQsIHIxNjhcclxuXHJcblx0XHRjb25zb2xlLndhcm4oICdUU0wuU3RhY2tOb2RlOiAuZWxzZWlmKCkgaGFzIGJlZW4gcmVuYW1lZCB0byAuRWxzZUlmKCkuJyApO1xyXG5cdFx0cmV0dXJuIHRoaXMuRWxzZUlmKCAuLi5wYXJhbXMgKTtcclxuXHJcblx0fVxyXG5cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgU3RhY2tOb2RlO1xyXG5cclxuLyoqXHJcbiAqIFRTTCBmdW5jdGlvbiBmb3IgY3JlYXRpbmcgYSBzdGFjayBub2RlLlxyXG4gKlxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHtTdGFja05vZGU/fSBbcGFyZW50PW51bGxdIC0gVGhlIHBhcmVudCBzdGFjayBub2RlLlxyXG4gKiBAcmV0dXJucyB7U3RhY2tOb2RlfVxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IHN0YWNrID0gLypAX19QVVJFX18qLyBub2RlUHJveHkoIFN0YWNrTm9kZSApO1xyXG4iLCJpbXBvcnQgTm9kZSBmcm9tICcuL05vZGUuanMnO1xyXG5pbXBvcnQgeyBub2RlUHJveHkgfSBmcm9tICcuLi90c2wvVFNMQmFzZS5qcyc7XHJcblxyXG4vKiogQG1vZHVsZSBPdXRwdXRTdHJ1Y3ROb2RlICoqL1xyXG5cclxuLyoqXHJcbiAqIFRoaXMgbm9kZSBjYW4gYmUgdXNlZCB0byBkZWZpbmUgbXVsdGlwbGUgb3V0cHV0cyBpbiBhIHNoYWRlciBwcm9ncmFtcy5cclxuICpcclxuICogQGF1Z21lbnRzIE5vZGVcclxuICovXHJcbmNsYXNzIE91dHB1dFN0cnVjdE5vZGUgZXh0ZW5kcyBOb2RlIHtcclxuXHJcblx0c3RhdGljIGdldCB0eXBlKCkge1xyXG5cclxuXHRcdHJldHVybiAnT3V0cHV0U3RydWN0Tm9kZSc7XHJcblxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogQ29uc3RydWN0cyBhIG5ldyBvdXRwdXQgc3RydWN0IG5vZGUuIFRoZSBjb25zdHJ1Y3RvciBjYW4gYmUgaW52b2tlZCB3aXRoIGFuXHJcblx0ICogYXJiaXRyYXJ5IG51bWJlciBvZiBub2RlcyByZXByZXNlbnRpbmcgdGhlIG1lbWJlcnMuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0gey4uLk5vZGV9IG1lbWJlcnMgLSBBIHBhcmFtZXRlciBsaXN0IG9mIG5vZGVzLlxyXG5cdCAqL1xyXG5cdGNvbnN0cnVjdG9yKCAuLi5tZW1iZXJzICkge1xyXG5cclxuXHRcdHN1cGVyKCk7XHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBBbiBhcnJheSBvZiBub2RlcyB3aGljaCBkZWZpbmVzIHRoZSBvdXRwdXQuXHJcblx0XHQgKlxyXG5cdFx0ICogQHR5cGUge0FycmF5PE5vZGU+fVxyXG5cdFx0ICovXHJcblx0XHR0aGlzLm1lbWJlcnMgPSBtZW1iZXJzO1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogVGhpcyBmbGFnIGNhbiBiZSB1c2VkIGZvciB0eXBlIHRlc3RpbmcuXHJcblx0XHQgKlxyXG5cdFx0ICogQHR5cGUge0Jvb2xlYW59XHJcblx0XHQgKiBAcmVhZG9ubHlcclxuXHRcdCAqIEBkZWZhdWx0IHRydWVcclxuXHRcdCAqL1xyXG5cdFx0dGhpcy5pc091dHB1dFN0cnVjdE5vZGUgPSB0cnVlO1xyXG5cclxuXHR9XHJcblxyXG5cdHNldHVwKCBidWlsZGVyICkge1xyXG5cclxuXHRcdHN1cGVyLnNldHVwKCBidWlsZGVyICk7XHJcblxyXG5cdFx0Y29uc3QgbWVtYmVycyA9IHRoaXMubWVtYmVycztcclxuXHRcdGNvbnN0IHR5cGVzID0gW107XHJcblxyXG5cdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgbWVtYmVycy5sZW5ndGg7IGkgKysgKSB7XHJcblxyXG5cdFx0XHR0eXBlcy5wdXNoKCBtZW1iZXJzWyBpIF0uZ2V0Tm9kZVR5cGUoIGJ1aWxkZXIgKSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLm5vZGVUeXBlID0gYnVpbGRlci5nZXRTdHJ1Y3RUeXBlRnJvbU5vZGUoIHRoaXMsIHR5cGVzICkubmFtZTtcclxuXHJcblx0fVxyXG5cclxuXHRnZW5lcmF0ZSggYnVpbGRlciwgb3V0cHV0ICkge1xyXG5cclxuXHRcdGNvbnN0IHByb3BlcnR5TmFtZSA9IGJ1aWxkZXIuZ2V0T3V0cHV0U3RydWN0TmFtZSgpO1xyXG5cdFx0Y29uc3QgbWVtYmVycyA9IHRoaXMubWVtYmVycztcclxuXHJcblx0XHRjb25zdCBzdHJ1Y3RQcmVmaXggPSBwcm9wZXJ0eU5hbWUgIT09ICcnID8gcHJvcGVydHlOYW1lICsgJy4nIDogJyc7XHJcblxyXG5cdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgbWVtYmVycy5sZW5ndGg7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRjb25zdCBzbmlwcGV0ID0gbWVtYmVyc1sgaSBdLmJ1aWxkKCBidWlsZGVyLCBvdXRwdXQgKTtcclxuXHJcblx0XHRcdGJ1aWxkZXIuYWRkTGluZUZsb3dDb2RlKCBgJHsgc3RydWN0UHJlZml4IH1tJHsgaSB9ID0gJHsgc25pcHBldCB9YCwgdGhpcyApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gcHJvcGVydHlOYW1lO1xyXG5cclxuXHR9XHJcblxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBPdXRwdXRTdHJ1Y3ROb2RlO1xyXG5cclxuLyoqXHJcbiAqIFRTTCBmdW5jdGlvbiBmb3IgY3JlYXRpbmcgYW4gb3V0cHV0IHN0cnVjdCBub2RlLlxyXG4gKlxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHsuLi5Ob2RlfSBtZW1iZXJzIC0gQSBwYXJhbWV0ZXIgbGlzdCBvZiBub2Rlcy5cclxuICogQHJldHVybnMge091dHB1dFN0cnVjdE5vZGV9XHJcbiAqL1xyXG5leHBvcnQgY29uc3Qgb3V0cHV0U3RydWN0ID0gLypAX19QVVJFX18qLyBub2RlUHJveHkoIE91dHB1dFN0cnVjdE5vZGUgKTtcclxuIiwiaW1wb3J0IE91dHB1dFN0cnVjdE5vZGUgZnJvbSAnLi9PdXRwdXRTdHJ1Y3ROb2RlLmpzJztcclxuaW1wb3J0IHsgbm9kZVByb3h5LCB2ZWM0IH0gZnJvbSAnLi4vdHNsL1RTTEJhc2UuanMnO1xyXG5cclxuLyoqIEBtb2R1bGUgTVJUTm9kZSAqKi9cclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBNUlQgdGV4dHVyZSBpbmRleCBmb3IgdGhlIGdpdmVuIG5hbWUuXHJcbiAqXHJcbiAqIEBwYXJhbSB7QXJyYXk8VGV4dHVyZT59IHRleHR1cmVzIC0gVGhlIHRleHR1cmVzIG9mIGEgTVJULWNvbmZpZ3VyZWQgcmVuZGVyIHRhcmdldC5cclxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgTVJUIHRleHR1cmUgd2hpY2ggaW5kZXggaXMgcmVxdWVzdGVkLlxyXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSB0ZXh0dXJlIGluZGV4LlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGdldFRleHR1cmVJbmRleCggdGV4dHVyZXMsIG5hbWUgKSB7XHJcblxyXG5cdGZvciAoIGxldCBpID0gMDsgaSA8IHRleHR1cmVzLmxlbmd0aDsgaSArKyApIHtcclxuXHJcblx0XHRpZiAoIHRleHR1cmVzWyBpIF0ubmFtZSA9PT0gbmFtZSApIHtcclxuXHJcblx0XHRcdHJldHVybiBpO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHRyZXR1cm4gLSAxO1xyXG5cclxufVxyXG5cclxuLyoqXHJcbiAqIFRoaXMgbm9kZSBjYW4gYmUgdXNlZCBzZXR1cCBhIE1SVCBjb250ZXh0IGZvciByZW5kZXJpbmcuIEEgdHlwaWNhbCBNUlQgc2V0dXAgZm9yXHJcbiAqIHBvc3QtcHJvY2Vzc2luZyBpcyBzaG93biBiZWxvdzpcclxuICogYGBganNcclxuICogY29uc3QgbXJ0Tm9kZSA9IG1ydCgge1xyXG4gKiAgIG91dHB1dDogb3V0cHV0LFxyXG4gKiAgIG5vcm1hbDogbm9ybWFsVmlld1xyXG4gKiB9ICkgKTtcclxuICogYGBgXHJcbiAqIFRoZSBNUlQgb3V0cHV0IGlzIGRlZmluZWQgYXMgYSBkaWN0aW9uYXJ5LlxyXG4gKlxyXG4gKiBAYXVnbWVudHMgT3V0cHV0U3RydWN0Tm9kZVxyXG4gKi9cclxuY2xhc3MgTVJUTm9kZSBleHRlbmRzIE91dHB1dFN0cnVjdE5vZGUge1xyXG5cclxuXHRzdGF0aWMgZ2V0IHR5cGUoKSB7XHJcblxyXG5cdFx0cmV0dXJuICdNUlROb2RlJztcclxuXHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBDb25zdHJ1Y3RzIGEgbmV3IG91dHB1dCBzdHJ1Y3Qgbm9kZS5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7T2JqZWN0PFN0cmluZywgTm9kZT59IG91dHB1dE5vZGVzIC0gVGhlIE1SVCBvdXRwdXRzLlxyXG5cdCAqL1xyXG5cdGNvbnN0cnVjdG9yKCBvdXRwdXROb2RlcyApIHtcclxuXHJcblx0XHRzdXBlcigpO1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogQSBkaWN0aW9uYXJ5IHJlcHJlc2VudGluZyB0aGUgTVJUIG91dHB1dHMuIFRoZSBrZXlcclxuXHRcdCAqIGlzIHRoZSBuYW1lIG9mIHRoZSBvdXRwdXQsIHRoZSB2YWx1ZSB0aGUgbm9kZSB3aGljaCBwcm9kdWNlc1xyXG5cdFx0ICogdGhlIG91dHB1dCByZXN1bHQuXHJcblx0XHQgKlxyXG5cdFx0ICogQHR5cGUge09iamVjdDxTdHJpbmcsIE5vZGU+fVxyXG5cdFx0ICovXHJcblx0XHR0aGlzLm91dHB1dE5vZGVzID0gb3V0cHV0Tm9kZXM7XHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBUaGlzIGZsYWcgY2FuIGJlIHVzZWQgZm9yIHR5cGUgdGVzdGluZy5cclxuXHRcdCAqXHJcblx0XHQgKiBAdHlwZSB7Qm9vbGVhbn1cclxuXHRcdCAqIEByZWFkb25seVxyXG5cdFx0ICogQGRlZmF1bHQgdHJ1ZVxyXG5cdFx0ICovXHJcblx0XHR0aGlzLmlzTVJUTm9kZSA9IHRydWU7XHJcblxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIE1SVCBub2RlIGhhcyBhbiBvdXRwdXQgd2l0aCB0aGUgZ2l2ZW4gbmFtZS5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIC0gVGhlIG5hbWUgb2YgdGhlIG91dHB1dC5cclxuXHQgKiBAcmV0dXJuIHtOb2RlQnVpbGRlcn0gV2hldGhlciB0aGUgTVJUIG5vZGUgaGFzIGFuIG91dHB1dCBmb3IgdGhlIGdpdmVuIG5hbWUgb3Igbm90LlxyXG5cdCAqL1xyXG5cdGhhcyggbmFtZSApIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5vdXRwdXROb2Rlc1sgbmFtZSBdICE9PSB1bmRlZmluZWQ7XHJcblxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogUmV0dXJucyB0aGUgb3V0cHV0IG5vZGUgZm9yIHRoZSBnaXZlbiBuYW1lLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgb3V0cHV0LlxyXG5cdCAqIEByZXR1cm4ge05vZGV9IFRoZSBvdXRwdXQgbm9kZS5cclxuXHQgKi9cclxuXHRnZXQoIG5hbWUgKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMub3V0cHV0Tm9kZXNbIG5hbWUgXTtcclxuXHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBNZXJnZXMgdGhlIG91dHB1dHMgb2YgdGhlIGdpdmVuIE1SVCBub2RlIHdpdGggdGhlIG91dHB1dHMgb2YgdGhpcyBub2RlLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtNUlROb2RlfSBtcnROb2RlIC0gVGhlIE1SVCB0byBtZXJnZS5cclxuXHQgKiBAcmV0dXJuIHtNUlROb2RlfSBBIG5ldyBNUlQgbm9kZSB3aXRoIG1lcmdlZCBvdXRwdXRzLi5cclxuXHQgKi9cclxuXHRtZXJnZSggbXJ0Tm9kZSApIHtcclxuXHJcblx0XHRjb25zdCBvdXRwdXRzID0geyAuLi50aGlzLm91dHB1dE5vZGVzLCAuLi5tcnROb2RlLm91dHB1dE5vZGVzIH07XHJcblxyXG5cdFx0cmV0dXJuIG1ydCggb3V0cHV0cyApO1xyXG5cclxuXHR9XHJcblxyXG5cdHNldHVwKCBidWlsZGVyICkge1xyXG5cclxuXHRcdGNvbnN0IG91dHB1dE5vZGVzID0gdGhpcy5vdXRwdXROb2RlcztcclxuXHRcdGNvbnN0IG1ydCA9IGJ1aWxkZXIucmVuZGVyZXIuZ2V0UmVuZGVyVGFyZ2V0KCk7XHJcblxyXG5cdFx0Y29uc3QgbWVtYmVycyA9IFtdO1xyXG5cclxuXHRcdGNvbnN0IHRleHR1cmVzID0gbXJ0LnRleHR1cmVzO1xyXG5cclxuXHRcdGZvciAoIGNvbnN0IG5hbWUgaW4gb3V0cHV0Tm9kZXMgKSB7XHJcblxyXG5cdFx0XHRjb25zdCBpbmRleCA9IGdldFRleHR1cmVJbmRleCggdGV4dHVyZXMsIG5hbWUgKTtcclxuXHJcblx0XHRcdG1lbWJlcnNbIGluZGV4IF0gPSB2ZWM0KCBvdXRwdXROb2Rlc1sgbmFtZSBdICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMubWVtYmVycyA9IG1lbWJlcnM7XHJcblxyXG5cdFx0cmV0dXJuIHN1cGVyLnNldHVwKCBidWlsZGVyICk7XHJcblxyXG5cdH1cclxuXHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IE1SVE5vZGU7XHJcblxyXG4vKipcclxuICogVFNMIGZ1bmN0aW9uIGZvciBjcmVhdGluZyBhIE1SVCBub2RlLlxyXG4gKlxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHtPYmplY3Q8U3RyaW5nLCBOb2RlPn0gb3V0cHV0Tm9kZXMgLSBUaGUgTVJUIG91dHB1dHMuXHJcbiAqIEByZXR1cm5zIHtNUlROb2RlfVxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IG1ydCA9IC8qQF9fUFVSRV9fKi8gbm9kZVByb3h5KCBNUlROb2RlICk7XHJcbiIsImltcG9ydCB7IEZuIH0gZnJvbSAnLi4vdHNsL1RTTEJhc2UuanMnO1xyXG5cclxuLyoqIEBtb2R1bGUgSGFzaCAqKi9cclxuXHJcbi8qKlxyXG4gKiBHZW5lcmF0ZXMgYSBoYXNoIHZhbHVlIGluIHRoZSByYW5nZSBgWzAsIDFdYCBmcm9tIHRoZSBnaXZlbiBzZWVkLlxyXG4gKlxyXG4gKiBAbWV0aG9kXHJcbiAqIEBwYXJhbSB7Tm9kZTxmbG9hdD59IHNlZWQgLSBUaGUgc2VlZC5cclxuICogQHJldHVybiB7Tm9kZTxmbG9hdD59IFRoZSBoYXNoIHZhbHVlLlxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IGhhc2ggPSAvKkBfX1BVUkVfXyovIEZuKCAoIFsgc2VlZCBdICkgPT4ge1xyXG5cclxuXHQvLyBUYWtlbiBmcm9tIGh0dHBzOi8vd3d3LnNoYWRlcnRveS5jb20vdmlldy9YbEdjUmgsIG9yaWdpbmFsbHkgZnJvbSBwY2ctcmFuZG9tLm9yZ1xyXG5cclxuXHRjb25zdCBzdGF0ZSA9IHNlZWQudG9VaW50KCkubXVsKCA3NDc3OTY0MDUgKS5hZGQoIDI4OTEzMzY0NTMgKTtcclxuXHRjb25zdCB3b3JkID0gc3RhdGUuc2hpZnRSaWdodCggc3RhdGUuc2hpZnRSaWdodCggMjggKS5hZGQoIDQgKSApLmJpdFhvciggc3RhdGUgKS5tdWwoIDI3NzgwMzczNyApO1xyXG5cdGNvbnN0IHJlc3VsdCA9IHdvcmQuc2hpZnRSaWdodCggMjIgKS5iaXRYb3IoIHdvcmQgKTtcclxuXHJcblx0cmV0dXJuIHJlc3VsdC50b0Zsb2F0KCkubXVsKCAxIC8gMiAqKiAzMiApOyAvLyBDb252ZXJ0IHRvIHJhbmdlIFswLCAxKVxyXG5cclxufSApO1xyXG4iLCJpbXBvcnQgeyBzdWIsIG11bCwgZGl2LCBhZGQgfSBmcm9tICcuL09wZXJhdG9yTm9kZS5qcyc7XHJcbmltcG9ydCB7IFBJLCBwb3csIHNpbiB9IGZyb20gJy4vTWF0aE5vZGUuanMnO1xyXG5cclxuLyoqIEBtb2R1bGUgTWF0aFV0aWxzICoqL1xyXG5cclxuLyoqXHJcbiAqIEEgZnVuY3Rpb24gdGhhdCByZW1hcHMgdGhlIGBbMCwxXWAgaW50ZXJ2YWwgaW50byB0aGUgYFswLDFdYCBpbnRlcnZhbC5cclxuICogVGhlIGNvcm5lcnMgYXJlIG1hcHBlZCB0byBgMGAgYW5kIHRoZSBjZW50ZXIgdG8gYDFgLlxyXG4gKiBSZWZlcmVuY2U6IHtAbGluayBodHRwczovL2lxdWlsZXpsZXMub3JnL2FydGljbGVzL2Z1bmN0aW9ucy99LlxyXG4gKlxyXG4gKiBAbWV0aG9kXHJcbiAqIEBwYXJhbSB7Tm9kZTxmbG9hdD59IHggLSBUaGUgdmFsdWUgdG8gcmVtYXAuXHJcbiAqIEBwYXJhbSB7Tm9kZTxmbG9hdD59IGsgLSBBbGxvd3MgdG8gY29udHJvbCB0aGUgcmVtYXBwaW5nIGZ1bmN0aW9ucyBzaGFwZSBieSByaXNpbmcgdGhlIHBhcmFib2xhIHRvIGEgcG93ZXIgYGtgLlxyXG4gKiBAcmV0dXJuIHtOb2RlPGZsb2F0Pn0gVGhlIHJlbWFwcGVkIHZhbHVlLlxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IHBhcmFib2xhID0gKCB4LCBrICkgPT4gcG93KCBtdWwoIDQuMCwgeC5tdWwoIHN1YiggMS4wLCB4ICkgKSApLCBrICk7XHJcblxyXG4vKipcclxuICogQSBmdW5jdGlvbiB0aGF0IHJlbWFwcyB0aGUgYFswLDFdYCBpbnRlcnZhbCBpbnRvIHRoZSBgWzAsMV1gIGludGVydmFsLlxyXG4gKiBFeHBhbmRzIHRoZSBzaWRlcyBhbmQgY29tcHJlc3NlcyB0aGUgY2VudGVyLCBhbmQga2VlcHMgYDAuNWAgbWFwcGVkIHRvIGAwLjVgLlxyXG4gKiBSZWZlcmVuY2U6IHtAbGluayBodHRwczovL2lxdWlsZXpsZXMub3JnL2FydGljbGVzL2Z1bmN0aW9ucy99LlxyXG4gKlxyXG4gKiBAbWV0aG9kXHJcbiAqIEBwYXJhbSB7Tm9kZTxmbG9hdD59IHggLSBUaGUgdmFsdWUgdG8gcmVtYXAuXHJcbiAqIEBwYXJhbSB7Tm9kZTxmbG9hdD59IGsgLSBgaz0xYCBpcyB0aGUgaWRlbnRpdHkgY3VydmUsYGs8MWAgcHJvZHVjZXMgdGhlIGNsYXNzaWMgYGdhaW4oKWAgc2hhcGUsIGFuZCBgaz4xYCBwcm9kdWNlcyBcInNcIiBzaGFwZWQgY3VydmVzLlxyXG4gKiBAcmV0dXJuIHtOb2RlPGZsb2F0Pn0gVGhlIHJlbWFwcGVkIHZhbHVlLlxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IGdhaW4gPSAoIHgsIGsgKSA9PiB4Lmxlc3NUaGFuKCAwLjUgKSA/IHBhcmFib2xhKCB4Lm11bCggMi4wICksIGsgKS5kaXYoIDIuMCApIDogc3ViKCAxLjAsIHBhcmFib2xhKCBtdWwoIHN1YiggMS4wLCB4ICksIDIuMCApLCBrICkuZGl2KCAyLjAgKSApO1xyXG5cclxuLyoqXHJcbiAqIEEgZnVuY3Rpb24gdGhhdCByZW1hcHMgdGhlIGBbMCwxXWAgaW50ZXJ2YWwgaW50byB0aGUgYFswLDFdYCBpbnRlcnZhbC5cclxuICogQSBnZW5lcmFsaXphdGlvbiBvZiB0aGUgYHBhcmFib2xhKClgLiBLZWVwcyB0aGUgY29ybmVycyBtYXBwZWQgdG8gMCBidXQgYWxsb3dzIHRoZSBjb250cm9sIG9mIHRoZSBzaGFwZSBvbmUgZWl0aGVyIHNpZGUgb2YgdGhlIGN1cnZlLlxyXG4gKiBSZWZlcmVuY2U6IHtAbGluayBodHRwczovL2lxdWlsZXpsZXMub3JnL2FydGljbGVzL2Z1bmN0aW9ucy99LlxyXG4gKlxyXG4gKiBAbWV0aG9kXHJcbiAqIEBwYXJhbSB7Tm9kZTxmbG9hdD59IHggLSBUaGUgdmFsdWUgdG8gcmVtYXAuXHJcbiAqIEBwYXJhbSB7Tm9kZTxmbG9hdD59IGEgLSBGaXJzdCBjb250cm9sIHBhcmFtZXRlci5cclxuICogQHBhcmFtIHtOb2RlPGZsb2F0Pn0gYiAtIFNlY29uZCBjb250cm9sIHBhcmFtZXRlci5cclxuICogQHJldHVybiB7Tm9kZTxmbG9hdD59IFRoZSByZW1hcHBlZCB2YWx1ZS5cclxuICovXHJcbmV4cG9ydCBjb25zdCBwY3VydmUgPSAoIHgsIGEsIGIgKSA9PiBwb3coIGRpdiggcG93KCB4LCBhICksIGFkZCggcG93KCB4LCBhICksIHBvdyggc3ViKCAxLjAsIHggKSwgYiApICkgKSwgMS4wIC8gYSApO1xyXG5cclxuLyoqXHJcbiAqIEEgcGhhc2Ugc2hpZnRlZCBzaW51cyBjdXJ2ZSB0aGF0IHN0YXJ0cyBhdCB6ZXJvIGFuZCBlbmRzIGF0IHplcm8sIHdpdGggYm91bmNpbmcgYmVoYXZpb3IuXHJcbiAqIFJlZmVyZW5jZToge0BsaW5rIGh0dHBzOi8vaXF1aWxlemxlcy5vcmcvYXJ0aWNsZXMvZnVuY3Rpb25zL30uXHJcbiAqXHJcbiAqIEBtZXRob2RcclxuICogQHBhcmFtIHtOb2RlPGZsb2F0Pn0geCAtIFRoZSB2YWx1ZSB0byBjb21wdXRlIHRoZSBzaW4gZm9yLlxyXG4gKiBAcGFyYW0ge05vZGU8ZmxvYXQ+fSBrIC0gQ29udHJvbHMgdGhlIGFtb3VudCBvZiBib3VuY2VzLlxyXG4gKiBAcmV0dXJuIHtOb2RlPGZsb2F0Pn0gVGhlIHJlc3VsdCB2YWx1ZS5cclxuICovXHJcbmV4cG9ydCBjb25zdCBzaW5jID0gKCB4LCBrICkgPT4gc2luKCBQSS5tdWwoIGsubXVsKCB4ICkuc3ViKCAxLjAgKSApICkuZGl2KCBQSS5tdWwoIGsubXVsKCB4ICkuc3ViKCAxLjAgKSApICk7XHJcbiIsIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9jYWJiaWJvL2dsc2wtdHJpLW5vaXNlLTNkXHJcblxyXG5pbXBvcnQgeyBMb29wIH0gZnJvbSAnLi4vdXRpbHMvTG9vcE5vZGUuanMnO1xyXG5pbXBvcnQgeyBmbG9hdCwgdmVjMywgRm4gfSBmcm9tICcuLi90c2wvVFNMQmFzZS5qcyc7XHJcblxyXG4vKiogQG1vZHVsZSBUcmlOb2lzZTNEICoqL1xyXG5cclxuY29uc3QgdHJpID0gLypAX19QVVJFX18qLyBGbiggKCBbIHggXSApID0+IHtcclxuXHJcblx0cmV0dXJuIHguZnJhY3QoKS5zdWIoIC41ICkuYWJzKCk7XHJcblxyXG59ICkuc2V0TGF5b3V0KCB7XHJcblx0bmFtZTogJ3RyaScsXHJcblx0dHlwZTogJ2Zsb2F0JyxcclxuXHRpbnB1dHM6IFtcclxuXHRcdHsgbmFtZTogJ3gnLCB0eXBlOiAnZmxvYXQnIH1cclxuXHRdXHJcbn0gKTtcclxuXHJcbmNvbnN0IHRyaTMgPSAvKkBfX1BVUkVfXyovIEZuKCAoIFsgcCBdICkgPT4ge1xyXG5cclxuXHRyZXR1cm4gdmVjMyggdHJpKCBwLnouYWRkKCB0cmkoIHAueS5tdWwoIDEuICkgKSApICksIHRyaSggcC56LmFkZCggdHJpKCBwLngubXVsKCAxLiApICkgKSApLCB0cmkoIHAueS5hZGQoIHRyaSggcC54Lm11bCggMS4gKSApICkgKSApO1xyXG5cclxufSApLnNldExheW91dCgge1xyXG5cdG5hbWU6ICd0cmkzJyxcclxuXHR0eXBlOiAndmVjMycsXHJcblx0aW5wdXRzOiBbXHJcblx0XHR7IG5hbWU6ICdwJywgdHlwZTogJ3ZlYzMnIH1cclxuXHRdXHJcbn0gKTtcclxuXHJcbi8qKlxyXG4gKiBHZW5lcmF0ZXMgYSBub2lzZSB2YWx1ZSBmcm9tIHRoZSBnaXZlbiBwb3NpdGlvbiwgc3BlZWQgYW5kIHRpbWUgcGFyYW1ldGVycy5cclxuICpcclxuICogQG1ldGhvZFxyXG4gKiBAcGFyYW0ge05vZGU8dmVjMz59IHBvc2l0aW9uIC0gVGhlIHBvc2l0aW9uLlxyXG4gKiBAcGFyYW0ge05vZGU8ZmxvYXQ+fSBzcGVlZCAtIFRoZSBzcGVlZC5cclxuICogQHBhcmFtIHtOb2RlPGZsb2F0Pn0gdGltZSAtIFRoZSB0aW1lLlxyXG4gKiBAcmV0dXJuIHtOb2RlPGZsb2F0Pn0gVGhlIGdlbmVyYXRlZCBub2lzZS5cclxuICovXHJcbmV4cG9ydCBjb25zdCB0cmlOb2lzZTNEID0gLypAX19QVVJFX18qLyBGbiggKCBbIHBvc2l0aW9uLCBzcGVlZCwgdGltZSBdICkgPT4ge1xyXG5cclxuXHRjb25zdCBwID0gdmVjMyggcG9zaXRpb24gKS50b1ZhcigpO1xyXG5cdGNvbnN0IHogPSBmbG9hdCggMS40ICkudG9WYXIoKTtcclxuXHRjb25zdCByeiA9IGZsb2F0KCAwLjAgKS50b1ZhcigpO1xyXG5cdGNvbnN0IGJwID0gdmVjMyggcCApLnRvVmFyKCk7XHJcblxyXG5cdExvb3AoIHsgc3RhcnQ6IGZsb2F0KCAwLjAgKSwgZW5kOiBmbG9hdCggMy4wICksIHR5cGU6ICdmbG9hdCcsIGNvbmRpdGlvbjogJzw9JyB9LCAoKSA9PiB7XHJcblxyXG5cdFx0Y29uc3QgZGcgPSB2ZWMzKCB0cmkzKCBicC5tdWwoIDIuMCApICkgKS50b1ZhcigpO1xyXG5cdFx0cC5hZGRBc3NpZ24oIGRnLmFkZCggdGltZS5tdWwoIGZsb2F0KCAwLjEgKS5tdWwoIHNwZWVkICkgKSApICk7XHJcblx0XHRicC5tdWxBc3NpZ24oIDEuOCApO1xyXG5cdFx0ei5tdWxBc3NpZ24oIDEuNSApO1xyXG5cdFx0cC5tdWxBc3NpZ24oIDEuMiApO1xyXG5cclxuXHRcdGNvbnN0IHQgPSBmbG9hdCggdHJpKCBwLnouYWRkKCB0cmkoIHAueC5hZGQoIHRyaSggcC55ICkgKSApICkgKSApLnRvVmFyKCk7XHJcblx0XHRyei5hZGRBc3NpZ24oIHQuZGl2KCB6ICkgKTtcclxuXHRcdGJwLmFkZEFzc2lnbiggMC4xNCApO1xyXG5cclxuXHR9ICk7XHJcblxyXG5cdHJldHVybiByejtcclxuXHJcbn0gKS5zZXRMYXlvdXQoIHtcclxuXHRuYW1lOiAndHJpTm9pc2UzRCcsXHJcblx0dHlwZTogJ2Zsb2F0JyxcclxuXHRpbnB1dHM6IFtcclxuXHRcdHsgbmFtZTogJ3Bvc2l0aW9uJywgdHlwZTogJ3ZlYzMnIH0sXHJcblx0XHR7IG5hbWU6ICdzcGVlZCcsIHR5cGU6ICdmbG9hdCcgfSxcclxuXHRcdHsgbmFtZTogJ3RpbWUnLCB0eXBlOiAnZmxvYXQnIH1cclxuXHRdXHJcbn0gKTtcclxuIiwiaW1wb3J0IE5vZGUgZnJvbSAnLi4vY29yZS9Ob2RlLmpzJztcclxuaW1wb3J0IHsgbm9kZVByb3h5IH0gZnJvbSAnLi4vdHNsL1RTTEJhc2UuanMnO1xyXG5cclxuLyoqIEBtb2R1bGUgRnVuY3Rpb25PdmVybG9hZGluZ05vZGUgKiovXHJcblxyXG4vKipcclxuICogVGhpcyBjbGFzcyBhbGxvd3MgdG8gZGVmaW5lIG11bHRpcGxlIG92ZXJsb2FkZWQgdmVyc2lvbnNcclxuICogb2YgdGhlIHNhbWUgZnVuY3Rpb24uIERlcGVuZGluZyBvbiB0aGUgcGFyYW1ldGVycyBvZiB0aGUgZnVuY3Rpb25cclxuICogY2FsbCwgdGhlIG5vZGUgcGlja3MgdGhlIGJlc3QtZml0IG92ZXJsb2FkZWQgdmVyc2lvbi5cclxuICpcclxuICogQGF1Z21lbnRzIE5vZGVcclxuICovXHJcbmNsYXNzIEZ1bmN0aW9uT3ZlcmxvYWRpbmdOb2RlIGV4dGVuZHMgTm9kZSB7XHJcblxyXG5cdHN0YXRpYyBnZXQgdHlwZSgpIHtcclxuXHJcblx0XHRyZXR1cm4gJ0Z1bmN0aW9uT3ZlcmxvYWRpbmdOb2RlJztcclxuXHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBDb25zdHJ1Y3RzIGEgbmV3IGZ1bmN0aW9uIG92ZXJsb2FkaW5nIG5vZGUuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge0FycmF5PEZ1bmN0aW9uPn0gZnVuY3Rpb25Ob2RlcyAtIEFycmF5IG9mIGBGbmAgZnVuY3Rpb24gZGVmaW5pdGlvbnMuXHJcblx0ICogQHBhcmFtIHsuLi5Ob2RlfSBwYXJhbWV0ZXJzTm9kZXMgLSBBIGxpc3Qgb2YgcGFyYW1ldGVyIG5vZGVzLlxyXG5cdCAqL1xyXG5cdGNvbnN0cnVjdG9yKCBmdW5jdGlvbk5vZGVzID0gW10sIC4uLnBhcmFtZXRlcnNOb2RlcyApIHtcclxuXHJcblx0XHRzdXBlcigpO1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogQXJyYXkgb2YgYEZuYCBmdW5jdGlvbiBkZWZpbml0aW9ucy5cclxuXHRcdCAqXHJcblx0XHQgKiBAdHlwZSB7QXJyYXk8RnVuY3Rpb24+fVxyXG5cdFx0ICovXHJcblx0XHR0aGlzLmZ1bmN0aW9uTm9kZXMgPSBmdW5jdGlvbk5vZGVzO1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogQSBsaXN0IG9mIHBhcmFtZXRlciBub2Rlcy5cclxuXHRcdCAqXHJcblx0XHQgKiBAdHlwZSB7QXJyYXk8Tm9kZT59XHJcblx0XHQgKi9cclxuXHRcdHRoaXMucGFyYW1ldGVyc05vZGVzID0gcGFyYW1ldGVyc05vZGVzO1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogVGhlIHNlbGVjdGVkIG92ZXJsb2FkZWQgZnVuY3Rpb24gY2FsbC5cclxuXHRcdCAqXHJcblx0XHQgKiBAcHJpdmF0ZVxyXG5cdFx0ICogQHR5cGUge1NoYWRlckNhbGxOb2RlSW50ZXJuYWx9XHJcblx0XHQgKi9cclxuXHRcdHRoaXMuX2NhbmRpZGF0ZUZuQ2FsbCA9IG51bGw7XHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBUaGlzIG5vZGUgaXMgbWFya2VkIGFzIGdsb2JhbC5cclxuXHRcdCAqXHJcblx0XHQgKiBAdHlwZSB7Qm9vbGVhbn1cclxuXHRcdCAqIEBkZWZhdWx0IHRydWVcclxuXHRcdCAqL1xyXG5cdFx0dGhpcy5nbG9iYWwgPSB0cnVlO1xyXG5cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFRoaXMgbWV0aG9kIGlzIG92ZXJ3cml0dGVuIHNpbmNlIHRoZSBub2RlIHR5cGUgaXMgaW5mZXJyZWQgZnJvbVxyXG5cdCAqIHRoZSBmdW5jdGlvbidzIHJldHVybiB0eXBlLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtOb2RlQnVpbGRlcn0gYnVpbGRlciAtIFRoZSBjdXJyZW50IG5vZGUgYnVpbGRlci5cclxuXHQgKiBAcmV0dXJuIHtTdHJpbmd9IFRoZSBub2RlIHR5cGUuXHJcblx0ICovXHJcblx0Z2V0Tm9kZVR5cGUoKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuZnVuY3Rpb25Ob2Rlc1sgMCBdLnNoYWRlck5vZGUubGF5b3V0LnR5cGU7XHJcblxyXG5cdH1cclxuXHJcblx0c2V0dXAoIGJ1aWxkZXIgKSB7XHJcblxyXG5cdFx0Y29uc3QgcGFyYW1zID0gdGhpcy5wYXJhbWV0ZXJzTm9kZXM7XHJcblxyXG5cdFx0bGV0IGNhbmRpZGF0ZUZuQ2FsbCA9IHRoaXMuX2NhbmRpZGF0ZUZuQ2FsbDtcclxuXHJcblx0XHRpZiAoIGNhbmRpZGF0ZUZuQ2FsbCA9PT0gbnVsbCApIHtcclxuXHJcblx0XHRcdGxldCBjYW5kaWRhdGVGbiA9IG51bGw7XHJcblx0XHRcdGxldCBjYW5kaWRhdGVTY29yZSA9IC0gMTtcclxuXHJcblx0XHRcdGZvciAoIGNvbnN0IGZ1bmN0aW9uTm9kZSBvZiB0aGlzLmZ1bmN0aW9uTm9kZXMgKSB7XHJcblxyXG5cdFx0XHRcdGNvbnN0IHNoYWRlck5vZGUgPSBmdW5jdGlvbk5vZGUuc2hhZGVyTm9kZTtcclxuXHRcdFx0XHRjb25zdCBsYXlvdXQgPSBzaGFkZXJOb2RlLmxheW91dDtcclxuXHJcblx0XHRcdFx0aWYgKCBsYXlvdXQgPT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCAnRnVuY3Rpb25PdmVybG9hZGluZ05vZGU6IEZ1bmN0aW9uTm9kZSBtdXN0IGJlIGEgbGF5b3V0LicgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRjb25zdCBpbnB1dHMgPSBsYXlvdXQuaW5wdXRzO1xyXG5cclxuXHRcdFx0XHRpZiAoIHBhcmFtcy5sZW5ndGggPT09IGlucHV0cy5sZW5ndGggKSB7XHJcblxyXG5cdFx0XHRcdFx0bGV0IHNjb3JlID0gMDtcclxuXHJcblx0XHRcdFx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCBwYXJhbXMubGVuZ3RoOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHRcdFx0Y29uc3QgcGFyYW0gPSBwYXJhbXNbIGkgXTtcclxuXHRcdFx0XHRcdFx0Y29uc3QgaW5wdXQgPSBpbnB1dHNbIGkgXTtcclxuXHJcblx0XHRcdFx0XHRcdGlmICggcGFyYW0uZ2V0Tm9kZVR5cGUoIGJ1aWxkZXIgKSA9PT0gaW5wdXQudHlwZSApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0c2NvcmUgKys7XHJcblxyXG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdFx0XHRzY29yZSA9IDA7XHJcblxyXG5cdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdGlmICggc2NvcmUgPiBjYW5kaWRhdGVTY29yZSApIHtcclxuXHJcblx0XHRcdFx0XHRcdGNhbmRpZGF0ZUZuID0gZnVuY3Rpb25Ob2RlO1xyXG5cdFx0XHRcdFx0XHRjYW5kaWRhdGVTY29yZSA9IHNjb3JlO1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dGhpcy5fY2FuZGlkYXRlRm5DYWxsID0gY2FuZGlkYXRlRm5DYWxsID0gY2FuZGlkYXRlRm4oIC4uLnBhcmFtcyApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gY2FuZGlkYXRlRm5DYWxsO1xyXG5cclxuXHR9XHJcblxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBGdW5jdGlvbk92ZXJsb2FkaW5nTm9kZTtcclxuXHJcbmNvbnN0IG92ZXJsb2FkaW5nQmFzZUZuID0gLypAX19QVVJFX18qLyBub2RlUHJveHkoIEZ1bmN0aW9uT3ZlcmxvYWRpbmdOb2RlICk7XHJcblxyXG4vKipcclxuICogVFNMIGZ1bmN0aW9uIGZvciBjcmVhdGluZyBhIGZ1bmN0aW9uIG92ZXJsb2FkaW5nIG5vZGUuXHJcbiAqXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0ge0FycmF5PEZ1bmN0aW9uPn0gZnVuY3Rpb25Ob2RlcyAtIEFycmF5IG9mIGBGbmAgZnVuY3Rpb24gZGVmaW5pdGlvbnMuXHJcbiAqIEByZXR1cm5zIHtGdW5jdGlvbk92ZXJsb2FkaW5nTm9kZX1cclxuICovXHJcbmV4cG9ydCBjb25zdCBvdmVybG9hZGluZ0ZuID0gKCBmdW5jdGlvbk5vZGVzICkgPT4gKCAuLi5wYXJhbXMgKSA9PiBvdmVybG9hZGluZ0Jhc2VGbiggZnVuY3Rpb25Ob2RlcywgLi4ucGFyYW1zICk7XHJcbiIsImltcG9ydCB7IHJlbmRlckdyb3VwIH0gZnJvbSAnLi4vY29yZS9Vbmlmb3JtR3JvdXBOb2RlLmpzJztcclxuaW1wb3J0IHsgdW5pZm9ybSB9IGZyb20gJy4uL2NvcmUvVW5pZm9ybU5vZGUuanMnO1xyXG5cclxuLyoqIEBtb2R1bGUgVGltZXIgKiovXHJcblxyXG4vKipcclxuICogUmVwcmVzZW50cyB0aGUgZWxhcHNlZCB0aW1lIGluIHNlY29uZHMuXHJcbiAqXHJcbiAqIEB0eXBlIHtVbmlmb3JtTm9kZTxmbG9hdD59XHJcbiAqL1xyXG5leHBvcnQgY29uc3QgdGltZSA9IC8qQF9fUFVSRV9fKi8gdW5pZm9ybSggMCApLnNldEdyb3VwKCByZW5kZXJHcm91cCApLm9uUmVuZGVyVXBkYXRlKCAoIGZyYW1lICkgPT4gZnJhbWUudGltZSApO1xyXG5cclxuLyoqXHJcbiAqIFJlcHJlc2VudHMgdGhlIGRlbHRhIHRpbWUgaW4gc2Vjb25kcy5cclxuICpcclxuICogQHR5cGUge1VuaWZvcm1Ob2RlPGZsb2F0Pn1cclxuICovXHJcbmV4cG9ydCBjb25zdCBkZWx0YVRpbWUgPSAvKkBfX1BVUkVfXyovIHVuaWZvcm0oIDAgKS5zZXRHcm91cCggcmVuZGVyR3JvdXAgKS5vblJlbmRlclVwZGF0ZSggKCBmcmFtZSApID0+IGZyYW1lLmRlbHRhVGltZSApO1xyXG5cclxuLyoqXHJcbiAqIFJlcHJlc2VudHMgdGhlIGN1cnJlbnQgZnJhbWUgSUQuXHJcbiAqXHJcbiAqIEB0eXBlIHtVbmlmb3JtTm9kZTx1aW50Pn1cclxuICovXHJcbmV4cG9ydCBjb25zdCBmcmFtZUlkID0gLypAX19QVVJFX18qLyB1bmlmb3JtKCAwLCAndWludCcgKS5zZXRHcm91cCggcmVuZGVyR3JvdXAgKS5vblJlbmRlclVwZGF0ZSggKCBmcmFtZSApID0+IGZyYW1lLmZyYW1lSWQgKTtcclxuXHJcbi8vIERlcHJlY2F0ZWRcclxuXHJcbmV4cG9ydCBjb25zdCB0aW1lckxvY2FsID0gKCB0aW1lU2NhbGUgPSAxICkgPT4geyAvLyBAZGVwcmVjYXRlZCwgcjE3MFxyXG5cclxuXHRjb25zb2xlLndhcm4oICdUU0w6IHRpbWVyTG9jYWwoKSBpcyBkZXByZWNhdGVkLiBVc2UgXCJ0aW1lXCIgaW5zdGVhZC4nICk7XHJcblx0cmV0dXJuIHRpbWUubXVsKCB0aW1lU2NhbGUgKTtcclxuXHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgdGltZXJHbG9iYWwgPSAoIHRpbWVTY2FsZSA9IDEgKSA9PiB7IC8vIEBkZXByZWNhdGVkLCByMTcwXHJcblxyXG5cdGNvbnNvbGUud2FybiggJ1RTTDogdGltZXJHbG9iYWwoKSBpcyBkZXByZWNhdGVkLiBVc2UgXCJ0aW1lXCIgaW5zdGVhZC4nICk7XHJcblx0cmV0dXJuIHRpbWUubXVsKCB0aW1lU2NhbGUgKTtcclxuXHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgdGltZXJEZWx0YSA9ICggdGltZVNjYWxlID0gMSApID0+IHsgLy8gQGRlcHJlY2F0ZWQsIHIxNzBcclxuXHJcblx0Y29uc29sZS53YXJuKCAnVFNMOiB0aW1lckRlbHRhKCkgaXMgZGVwcmVjYXRlZC4gVXNlIFwiZGVsdGFUaW1lXCIgaW5zdGVhZC4nICk7XHJcblx0cmV0dXJuIGRlbHRhVGltZS5tdWwoIHRpbWVTY2FsZSApO1xyXG5cclxufTtcclxuIiwiaW1wb3J0IHsgdGltZSB9IGZyb20gJy4vVGltZXIuanMnO1xyXG5cclxuLyoqIEBtb2R1bGUgT3NjaWxsYXRvcnMgKiovXHJcblxyXG4vKipcclxuICogR2VuZXJhdGVzIGEgc2luZSB3YXZlIG9zY2lsbGF0aW9uIGJhc2VkIG9uIGEgdGltZXIuXHJcbiAqXHJcbiAqIEBtZXRob2RcclxuICogQHBhcmFtIHtOb2RlPGZsb2F0Pn0gdCAtIFRoZSB0aW1lciB0byBnZW5lcmF0ZSB0aGUgb3NjaWxsYXRpb24gd2l0aC5cclxuICogQHJldHVybiB7Tm9kZTxmbG9hdD59IFRoZSBvc2NpbGxhdGlvbiBub2RlLlxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IG9zY1NpbmUgPSAoIHQgPSB0aW1lICkgPT4gdC5hZGQoIDAuNzUgKS5tdWwoIE1hdGguUEkgKiAyICkuc2luKCkubXVsKCAwLjUgKS5hZGQoIDAuNSApO1xyXG5cclxuLyoqXHJcbiAqIEdlbmVyYXRlcyBhIHNxdWFyZSB3YXZlIG9zY2lsbGF0aW9uIGJhc2VkIG9uIGEgdGltZXIuXHJcbiAqXHJcbiAqIEBtZXRob2RcclxuICogQHBhcmFtIHtOb2RlPGZsb2F0Pn0gdCAtIFRoZSB0aW1lciB0byBnZW5lcmF0ZSB0aGUgb3NjaWxsYXRpb24gd2l0aC5cclxuICogQHJldHVybiB7Tm9kZTxmbG9hdD59IFRoZSBvc2NpbGxhdGlvbiBub2RlLlxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IG9zY1NxdWFyZSA9ICggdCA9IHRpbWUgKSA9PiB0LmZyYWN0KCkucm91bmQoKTtcclxuXHJcbi8qKlxyXG4gKiBHZW5lcmF0ZXMgYSB0cmlhbmdsZSB3YXZlIG9zY2lsbGF0aW9uIGJhc2VkIG9uIGEgdGltZXIuXHJcbiAqXHJcbiAqIEBtZXRob2RcclxuICogQHBhcmFtIHtOb2RlPGZsb2F0Pn0gdCAtIFRoZSB0aW1lciB0byBnZW5lcmF0ZSB0aGUgb3NjaWxsYXRpb24gd2l0aC5cclxuICogQHJldHVybiB7Tm9kZTxmbG9hdD59IFRoZSBvc2NpbGxhdGlvbiBub2RlLlxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IG9zY1RyaWFuZ2xlID0gKCB0ID0gdGltZSApID0+IHQuYWRkKCAwLjUgKS5mcmFjdCgpLm11bCggMiApLnN1YiggMSApLmFicygpO1xyXG5cclxuLyoqXHJcbiAqIEdlbmVyYXRlcyBhIHNhd3Rvb3RoIHdhdmUgb3NjaWxsYXRpb24gYmFzZWQgb24gYSB0aW1lci5cclxuICpcclxuICogQG1ldGhvZFxyXG4gKiBAcGFyYW0ge05vZGU8ZmxvYXQ+fSB0IC0gVGhlIHRpbWVyIHRvIGdlbmVyYXRlIHRoZSBvc2NpbGxhdGlvbiB3aXRoLlxyXG4gKiBAcmV0dXJuIHtOb2RlPGZsb2F0Pn0gVGhlIG9zY2lsbGF0aW9uIG5vZGUuXHJcbiAqL1xyXG5leHBvcnQgY29uc3Qgb3NjU2F3dG9vdGggPSAoIHQgPSB0aW1lICkgPT4gdC5mcmFjdCgpO1xyXG4iLCJpbXBvcnQgeyBGbiwgdmVjMiB9IGZyb20gJy4uL3RzbC9UU0xCYXNlLmpzJztcclxuaW1wb3J0IHsgcm90YXRlIH0gZnJvbSAnLi9Sb3RhdGVOb2RlLmpzJztcclxuXHJcbi8qKiBAbW9kdWxlIFVWVXRpbHMgKiovXHJcblxyXG4vKipcclxuICogUm90YXRlcyB0aGUgZ2l2ZW4gdXYgY29vcmRpbmF0ZXMgYXJvdW5kIGEgY2VudGVyIHBvaW50XHJcbiAqXHJcbiAqIEBtZXRob2RcclxuICogQHBhcmFtIHtOb2RlPHZlYzI+fSB1diAtIFRoZSB1diBjb29yZGluYXRlcy5cclxuICogQHBhcmFtIHtOb2RlPGZsb2F0Pn0gcm90YXRpb24gLSBUaGUgcm90YXRpb24gZGVmaW5lZCBpbiByYWRpYW5zLlxyXG4gKiBAcGFyYW0ge05vZGU8dmVjMj59IGNlbnRlciAtIFRoZSBjZW50ZXIgb2Ygcm90YXRpb25cclxuICogQHJldHVybiB7Tm9kZTx2ZWMyPn0gVGhlIHJvdGF0ZWQgdXYgY29vcmRpbmF0ZXMuXHJcbiAqL1xyXG5leHBvcnQgY29uc3Qgcm90YXRlVVYgPSAvKkBfX1BVUkVfXyovIEZuKCAoIFsgdXYsIHJvdGF0aW9uLCBjZW50ZXIgPSB2ZWMyKCAwLjUgKSBdICkgPT4ge1xyXG5cclxuXHRyZXR1cm4gcm90YXRlKCB1di5zdWIoIGNlbnRlciApLCByb3RhdGlvbiApLmFkZCggY2VudGVyICk7XHJcblxyXG59ICk7XHJcblxyXG4vKipcclxuICogQXBwbGllcyBhIHNwaGVyaWNhbCB3YXJwaW5nIGVmZmVjdCB0byB0aGUgZ2l2ZW4gdXYgY29vcmRpbmF0ZXMuXHJcbiAqXHJcbiAqIEBtZXRob2RcclxuICogQHBhcmFtIHtOb2RlPHZlYzI+fSB1diAtIFRoZSB1diBjb29yZGluYXRlcy5cclxuICogQHBhcmFtIHtOb2RlPGZsb2F0Pn0gc3RyZW5ndGggLSBUaGUgc3RyZW5ndGggb2YgdGhlIGVmZmVjdC5cclxuICogQHBhcmFtIHtOb2RlPHZlYzI+fSBjZW50ZXIgLSBUaGUgY2VudGVyIHBvaW50XHJcbiAqIEByZXR1cm4ge05vZGU8dmVjMj59IFRoZSB1cGRhdGVkIHV2IGNvb3JkaW5hdGVzLlxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IHNwaGVyaXplVVYgPSAvKkBfX1BVUkVfXyovIEZuKCAoIFsgdXYsIHN0cmVuZ3RoLCBjZW50ZXIgPSB2ZWMyKCAwLjUgKSBdICkgPT4ge1xyXG5cclxuXHRjb25zdCBkZWx0YSA9IHV2LnN1YiggY2VudGVyICk7XHJcblx0Y29uc3QgZGVsdGEyID0gZGVsdGEuZG90KCBkZWx0YSApO1xyXG5cdGNvbnN0IGRlbHRhNCA9IGRlbHRhMi5tdWwoIGRlbHRhMiApO1xyXG5cdGNvbnN0IGRlbHRhT2Zmc2V0ID0gZGVsdGE0Lm11bCggc3RyZW5ndGggKTtcclxuXHJcblx0cmV0dXJuIHV2LmFkZCggZGVsdGEubXVsKCBkZWx0YU9mZnNldCApICk7XHJcblxyXG59ICk7XHJcbiIsImltcG9ydCB7IG1vZGVsV29ybGRNYXRyaXggfSBmcm9tICcuLi9hY2Nlc3NvcnMvTW9kZWxOb2RlLmpzJztcclxuaW1wb3J0IHsgY2FtZXJhVmlld01hdHJpeCwgY2FtZXJhUHJvamVjdGlvbk1hdHJpeCB9IGZyb20gJy4uL2FjY2Vzc29ycy9DYW1lcmEuanMnO1xyXG5pbXBvcnQgeyBwb3NpdGlvbkxvY2FsIH0gZnJvbSAnLi4vYWNjZXNzb3JzL1Bvc2l0aW9uLmpzJztcclxuaW1wb3J0IHsgRm4sIGRlZmluZWQgfSBmcm9tICcuLi90c2wvVFNMQmFzZS5qcyc7XHJcblxyXG4vKiogQG1vZHVsZSBTcHJpdGVVdGlscyAqKi9cclxuXHJcbi8qKlxyXG4gKiBUaGlzIGNhbiBiZSB1c2VkIHRvIGFjaGlldmUgYSBiaWxsYm9hcmRpbmcgYmVoYXZpb3IgZm9yIGZsYXQgbWVzaGVzLiBUaGF0IG1lYW5zIHRoZXkgYXJlXHJcbiAqIG9yaWVudGVkIGFsd2F5cyB0b3dhcmRzIHRoZSBjYW1lcmEuXHJcbiAqXHJcbiAqIGBgYGpzXHJcbiAqIG1hdGVyaWFsLnZlcnRleE5vZGUgPSBiaWxsYm9hcmRpbmcoKTtcclxuICogYGBgXHJcbiAqXHJcbiAqIEBtZXRob2RcclxuICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyAtIFRoZSBjb25maWd1cmF0aW9uIG9iamVjdC5cclxuICogQHBhcmFtIHtOb2RlPHZlYzM+P30gW2NvbmZpZy5wb3NpdGlvbj1udWxsXSAtIENhbiBiZSB1c2VkIHRvIGRlZmluZSB0aGUgdmVydGV4IHBvc2l0aW9ucyBpbiB3b3JsZCBzcGFjZS5cclxuICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLmhvcml6b250YWw9dHJ1ZV0gLSBXaGV0aGVyIHRvIGZvbGxvdyB0aGUgY2FtZXJhIHJvdGF0aW9uIGhvcml6b250YWxseSBvciBub3QuXHJcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy52ZXJ0aWNhbD1mYWxzZV0gLSBXaGV0aGVyIHRvIGZvbGxvdyB0aGUgY2FtZXJhIHJvdGF0aW9uIHZlcnRpY2FsbHkgb3Igbm90LlxyXG4gKiBAcmV0dXJuIHtOb2RlPHZlYzM+fSBUaGUgdXBkYXRlZCB2ZXJ0ZXggcG9zaXRpb24gaW4gY2xpcCBzcGFjZS5cclxuICovXHJcbmV4cG9ydCBjb25zdCBiaWxsYm9hcmRpbmcgPSAvKkBfX1BVUkVfXyovIEZuKCAoIHsgcG9zaXRpb24gPSBudWxsLCBob3Jpem9udGFsID0gdHJ1ZSwgdmVydGljYWwgPSBmYWxzZSB9ICkgPT4ge1xyXG5cclxuXHRsZXQgd29ybGRNYXRyaXg7XHJcblxyXG5cdGlmICggcG9zaXRpb24gIT09IG51bGwgKSB7XHJcblxyXG5cdFx0d29ybGRNYXRyaXggPSBtb2RlbFdvcmxkTWF0cml4LnRvVmFyKCk7XHJcblx0XHR3b3JsZE1hdHJpeFsgMyBdWyAwIF0gPSBwb3NpdGlvbi54O1xyXG5cdFx0d29ybGRNYXRyaXhbIDMgXVsgMSBdID0gcG9zaXRpb24ueTtcclxuXHRcdHdvcmxkTWF0cml4WyAzIF1bIDIgXSA9IHBvc2l0aW9uLno7XHJcblxyXG5cdH0gZWxzZSB7XHJcblxyXG5cdFx0d29ybGRNYXRyaXggPSBtb2RlbFdvcmxkTWF0cml4O1xyXG5cclxuXHR9XHJcblxyXG5cdGNvbnN0IG1vZGVsVmlld01hdHJpeCA9IGNhbWVyYVZpZXdNYXRyaXgubXVsKCB3b3JsZE1hdHJpeCApO1xyXG5cclxuXHRpZiAoIGRlZmluZWQoIGhvcml6b250YWwgKSApIHtcclxuXHJcblx0XHRtb2RlbFZpZXdNYXRyaXhbIDAgXVsgMCBdID0gbW9kZWxXb3JsZE1hdHJpeFsgMCBdLmxlbmd0aCgpO1xyXG5cdFx0bW9kZWxWaWV3TWF0cml4WyAwIF1bIDEgXSA9IDA7XHJcblx0XHRtb2RlbFZpZXdNYXRyaXhbIDAgXVsgMiBdID0gMDtcclxuXHJcblx0fVxyXG5cclxuXHRpZiAoIGRlZmluZWQoIHZlcnRpY2FsICkgKSB7XHJcblxyXG5cdFx0bW9kZWxWaWV3TWF0cml4WyAxIF1bIDAgXSA9IDA7XHJcblx0XHRtb2RlbFZpZXdNYXRyaXhbIDEgXVsgMSBdID0gbW9kZWxXb3JsZE1hdHJpeFsgMSBdLmxlbmd0aCgpO1xyXG5cdFx0bW9kZWxWaWV3TWF0cml4WyAxIF1bIDIgXSA9IDA7XHJcblxyXG5cdH1cclxuXHJcblx0bW9kZWxWaWV3TWF0cml4WyAyIF1bIDAgXSA9IDA7XHJcblx0bW9kZWxWaWV3TWF0cml4WyAyIF1bIDEgXSA9IDA7XHJcblx0bW9kZWxWaWV3TWF0cml4WyAyIF1bIDIgXSA9IDE7XHJcblxyXG5cdHJldHVybiBjYW1lcmFQcm9qZWN0aW9uTWF0cml4Lm11bCggbW9kZWxWaWV3TWF0cml4ICkubXVsKCBwb3NpdGlvbkxvY2FsICk7XHJcblxyXG59ICk7XHJcbiIsImltcG9ydCB7IEZuIH0gZnJvbSAnLi4vdHNsL1RTTEJhc2UuanMnO1xyXG5pbXBvcnQgeyBzY3JlZW5VViB9IGZyb20gJy4uL2Rpc3BsYXkvU2NyZWVuTm9kZS5qcyc7XHJcbmltcG9ydCB7IHZpZXdwb3J0RGVwdGhUZXh0dXJlIH0gZnJvbSAnLi4vZGlzcGxheS9WaWV3cG9ydERlcHRoVGV4dHVyZU5vZGUuanMnO1xyXG5pbXBvcnQgeyBsaW5lYXJEZXB0aCB9IGZyb20gJy4uL2Rpc3BsYXkvVmlld3BvcnREZXB0aE5vZGUuanMnO1xyXG5cclxuLyoqIEBtb2R1bGUgVmlld3BvcnRVdGlscyAqKi9cclxuXHJcbi8qKlxyXG4gKiBBIHNwZWNpYWwgdmVyc2lvbiBvZiBhIHNjcmVlbiB1diBmdW5jdGlvbiB0aGF0IGludm9sdmVzIGEgZGVwdGggY29tcGFyaXNvblxyXG4gKiB3aGVuIGNvbXB1dGluZyB0aGUgZmluYWwgdXZzLiBUaGUgZnVuY3Rpb24gbWl0aWdhdGVzIHZpc3VhbCBlcnJvcnMgd2hlblxyXG4gKiB1c2luZyB2aWV3cG9ydCB0ZXh0dXJlIG5vZGVzIGZvciByZWZyYWN0aW9uIHB1cnBvc2VzLiBXaXRob3V0IHRoaXMgZnVuY3Rpb25cclxuICogb2JqZWN0cyBpbiBmcm9udCBvZiBhIHJlZnJhY3RpdmUgc3VyZmFjZSBtaWdodCBhcHBlYXIgb24gdGhlIHJlZnJhY3RpdmUgc3VyZmFjZVxyXG4gKiB3aGljaCBpcyBpbmNvcnJlY3QuXHJcbiAqXHJcbiAqIEBtZXRob2RcclxuICogQHBhcmFtIHtOb2RlPHZlYzI+P30gdXYgLSBPcHRpb25hbCB1diBjb29yZGluYXRlcy4gQnkgZGVmYXVsdCBgc2NyZWVuVVZgIGlzIHVzZWQuXHJcbiAqIEByZXR1cm4ge05vZGU8dmVjMj59IFRoZSB1cGRhdGUgdXYgY29vcmRpbmF0ZXMuXHJcbiAqL1xyXG5leHBvcnQgY29uc3Qgdmlld3BvcnRTYWZlVVYgPSAvKkBfX1BVUkVfXyovIEZuKCAoIFsgdXYgPSBudWxsIF0gKSA9PiB7XHJcblxyXG5cdGNvbnN0IGRlcHRoID0gbGluZWFyRGVwdGgoKTtcclxuXHRjb25zdCBkZXB0aERpZmYgPSBsaW5lYXJEZXB0aCggdmlld3BvcnREZXB0aFRleHR1cmUoIHV2ICkgKS5zdWIoIGRlcHRoICk7XHJcblx0Y29uc3QgZmluYWxVViA9IGRlcHRoRGlmZi5sZXNzVGhhbiggMCApLnNlbGVjdCggc2NyZWVuVVYsIHV2ICk7XHJcblxyXG5cdHJldHVybiBmaW5hbFVWO1xyXG5cclxufSApO1xyXG4iLCJpbXBvcnQgTm9kZSBmcm9tICcuLi9jb3JlL05vZGUuanMnO1xyXG5pbXBvcnQgeyB1diB9IGZyb20gJy4uL2FjY2Vzc29ycy9VVi5qcyc7XHJcbmltcG9ydCB7IG5vZGVQcm94eSwgZmxvYXQsIHZlYzIgfSBmcm9tICcuLi90c2wvVFNMQmFzZS5qcyc7XHJcblxyXG4vKiogQG1vZHVsZSBTcHJpdGVTaGVldFVWTm9kZSAqKi9cclxuXHJcbi8qKlxyXG4gKiBDYW4gYmUgdXNlZCB0byBjb21wdXRlIHRleHR1cmUgY29vcmRpbmF0ZXMgZm9yIGFuaW1hdGVkIHNwcml0ZSBzaGVldHMuXHJcbiAqXHJcbiAqIGBgYGpzXHJcbiAqIGNvbnN0IHV2Tm9kZSA9IHNwcml0ZXNoZWV0VVYoIHZlYzIoIDYsIDYgKSwgdXYoKSwgdGltZS5tdWwoIGFuaW1hdGlvblNwZWVkICkgKTtcclxuICpcclxuICogbWF0ZXJpYWwuY29sb3JOb2RlID0gdGV4dHVyZSggc3ByaXRlU2hlZXQsIHV2Tm9kZSApO1xyXG4gKiBgYGBcclxuICpcclxuICogQGF1Z21lbnRzIE5vZGVcclxuICovXHJcbmNsYXNzIFNwcml0ZVNoZWV0VVZOb2RlIGV4dGVuZHMgTm9kZSB7XHJcblxyXG5cdHN0YXRpYyBnZXQgdHlwZSgpIHtcclxuXHJcblx0XHRyZXR1cm4gJ1Nwcml0ZVNoZWV0VVZOb2RlJztcclxuXHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBDb25zdHJ1Y3RzIGEgbmV3IHNwcml0ZSBzaGVldCB1diBub2RlLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtOb2RlPHZlYzI+fSBjb3VudE5vZGUgLSBUaGUgbm9kZSB0aGF0IGRlZmluZXMgdGhlIG51bWJlciBvZiBzcHJpdGVzIGluIHRoZSB4IGFuZCB5IGRpcmVjdGlvbiAoZS5nIDZ4NikuXHJcblx0ICogQHBhcmFtIHtOb2RlPHZlYzI+fSBbdXZOb2RlPXV2KCldIC0gVGhlIHV2IG5vZGUuXHJcblx0ICogQHBhcmFtIHtOb2RlPGZsb2F0Pn0gW2ZyYW1lTm9kZT1mbG9hdCgpXSAtIFRoZSBub2RlIHRoYXQgZGVmaW5lcyB0aGUgY3VycmVudCBmcmFtZS9zcHJpdGUuXHJcblx0ICovXHJcblx0Y29uc3RydWN0b3IoIGNvdW50Tm9kZSwgdXZOb2RlID0gdXYoKSwgZnJhbWVOb2RlID0gZmxvYXQoIDAgKSApIHtcclxuXHJcblx0XHRzdXBlciggJ3ZlYzInICk7XHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBUaGUgbm9kZSB0aGF0IGRlZmluZXMgdGhlIG51bWJlciBvZiBzcHJpdGVzIGluIHRoZSB4IGFuZCB5IGRpcmVjdGlvbiAoZS5nIDZ4NikuXHJcblx0XHQgKlxyXG5cdFx0ICogQHR5cGUge05vZGU8dmVjMj59XHJcblx0XHQgKi9cclxuXHRcdHRoaXMuY291bnROb2RlID0gY291bnROb2RlO1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogVGhlIHV2IG5vZGUuXHJcblx0XHQgKlxyXG5cdFx0ICogQHR5cGUge05vZGU8dmVjMj59XHJcblx0XHQgKi9cclxuXHRcdHRoaXMudXZOb2RlID0gdXZOb2RlO1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogVGhlIG5vZGUgdGhhdCBkZWZpbmVzIHRoZSBjdXJyZW50IGZyYW1lL3Nwcml0ZS5cclxuXHRcdCAqXHJcblx0XHQgKiBAdHlwZSB7Tm9kZTxmbG9hdD59XHJcblx0XHQgKi9cclxuXHRcdHRoaXMuZnJhbWVOb2RlID0gZnJhbWVOb2RlO1xyXG5cclxuXHR9XHJcblxyXG5cdHNldHVwKCkge1xyXG5cclxuXHRcdGNvbnN0IHsgZnJhbWVOb2RlLCB1dk5vZGUsIGNvdW50Tm9kZSB9ID0gdGhpcztcclxuXHJcblx0XHRjb25zdCB7IHdpZHRoLCBoZWlnaHQgfSA9IGNvdW50Tm9kZTtcclxuXHJcblx0XHRjb25zdCBmcmFtZU51bSA9IGZyYW1lTm9kZS5tb2QoIHdpZHRoLm11bCggaGVpZ2h0ICkgKS5mbG9vcigpO1xyXG5cclxuXHRcdGNvbnN0IGNvbHVtbiA9IGZyYW1lTnVtLm1vZCggd2lkdGggKTtcclxuXHRcdGNvbnN0IHJvdyA9IGhlaWdodC5zdWIoIGZyYW1lTnVtLmFkZCggMSApLmRpdiggd2lkdGggKS5jZWlsKCkgKTtcclxuXHJcblx0XHRjb25zdCBzY2FsZSA9IGNvdW50Tm9kZS5yZWNpcHJvY2FsKCk7XHJcblx0XHRjb25zdCB1dkZyYW1lT2Zmc2V0ID0gdmVjMiggY29sdW1uLCByb3cgKTtcclxuXHJcblx0XHRyZXR1cm4gdXZOb2RlLmFkZCggdXZGcmFtZU9mZnNldCApLm11bCggc2NhbGUgKTtcclxuXHJcblx0fVxyXG5cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgU3ByaXRlU2hlZXRVVk5vZGU7XHJcblxyXG4vKipcclxuICogVFNMIGZ1bmN0aW9uIGZvciBjcmVhdGluZyBhIHNwcml0ZSBzaGVldCB1diBub2RlLlxyXG4gKlxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHtOb2RlPHZlYzI+fSBjb3VudE5vZGUgLSBUaGUgbm9kZSB0aGF0IGRlZmluZXMgdGhlIG51bWJlciBvZiBzcHJpdGVzIGluIHRoZSB4IGFuZCB5IGRpcmVjdGlvbiAoZS5nIDZ4NikuXHJcbiAqIEBwYXJhbSB7Tm9kZTx2ZWMyPn0gW3V2Tm9kZT11digpXSAtIFRoZSB1diBub2RlLlxyXG4gKiBAcGFyYW0ge05vZGU8ZmxvYXQ+fSBbZnJhbWVOb2RlPWZsb2F0KCldIC0gVGhlIG5vZGUgdGhhdCBkZWZpbmVzIHRoZSBjdXJyZW50IGZyYW1lL3Nwcml0ZS5cclxuICogQHJldHVybnMge1Nwcml0ZVNoZWV0VVZOb2RlfVxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IHNwcml0ZXNoZWV0VVYgPSAvKkBfX1BVUkVfXyovIG5vZGVQcm94eSggU3ByaXRlU2hlZXRVVk5vZGUgKTtcclxuIiwiaW1wb3J0IE5vZGUgZnJvbSAnLi4vY29yZS9Ob2RlLmpzJztcclxuaW1wb3J0IHsgYWRkIH0gZnJvbSAnLi4vbWF0aC9PcGVyYXRvck5vZGUuanMnO1xyXG5pbXBvcnQgeyBub3JtYWxMb2NhbCB9IGZyb20gJy4uL2FjY2Vzc29ycy9Ob3JtYWwuanMnO1xyXG5pbXBvcnQgeyBwb3NpdGlvbkxvY2FsIH0gZnJvbSAnLi4vYWNjZXNzb3JzL1Bvc2l0aW9uLmpzJztcclxuaW1wb3J0IHsgdGV4dHVyZSB9IGZyb20gJy4uL2FjY2Vzc29ycy9UZXh0dXJlTm9kZS5qcyc7XHJcbmltcG9ydCB7IG5vZGVQcm94eSwgZmxvYXQsIHZlYzMgfSBmcm9tICcuLi90c2wvVFNMQmFzZS5qcyc7XHJcblxyXG4vKiogQG1vZHVsZSBUcmlwbGFuYXJUZXh0dXJlc05vZGUgKiovXHJcblxyXG4vKipcclxuICogQ2FuIGJlIHVzZWQgZm9yIHRyaXBsYW5hciB0ZXh0dXJlIG1hcHBpbmcuXHJcbiAqXHJcbiAqIGBgYGpzXHJcbiAqIG1hdGVyaWFsLmNvbG9yTm9kZSA9IHRyaXBsYW5hclRleHR1cmUoIHRleHR1cmUoIGRpZmZ1c2VNYXAgKSApO1xyXG4gKiBgYGBcclxuICpcclxuICogQGF1Z21lbnRzIE5vZGVcclxuICovXHJcbmNsYXNzIFRyaXBsYW5hclRleHR1cmVzTm9kZSBleHRlbmRzIE5vZGUge1xyXG5cclxuXHRzdGF0aWMgZ2V0IHR5cGUoKSB7XHJcblxyXG5cdFx0cmV0dXJuICdUcmlwbGFuYXJUZXh0dXJlc05vZGUnO1xyXG5cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIENvbnN0cnVjdHMgYSBuZXcgdHJpcGxhbmFyIHRleHR1cmVzIG5vZGUuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge05vZGV9IHRleHR1cmVYTm9kZSAtIEZpcnN0IHRleHR1cmUgbm9kZS5cclxuXHQgKiBAcGFyYW0ge05vZGU/fSBbdGV4dHVyZVlOb2RlPW51bGxdIC0gU2Vjb25kIHRleHR1cmUgbm9kZS4gV2hlbiBub3Qgc2V0LCB0aGUgc2hhZGVyIHdpbGwgc2FtcGxlIGZyb20gYHRleHR1cmVYTm9kZWAgaW5zdGVhZC5cclxuXHQgKiBAcGFyYW0ge05vZGU/fSBbdGV4dHVyZVpOb2RlPW51bGxdIC0gVGhpcmQgdGV4dHVyZSBub2RlLiBXaGVuIG5vdCBzZXQsIHRoZSBzaGFkZXIgd2lsbCBzYW1wbGUgZnJvbSBgdGV4dHVyZVhOb2RlYCBpbnN0ZWFkLlxyXG5cdCAqIEBwYXJhbSB7Tm9kZTxmbG9hdD4/fSBbc2NhbGVOb2RlPWZsb2F0KDEpXSAtIFRoZSBzY2FsZSBub2RlLlxyXG5cdCAqIEBwYXJhbSB7Tm9kZTx2ZWMzPj99IFtwb3NpdGlvbk5vZGU9cG9zaXRpb25Mb2NhbF0gLSBWZXJ0ZXggcG9zaXRpb25zIGluIGxvY2FsIHNwYWNlLlxyXG5cdCAqIEBwYXJhbSB7Tm9kZTx2ZWMzPj99IFtub3JtYWxOb2RlPW5vcm1hbExvY2FsXSAtIE5vcm1hbHMgaW4gbG9jYWwgc3BhY2UuXHJcblx0ICovXHJcblx0Y29uc3RydWN0b3IoIHRleHR1cmVYTm9kZSwgdGV4dHVyZVlOb2RlID0gbnVsbCwgdGV4dHVyZVpOb2RlID0gbnVsbCwgc2NhbGVOb2RlID0gZmxvYXQoIDEgKSwgcG9zaXRpb25Ob2RlID0gcG9zaXRpb25Mb2NhbCwgbm9ybWFsTm9kZSA9IG5vcm1hbExvY2FsICkge1xyXG5cclxuXHRcdHN1cGVyKCAndmVjNCcgKTtcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIEZpcnN0IHRleHR1cmUgbm9kZS5cclxuXHRcdCAqXHJcblx0XHQgKiBAdHlwZSB7Tm9kZX1cclxuXHRcdCAqL1xyXG5cdFx0dGhpcy50ZXh0dXJlWE5vZGUgPSB0ZXh0dXJlWE5vZGU7XHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBTZWNvbmQgdGV4dHVyZSBub2RlLiBXaGVuIG5vdCBzZXQsIHRoZSBzaGFkZXIgd2lsbCBzYW1wbGUgZnJvbSBgdGV4dHVyZVhOb2RlYCBpbnN0ZWFkLlxyXG5cdFx0ICpcclxuXHRcdCAqIEB0eXBlIHtOb2RlfVxyXG5cdFx0ICogQGRlZmF1bHQgbnVsbFxyXG5cdFx0ICovXHJcblx0XHR0aGlzLnRleHR1cmVZTm9kZSA9IHRleHR1cmVZTm9kZTtcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIFRoaXJkIHRleHR1cmUgbm9kZS4gV2hlbiBub3Qgc2V0LCB0aGUgc2hhZGVyIHdpbGwgc2FtcGxlIGZyb20gYHRleHR1cmVYTm9kZWAgaW5zdGVhZC5cclxuXHRcdCAqXHJcblx0XHQgKiBAdHlwZSB7Tm9kZX1cclxuXHRcdCAqIEBkZWZhdWx0IG51bGxcclxuXHRcdCAqL1xyXG5cdFx0dGhpcy50ZXh0dXJlWk5vZGUgPSB0ZXh0dXJlWk5vZGU7XHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBUaGUgc2NhbGUgbm9kZS5cclxuXHRcdCAqXHJcblx0XHQgKiBAdHlwZSB7Tm9kZTxmbG9hdD59XHJcblx0XHQgKiBAZGVmYXVsdCBmbG9hdCgxKVxyXG5cdFx0ICovXHJcblx0XHR0aGlzLnNjYWxlTm9kZSA9IHNjYWxlTm9kZTtcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIFZlcnRleCBwb3NpdGlvbnMgaW4gbG9jYWwgc3BhY2UuXHJcblx0XHQgKlxyXG5cdFx0ICogQHR5cGUge05vZGU8dmVjMz59XHJcblx0XHQgKiBAZGVmYXVsdCBwb3NpdGlvbkxvY2FsXHJcblx0XHQgKi9cclxuXHRcdHRoaXMucG9zaXRpb25Ob2RlID0gcG9zaXRpb25Ob2RlO1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogTm9ybWFscyBpbiBsb2NhbCBzcGFjZS5cclxuXHRcdCAqXHJcblx0XHQgKiBAdHlwZSB7Tm9kZTx2ZWMzPn1cclxuXHRcdCAqIEBkZWZhdWx0IG5vcm1hbExvY2FsXHJcblx0XHQgKi9cclxuXHRcdHRoaXMubm9ybWFsTm9kZSA9IG5vcm1hbE5vZGU7XHJcblxyXG5cdH1cclxuXHJcblx0c2V0dXAoKSB7XHJcblxyXG5cdFx0Y29uc3QgeyB0ZXh0dXJlWE5vZGUsIHRleHR1cmVZTm9kZSwgdGV4dHVyZVpOb2RlLCBzY2FsZU5vZGUsIHBvc2l0aW9uTm9kZSwgbm9ybWFsTm9kZSB9ID0gdGhpcztcclxuXHJcblx0XHQvLyBSZWY6IGh0dHBzOi8vZ2l0aHViLmNvbS9rZWlqaXJvL1N0YW5kYXJkVHJpcGxhbmFyXHJcblxyXG5cdFx0Ly8gQmxlbmRpbmcgZmFjdG9yIG9mIHRyaXBsYW5hciBtYXBwaW5nXHJcblx0XHRsZXQgYmYgPSBub3JtYWxOb2RlLmFicygpLm5vcm1hbGl6ZSgpO1xyXG5cdFx0YmYgPSBiZi5kaXYoIGJmLmRvdCggdmVjMyggMS4wICkgKSApO1xyXG5cclxuXHRcdC8vIFRyaXBsYW5hciBtYXBwaW5nXHJcblx0XHRjb25zdCB0eCA9IHBvc2l0aW9uTm9kZS55ei5tdWwoIHNjYWxlTm9kZSApO1xyXG5cdFx0Y29uc3QgdHkgPSBwb3NpdGlvbk5vZGUuengubXVsKCBzY2FsZU5vZGUgKTtcclxuXHRcdGNvbnN0IHR6ID0gcG9zaXRpb25Ob2RlLnh5Lm11bCggc2NhbGVOb2RlICk7XHJcblxyXG5cdFx0Ly8gQmFzZSBjb2xvclxyXG5cdFx0Y29uc3QgdGV4dHVyZVggPSB0ZXh0dXJlWE5vZGUudmFsdWU7XHJcblx0XHRjb25zdCB0ZXh0dXJlWSA9IHRleHR1cmVZTm9kZSAhPT0gbnVsbCA/IHRleHR1cmVZTm9kZS52YWx1ZSA6IHRleHR1cmVYO1xyXG5cdFx0Y29uc3QgdGV4dHVyZVogPSB0ZXh0dXJlWk5vZGUgIT09IG51bGwgPyB0ZXh0dXJlWk5vZGUudmFsdWUgOiB0ZXh0dXJlWDtcclxuXHJcblx0XHRjb25zdCBjeCA9IHRleHR1cmUoIHRleHR1cmVYLCB0eCApLm11bCggYmYueCApO1xyXG5cdFx0Y29uc3QgY3kgPSB0ZXh0dXJlKCB0ZXh0dXJlWSwgdHkgKS5tdWwoIGJmLnkgKTtcclxuXHRcdGNvbnN0IGN6ID0gdGV4dHVyZSggdGV4dHVyZVosIHR6ICkubXVsKCBiZi56ICk7XHJcblxyXG5cdFx0cmV0dXJuIGFkZCggY3gsIGN5LCBjeiApO1xyXG5cclxuXHR9XHJcblxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBUcmlwbGFuYXJUZXh0dXJlc05vZGU7XHJcblxyXG4vKipcclxuICogVFNMIGZ1bmN0aW9uIGZvciBjcmVhdGluZyBhIHRyaXBsYW5hciB0ZXh0dXJlcyBub2RlLlxyXG4gKlxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHtOb2RlfSB0ZXh0dXJlWE5vZGUgLSBGaXJzdCB0ZXh0dXJlIG5vZGUuXHJcbiAqIEBwYXJhbSB7Tm9kZT99IFt0ZXh0dXJlWU5vZGU9bnVsbF0gLSBTZWNvbmQgdGV4dHVyZSBub2RlLiBXaGVuIG5vdCBzZXQsIHRoZSBzaGFkZXIgd2lsbCBzYW1wbGUgZnJvbSBgdGV4dHVyZVhOb2RlYCBpbnN0ZWFkLlxyXG4gKiBAcGFyYW0ge05vZGU/fSBbdGV4dHVyZVpOb2RlPW51bGxdIC0gVGhpcmQgdGV4dHVyZSBub2RlLiBXaGVuIG5vdCBzZXQsIHRoZSBzaGFkZXIgd2lsbCBzYW1wbGUgZnJvbSBgdGV4dHVyZVhOb2RlYCBpbnN0ZWFkLlxyXG4gKiBAcGFyYW0ge05vZGU8ZmxvYXQ+P30gW3NjYWxlTm9kZT1mbG9hdCgxKV0gLSBUaGUgc2NhbGUgbm9kZS5cclxuICogQHBhcmFtIHtOb2RlPHZlYzM+P30gW3Bvc2l0aW9uTm9kZT1wb3NpdGlvbkxvY2FsXSAtIFZlcnRleCBwb3NpdGlvbnMgaW4gbG9jYWwgc3BhY2UuXHJcbiAqIEBwYXJhbSB7Tm9kZTx2ZWMzPj99IFtub3JtYWxOb2RlPW5vcm1hbExvY2FsXSAtIE5vcm1hbHMgaW4gbG9jYWwgc3BhY2UuXHJcbiAqIEByZXR1cm5zIHtUcmlwbGFuYXJUZXh0dXJlc05vZGV9XHJcbiAqL1xyXG5leHBvcnQgY29uc3QgdHJpcGxhbmFyVGV4dHVyZXMgPSAvKkBfX1BVUkVfXyovIG5vZGVQcm94eSggVHJpcGxhbmFyVGV4dHVyZXNOb2RlICk7XHJcblxyXG4vKipcclxuICogVFNMIGZ1bmN0aW9uIGZvciBjcmVhdGluZyBhIHRyaXBsYW5hciB0ZXh0dXJlcyBub2RlLlxyXG4gKlxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHtOb2RlfSB0ZXh0dXJlWE5vZGUgLSBGaXJzdCB0ZXh0dXJlIG5vZGUuXHJcbiAqIEBwYXJhbSB7Tm9kZT99IFt0ZXh0dXJlWU5vZGU9bnVsbF0gLSBTZWNvbmQgdGV4dHVyZSBub2RlLiBXaGVuIG5vdCBzZXQsIHRoZSBzaGFkZXIgd2lsbCBzYW1wbGUgZnJvbSBgdGV4dHVyZVhOb2RlYCBpbnN0ZWFkLlxyXG4gKiBAcGFyYW0ge05vZGU/fSBbdGV4dHVyZVpOb2RlPW51bGxdIC0gVGhpcmQgdGV4dHVyZSBub2RlLiBXaGVuIG5vdCBzZXQsIHRoZSBzaGFkZXIgd2lsbCBzYW1wbGUgZnJvbSBgdGV4dHVyZVhOb2RlYCBpbnN0ZWFkLlxyXG4gKiBAcGFyYW0ge05vZGU8ZmxvYXQ+P30gW3NjYWxlTm9kZT1mbG9hdCgxKV0gLSBUaGUgc2NhbGUgbm9kZS5cclxuICogQHBhcmFtIHtOb2RlPHZlYzM+P30gW3Bvc2l0aW9uTm9kZT1wb3NpdGlvbkxvY2FsXSAtIFZlcnRleCBwb3NpdGlvbnMgaW4gbG9jYWwgc3BhY2UuXHJcbiAqIEBwYXJhbSB7Tm9kZTx2ZWMzPj99IFtub3JtYWxOb2RlPW5vcm1hbExvY2FsXSAtIE5vcm1hbHMgaW4gbG9jYWwgc3BhY2UuXHJcbiAqIEByZXR1cm5zIHtUcmlwbGFuYXJUZXh0dXJlc05vZGV9XHJcbiAqL1xyXG5leHBvcnQgY29uc3QgdHJpcGxhbmFyVGV4dHVyZSA9ICggLi4ucGFyYW1zICkgPT4gdHJpcGxhbmFyVGV4dHVyZXMoIC4uLnBhcmFtcyApO1xyXG4iLCJpbXBvcnQgTm9kZSBmcm9tICcuLi9jb3JlL05vZGUuanMnO1xyXG5pbXBvcnQgVGV4dHVyZU5vZGUgZnJvbSAnLi4vYWNjZXNzb3JzL1RleHR1cmVOb2RlLmpzJztcclxuaW1wb3J0IHsgbm9kZU9iamVjdCB9IGZyb20gJy4uL3RzbC9UU0xCYXNlLmpzJztcclxuaW1wb3J0IHsgTm9kZVVwZGF0ZVR5cGUgfSBmcm9tICcuLi9jb3JlL2NvbnN0YW50cy5qcyc7XHJcbmltcG9ydCB7IHNjcmVlblVWIH0gZnJvbSAnLi4vZGlzcGxheS9TY3JlZW5Ob2RlLmpzJztcclxuXHJcbmltcG9ydCB7IEhhbGZGbG9hdFR5cGUsIExpbmVhck1pcE1hcExpbmVhckZpbHRlciwgV2ViR1BVQ29vcmRpbmF0ZVN5c3RlbSB9IGZyb20gJy4uLy4uL2NvbnN0YW50cy5qcyc7XHJcbmltcG9ydCB7IFBsYW5lIH0gZnJvbSAnLi4vLi4vbWF0aC9QbGFuZS5qcyc7XHJcbmltcG9ydCB7IE9iamVjdDNEIH0gZnJvbSAnLi4vLi4vY29yZS9PYmplY3QzRC5qcyc7XHJcbmltcG9ydCB7IFZlY3RvcjIgfSBmcm9tICcuLi8uLi9tYXRoL1ZlY3RvcjIuanMnO1xyXG5pbXBvcnQgeyBWZWN0b3IzIH0gZnJvbSAnLi4vLi4vbWF0aC9WZWN0b3IzLmpzJztcclxuaW1wb3J0IHsgVmVjdG9yNCB9IGZyb20gJy4uLy4uL21hdGgvVmVjdG9yNC5qcyc7XHJcbmltcG9ydCB7IE1hdHJpeDQgfSBmcm9tICcuLi8uLi9tYXRoL01hdHJpeDQuanMnO1xyXG5pbXBvcnQgeyBSZW5kZXJUYXJnZXQgfSBmcm9tICcuLi8uLi9jb3JlL1JlbmRlclRhcmdldC5qcyc7XHJcbmltcG9ydCB7IERlcHRoVGV4dHVyZSB9IGZyb20gJy4uLy4uL3RleHR1cmVzL0RlcHRoVGV4dHVyZS5qcyc7XHJcblxyXG4vKiogQG1vZHVsZSBSZWZsZWN0b3JOb2RlICoqL1xyXG5cclxuY29uc3QgX3JlZmxlY3RvclBsYW5lID0gbmV3IFBsYW5lKCk7XHJcbmNvbnN0IF9ub3JtYWwgPSBuZXcgVmVjdG9yMygpO1xyXG5jb25zdCBfcmVmbGVjdG9yV29ybGRQb3NpdGlvbiA9IG5ldyBWZWN0b3IzKCk7XHJcbmNvbnN0IF9jYW1lcmFXb3JsZFBvc2l0aW9uID0gbmV3IFZlY3RvcjMoKTtcclxuY29uc3QgX3JvdGF0aW9uTWF0cml4ID0gbmV3IE1hdHJpeDQoKTtcclxuY29uc3QgX2xvb2tBdFBvc2l0aW9uID0gbmV3IFZlY3RvcjMoIDAsIDAsIC0gMSApO1xyXG5jb25zdCBjbGlwUGxhbmUgPSBuZXcgVmVjdG9yNCgpO1xyXG5cclxuY29uc3QgX3ZpZXcgPSBuZXcgVmVjdG9yMygpO1xyXG5jb25zdCBfdGFyZ2V0ID0gbmV3IFZlY3RvcjMoKTtcclxuY29uc3QgX3EgPSBuZXcgVmVjdG9yNCgpO1xyXG5cclxuY29uc3QgX3NpemUgPSBuZXcgVmVjdG9yMigpO1xyXG5cclxuY29uc3QgX2RlZmF1bHRSVCA9IG5ldyBSZW5kZXJUYXJnZXQoKTtcclxuY29uc3QgX2RlZmF1bHRVViA9IHNjcmVlblVWLmZsaXBYKCk7XHJcblxyXG5fZGVmYXVsdFJULmRlcHRoVGV4dHVyZSA9IG5ldyBEZXB0aFRleHR1cmUoIDEsIDEgKTtcclxuXHJcbmxldCBfaW5SZWZsZWN0b3IgPSBmYWxzZTtcclxuXHJcbi8qKlxyXG4gKiBUaGlzIG5vZGUgY2FuIGJlIHVzZWQgdG8gaW1wbGVtZW50IG1pcnJvci1saWtlIGZsYXQgcmVmbGVjdGl2ZSBzdXJmYWNlcy5cclxuICpcclxuICogYGBganNcclxuICogY29uc3QgZ3JvdW5kUmVmbGVjdG9yID0gcmVmbGVjdG9yKCk7XHJcbiAqIG1hdGVyaWFsLmNvbG9yTm9kZSA9IGdyb3VuZFJlZmxlY3RvcjtcclxuICpcclxuICogY29uc3QgcGxhbmUgPSBuZXcgTWVzaCggZ2VvbWV0cnksIG1hdGVyaWFsICk7XHJcbiAqIHBsYW5lLmFkZCggZ3JvdW5kUmVmbGVjdG9yLnRhcmdldCApO1xyXG4gKiBgYGBcclxuICpcclxuICogQGF1Z21lbnRzIG1vZHVsZTpUZXh0dXJlTm9kZX5UZXh0dXJlTm9kZVxyXG4gKi9cclxuY2xhc3MgUmVmbGVjdG9yTm9kZSBleHRlbmRzIFRleHR1cmVOb2RlIHtcclxuXHJcblx0c3RhdGljIGdldCB0eXBlKCkge1xyXG5cclxuXHRcdHJldHVybiAnUmVmbGVjdG9yTm9kZSc7XHJcblxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogQ29uc3RydWN0cyBhIG5ldyByZWZsZWN0b3Igbm9kZS5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBbcGFyYW1ldGVycz17fV0gLSBBbiBvYmplY3QgaG9sZGluZyBjb25maWd1cmF0aW9uIHBhcmFtZXRlcnMuXHJcblx0ICogQHBhcmFtIHtPYmplY3QzRH0gW3BhcmFtZXRlcnMudGFyZ2V0PW5ldyBPYmplY3QzRCgpXSAtIFRoZSAzRCBvYmplY3QgdGhlIHJlZmxlY3RvciBpcyBsaW5rZWQgdG8uXHJcblx0ICogQHBhcmFtIHtOdW1iZXJ9IFtwYXJhbWV0ZXJzLnJlc29sdXRpb249MV0gLSBUaGUgcmVzb2x1dGlvbiBzY2FsZS5cclxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IFtwYXJhbWV0ZXJzLmdlbmVyYXRlTWlwbWFwcz1mYWxzZV0gLSBXaGV0aGVyIG1pcG1hcHMgc2hvdWxkIGJlIGdlbmVyYXRlZCBvciBub3QuXHJcblx0ICogQHBhcmFtIHtCb29sZWFufSBbcGFyYW1ldGVycy5ib3VuY2VzPXRydWVdIC0gV2hldGhlciByZWZsZWN0b3JzIGNhbiByZW5kZXIgb3RoZXIgcmVmbGVjdG9yIG5vZGVzIG9yIG5vdC5cclxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IFtwYXJhbWV0ZXJzLmRlcHRoPWZhbHNlXSAtIFdoZXRoZXIgZGVwdGggZGF0YSBzaG91bGQgYmUgZ2VuZXJhdGVkIG9yIG5vdC5cclxuXHQgKiBAcGFyYW0ge1RleHR1cmVOb2RlfSBbcGFyYW1ldGVycy5kZWZhdWx0VGV4dHVyZV0gLSBUaGUgZGVmYXVsdCB0ZXh0dXJlIG5vZGUuXHJcblx0ICogQHBhcmFtIHtSZWZsZWN0b3JCYXNlTm9kZX0gW3BhcmFtZXRlcnMucmVmbGVjdG9yXSAtIFRoZSByZWZsZWN0b3IgYmFzZSBub2RlLlxyXG5cdCAqL1xyXG5cdGNvbnN0cnVjdG9yKCBwYXJhbWV0ZXJzID0ge30gKSB7XHJcblxyXG5cdFx0c3VwZXIoIHBhcmFtZXRlcnMuZGVmYXVsdFRleHR1cmUgfHwgX2RlZmF1bHRSVC50ZXh0dXJlLCBfZGVmYXVsdFVWICk7XHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBBIHJlZmVyZW5jZSB0byB0aGUgaW50ZXJuYWwgcmVmbGVjdG9yIGJhc2Ugbm9kZSB3aGljaCBob2xkcyB0aGUgYWN0dWFsIGltcGxlbWVudGF0aW9uLlxyXG5cdFx0ICpcclxuXHRcdCAqIEBwcml2YXRlXHJcblx0XHQgKiBAdHlwZSB7UmVmbGVjdG9yQmFzZU5vZGU/fVxyXG5cdFx0ICogQGRlZmF1bHQgbnVsbFxyXG5cdFx0ICovXHJcblx0XHR0aGlzLl9yZWZsZWN0b3JCYXNlTm9kZSA9IHBhcmFtZXRlcnMucmVmbGVjdG9yIHx8IG5ldyBSZWZsZWN0b3JCYXNlTm9kZSggdGhpcywgcGFyYW1ldGVycyApO1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogQSByZWZlcmVuY2UgdG8gdGhlIGludGVybmFsIGRlcHRoIG5vZGUuXHJcblx0XHQgKlxyXG5cdFx0ICogQHByaXZhdGVcclxuXHRcdCAqIEB0eXBlIHtOb2RlP31cclxuXHRcdCAqIEBkZWZhdWx0IG51bGxcclxuXHRcdCAqL1xyXG5cdFx0dGhpcy5fZGVwdGhOb2RlID0gbnVsbDtcclxuXHJcblx0XHR0aGlzLnNldFVwZGF0ZU1hdHJpeCggZmFsc2UgKTtcclxuXHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBBIHJlZmVyZW5jZSB0byB0aGUgaW50ZXJuYWwgcmVmbGVjdG9yIG5vZGUuXHJcblx0ICpcclxuXHQgKiBAdHlwZSB7UmVmbGVjdG9yQmFzZU5vZGV9XHJcblx0ICovXHJcblx0Z2V0IHJlZmxlY3RvcigpIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5fcmVmbGVjdG9yQmFzZU5vZGU7XHJcblxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogQSByZWZlcmVuY2UgdG8gM0Qgb2JqZWN0IHRoZSByZWZsZWN0b3IgaXMgbGlua2VkIHRvLlxyXG5cdCAqXHJcblx0ICogQHR5cGUge09iamVjdDNEfVxyXG5cdCAqL1xyXG5cdGdldCB0YXJnZXQoKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuX3JlZmxlY3RvckJhc2VOb2RlLnRhcmdldDtcclxuXHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBSZXR1cm5zIGEgbm9kZSByZXByZXNlbnRpbmcgdGhlIG1pcnJvcidzIGRlcHRoLiBUaGF0IGNhbiBiZSB1c2VkXHJcblx0ICogdG8gaW1wbGVtZW50IG1vcmUgYWR2YW5jZWQgcmVmbGVjdGlvbiBlZmZlY3RzIGxpa2UgZGlzdGFuY2UgYXR0ZW51YXRpb24uXHJcblx0ICpcclxuXHQgKiBAcmV0dXJuIHtOb2RlfSBUaGUgZGVwdGggbm9kZS5cclxuXHQgKi9cclxuXHRnZXREZXB0aE5vZGUoKSB7XHJcblxyXG5cdFx0aWYgKCB0aGlzLl9kZXB0aE5vZGUgPT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHRpZiAoIHRoaXMuX3JlZmxlY3RvckJhc2VOb2RlLmRlcHRoICE9PSB0cnVlICkge1xyXG5cclxuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoICdUSFJFRS5SZWZsZWN0b3JOb2RlOiBEZXB0aCBub2RlIGNhbiBvbmx5IGJlIHJlcXVlc3RlZCB3aGVuIHRoZSByZWZsZWN0b3IgaXMgY3JlYXRlZCB3aXRoIHsgZGVwdGg6IHRydWUgfS4gJyApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dGhpcy5fZGVwdGhOb2RlID0gbm9kZU9iamVjdCggbmV3IFJlZmxlY3Rvck5vZGUoIHtcclxuXHRcdFx0XHRkZWZhdWx0VGV4dHVyZTogX2RlZmF1bHRSVC5kZXB0aFRleHR1cmUsXHJcblx0XHRcdFx0cmVmbGVjdG9yOiB0aGlzLl9yZWZsZWN0b3JCYXNlTm9kZVxyXG5cdFx0XHR9ICkgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuX2RlcHRoTm9kZTtcclxuXHJcblx0fVxyXG5cclxuXHRzZXR1cCggYnVpbGRlciApIHtcclxuXHJcblx0XHQvLyBpZ25vcmUgaWYgdXNlZCBpbiBwb3N0LXByb2Nlc3NpbmdcclxuXHRcdGlmICggISBidWlsZGVyLm9iamVjdC5pc1F1YWRNZXNoICkgdGhpcy5fcmVmbGVjdG9yQmFzZU5vZGUuYnVpbGQoIGJ1aWxkZXIgKTtcclxuXHJcblx0XHRyZXR1cm4gc3VwZXIuc2V0dXAoIGJ1aWxkZXIgKTtcclxuXHJcblx0fVxyXG5cclxuXHRjbG9uZSgpIHtcclxuXHJcblx0XHRjb25zdCB0ZXh0dXJlID0gbmV3IHRoaXMuY29uc3RydWN0b3IoIHRoaXMucmVmbGVjdG9yTm9kZSApO1xyXG5cdFx0dGV4dHVyZS5fcmVmbGVjdG9yQmFzZU5vZGUgPSB0aGlzLl9yZWZsZWN0b3JCYXNlTm9kZTtcclxuXHJcblx0XHRyZXR1cm4gdGV4dHVyZTtcclxuXHJcblx0fVxyXG5cclxufVxyXG5cclxuLyoqXHJcbiAqIEhvbGRzIHRoZSBhY3R1YWwgaW1wbGVtZW50YXRpb24gb2YgdGhlIHJlZmxlY3Rvci5cclxuICpcclxuICogVE9ETzogRXhwbGFpbiB3aHkgYFJlZmxlY3RvckJhc2VOb2RlYC4gT3JpZ2luYWxseSB0aGUgZW50aXJlIGxvZ2ljIHdhcyBpbXBsZW1lbnRlZFxyXG4gKiBpbiBgUmVmbGVjdG9yTm9kZWAsIHNlZSAjMjk2MTkuXHJcbiAqXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBhdWdtZW50cyBOb2RlXHJcbiAqL1xyXG5jbGFzcyBSZWZsZWN0b3JCYXNlTm9kZSBleHRlbmRzIE5vZGUge1xyXG5cclxuXHRzdGF0aWMgZ2V0IHR5cGUoKSB7XHJcblxyXG5cdFx0cmV0dXJuICdSZWZsZWN0b3JCYXNlTm9kZSc7XHJcblxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogQ29uc3RydWN0cyBhIG5ldyByZWZsZWN0b3IgYmFzZSBub2RlLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtUZXh0dXJlTm9kZX0gdGV4dHVyZU5vZGUgLSBSZXByZXNlbnRzIHRoZSByZW5kZXJlZCByZWZsZWN0aW9ucyBhcyBhIHRleHR1cmUgbm9kZS5cclxuXHQgKiBAcGFyYW0ge09iamVjdH0gW3BhcmFtZXRlcnM9e31dIC0gQW4gb2JqZWN0IGhvbGRpbmcgY29uZmlndXJhdGlvbiBwYXJhbWV0ZXJzLlxyXG5cdCAqIEBwYXJhbSB7T2JqZWN0M0R9IFtwYXJhbWV0ZXJzLnRhcmdldD1uZXcgT2JqZWN0M0QoKV0gLSBUaGUgM0Qgb2JqZWN0IHRoZSByZWZsZWN0b3IgaXMgbGlua2VkIHRvLlxyXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbcGFyYW1ldGVycy5yZXNvbHV0aW9uPTFdIC0gVGhlIHJlc29sdXRpb24gc2NhbGUuXHJcblx0ICogQHBhcmFtIHtCb29sZWFufSBbcGFyYW1ldGVycy5nZW5lcmF0ZU1pcG1hcHM9ZmFsc2VdIC0gV2hldGhlciBtaXBtYXBzIHNob3VsZCBiZSBnZW5lcmF0ZWQgb3Igbm90LlxyXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gW3BhcmFtZXRlcnMuYm91bmNlcz10cnVlXSAtIFdoZXRoZXIgcmVmbGVjdG9ycyBjYW4gcmVuZGVyIG90aGVyIHJlZmxlY3RvciBub2RlcyBvciBub3QuXHJcblx0ICogQHBhcmFtIHtCb29sZWFufSBbcGFyYW1ldGVycy5kZXB0aD1mYWxzZV0gLSBXaGV0aGVyIGRlcHRoIGRhdGEgc2hvdWxkIGJlIGdlbmVyYXRlZCBvciBub3QuXHJcblx0ICovXHJcblx0Y29uc3RydWN0b3IoIHRleHR1cmVOb2RlLCBwYXJhbWV0ZXJzID0ge30gKSB7XHJcblxyXG5cdFx0c3VwZXIoKTtcclxuXHJcblx0XHRjb25zdCB7XHJcblx0XHRcdHRhcmdldCA9IG5ldyBPYmplY3QzRCgpLFxyXG5cdFx0XHRyZXNvbHV0aW9uID0gMSxcclxuXHRcdFx0Z2VuZXJhdGVNaXBtYXBzID0gZmFsc2UsXHJcblx0XHRcdGJvdW5jZXMgPSB0cnVlLFxyXG5cdFx0XHRkZXB0aCA9IGZhbHNlXHJcblx0XHR9ID0gcGFyYW1ldGVycztcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIFJlcHJlc2VudHMgdGhlIHJlbmRlcmVkIHJlZmxlY3Rpb25zIGFzIGEgdGV4dHVyZSBub2RlLlxyXG5cdFx0ICpcclxuXHRcdCAqIEB0eXBlIHtUZXh0dXJlTm9kZX1cclxuXHRcdCAqL1xyXG5cdFx0dGhpcy50ZXh0dXJlTm9kZSA9IHRleHR1cmVOb2RlO1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogVGhlIDNEIG9iamVjdCB0aGUgcmVmbGVjdG9yIGlzIGxpbmtlZCB0by5cclxuXHRcdCAqXHJcblx0XHQgKiBAdHlwZSB7T2JqZWN0M0R9XHJcblx0XHQgKiBAZGVmYXVsdCB7bmV3IE9iamVjdDNEKCl9XHJcblx0XHQgKi9cclxuXHRcdHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogVGhlIHJlc29sdXRpb24gc2NhbGUuXHJcblx0XHQgKlxyXG5cdFx0ICogQHR5cGUge051bWJlcn1cclxuXHRcdCAqIEBkZWZhdWx0IHsxfVxyXG5cdFx0ICovXHJcblx0XHR0aGlzLnJlc29sdXRpb24gPSByZXNvbHV0aW9uO1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogV2hldGhlciBtaXBtYXBzIHNob3VsZCBiZSBnZW5lcmF0ZWQgb3Igbm90LlxyXG5cdFx0ICpcclxuXHRcdCAqIEB0eXBlIHtCb29sZWFufVxyXG5cdFx0ICogQGRlZmF1bHQge2ZhbHNlfVxyXG5cdFx0ICovXHJcblx0XHR0aGlzLmdlbmVyYXRlTWlwbWFwcyA9IGdlbmVyYXRlTWlwbWFwcztcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIFdoZXRoZXIgcmVmbGVjdG9ycyBjYW4gcmVuZGVyIG90aGVyIHJlZmxlY3RvciBub2RlcyBvciBub3QuXHJcblx0XHQgKlxyXG5cdFx0ICogQHR5cGUge0Jvb2xlYW59XHJcblx0XHQgKiBAZGVmYXVsdCB7dHJ1ZX1cclxuXHRcdCAqL1xyXG5cdFx0dGhpcy5ib3VuY2VzID0gYm91bmNlcztcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIFdoZXRoZXIgZGVwdGggZGF0YSBzaG91bGQgYmUgZ2VuZXJhdGVkIG9yIG5vdC5cclxuXHRcdCAqXHJcblx0XHQgKiBAdHlwZSB7Qm9vbGVhbn1cclxuXHRcdCAqIEBkZWZhdWx0IHtmYWxzZX1cclxuXHRcdCAqL1xyXG5cdFx0dGhpcy5kZXB0aCA9IGRlcHRoO1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogVGhlIGB1cGRhdGVCZWZvcmVUeXBlYCBpcyBzZXQgdG8gYE5vZGVVcGRhdGVUeXBlLlJFTkRFUmAgd2hlbiB7QGxpbmsgUmVmbGVjdG9yQmFzZU5vZGUjYm91bmNlc31cclxuXHRcdCAqIGlzIGB0cnVlYC4gT3RoZXJ3aXNlIGl0J3MgYE5vZGVVcGRhdGVUeXBlLkZSQU1FYC5cclxuXHRcdCAqXHJcblx0XHQgKiBAdHlwZSB7U3RyaW5nfVxyXG5cdFx0ICogQGRlZmF1bHQgJ3JlbmRlcidcclxuXHRcdCAqL1xyXG5cdFx0dGhpcy51cGRhdGVCZWZvcmVUeXBlID0gYm91bmNlcyA/IE5vZGVVcGRhdGVUeXBlLlJFTkRFUiA6IE5vZGVVcGRhdGVUeXBlLkZSQU1FO1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogV2VhayBtYXAgZm9yIG1hbmFnaW5nIHZpcnR1YWwgY2FtZXJhcy5cclxuXHRcdCAqXHJcblx0XHQgKiBAdHlwZSB7V2Vha01hcDxDYW1lcmEsIENhbWVyYT59XHJcblx0XHQgKi9cclxuXHRcdHRoaXMudmlydHVhbENhbWVyYXMgPSBuZXcgV2Vha01hcCgpO1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogV2VhayBtYXAgZm9yIG1hbmFnaW5nIHJlbmRlciB0YXJnZXRzLlxyXG5cdFx0ICpcclxuXHRcdCAqIEB0eXBlIHtXZWFrTWFwPENhbWVyYSwgUmVuZGVyVGFyZ2V0Pn1cclxuXHRcdCAqL1xyXG5cdFx0dGhpcy5yZW5kZXJUYXJnZXRzID0gbmV3IFdlYWtNYXAoKTtcclxuXHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBVcGRhdGVzIHRoZSByZXNvbHV0aW9uIG9mIHRoZSBpbnRlcm5hbCByZW5kZXIgdGFyZ2V0LlxyXG5cdCAqXHJcblx0ICogQHByaXZhdGVcclxuXHQgKiBAcGFyYW0ge1JlbmRlclRhcmdldH0gcmVuZGVyVGFyZ2V0IC0gVGhlIHJlbmRlciB0YXJnZXQgdG8gcmVzaXplLlxyXG5cdCAqIEBwYXJhbSB7UmVuZGVyZXJ9IHJlbmRlcmVyIC0gVGhlIHJlbmRlcmVyIHRoYXQgaXMgdXNlZCB0byBkZXRlcm1pbmUgdGhlIG5ldyBzaXplLlxyXG5cdCAqL1xyXG5cdF91cGRhdGVSZXNvbHV0aW9uKCByZW5kZXJUYXJnZXQsIHJlbmRlcmVyICkge1xyXG5cclxuXHRcdGNvbnN0IHJlc29sdXRpb24gPSB0aGlzLnJlc29sdXRpb247XHJcblxyXG5cdFx0cmVuZGVyZXIuZ2V0RHJhd2luZ0J1ZmZlclNpemUoIF9zaXplICk7XHJcblxyXG5cdFx0cmVuZGVyVGFyZ2V0LnNldFNpemUoIE1hdGgucm91bmQoIF9zaXplLndpZHRoICogcmVzb2x1dGlvbiApLCBNYXRoLnJvdW5kKCBfc2l6ZS5oZWlnaHQgKiByZXNvbHV0aW9uICkgKTtcclxuXHJcblx0fVxyXG5cclxuXHRzZXR1cCggYnVpbGRlciApIHtcclxuXHJcblx0XHR0aGlzLl91cGRhdGVSZXNvbHV0aW9uKCBfZGVmYXVsdFJULCBidWlsZGVyLnJlbmRlcmVyICk7XHJcblxyXG5cdFx0cmV0dXJuIHN1cGVyLnNldHVwKCBidWlsZGVyICk7XHJcblxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogUmV0dXJucyBhIHZpcnR1YWwgY2FtZXJhIGZvciB0aGUgZ2l2ZW4gY2FtZXJhLiBUaGUgdmlydHVhbCBjYW1lcmEgaXMgdXNlZCB0b1xyXG5cdCAqIHJlbmRlciB0aGUgc2NlbmUgZnJvbSB0aGUgcmVmbGVjdG9yJ3MgdmlldyBzbyBjb3JyZWN0IHJlZmxlY3Rpb25zIGNhbiBiZSBwcm9kdWNlZC5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7Q2FtZXJhfSBjYW1lcmEgLSBUaGUgc2NlbmUncyBjYW1lcmEuXHJcblx0ICogQHJldHVybiB7Q2FtZXJhfSBUaGUgY29ycmVzcG9uZGluZyB2aXJ0dWFsIGNhbWVyYS5cclxuXHQgKi9cclxuXHRnZXRWaXJ0dWFsQ2FtZXJhKCBjYW1lcmEgKSB7XHJcblxyXG5cdFx0bGV0IHZpcnR1YWxDYW1lcmEgPSB0aGlzLnZpcnR1YWxDYW1lcmFzLmdldCggY2FtZXJhICk7XHJcblxyXG5cdFx0aWYgKCB2aXJ0dWFsQ2FtZXJhID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHR2aXJ0dWFsQ2FtZXJhID0gY2FtZXJhLmNsb25lKCk7XHJcblxyXG5cdFx0XHR0aGlzLnZpcnR1YWxDYW1lcmFzLnNldCggY2FtZXJhLCB2aXJ0dWFsQ2FtZXJhICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB2aXJ0dWFsQ2FtZXJhO1xyXG5cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFJldHVybnMgYSByZW5kZXIgdGFyZ2V0IGZvciB0aGUgZ2l2ZW4gY2FtZXJhLiBUaGUgcmVmbGVjdGlvbnMgYXJlIHJlbmRlcmVkXHJcblx0ICogaW50byB0aGlzIHJlbmRlciB0YXJnZXQuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge0NhbWVyYX0gY2FtZXJhIC0gVGhlIHNjZW5lJ3MgY2FtZXJhLlxyXG5cdCAqIEByZXR1cm4ge1JlbmRlclRhcmdldH0gVGhlIHJlbmRlciB0YXJnZXQuXHJcblx0ICovXHJcblx0Z2V0UmVuZGVyVGFyZ2V0KCBjYW1lcmEgKSB7XHJcblxyXG5cdFx0bGV0IHJlbmRlclRhcmdldCA9IHRoaXMucmVuZGVyVGFyZ2V0cy5nZXQoIGNhbWVyYSApO1xyXG5cclxuXHRcdGlmICggcmVuZGVyVGFyZ2V0ID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRyZW5kZXJUYXJnZXQgPSBuZXcgUmVuZGVyVGFyZ2V0KCAwLCAwLCB7IHR5cGU6IEhhbGZGbG9hdFR5cGUgfSApO1xyXG5cclxuXHRcdFx0aWYgKCB0aGlzLmdlbmVyYXRlTWlwbWFwcyA9PT0gdHJ1ZSApIHtcclxuXHJcblx0XHRcdFx0cmVuZGVyVGFyZ2V0LnRleHR1cmUubWluRmlsdGVyID0gTGluZWFyTWlwTWFwTGluZWFyRmlsdGVyO1xyXG5cdFx0XHRcdHJlbmRlclRhcmdldC50ZXh0dXJlLmdlbmVyYXRlTWlwbWFwcyA9IHRydWU7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoIHRoaXMuZGVwdGggPT09IHRydWUgKSB7XHJcblxyXG5cdFx0XHRcdHJlbmRlclRhcmdldC5kZXB0aFRleHR1cmUgPSBuZXcgRGVwdGhUZXh0dXJlKCk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR0aGlzLnJlbmRlclRhcmdldHMuc2V0KCBjYW1lcmEsIHJlbmRlclRhcmdldCApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gcmVuZGVyVGFyZ2V0O1xyXG5cclxuXHR9XHJcblxyXG5cdHVwZGF0ZUJlZm9yZSggZnJhbWUgKSB7XHJcblxyXG5cdFx0aWYgKCB0aGlzLmJvdW5jZXMgPT09IGZhbHNlICYmIF9pblJlZmxlY3RvciApIHJldHVybjtcclxuXHJcblx0XHRfaW5SZWZsZWN0b3IgPSB0cnVlO1xyXG5cclxuXHRcdGNvbnN0IHsgc2NlbmUsIGNhbWVyYSwgcmVuZGVyZXIsIG1hdGVyaWFsIH0gPSBmcmFtZTtcclxuXHRcdGNvbnN0IHsgdGFyZ2V0IH0gPSB0aGlzO1xyXG5cclxuXHRcdGNvbnN0IHZpcnR1YWxDYW1lcmEgPSB0aGlzLmdldFZpcnR1YWxDYW1lcmEoIGNhbWVyYSApO1xyXG5cdFx0Y29uc3QgcmVuZGVyVGFyZ2V0ID0gdGhpcy5nZXRSZW5kZXJUYXJnZXQoIHZpcnR1YWxDYW1lcmEgKTtcclxuXHJcblx0XHRyZW5kZXJlci5nZXREcmF3aW5nQnVmZmVyU2l6ZSggX3NpemUgKTtcclxuXHJcblx0XHR0aGlzLl91cGRhdGVSZXNvbHV0aW9uKCByZW5kZXJUYXJnZXQsIHJlbmRlcmVyICk7XHJcblxyXG5cdFx0Ly9cclxuXHJcblx0XHRfcmVmbGVjdG9yV29ybGRQb3NpdGlvbi5zZXRGcm9tTWF0cml4UG9zaXRpb24oIHRhcmdldC5tYXRyaXhXb3JsZCApO1xyXG5cdFx0X2NhbWVyYVdvcmxkUG9zaXRpb24uc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCBjYW1lcmEubWF0cml4V29ybGQgKTtcclxuXHJcblx0XHRfcm90YXRpb25NYXRyaXguZXh0cmFjdFJvdGF0aW9uKCB0YXJnZXQubWF0cml4V29ybGQgKTtcclxuXHJcblx0XHRfbm9ybWFsLnNldCggMCwgMCwgMSApO1xyXG5cdFx0X25vcm1hbC5hcHBseU1hdHJpeDQoIF9yb3RhdGlvbk1hdHJpeCApO1xyXG5cclxuXHRcdF92aWV3LnN1YlZlY3RvcnMoIF9yZWZsZWN0b3JXb3JsZFBvc2l0aW9uLCBfY2FtZXJhV29ybGRQb3NpdGlvbiApO1xyXG5cclxuXHRcdC8vIEF2b2lkIHJlbmRlcmluZyB3aGVuIHJlZmxlY3RvciBpcyBmYWNpbmcgYXdheVxyXG5cclxuXHRcdGlmICggX3ZpZXcuZG90KCBfbm9ybWFsICkgPiAwICkgcmV0dXJuO1xyXG5cclxuXHRcdF92aWV3LnJlZmxlY3QoIF9ub3JtYWwgKS5uZWdhdGUoKTtcclxuXHRcdF92aWV3LmFkZCggX3JlZmxlY3RvcldvcmxkUG9zaXRpb24gKTtcclxuXHJcblx0XHRfcm90YXRpb25NYXRyaXguZXh0cmFjdFJvdGF0aW9uKCBjYW1lcmEubWF0cml4V29ybGQgKTtcclxuXHJcblx0XHRfbG9va0F0UG9zaXRpb24uc2V0KCAwLCAwLCAtIDEgKTtcclxuXHRcdF9sb29rQXRQb3NpdGlvbi5hcHBseU1hdHJpeDQoIF9yb3RhdGlvbk1hdHJpeCApO1xyXG5cdFx0X2xvb2tBdFBvc2l0aW9uLmFkZCggX2NhbWVyYVdvcmxkUG9zaXRpb24gKTtcclxuXHJcblx0XHRfdGFyZ2V0LnN1YlZlY3RvcnMoIF9yZWZsZWN0b3JXb3JsZFBvc2l0aW9uLCBfbG9va0F0UG9zaXRpb24gKTtcclxuXHRcdF90YXJnZXQucmVmbGVjdCggX25vcm1hbCApLm5lZ2F0ZSgpO1xyXG5cdFx0X3RhcmdldC5hZGQoIF9yZWZsZWN0b3JXb3JsZFBvc2l0aW9uICk7XHJcblxyXG5cdFx0Ly9cclxuXHJcblx0XHR2aXJ0dWFsQ2FtZXJhLmNvb3JkaW5hdGVTeXN0ZW0gPSBjYW1lcmEuY29vcmRpbmF0ZVN5c3RlbTtcclxuXHRcdHZpcnR1YWxDYW1lcmEucG9zaXRpb24uY29weSggX3ZpZXcgKTtcclxuXHRcdHZpcnR1YWxDYW1lcmEudXAuc2V0KCAwLCAxLCAwICk7XHJcblx0XHR2aXJ0dWFsQ2FtZXJhLnVwLmFwcGx5TWF0cml4NCggX3JvdGF0aW9uTWF0cml4ICk7XHJcblx0XHR2aXJ0dWFsQ2FtZXJhLnVwLnJlZmxlY3QoIF9ub3JtYWwgKTtcclxuXHRcdHZpcnR1YWxDYW1lcmEubG9va0F0KCBfdGFyZ2V0ICk7XHJcblxyXG5cdFx0dmlydHVhbENhbWVyYS5uZWFyID0gY2FtZXJhLm5lYXI7XHJcblx0XHR2aXJ0dWFsQ2FtZXJhLmZhciA9IGNhbWVyYS5mYXI7XHJcblxyXG5cdFx0dmlydHVhbENhbWVyYS51cGRhdGVNYXRyaXhXb3JsZCgpO1xyXG5cdFx0dmlydHVhbENhbWVyYS5wcm9qZWN0aW9uTWF0cml4LmNvcHkoIGNhbWVyYS5wcm9qZWN0aW9uTWF0cml4ICk7XHJcblxyXG5cdFx0Ly8gTm93IHVwZGF0ZSBwcm9qZWN0aW9uIG1hdHJpeCB3aXRoIG5ldyBjbGlwIHBsYW5lLCBpbXBsZW1lbnRpbmcgY29kZSBmcm9tOiBodHRwOi8vd3d3LnRlcmF0aG9uLmNvbS9jb2RlL29ibGlxdWUuaHRtbFxyXG5cdFx0Ly8gUGFwZXIgZXhwbGFpbmluZyB0aGlzIHRlY2huaXF1ZTogaHR0cDovL3d3dy50ZXJhdGhvbi5jb20vbGVuZ3llbC9MZW5neWVsLU9ibGlxdWUucGRmXHJcblx0XHRfcmVmbGVjdG9yUGxhbmUuc2V0RnJvbU5vcm1hbEFuZENvcGxhbmFyUG9pbnQoIF9ub3JtYWwsIF9yZWZsZWN0b3JXb3JsZFBvc2l0aW9uICk7XHJcblx0XHRfcmVmbGVjdG9yUGxhbmUuYXBwbHlNYXRyaXg0KCB2aXJ0dWFsQ2FtZXJhLm1hdHJpeFdvcmxkSW52ZXJzZSApO1xyXG5cclxuXHRcdGNsaXBQbGFuZS5zZXQoIF9yZWZsZWN0b3JQbGFuZS5ub3JtYWwueCwgX3JlZmxlY3RvclBsYW5lLm5vcm1hbC55LCBfcmVmbGVjdG9yUGxhbmUubm9ybWFsLnosIF9yZWZsZWN0b3JQbGFuZS5jb25zdGFudCApO1xyXG5cclxuXHRcdGNvbnN0IHByb2plY3Rpb25NYXRyaXggPSB2aXJ0dWFsQ2FtZXJhLnByb2plY3Rpb25NYXRyaXg7XHJcblxyXG5cdFx0X3EueCA9ICggTWF0aC5zaWduKCBjbGlwUGxhbmUueCApICsgcHJvamVjdGlvbk1hdHJpeC5lbGVtZW50c1sgOCBdICkgLyBwcm9qZWN0aW9uTWF0cml4LmVsZW1lbnRzWyAwIF07XHJcblx0XHRfcS55ID0gKCBNYXRoLnNpZ24oIGNsaXBQbGFuZS55ICkgKyBwcm9qZWN0aW9uTWF0cml4LmVsZW1lbnRzWyA5IF0gKSAvIHByb2plY3Rpb25NYXRyaXguZWxlbWVudHNbIDUgXTtcclxuXHRcdF9xLnogPSAtIDEuMDtcclxuXHRcdF9xLncgPSAoIDEuMCArIHByb2plY3Rpb25NYXRyaXguZWxlbWVudHNbIDEwIF0gKSAvIHByb2plY3Rpb25NYXRyaXguZWxlbWVudHNbIDE0IF07XHJcblxyXG5cdFx0Ly8gQ2FsY3VsYXRlIHRoZSBzY2FsZWQgcGxhbmUgdmVjdG9yXHJcblx0XHRjbGlwUGxhbmUubXVsdGlwbHlTY2FsYXIoIDEuMCAvIGNsaXBQbGFuZS5kb3QoIF9xICkgKTtcclxuXHJcblx0XHRjb25zdCBjbGlwQmlhcyA9IDA7XHJcblxyXG5cdFx0Ly8gUmVwbGFjaW5nIHRoZSB0aGlyZCByb3cgb2YgdGhlIHByb2plY3Rpb24gbWF0cml4XHJcblx0XHRwcm9qZWN0aW9uTWF0cml4LmVsZW1lbnRzWyAyIF0gPSBjbGlwUGxhbmUueDtcclxuXHRcdHByb2plY3Rpb25NYXRyaXguZWxlbWVudHNbIDYgXSA9IGNsaXBQbGFuZS55O1xyXG5cdFx0cHJvamVjdGlvbk1hdHJpeC5lbGVtZW50c1sgMTAgXSA9ICggcmVuZGVyZXIuY29vcmRpbmF0ZVN5c3RlbSA9PT0gV2ViR1BVQ29vcmRpbmF0ZVN5c3RlbSApID8gKCBjbGlwUGxhbmUueiAtIGNsaXBCaWFzICkgOiAoIGNsaXBQbGFuZS56ICsgMS4wIC0gY2xpcEJpYXMgKTtcclxuXHRcdHByb2plY3Rpb25NYXRyaXguZWxlbWVudHNbIDE0IF0gPSBjbGlwUGxhbmUudztcclxuXHJcblx0XHQvL1xyXG5cclxuXHRcdHRoaXMudGV4dHVyZU5vZGUudmFsdWUgPSByZW5kZXJUYXJnZXQudGV4dHVyZTtcclxuXHJcblx0XHRpZiAoIHRoaXMuZGVwdGggPT09IHRydWUgKSB7XHJcblxyXG5cdFx0XHR0aGlzLnRleHR1cmVOb2RlLmdldERlcHRoTm9kZSgpLnZhbHVlID0gcmVuZGVyVGFyZ2V0LmRlcHRoVGV4dHVyZTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0bWF0ZXJpYWwudmlzaWJsZSA9IGZhbHNlO1xyXG5cclxuXHRcdGNvbnN0IGN1cnJlbnRSZW5kZXJUYXJnZXQgPSByZW5kZXJlci5nZXRSZW5kZXJUYXJnZXQoKTtcclxuXHRcdGNvbnN0IGN1cnJlbnRNUlQgPSByZW5kZXJlci5nZXRNUlQoKTtcclxuXHJcblx0XHRyZW5kZXJlci5zZXRNUlQoIG51bGwgKTtcclxuXHRcdHJlbmRlcmVyLnNldFJlbmRlclRhcmdldCggcmVuZGVyVGFyZ2V0ICk7XHJcblxyXG5cdFx0cmVuZGVyZXIucmVuZGVyKCBzY2VuZSwgdmlydHVhbENhbWVyYSApO1xyXG5cclxuXHRcdHJlbmRlcmVyLnNldE1SVCggY3VycmVudE1SVCApO1xyXG5cdFx0cmVuZGVyZXIuc2V0UmVuZGVyVGFyZ2V0KCBjdXJyZW50UmVuZGVyVGFyZ2V0ICk7XHJcblxyXG5cdFx0bWF0ZXJpYWwudmlzaWJsZSA9IHRydWU7XHJcblxyXG5cdFx0X2luUmVmbGVjdG9yID0gZmFsc2U7XHJcblxyXG5cdH1cclxuXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBUU0wgZnVuY3Rpb24gZm9yIGNyZWF0aW5nIGEgcmVmbGVjdG9yIG5vZGUuXHJcbiAqXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0ge09iamVjdH0gW3BhcmFtZXRlcnM9e31dIC0gQW4gb2JqZWN0IGhvbGRpbmcgY29uZmlndXJhdGlvbiBwYXJhbWV0ZXJzLlxyXG4gKiBAcGFyYW0ge09iamVjdDNEfSBbcGFyYW1ldGVycy50YXJnZXQ9bmV3IE9iamVjdDNEKCldIC0gVGhlIDNEIG9iamVjdCB0aGUgcmVmbGVjdG9yIGlzIGxpbmtlZCB0by5cclxuICogQHBhcmFtIHtOdW1iZXJ9IFtwYXJhbWV0ZXJzLnJlc29sdXRpb249MV0gLSBUaGUgcmVzb2x1dGlvbiBzY2FsZS5cclxuICogQHBhcmFtIHtCb29sZWFufSBbcGFyYW1ldGVycy5nZW5lcmF0ZU1pcG1hcHM9ZmFsc2VdIC0gV2hldGhlciBtaXBtYXBzIHNob3VsZCBiZSBnZW5lcmF0ZWQgb3Igbm90LlxyXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtwYXJhbWV0ZXJzLmJvdW5jZXM9dHJ1ZV0gLSBXaGV0aGVyIHJlZmxlY3RvcnMgY2FuIHJlbmRlciBvdGhlciByZWZsZWN0b3Igbm9kZXMgb3Igbm90LlxyXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtwYXJhbWV0ZXJzLmRlcHRoPWZhbHNlXSAtIFdoZXRoZXIgZGVwdGggZGF0YSBzaG91bGQgYmUgZ2VuZXJhdGVkIG9yIG5vdC5cclxuICogQHBhcmFtIHtUZXh0dXJlTm9kZX0gW3BhcmFtZXRlcnMuZGVmYXVsdFRleHR1cmVdIC0gVGhlIGRlZmF1bHQgdGV4dHVyZSBub2RlLlxyXG4gKiBAcGFyYW0ge1JlZmxlY3RvckJhc2VOb2RlfSBbcGFyYW1ldGVycy5yZWZsZWN0b3JdIC0gVGhlIHJlZmxlY3RvciBiYXNlIG5vZGUuXHJcbiAqIEByZXR1cm5zIHtSZWZsZWN0b3JOb2RlfVxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IHJlZmxlY3RvciA9ICggcGFyYW1ldGVycyApID0+IG5vZGVPYmplY3QoIG5ldyBSZWZsZWN0b3JOb2RlKCBwYXJhbWV0ZXJzICkgKTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IFJlZmxlY3Rvck5vZGU7XHJcbiIsImltcG9ydCB7IEJ1ZmZlckdlb21ldHJ5IH0gZnJvbSAnLi4vLi4vY29yZS9CdWZmZXJHZW9tZXRyeS5qcyc7XHJcbmltcG9ydCB7IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUgfSBmcm9tICcuLi8uLi9jb3JlL0J1ZmZlckF0dHJpYnV0ZS5qcyc7XHJcbmltcG9ydCB7IE1lc2ggfSBmcm9tICcuLi8uLi9vYmplY3RzL01lc2guanMnO1xyXG5pbXBvcnQgeyBPcnRob2dyYXBoaWNDYW1lcmEgfSBmcm9tICcuLi8uLi9jYW1lcmFzL09ydGhvZ3JhcGhpY0NhbWVyYS5qcyc7XHJcblxyXG4vLyBIZWxwZXIgZm9yIHBhc3NlcyB0aGF0IG5lZWQgdG8gZmlsbCB0aGUgdmlld3BvcnQgd2l0aCBhIHNpbmdsZSBxdWFkLlxyXG5cclxuY29uc3QgX2NhbWVyYSA9IC8qQF9fUFVSRV9fKi8gbmV3IE9ydGhvZ3JhcGhpY0NhbWVyYSggLSAxLCAxLCAxLCAtIDEsIDAsIDEgKTtcclxuXHJcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tcmRvb2IvdGhyZWUuanMvcHVsbC8yMTM1OFxyXG5cclxuY2xhc3MgUXVhZEdlb21ldHJ5IGV4dGVuZHMgQnVmZmVyR2VvbWV0cnkge1xyXG5cclxuXHRjb25zdHJ1Y3RvciggZmxpcFkgPSBmYWxzZSApIHtcclxuXHJcblx0XHRzdXBlcigpO1xyXG5cclxuXHRcdGNvbnN0IHV2ID0gZmxpcFkgPT09IGZhbHNlID8gWyAwLCAtIDEsIDAsIDEsIDIsIDEgXSA6IFsgMCwgMiwgMCwgMCwgMiwgMCBdO1xyXG5cclxuXHRcdHRoaXMuc2V0QXR0cmlidXRlKCAncG9zaXRpb24nLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggWyAtIDEsIDMsIDAsIC0gMSwgLSAxLCAwLCAzLCAtIDEsIDAgXSwgMyApICk7XHJcblx0XHR0aGlzLnNldEF0dHJpYnV0ZSggJ3V2JywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIHV2LCAyICkgKTtcclxuXHJcblx0fVxyXG5cclxufVxyXG5cclxuY29uc3QgX2dlb21ldHJ5ID0gLypAX19QVVJFX18qLyBuZXcgUXVhZEdlb21ldHJ5KCk7XHJcblxyXG5jbGFzcyBRdWFkTWVzaCBleHRlbmRzIE1lc2gge1xyXG5cclxuXHRjb25zdHJ1Y3RvciggbWF0ZXJpYWwgPSBudWxsICkge1xyXG5cclxuXHRcdHN1cGVyKCBfZ2VvbWV0cnksIG1hdGVyaWFsICk7XHJcblxyXG5cdFx0dGhpcy5jYW1lcmEgPSBfY2FtZXJhO1xyXG5cclxuXHRcdHRoaXMuaXNRdWFkTWVzaCA9IHRydWU7XHJcblxyXG5cdH1cclxuXHJcblx0cmVuZGVyQXN5bmMoIHJlbmRlcmVyICkge1xyXG5cclxuXHRcdHJldHVybiByZW5kZXJlci5yZW5kZXJBc3luYyggdGhpcywgX2NhbWVyYSApO1xyXG5cclxuXHR9XHJcblxyXG5cdHJlbmRlciggcmVuZGVyZXIgKSB7XHJcblxyXG5cdFx0cmVuZGVyZXIucmVuZGVyKCB0aGlzLCBfY2FtZXJhICk7XHJcblxyXG5cdH1cclxuXHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IFF1YWRNZXNoO1xyXG4iLCJpbXBvcnQgeyBub2RlT2JqZWN0IH0gZnJvbSAnLi4vdHNsL1RTTENvcmUuanMnO1xyXG5pbXBvcnQgVGV4dHVyZU5vZGUgZnJvbSAnLi4vYWNjZXNzb3JzL1RleHR1cmVOb2RlLmpzJztcclxuaW1wb3J0IHsgTm9kZVVwZGF0ZVR5cGUgfSBmcm9tICcuLi9jb3JlL2NvbnN0YW50cy5qcyc7XHJcbmltcG9ydCB7IHV2IH0gZnJvbSAnLi4vYWNjZXNzb3JzL1VWLmpzJztcclxuaW1wb3J0IE5vZGVNYXRlcmlhbCBmcm9tICcuLi8uLi9tYXRlcmlhbHMvbm9kZXMvTm9kZU1hdGVyaWFsLmpzJztcclxuaW1wb3J0IFF1YWRNZXNoIGZyb20gJy4uLy4uL3JlbmRlcmVycy9jb21tb24vUXVhZE1lc2guanMnO1xyXG5cclxuaW1wb3J0IHsgUmVuZGVyVGFyZ2V0IH0gZnJvbSAnLi4vLi4vY29yZS9SZW5kZXJUYXJnZXQuanMnO1xyXG5pbXBvcnQgeyBWZWN0b3IyIH0gZnJvbSAnLi4vLi4vbWF0aC9WZWN0b3IyLmpzJztcclxuaW1wb3J0IHsgSGFsZkZsb2F0VHlwZSB9IGZyb20gJy4uLy4uL2NvbnN0YW50cy5qcyc7XHJcblxyXG4vKiogQG1vZHVsZSBSVFROb2RlICoqL1xyXG5cclxuY29uc3QgX3NpemUgPSAvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IyKCk7XHJcblxyXG4vKipcclxuICogYFJUVE5vZGVgIHRha2VzIGFub3RoZXIgbm9kZSBhbmQgdXNlcyBpdCB3aXRoIGEgYFF1YWRNZXNoYCB0byByZW5kZXIgaW50byBhIHRleHR1cmUgKFJUVCkuXHJcbiAqIFRoaXMgbW9kdWxlIGlzIGVzcGVjaWFsbHkgcmVsZXZhbnQgaW4gY29udGV4dCBvZiBwb3N0IHByb2Nlc3Npbmcgd2hlcmUgY2VydGFpbiBub2RlcyByZXF1aXJlXHJcbiAqIHRleHR1cmUgaW5wdXQgZm9yIHRoZWlyIGVmZmVjdHMuIFdpdGggdGhlIGhlbHBlciBmdW5jdGlvbiBgY29udmVydFRvVGV4dHVyZSgpYCB3aGljaCBpcyBiYXNlZFxyXG4gKiBvbiB0aGlzIG1vZHVsZSwgdGhlIG5vZGUgc3lzdGVtIGNhbiBhdXRvbWF0aWNhbGx5IGVuc3VyZSB0ZXh0dXJlIGlucHV0IGlmIHJlcXVpcmVkLlxyXG4gKlxyXG4gKiBAYXVnbWVudHMgbW9kdWxlOlRleHR1cmVOb2RlflRleHR1cmVOb2RlXHJcbiAqL1xyXG5jbGFzcyBSVFROb2RlIGV4dGVuZHMgVGV4dHVyZU5vZGUge1xyXG5cclxuXHRzdGF0aWMgZ2V0IHR5cGUoKSB7XHJcblxyXG5cdFx0cmV0dXJuICdSVFROb2RlJztcclxuXHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBDb25zdHJ1Y3RzIGEgbmV3IFJUVCBub2RlLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtOb2RlfSBub2RlIC0gVGhlIG5vZGUgdG8gcmVuZGVyIGEgdGV4dHVyZSB3aXRoLlxyXG5cdCAqIEBwYXJhbSB7TnVtYmVyP30gW3dpZHRoPW51bGxdIC0gVGhlIHdpZHRoIG9mIHRoZSBpbnRlcm5hbCByZW5kZXIgdGFyZ2V0LiBJZiBub3Qgd2lkdGggaXMgYXBwbGllZCwgdGhlIHJlbmRlciB0YXJnZXQgaXMgYXV0b21hdGljYWxseSByZXNpemVkLlxyXG5cdCAqIEBwYXJhbSB7TnVtYmVyP30gW2hlaWdodD1udWxsXSAtIFRoZSBoZWlnaHQgb2YgdGhlIGludGVybmFsIHJlbmRlciB0YXJnZXQuXHJcblx0ICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPXt0eXBlOkhhbGZGbG9hdFR5cGV9XSAtIFRoZSBvcHRpb25zIGZvciB0aGUgaW50ZXJuYWwgcmVuZGVyIHRhcmdldC5cclxuXHQgKi9cclxuXHRjb25zdHJ1Y3Rvciggbm9kZSwgd2lkdGggPSBudWxsLCBoZWlnaHQgPSBudWxsLCBvcHRpb25zID0geyB0eXBlOiBIYWxmRmxvYXRUeXBlIH0gKSB7XHJcblxyXG5cdFx0Y29uc3QgcmVuZGVyVGFyZ2V0ID0gbmV3IFJlbmRlclRhcmdldCggd2lkdGgsIGhlaWdodCwgb3B0aW9ucyApO1xyXG5cclxuXHRcdHN1cGVyKCByZW5kZXJUYXJnZXQudGV4dHVyZSwgdXYoKSApO1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogVGhlIG5vZGUgdG8gcmVuZGVyIGEgdGV4dHVyZSB3aXRoLlxyXG5cdFx0ICpcclxuXHRcdCAqIEB0eXBlIHtOb2RlfVxyXG5cdFx0ICovXHJcblx0XHR0aGlzLm5vZGUgPSBub2RlO1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogVGhlIHdpZHRoIG9mIHRoZSBpbnRlcm5hbCByZW5kZXIgdGFyZ2V0LlxyXG5cdFx0ICogSWYgbm90IHdpZHRoIGlzIGFwcGxpZWQsIHRoZSByZW5kZXIgdGFyZ2V0IGlzIGF1dG9tYXRpY2FsbHkgcmVzaXplZC5cclxuXHRcdCAqXHJcblx0XHQgKiBAdHlwZSB7TnVtYmVyP31cclxuXHRcdCAqIEBkZWZhdWx0IG51bGxcclxuXHRcdCAqL1xyXG5cdFx0dGhpcy53aWR0aCA9IHdpZHRoO1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogVGhlIGhlaWdodCBvZiB0aGUgaW50ZXJuYWwgcmVuZGVyIHRhcmdldC5cclxuXHRcdCAqXHJcblx0XHQgKiBAdHlwZSB7TnVtYmVyP31cclxuXHRcdCAqIEBkZWZhdWx0IG51bGxcclxuXHRcdCAqL1xyXG5cdFx0dGhpcy5oZWlnaHQgPSBoZWlnaHQ7XHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBUaGUgcGl4ZWwgcmF0aW9cclxuXHRcdCAqXHJcblx0XHQgKiBAdHlwZSB7TnVtYmVyfVxyXG5cdFx0ICogQGRlZmF1bHQgMVxyXG5cdFx0ICovXHJcblx0XHR0aGlzLnBpeGVsUmF0aW8gPSAxO1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogVGhlIHJlbmRlciB0YXJnZXRcclxuXHRcdCAqXHJcblx0XHQgKiBAdHlwZSB7UmVuZGVyVGFyZ2V0fVxyXG5cdFx0ICovXHJcblx0XHR0aGlzLnJlbmRlclRhcmdldCA9IHJlbmRlclRhcmdldDtcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIFdoZXRoZXIgdGhlIHRleHR1cmUgcmVxdWlyZXMgYW4gdXBkYXRlIG9yIG5vdC5cclxuXHRcdCAqXHJcblx0XHQgKiBAdHlwZSB7Qm9vbGVhbn1cclxuXHRcdCAqIEBkZWZhdWx0IHRydWVcclxuXHRcdCAqL1xyXG5cdFx0dGhpcy50ZXh0dXJlTmVlZHNVcGRhdGUgPSB0cnVlO1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogV2hldGhlciB0aGUgdGV4dHVyZSBzaG91bGQgYXV0b21hdGljYWxseSBiZSB1cGRhdGVkIG9yIG5vdC5cclxuXHRcdCAqXHJcblx0XHQgKiBAdHlwZSB7Qm9vbGVhbn1cclxuXHRcdCAqIEBkZWZhdWx0IHRydWVcclxuXHRcdCAqL1xyXG5cdFx0dGhpcy5hdXRvVXBkYXRlID0gdHJ1ZTtcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIFRoZSBub2RlIHdoaWNoIGlzIHVzZWQgd2l0aCB0aGUgcXVhZCBtZXNoIGZvciBSVFQuXHJcblx0XHQgKlxyXG5cdFx0ICogQHByaXZhdGVcclxuXHRcdCAqIEB0eXBlIHtOb2RlfVxyXG5cdFx0ICogQGRlZmF1bHQgbnVsbFxyXG5cdFx0ICovXHJcblx0XHR0aGlzLl9ydHROb2RlID0gbnVsbDtcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIFRoZSBpbnRlcm5hbCBxdWFkIG1lc2ggZm9yIFJUVC5cclxuXHRcdCAqXHJcblx0XHQgKiBAcHJpdmF0ZVxyXG5cdFx0ICogQHR5cGUge1F1YWRNZXNofVxyXG5cdFx0ICovXHJcblx0XHR0aGlzLl9xdWFkTWVzaCA9IG5ldyBRdWFkTWVzaCggbmV3IE5vZGVNYXRlcmlhbCgpICk7XHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBUaGUgYHVwZGF0ZUJlZm9yZVR5cGVgIGlzIHNldCB0byBgTm9kZVVwZGF0ZVR5cGUuUkVOREVSYCBzaW5jZSB0aGUgbm9kZSB1cGRhdGVzXHJcblx0XHQgKiB0aGUgdGV4dHVyZSBvbmNlIHBlciByZW5kZXIgaW4gaXRzIHtAbGluayBSVFROb2RlI3VwZGF0ZUJlZm9yZX0gbWV0aG9kLlxyXG5cdFx0ICpcclxuXHRcdCAqIEB0eXBlIHtTdHJpbmd9XHJcblx0XHQgKiBAZGVmYXVsdCAncmVuZGVyJ1xyXG5cdFx0ICovXHJcblx0XHR0aGlzLnVwZGF0ZUJlZm9yZVR5cGUgPSBOb2RlVXBkYXRlVHlwZS5SRU5ERVI7XHJcblxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogV2hldGhlciB0aGUgaW50ZXJuYWwgcmVuZGVyIHRhcmdldCBzaG91bGQgYXV0b21hdGljYWxseSBiZSByZXNpemVkIG9yIG5vdC5cclxuXHQgKlxyXG5cdCAqIEB0eXBlIHtCb29sZWFufVxyXG5cdCAqIEByZWFkb25seVxyXG5cdCAqIEBkZWZhdWx0IHRydWVcclxuXHQgKi9cclxuXHRnZXQgYXV0b1NpemUoKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMud2lkdGggPT09IG51bGw7XHJcblxyXG5cdH1cclxuXHJcblx0c2V0dXAoIGJ1aWxkZXIgKSB7XHJcblxyXG5cdFx0dGhpcy5fcnR0Tm9kZSA9IHRoaXMubm9kZS5jb250ZXh0KCBidWlsZGVyLmdldFNoYXJlZENvbnRleHQoKSApO1xyXG5cdFx0dGhpcy5fcXVhZE1lc2gubWF0ZXJpYWwubmFtZSA9ICdSVFQnO1xyXG5cdFx0dGhpcy5fcXVhZE1lc2gubWF0ZXJpYWwubmVlZHNVcGRhdGUgPSB0cnVlO1xyXG5cclxuXHRcdHJldHVybiBzdXBlci5zZXR1cCggYnVpbGRlciApO1xyXG5cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFNldHMgdGhlIHNpemUgb2YgdGhlIGludGVybmFsIHJlbmRlciB0YXJnZXRcclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aCAtIFRoZSB3aWR0aCB0byBzZXQuXHJcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGhlaWdodCAtIFRoZSB3aWR0aCB0byBzZXQuXHJcblx0ICovXHJcblx0c2V0U2l6ZSggd2lkdGgsIGhlaWdodCApIHtcclxuXHJcblx0XHR0aGlzLndpZHRoID0gd2lkdGg7XHJcblx0XHR0aGlzLmhlaWdodCA9IGhlaWdodDtcclxuXHJcblx0XHRjb25zdCBlZmZlY3RpdmVXaWR0aCA9IHdpZHRoICogdGhpcy5waXhlbFJhdGlvO1xyXG5cdFx0Y29uc3QgZWZmZWN0aXZlSGVpZ2h0ID0gaGVpZ2h0ICogdGhpcy5waXhlbFJhdGlvO1xyXG5cclxuXHRcdHRoaXMucmVuZGVyVGFyZ2V0LnNldFNpemUoIGVmZmVjdGl2ZVdpZHRoLCBlZmZlY3RpdmVIZWlnaHQgKTtcclxuXHJcblx0XHR0aGlzLnRleHR1cmVOZWVkc1VwZGF0ZSA9IHRydWU7XHJcblxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogU2V0cyB0aGUgcGl4ZWwgcmF0aW8uIFRoaXMgd2lsbCBhbHNvIHJlc2l6ZSB0aGUgcmVuZGVyIHRhcmdldC5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBwaXhlbFJhdGlvIC0gVGhlIHBpeGVsIHJhdGlvIHRvIHNldC5cclxuXHQgKi9cclxuXHRzZXRQaXhlbFJhdGlvKCBwaXhlbFJhdGlvICkge1xyXG5cclxuXHRcdHRoaXMucGl4ZWxSYXRpbyA9IHBpeGVsUmF0aW87XHJcblxyXG5cdFx0dGhpcy5zZXRTaXplKCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCApO1xyXG5cclxuXHR9XHJcblxyXG5cdHVwZGF0ZUJlZm9yZSggeyByZW5kZXJlciB9ICkge1xyXG5cclxuXHRcdGlmICggdGhpcy50ZXh0dXJlTmVlZHNVcGRhdGUgPT09IGZhbHNlICYmIHRoaXMuYXV0b1VwZGF0ZSA9PT0gZmFsc2UgKSByZXR1cm47XHJcblxyXG5cdFx0dGhpcy50ZXh0dXJlTmVlZHNVcGRhdGUgPSBmYWxzZTtcclxuXHJcblx0XHQvL1xyXG5cclxuXHRcdGlmICggdGhpcy5hdXRvU2l6ZSA9PT0gdHJ1ZSApIHtcclxuXHJcblx0XHRcdHRoaXMucGl4ZWxSYXRpbyA9IHJlbmRlcmVyLmdldFBpeGVsUmF0aW8oKTtcclxuXHJcblx0XHRcdGNvbnN0IHNpemUgPSByZW5kZXJlci5nZXRTaXplKCBfc2l6ZSApO1xyXG5cclxuXHRcdFx0dGhpcy5zZXRTaXplKCBzaXplLndpZHRoLCBzaXplLmhlaWdodCApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvL1xyXG5cclxuXHRcdHRoaXMuX3F1YWRNZXNoLm1hdGVyaWFsLmZyYWdtZW50Tm9kZSA9IHRoaXMuX3J0dE5vZGU7XHJcblxyXG5cdFx0Ly9cclxuXHJcblx0XHRjb25zdCBjdXJyZW50UmVuZGVyVGFyZ2V0ID0gcmVuZGVyZXIuZ2V0UmVuZGVyVGFyZ2V0KCk7XHJcblxyXG5cdFx0cmVuZGVyZXIuc2V0UmVuZGVyVGFyZ2V0KCB0aGlzLnJlbmRlclRhcmdldCApO1xyXG5cclxuXHRcdHRoaXMuX3F1YWRNZXNoLnJlbmRlciggcmVuZGVyZXIgKTtcclxuXHJcblx0XHRyZW5kZXJlci5zZXRSZW5kZXJUYXJnZXQoIGN1cnJlbnRSZW5kZXJUYXJnZXQgKTtcclxuXHJcblx0fVxyXG5cclxuXHRjbG9uZSgpIHtcclxuXHJcblx0XHRjb25zdCBuZXdOb2RlID0gbmV3IFRleHR1cmVOb2RlKCB0aGlzLnZhbHVlLCB0aGlzLnV2Tm9kZSwgdGhpcy5sZXZlbE5vZGUgKTtcclxuXHRcdG5ld05vZGUuc2FtcGxlciA9IHRoaXMuc2FtcGxlcjtcclxuXHRcdG5ld05vZGUucmVmZXJlbmNlTm9kZSA9IHRoaXM7XHJcblxyXG5cdFx0cmV0dXJuIG5ld05vZGU7XHJcblxyXG5cdH1cclxuXHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IFJUVE5vZGU7XHJcblxyXG4vKipcclxuICogVFNMIGZ1bmN0aW9uIGZvciBjcmVhdGluZyBhIFJUVCBub2RlLlxyXG4gKlxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHtOb2RlfSBub2RlIC0gVGhlIG5vZGUgdG8gcmVuZGVyIGEgdGV4dHVyZSB3aXRoLlxyXG4gKiBAcGFyYW0ge051bWJlcj99IFt3aWR0aD1udWxsXSAtIFRoZSB3aWR0aCBvZiB0aGUgaW50ZXJuYWwgcmVuZGVyIHRhcmdldC4gSWYgbm90IHdpZHRoIGlzIGFwcGxpZWQsIHRoZSByZW5kZXIgdGFyZ2V0IGlzIGF1dG9tYXRpY2FsbHkgcmVzaXplZC5cclxuICogQHBhcmFtIHtOdW1iZXI/fSBbaGVpZ2h0PW51bGxdIC0gVGhlIGhlaWdodCBvZiB0aGUgaW50ZXJuYWwgcmVuZGVyIHRhcmdldC5cclxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPXt0eXBlOkhhbGZGbG9hdFR5cGV9XSAtIFRoZSBvcHRpb25zIGZvciB0aGUgaW50ZXJuYWwgcmVuZGVyIHRhcmdldC5cclxuICogQHJldHVybnMge1JUVE5vZGV9XHJcbiAqL1xyXG5leHBvcnQgY29uc3QgcnR0ID0gKCBub2RlLCAuLi5wYXJhbXMgKSA9PiBub2RlT2JqZWN0KCBuZXcgUlRUTm9kZSggbm9kZU9iamVjdCggbm9kZSApLCAuLi5wYXJhbXMgKSApO1xyXG5cclxuLyoqXHJcbiAqIFRTTCBmdW5jdGlvbiBmb3IgY29udmVydGluZyBub2RlcyB0byB0ZXh0dXJlcyBub2Rlcy5cclxuICpcclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7Tm9kZX0gbm9kZSAtIFRoZSBub2RlIHRvIHJlbmRlciBhIHRleHR1cmUgd2l0aC5cclxuICogQHBhcmFtIHtOdW1iZXI/fSBbd2lkdGg9bnVsbF0gLSBUaGUgd2lkdGggb2YgdGhlIGludGVybmFsIHJlbmRlciB0YXJnZXQuIElmIG5vdCB3aWR0aCBpcyBhcHBsaWVkLCB0aGUgcmVuZGVyIHRhcmdldCBpcyBhdXRvbWF0aWNhbGx5IHJlc2l6ZWQuXHJcbiAqIEBwYXJhbSB7TnVtYmVyP30gW2hlaWdodD1udWxsXSAtIFRoZSBoZWlnaHQgb2YgdGhlIGludGVybmFsIHJlbmRlciB0YXJnZXQuXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17dHlwZTpIYWxmRmxvYXRUeXBlfV0gLSBUaGUgb3B0aW9ucyBmb3IgdGhlIGludGVybmFsIHJlbmRlciB0YXJnZXQuXHJcbiAqIEByZXR1cm5zIHtSVFROb2RlfVxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IGNvbnZlcnRUb1RleHR1cmUgPSAoIG5vZGUsIC4uLnBhcmFtcyApID0+IHtcclxuXHJcblx0aWYgKCBub2RlLmlzVGV4dHVyZU5vZGUgKSByZXR1cm4gbm9kZTtcclxuXHRpZiAoIG5vZGUuaXNQYXNzTm9kZSApIHJldHVybiBub2RlLmdldFRleHR1cmVOb2RlKCk7XHJcblxyXG5cdHJldHVybiBydHQoIG5vZGUsIC4uLnBhcmFtcyApO1xyXG5cclxufTtcclxuIiwiaW1wb3J0IHsgYWJzLCBjcm9zcywgZmxvYXQsIEZuLCBub3JtYWxpemUsIGl2ZWMyLCBzdWIsIHZlYzIsIHZlYzMsIHZlYzQgfSBmcm9tICcuLi90c2wvVFNMQmFzZS5qcyc7XHJcbmltcG9ydCB7IHRleHR1cmVTaXplIH0gZnJvbSAnLi4vYWNjZXNzb3JzL1RleHR1cmVTaXplTm9kZS5qcyc7XHJcbmltcG9ydCB7IHRleHR1cmVMb2FkIH0gZnJvbSAnLi4vYWNjZXNzb3JzL1RleHR1cmVOb2RlLmpzJztcclxuaW1wb3J0IHsgV2ViR1BVQ29vcmRpbmF0ZVN5c3RlbSB9IGZyb20gJy4uLy4uL2NvbnN0YW50cy5qcyc7XHJcblxyXG4vKiogQG1vZHVsZSBQb3N0UHJvY2Vzc2luZ1V0aWxzICoqL1xyXG5cclxuLyoqXHJcbiAqIENvbXB1dGVzIGEgcG9zaXRpb24gaW4gdmlldyBzcGFjZSBiYXNlZCBvbiBhIGZyYWdtZW50J3Mgc2NyZWVuIHBvc2l0aW9uIGV4cHJlc3NlZCBhcyB1diBjb29yZGluYXRlcywgdGhlIGZyYWdtZW50c1xyXG4gKiBkZXB0aCB2YWx1ZSBhbmQgdGhlIGNhbWVyYSdzIGludmVyc2UgcHJvamVjdGlvbiBtYXRyaXguXHJcbiAqXHJcbiAqIEBtZXRob2RcclxuICogQHBhcmFtIHtOb2RlPHZlYzI+fSBzY3JlZW5Qb3NpdGlvbiAtIFRoZSBmcmFnbWVudCdzIHNjcmVlbiBwb3NpdGlvbiBleHByZXNzZWQgYXMgdXYgY29vcmRpbmF0ZXMuXHJcbiAqIEBwYXJhbSB7Tm9kZTxmbG9hdD59IGRlcHRoIC0gVGhlIGZyYWdtZW50J3MgZGVwdGggdmFsdWUuXHJcbiAqIEBwYXJhbSB7Tm9kZTxtYXQ0Pn0gcHJvamVjdGlvbk1hdHJpeEludmVyc2UgLSBUaGUgY2FtZXJhJ3MgaW52ZXJzZSBwcm9qZWN0aW9uIG1hdHJpeC5cclxuICogQHJldHVybiB7Tm9kZTx2ZWMzPn0gVGhlIGZyYWdtZW50cyBwb3NpdGlvbiBpbiB2aWV3IHNwYWNlLlxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IGdldFZpZXdQb3NpdGlvbiA9IC8qQF9fUFVSRV9fKi8gRm4oICggWyBzY3JlZW5Qb3NpdGlvbiwgZGVwdGgsIHByb2plY3Rpb25NYXRyaXhJbnZlcnNlIF0sIGJ1aWxkZXIgKSA9PiB7XHJcblxyXG5cdGxldCBjbGlwU3BhY2VQb3NpdGlvbjtcclxuXHJcblx0aWYgKCBidWlsZGVyLnJlbmRlcmVyLmNvb3JkaW5hdGVTeXN0ZW0gPT09IFdlYkdQVUNvb3JkaW5hdGVTeXN0ZW0gKSB7XHJcblxyXG5cdFx0c2NyZWVuUG9zaXRpb24gPSB2ZWMyKCBzY3JlZW5Qb3NpdGlvbi54LCBzY3JlZW5Qb3NpdGlvbi55Lm9uZU1pbnVzKCkgKS5tdWwoIDIuMCApLnN1YiggMS4wICk7XHJcblx0XHRjbGlwU3BhY2VQb3NpdGlvbiA9IHZlYzQoIHZlYzMoIHNjcmVlblBvc2l0aW9uLCBkZXB0aCApLCAxLjAgKTtcclxuXHJcblx0fSBlbHNlIHtcclxuXHJcblx0XHRjbGlwU3BhY2VQb3NpdGlvbiA9IHZlYzQoIHZlYzMoIHNjcmVlblBvc2l0aW9uLngsIHNjcmVlblBvc2l0aW9uLnkub25lTWludXMoKSwgZGVwdGggKS5tdWwoIDIuMCApLnN1YiggMS4wICksIDEuMCApO1xyXG5cclxuXHR9XHJcblxyXG5cdGNvbnN0IHZpZXdTcGFjZVBvc2l0aW9uID0gdmVjNCggcHJvamVjdGlvbk1hdHJpeEludmVyc2UubXVsKCBjbGlwU3BhY2VQb3NpdGlvbiApICk7XHJcblxyXG5cdHJldHVybiB2aWV3U3BhY2VQb3NpdGlvbi54eXouZGl2KCB2aWV3U3BhY2VQb3NpdGlvbi53ICk7XHJcblxyXG59ICk7XHJcblxyXG4vKipcclxuICogQ29tcHV0ZXMgYSBzY3JlZW4gcG9zaXRpb24gZXhwcmVzc2VkIGFzIHV2IGNvb3JkaW5hdGVzIGJhc2VkIG9uIGEgZnJhZ21lbnQncyBwb3NpdGlvbiBpbiB2aWV3IHNwYWNlXHJcbiAqIGFuZCB0aGUgY2FtZXJhJ3MgcHJvamVjdGlvbiBtYXRyaXhcclxuICpcclxuICogQG1ldGhvZFxyXG4gKiBAcGFyYW0ge05vZGU8dmVjMz59IHZpZXdQb3NpdGlvbiAtIFRoZSBmcmFnbWVudHMgcG9zaXRpb24gaW4gdmlldyBzcGFjZS5cclxuICogQHBhcmFtIHtOb2RlPG1hdDQ+fSBwcm9qZWN0aW9uTWF0cml4IC0gVGhlIGNhbWVyYSdzIHByb2plY3Rpb24gbWF0cml4LlxyXG4gKiBAcmV0dXJuIHtOb2RlPHZlYzI+fSBUaGUgZnJhZ21lbnQncyBzY3JlZW4gcG9zaXRpb24gZXhwcmVzc2VkIGFzIHV2IGNvb3JkaW5hdGVzLlxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IGdldFNjcmVlblBvc2l0aW9uID0gLypAX19QVVJFX18qLyBGbiggKCBbIHZpZXdQb3NpdGlvbiwgcHJvamVjdGlvbk1hdHJpeCBdICkgPT4ge1xyXG5cclxuXHRjb25zdCBzYW1wbGVDbGlwUG9zID0gcHJvamVjdGlvbk1hdHJpeC5tdWwoIHZlYzQoIHZpZXdQb3NpdGlvbiwgMS4wICkgKTtcclxuXHRjb25zdCBzYW1wbGVVdiA9IHNhbXBsZUNsaXBQb3MueHkuZGl2KCBzYW1wbGVDbGlwUG9zLncgKS5tdWwoIDAuNSApLmFkZCggMC41ICkudG9WYXIoKTtcclxuXHRyZXR1cm4gdmVjMiggc2FtcGxlVXYueCwgc2FtcGxlVXYueS5vbmVNaW51cygpICk7XHJcblxyXG59ICk7XHJcblxyXG4vKipcclxuICogQ29tcHV0ZXMgYSBub3JtYWwgdmVjdG9yIGJhc2VkIG9uIGRlcHRoIGRhdGEuIENhbiBiZSB1c2VkIGFzIGEgZmFsbGJhY2sgd2hlbiBubyBub3JtYWwgcmVuZGVyXHJcbiAqIHRhcmdldCBpcyBhdmFpbGFibGUgb3IgaWYgZmxhdCBzdXJmYWNlIG5vcm1hbHMgYXJlIHJlcXVpcmVkLlxyXG4gKlxyXG4gKiBAbWV0aG9kXHJcbiAqIEBwYXJhbSB7Tm9kZTx2ZWMyPn0gdXYgLSBUaGUgdGV4dHVyZSBjb29yZGluYXRlLlxyXG4gKiBAcGFyYW0ge0RlcHRoVGV4dHVyZX0gZGVwdGhUZXh0dXJlIC0gVGhlIGRlcHRoIHRleHR1cmUuXHJcbiAqIEBwYXJhbSB7Tm9kZTxtYXQ0Pn0gcHJvamVjdGlvbk1hdHJpeEludmVyc2UgLSBUaGUgY2FtZXJhJ3MgaW52ZXJzZSBwcm9qZWN0aW9uIG1hdHJpeC5cclxuICogQHJldHVybiB7Tm9kZTx2ZWMzPn0gVGhlIGNvbXB1dGVkIG5vcm1hbCB2ZWN0b3IuXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgZ2V0Tm9ybWFsRnJvbURlcHRoID0gLypAX19QVVJFX18qLyBGbiggKCBbIHV2LCBkZXB0aFRleHR1cmUsIHByb2plY3Rpb25NYXRyaXhJbnZlcnNlIF0gKSA9PiB7XHJcblxyXG5cdGNvbnN0IHNpemUgPSB0ZXh0dXJlU2l6ZSggdGV4dHVyZUxvYWQoIGRlcHRoVGV4dHVyZSApICk7XHJcblx0Y29uc3QgcCA9IGl2ZWMyKCB1di5tdWwoIHNpemUgKSApLnRvVmFyKCk7XHJcblxyXG5cdGNvbnN0IGMwID0gdGV4dHVyZUxvYWQoIGRlcHRoVGV4dHVyZSwgcCApLnRvVmFyKCk7XHJcblxyXG5cdGNvbnN0IGwyID0gdGV4dHVyZUxvYWQoIGRlcHRoVGV4dHVyZSwgcC5zdWIoIGl2ZWMyKCAyLCAwICkgKSApLnRvVmFyKCk7XHJcblx0Y29uc3QgbDEgPSB0ZXh0dXJlTG9hZCggZGVwdGhUZXh0dXJlLCBwLnN1YiggaXZlYzIoIDEsIDAgKSApICkudG9WYXIoKTtcclxuXHRjb25zdCByMSA9IHRleHR1cmVMb2FkKCBkZXB0aFRleHR1cmUsIHAuYWRkKCBpdmVjMiggMSwgMCApICkgKS50b1ZhcigpO1xyXG5cdGNvbnN0IHIyID0gdGV4dHVyZUxvYWQoIGRlcHRoVGV4dHVyZSwgcC5hZGQoIGl2ZWMyKCAyLCAwICkgKSApLnRvVmFyKCk7XHJcblx0Y29uc3QgYjIgPSB0ZXh0dXJlTG9hZCggZGVwdGhUZXh0dXJlLCBwLmFkZCggaXZlYzIoIDAsIDIgKSApICkudG9WYXIoKTtcclxuXHRjb25zdCBiMSA9IHRleHR1cmVMb2FkKCBkZXB0aFRleHR1cmUsIHAuYWRkKCBpdmVjMiggMCwgMSApICkgKS50b1ZhcigpO1xyXG5cdGNvbnN0IHQxID0gdGV4dHVyZUxvYWQoIGRlcHRoVGV4dHVyZSwgcC5zdWIoIGl2ZWMyKCAwLCAxICkgKSApLnRvVmFyKCk7XHJcblx0Y29uc3QgdDIgPSB0ZXh0dXJlTG9hZCggZGVwdGhUZXh0dXJlLCBwLnN1YiggaXZlYzIoIDAsIDIgKSApICkudG9WYXIoKTtcclxuXHJcblx0Y29uc3QgZGwgPSBhYnMoIHN1YiggZmxvYXQoIDIgKS5tdWwoIGwxICkuc3ViKCBsMiApLCBjMCApICkudG9WYXIoKTtcclxuXHRjb25zdCBkciA9IGFicyggc3ViKCBmbG9hdCggMiApLm11bCggcjEgKS5zdWIoIHIyICksIGMwICkgKS50b1ZhcigpO1xyXG5cdGNvbnN0IGRiID0gYWJzKCBzdWIoIGZsb2F0KCAyICkubXVsKCBiMSApLnN1YiggYjIgKSwgYzAgKSApLnRvVmFyKCk7XHJcblx0Y29uc3QgZHQgPSBhYnMoIHN1YiggZmxvYXQoIDIgKS5tdWwoIHQxICkuc3ViKCB0MiApLCBjMCApICkudG9WYXIoKTtcclxuXHJcblx0Y29uc3QgY2UgPSBnZXRWaWV3UG9zaXRpb24oIHV2LCBjMCwgcHJvamVjdGlvbk1hdHJpeEludmVyc2UgKS50b1ZhcigpO1xyXG5cclxuXHRjb25zdCBkcGR4ID0gZGwubGVzc1RoYW4oIGRyICkuc2VsZWN0KCBjZS5zdWIoIGdldFZpZXdQb3NpdGlvbiggdXYuc3ViKCB2ZWMyKCBmbG9hdCggMSApLmRpdiggc2l6ZS54ICksIDAgKSApLCBsMSwgcHJvamVjdGlvbk1hdHJpeEludmVyc2UgKSApLCBjZS5uZWdhdGUoKS5hZGQoIGdldFZpZXdQb3NpdGlvbiggdXYuYWRkKCB2ZWMyKCBmbG9hdCggMSApLmRpdiggc2l6ZS54ICksIDAgKSApLCByMSwgcHJvamVjdGlvbk1hdHJpeEludmVyc2UgKSApICk7XHJcblx0Y29uc3QgZHBkeSA9IGRiLmxlc3NUaGFuKCBkdCApLnNlbGVjdCggY2Uuc3ViKCBnZXRWaWV3UG9zaXRpb24oIHV2LmFkZCggdmVjMiggMCwgZmxvYXQoIDEgKS5kaXYoIHNpemUueSApICkgKSwgYjEsIHByb2plY3Rpb25NYXRyaXhJbnZlcnNlICkgKSwgY2UubmVnYXRlKCkuYWRkKCBnZXRWaWV3UG9zaXRpb24oIHV2LnN1YiggdmVjMiggMCwgZmxvYXQoIDEgKS5kaXYoIHNpemUueSApICkgKSwgdDEsIHByb2plY3Rpb25NYXRyaXhJbnZlcnNlICkgKSApO1xyXG5cclxuXHRyZXR1cm4gbm9ybWFsaXplKCBjcm9zcyggZHBkeCwgZHBkeSApICk7XHJcblxyXG59ICk7XHJcbiIsImltcG9ydCB7IEluc3RhbmNlZEJ1ZmZlckF0dHJpYnV0ZSB9IGZyb20gJy4uLy4uL2NvcmUvSW5zdGFuY2VkQnVmZmVyQXR0cmlidXRlLmpzJztcclxuXHJcbmNsYXNzIFN0b3JhZ2VJbnN0YW5jZWRCdWZmZXJBdHRyaWJ1dGUgZXh0ZW5kcyBJbnN0YW5jZWRCdWZmZXJBdHRyaWJ1dGUge1xyXG5cclxuXHRjb25zdHJ1Y3RvciggYXJyYXksIGl0ZW1TaXplLCB0eXBlQ2xhc3MgPSBGbG9hdDMyQXJyYXkgKSB7XHJcblxyXG5cdFx0aWYgKCBBcnJheUJ1ZmZlci5pc1ZpZXcoIGFycmF5ICkgPT09IGZhbHNlICkgYXJyYXkgPSBuZXcgdHlwZUNsYXNzKCBhcnJheSAqIGl0ZW1TaXplICk7XHJcblxyXG5cdFx0c3VwZXIoIGFycmF5LCBpdGVtU2l6ZSApO1xyXG5cclxuXHRcdHRoaXMuaXNTdG9yYWdlSW5zdGFuY2VkQnVmZmVyQXR0cmlidXRlID0gdHJ1ZTtcclxuXHJcblx0fVxyXG5cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgU3RvcmFnZUluc3RhbmNlZEJ1ZmZlckF0dHJpYnV0ZTtcclxuIiwiaW1wb3J0IHsgQnVmZmVyQXR0cmlidXRlIH0gZnJvbSAnLi4vLi4vY29yZS9CdWZmZXJBdHRyaWJ1dGUuanMnO1xyXG5cclxuY2xhc3MgU3RvcmFnZUJ1ZmZlckF0dHJpYnV0ZSBleHRlbmRzIEJ1ZmZlckF0dHJpYnV0ZSB7XHJcblxyXG5cdGNvbnN0cnVjdG9yKCBhcnJheSwgaXRlbVNpemUsIHR5cGVDbGFzcyA9IEZsb2F0MzJBcnJheSApIHtcclxuXHJcblx0XHRpZiAoIEFycmF5QnVmZmVyLmlzVmlldyggYXJyYXkgKSA9PT0gZmFsc2UgKSBhcnJheSA9IG5ldyB0eXBlQ2xhc3MoIGFycmF5ICogaXRlbVNpemUgKTtcclxuXHJcblx0XHRzdXBlciggYXJyYXksIGl0ZW1TaXplICk7XHJcblxyXG5cdFx0dGhpcy5pc1N0b3JhZ2VCdWZmZXJBdHRyaWJ1dGUgPSB0cnVlO1xyXG5cclxuXHR9XHJcblxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBTdG9yYWdlQnVmZmVyQXR0cmlidXRlO1xyXG4iLCJpbXBvcnQgeyBub2RlUHJveHkgfSBmcm9tICcuLi90c2wvVFNMQmFzZS5qcyc7XHJcbmltcG9ydCBBcnJheUVsZW1lbnROb2RlIGZyb20gJy4vQXJyYXlFbGVtZW50Tm9kZS5qcyc7XHJcblxyXG4vKiogQG1vZHVsZSBTdG9yYWdlQXJyYXlFbGVtZW50Tm9kZSAqKi9cclxuXHJcbi8qKlxyXG4gKiBUaGlzIGNsYXNzIGVuYWJsZXMgZWxlbWVudCBhY2Nlc3Mgb24gaW5zdGFuY2VzIG9mIHtAbGluayBTdG9yYWdlQnVmZmVyTm9kZX0uXHJcbiAqIEluIG1vc3QgY2FzZXMsIGl0IGlzIGluZGlyZWN0bHkgdXNlZCB3aGVuIGFjY2Vzc2luZyBlbGVtZW50cyB3aXRoIHRoZVxyXG4gKiB7QGxpbmsgU3RvcmFnZUJ1ZmZlck5vZGUjZWxlbWVudH0gbWV0aG9kLlxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiBjb25zdCBwb3NpdGlvbiA9IHBvc2l0aW9uU3RvcmFnZS5lbGVtZW50KCBpbnN0YW5jZUluZGV4ICk7XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBAYXVnbWVudHMgQXJyYXlFbGVtZW50Tm9kZVxyXG4gKi9cclxuY2xhc3MgU3RvcmFnZUFycmF5RWxlbWVudE5vZGUgZXh0ZW5kcyBBcnJheUVsZW1lbnROb2RlIHtcclxuXHJcblx0c3RhdGljIGdldCB0eXBlKCkge1xyXG5cclxuXHRcdHJldHVybiAnU3RvcmFnZUFycmF5RWxlbWVudE5vZGUnO1xyXG5cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIENvbnN0cnVjdHMgc3RvcmFnZSBidWZmZXIgZWxlbWVudCBub2RlLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtTdG9yYWdlQnVmZmVyTm9kZX0gc3RvcmFnZUJ1ZmZlck5vZGUgLSBUaGUgc3RvcmFnZSBidWZmZXIgbm9kZS5cclxuXHQgKiBAcGFyYW0ge05vZGV9IGluZGV4Tm9kZSAtIFRoZSBpbmRleCBub2RlIHRoYXQgZGVmaW5lcyB0aGUgZWxlbWVudCBhY2Nlc3MuXHJcblx0ICovXHJcblx0Y29uc3RydWN0b3IoIHN0b3JhZ2VCdWZmZXJOb2RlLCBpbmRleE5vZGUgKSB7XHJcblxyXG5cdFx0c3VwZXIoIHN0b3JhZ2VCdWZmZXJOb2RlLCBpbmRleE5vZGUgKTtcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIFRoaXMgZmxhZyBjYW4gYmUgdXNlZCBmb3IgdHlwZSB0ZXN0aW5nLlxyXG5cdFx0ICpcclxuXHRcdCAqIEB0eXBlIHtCb29sZWFufVxyXG5cdFx0ICogQHJlYWRvbmx5XHJcblx0XHQgKiBAZGVmYXVsdCB0cnVlXHJcblx0XHQgKi9cclxuXHRcdHRoaXMuaXNTdG9yYWdlQXJyYXlFbGVtZW50Tm9kZSA9IHRydWU7XHJcblxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogVGhlIHN0b3JhZ2UgYnVmZmVyIG5vZGUuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge05vZGV9IHZhbHVlXHJcblx0ICogQHR5cGUge1N0b3JhZ2VCdWZmZXJOb2RlfVxyXG5cdCAqL1xyXG5cdHNldCBzdG9yYWdlQnVmZmVyTm9kZSggdmFsdWUgKSB7XHJcblxyXG5cdFx0dGhpcy5ub2RlID0gdmFsdWU7XHJcblxyXG5cdH1cclxuXHJcblx0Z2V0IHN0b3JhZ2VCdWZmZXJOb2RlKCkge1xyXG5cclxuXHRcdHJldHVybiB0aGlzLm5vZGU7XHJcblxyXG5cdH1cclxuXHJcblx0c2V0dXAoIGJ1aWxkZXIgKSB7XHJcblxyXG5cdFx0aWYgKCBidWlsZGVyLmlzQXZhaWxhYmxlKCAnc3RvcmFnZUJ1ZmZlcicgKSA9PT0gZmFsc2UgKSB7XHJcblxyXG5cdFx0XHRpZiAoIHRoaXMubm9kZS5pc1BCTyA9PT0gdHJ1ZSApIHtcclxuXHJcblx0XHRcdFx0YnVpbGRlci5zZXR1cFBCTyggdGhpcy5ub2RlICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBzdXBlci5zZXR1cCggYnVpbGRlciApO1xyXG5cclxuXHR9XHJcblxyXG5cdGdlbmVyYXRlKCBidWlsZGVyLCBvdXRwdXQgKSB7XHJcblxyXG5cdFx0bGV0IHNuaXBwZXQ7XHJcblxyXG5cdFx0Y29uc3QgaXNBc3NpZ25Db250ZXh0ID0gYnVpbGRlci5jb250ZXh0LmFzc2lnbjtcclxuXHJcblx0XHQvL1xyXG5cclxuXHRcdGlmICggYnVpbGRlci5pc0F2YWlsYWJsZSggJ3N0b3JhZ2VCdWZmZXInICkgPT09IGZhbHNlICkge1xyXG5cclxuXHRcdFx0aWYgKCB0aGlzLm5vZGUuaXNQQk8gPT09IHRydWUgJiYgaXNBc3NpZ25Db250ZXh0ICE9PSB0cnVlICYmICggdGhpcy5ub2RlLnZhbHVlLmlzSW5zdGFuY2VkQnVmZmVyQXR0cmlidXRlIHx8IGJ1aWxkZXIuc2hhZGVyU3RhZ2UgIT09ICdjb21wdXRlJyApICkge1xyXG5cclxuXHRcdFx0XHRzbmlwcGV0ID0gYnVpbGRlci5nZW5lcmF0ZVBCTyggdGhpcyApO1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0c25pcHBldCA9IHRoaXMubm9kZS5idWlsZCggYnVpbGRlciApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRzbmlwcGV0ID0gc3VwZXIuZ2VuZXJhdGUoIGJ1aWxkZXIgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBpc0Fzc2lnbkNvbnRleHQgIT09IHRydWUgKSB7XHJcblxyXG5cdFx0XHRjb25zdCB0eXBlID0gdGhpcy5nZXROb2RlVHlwZSggYnVpbGRlciApO1xyXG5cclxuXHRcdFx0c25pcHBldCA9IGJ1aWxkZXIuZm9ybWF0KCBzbmlwcGV0LCB0eXBlLCBvdXRwdXQgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHNuaXBwZXQ7XHJcblxyXG5cdH1cclxuXHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IFN0b3JhZ2VBcnJheUVsZW1lbnROb2RlO1xyXG5cclxuLyoqXHJcbiAqIFRTTCBmdW5jdGlvbiBmb3IgY3JlYXRpbmcgYSBzdG9yYWdlIGVsZW1lbnQgbm9kZS5cclxuICpcclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7U3RvcmFnZUJ1ZmZlck5vZGV9IHN0b3JhZ2VCdWZmZXJOb2RlIC0gVGhlIHN0b3JhZ2UgYnVmZmVyIG5vZGUuXHJcbiAqIEBwYXJhbSB7Tm9kZX0gaW5kZXhOb2RlIC0gVGhlIGluZGV4IG5vZGUgdGhhdCBkZWZpbmVzIHRoZSBlbGVtZW50IGFjY2Vzcy5cclxuICogQHJldHVybnMge1N0b3JhZ2VBcnJheUVsZW1lbnROb2RlfVxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IHN0b3JhZ2VFbGVtZW50ID0gLypAX19QVVJFX18qLyBub2RlUHJveHkoIFN0b3JhZ2VBcnJheUVsZW1lbnROb2RlICk7XHJcbiIsImltcG9ydCBCdWZmZXJOb2RlIGZyb20gJy4vQnVmZmVyTm9kZS5qcyc7XHJcbmltcG9ydCB7IGJ1ZmZlckF0dHJpYnV0ZSB9IGZyb20gJy4vQnVmZmVyQXR0cmlidXRlTm9kZS5qcyc7XHJcbmltcG9ydCB7IG5vZGVPYmplY3QsIHZhcnlpbmcgfSBmcm9tICcuLi90c2wvVFNMQmFzZS5qcyc7XHJcbmltcG9ydCB7IHN0b3JhZ2VFbGVtZW50IH0gZnJvbSAnLi4vdXRpbHMvU3RvcmFnZUFycmF5RWxlbWVudE5vZGUuanMnO1xyXG5pbXBvcnQgeyBOb2RlQWNjZXNzIH0gZnJvbSAnLi4vY29yZS9jb25zdGFudHMuanMnO1xyXG5pbXBvcnQgeyBnZXRUeXBlRnJvbUxlbmd0aCB9IGZyb20gJy4uL2NvcmUvTm9kZVV0aWxzLmpzJztcclxuXHJcbmNsYXNzIFN0b3JhZ2VCdWZmZXJOb2RlIGV4dGVuZHMgQnVmZmVyTm9kZSB7XHJcblxyXG5cdHN0YXRpYyBnZXQgdHlwZSgpIHtcclxuXHJcblx0XHRyZXR1cm4gJ1N0b3JhZ2VCdWZmZXJOb2RlJztcclxuXHJcblx0fVxyXG5cclxuXHRjb25zdHJ1Y3RvciggdmFsdWUsIGJ1ZmZlclR5cGUgPSBudWxsLCBidWZmZXJDb3VudCA9IDAgKSB7XHJcblxyXG5cdFx0aWYgKCBidWZmZXJUeXBlID09PSBudWxsICYmICggdmFsdWUuaXNTdG9yYWdlQnVmZmVyQXR0cmlidXRlIHx8IHZhbHVlLmlzU3RvcmFnZUluc3RhbmNlZEJ1ZmZlckF0dHJpYnV0ZSApICkge1xyXG5cclxuXHRcdFx0YnVmZmVyVHlwZSA9IGdldFR5cGVGcm9tTGVuZ3RoKCB2YWx1ZS5pdGVtU2l6ZSApO1xyXG5cdFx0XHRidWZmZXJDb3VudCA9IHZhbHVlLmNvdW50O1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRzdXBlciggdmFsdWUsIGJ1ZmZlclR5cGUsIGJ1ZmZlckNvdW50ICk7XHJcblxyXG5cdFx0dGhpcy5pc1N0b3JhZ2VCdWZmZXJOb2RlID0gdHJ1ZTtcclxuXHJcblx0XHR0aGlzLmFjY2VzcyA9IE5vZGVBY2Nlc3MuUkVBRF9XUklURTtcclxuXHRcdHRoaXMuaXNBdG9taWMgPSBmYWxzZTtcclxuXHRcdHRoaXMuaXNQQk8gPSBmYWxzZTtcclxuXHJcblx0XHR0aGlzLmJ1ZmZlckNvdW50ID0gYnVmZmVyQ291bnQ7XHJcblxyXG5cdFx0dGhpcy5fYXR0cmlidXRlID0gbnVsbDtcclxuXHRcdHRoaXMuX3ZhcnlpbmcgPSBudWxsO1xyXG5cclxuXHRcdHRoaXMuZ2xvYmFsID0gdHJ1ZTtcclxuXHJcblx0XHRpZiAoIHZhbHVlLmlzU3RvcmFnZUJ1ZmZlckF0dHJpYnV0ZSAhPT0gdHJ1ZSAmJiB2YWx1ZS5pc1N0b3JhZ2VJbnN0YW5jZWRCdWZmZXJBdHRyaWJ1dGUgIT09IHRydWUgKSB7XHJcblxyXG5cdFx0XHQvLyBUT0RPOiBJbXByb3ZlIGl0LCBwb3NzaWJseSBhZGRpbmcgYSBuZXcgcHJvcGVydHkgdG8gdGhlIEJ1ZmZlckF0dHJpYnV0ZSB0byBpZGVudGlmeSBpdCBhcyBhIHN0b3JhZ2UgYnVmZmVyIHJlYWQtb25seSBhdHRyaWJ1dGUgaW4gUmVuZGVyZXJcclxuXHJcblx0XHRcdGlmICggdmFsdWUuaXNJbnN0YW5jZWRCdWZmZXJBdHRyaWJ1dGUgKSB2YWx1ZS5pc1N0b3JhZ2VJbnN0YW5jZWRCdWZmZXJBdHRyaWJ1dGUgPSB0cnVlO1xyXG5cdFx0XHRlbHNlIHZhbHVlLmlzU3RvcmFnZUJ1ZmZlckF0dHJpYnV0ZSA9IHRydWU7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdGdldEhhc2goIGJ1aWxkZXIgKSB7XHJcblxyXG5cdFx0aWYgKCB0aGlzLmJ1ZmZlckNvdW50ID09PSAwICkge1xyXG5cclxuXHRcdFx0bGV0IGJ1ZmZlckRhdGEgPSBidWlsZGVyLmdsb2JhbENhY2hlLmdldERhdGEoIHRoaXMudmFsdWUgKTtcclxuXHJcblx0XHRcdGlmICggYnVmZmVyRGF0YSA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRidWZmZXJEYXRhID0ge1xyXG5cdFx0XHRcdFx0bm9kZTogdGhpc1xyXG5cdFx0XHRcdH07XHJcblxyXG5cdFx0XHRcdGJ1aWxkZXIuZ2xvYmFsQ2FjaGUuc2V0RGF0YSggdGhpcy52YWx1ZSwgYnVmZmVyRGF0YSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmV0dXJuIGJ1ZmZlckRhdGEubm9kZS51dWlkO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcy51dWlkO1xyXG5cclxuXHR9XHJcblxyXG5cdGdldElucHV0VHlwZSggLypidWlsZGVyKi8gKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMudmFsdWUuaXNJbmRpcmVjdFN0b3JhZ2VCdWZmZXJBdHRyaWJ1dGUgPyAnaW5kaXJlY3RTdG9yYWdlQnVmZmVyJyA6ICdzdG9yYWdlQnVmZmVyJztcclxuXHJcblx0fVxyXG5cclxuXHRlbGVtZW50KCBpbmRleE5vZGUgKSB7XHJcblxyXG5cdFx0cmV0dXJuIHN0b3JhZ2VFbGVtZW50KCB0aGlzLCBpbmRleE5vZGUgKTtcclxuXHJcblx0fVxyXG5cclxuXHRzZXRQQk8oIHZhbHVlICkge1xyXG5cclxuXHRcdHRoaXMuaXNQQk8gPSB2YWx1ZTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fVxyXG5cclxuXHRnZXRQQk8oKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuaXNQQk87XHJcblxyXG5cdH1cclxuXHJcblx0c2V0QWNjZXNzKCB2YWx1ZSApIHtcclxuXHJcblx0XHR0aGlzLmFjY2VzcyA9IHZhbHVlO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9XHJcblxyXG5cdHRvUmVhZE9ubHkoKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuc2V0QWNjZXNzKCBOb2RlQWNjZXNzLlJFQURfT05MWSApO1xyXG5cclxuXHR9XHJcblxyXG5cdHNldEF0b21pYyggdmFsdWUgKSB7XHJcblxyXG5cdFx0dGhpcy5pc0F0b21pYyA9IHZhbHVlO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9XHJcblxyXG5cdHRvQXRvbWljKCkge1xyXG5cclxuXHRcdHJldHVybiB0aGlzLnNldEF0b21pYyggdHJ1ZSApO1xyXG5cclxuXHR9XHJcblxyXG5cdGdldEF0dHJpYnV0ZURhdGEoKSB7XHJcblxyXG5cdFx0aWYgKCB0aGlzLl9hdHRyaWJ1dGUgPT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHR0aGlzLl9hdHRyaWJ1dGUgPSBidWZmZXJBdHRyaWJ1dGUoIHRoaXMudmFsdWUgKTtcclxuXHRcdFx0dGhpcy5fdmFyeWluZyA9IHZhcnlpbmcoIHRoaXMuX2F0dHJpYnV0ZSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4ge1xyXG5cdFx0XHRhdHRyaWJ1dGU6IHRoaXMuX2F0dHJpYnV0ZSxcclxuXHRcdFx0dmFyeWluZzogdGhpcy5fdmFyeWluZ1xyXG5cdFx0fTtcclxuXHJcblx0fVxyXG5cclxuXHRnZXROb2RlVHlwZSggYnVpbGRlciApIHtcclxuXHJcblx0XHRpZiAoIGJ1aWxkZXIuaXNBdmFpbGFibGUoICdzdG9yYWdlQnVmZmVyJyApIHx8IGJ1aWxkZXIuaXNBdmFpbGFibGUoICdpbmRpcmVjdFN0b3JhZ2VCdWZmZXInICkgKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gc3VwZXIuZ2V0Tm9kZVR5cGUoIGJ1aWxkZXIgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Y29uc3QgeyBhdHRyaWJ1dGUgfSA9IHRoaXMuZ2V0QXR0cmlidXRlRGF0YSgpO1xyXG5cclxuXHRcdHJldHVybiBhdHRyaWJ1dGUuZ2V0Tm9kZVR5cGUoIGJ1aWxkZXIgKTtcclxuXHJcblx0fVxyXG5cclxuXHRnZW5lcmF0ZSggYnVpbGRlciApIHtcclxuXHJcblx0XHRpZiAoIGJ1aWxkZXIuaXNBdmFpbGFibGUoICdzdG9yYWdlQnVmZmVyJyApIHx8IGJ1aWxkZXIuaXNBdmFpbGFibGUoICdpbmRpcmVjdFN0b3JhZ2VCdWZmZXInICkgKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gc3VwZXIuZ2VuZXJhdGUoIGJ1aWxkZXIgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Y29uc3QgeyBhdHRyaWJ1dGUsIHZhcnlpbmcgfSA9IHRoaXMuZ2V0QXR0cmlidXRlRGF0YSgpO1xyXG5cclxuXHRcdGNvbnN0IG91dHB1dCA9IHZhcnlpbmcuYnVpbGQoIGJ1aWxkZXIgKTtcclxuXHJcblx0XHRidWlsZGVyLnJlZ2lzdGVyVHJhbnNmb3JtKCBvdXRwdXQsIGF0dHJpYnV0ZSApO1xyXG5cclxuXHRcdHJldHVybiBvdXRwdXQ7XHJcblxyXG5cdH1cclxuXHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IFN0b3JhZ2VCdWZmZXJOb2RlO1xyXG5cclxuZXhwb3J0IGNvbnN0IHN0b3JhZ2UgPSAoIHZhbHVlLCB0eXBlLCBjb3VudCApID0+IG5vZGVPYmplY3QoIG5ldyBTdG9yYWdlQnVmZmVyTm9kZSggdmFsdWUsIHR5cGUsIGNvdW50ICkgKTtcclxuXHJcbmV4cG9ydCBjb25zdCBzdG9yYWdlT2JqZWN0ID0gKCB2YWx1ZSwgdHlwZSwgY291bnQgKSA9PiB7IC8vIEBkZXByZWNhdGVkLCByMTcxXHJcblxyXG5cdGNvbnNvbGUud2FybiggJ1RIUkVFLlRTTDogXCJzdG9yYWdlT2JqZWN0KClcIiBpcyBkZXByZWNhdGVkLiBVc2UgXCJzdG9yYWdlKCkuc2V0UEJPKCB0cnVlIClcIiBpbnN0ZWFkLicgKTtcclxuXHJcblx0cmV0dXJuIHN0b3JhZ2UoIHZhbHVlLCB0eXBlLCBjb3VudCApLnNldFBCTyggdHJ1ZSApO1xyXG5cclxufTtcclxuIiwiaW1wb3J0IFN0b3JhZ2VJbnN0YW5jZWRCdWZmZXJBdHRyaWJ1dGUgZnJvbSAnLi4vLi4vcmVuZGVyZXJzL2NvbW1vbi9TdG9yYWdlSW5zdGFuY2VkQnVmZmVyQXR0cmlidXRlLmpzJztcclxuaW1wb3J0IFN0b3JhZ2VCdWZmZXJBdHRyaWJ1dGUgZnJvbSAnLi4vLi4vcmVuZGVyZXJzL2NvbW1vbi9TdG9yYWdlQnVmZmVyQXR0cmlidXRlLmpzJztcclxuaW1wb3J0IHsgc3RvcmFnZSB9IGZyb20gJy4vU3RvcmFnZUJ1ZmZlck5vZGUuanMnO1xyXG5pbXBvcnQgeyBnZXRMZW5ndGhGcm9tVHlwZSB9IGZyb20gJy4uL2NvcmUvTm9kZVV0aWxzLmpzJztcclxuXHJcbmV4cG9ydCBjb25zdCBhdHRyaWJ1dGVBcnJheSA9ICggY291bnQsIHR5cGUgPSAnZmxvYXQnICkgPT4ge1xyXG5cclxuXHRjb25zdCBpdGVtU2l6ZSA9IGdldExlbmd0aEZyb21UeXBlKCB0eXBlICk7XHJcblxyXG5cdGNvbnN0IGJ1ZmZlciA9IG5ldyBTdG9yYWdlQnVmZmVyQXR0cmlidXRlKCBjb3VudCwgaXRlbVNpemUgKTtcclxuXHRjb25zdCBub2RlID0gc3RvcmFnZSggYnVmZmVyLCB0eXBlLCBjb3VudCApO1xyXG5cclxuXHRyZXR1cm4gbm9kZTtcclxuXHJcbn07XHJcblxyXG5cclxuZXhwb3J0IGNvbnN0IGluc3RhbmNlZEFycmF5ID0gKCBjb3VudCwgdHlwZSA9ICdmbG9hdCcgKSA9PiB7XHJcblxyXG5cdGNvbnN0IGl0ZW1TaXplID0gZ2V0TGVuZ3RoRnJvbVR5cGUoIHR5cGUgKTtcclxuXHJcblx0Y29uc3QgYnVmZmVyID0gbmV3IFN0b3JhZ2VJbnN0YW5jZWRCdWZmZXJBdHRyaWJ1dGUoIGNvdW50LCBpdGVtU2l6ZSApO1xyXG5cdGNvbnN0IG5vZGUgPSBzdG9yYWdlKCBidWZmZXIsIHR5cGUsIGNvdW50ICk7XHJcblxyXG5cdHJldHVybiBub2RlO1xyXG5cclxufTtcclxuIiwiaW1wb3J0IEF0dHJpYnV0ZU5vZGUgZnJvbSAnLi4vY29yZS9BdHRyaWJ1dGVOb2RlLmpzJztcclxuaW1wb3J0IHsgbm9kZU9iamVjdCB9IGZyb20gJy4uL3RzbC9UU0xCYXNlLmpzJztcclxuaW1wb3J0IHsgVmVjdG9yNCB9IGZyb20gJy4uLy4uL21hdGgvVmVjdG9yNC5qcyc7XHJcblxyXG4vKiogQG1vZHVsZSBWZXJ0ZXhDb2xvck5vZGUgKiovXHJcblxyXG4vKipcclxuICogQW4gYXR0cmlidXRlIG5vZGUgZm9yIHJlcHJlc2VudGluZyB2ZXJ0ZXggY29sb3JzLlxyXG4gKlxyXG4gKiBAYXVnbWVudHMgbW9kdWxlOkF0dHJpYnV0ZU5vZGV+QXR0cmlidXRlTm9kZVxyXG4gKi9cclxuY2xhc3MgVmVydGV4Q29sb3JOb2RlIGV4dGVuZHMgQXR0cmlidXRlTm9kZSB7XHJcblxyXG5cdHN0YXRpYyBnZXQgdHlwZSgpIHtcclxuXHJcblx0XHRyZXR1cm4gJ1ZlcnRleENvbG9yTm9kZSc7XHJcblxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogQ29uc3RydWN0cyBhIG5ldyB2ZXJ0ZXggY29sb3Igbm9kZS5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbaW5kZXg9MF0gLSBUaGUgYXR0cmlidXRlIGluZGV4LlxyXG5cdCAqL1xyXG5cdGNvbnN0cnVjdG9yKCBpbmRleCA9IDAgKSB7XHJcblxyXG5cdFx0c3VwZXIoIG51bGwsICd2ZWM0JyApO1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogVGhpcyBmbGFnIGNhbiBiZSB1c2VkIGZvciB0eXBlIHRlc3RpbmcuXHJcblx0XHQgKlxyXG5cdFx0ICogQHR5cGUge0Jvb2xlYW59XHJcblx0XHQgKiBAcmVhZG9ubHlcclxuXHRcdCAqIEBkZWZhdWx0IHRydWVcclxuXHRcdCAqL1xyXG5cdFx0dGhpcy5pc1ZlcnRleENvbG9yTm9kZSA9IHRydWU7XHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBUaGUgYXR0cmlidXRlIGluZGV4IHRvIGVuYWJsZSBtb3JlIHRoYW4gb25lIHNldHMgb2YgdmVydGV4IGNvbG9ycy5cclxuXHRcdCAqXHJcblx0XHQgKiBAdHlwZSB7TnVtYmVyfVxyXG5cdFx0ICogQGRlZmF1bHQgMFxyXG5cdFx0ICovXHJcblx0XHR0aGlzLmluZGV4ID0gaW5kZXg7XHJcblxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogT3ZlcndyaXRlcyB0aGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiBieSBob25vcmluZyB0aGUgYXR0cmlidXRlIGluZGV4LlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtOb2RlQnVpbGRlcn0gYnVpbGRlciAtIFRoZSBjdXJyZW50IG5vZGUgYnVpbGRlci5cclxuXHQgKiBAcmV0dXJuIHtTdHJpbmd9IFRoZSBhdHRyaWJ1dGUgbmFtZS5cclxuXHQgKi9cclxuXHRnZXRBdHRyaWJ1dGVOYW1lKCAvKmJ1aWxkZXIqLyApIHtcclxuXHJcblx0XHRjb25zdCBpbmRleCA9IHRoaXMuaW5kZXg7XHJcblxyXG5cdFx0cmV0dXJuICdjb2xvcicgKyAoIGluZGV4ID4gMCA/IGluZGV4IDogJycgKTtcclxuXHJcblx0fVxyXG5cclxuXHRnZW5lcmF0ZSggYnVpbGRlciApIHtcclxuXHJcblx0XHRjb25zdCBhdHRyaWJ1dGVOYW1lID0gdGhpcy5nZXRBdHRyaWJ1dGVOYW1lKCBidWlsZGVyICk7XHJcblx0XHRjb25zdCBnZW9tZXRyeUF0dHJpYnV0ZSA9IGJ1aWxkZXIuaGFzR2VvbWV0cnlBdHRyaWJ1dGUoIGF0dHJpYnV0ZU5hbWUgKTtcclxuXHJcblx0XHRsZXQgcmVzdWx0O1xyXG5cclxuXHRcdGlmICggZ2VvbWV0cnlBdHRyaWJ1dGUgPT09IHRydWUgKSB7XHJcblxyXG5cdFx0XHRyZXN1bHQgPSBzdXBlci5nZW5lcmF0ZSggYnVpbGRlciApO1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHQvLyBWZXJ0ZXggY29sb3IgZmFsbGJhY2sgc2hvdWxkIGJlIHdoaXRlXHJcblx0XHRcdHJlc3VsdCA9IGJ1aWxkZXIuZ2VuZXJhdGVDb25zdCggdGhpcy5ub2RlVHlwZSwgbmV3IFZlY3RvcjQoIDEsIDEsIDEsIDEgKSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gcmVzdWx0O1xyXG5cclxuXHR9XHJcblxyXG5cdHNlcmlhbGl6ZSggZGF0YSApIHtcclxuXHJcblx0XHRzdXBlci5zZXJpYWxpemUoIGRhdGEgKTtcclxuXHJcblx0XHRkYXRhLmluZGV4ID0gdGhpcy5pbmRleDtcclxuXHJcblx0fVxyXG5cclxuXHRkZXNlcmlhbGl6ZSggZGF0YSApIHtcclxuXHJcblx0XHRzdXBlci5kZXNlcmlhbGl6ZSggZGF0YSApO1xyXG5cclxuXHRcdHRoaXMuaW5kZXggPSBkYXRhLmluZGV4O1xyXG5cclxuXHR9XHJcblxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBWZXJ0ZXhDb2xvck5vZGU7XHJcblxyXG4vKipcclxuICogVFNMIGZ1bmN0aW9uIGZvciBjcmVhdGluZyBhIHJlZmVyZW5jZSBub2RlLlxyXG4gKlxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4IC0gVGhlIGF0dHJpYnV0ZSBpbmRleC5cclxuICogQHJldHVybnMge1ZlcnRleENvbG9yTm9kZX1cclxuICovXHJcbmV4cG9ydCBjb25zdCB2ZXJ0ZXhDb2xvciA9ICggaW5kZXggKSA9PiBub2RlT2JqZWN0KCBuZXcgVmVydGV4Q29sb3JOb2RlKCBpbmRleCApICk7XHJcbiIsImltcG9ydCBOb2RlIGZyb20gJy4uL2NvcmUvTm9kZS5qcyc7XHJcbmltcG9ydCB7IG5vZGVJbW11dGFibGUgfSBmcm9tICcuLi90c2wvVFNMQmFzZS5qcyc7XHJcblxyXG4vKiogQG1vZHVsZSBQb2ludFVWTm9kZSAqKi9cclxuXHJcbi8qKlxyXG4gKiBBIG5vZGUgZm9yIHJlcHJlc2VudGluZyB0aGUgdXYgY29vcmRpbmF0ZXMgb2YgcG9pbnRzLlxyXG4gKlxyXG4gKiBDYW4gb25seSBiZSB1c2VkIHdpdGggYSBXZWJHTCBiYWNrZW5kLiBJbiBXZWJHUFUsIHBvaW50XHJcbiAqIHByaW1pdGl2ZXMgYWx3YXlzIGhhdmUgdGhlIHNpemUgb2Ygb25lIHBpeGVsIGFuZCBjYW4gdGh1c1xyXG4gKiBjYW4ndCBiZSB1c2VkIGFzIHNwcml0ZS1saWtlIG9iamVjdHMgdGhhdCBkaXNwbGF5IHRleHR1cmVzLlxyXG4gKlxyXG4gKiBAYXVnbWVudHMgTm9kZVxyXG4gKi9cclxuY2xhc3MgUG9pbnRVVk5vZGUgZXh0ZW5kcyBOb2RlIHtcclxuXHJcblx0c3RhdGljIGdldCB0eXBlKCkge1xyXG5cclxuXHRcdHJldHVybiAnUG9pbnRVVk5vZGUnO1xyXG5cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIENvbnN0cnVjdHMgYSBuZXcgcG9pbnQgdXYgbm9kZS5cclxuXHQgKi9cclxuXHRjb25zdHJ1Y3RvcigpIHtcclxuXHJcblx0XHRzdXBlciggJ3ZlYzInICk7XHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBUaGlzIGZsYWcgY2FuIGJlIHVzZWQgZm9yIHR5cGUgdGVzdGluZy5cclxuXHRcdCAqXHJcblx0XHQgKiBAdHlwZSB7Qm9vbGVhbn1cclxuXHRcdCAqIEByZWFkb25seVxyXG5cdFx0ICogQGRlZmF1bHQgdHJ1ZVxyXG5cdFx0ICovXHJcblx0XHR0aGlzLmlzUG9pbnRVVk5vZGUgPSB0cnVlO1xyXG5cclxuXHR9XHJcblxyXG5cdGdlbmVyYXRlKCAvKmJ1aWxkZXIqLyApIHtcclxuXHJcblx0XHRyZXR1cm4gJ3ZlYzIoIGdsX1BvaW50Q29vcmQueCwgMS4wIC0gZ2xfUG9pbnRDb29yZC55ICknO1xyXG5cclxuXHR9XHJcblxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBQb2ludFVWTm9kZTtcclxuXHJcbi8qKlxyXG4gKiBUU0wgb2JqZWN0IHRoYXQgcmVwcmVzZW50cyB0aGUgdXYgY29vcmRpbmF0ZXMgb2YgcG9pbnRzLlxyXG4gKlxyXG4gKiBAdHlwZSB7UG9pbnRVVk5vZGV9XHJcbiAqL1xyXG5leHBvcnQgY29uc3QgcG9pbnRVViA9IC8qQF9fUFVSRV9fKi8gbm9kZUltbXV0YWJsZSggUG9pbnRVVk5vZGUgKTtcclxuIiwiaW1wb3J0IHsgVVZNYXBwaW5nIH0gZnJvbSAnLi4vLi4vY29uc3RhbnRzLmpzJztcclxuaW1wb3J0IHsgRXVsZXIgfSBmcm9tICcuLi8uLi9tYXRoL0V1bGVyLmpzJztcclxuaW1wb3J0IHsgTWF0cml4NCB9IGZyb20gJy4uLy4uL21hdGgvTWF0cml4NC5qcyc7XHJcbmltcG9ydCBOb2RlIGZyb20gJy4uL2NvcmUvTm9kZS5qcyc7XHJcbmltcG9ydCB7IHJlbmRlckdyb3VwIH0gZnJvbSAnLi4vY29yZS9Vbmlmb3JtR3JvdXBOb2RlLmpzJztcclxuaW1wb3J0IHsgbm9kZUltbXV0YWJsZSwgdW5pZm9ybSB9IGZyb20gJy4uL3RzbC9UU0xCYXNlLmpzJztcclxuaW1wb3J0IHsgcmVmZXJlbmNlIH0gZnJvbSAnLi9SZWZlcmVuY2VOb2RlLmpzJztcclxuXHJcbmNvbnN0IF9lMSA9IC8qQF9fUFVSRV9fKi8gbmV3IEV1bGVyKCk7XHJcbmNvbnN0IF9tMSA9IC8qQF9fUFVSRV9fKi8gbmV3IE1hdHJpeDQoKTtcclxuXHJcbi8qKiBAbW9kdWxlIFNjZW5lTm9kZSAqKi9cclxuXHJcbi8qKlxyXG4gKiBUaGlzIG1vZHVsZSBhbGxvd3MgYWNjZXNzIHRvIGEgY29sbGVjdGlvbiBvZiBzY2VuZSBwcm9wZXJ0aWVzLiBUaGUgZm9sbG93aW5nIHByZWRlZmluZWQgVFNMIG9iamVjdHNcclxuICogYXJlIGF2YWlsYWJsZSBmb3IgZWFzaWVyIHVzZTpcclxuICpcclxuICogLSBgYmFja2dyb3VuZEJsdXJyaW5lc3NgOiBBIG5vZGUgdGhhdCByZXByZXNlbnRzIHRoZSBzY2VuZSdzIGJhY2tncm91bmQgYmx1cnJpbmVzcy5cclxuICogLSBgYmFja2dyb3VuZEludGVuc2l0eWA6IEEgbm9kZSB0aGF0IHJlcHJlc2VudHMgdGhlIHNjZW5lJ3MgYmFja2dyb3VuZCBpbnRlbnNpdHkuXHJcbiAqIC0gYGJhY2tncm91bmRSb3RhdGlvbmA6IEEgbm9kZSB0aGF0IHJlcHJlc2VudHMgdGhlIHNjZW5lJ3MgYmFja2dyb3VuZCByb3RhdGlvbi5cclxuICpcclxuICogQGF1Z21lbnRzIE5vZGVcclxuICovXHJcbmNsYXNzIFNjZW5lTm9kZSBleHRlbmRzIE5vZGUge1xyXG5cclxuXHRzdGF0aWMgZ2V0IHR5cGUoKSB7XHJcblxyXG5cdFx0cmV0dXJuICdTY2VuZU5vZGUnO1xyXG5cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIENvbnN0cnVjdHMgYSBuZXcgc2NlbmUgbm9kZS5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7KCdiYWNrZ3JvdW5kQmx1cnJpbmVzcyd8J2JhY2tncm91bmRJbnRlbnNpdHknfCdiYWNrZ3JvdW5kUm90YXRpb24nKX0gc2NvcGUgLSBUaGUgc2NvcGUgZGVmaW5lcyB0aGUgdHlwZSBvZiBzY2VuZSBwcm9wZXJ0eSB0aGF0IGlzIGFjY2Vzc2VkLlxyXG5cdCAqIEBwYXJhbSB7U2NlbmU/fSBbc2NlbmU9bnVsbF0gLSBBIHJlZmVyZW5jZSB0byB0aGUgc2NlbmUuXHJcblx0ICovXHJcblx0Y29uc3RydWN0b3IoIHNjb3BlID0gU2NlbmVOb2RlLkJBQ0tHUk9VTkRfQkxVUlJJTkVTUywgc2NlbmUgPSBudWxsICkge1xyXG5cclxuXHRcdHN1cGVyKCk7XHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBUaGUgc2NvcGUgZGVmaW5lcyB0aGUgdHlwZSBvZiBzY2VuZSBwcm9wZXJ0eSB0aGF0IGlzIGFjY2Vzc2VkLlxyXG5cdFx0ICpcclxuXHRcdCAqIEB0eXBlIHsoJ2JhY2tncm91bmRCbHVycmluZXNzJ3wnYmFja2dyb3VuZEludGVuc2l0eSd8J2JhY2tncm91bmRSb3RhdGlvbicpfVxyXG5cdFx0ICovXHJcblx0XHR0aGlzLnNjb3BlID0gc2NvcGU7XHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBBIHJlZmVyZW5jZSB0byB0aGUgc2NlbmUgdGhhdCBpcyBnb2luZyB0byBiZSBhY2Nlc3NlZC5cclxuXHRcdCAqXHJcblx0XHQgKiBAdHlwZSB7U2NlbmU/fVxyXG5cdFx0ICogQGRlZmF1bHQgbnVsbFxyXG5cdFx0ICovXHJcblx0XHR0aGlzLnNjZW5lID0gc2NlbmU7XHJcblxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogRGVwZW5kaW5nIG9uIHRoZSBzY29wZSwgdGhlIG1ldGhvZCByZXR1cm5zIGEgZGlmZmVyZW50IHR5cGUgb2Ygbm9kZSB0aGF0IHJlcHJlc2VudHNcclxuXHQgKiB0aGUgcmVzcGVjdGl2ZSBzY2VuZSBwcm9wZXJ0eS5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7Tm9kZUJ1aWxkZXJ9IGJ1aWxkZXIgLSBUaGUgY3VycmVudCBub2RlIGJ1aWxkZXIuXHJcblx0ICogQHJldHVybiB7Tm9kZX0gVGhlIG91dHB1dCBub2RlLlxyXG5cdCAqL1xyXG5cdHNldHVwKCBidWlsZGVyICkge1xyXG5cclxuXHRcdGNvbnN0IHNjb3BlID0gdGhpcy5zY29wZTtcclxuXHRcdGNvbnN0IHNjZW5lID0gdGhpcy5zY2VuZSAhPT0gbnVsbCA/IHRoaXMuc2NlbmUgOiBidWlsZGVyLnNjZW5lO1xyXG5cclxuXHRcdGxldCBvdXRwdXQ7XHJcblxyXG5cdFx0aWYgKCBzY29wZSA9PT0gU2NlbmVOb2RlLkJBQ0tHUk9VTkRfQkxVUlJJTkVTUyApIHtcclxuXHJcblx0XHRcdG91dHB1dCA9IHJlZmVyZW5jZSggJ2JhY2tncm91bmRCbHVycmluZXNzJywgJ2Zsb2F0Jywgc2NlbmUgKTtcclxuXHJcblx0XHR9IGVsc2UgaWYgKCBzY29wZSA9PT0gU2NlbmVOb2RlLkJBQ0tHUk9VTkRfSU5URU5TSVRZICkge1xyXG5cclxuXHRcdFx0b3V0cHV0ID0gcmVmZXJlbmNlKCAnYmFja2dyb3VuZEludGVuc2l0eScsICdmbG9hdCcsIHNjZW5lICk7XHJcblxyXG5cdFx0fSBlbHNlIGlmICggc2NvcGUgPT09IFNjZW5lTm9kZS5CQUNLR1JPVU5EX1JPVEFUSU9OICkge1xyXG5cclxuXHRcdFx0b3V0cHV0ID0gdW5pZm9ybSggJ21hdDQnICkubGFiZWwoICdiYWNrZ3JvdW5kUm90YXRpb24nICkuc2V0R3JvdXAoIHJlbmRlckdyb3VwICkub25SZW5kZXJVcGRhdGUoICgpID0+IHtcclxuXHJcblx0XHRcdFx0Y29uc3QgYmFja2dyb3VuZCA9IHNjZW5lLmJhY2tncm91bmQ7XHJcblxyXG5cdFx0XHRcdGlmICggYmFja2dyb3VuZCAhPT0gbnVsbCAmJiBiYWNrZ3JvdW5kLmlzVGV4dHVyZSAmJiBiYWNrZ3JvdW5kLm1hcHBpbmcgIT09IFVWTWFwcGluZyApIHtcclxuXHJcblx0XHRcdFx0XHRfZTEuY29weSggc2NlbmUuYmFja2dyb3VuZFJvdGF0aW9uICk7XHJcblxyXG5cdFx0XHRcdFx0Ly8gYWNjb21tb2RhdGUgbGVmdC1oYW5kZWQgZnJhbWVcclxuXHRcdFx0XHRcdF9lMS54ICo9IC0gMTsgX2UxLnkgKj0gLSAxOyBfZTEueiAqPSAtIDE7XHJcblxyXG5cdFx0XHRcdFx0X20xLm1ha2VSb3RhdGlvbkZyb21FdWxlciggX2UxICk7XHJcblxyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0X20xLmlkZW50aXR5KCk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0cmV0dXJuIF9tMTtcclxuXHJcblx0XHRcdH0gKTtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLlNjZW5lTm9kZTogVW5rbm93biBzY29wZTonLCBzY29wZSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gb3V0cHV0O1xyXG5cclxuXHR9XHJcblxyXG59XHJcblxyXG5TY2VuZU5vZGUuQkFDS0dST1VORF9CTFVSUklORVNTID0gJ2JhY2tncm91bmRCbHVycmluZXNzJztcclxuU2NlbmVOb2RlLkJBQ0tHUk9VTkRfSU5URU5TSVRZID0gJ2JhY2tncm91bmRJbnRlbnNpdHknO1xyXG5TY2VuZU5vZGUuQkFDS0dST1VORF9ST1RBVElPTiA9ICdiYWNrZ3JvdW5kUm90YXRpb24nO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgU2NlbmVOb2RlO1xyXG5cclxuLyoqXHJcbiAqIFRTTCBvYmplY3QgdGhhdCByZXByZXNlbnRzIHRoZSBzY2VuZSdzIGJhY2tncm91bmQgYmx1cnJpbmVzcy5cclxuICpcclxuICogQHR5cGUge1NjZW5lTm9kZX1cclxuICovXHJcbmV4cG9ydCBjb25zdCBiYWNrZ3JvdW5kQmx1cnJpbmVzcyA9IC8qQF9fUFVSRV9fKi8gbm9kZUltbXV0YWJsZSggU2NlbmVOb2RlLCBTY2VuZU5vZGUuQkFDS0dST1VORF9CTFVSUklORVNTICk7XHJcblxyXG4vKipcclxuICogVFNMIG9iamVjdCB0aGF0IHJlcHJlc2VudHMgdGhlIHNjZW5lJ3MgYmFja2dyb3VuZCBpbnRlbnNpdHkuXHJcbiAqXHJcbiAqIEB0eXBlIHtTY2VuZU5vZGV9XHJcbiAqL1xyXG5leHBvcnQgY29uc3QgYmFja2dyb3VuZEludGVuc2l0eSA9IC8qQF9fUFVSRV9fKi8gbm9kZUltbXV0YWJsZSggU2NlbmVOb2RlLCBTY2VuZU5vZGUuQkFDS0dST1VORF9JTlRFTlNJVFkgKTtcclxuXHJcbi8qKlxyXG4gKiBUU0wgb2JqZWN0IHRoYXQgcmVwcmVzZW50cyB0aGUgc2NlbmUncyBiYWNrZ3JvdW5kIHJvdGF0aW9uLlxyXG4gKlxyXG4gKiBAdHlwZSB7U2NlbmVOb2RlfVxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IGJhY2tncm91bmRSb3RhdGlvbiA9IC8qQF9fUFVSRV9fKi8gbm9kZUltbXV0YWJsZSggU2NlbmVOb2RlLCBTY2VuZU5vZGUuQkFDS0dST1VORF9ST1RBVElPTiApO1xyXG4iLCJpbXBvcnQgVGV4dHVyZU5vZGUgZnJvbSAnLi9UZXh0dXJlTm9kZS5qcyc7XHJcbmltcG9ydCB7IG5vZGVQcm94eSB9IGZyb20gJy4uL3RzbC9UU0xCYXNlLmpzJztcclxuaW1wb3J0IHsgTm9kZUFjY2VzcyB9IGZyb20gJy4uL2NvcmUvY29uc3RhbnRzLmpzJztcclxuXHJcbmNsYXNzIFN0b3JhZ2VUZXh0dXJlTm9kZSBleHRlbmRzIFRleHR1cmVOb2RlIHtcclxuXHJcblx0c3RhdGljIGdldCB0eXBlKCkge1xyXG5cclxuXHRcdHJldHVybiAnU3RvcmFnZVRleHR1cmVOb2RlJztcclxuXHJcblx0fVxyXG5cclxuXHRjb25zdHJ1Y3RvciggdmFsdWUsIHV2Tm9kZSwgc3RvcmVOb2RlID0gbnVsbCApIHtcclxuXHJcblx0XHRzdXBlciggdmFsdWUsIHV2Tm9kZSApO1xyXG5cclxuXHRcdHRoaXMuc3RvcmVOb2RlID0gc3RvcmVOb2RlO1xyXG5cclxuXHRcdHRoaXMuaXNTdG9yYWdlVGV4dHVyZU5vZGUgPSB0cnVlO1xyXG5cclxuXHRcdHRoaXMuYWNjZXNzID0gTm9kZUFjY2Vzcy5XUklURV9PTkxZO1xyXG5cclxuXHR9XHJcblxyXG5cdGdldElucHV0VHlwZSggLypidWlsZGVyKi8gKSB7XHJcblxyXG5cdFx0cmV0dXJuICdzdG9yYWdlVGV4dHVyZSc7XHJcblxyXG5cdH1cclxuXHJcblx0c2V0dXAoIGJ1aWxkZXIgKSB7XHJcblxyXG5cdFx0c3VwZXIuc2V0dXAoIGJ1aWxkZXIgKTtcclxuXHJcblx0XHRjb25zdCBwcm9wZXJ0aWVzID0gYnVpbGRlci5nZXROb2RlUHJvcGVydGllcyggdGhpcyApO1xyXG5cdFx0cHJvcGVydGllcy5zdG9yZU5vZGUgPSB0aGlzLnN0b3JlTm9kZTtcclxuXHJcblx0fVxyXG5cclxuXHRzZXRBY2Nlc3MoIHZhbHVlICkge1xyXG5cclxuXHRcdHRoaXMuYWNjZXNzID0gdmFsdWU7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fVxyXG5cclxuXHRnZW5lcmF0ZSggYnVpbGRlciwgb3V0cHV0ICkge1xyXG5cclxuXHRcdGxldCBzbmlwcGV0O1xyXG5cclxuXHRcdGlmICggdGhpcy5zdG9yZU5vZGUgIT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHRzbmlwcGV0ID0gdGhpcy5nZW5lcmF0ZVN0b3JlKCBidWlsZGVyICk7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdHNuaXBwZXQgPSBzdXBlci5nZW5lcmF0ZSggYnVpbGRlciwgb3V0cHV0ICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBzbmlwcGV0O1xyXG5cclxuXHR9XHJcblxyXG5cdHRvUmVhZFdyaXRlKCkge1xyXG5cclxuXHRcdHJldHVybiB0aGlzLnNldEFjY2VzcyggTm9kZUFjY2Vzcy5SRUFEX1dSSVRFICk7XHJcblxyXG5cdH1cclxuXHJcblx0dG9SZWFkT25seSgpIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5zZXRBY2Nlc3MoIE5vZGVBY2Nlc3MuUkVBRF9PTkxZICk7XHJcblxyXG5cdH1cclxuXHJcblx0dG9Xcml0ZU9ubHkoKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuc2V0QWNjZXNzKCBOb2RlQWNjZXNzLldSSVRFX09OTFkgKTtcclxuXHJcblx0fVxyXG5cclxuXHRnZW5lcmF0ZVN0b3JlKCBidWlsZGVyICkge1xyXG5cclxuXHRcdGNvbnN0IHByb3BlcnRpZXMgPSBidWlsZGVyLmdldE5vZGVQcm9wZXJ0aWVzKCB0aGlzICk7XHJcblxyXG5cdFx0Y29uc3QgeyB1dk5vZGUsIHN0b3JlTm9kZSB9ID0gcHJvcGVydGllcztcclxuXHJcblx0XHRjb25zdCB0ZXh0dXJlUHJvcGVydHkgPSBzdXBlci5nZW5lcmF0ZSggYnVpbGRlciwgJ3Byb3BlcnR5JyApO1xyXG5cdFx0Y29uc3QgdXZTbmlwcGV0ID0gdXZOb2RlLmJ1aWxkKCBidWlsZGVyLCAndXZlYzInICk7XHJcblx0XHRjb25zdCBzdG9yZVNuaXBwZXQgPSBzdG9yZU5vZGUuYnVpbGQoIGJ1aWxkZXIsICd2ZWM0JyApO1xyXG5cclxuXHRcdGNvbnN0IHNuaXBwZXQgPSBidWlsZGVyLmdlbmVyYXRlVGV4dHVyZVN0b3JlKCBidWlsZGVyLCB0ZXh0dXJlUHJvcGVydHksIHV2U25pcHBldCwgc3RvcmVTbmlwcGV0ICk7XHJcblxyXG5cdFx0YnVpbGRlci5hZGRMaW5lRmxvd0NvZGUoIHNuaXBwZXQsIHRoaXMgKTtcclxuXHJcblx0fVxyXG5cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgU3RvcmFnZVRleHR1cmVOb2RlO1xyXG5cclxuZXhwb3J0IGNvbnN0IHN0b3JhZ2VUZXh0dXJlID0gLypAX19QVVJFX18qLyBub2RlUHJveHkoIFN0b3JhZ2VUZXh0dXJlTm9kZSApO1xyXG5cclxuZXhwb3J0IGNvbnN0IHRleHR1cmVTdG9yZSA9ICggdmFsdWUsIHV2Tm9kZSwgc3RvcmVOb2RlICkgPT4ge1xyXG5cclxuXHRjb25zdCBub2RlID0gc3RvcmFnZVRleHR1cmUoIHZhbHVlLCB1dk5vZGUsIHN0b3JlTm9kZSApO1xyXG5cclxuXHRpZiAoIHN0b3JlTm9kZSAhPT0gbnVsbCApIG5vZGUuYXBwZW5kKCk7XHJcblxyXG5cdHJldHVybiBub2RlO1xyXG5cclxufTtcclxuIiwiaW1wb3J0IFJlZmVyZW5jZU5vZGUgZnJvbSAnLi9SZWZlcmVuY2VOb2RlLmpzJztcclxuaW1wb3J0IHsgbm9kZU9iamVjdCB9IGZyb20gJy4uL3RzbC9UU0xCYXNlLmpzJztcclxuXHJcbi8qKiBAbW9kdWxlIFVzZXJEYXRhTm9kZSAqKi9cclxuXHJcbi8qKlxyXG4gKiBBIHNwZWNpYWwgdHlwZSBvZiByZWZlcmVuY2Ugbm9kZSB0aGF0IGFsbG93cyB0byBsaW5rIHZhbHVlcyBpblxyXG4gKiBgdXNlckRhdGFgIGZpZWxkcyB0byBub2RlIG9iamVjdHMuXHJcbiAqIGBgYGpzXHJcbiAqIHNwcml0ZS51c2VyRGF0YS5yb3RhdGlvbiA9IDE7IC8vIHN0b3JlcyBpbmRpdmlkdWFsIHJvdGF0aW9uIHBlciBzcHJpdGVcclxuICpcclxuICogY29uc3QgbWF0ZXJpYWwgPSBuZXcgVEhSRUUuU3ByaXRlTm9kZU1hdGVyaWFsKCk7XHJcbiAqIG1hdGVyaWFsLnJvdGF0aW9uTm9kZSA9IHVzZXJEYXRhKCAncm90YXRpb24nLCAnZmxvYXQnICk7XHJcbiAqIGBgYFxyXG4gKiBTaW5jZSBgVXNlckRhdGFOb2RlYCBpcyBleHRlbmRlZCBmcm9tIHtAbGluayBtb2R1bGU6UmVmZXJlbmNlTm9kZX5SZWZlcmVuY2VOb2RlfSwgdGhlIG5vZGUgdmFsdWVcclxuICogd2lsbCBhdXRvbWF0aWNhbGx5IGJlIHVwZGF0ZWQgd2hlbiB0aGUgYHJvdGF0aW9uYCB1c2VyIGRhdGEgZmllbGQgY2hhbmdlcy5cclxuICpcclxuICogQGF1Z21lbnRzIG1vZHVsZTpSZWZlcmVuY2VOb2RlflJlZmVyZW5jZU5vZGVcclxuICovXHJcbmNsYXNzIFVzZXJEYXRhTm9kZSBleHRlbmRzIFJlZmVyZW5jZU5vZGUge1xyXG5cclxuXHRzdGF0aWMgZ2V0IHR5cGUoKSB7XHJcblxyXG5cdFx0cmV0dXJuICdVc2VyRGF0YU5vZGUnO1xyXG5cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIENvbnN0cnVjdHMgYSBuZXcgdXNlciBkYXRhIG5vZGUuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydHkgLSBUaGUgcHJvcGVydHkgbmFtZSB0aGF0IHNob3VsZCBiZSByZWZlcmVuY2VkIGJ5IHRoZSBub2RlLlxyXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dFR5cGUgLSBUaGUgbm9kZSBkYXRhIHR5cGUgb2YgdGhlIHJlZmVyZW5jZS5cclxuXHQgKiBAcGFyYW0ge09iamVjdD99IFt1c2VyRGF0YT1udWxsXSAtIEEgcmVmZXJlbmNlIHRvIHRoZSBgdXNlckRhdGFgIG9iamVjdC4gSWYgbm90IHByb3ZpZGVkLCB0aGUgYHVzZXJEYXRhYCBwcm9wZXJ0eSBvZiB0aGUgM0Qgb2JqZWN0IHRoYXQgdXNlcyB0aGUgbm9kZSBtYXRlcmlhbCBpcyBldmFsdWF0ZWQuXHJcblx0ICovXHJcblx0Y29uc3RydWN0b3IoIHByb3BlcnR5LCBpbnB1dFR5cGUsIHVzZXJEYXRhID0gbnVsbCApIHtcclxuXHJcblx0XHRzdXBlciggcHJvcGVydHksIGlucHV0VHlwZSwgdXNlckRhdGEgKTtcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIEEgcmVmZXJlbmNlIHRvIHRoZSBgdXNlckRhdGFgIG9iamVjdC4gSWYgbm90IHByb3ZpZGVkLCB0aGUgYHVzZXJEYXRhYFxyXG5cdFx0ICogcHJvcGVydHkgb2YgdGhlIDNEIG9iamVjdCB0aGF0IHVzZXMgdGhlIG5vZGUgbWF0ZXJpYWwgaXMgZXZhbHVhdGVkLlxyXG5cdFx0ICpcclxuXHRcdCAqIEB0eXBlIHtPYmplY3Q/fVxyXG5cdFx0ICogQGRlZmF1bHQgbnVsbFxyXG5cdFx0ICovXHJcblx0XHR0aGlzLnVzZXJEYXRhID0gdXNlckRhdGE7XHJcblxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogT3ZlcndyaXR0ZW4gdG8gbWFrZSBzdXJlIHtAbGluayBtb2R1bGU6UmVmZXJlbmNlTm9kZX5SZWZlcmVuY2VOb2RlI3JlZmVyZW5jZX0gcG9pbnRzIHRvIHRoZSBjb3JyZWN0XHJcblx0ICogYHVzZXJEYXRhYCBmaWVsZC5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7KE5vZGVGcmFtZXxOb2RlQnVpbGRlcil9IHN0YXRlIC0gVGhlIGN1cnJlbnQgc3RhdGUgdG8gZXZhbHVhdGUuXHJcblx0ICogQHJldHVybiB7T2JqZWN0fSBBIHJlZmVyZW5jZSB0byB0aGUgYHVzZXJEYXRhYCBmaWVsZC5cclxuXHQgKi9cclxuXHR1cGRhdGVSZWZlcmVuY2UoIHN0YXRlICkge1xyXG5cclxuXHRcdHRoaXMucmVmZXJlbmNlID0gdGhpcy51c2VyRGF0YSAhPT0gbnVsbCA/IHRoaXMudXNlckRhdGEgOiBzdGF0ZS5vYmplY3QudXNlckRhdGE7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMucmVmZXJlbmNlO1xyXG5cclxuXHR9XHJcblxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBVc2VyRGF0YU5vZGU7XHJcblxyXG4vKipcclxuICogVFNMIGZ1bmN0aW9uIGZvciBjcmVhdGluZyBhIHVzZXIgZGF0YSBub2RlLlxyXG4gKlxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgLSBUaGUgcHJvcGVydHkgbmFtZSB0aGF0IHNob3VsZCBiZSByZWZlcmVuY2VkIGJ5IHRoZSBub2RlLlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gaW5wdXRUeXBlIC0gVGhlIG5vZGUgZGF0YSB0eXBlIG9mIHRoZSByZWZlcmVuY2UuXHJcbiAqIEBwYXJhbSB7T2JqZWN0P30gdXNlckRhdGEgLSBBIHJlZmVyZW5jZSB0byB0aGUgYHVzZXJEYXRhYCBvYmplY3QuIElmIG5vdCBwcm92aWRlZCwgdGhlIGB1c2VyRGF0YWAgcHJvcGVydHkgb2YgdGhlIDNEIG9iamVjdCB0aGF0IHVzZXMgdGhlIG5vZGUgbWF0ZXJpYWwgaXMgZXZhbHVhdGVkLlxyXG4gKiBAcmV0dXJucyB7VXNlckRhdGFOb2RlfVxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IHVzZXJEYXRhID0gKCBuYW1lLCBpbnB1dFR5cGUsIHVzZXJEYXRhICkgPT4gbm9kZU9iamVjdCggbmV3IFVzZXJEYXRhTm9kZSggbmFtZSwgaW5wdXRUeXBlLCB1c2VyRGF0YSApICk7XHJcbiIsImltcG9ydCBUZW1wTm9kZSBmcm9tICcuLi9jb3JlL1RlbXBOb2RlLmpzJztcclxuaW1wb3J0IHsgbW9kZWxWaWV3TWF0cml4IH0gZnJvbSAnLi9Nb2RlbE5vZGUuanMnO1xyXG5pbXBvcnQgeyBwb3NpdGlvbkxvY2FsLCBwb3NpdGlvblByZXZpb3VzIH0gZnJvbSAnLi9Qb3NpdGlvbi5qcyc7XHJcbmltcG9ydCB7IG5vZGVJbW11dGFibGUgfSBmcm9tICcuLi90c2wvVFNMQmFzZS5qcyc7XHJcbmltcG9ydCB7IE5vZGVVcGRhdGVUeXBlIH0gZnJvbSAnLi4vY29yZS9jb25zdGFudHMuanMnO1xyXG5pbXBvcnQgeyBNYXRyaXg0IH0gZnJvbSAnLi4vLi4vbWF0aC9NYXRyaXg0LmpzJztcclxuaW1wb3J0IHsgdW5pZm9ybSB9IGZyb20gJy4uL2NvcmUvVW5pZm9ybU5vZGUuanMnO1xyXG5pbXBvcnQgeyBzdWIgfSBmcm9tICcuLi9tYXRoL09wZXJhdG9yTm9kZS5qcyc7XHJcbmltcG9ydCB7IGNhbWVyYVByb2plY3Rpb25NYXRyaXggfSBmcm9tICcuL0NhbWVyYS5qcyc7XHJcbmltcG9ydCB7IHJlbmRlckdyb3VwIH0gZnJvbSAnLi4vY29yZS9Vbmlmb3JtR3JvdXBOb2RlLmpzJztcclxuXHJcbmNvbnN0IF9vYmplY3REYXRhID0gbmV3IFdlYWtNYXAoKTtcclxuXHJcbi8qKiBAbW9kdWxlIFZlbG9jaXR5Tm9kZSAqKi9cclxuXHJcbi8qKlxyXG4gKiBBIG5vZGUgZm9yIHJlcHJlc2VudGluZyBtb3Rpb24gb3IgdmVsb2NpdHkgdmVjdG9ycy4gRm91bmRhdGlvblxyXG4gKiBmb3IgYWR2YW5jZWQgcG9zdCBwcm9jZXNzaW5nIGVmZmVjdHMgbGlrZSBtb3Rpb24gYmx1ciBvciBUUkFBLlxyXG4gKlxyXG4gKiBUaGUgbm9kZSBrZWVwcyB0cmFjayBvZiB0aGUgbW9kZWwsIHZpZXcgYW5kIHByb2plY3Rpb24gbWF0cmljZXNcclxuICogb2YgdGhlIHByZXZpb3VzIGZyYW1lIGFuZCB1c2VzIHRoZW0gdG8gY29tcHV0ZSBvZmZzZXRzIGluIE5EQyBzcGFjZS5cclxuICogVGhlc2Ugb2Zmc2V0cyByZXByZXNlbnQgdGhlIGZpbmFsIHZlbG9jaXR5LlxyXG4gKlxyXG4gKiBAYXVnbWVudHMgVGVtcE5vZGVcclxuICovXHJcbmNsYXNzIFZlbG9jaXR5Tm9kZSBleHRlbmRzIFRlbXBOb2RlIHtcclxuXHJcblx0c3RhdGljIGdldCB0eXBlKCkge1xyXG5cclxuXHRcdHJldHVybiAnVmVsb2NpdHlOb2RlJztcclxuXHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBDb25zdHJ1Y3RzIGEgbmV3IHZlcnRleCBjb2xvciBub2RlLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtOdW1iZXJ9IFtpbmRleD0wXSAtIFRoZSBhdHRyaWJ1dGUgaW5kZXguXHJcblx0ICovXHJcblx0Y29uc3RydWN0b3IoKSB7XHJcblxyXG5cdFx0c3VwZXIoICd2ZWMyJyApO1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogVGhlIGN1cnJlbnQgcHJvamVjdGlvbiBtYXRyaXguXHJcblx0XHQgKlxyXG5cdFx0ICogQHR5cGUge01hdHJpeDQ/fVxyXG5cdFx0ICogQGRlZmF1bHQgbnVsbFxyXG5cdFx0ICovXHJcblx0XHR0aGlzLnByb2plY3Rpb25NYXRyaXggPSBudWxsO1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogT3ZlcndyaXR0ZW4gc2luY2UgdmVsb2NpdHkgbm9kZXMgYXJlIHVwZGF0ZWQgcGVyIG9iamVjdC5cclxuXHRcdCAqXHJcblx0XHQgKiBAdHlwZSB7U3RyaW5nfVxyXG5cdFx0ICogQGRlZmF1bHQgJ29iamVjdCdcclxuXHRcdCAqL1xyXG5cdFx0dGhpcy51cGRhdGVUeXBlID0gTm9kZVVwZGF0ZVR5cGUuT0JKRUNUO1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogT3ZlcndyaXR0ZW4gc2luY2UgdmVsb2NpdHkgbm9kZXMgc2F2ZSBkYXRhIGFmdGVyIHRoZSB1cGRhdGUuXHJcblx0XHQgKlxyXG5cdFx0ICogQHR5cGUge1N0cmluZ31cclxuXHRcdCAqIEBkZWZhdWx0ICdvYmplY3QnXHJcblx0XHQgKi9cclxuXHRcdHRoaXMudXBkYXRlQWZ0ZXJUeXBlID0gTm9kZVVwZGF0ZVR5cGUuT0JKRUNUO1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogVW5pZm9ybSBub2RlIHJlcHJlc2VudGluZyB0aGUgcHJldmlvdXMgbW9kZWwgbWF0cml4IGluIHdvcmxkIHNwYWNlLlxyXG5cdFx0ICpcclxuXHRcdCAqIEB0eXBlIHtVbmlmb3JtTm9kZTxtYXQ0Pn1cclxuXHRcdCAqIEBkZWZhdWx0IG51bGxcclxuXHRcdCAqL1xyXG5cdFx0dGhpcy5wcmV2aW91c01vZGVsV29ybGRNYXRyaXggPSB1bmlmb3JtKCBuZXcgTWF0cml4NCgpICk7XHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBVbmlmb3JtIG5vZGUgcmVwcmVzZW50aW5nIHRoZSBwcmV2aW91cyBwcm9qZWN0aW9uIG1hdHJpeC5cclxuXHRcdCAqXHJcblx0XHQgKiBAdHlwZSB7VW5pZm9ybU5vZGU8bWF0ND59XHJcblx0XHQgKiBAZGVmYXVsdCBudWxsXHJcblx0XHQgKi9cclxuXHRcdHRoaXMucHJldmlvdXNQcm9qZWN0aW9uTWF0cml4ID0gdW5pZm9ybSggbmV3IE1hdHJpeDQoKSApLnNldEdyb3VwKCByZW5kZXJHcm91cCApO1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogVW5pZm9ybSBub2RlIHJlcHJlc2VudGluZyB0aGUgcHJldmlvdXMgdmlldyBtYXRyaXguXHJcblx0XHQgKlxyXG5cdFx0ICogQHR5cGUge1VuaWZvcm1Ob2RlPG1hdDQ+fVxyXG5cdFx0ICogQGRlZmF1bHQgbnVsbFxyXG5cdFx0ICovXHJcblx0XHR0aGlzLnByZXZpb3VzQ2FtZXJhVmlld01hdHJpeCA9IHVuaWZvcm0oIG5ldyBNYXRyaXg0KCkgKTtcclxuXHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBTZXRzIHRoZSBnaXZlbiBwcm9qZWN0aW9uIG1hdHJpeC5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7TWF0cml4NH0gcHJvamVjdGlvbk1hdHJpeCAtIFRoZSBwcm9qZWN0aW9uIG1hdHJpeCB0byBzZXQuXHJcblx0ICovXHJcblx0c2V0UHJvamVjdGlvbk1hdHJpeCggcHJvamVjdGlvbk1hdHJpeCApIHtcclxuXHJcblx0XHR0aGlzLnByb2plY3Rpb25NYXRyaXggPSBwcm9qZWN0aW9uTWF0cml4O1xyXG5cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFVwZGF0ZXMgdmVsb2NpdHkgc3BlY2lmaWMgdW5pZm9ybXMuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge05vZGVGcmFtZX0gZnJhbWUgLSBBIHJlZmVyZW5jZSB0byB0aGUgY3VycmVudCBub2RlIGZyYW1lLlxyXG5cdCAqL1xyXG5cdHVwZGF0ZSggeyBmcmFtZUlkLCBjYW1lcmEsIG9iamVjdCB9ICkge1xyXG5cclxuXHRcdGNvbnN0IHByZXZpb3VzTW9kZWxNYXRyaXggPSBnZXRQcmV2aW91c01hdHJpeCggb2JqZWN0ICk7XHJcblxyXG5cdFx0dGhpcy5wcmV2aW91c01vZGVsV29ybGRNYXRyaXgudmFsdWUuY29weSggcHJldmlvdXNNb2RlbE1hdHJpeCApO1xyXG5cclxuXHRcdC8vXHJcblxyXG5cdFx0Y29uc3QgY2FtZXJhRGF0YSA9IGdldERhdGEoIGNhbWVyYSApO1xyXG5cclxuXHRcdGlmICggY2FtZXJhRGF0YS5mcmFtZUlkICE9PSBmcmFtZUlkICkge1xyXG5cclxuXHRcdFx0Y2FtZXJhRGF0YS5mcmFtZUlkID0gZnJhbWVJZDtcclxuXHJcblx0XHRcdGlmICggY2FtZXJhRGF0YS5wcmV2aW91c1Byb2plY3Rpb25NYXRyaXggPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0Y2FtZXJhRGF0YS5wcmV2aW91c1Byb2plY3Rpb25NYXRyaXggPSBuZXcgTWF0cml4NCgpO1xyXG5cdFx0XHRcdGNhbWVyYURhdGEucHJldmlvdXNDYW1lcmFWaWV3TWF0cml4ID0gbmV3IE1hdHJpeDQoKTtcclxuXHJcblx0XHRcdFx0Y2FtZXJhRGF0YS5jdXJyZW50UHJvamVjdGlvbk1hdHJpeCA9IG5ldyBNYXRyaXg0KCk7XHJcblx0XHRcdFx0Y2FtZXJhRGF0YS5jdXJyZW50Q2FtZXJhVmlld01hdHJpeCA9IG5ldyBNYXRyaXg0KCk7XHJcblxyXG5cdFx0XHRcdGNhbWVyYURhdGEucHJldmlvdXNQcm9qZWN0aW9uTWF0cml4LmNvcHkoIHRoaXMucHJvamVjdGlvbk1hdHJpeCB8fCBjYW1lcmEucHJvamVjdGlvbk1hdHJpeCApO1xyXG5cdFx0XHRcdGNhbWVyYURhdGEucHJldmlvdXNDYW1lcmFWaWV3TWF0cml4LmNvcHkoIGNhbWVyYS5tYXRyaXhXb3JsZEludmVyc2UgKTtcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdGNhbWVyYURhdGEucHJldmlvdXNQcm9qZWN0aW9uTWF0cml4LmNvcHkoIGNhbWVyYURhdGEuY3VycmVudFByb2plY3Rpb25NYXRyaXggKTtcclxuXHRcdFx0XHRjYW1lcmFEYXRhLnByZXZpb3VzQ2FtZXJhVmlld01hdHJpeC5jb3B5KCBjYW1lcmFEYXRhLmN1cnJlbnRDYW1lcmFWaWV3TWF0cml4ICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRjYW1lcmFEYXRhLmN1cnJlbnRQcm9qZWN0aW9uTWF0cml4LmNvcHkoIHRoaXMucHJvamVjdGlvbk1hdHJpeCB8fCBjYW1lcmEucHJvamVjdGlvbk1hdHJpeCApO1xyXG5cdFx0XHRjYW1lcmFEYXRhLmN1cnJlbnRDYW1lcmFWaWV3TWF0cml4LmNvcHkoIGNhbWVyYS5tYXRyaXhXb3JsZEludmVyc2UgKTtcclxuXHJcblx0XHRcdHRoaXMucHJldmlvdXNQcm9qZWN0aW9uTWF0cml4LnZhbHVlLmNvcHkoIGNhbWVyYURhdGEucHJldmlvdXNQcm9qZWN0aW9uTWF0cml4ICk7XHJcblx0XHRcdHRoaXMucHJldmlvdXNDYW1lcmFWaWV3TWF0cml4LnZhbHVlLmNvcHkoIGNhbWVyYURhdGEucHJldmlvdXNDYW1lcmFWaWV3TWF0cml4ICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIE92ZXJ3cml0dGVuIHRvIHVwZGF0ZWQgdmVsb2NpdHkgc3BlY2lmaWMgdW5pZm9ybXMuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge05vZGVGcmFtZX0gZnJhbWUgLSBBIHJlZmVyZW5jZSB0byB0aGUgY3VycmVudCBub2RlIGZyYW1lLlxyXG5cdCAqL1xyXG5cdHVwZGF0ZUFmdGVyKCB7IG9iamVjdCB9ICkge1xyXG5cclxuXHRcdGdldFByZXZpb3VzTWF0cml4KCBvYmplY3QgKS5jb3B5KCBvYmplY3QubWF0cml4V29ybGQgKTtcclxuXHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBJbXBsZW1lbnRzIHRoZSB2ZWxvY2l0eSBjb21wdXRhdGlvbiBiYXNlZCBvbiB0aGUgcHJldmlvdXMgYW5kIGN1cnJlbnQgdmVydGV4IGRhdGEuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge05vZGVCdWlsZGVyfSBidWlsZGVyIC0gQSByZWZlcmVuY2UgdG8gdGhlIGN1cnJlbnQgbm9kZSBidWlsZGVyLlxyXG5cdCAqIEByZXR1cm4ge05vZGU8dmVjMj59IFRoZSBtb3Rpb24gdmVjdG9yLlxyXG5cdCAqL1xyXG5cdHNldHVwKCAvKmJ1aWxkZXIqLyApIHtcclxuXHJcblx0XHRjb25zdCBwcm9qZWN0aW9uTWF0cml4ID0gKCB0aGlzLnByb2plY3Rpb25NYXRyaXggPT09IG51bGwgKSA/IGNhbWVyYVByb2plY3Rpb25NYXRyaXggOiB1bmlmb3JtKCB0aGlzLnByb2plY3Rpb25NYXRyaXggKTtcclxuXHJcblx0XHRjb25zdCBwcmV2aW91c01vZGVsVmlld01hdHJpeCA9IHRoaXMucHJldmlvdXNDYW1lcmFWaWV3TWF0cml4Lm11bCggdGhpcy5wcmV2aW91c01vZGVsV29ybGRNYXRyaXggKTtcclxuXHJcblx0XHRjb25zdCBjbGlwUG9zaXRpb25DdXJyZW50ID0gcHJvamVjdGlvbk1hdHJpeC5tdWwoIG1vZGVsVmlld01hdHJpeCApLm11bCggcG9zaXRpb25Mb2NhbCApO1xyXG5cdFx0Y29uc3QgY2xpcFBvc2l0aW9uUHJldmlvdXMgPSB0aGlzLnByZXZpb3VzUHJvamVjdGlvbk1hdHJpeC5tdWwoIHByZXZpb3VzTW9kZWxWaWV3TWF0cml4ICkubXVsKCBwb3NpdGlvblByZXZpb3VzICk7XHJcblxyXG5cdFx0Y29uc3QgbmRjUG9zaXRpb25DdXJyZW50ID0gY2xpcFBvc2l0aW9uQ3VycmVudC54eS5kaXYoIGNsaXBQb3NpdGlvbkN1cnJlbnQudyApO1xyXG5cdFx0Y29uc3QgbmRjUG9zaXRpb25QcmV2aW91cyA9IGNsaXBQb3NpdGlvblByZXZpb3VzLnh5LmRpdiggY2xpcFBvc2l0aW9uUHJldmlvdXMudyApO1xyXG5cclxuXHRcdGNvbnN0IHZlbG9jaXR5ID0gc3ViKCBuZGNQb3NpdGlvbkN1cnJlbnQsIG5kY1Bvc2l0aW9uUHJldmlvdXMgKTtcclxuXHJcblx0XHRyZXR1cm4gdmVsb2NpdHk7XHJcblxyXG5cdH1cclxuXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdldERhdGEoIG9iamVjdCApIHtcclxuXHJcblx0bGV0IG9iamVjdERhdGEgPSBfb2JqZWN0RGF0YS5nZXQoIG9iamVjdCApO1xyXG5cclxuXHRpZiAoIG9iamVjdERhdGEgPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRvYmplY3REYXRhID0ge307XHJcblx0XHRfb2JqZWN0RGF0YS5zZXQoIG9iamVjdCwgb2JqZWN0RGF0YSApO1xyXG5cclxuXHR9XHJcblxyXG5cdHJldHVybiBvYmplY3REYXRhO1xyXG5cclxufVxyXG5cclxuZnVuY3Rpb24gZ2V0UHJldmlvdXNNYXRyaXgoIG9iamVjdCwgaW5kZXggPSAwICkge1xyXG5cclxuXHRjb25zdCBvYmplY3REYXRhID0gZ2V0RGF0YSggb2JqZWN0ICk7XHJcblxyXG5cdGxldCBtYXRyaXggPSBvYmplY3REYXRhWyBpbmRleCBdO1xyXG5cclxuXHRpZiAoIG1hdHJpeCA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdG9iamVjdERhdGFbIGluZGV4IF0gPSBtYXRyaXggPSBuZXcgTWF0cml4NCgpO1xyXG5cclxuXHR9XHJcblxyXG5cdHJldHVybiBtYXRyaXg7XHJcblxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBWZWxvY2l0eU5vZGU7XHJcblxyXG4vKipcclxuICogVFNMIG9iamVjdCB0aGF0IHJlcHJlc2VudHMgdGhlIHZlbG9jaXR5IG9mIGEgcmVuZGVyIHBhc3MuXHJcbiAqXHJcbiAqIEB0eXBlIHtWZWxvY2l0eU5vZGV9XHJcbiAqL1xyXG5leHBvcnQgY29uc3QgdmVsb2NpdHkgPSAvKkBfX1BVUkVfXyovIG5vZGVJbW11dGFibGUoIFZlbG9jaXR5Tm9kZSApO1xyXG4iLCJpbXBvcnQgeyBGbiwgdmVjNCB9IGZyb20gJy4uL3RzbC9UU0xCYXNlLmpzJztcclxuaW1wb3J0IHsgbWl4LCBtaW4sIHN0ZXAgfSBmcm9tICcuLi9tYXRoL01hdGhOb2RlLmpzJztcclxuXHJcbmV4cG9ydCBjb25zdCBibGVuZEJ1cm4gPSAvKkBfX1BVUkVfXyovIEZuKCAoIFsgYmFzZSwgYmxlbmQgXSApID0+IHtcclxuXHJcblx0cmV0dXJuIG1pbiggMS4wLCBiYXNlLm9uZU1pbnVzKCkuZGl2KCBibGVuZCApICkub25lTWludXMoKTtcclxuXHJcbn0gKS5zZXRMYXlvdXQoIHtcclxuXHRuYW1lOiAnYmxlbmRCdXJuJyxcclxuXHR0eXBlOiAndmVjMycsXHJcblx0aW5wdXRzOiBbXHJcblx0XHR7IG5hbWU6ICdiYXNlJywgdHlwZTogJ3ZlYzMnIH0sXHJcblx0XHR7IG5hbWU6ICdibGVuZCcsIHR5cGU6ICd2ZWMzJyB9XHJcblx0XVxyXG59ICk7XHJcblxyXG5leHBvcnQgY29uc3QgYmxlbmREb2RnZSA9IC8qQF9fUFVSRV9fKi8gRm4oICggWyBiYXNlLCBibGVuZCBdICkgPT4ge1xyXG5cclxuXHRyZXR1cm4gbWluKCBiYXNlLmRpdiggYmxlbmQub25lTWludXMoKSApLCAxLjAgKTtcclxuXHJcbn0gKS5zZXRMYXlvdXQoIHtcclxuXHRuYW1lOiAnYmxlbmREb2RnZScsXHJcblx0dHlwZTogJ3ZlYzMnLFxyXG5cdGlucHV0czogW1xyXG5cdFx0eyBuYW1lOiAnYmFzZScsIHR5cGU6ICd2ZWMzJyB9LFxyXG5cdFx0eyBuYW1lOiAnYmxlbmQnLCB0eXBlOiAndmVjMycgfVxyXG5cdF1cclxufSApO1xyXG5cclxuZXhwb3J0IGNvbnN0IGJsZW5kU2NyZWVuID0gLypAX19QVVJFX18qLyBGbiggKCBbIGJhc2UsIGJsZW5kIF0gKSA9PiB7XHJcblxyXG5cdHJldHVybiBiYXNlLm9uZU1pbnVzKCkubXVsKCBibGVuZC5vbmVNaW51cygpICkub25lTWludXMoKTtcclxuXHJcbn0gKS5zZXRMYXlvdXQoIHtcclxuXHRuYW1lOiAnYmxlbmRTY3JlZW4nLFxyXG5cdHR5cGU6ICd2ZWMzJyxcclxuXHRpbnB1dHM6IFtcclxuXHRcdHsgbmFtZTogJ2Jhc2UnLCB0eXBlOiAndmVjMycgfSxcclxuXHRcdHsgbmFtZTogJ2JsZW5kJywgdHlwZTogJ3ZlYzMnIH1cclxuXHRdXHJcbn0gKTtcclxuXHJcbmV4cG9ydCBjb25zdCBibGVuZE92ZXJsYXkgPSAvKkBfX1BVUkVfXyovIEZuKCAoIFsgYmFzZSwgYmxlbmQgXSApID0+IHtcclxuXHJcblx0cmV0dXJuIG1peCggYmFzZS5tdWwoIDIuMCApLm11bCggYmxlbmQgKSwgYmFzZS5vbmVNaW51cygpLm11bCggMi4wICkubXVsKCBibGVuZC5vbmVNaW51cygpICkub25lTWludXMoKSwgc3RlcCggMC41LCBiYXNlICkgKTtcclxuXHJcbn0gKS5zZXRMYXlvdXQoIHtcclxuXHRuYW1lOiAnYmxlbmRPdmVybGF5JyxcclxuXHR0eXBlOiAndmVjMycsXHJcblx0aW5wdXRzOiBbXHJcblx0XHR7IG5hbWU6ICdiYXNlJywgdHlwZTogJ3ZlYzMnIH0sXHJcblx0XHR7IG5hbWU6ICdibGVuZCcsIHR5cGU6ICd2ZWMzJyB9XHJcblx0XVxyXG59ICk7XHJcblxyXG5leHBvcnQgY29uc3QgYmxlbmRDb2xvciA9IC8qQF9fUFVSRV9fKi8gRm4oICggWyBiYXNlLCBibGVuZCBdICkgPT4ge1xyXG5cclxuXHRjb25zdCBvdXRBbHBoYSA9IGJsZW5kLmEuYWRkKCBiYXNlLmEubXVsKCBibGVuZC5hLm9uZU1pbnVzKCkgKSApO1xyXG5cclxuXHRyZXR1cm4gdmVjNCggYmxlbmQucmdiLm11bCggYmxlbmQuYSApLmFkZCggYmFzZS5yZ2IubXVsKCBiYXNlLmEgKS5tdWwoIGJsZW5kLmEub25lTWludXMoKSApICkuZGl2KCBvdXRBbHBoYSApLCBvdXRBbHBoYSApO1xyXG5cclxufSApLnNldExheW91dCgge1xyXG5cdG5hbWU6ICdibGVuZENvbG9yJyxcclxuXHR0eXBlOiAndmVjNCcsXHJcblx0aW5wdXRzOiBbXHJcblx0XHR7IG5hbWU6ICdiYXNlJywgdHlwZTogJ3ZlYzQnIH0sXHJcblx0XHR7IG5hbWU6ICdibGVuZCcsIHR5cGU6ICd2ZWM0JyB9XHJcblx0XVxyXG59ICk7XHJcblxyXG4vLyBkZXByZWNhdGVkXHJcblxyXG5leHBvcnQgY29uc3QgYnVybiA9ICggLi4ucGFyYW1zICkgPT4geyAvLyBAZGVwcmVjYXRlZCwgcjE3MVxyXG5cclxuXHRjb25zb2xlLndhcm4oICdUSFJFRS5UU0w6IFwiYnVyblwiIGhhcyBiZWVuIHJlbmFtZWQuIFVzZSBcImJsZW5kQnVyblwiIGluc3RlYWQuJyApO1xyXG5cdHJldHVybiBibGVuZEJ1cm4oIHBhcmFtcyApO1xyXG5cclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBkb2RnZSA9ICggLi4ucGFyYW1zICkgPT4geyAvLyBAZGVwcmVjYXRlZCwgcjE3MVxyXG5cclxuXHRjb25zb2xlLndhcm4oICdUSFJFRS5UU0w6IFwiZG9kZ2VcIiBoYXMgYmVlbiByZW5hbWVkLiBVc2UgXCJibGVuZERvZGdlXCIgaW5zdGVhZC4nICk7XHJcblx0cmV0dXJuIGJsZW5kRG9kZ2UoIHBhcmFtcyApO1xyXG5cclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBzY3JlZW4gPSAoIC4uLnBhcmFtcyApID0+IHsgLy8gQGRlcHJlY2F0ZWQsIHIxNzFcclxuXHJcblx0Y29uc29sZS53YXJuKCAnVEhSRUUuVFNMOiBcInNjcmVlblwiIGhhcyBiZWVuIHJlbmFtZWQuIFVzZSBcImJsZW5kU2NyZWVuXCIgaW5zdGVhZC4nICk7XHJcblx0cmV0dXJuIGJsZW5kU2NyZWVuKCBwYXJhbXMgKTtcclxuXHJcbn07XHJcblxyXG5leHBvcnQgY29uc3Qgb3ZlcmxheSA9ICggLi4ucGFyYW1zICkgPT4geyAvLyBAZGVwcmVjYXRlZCwgcjE3MVxyXG5cclxuXHRjb25zb2xlLndhcm4oICdUSFJFRS5UU0w6IFwib3ZlcmxheVwiIGhhcyBiZWVuIHJlbmFtZWQuIFVzZSBcImJsZW5kT3ZlcmxheVwiIGluc3RlYWQuJyApO1xyXG5cdHJldHVybiBibGVuZE92ZXJsYXkoIHBhcmFtcyApO1xyXG5cclxufTtcclxuIiwiaW1wb3J0IHsgZG90LCBtYXgsIG1peCB9IGZyb20gJy4uL21hdGgvTWF0aE5vZGUuanMnO1xyXG5pbXBvcnQgeyBhZGQgfSBmcm9tICcuLi9tYXRoL09wZXJhdG9yTm9kZS5qcyc7XHJcbmltcG9ydCB7IEZuLCBJZiwgZmxvYXQsIHZlYzMsIHZlYzQgfSBmcm9tICcuLi90c2wvVFNMQmFzZS5qcyc7XHJcbmltcG9ydCB7IENvbG9yTWFuYWdlbWVudCB9IGZyb20gJy4uLy4uL21hdGgvQ29sb3JNYW5hZ2VtZW50LmpzJztcclxuaW1wb3J0IHsgVmVjdG9yMyB9IGZyb20gJy4uLy4uL21hdGgvVmVjdG9yMy5qcyc7XHJcbmltcG9ydCB7IExpbmVhclNSR0JDb2xvclNwYWNlIH0gZnJvbSAnLi4vLi4vY29uc3RhbnRzLmpzJztcclxuXHJcbi8qKiBAbW9kdWxlIENvbG9yQWRqdXN0bWVudCAqKi9cclxuXHJcbi8qKlxyXG4gKiBDb21wdXRlcyBhIGdyYXlzY2FsZSB2YWx1ZSBmb3IgdGhlIGdpdmVuIFJHQiBjb2xvciB2YWx1ZS5cclxuICpcclxuICogQG1ldGhvZFxyXG4gKiBAcGFyYW0ge05vZGU8dmVjMz59IGNvbG9yIC0gVGhlIGNvbG9yIHZhbHVlIHRvIGNvbXB1dGUgdGhlIGdyYXlzY2FsZSBmb3IuXHJcbiAqIEByZXR1cm4ge05vZGU8dmVjMz59IFRoZSBncmF5c2NhbGUgY29sb3IuXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgZ3JheXNjYWxlID0gLypAX19QVVJFX18qLyBGbiggKCBbIGNvbG9yIF0gKSA9PiB7XHJcblxyXG5cdHJldHVybiBsdW1pbmFuY2UoIGNvbG9yLnJnYiApO1xyXG5cclxufSApO1xyXG5cclxuLyoqXHJcbiAqIFN1cGVyLXNhdHVyYXRlcyBvciBkZXNhdHVyYXRlcyB0aGUgZ2l2ZW4gUkdCIGNvbG9yLlxyXG4gKlxyXG4gKiBAbWV0aG9kXHJcbiAqIEBwYXJhbSB7Tm9kZTx2ZWMzPn0gY29sb3IgLSBUaGUgaW5wdXQgY29sb3IuXHJcbiAqIEBwYXJhbSB7Tm9kZTxmbG9hdD59IFthZGp1c3RtZW50PTFdIC0gU3BlY2lmaWVzIHRoZSBhbW91bnQgb2YgdGhlIGNvbnZlcnNpb24uIEEgdmFsdWUgdW5kZXIgYDFgIGRlc2F0dXJhdGVzIHRoZSBjb2xvciwgYSB2YWx1ZSBvdmVyIGAxYCBzdXBlci1zYXR1cmF0ZXMgaXQuXHJcbiAqIEByZXR1cm4ge05vZGU8dmVjMz59IFRoZSBzYXR1cmF0ZWQgY29sb3IuXHJcbiAqL1xyXG5leHBvcnQgY29uc3Qgc2F0dXJhdGlvbiA9IC8qQF9fUFVSRV9fKi8gRm4oICggWyBjb2xvciwgYWRqdXN0bWVudCA9IGZsb2F0KCAxICkgXSApID0+IHtcclxuXHJcblx0cmV0dXJuIGFkanVzdG1lbnQubWl4KCBsdW1pbmFuY2UoIGNvbG9yLnJnYiApLCBjb2xvci5yZ2IgKTtcclxuXHJcbn0gKTtcclxuXHJcbi8qKlxyXG4gKiBTZWxlY3RpdmVseSBlbmhhbmNlIHRoZSBpbnRlbnNpdHkgb2YgbGVzcyBzYXR1cmF0ZWQgUkdCIGNvbG9ycy4gQ2FuIHJlc3VsdFxyXG4gKiBpbiBhIG1vcmUgbmF0dXJhbCBhbmQgdmlzdWFsbHkgYXBwZWFsaW5nIGltYWdlIHdpdGggZW5oYW5jZWQgY29sb3IgZGVwdGhcclxuICogY29tcGFyZWQgdG8ge0BsaW5rIENvbG9yQWRqdXN0bWVudCNzYXR1cmF0aW9ufS5cclxuICpcclxuICogQG1ldGhvZFxyXG4gKiBAcGFyYW0ge05vZGU8dmVjMz59IGNvbG9yIC0gVGhlIGlucHV0IGNvbG9yLlxyXG4gKiBAcGFyYW0ge05vZGU8ZmxvYXQ+fSBbYWRqdXN0bWVudD0xXSAtIENvbnRyb2xzIHRoZSBpbnRlbnNpdHkgb2YgdGhlIHZpYnJhbmNlIGVmZmVjdC5cclxuICogQHJldHVybiB7Tm9kZTx2ZWMzPn0gVGhlIHVwZGF0ZWQgY29sb3IuXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgdmlicmFuY2UgPSAvKkBfX1BVUkVfXyovIEZuKCAoIFsgY29sb3IsIGFkanVzdG1lbnQgPSBmbG9hdCggMSApIF0gKSA9PiB7XHJcblxyXG5cdGNvbnN0IGF2ZXJhZ2UgPSBhZGQoIGNvbG9yLnIsIGNvbG9yLmcsIGNvbG9yLmIgKS5kaXYoIDMuMCApO1xyXG5cclxuXHRjb25zdCBteCA9IGNvbG9yLnIubWF4KCBjb2xvci5nLm1heCggY29sb3IuYiApICk7XHJcblx0Y29uc3QgYW10ID0gbXguc3ViKCBhdmVyYWdlICkubXVsKCBhZGp1c3RtZW50ICkubXVsKCAtIDMuMCApO1xyXG5cclxuXHRyZXR1cm4gbWl4KCBjb2xvci5yZ2IsIG14LCBhbXQgKTtcclxuXHJcbn0gKTtcclxuXHJcbi8qKlxyXG4gKiBVcGRhdGVzIHRoZSBodWUgY29tcG9uZW50IG9mIHRoZSBnaXZlbiBSR0IgY29sb3Igd2hpbGUgcHJlc2VydmluZyBpdHMgbHVtaW5hbmNlIGFuZCBzYXR1cmF0aW9uLlxyXG4gKlxyXG4gKiBAbWV0aG9kXHJcbiAqIEBwYXJhbSB7Tm9kZTx2ZWMzPn0gY29sb3IgLSBUaGUgaW5wdXQgY29sb3IuXHJcbiAqIEBwYXJhbSB7Tm9kZTxmbG9hdD59IFthZGp1c3RtZW50PTFdIC0gRGVmaW5lcyB0aGUgZGVncmVlIG9mIGh1ZSByb3RhdGlvbiBpbiByYWRpYW5zLiBBIHBvc2l0aXZlIHZhbHVlIHJvdGF0ZXMgdGhlIGh1ZSBjbG9ja3dpc2UsIHdoaWxlIGEgbmVnYXRpdmUgdmFsdWUgcm90YXRlcyBpdCBjb3VudGVyY2xvY2t3aXNlLlxyXG4gKiBAcmV0dXJuIHtOb2RlPHZlYzM+fSBUaGUgdXBkYXRlZCBjb2xvci5cclxuICovXHJcbmV4cG9ydCBjb25zdCBodWUgPSAvKkBfX1BVUkVfXyovIEZuKCAoIFsgY29sb3IsIGFkanVzdG1lbnQgPSBmbG9hdCggMSApIF0gKSA9PiB7XHJcblxyXG5cdGNvbnN0IGsgPSB2ZWMzKCAwLjU3NzM1LCAwLjU3NzM1LCAwLjU3NzM1ICk7XHJcblxyXG5cdGNvbnN0IGNvc0FuZ2xlID0gYWRqdXN0bWVudC5jb3MoKTtcclxuXHJcblx0cmV0dXJuIHZlYzMoIGNvbG9yLnJnYi5tdWwoIGNvc0FuZ2xlICkuYWRkKCBrLmNyb3NzKCBjb2xvci5yZ2IgKS5tdWwoIGFkanVzdG1lbnQuc2luKCkgKS5hZGQoIGsubXVsKCBkb3QoIGssIGNvbG9yLnJnYiApLm11bCggY29zQW5nbGUub25lTWludXMoKSApICkgKSApICk7XHJcblxyXG59ICk7XHJcblxyXG4vKipcclxuICogQ29tcHV0ZXMgdGhlIGx1bWluYW5jZSBmb3IgdGhlIGdpdmVuIFJHQiBjb2xvciB2YWx1ZS5cclxuICpcclxuICogQG1ldGhvZFxyXG4gKiBAcGFyYW0ge05vZGU8dmVjMz59IGNvbG9yIC0gVGhlIGNvbG9yIHZhbHVlIHRvIGNvbXB1dGUgdGhlIGx1bWluYW5jZSBmb3IuXHJcbiAqIEBwYXJhbSB7Tm9kZTx2ZWMzPj99IGx1bWluYW5jZUNvZWZmaWNpZW50cyAtIFRoZSBsdW1pbmFuY2UgY29lZmZpY2llbnRzLiBCeSBkZWZhdWx0IHByZWRlZmluZWQgdmFsdWVzIG9mIHRoZSBjdXJyZW50IHdvcmtpbmcgY29sb3Igc3BhY2UgYXJlIHVzZWQuXHJcbiAqIEByZXR1cm4ge05vZGU8dmVjMz59IFRoZSBsdW1pbmFuY2UuXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgbHVtaW5hbmNlID0gKFxyXG5cdGNvbG9yLFxyXG5cdGx1bWluYW5jZUNvZWZmaWNpZW50cyA9IHZlYzMoIENvbG9yTWFuYWdlbWVudC5nZXRMdW1pbmFuY2VDb2VmZmljaWVudHMoIG5ldyBWZWN0b3IzKCkgKSApXHJcbikgPT4gZG90KCBjb2xvciwgbHVtaW5hbmNlQ29lZmZpY2llbnRzICk7XHJcblxyXG4vKipcclxuICogQ29sb3IgRGVjaXNpb24gTGlzdCAoQ0RMKSB2MS4yXHJcbiAqXHJcbiAqIENvbXBhY3QgcmVwcmVzZW50YXRpb24gb2YgY29sb3IgZ3JhZGluZyBpbmZvcm1hdGlvbiwgZGVmaW5lZCBieSBzbG9wZSwgb2Zmc2V0LCBwb3dlciwgYW5kXHJcbiAqIHNhdHVyYXRpb24uIFRoZSBDREwgc2hvdWxkIGJlIHR5cGljYWxseSBiZSBnaXZlbiBpbnB1dCBpbiBhIGxvZyBzcGFjZSAoc3VjaCBhcyBMb2dDLCBBQ0VTY2MsXHJcbiAqIG9yIEFnWCBMb2cpLCBhbmQgd2lsbCByZXR1cm4gb3V0cHV0IGluIHRoZSBzYW1lIHNwYWNlLiBPdXRwdXQgbWF5IHJlcXVpcmUgY2xhbXBpbmcgPj0wLlxyXG4gKlxyXG4gKiBAbWV0aG9kXHJcbiAqIEBwYXJhbSB7Tm9kZTx2ZWM0Pn0gY29sb3IgSW5wdXQgKC1JbmZpbml0eSA8IGlucHV0IDwgK0luZmluaXR5KVxyXG4gKiBAcGFyYW0ge05vZGU8dmVjMz59IHNsb3BlIFNsb3BlICgwIOKJpCBzbG9wZSA8ICtJbmZpbml0eSlcclxuICogQHBhcmFtIHtOb2RlPHZlYzM+fSBvZmZzZXQgT2Zmc2V0ICgtSW5maW5pdHkgPCBvZmZzZXQgPCArSW5maW5pdHk7IHR5cGljYWxseSAtMSA8IG9mZnNldCA8IDEpXHJcbiAqIEBwYXJhbSB7Tm9kZTx2ZWMzPn0gcG93ZXIgUG93ZXIgKDAgPCBwb3dlciA8ICtJbmZpbml0eSlcclxuICogQHBhcmFtIHtOb2RlPGZsb2F0Pn0gc2F0dXJhdGlvbiBTYXR1cmF0aW9uICgwIOKJpCBzYXR1cmF0aW9uIDwgK0luZmluaXR5OyB0eXBpY2FsbHkgMCDiiaQgc2F0dXJhdGlvbiA8IDQpXHJcbiAqIEBwYXJhbSB7Tm9kZTx2ZWMzPn0gbHVtaW5hbmNlQ29lZmZpY2llbnRzIEx1bWluYW5jZSBjb2VmZmljaWVudHMgZm9yIHNhdHVyYXRpb24gdGVybSwgdHlwaWNhbGx5IFJlYy4gNzA5XHJcbiAqIEByZXR1cm4ge05vZGU8dmVjND59IE91dHB1dCwgLUluZmluaXR5IDwgb3V0cHV0IDwgK0luZmluaXR5XHJcbiAqXHJcbiAqIFJlZmVyZW5jZXM6XHJcbiAqIC0gQVNDIENETCB2MS4yXHJcbiAqIC0ge0BsaW5rIGh0dHBzOi8vYmxlbmRlci5zdGFja2V4Y2hhbmdlLmNvbS9hLzU1MjM5LzQzOTMwfVxyXG4gKiAtIHtAbGluayBodHRwczovL2RvY3MuYWNlc2NlbnRyYWwuY29tL3NwZWNpZmljYXRpb25zL2FjZXNjYy99XHJcbiAqL1xyXG5leHBvcnQgY29uc3QgY2RsID0gLypAX19QVVJFX18qLyBGbiggKCBbXHJcblx0Y29sb3IsXHJcblx0c2xvcGUgPSB2ZWMzKCAxICksXHJcblx0b2Zmc2V0ID0gdmVjMyggMCApLFxyXG5cdHBvd2VyID0gdmVjMyggMSApLFxyXG5cdHNhdHVyYXRpb24gPSBmbG9hdCggMSApLFxyXG5cdC8vIEFTQyBDREwgdjEuMiBleHBsaWNpdGx5IHJlcXVpcmVzIFJlYy4gNzA5IGx1bWluYW5jZSBjb2VmZmljaWVudHMuXHJcblx0bHVtaW5hbmNlQ29lZmZpY2llbnRzID0gdmVjMyggQ29sb3JNYW5hZ2VtZW50LmdldEx1bWluYW5jZUNvZWZmaWNpZW50cyggbmV3IFZlY3RvcjMoKSwgTGluZWFyU1JHQkNvbG9yU3BhY2UgKSApXHJcbl0gKSA9PiB7XHJcblxyXG5cdC8vIE5PVEU6IFRoZSBBU0MgQ0RMIHYxLjIgZGVmaW5lcyBhIFswLCAxXSBjbGFtcCBvbiB0aGUgc2xvcGUrb2Zmc2V0IHRlcm0sIGFuZCBhbm90aGVyIG9uIHRoZVxyXG5cdC8vIHNhdHVyYXRpb24gdGVybS4gUGVyIHRoZSBBQ0VTY2Mgc3BlY2lmaWNhdGlvbiBhbmQgRmlsYW1lbnQsIGxpbWl0cyBtYXkgYmUgb21pdHRlZCB0byBzdXBwb3J0XHJcblx0Ly8gdmFsdWVzIG91dHNpZGUgWzAsIDFdLCByZXF1aXJpbmcgYSB3b3JrYXJvdW5kIGZvciBuZWdhdGl2ZSB2YWx1ZXMgaW4gdGhlIHBvd2VyIGV4cHJlc3Npb24uXHJcblxyXG5cdGNvbnN0IGx1bWEgPSBjb2xvci5yZ2IuZG90KCB2ZWMzKCBsdW1pbmFuY2VDb2VmZmljaWVudHMgKSApO1xyXG5cclxuXHRjb25zdCB2ID0gbWF4KCBjb2xvci5yZ2IubXVsKCBzbG9wZSApLmFkZCggb2Zmc2V0ICksIDAuMCApLnRvVmFyKCk7XHJcblx0Y29uc3QgcHYgPSB2LnBvdyggcG93ZXIgKS50b1ZhcigpO1xyXG5cclxuXHRJZiggdi5yLmdyZWF0ZXJUaGFuKCAwLjAgKSwgKCkgPT4geyB2LnIuYXNzaWduKCBwdi5yICk7IH0gKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxyXG5cdElmKCB2LmcuZ3JlYXRlclRoYW4oIDAuMCApLCAoKSA9PiB7IHYuZy5hc3NpZ24oIHB2LmcgKTsgfSApOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXHJcblx0SWYoIHYuYi5ncmVhdGVyVGhhbiggMC4wICksICgpID0+IHsgdi5iLmFzc2lnbiggcHYuYiApOyB9ICk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcclxuXHJcblx0di5hc3NpZ24oIGx1bWEuYWRkKCB2LnN1YiggbHVtYSApLm11bCggc2F0dXJhdGlvbiApICkgKTtcclxuXHJcblx0cmV0dXJuIHZlYzQoIHYucmdiLCBjb2xvci5hICk7XHJcblxyXG59ICk7XHJcbiIsImltcG9ydCBUZW1wTm9kZSBmcm9tICcuLi9jb3JlL1RlbXBOb2RlLmpzJztcclxuaW1wb3J0IHsgbm9kZVByb3h5IH0gZnJvbSAnLi4vdHNsL1RTTEJhc2UuanMnO1xyXG5cclxuLyoqIEBtb2R1bGUgUG9zdGVyaXplTm9kZSAqKi9cclxuXHJcbi8qKlxyXG4gKiBSZXByZXNlbnRzIGEgcG9zdGVyaXplIGVmZmVjdCB3aGljaCByZWR1Y2VzIHRoZSBudW1iZXIgb2YgY29sb3JzXHJcbiAqIGluIGFuIGltYWdlLCByZXN1bHRpbmcgaW4gYSBtb3JlIGJsb2NreSBhbmQgc3R5bGl6ZWQgYXBwZWFyYW5jZS5cclxuICpcclxuICogQGF1Z21lbnRzIFRlbXBOb2RlXHJcbiAqL1xyXG5jbGFzcyBQb3N0ZXJpemVOb2RlIGV4dGVuZHMgVGVtcE5vZGUge1xyXG5cclxuXHRzdGF0aWMgZ2V0IHR5cGUoKSB7XHJcblxyXG5cdFx0cmV0dXJuICdQb3N0ZXJpemVOb2RlJztcclxuXHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBDb25zdHJ1Y3RzIGEgbmV3IHBvc3Rlcml6ZSBub2RlLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtOb2RlfSBzb3VyY2VOb2RlIC0gVGhlIGlucHV0IGNvbG9yLlxyXG5cdCAqIEBwYXJhbSB7Tm9kZX0gc3RlcHNOb2RlIC0gQ29udHJvbHMgdGhlIGludGVuc2l0eSBvZiB0aGUgcG9zdGVyaXphdGlvbiBlZmZlY3QuIEEgbG93ZXIgbnVtYmVyIHJlc3VsdHMgaW4gYSBtb3JlIGJsb2NreSBhcHBlYXJhbmNlLlxyXG5cdCAqL1xyXG5cdGNvbnN0cnVjdG9yKCBzb3VyY2VOb2RlLCBzdGVwc05vZGUgKSB7XHJcblxyXG5cdFx0c3VwZXIoKTtcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIFRoZSBpbnB1dCBjb2xvci5cclxuXHRcdCAqXHJcblx0XHQgKiBAdHlwZSB7Tm9kZX1cclxuXHRcdCAqL1xyXG5cdFx0dGhpcy5zb3VyY2VOb2RlID0gc291cmNlTm9kZTtcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIENvbnRyb2xzIHRoZSBpbnRlbnNpdHkgb2YgdGhlIHBvc3Rlcml6YXRpb24gZWZmZWN0LiBBIGxvd2VyIG51bWJlciByZXN1bHRzIGluIGEgbW9yZSBibG9ja3kgYXBwZWFyYW5jZS5cclxuXHRcdCAqXHJcblx0XHQgKiBAdHlwZSB7Tm9kZX1cclxuXHRcdCAqL1xyXG5cdFx0dGhpcy5zdGVwc05vZGUgPSBzdGVwc05vZGU7XHJcblxyXG5cdH1cclxuXHJcblx0c2V0dXAoKSB7XHJcblxyXG5cdFx0Y29uc3QgeyBzb3VyY2VOb2RlLCBzdGVwc05vZGUgfSA9IHRoaXM7XHJcblxyXG5cdFx0cmV0dXJuIHNvdXJjZU5vZGUubXVsKCBzdGVwc05vZGUgKS5mbG9vcigpLmRpdiggc3RlcHNOb2RlICk7XHJcblxyXG5cdH1cclxuXHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IFBvc3Rlcml6ZU5vZGU7XHJcblxyXG4vKipcclxuICogVFNMIGZ1bmN0aW9uIGZvciBjcmVhdGluZyBhIHBvc3Rlcml6ZSBub2RlLlxyXG4gKlxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHtOb2RlfSBzb3VyY2VOb2RlIC0gVGhlIGlucHV0IGNvbG9yLlxyXG4gKiBAcGFyYW0ge05vZGV9IHN0ZXBzTm9kZSAtIENvbnRyb2xzIHRoZSBpbnRlbnNpdHkgb2YgdGhlIHBvc3Rlcml6YXRpb24gZWZmZWN0LiBBIGxvd2VyIG51bWJlciByZXN1bHRzIGluIGEgbW9yZSBibG9ja3kgYXBwZWFyYW5jZS5cclxuICogQHJldHVybnMge1Bvc3Rlcml6ZU5vZGV9XHJcbiAqL1xyXG5leHBvcnQgY29uc3QgcG9zdGVyaXplID0gLypAX19QVVJFX18qLyBub2RlUHJveHkoIFBvc3Rlcml6ZU5vZGUgKTtcclxuIiwiaW1wb3J0IFRlbXBOb2RlIGZyb20gJy4uL2NvcmUvVGVtcE5vZGUuanMnO1xyXG5pbXBvcnQgeyBkZWZhdWx0IGFzIFRleHR1cmVOb2RlLyosIHRleHR1cmUqLyB9IGZyb20gJy4uL2FjY2Vzc29ycy9UZXh0dXJlTm9kZS5qcyc7XHJcbmltcG9ydCB7IE5vZGVVcGRhdGVUeXBlIH0gZnJvbSAnLi4vY29yZS9jb25zdGFudHMuanMnO1xyXG5pbXBvcnQgeyBub2RlT2JqZWN0IH0gZnJvbSAnLi4vdHNsL1RTTEJhc2UuanMnO1xyXG5pbXBvcnQgeyB1bmlmb3JtIH0gZnJvbSAnLi4vY29yZS9Vbmlmb3JtTm9kZS5qcyc7XHJcbmltcG9ydCB7IHZpZXdaVG9PcnRob2dyYXBoaWNEZXB0aCwgcGVyc3BlY3RpdmVEZXB0aFRvVmlld1ogfSBmcm9tICcuL1ZpZXdwb3J0RGVwdGhOb2RlLmpzJztcclxuXHJcbmltcG9ydCB7IEhhbGZGbG9hdFR5cGUvKiwgRmxvYXRUeXBlKi8gfSBmcm9tICcuLi8uLi9jb25zdGFudHMuanMnO1xyXG5pbXBvcnQgeyBWZWN0b3IyIH0gZnJvbSAnLi4vLi4vbWF0aC9WZWN0b3IyLmpzJztcclxuaW1wb3J0IHsgRGVwdGhUZXh0dXJlIH0gZnJvbSAnLi4vLi4vdGV4dHVyZXMvRGVwdGhUZXh0dXJlLmpzJztcclxuaW1wb3J0IHsgUmVuZGVyVGFyZ2V0IH0gZnJvbSAnLi4vLi4vY29yZS9SZW5kZXJUYXJnZXQuanMnO1xyXG5cclxuLyoqIEBtb2R1bGUgUGFzc05vZGUgKiovXHJcblxyXG5jb25zdCBfc2l6ZSA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjIoKTtcclxuXHJcbi8qKlxyXG4gKiBSZXByZXNlbnRzIHRoZSB0ZXh0dXJlIG9mIGEgcGFzcyBub2RlLlxyXG4gKlxyXG4gKiBAYXVnbWVudHMgbW9kdWxlOlRleHR1cmVOb2RlflRleHR1cmVOb2RlXHJcbiAqL1xyXG5jbGFzcyBQYXNzVGV4dHVyZU5vZGUgZXh0ZW5kcyBUZXh0dXJlTm9kZSB7XHJcblxyXG5cdHN0YXRpYyBnZXQgdHlwZSgpIHtcclxuXHJcblx0XHRyZXR1cm4gJ1Bhc3NUZXh0dXJlTm9kZSc7XHJcblxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogQ29uc3RydWN0cyBhIG5ldyBwYXNzIHRleHR1cmUgbm9kZS5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7UGFzc05vZGV9IHBhc3NOb2RlIC0gVGhlIHBhc3Mgbm9kZS5cclxuXHQgKiBAcGFyYW0ge1RleHR1cmV9IHRleHR1cmUgLSBUaGUgb3V0cHV0IHRleHR1cmUuXHJcblx0ICovXHJcblx0Y29uc3RydWN0b3IoIHBhc3NOb2RlLCB0ZXh0dXJlICkge1xyXG5cclxuXHRcdHN1cGVyKCB0ZXh0dXJlICk7XHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBBIHJlZmVyZW5jZSB0byB0aGUgcGFzcyBub2RlLlxyXG5cdFx0ICpcclxuXHRcdCAqIEB0eXBlIHtQYXNzTm9kZX1cclxuXHRcdCAqL1xyXG5cdFx0dGhpcy5wYXNzTm9kZSA9IHBhc3NOb2RlO1xyXG5cclxuXHRcdHRoaXMuc2V0VXBkYXRlTWF0cml4KCBmYWxzZSApO1xyXG5cclxuXHR9XHJcblxyXG5cdHNldHVwKCBidWlsZGVyICkge1xyXG5cclxuXHRcdGlmICggYnVpbGRlci5vYmplY3QuaXNRdWFkTWVzaCApIHRoaXMucGFzc05vZGUuYnVpbGQoIGJ1aWxkZXIgKTtcclxuXHJcblx0XHRyZXR1cm4gc3VwZXIuc2V0dXAoIGJ1aWxkZXIgKTtcclxuXHJcblx0fVxyXG5cclxuXHRjbG9uZSgpIHtcclxuXHJcblx0XHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoIHRoaXMucGFzc05vZGUsIHRoaXMudmFsdWUgKTtcclxuXHJcblx0fVxyXG5cclxufVxyXG5cclxuLyoqXHJcbiAqIEFuIGV4dGVuc2lvbiBvZiBgUGFzc1RleHR1cmVOb2RlYCB3aGljaCBhbGxvd3MgdG8gbWFuYWdlIG1vcmUgdGhhbiBvbmVcclxuICogaW50ZXJuYWwgdGV4dHVyZS4gUmVsZXZhbnQgZm9yIHRoZSBgZ2V0UHJldmlvdXNUZXh0dXJlKClgIHJlbGF0ZWQgQVBJLlxyXG4gKlxyXG4gKiBAYXVnbWVudHMgbW9kdWxlOlBhc3NUZXh0dXJlTm9kZX5QYXNzVGV4dHVyZU5vZGVcclxuICovXHJcbmNsYXNzIFBhc3NNdWx0aXBsZVRleHR1cmVOb2RlIGV4dGVuZHMgUGFzc1RleHR1cmVOb2RlIHtcclxuXHJcblx0c3RhdGljIGdldCB0eXBlKCkge1xyXG5cclxuXHRcdHJldHVybiAnUGFzc011bHRpcGxlVGV4dHVyZU5vZGUnO1xyXG5cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIENvbnN0cnVjdHMgYSBuZXcgcGFzcyB0ZXh0dXJlIG5vZGUuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge1Bhc3NOb2RlfSBwYXNzTm9kZSAtIFRoZSBwYXNzIG5vZGUuXHJcblx0ICogQHBhcmFtIHtTdHJpbmd9IHRleHR1cmVOYW1lIC0gVGhlIG91dHB1dCB0ZXh0dXJlIG5hbWUuXHJcblx0ICogQHBhcmFtIHtCb29sZWFufSBbcHJldmlvdXNUZXh0dXJlPWZhbHNlXSAtIFdoZXRoZXIgcHJldmlvdXMgZnJhbWUgZGF0YSBzaG91bGQgYmUgdXNlZCBvciBub3QuXHJcblx0ICovXHJcblx0Y29uc3RydWN0b3IoIHBhc3NOb2RlLCB0ZXh0dXJlTmFtZSwgcHJldmlvdXNUZXh0dXJlID0gZmFsc2UgKSB7XHJcblxyXG5cdFx0Ly8gbnVsbCBpcyBwYXNzZWQgdG8gdGhlIHN1cGVyIGNhbGwgc2luY2UgdGhpcyBjbGFzcyBkb2VzIG5vdFxyXG5cdFx0Ly8gdXNlIGFuIGV4dGVybmFsIHRleHR1cmUgZm9yIHJlbmRlcmluZyBwYXNzIGRhdGEgaW50by4gSW5zdGVhZFxyXG5cdFx0Ly8gdGhlIHRleHR1cmUgaXMgbWFuYWdlZCBieSB0aGUgcGFzcyBub2RlIGl0c2VsZlxyXG5cclxuXHRcdHN1cGVyKCBwYXNzTm9kZSwgbnVsbCApO1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogVGhlIG91dHB1dCB0ZXh0dXJlIG5hbWUuXHJcblx0XHQgKlxyXG5cdFx0ICogQHR5cGUge1N0cmluZ31cclxuXHRcdCAqL1xyXG5cdFx0dGhpcy50ZXh0dXJlTmFtZSA9IHRleHR1cmVOYW1lO1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogV2hldGhlciBwcmV2aW91cyBmcmFtZSBkYXRhIHNob3VsZCBiZSB1c2VkIG9yIG5vdC5cclxuXHRcdCAqXHJcblx0XHQgKiBAdHlwZSB7Qm9vbGVhbn1cclxuXHRcdCAqL1xyXG5cdFx0dGhpcy5wcmV2aW91c1RleHR1cmUgPSBwcmV2aW91c1RleHR1cmU7XHJcblxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogVXBkYXRlcyB0aGUgdGV4dHVyZSByZWZlcmVuY2Ugb2YgdGhpcyBub2RlLlxyXG5cdCAqL1xyXG5cdHVwZGF0ZVRleHR1cmUoKSB7XHJcblxyXG5cdFx0dGhpcy52YWx1ZSA9IHRoaXMucHJldmlvdXNUZXh0dXJlID8gdGhpcy5wYXNzTm9kZS5nZXRQcmV2aW91c1RleHR1cmUoIHRoaXMudGV4dHVyZU5hbWUgKSA6IHRoaXMucGFzc05vZGUuZ2V0VGV4dHVyZSggdGhpcy50ZXh0dXJlTmFtZSApO1xyXG5cclxuXHR9XHJcblxyXG5cdHNldHVwKCBidWlsZGVyICkge1xyXG5cclxuXHRcdHRoaXMudXBkYXRlVGV4dHVyZSgpO1xyXG5cclxuXHRcdHJldHVybiBzdXBlci5zZXR1cCggYnVpbGRlciApO1xyXG5cclxuXHR9XHJcblxyXG5cdGNsb25lKCkge1xyXG5cclxuXHRcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvciggdGhpcy5wYXNzTm9kZSwgdGhpcy50ZXh0dXJlTmFtZSwgdGhpcy5wcmV2aW91c1RleHR1cmUgKTtcclxuXHJcblx0fVxyXG5cclxufVxyXG5cclxuLyoqXHJcbiAqIFJlcHJlc2VudHMgYSByZW5kZXIgcGFzcyAoc29tZXRpbWVzIGNhbGxlZCBiZWF1dHkgcGFzcykgaW4gY29udGV4dCBvZiBwb3N0IHByb2Nlc3NpbmcuXHJcbiAqIFRoaXMgcGFzcyBwcm9kdWNlcyBhIHJlbmRlciBmb3IgdGhlIGdpdmVuIHNjZW5lIGFuZCBjYW1lcmEgYW5kIGNhbiBwcm92aWRlIG11bHRpcGxlIG91dHB1dHNcclxuICogdmlhIE1SVCBmb3IgZnVydGhlciBwcm9jZXNzaW5nLlxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiBjb25zdCBwb3N0UHJvY2Vzc2luZyA9IG5ldyBQb3N0UHJvY2Vzc2luZyggcmVuZGVyZXIgKTtcclxuICpcclxuICogY29uc3Qgc2NlbmVQYXNzID0gcGFzcyggc2NlbmUsIGNhbWVyYSApO1xyXG4gKlxyXG4gKiBwb3N0UHJvY2Vzc2luZy5vdXRwdXROb2RlID0gc2NlbmVQYXNzO1xyXG4gKiBgYGBcclxuICpcclxuICogQGF1Z21lbnRzIFRlbXBOb2RlXHJcbiAqL1xyXG5jbGFzcyBQYXNzTm9kZSBleHRlbmRzIFRlbXBOb2RlIHtcclxuXHJcblx0c3RhdGljIGdldCB0eXBlKCkge1xyXG5cclxuXHRcdHJldHVybiAnUGFzc05vZGUnO1xyXG5cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIENvbnN0cnVjdHMgYSBuZXcgcGFzcyBub2RlLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHsoJ2NvbG9yJ3wnZGVwdGgnKX0gc2NvcGUgLSBUaGUgc2NvcGUgb2YgdGhlIHBhc3MuIFRoZSBzY29wZSBkZXRlcm1pbmVzIHdoZXRoZXIgdGhlIG5vZGUgb3V0cHV0cyBjb2xvciBvciBkZXB0aC5cclxuXHQgKiBAcGFyYW0ge1NjZW5lfSBzY2VuZSAtIEEgcmVmZXJlbmNlIHRvIHRoZSBzY2VuZS5cclxuXHQgKiBAcGFyYW0ge0NhbWVyYX0gY2FtZXJhIC0gQSByZWZlcmVuY2UgdG8gdGhlIGNhbWVyYS5cclxuXHQgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIE9wdGlvbnMgZm9yIHRoZSBpbnRlcm5hbCByZW5kZXIgdGFyZ2V0LlxyXG5cdCAqL1xyXG5cdGNvbnN0cnVjdG9yKCBzY29wZSwgc2NlbmUsIGNhbWVyYSwgb3B0aW9ucyA9IHt9ICkge1xyXG5cclxuXHRcdHN1cGVyKCAndmVjNCcgKTtcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIFRoZSBzY29wZSBvZiB0aGUgcGFzcy4gVGhlIHNjb3BlIGRldGVybWluZXMgd2hldGhlciB0aGUgbm9kZSBvdXRwdXRzIGNvbG9yIG9yIGRlcHRoLlxyXG5cdFx0ICpcclxuXHRcdCAqIEB0eXBlIHsoJ2NvbG9yJ3wnZGVwdGgnKX1cclxuXHRcdCAqL1xyXG5cdFx0dGhpcy5zY29wZSA9IHNjb3BlO1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogQSByZWZlcmVuY2UgdG8gdGhlIHNjZW5lLlxyXG5cdFx0ICpcclxuXHRcdCAqIEB0eXBlIHtTY2VuZX1cclxuXHRcdCAqL1xyXG5cdFx0dGhpcy5zY2VuZSA9IHNjZW5lO1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogQSByZWZlcmVuY2UgdG8gdGhlIGNhbWVyYS5cclxuXHRcdCAqXHJcblx0XHQgKiBAdHlwZSB7Q2FtZXJhfVxyXG5cdFx0ICovXHJcblx0XHR0aGlzLmNhbWVyYSA9IGNhbWVyYTtcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIE9wdGlvbnMgZm9yIHRoZSBpbnRlcm5hbCByZW5kZXIgdGFyZ2V0LlxyXG5cdFx0ICpcclxuXHRcdCAqIEB0eXBlIHtPYmplY3R9XHJcblx0XHQgKi9cclxuXHRcdHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBUaGUgcGFzcydzIHBpeGVsIHJhdGlvLiBXaWxsIGJlIGtlcHQgYXV0b21hdGljYWxseSBrZXB0IGluIHN5bmMgd2l0aCB0aGUgcmVuZGVyZXIncyBwaXhlbCByYXRpby5cclxuXHRcdCAqXHJcblx0XHQgKiBAcHJpdmF0ZVxyXG5cdFx0ICogQHR5cGUge051bWJlcn1cclxuXHRcdCAqIEBkZWZhdWx0IDFcclxuXHRcdCAqL1xyXG5cdFx0dGhpcy5fcGl4ZWxSYXRpbyA9IDE7XHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBUaGUgcGFzcydzIHBpeGVsIHdpZHRoLiBXaWxsIGJlIGtlcHQgYXV0b21hdGljYWxseSBrZXB0IGluIHN5bmMgd2l0aCB0aGUgcmVuZGVyZXIncyB3aWR0aC5cclxuXHRcdCAqIEBwcml2YXRlXHJcblx0XHQgKiBAdHlwZSB7TnVtYmVyfVxyXG5cdFx0ICogQGRlZmF1bHQgMVxyXG5cdFx0ICovXHJcblx0XHR0aGlzLl93aWR0aCA9IDE7XHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBUaGUgcGFzcydzIHBpeGVsIGhlaWdodC4gV2lsbCBiZSBrZXB0IGF1dG9tYXRpY2FsbHkga2VwdCBpbiBzeW5jIHdpdGggdGhlIHJlbmRlcmVyJ3MgaGVpZ2h0LlxyXG5cdFx0ICogQHByaXZhdGVcclxuXHRcdCAqIEB0eXBlIHtOdW1iZXJ9XHJcblx0XHQgKiBAZGVmYXVsdCAxXHJcblx0XHQgKi9cclxuXHRcdHRoaXMuX2hlaWdodCA9IDE7XHJcblxyXG5cdFx0Y29uc3QgZGVwdGhUZXh0dXJlID0gbmV3IERlcHRoVGV4dHVyZSgpO1xyXG5cdFx0ZGVwdGhUZXh0dXJlLmlzUmVuZGVyVGFyZ2V0VGV4dHVyZSA9IHRydWU7XHJcblx0XHQvL2RlcHRoVGV4dHVyZS50eXBlID0gRmxvYXRUeXBlO1xyXG5cdFx0ZGVwdGhUZXh0dXJlLm5hbWUgPSAnZGVwdGgnO1xyXG5cclxuXHRcdGNvbnN0IHJlbmRlclRhcmdldCA9IG5ldyBSZW5kZXJUYXJnZXQoIHRoaXMuX3dpZHRoICogdGhpcy5fcGl4ZWxSYXRpbywgdGhpcy5faGVpZ2h0ICogdGhpcy5fcGl4ZWxSYXRpbywgeyB0eXBlOiBIYWxmRmxvYXRUeXBlLCAuLi5vcHRpb25zLCB9ICk7XHJcblx0XHRyZW5kZXJUYXJnZXQudGV4dHVyZS5uYW1lID0gJ291dHB1dCc7XHJcblx0XHRyZW5kZXJUYXJnZXQuZGVwdGhUZXh0dXJlID0gZGVwdGhUZXh0dXJlO1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogVGhlIHBhc3MncyByZW5kZXIgdGFyZ2V0LlxyXG5cdFx0ICpcclxuXHRcdCAqIEB0eXBlIHtSZW5kZXJUYXJnZXR9XHJcblx0XHQgKi9cclxuXHRcdHRoaXMucmVuZGVyVGFyZ2V0ID0gcmVuZGVyVGFyZ2V0O1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogQSBkaWN0aW9uYXJ5IGhvbGRpbmcgdGhlIGludGVybmFsIHJlc3VsdCB0ZXh0dXJlcy5cclxuXHRcdCAqXHJcblx0XHQgKiBAcHJpdmF0ZVxyXG5cdFx0ICogQHR5cGUge09iamVjdDxTdHJpbmcsIFRleHR1cmU+fVxyXG5cdFx0ICovXHJcblx0XHR0aGlzLl90ZXh0dXJlcyA9IHtcclxuXHRcdFx0b3V0cHV0OiByZW5kZXJUYXJnZXQudGV4dHVyZSxcclxuXHRcdFx0ZGVwdGg6IGRlcHRoVGV4dHVyZVxyXG5cdFx0fTtcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIEEgZGljdGlvbmFyeSBob2xkaW5nIHRoZSBpbnRlcm5hbCB0ZXh0dXJlIG5vZGVzLlxyXG5cdFx0ICpcclxuXHRcdCAqIEBwcml2YXRlXHJcblx0XHQgKiBAdHlwZSB7T2JqZWN0PFN0cmluZywgVGV4dHVyZU5vZGU+fVxyXG5cdFx0ICovXHJcblx0XHR0aGlzLl90ZXh0dXJlTm9kZXMgPSB7fTtcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIEEgZGljdGlvbmFyeSBob2xkaW5nIHRoZSBpbnRlcm5hbCBkZXB0aCBub2Rlcy5cclxuXHRcdCAqXHJcblx0XHQgKiBAcHJpdmF0ZVxyXG5cdFx0ICogQHR5cGUge09iamVjdH1cclxuXHRcdCAqL1xyXG5cdFx0dGhpcy5fbGluZWFyRGVwdGhOb2RlcyA9IHt9O1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogQSBkaWN0aW9uYXJ5IGhvbGRpbmcgdGhlIGludGVybmFsIHZpZXdaIG5vZGVzLlxyXG5cdFx0ICpcclxuXHRcdCAqIEBwcml2YXRlXHJcblx0XHQgKiBAdHlwZSB7T2JqZWN0fVxyXG5cdFx0ICovXHJcblx0XHR0aGlzLl92aWV3Wk5vZGVzID0ge307XHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBBIGRpY3Rpb25hcnkgaG9sZGluZyB0aGUgdGV4dHVyZSBkYXRhIG9mIHRoZSBwcmV2aW91cyBmcmFtZS5cclxuXHRcdCAqIFVzZWQgZm9yIGNvbXB1dGluZyB2ZWxvY2l0eS9tb3Rpb24gdmVjdG9ycy5cclxuXHRcdCAqXHJcblx0XHQgKiBAcHJpdmF0ZVxyXG5cdFx0ICogQHR5cGUge09iamVjdDxTdHJpbmcsIFRleHR1cmU+fVxyXG5cdFx0ICovXHJcblx0XHR0aGlzLl9wcmV2aW91c1RleHR1cmVzID0ge307XHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBBIGRpY3Rpb25hcnkgaG9sZGluZyB0aGUgdGV4dHVyZSBub2RlcyBvZiB0aGUgcHJldmlvdXMgZnJhbWUuXHJcblx0XHQgKiBVc2VkIGZvciBjb21wdXRpbmcgdmVsb2NpdHkvbW90aW9uIHZlY3RvcnMuXHJcblx0XHQgKlxyXG5cdFx0ICogQHByaXZhdGVcclxuXHRcdCAqIEB0eXBlIHtPYmplY3Q8U3RyaW5nLCBUZXh0dXJlTm9kZT59XHJcblx0XHQgKi9cclxuXHRcdHRoaXMuX3ByZXZpb3VzVGV4dHVyZU5vZGVzID0ge307XHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBUaGUgYG5lYXJgIHByb3BlcnR5IG9mIHRoZSBjYW1lcmEgYXMgYSB1bmlmb3JtLlxyXG5cdFx0ICpcclxuXHRcdCAqIEBwcml2YXRlXHJcblx0XHQgKiBAdHlwZSB7VW5pZm9ybU5vZGV9XHJcblx0XHQgKi9cclxuXHRcdHRoaXMuX2NhbWVyYU5lYXIgPSB1bmlmb3JtKCAwICk7XHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBUaGUgYGZhcmAgcHJvcGVydHkgb2YgdGhlIGNhbWVyYSBhcyBhIHVuaWZvcm0uXHJcblx0XHQgKlxyXG5cdFx0ICogQHByaXZhdGVcclxuXHRcdCAqIEB0eXBlIHtVbmlmb3JtTm9kZX1cclxuXHRcdCAqL1xyXG5cdFx0dGhpcy5fY2FtZXJhRmFyID0gdW5pZm9ybSggMCApO1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogQSBNUlQgbm9kZSBjb25maWd1cmluZyB0aGUgTVJUIHNldHRpbmdzLlxyXG5cdFx0ICpcclxuXHRcdCAqIEBwcml2YXRlXHJcblx0XHQgKiBAdHlwZSB7TVJUTm9kZT99XHJcblx0XHQgKiBAZGVmYXVsdCBudWxsXHJcblx0XHQgKi9cclxuXHRcdHRoaXMuX21ydCA9IG51bGw7XHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBUaGlzIGZsYWcgY2FuIGJlIHVzZWQgZm9yIHR5cGUgdGVzdGluZy5cclxuXHRcdCAqXHJcblx0XHQgKiBAdHlwZSB7Qm9vbGVhbn1cclxuXHRcdCAqIEByZWFkb25seVxyXG5cdFx0ICogQGRlZmF1bHQgdHJ1ZVxyXG5cdFx0ICovXHJcblx0XHR0aGlzLmlzUGFzc05vZGUgPSB0cnVlO1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogVGhlIGB1cGRhdGVCZWZvcmVUeXBlYCBpcyBzZXQgdG8gYE5vZGVVcGRhdGVUeXBlLkZSQU1FYCBzaW5jZSB0aGUgbm9kZSByZW5kZXJzIHRoZVxyXG5cdFx0ICogc2NlbmUgb25jZSBwZXIgZnJhbWUgaW4gaXRzIHtAbGluayBQYXNzTm9kZSN1cGRhdGVCZWZvcmV9IG1ldGhvZC5cclxuXHRcdCAqXHJcblx0XHQgKiBAdHlwZSB7U3RyaW5nfVxyXG5cdFx0ICogQGRlZmF1bHQgJ2ZyYW1lJ1xyXG5cdFx0ICovXHJcblx0XHR0aGlzLnVwZGF0ZUJlZm9yZVR5cGUgPSBOb2RlVXBkYXRlVHlwZS5GUkFNRTtcclxuXHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBTZXRzIHRoZSBnaXZlbiBNUlQgbm9kZSB0byBzZXR1cCBNUlQgZm9yIHRoaXMgcGFzcy5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7TVJUTm9kZX0gbXJ0IC0gVGhlIE1SVCBvYmplY3QuXHJcblx0ICogQHJldHVybiB7UGFzc05vZGV9IEEgcmVmZXJlbmNlIHRvIHRoaXMgcGFzcy5cclxuXHQgKi9cclxuXHRzZXRNUlQoIG1ydCApIHtcclxuXHJcblx0XHR0aGlzLl9tcnQgPSBtcnQ7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogUmV0dXJucyB0aGUgY3VycmVudCBNUlQgbm9kZS5cclxuXHQgKlxyXG5cdCAqIEByZXR1cm4ge01SVE5vZGV9IFRoZSBjdXJyZW50IE1SVCBub2RlLlxyXG5cdCAqL1xyXG5cdGdldE1SVCgpIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5fbXJ0O1xyXG5cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFRoZSBtZXRob2QgaXMgb3ZlcndyaXR0ZW4gc28gaXQgYWx3YXlzIHJldHVybnMgYHRydWVgLlxyXG5cdCAqXHJcblx0ICogQHJldHVybiB7Qm9vbGVhbn0gV2hldGhlciB0aGlzIG5vZGUgaXMgZ2xvYmFsIG9yIG5vdC5cclxuXHQgKi9cclxuXHRpc0dsb2JhbCgpIHtcclxuXHJcblx0XHRyZXR1cm4gdHJ1ZTtcclxuXHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBSZXR1cm5zIHRoZSB0ZXh0dXJlIGZvciB0aGUgZ2l2ZW4gb3V0cHV0IG5hbWUuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSAtIFRoZSBvdXRwdXQgbmFtZSB0byBnZXQgdGhlIHRleHR1cmUgZm9yLlxyXG5cdCAqIEByZXR1cm4ge1RleHR1cmV9IFRoZSB0ZXh0dXJlLlxyXG5cdCAqL1xyXG5cdGdldFRleHR1cmUoIG5hbWUgKSB7XHJcblxyXG5cdFx0bGV0IHRleHR1cmUgPSB0aGlzLl90ZXh0dXJlc1sgbmFtZSBdO1xyXG5cclxuXHRcdGlmICggdGV4dHVyZSA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0Y29uc3QgcmVmVGV4dHVyZSA9IHRoaXMucmVuZGVyVGFyZ2V0LnRleHR1cmU7XHJcblxyXG5cdFx0XHR0ZXh0dXJlID0gcmVmVGV4dHVyZS5jbG9uZSgpO1xyXG5cdFx0XHR0ZXh0dXJlLm5hbWUgPSBuYW1lO1xyXG5cclxuXHRcdFx0dGhpcy5fdGV4dHVyZXNbIG5hbWUgXSA9IHRleHR1cmU7XHJcblxyXG5cdFx0XHR0aGlzLnJlbmRlclRhcmdldC50ZXh0dXJlcy5wdXNoKCB0ZXh0dXJlICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0ZXh0dXJlO1xyXG5cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFJldHVybnMgdGhlIHRleHR1cmUgaG9sZGluZyB0aGUgZGF0YSBvZiB0aGUgcHJldmlvdXMgZnJhbWUgZm9yIHRoZSBnaXZlbiBvdXRwdXQgbmFtZS5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIC0gVGhlIG91dHB1dCBuYW1lIHRvIGdldCB0aGUgdGV4dHVyZSBmb3IuXHJcblx0ICogQHJldHVybiB7VGV4dHVyZX0gVGhlIHRleHR1cmUgaG9sZGluZyB0aGUgZGF0YSBvZiB0aGUgcHJldmlvdXMgZnJhbWUuXHJcblx0ICovXHJcblx0Z2V0UHJldmlvdXNUZXh0dXJlKCBuYW1lICkge1xyXG5cclxuXHRcdGxldCB0ZXh0dXJlID0gdGhpcy5fcHJldmlvdXNUZXh0dXJlc1sgbmFtZSBdO1xyXG5cclxuXHRcdGlmICggdGV4dHVyZSA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0dGV4dHVyZSA9IHRoaXMuZ2V0VGV4dHVyZSggbmFtZSApLmNsb25lKCk7XHJcblxyXG5cdFx0XHR0aGlzLl9wcmV2aW91c1RleHR1cmVzWyBuYW1lIF0gPSB0ZXh0dXJlO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGV4dHVyZTtcclxuXHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBTd2l0Y2hlcyBjdXJyZW50IGFuZCBwcmV2aW91cyB0ZXh0dXJlcyBmb3IgdGhlIGdpdmVuIG91dHB1dCBuYW1lLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgLSBUaGUgb3V0cHV0IG5hbWUuXHJcblx0ICovXHJcblx0dG9nZ2xlVGV4dHVyZSggbmFtZSApIHtcclxuXHJcblx0XHRjb25zdCBwcmV2VGV4dHVyZSA9IHRoaXMuX3ByZXZpb3VzVGV4dHVyZXNbIG5hbWUgXTtcclxuXHJcblx0XHRpZiAoIHByZXZUZXh0dXJlICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRjb25zdCB0ZXh0dXJlID0gdGhpcy5fdGV4dHVyZXNbIG5hbWUgXTtcclxuXHJcblx0XHRcdGNvbnN0IGluZGV4ID0gdGhpcy5yZW5kZXJUYXJnZXQudGV4dHVyZXMuaW5kZXhPZiggdGV4dHVyZSApO1xyXG5cdFx0XHR0aGlzLnJlbmRlclRhcmdldC50ZXh0dXJlc1sgaW5kZXggXSA9IHByZXZUZXh0dXJlO1xyXG5cclxuXHRcdFx0dGhpcy5fdGV4dHVyZXNbIG5hbWUgXSA9IHByZXZUZXh0dXJlO1xyXG5cdFx0XHR0aGlzLl9wcmV2aW91c1RleHR1cmVzWyBuYW1lIF0gPSB0ZXh0dXJlO1xyXG5cclxuXHRcdFx0dGhpcy5fdGV4dHVyZU5vZGVzWyBuYW1lIF0udXBkYXRlVGV4dHVyZSgpO1xyXG5cdFx0XHR0aGlzLl9wcmV2aW91c1RleHR1cmVOb2Rlc1sgbmFtZSBdLnVwZGF0ZVRleHR1cmUoKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogUmV0dXJucyB0aGUgdGV4dHVyZSBub2RlIGZvciB0aGUgZ2l2ZW4gb3V0cHV0IG5hbWUuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge1N0cmluZ30gW25hbWU9J291dHB1dCddIC0gVGhlIG91dHB1dCBuYW1lIHRvIGdldCB0aGUgdGV4dHVyZSBub2RlIGZvci5cclxuXHQgKiBAcmV0dXJuIHtUZXh0dXJlTm9kZX0gVGhlIHRleHR1cmUgbm9kZS5cclxuXHQgKi9cclxuXHRnZXRUZXh0dXJlTm9kZSggbmFtZSA9ICdvdXRwdXQnICkge1xyXG5cclxuXHRcdGxldCB0ZXh0dXJlTm9kZSA9IHRoaXMuX3RleHR1cmVOb2Rlc1sgbmFtZSBdO1xyXG5cclxuXHRcdGlmICggdGV4dHVyZU5vZGUgPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdHRleHR1cmVOb2RlID0gbm9kZU9iamVjdCggbmV3IFBhc3NNdWx0aXBsZVRleHR1cmVOb2RlKCB0aGlzLCBuYW1lICkgKTtcclxuXHRcdFx0dGV4dHVyZU5vZGUudXBkYXRlVGV4dHVyZSgpO1xyXG5cdFx0XHR0aGlzLl90ZXh0dXJlTm9kZXNbIG5hbWUgXSA9IHRleHR1cmVOb2RlO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGV4dHVyZU5vZGU7XHJcblxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogUmV0dXJucyB0aGUgcHJldmlvdXMgdGV4dHVyZSBub2RlIGZvciB0aGUgZ2l2ZW4gb3V0cHV0IG5hbWUuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge1N0cmluZ30gW25hbWU9J291dHB1dCddIC0gVGhlIG91dHB1dCBuYW1lIHRvIGdldCB0aGUgcHJldmlvdXMgdGV4dHVyZSBub2RlIGZvci5cclxuXHQgKiBAcmV0dXJuIHtUZXh0dXJlTm9kZX0gVGhlIHByZXZpb3VzIHRleHR1cmUgbm9kZS5cclxuXHQgKi9cclxuXHRnZXRQcmV2aW91c1RleHR1cmVOb2RlKCBuYW1lID0gJ291dHB1dCcgKSB7XHJcblxyXG5cdFx0bGV0IHRleHR1cmVOb2RlID0gdGhpcy5fcHJldmlvdXNUZXh0dXJlTm9kZXNbIG5hbWUgXTtcclxuXHJcblx0XHRpZiAoIHRleHR1cmVOb2RlID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRpZiAoIHRoaXMuX3RleHR1cmVOb2Rlc1sgbmFtZSBdID09PSB1bmRlZmluZWQgKSB0aGlzLmdldFRleHR1cmVOb2RlKCBuYW1lICk7XHJcblxyXG5cdFx0XHR0ZXh0dXJlTm9kZSA9IG5vZGVPYmplY3QoIG5ldyBQYXNzTXVsdGlwbGVUZXh0dXJlTm9kZSggdGhpcywgbmFtZSwgdHJ1ZSApICk7XHJcblx0XHRcdHRleHR1cmVOb2RlLnVwZGF0ZVRleHR1cmUoKTtcclxuXHRcdFx0dGhpcy5fcHJldmlvdXNUZXh0dXJlTm9kZXNbIG5hbWUgXSA9IHRleHR1cmVOb2RlO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGV4dHVyZU5vZGU7XHJcblxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogUmV0dXJucyBhIHZpZXdaIG5vZGUgb2YgdGhpcyBwYXNzLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtTdHJpbmd9IFtuYW1lPSdkZXB0aCddIC0gVGhlIG91dHB1dCBuYW1lIHRvIGdldCB0aGUgdmlld1ogbm9kZSBmb3IuIEluIG1vc3QgY2FzZXMgdGhlIGRlZmF1bHQgYCdkZXB0aCdgIGNhbiBiZSB1c2VkIGhvd2V2ZXIgdGhlIHBhcmFtZXRlciBleGlzdHMgZm9yIGN1c3RvbSBkZXB0aCBvdXRwdXRzLlxyXG5cdCAqIEByZXR1cm4ge05vZGV9IFRoZSB2aWV3WiBub2RlLlxyXG5cdCAqL1xyXG5cdGdldFZpZXdaTm9kZSggbmFtZSA9ICdkZXB0aCcgKSB7XHJcblxyXG5cdFx0bGV0IHZpZXdaTm9kZSA9IHRoaXMuX3ZpZXdaTm9kZXNbIG5hbWUgXTtcclxuXHJcblx0XHRpZiAoIHZpZXdaTm9kZSA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0Y29uc3QgY2FtZXJhTmVhciA9IHRoaXMuX2NhbWVyYU5lYXI7XHJcblx0XHRcdGNvbnN0IGNhbWVyYUZhciA9IHRoaXMuX2NhbWVyYUZhcjtcclxuXHJcblx0XHRcdHRoaXMuX3ZpZXdaTm9kZXNbIG5hbWUgXSA9IHZpZXdaTm9kZSA9IHBlcnNwZWN0aXZlRGVwdGhUb1ZpZXdaKCB0aGlzLmdldFRleHR1cmVOb2RlKCBuYW1lICksIGNhbWVyYU5lYXIsIGNhbWVyYUZhciApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdmlld1pOb2RlO1xyXG5cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFJldHVybnMgYSBsaW5lYXIgZGVwdGggbm9kZSBvZiB0aGlzIHBhc3MuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge1N0cmluZ30gW25hbWU9J2RlcHRoJ10gLSBUaGUgb3V0cHV0IG5hbWUgdG8gZ2V0IHRoZSBsaW5lYXIgZGVwdGggbm9kZSBmb3IuIEluIG1vc3QgY2FzZXMgdGhlIGRlZmF1bHQgYCdkZXB0aCdgIGNhbiBiZSB1c2VkIGhvd2V2ZXIgdGhlIHBhcmFtZXRlciBleGlzdHMgZm9yIGN1c3RvbSBkZXB0aCBvdXRwdXRzLlxyXG5cdCAqIEByZXR1cm4ge05vZGV9IFRoZSBsaW5lYXIgZGVwdGggbm9kZS5cclxuXHQgKi9cclxuXHRnZXRMaW5lYXJEZXB0aE5vZGUoIG5hbWUgPSAnZGVwdGgnICkge1xyXG5cclxuXHRcdGxldCBsaW5lYXJEZXB0aE5vZGUgPSB0aGlzLl9saW5lYXJEZXB0aE5vZGVzWyBuYW1lIF07XHJcblxyXG5cdFx0aWYgKCBsaW5lYXJEZXB0aE5vZGUgPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdGNvbnN0IGNhbWVyYU5lYXIgPSB0aGlzLl9jYW1lcmFOZWFyO1xyXG5cdFx0XHRjb25zdCBjYW1lcmFGYXIgPSB0aGlzLl9jYW1lcmFGYXI7XHJcblx0XHRcdGNvbnN0IHZpZXdaTm9kZSA9IHRoaXMuZ2V0Vmlld1pOb2RlKCBuYW1lICk7XHJcblxyXG5cdFx0XHQvLyBUT0RPOiBqdXN0IGlmICggYnVpbGRlci5jYW1lcmEuaXNQZXJzcGVjdGl2ZUNhbWVyYSApXHJcblxyXG5cdFx0XHR0aGlzLl9saW5lYXJEZXB0aE5vZGVzWyBuYW1lIF0gPSBsaW5lYXJEZXB0aE5vZGUgPSB2aWV3WlRvT3J0aG9ncmFwaGljRGVwdGgoIHZpZXdaTm9kZSwgY2FtZXJhTmVhciwgY2FtZXJhRmFyICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBsaW5lYXJEZXB0aE5vZGU7XHJcblxyXG5cdH1cclxuXHJcblx0c2V0dXAoIHsgcmVuZGVyZXIgfSApIHtcclxuXHJcblx0XHR0aGlzLnJlbmRlclRhcmdldC5zYW1wbGVzID0gdGhpcy5vcHRpb25zLnNhbXBsZXMgPT09IHVuZGVmaW5lZCA/IHJlbmRlcmVyLnNhbXBsZXMgOiB0aGlzLm9wdGlvbnMuc2FtcGxlcztcclxuXHJcblx0XHQvLyBEaXNhYmxlIE1TQUEgZm9yIFdlYkdMIGJhY2tlbmQgZm9yIG5vd1xyXG5cdFx0aWYgKCByZW5kZXJlci5iYWNrZW5kLmlzV2ViR0xCYWNrZW5kID09PSB0cnVlICkge1xyXG5cclxuXHRcdFx0dGhpcy5yZW5kZXJUYXJnZXQuc2FtcGxlcyA9IDA7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzLnNjb3BlID09PSBQYXNzTm9kZS5DT0xPUiA/IHRoaXMuZ2V0VGV4dHVyZU5vZGUoKSA6IHRoaXMuZ2V0TGluZWFyRGVwdGhOb2RlKCk7XHJcblxyXG5cdH1cclxuXHJcblx0dXBkYXRlQmVmb3JlKCBmcmFtZSApIHtcclxuXHJcblx0XHRjb25zdCB7IHJlbmRlcmVyIH0gPSBmcmFtZTtcclxuXHRcdGNvbnN0IHsgc2NlbmUsIGNhbWVyYSB9ID0gdGhpcztcclxuXHJcblx0XHR0aGlzLl9waXhlbFJhdGlvID0gcmVuZGVyZXIuZ2V0UGl4ZWxSYXRpbygpO1xyXG5cclxuXHRcdGNvbnN0IHNpemUgPSByZW5kZXJlci5nZXRTaXplKCBfc2l6ZSApO1xyXG5cclxuXHRcdHRoaXMuc2V0U2l6ZSggc2l6ZS53aWR0aCwgc2l6ZS5oZWlnaHQgKTtcclxuXHJcblx0XHRjb25zdCBjdXJyZW50UmVuZGVyVGFyZ2V0ID0gcmVuZGVyZXIuZ2V0UmVuZGVyVGFyZ2V0KCk7XHJcblx0XHRjb25zdCBjdXJyZW50TVJUID0gcmVuZGVyZXIuZ2V0TVJUKCk7XHJcblxyXG5cdFx0dGhpcy5fY2FtZXJhTmVhci52YWx1ZSA9IGNhbWVyYS5uZWFyO1xyXG5cdFx0dGhpcy5fY2FtZXJhRmFyLnZhbHVlID0gY2FtZXJhLmZhcjtcclxuXHJcblx0XHRmb3IgKCBjb25zdCBuYW1lIGluIHRoaXMuX3ByZXZpb3VzVGV4dHVyZXMgKSB7XHJcblxyXG5cdFx0XHR0aGlzLnRvZ2dsZVRleHR1cmUoIG5hbWUgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmVuZGVyZXIuc2V0UmVuZGVyVGFyZ2V0KCB0aGlzLnJlbmRlclRhcmdldCApO1xyXG5cdFx0cmVuZGVyZXIuc2V0TVJUKCB0aGlzLl9tcnQgKTtcclxuXHJcblx0XHRyZW5kZXJlci5yZW5kZXIoIHNjZW5lLCBjYW1lcmEgKTtcclxuXHJcblx0XHRyZW5kZXJlci5zZXRSZW5kZXJUYXJnZXQoIGN1cnJlbnRSZW5kZXJUYXJnZXQgKTtcclxuXHRcdHJlbmRlcmVyLnNldE1SVCggY3VycmVudE1SVCApO1xyXG5cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFNldHMgdGhlIHNpemUgb2YgdGhlIHBhc3MncyByZW5kZXIgdGFyZ2V0LiBIb25vcnMgdGhlIHBpeGVsIHJhdGlvLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHdpZHRoIC0gVGhlIHdpZHRoIHRvIHNldC5cclxuXHQgKiBAcGFyYW0ge051bWJlcn0gaGVpZ2h0IC0gVGhlIGhlaWdodCB0byBzZXQuXHJcblx0ICovXHJcblx0c2V0U2l6ZSggd2lkdGgsIGhlaWdodCApIHtcclxuXHJcblx0XHR0aGlzLl93aWR0aCA9IHdpZHRoO1xyXG5cdFx0dGhpcy5faGVpZ2h0ID0gaGVpZ2h0O1xyXG5cclxuXHRcdGNvbnN0IGVmZmVjdGl2ZVdpZHRoID0gdGhpcy5fd2lkdGggKiB0aGlzLl9waXhlbFJhdGlvO1xyXG5cdFx0Y29uc3QgZWZmZWN0aXZlSGVpZ2h0ID0gdGhpcy5faGVpZ2h0ICogdGhpcy5fcGl4ZWxSYXRpbztcclxuXHJcblx0XHR0aGlzLnJlbmRlclRhcmdldC5zZXRTaXplKCBlZmZlY3RpdmVXaWR0aCwgZWZmZWN0aXZlSGVpZ2h0ICk7XHJcblxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogU2V0cyB0aGUgcGl4ZWwgcmF0aW8gdGhlIHBhc3MncyByZW5kZXIgdGFyZ2V0IGFuZCB1cGRhdGVzIHRoZSBzaXplLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHBpeGVsUmF0aW8gLSBUaGUgcGl4ZWwgcmF0aW8gdG8gc2V0LlxyXG5cdCAqL1xyXG5cdHNldFBpeGVsUmF0aW8oIHBpeGVsUmF0aW8gKSB7XHJcblxyXG5cdFx0dGhpcy5fcGl4ZWxSYXRpbyA9IHBpeGVsUmF0aW87XHJcblxyXG5cdFx0dGhpcy5zZXRTaXplKCB0aGlzLl93aWR0aCwgdGhpcy5faGVpZ2h0ICk7XHJcblxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogRnJlZXMgaW50ZXJuYWwgcmVzb3VyY2VzLiBTaG91bGQgYmUgY2FsbGVkIHdoZW4gdGhlIG5vZGUgaXMgbm8gbG9uZ2VyIGluIHVzZS5cclxuXHQgKi9cclxuXHRkaXNwb3NlKCkge1xyXG5cclxuXHRcdHRoaXMucmVuZGVyVGFyZ2V0LmRpc3Bvc2UoKTtcclxuXHJcblx0fVxyXG5cclxuXHJcbn1cclxuXHJcblBhc3NOb2RlLkNPTE9SID0gJ2NvbG9yJztcclxuUGFzc05vZGUuREVQVEggPSAnZGVwdGgnO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgUGFzc05vZGU7XHJcblxyXG4vKipcclxuICogVFNMIGZ1bmN0aW9uIGZvciBjcmVhdGluZyBhIHBhc3Mgbm9kZS5cclxuICpcclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7U2NlbmV9IHNjZW5lIC0gQSByZWZlcmVuY2UgdG8gdGhlIHNjZW5lLlxyXG4gKiBAcGFyYW0ge0NhbWVyYX0gY2FtZXJhIC0gQSByZWZlcmVuY2UgdG8gdGhlIGNhbWVyYS5cclxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBPcHRpb25zIGZvciB0aGUgaW50ZXJuYWwgcmVuZGVyIHRhcmdldC5cclxuICogQHJldHVybnMge1Bhc3NOb2RlfVxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IHBhc3MgPSAoIHNjZW5lLCBjYW1lcmEsIG9wdGlvbnMgKSA9PiBub2RlT2JqZWN0KCBuZXcgUGFzc05vZGUoIFBhc3NOb2RlLkNPTE9SLCBzY2VuZSwgY2FtZXJhLCBvcHRpb25zICkgKTtcclxuXHJcbi8qKlxyXG4gKiBUU0wgZnVuY3Rpb24gZm9yIGNyZWF0aW5nIGEgcGFzcyB0ZXh0dXJlIG5vZGUuXHJcbiAqXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0ge1Bhc3NOb2RlfSBwYXNzIC0gVGhlIHBhc3Mgbm9kZS5cclxuICogQHBhcmFtIHtUZXh0dXJlfSB0ZXh0dXJlIC0gVGhlIG91dHB1dCB0ZXh0dXJlLlxyXG4gKiBAcmV0dXJucyB7UGFzc1RleHR1cmVOb2RlfVxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IHBhc3NUZXh0dXJlID0gKCBwYXNzLCB0ZXh0dXJlICkgPT4gbm9kZU9iamVjdCggbmV3IFBhc3NUZXh0dXJlTm9kZSggcGFzcywgdGV4dHVyZSApICk7XHJcblxyXG4vKipcclxuICogVFNMIGZ1bmN0aW9uIGZvciBjcmVhdGluZyBhIGRlcHRoIHBhc3Mgbm9kZS5cclxuICpcclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7U2NlbmV9IHNjZW5lIC0gQSByZWZlcmVuY2UgdG8gdGhlIHNjZW5lLlxyXG4gKiBAcGFyYW0ge0NhbWVyYX0gY2FtZXJhIC0gQSByZWZlcmVuY2UgdG8gdGhlIGNhbWVyYS5cclxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBPcHRpb25zIGZvciB0aGUgaW50ZXJuYWwgcmVuZGVyIHRhcmdldC5cclxuICogQHJldHVybnMge1Bhc3NOb2RlfVxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IGRlcHRoUGFzcyA9ICggc2NlbmUsIGNhbWVyYSwgb3B0aW9ucyApID0+IG5vZGVPYmplY3QoIG5ldyBQYXNzTm9kZSggUGFzc05vZGUuREVQVEgsIHNjZW5lLCBjYW1lcmEsIG9wdGlvbnMgKSApO1xyXG4iLCJpbXBvcnQgeyBmbG9hdCwgbm9kZU9iamVjdCwgbm9ybWFsaXplLCB2ZWM0IH0gZnJvbSAnLi4vdHNsL1RTTEJhc2UuanMnO1xyXG5pbXBvcnQgeyBDb2xvciB9IGZyb20gJy4uLy4uL21hdGgvQ29sb3IuanMnO1xyXG5pbXBvcnQgTm9kZU1hdGVyaWFsIGZyb20gJy4uLy4uL21hdGVyaWFscy9ub2Rlcy9Ob2RlTWF0ZXJpYWwuanMnO1xyXG5pbXBvcnQgeyBjYW1lcmFQcm9qZWN0aW9uTWF0cml4IH0gZnJvbSAnLi4vLi4vbm9kZXMvYWNjZXNzb3JzL0NhbWVyYS5qcyc7XHJcbmltcG9ydCB7IG1vZGVsVmlld01hdHJpeCB9IGZyb20gJy4uLy4uL25vZGVzL2FjY2Vzc29ycy9Nb2RlbE5vZGUuanMnO1xyXG5pbXBvcnQgeyBwb3NpdGlvbkxvY2FsIH0gZnJvbSAnLi4vLi4vbm9kZXMvYWNjZXNzb3JzL1Bvc2l0aW9uLmpzJztcclxuaW1wb3J0IHsgbm9ybWFsTG9jYWwgfSBmcm9tICcuLi8uLi9ub2Rlcy9hY2Nlc3NvcnMvTm9ybWFsLmpzJztcclxuaW1wb3J0IHsgQmFja1NpZGUgfSBmcm9tICcuLi8uLi9jb25zdGFudHMuanMnO1xyXG5pbXBvcnQgUGFzc05vZGUgZnJvbSAnLi9QYXNzTm9kZS5qcyc7XHJcblxyXG4vKiogQG1vZHVsZSBUb29uT3V0bGluZVBhc3NOb2RlICoqL1xyXG5cclxuLyoqXHJcbiAqIFJlcHJlc2VudHMgYSByZW5kZXIgcGFzcyBmb3IgcHJvZHVjaW5nIGEgdG9vbiBvdXRsaW5lIGVmZmVjdCBvbiBjb21wYXRpYmxlIG9iamVjdHMuXHJcbiAqIE9ubHkgM0Qgb2JqZWN0cyB3aXRoIG1hdGVyaWFscyBvZiB0eXBlIGBNZXNoVG9vbk1hdGVyaWFsYCBhbmQgYE1lc2hUb29uTm9kZU1hdGVyaWFsYFxyXG4gKiB3aWxsIHJlY2VpdmUgdGhlIG91dGxpbmUuXHJcbiAqXHJcbiAqIGBgYGpzXHJcbiAqIGNvbnN0IHBvc3RQcm9jZXNzaW5nID0gbmV3IFBvc3RQcm9jZXNzaW5nKCByZW5kZXJlciApO1xyXG4gKlxyXG4gKiBjb25zdCBzY2VuZVBhc3MgPSB0b29uT3V0bGluZVBhc3MoIHNjZW5lLCBjYW1lcmEgKTtcclxuICpcclxuICogcG9zdFByb2Nlc3Npbmcub3V0cHV0Tm9kZSA9IHNjZW5lUGFzcztcclxuICogYGBgXHJcbiAqIEBhdWdtZW50cyBQYXNzTm9kZVxyXG4gKi9cclxuY2xhc3MgVG9vbk91dGxpbmVQYXNzTm9kZSBleHRlbmRzIFBhc3NOb2RlIHtcclxuXHJcblx0c3RhdGljIGdldCB0eXBlKCkge1xyXG5cclxuXHRcdHJldHVybiAnVG9vbk91dGxpbmVQYXNzTm9kZSc7XHJcblxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogQ29uc3RydWN0cyBhIG5ldyBvdXRsaW5lIHBhc3Mgbm9kZS5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7U2NlbmV9IHNjZW5lIC0gQSByZWZlcmVuY2UgdG8gdGhlIHNjZW5lLlxyXG5cdCAqIEBwYXJhbSB7Q2FtZXJhfSBjYW1lcmEgLSBBIHJlZmVyZW5jZSB0byB0aGUgY2FtZXJhLlxyXG5cdCAqIEBwYXJhbSB7Tm9kZX0gY29sb3JOb2RlIC0gRGVmaW5lcyB0aGUgb3V0bGluZSdzIGNvbG9yLlxyXG5cdCAqIEBwYXJhbSB7Tm9kZX0gdGhpY2tuZXNzTm9kZSAtIERlZmluZXMgdGhlIG91dGxpbmUncyB0aGlja25lc3MuXHJcblx0ICogQHBhcmFtIHtOb2RlfSBhbHBoYU5vZGUgLSBEZWZpbmVzIHRoZSBvdXRsaW5lJ3MgYWxwaGEuXHJcblx0ICovXHJcblx0Y29uc3RydWN0b3IoIHNjZW5lLCBjYW1lcmEsIGNvbG9yTm9kZSwgdGhpY2tuZXNzTm9kZSwgYWxwaGFOb2RlICkge1xyXG5cclxuXHRcdHN1cGVyKCBQYXNzTm9kZS5DT0xPUiwgc2NlbmUsIGNhbWVyYSApO1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogRGVmaW5lcyB0aGUgb3V0bGluZSdzIGNvbG9yLlxyXG5cdFx0ICpcclxuXHRcdCAqIEB0eXBlIHtOb2RlfVxyXG5cdFx0ICovXHJcblx0XHR0aGlzLmNvbG9yTm9kZSA9IGNvbG9yTm9kZTtcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIERlZmluZXMgdGhlIG91dGxpbmUncyB0aGlja25lc3MuXHJcblx0XHQgKlxyXG5cdFx0ICogQHR5cGUge05vZGV9XHJcblx0XHQgKi9cclxuXHRcdHRoaXMudGhpY2tuZXNzTm9kZSA9IHRoaWNrbmVzc05vZGU7XHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBEZWZpbmVzIHRoZSBvdXRsaW5lJ3MgYWxwaGEuXHJcblx0XHQgKlxyXG5cdFx0ICogQHR5cGUge05vZGV9XHJcblx0XHQgKi9cclxuXHRcdHRoaXMuYWxwaGFOb2RlID0gYWxwaGFOb2RlO1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogQW4gaW50ZXJuYWwgbWF0ZXJpYWwgY2FjaGUuXHJcblx0XHQgKlxyXG5cdFx0ICogQHByaXZhdGVcclxuXHRcdCAqIEB0eXBlIHtXZWFrTWFwPE1hdGVyaWFsLCBOb2RlTWF0ZXJpYWw+fVxyXG5cdFx0ICovXHJcblx0XHR0aGlzLl9tYXRlcmlhbENhY2hlID0gbmV3IFdlYWtNYXAoKTtcclxuXHJcblx0fVxyXG5cclxuXHR1cGRhdGVCZWZvcmUoIGZyYW1lICkge1xyXG5cclxuXHRcdGNvbnN0IHsgcmVuZGVyZXIgfSA9IGZyYW1lO1xyXG5cclxuXHRcdGNvbnN0IGN1cnJlbnRSZW5kZXJPYmplY3RGdW5jdGlvbiA9IHJlbmRlcmVyLmdldFJlbmRlck9iamVjdEZ1bmN0aW9uKCk7XHJcblxyXG5cdFx0cmVuZGVyZXIuc2V0UmVuZGVyT2JqZWN0RnVuY3Rpb24oICggb2JqZWN0LCBzY2VuZSwgY2FtZXJhLCBnZW9tZXRyeSwgbWF0ZXJpYWwsIGdyb3VwLCBsaWdodHNOb2RlLCBjbGlwcGluZ0NvbnRleHQgKSA9PiB7XHJcblxyXG5cdFx0XHQvLyBvbmx5IHJlbmRlciBvdXRsaW5lIGZvciBzdXBwb3J0ZWQgbWF0ZXJpYWxzXHJcblxyXG5cdFx0XHRpZiAoIG1hdGVyaWFsLmlzTWVzaFRvb25NYXRlcmlhbCB8fCBtYXRlcmlhbC5pc01lc2hUb29uTm9kZU1hdGVyaWFsICkge1xyXG5cclxuXHRcdFx0XHRpZiAoIG1hdGVyaWFsLndpcmVmcmFtZSA9PT0gZmFsc2UgKSB7XHJcblxyXG5cdFx0XHRcdFx0Y29uc3Qgb3V0bGluZU1hdGVyaWFsID0gdGhpcy5fZ2V0T3V0bGluZU1hdGVyaWFsKCBtYXRlcmlhbCApO1xyXG5cdFx0XHRcdFx0cmVuZGVyZXIucmVuZGVyT2JqZWN0KCBvYmplY3QsIHNjZW5lLCBjYW1lcmEsIGdlb21ldHJ5LCBvdXRsaW5lTWF0ZXJpYWwsIGdyb3VwLCBsaWdodHNOb2RlLCBjbGlwcGluZ0NvbnRleHQgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gZGVmYXVsdFxyXG5cclxuXHRcdFx0cmVuZGVyZXIucmVuZGVyT2JqZWN0KCBvYmplY3QsIHNjZW5lLCBjYW1lcmEsIGdlb21ldHJ5LCBtYXRlcmlhbCwgZ3JvdXAsIGxpZ2h0c05vZGUsIGNsaXBwaW5nQ29udGV4dCApO1xyXG5cclxuXHRcdH0gKTtcclxuXHJcblx0XHRzdXBlci51cGRhdGVCZWZvcmUoIGZyYW1lICk7XHJcblxyXG5cdFx0cmVuZGVyZXIuc2V0UmVuZGVyT2JqZWN0RnVuY3Rpb24oIGN1cnJlbnRSZW5kZXJPYmplY3RGdW5jdGlvbiApO1xyXG5cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIENyZWF0ZXMgdGhlIG1hdGVyaWFsIHVzZWQgZm9yIG91dGxpbmUgcmVuZGVyaW5nLlxyXG5cdCAqXHJcblx0ICogQHByaXZhdGVcclxuXHQgKiBAcmV0dXJuIHtOb2RlTWF0ZXJpYWx9IFRoZSBvdXRsaW5lIG1hdGVyaWFsLlxyXG5cdCAqL1xyXG5cdF9jcmVhdGVNYXRlcmlhbCgpIHtcclxuXHJcblx0XHRjb25zdCBtYXRlcmlhbCA9IG5ldyBOb2RlTWF0ZXJpYWwoKTtcclxuXHRcdG1hdGVyaWFsLmlzTWVzaFRvb25PdXRsaW5lTWF0ZXJpYWwgPSB0cnVlO1xyXG5cdFx0bWF0ZXJpYWwubmFtZSA9ICdUb29uX091dGxpbmUnO1xyXG5cdFx0bWF0ZXJpYWwuc2lkZSA9IEJhY2tTaWRlO1xyXG5cclxuXHRcdC8vIHZlcnRleCBub2RlXHJcblxyXG5cdFx0Y29uc3Qgb3V0bGluZU5vcm1hbCA9IG5vcm1hbExvY2FsLm5lZ2F0ZSgpO1xyXG5cdFx0Y29uc3QgbXZwID0gY2FtZXJhUHJvamVjdGlvbk1hdHJpeC5tdWwoIG1vZGVsVmlld01hdHJpeCApO1xyXG5cclxuXHRcdGNvbnN0IHJhdGlvID0gZmxvYXQoIDEuMCApOyAvLyBUT0RPOiBzdXBwb3J0IG91dGxpbmUgdGhpY2tuZXNzIHJhdGlvIGZvciBlYWNoIHZlcnRleFxyXG5cdFx0Y29uc3QgcG9zID0gbXZwLm11bCggdmVjNCggcG9zaXRpb25Mb2NhbCwgMS4wICkgKTtcclxuXHRcdGNvbnN0IHBvczIgPSBtdnAubXVsKCB2ZWM0KCBwb3NpdGlvbkxvY2FsLmFkZCggb3V0bGluZU5vcm1hbCApLCAxLjAgKSApO1xyXG5cdFx0Y29uc3Qgbm9ybSA9IG5vcm1hbGl6ZSggcG9zLnN1YiggcG9zMiApICk7IC8vIE5PVEU6IHN1YnRyYWN0IHBvczIgZnJvbSBwb3MgYmVjYXVzZSBCYWNrU2lkZSBvYmplY3ROb3JtYWwgaXMgbmVnYXRpdmVcclxuXHJcblx0XHRtYXRlcmlhbC52ZXJ0ZXhOb2RlID0gcG9zLmFkZCggbm9ybS5tdWwoIHRoaXMudGhpY2tuZXNzTm9kZSApLm11bCggcG9zLncgKS5tdWwoIHJhdGlvICkgKTtcclxuXHJcblx0XHQvLyBjb2xvciBub2RlXHJcblxyXG5cdFx0bWF0ZXJpYWwuY29sb3JOb2RlID0gdmVjNCggdGhpcy5jb2xvck5vZGUsIHRoaXMuYWxwaGFOb2RlICk7XHJcblxyXG5cdFx0cmV0dXJuIG1hdGVyaWFsO1xyXG5cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEZvciB0aGUgZ2l2ZW4gdG9vbiBtYXRlcmlhbCwgdGhpcyBtZXRob2QgcmV0dXJucyBhIGNvcnJlc3BvbmRpbmdcclxuXHQgKiBvdXRsaW5lIG1hdGVyaWFsLlxyXG5cdCAqXHJcblx0ICogQHByaXZhdGVcclxuXHQgKiBAcGFyYW0geyhNZXNoVG9vbk1hdGVyaWFsfE1lc2hUb29uTm9kZU1hdGVyaWFsKX0gb3JpZ2luYWxNYXRlcmlhbCAtIFRoZSB0b29uIG1hdGVyaWFsLlxyXG5cdCAqIEByZXR1cm4ge05vZGVNYXRlcmlhbH0gVGhlIG91dGxpbmUgbWF0ZXJpYWwuXHJcblx0ICovXHJcblx0X2dldE91dGxpbmVNYXRlcmlhbCggb3JpZ2luYWxNYXRlcmlhbCApIHtcclxuXHJcblx0XHRsZXQgb3V0bGluZU1hdGVyaWFsID0gdGhpcy5fbWF0ZXJpYWxDYWNoZS5nZXQoIG9yaWdpbmFsTWF0ZXJpYWwgKTtcclxuXHJcblx0XHRpZiAoIG91dGxpbmVNYXRlcmlhbCA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0b3V0bGluZU1hdGVyaWFsID0gdGhpcy5fY3JlYXRlTWF0ZXJpYWwoKTtcclxuXHJcblx0XHRcdHRoaXMuX21hdGVyaWFsQ2FjaGUuc2V0KCBvcmlnaW5hbE1hdGVyaWFsLCBvdXRsaW5lTWF0ZXJpYWwgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIG91dGxpbmVNYXRlcmlhbDtcclxuXHJcblx0fVxyXG5cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgVG9vbk91dGxpbmVQYXNzTm9kZTtcclxuXHJcbi8qKlxyXG4gKiBUU0wgZnVuY3Rpb24gZm9yIGNyZWF0aW5nIGEgdG9vbiBvdXRsaW5lIHBhc3Mgbm9kZS5cclxuICpcclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7U2NlbmV9IHNjZW5lIC0gQSByZWZlcmVuY2UgdG8gdGhlIHNjZW5lLlxyXG4gKiBAcGFyYW0ge0NhbWVyYX0gY2FtZXJhIC0gQSByZWZlcmVuY2UgdG8gdGhlIGNhbWVyYS5cclxuICogQHBhcmFtIHtDb2xvcn0gY29sb3IgLSBEZWZpbmVzIHRoZSBvdXRsaW5lJ3MgY29sb3IuXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBbdGhpY2tuZXNzPTAuMDAzXSAtIERlZmluZXMgdGhlIG91dGxpbmUncyB0aGlja25lc3MuXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBbYWxwaGE9MV0gLSBEZWZpbmVzIHRoZSBvdXRsaW5lJ3MgYWxwaGEuXHJcbiAqIEByZXR1cm5zIHtUb29uT3V0bGluZVBhc3NOb2RlfVxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IHRvb25PdXRsaW5lUGFzcyA9ICggc2NlbmUsIGNhbWVyYSwgY29sb3IgPSBuZXcgQ29sb3IoIDAsIDAsIDAgKSwgdGhpY2tuZXNzID0gMC4wMDMsIGFscGhhID0gMSApID0+IG5vZGVPYmplY3QoIG5ldyBUb29uT3V0bGluZVBhc3NOb2RlKCBzY2VuZSwgY2FtZXJhLCBub2RlT2JqZWN0KCBjb2xvciApLCBub2RlT2JqZWN0KCB0aGlja25lc3MgKSwgbm9kZU9iamVjdCggYWxwaGEgKSApICk7XHJcbiIsImltcG9ydCB7IEZuLCBmbG9hdCwgbWF0MywgdmVjMywgSWYgfSBmcm9tICcuLi90c2wvVFNMQmFzZS5qcyc7XHJcbmltcG9ydCB7IHNlbGVjdCB9IGZyb20gJy4uL21hdGgvQ29uZGl0aW9uYWxOb2RlLmpzJztcclxuaW1wb3J0IHsgY2xhbXAsIGxvZzIsIG1heCwgbWluLCBwb3csIG1peCB9IGZyb20gJy4uL21hdGgvTWF0aE5vZGUuanMnO1xyXG5pbXBvcnQgeyBtdWwsIHN1YiwgZGl2IH0gZnJvbSAnLi4vbWF0aC9PcGVyYXRvck5vZGUuanMnO1xyXG5cclxuLyoqIEBtb2R1bGUgVG9uZU1hcHBpbmdGdW5jdGlvbnMgKiovXHJcblxyXG4vKipcclxuICogTGluZWFyIHRvbmUgbWFwcGluZywgZXhwb3N1cmUgb25seS5cclxuICpcclxuICogQG1ldGhvZFxyXG4gKiBAcGFyYW0ge05vZGU8dmVjMz59IGNvbG9yIC0gVGhlIGNvbG9yIHRoYXQgc2hvdWxkIGJlIHRvbmUgbWFwcGVkLlxyXG4gKiBAcGFyYW0ge05vZGU8ZmxvYXQ+fSBleHBvc3VyZSAtIFRoZSBleHBvc3VyZS5cclxuICogQHJldHVybiB7Tm9kZTx2ZWMzPn0gVGhlIHRvbmUgbWFwcGVkIGNvbG9yLlxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IGxpbmVhclRvbmVNYXBwaW5nID0gLypAX19QVVJFX18qLyBGbiggKCBbIGNvbG9yLCBleHBvc3VyZSBdICkgPT4ge1xyXG5cclxuXHRyZXR1cm4gY29sb3IubXVsKCBleHBvc3VyZSApLmNsYW1wKCk7XHJcblxyXG59ICkuc2V0TGF5b3V0KCB7XHJcblx0bmFtZTogJ2xpbmVhclRvbmVNYXBwaW5nJyxcclxuXHR0eXBlOiAndmVjMycsXHJcblx0aW5wdXRzOiBbXHJcblx0XHR7IG5hbWU6ICdjb2xvcicsIHR5cGU6ICd2ZWMzJyB9LFxyXG5cdFx0eyBuYW1lOiAnZXhwb3N1cmUnLCB0eXBlOiAnZmxvYXQnIH1cclxuXHRdXHJcbn0gKTtcclxuXHJcbi8qKlxyXG4gKiBSZWluaGFyZCB0b25lIG1hcHBpbmcuXHJcbiAqXHJcbiAqIFJlZmVyZW5jZToge0BsaW5rIGh0dHBzOi8vd3d3LmNzLnV0YWguZWR1L2RvY3MvdGVjaHJlcG9ydHMvMjAwMi9wZGYvVVVDUy0wMi0wMDEucGRmfVxyXG4gKlxyXG4gKiBAbWV0aG9kXHJcbiAqIEBwYXJhbSB7Tm9kZTx2ZWMzPn0gY29sb3IgLSBUaGUgY29sb3IgdGhhdCBzaG91bGQgYmUgdG9uZSBtYXBwZWQuXHJcbiAqIEBwYXJhbSB7Tm9kZTxmbG9hdD59IGV4cG9zdXJlIC0gVGhlIGV4cG9zdXJlLlxyXG4gKiBAcmV0dXJuIHtOb2RlPHZlYzM+fSBUaGUgdG9uZSBtYXBwZWQgY29sb3IuXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgcmVpbmhhcmRUb25lTWFwcGluZyA9IC8qQF9fUFVSRV9fKi8gRm4oICggWyBjb2xvciwgZXhwb3N1cmUgXSApID0+IHtcclxuXHJcblx0Y29sb3IgPSBjb2xvci5tdWwoIGV4cG9zdXJlICk7XHJcblxyXG5cdHJldHVybiBjb2xvci5kaXYoIGNvbG9yLmFkZCggMS4wICkgKS5jbGFtcCgpO1xyXG5cclxufSApLnNldExheW91dCgge1xyXG5cdG5hbWU6ICdyZWluaGFyZFRvbmVNYXBwaW5nJyxcclxuXHR0eXBlOiAndmVjMycsXHJcblx0aW5wdXRzOiBbXHJcblx0XHR7IG5hbWU6ICdjb2xvcicsIHR5cGU6ICd2ZWMzJyB9LFxyXG5cdFx0eyBuYW1lOiAnZXhwb3N1cmUnLCB0eXBlOiAnZmxvYXQnIH1cclxuXHRdXHJcbn0gKTtcclxuXHJcbi8qKlxyXG4gKiBDaW5lb24gdG9uZSBtYXBwaW5nLlxyXG4gKlxyXG4gKiBSZWZlcmVuY2U6IHtAbGluayBodHRwOi8vZmlsbWljd29ybGRzLmNvbS9ibG9nL2ZpbG1pYy10b25lbWFwcGluZy1vcGVyYXRvcnMvfVxyXG4gKlxyXG4gKiBAbWV0aG9kXHJcbiAqIEBwYXJhbSB7Tm9kZTx2ZWMzPn0gY29sb3IgLSBUaGUgY29sb3IgdGhhdCBzaG91bGQgYmUgdG9uZSBtYXBwZWQuXHJcbiAqIEBwYXJhbSB7Tm9kZTxmbG9hdD59IGV4cG9zdXJlIC0gVGhlIGV4cG9zdXJlLlxyXG4gKiBAcmV0dXJuIHtOb2RlPHZlYzM+fSBUaGUgdG9uZSBtYXBwZWQgY29sb3IuXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgY2luZW9uVG9uZU1hcHBpbmcgPSAvKkBfX1BVUkVfXyovIEZuKCAoIFsgY29sb3IsIGV4cG9zdXJlIF0gKSA9PiB7XHJcblxyXG5cdC8vIGZpbG1pYyBvcGVyYXRvciBieSBKaW0gSGVqbCBhbmQgUmljaGFyZCBCdXJnZXNzLURhd3NvblxyXG5cdGNvbG9yID0gY29sb3IubXVsKCBleHBvc3VyZSApO1xyXG5cdGNvbG9yID0gY29sb3Iuc3ViKCAwLjAwNCApLm1heCggMC4wICk7XHJcblxyXG5cdGNvbnN0IGEgPSBjb2xvci5tdWwoIGNvbG9yLm11bCggNi4yICkuYWRkKCAwLjUgKSApO1xyXG5cdGNvbnN0IGIgPSBjb2xvci5tdWwoIGNvbG9yLm11bCggNi4yICkuYWRkKCAxLjcgKSApLmFkZCggMC4wNiApO1xyXG5cclxuXHRyZXR1cm4gYS5kaXYoIGIgKS5wb3coIDIuMiApO1xyXG5cclxufSApLnNldExheW91dCgge1xyXG5cdG5hbWU6ICdjaW5lb25Ub25lTWFwcGluZycsXHJcblx0dHlwZTogJ3ZlYzMnLFxyXG5cdGlucHV0czogW1xyXG5cdFx0eyBuYW1lOiAnY29sb3InLCB0eXBlOiAndmVjMycgfSxcclxuXHRcdHsgbmFtZTogJ2V4cG9zdXJlJywgdHlwZTogJ2Zsb2F0JyB9XHJcblx0XVxyXG59ICk7XHJcblxyXG4vLyBzb3VyY2U6IGh0dHBzOi8vZ2l0aHViLmNvbS9zZWxmc2hhZG93L2x0Y19jb2RlL2Jsb2IvbWFzdGVyL3dlYmdsL3NoYWRlcnMvbHRjL2x0Y19ibGl0LmZzXHJcblxyXG5jb25zdCBSUlRBbmRPRFRGaXQgPSAvKkBfX1BVUkVfXyovIEZuKCAoIFsgY29sb3IgXSApID0+IHtcclxuXHJcblx0Y29uc3QgYSA9IGNvbG9yLm11bCggY29sb3IuYWRkKCAwLjAyNDU3ODYgKSApLnN1YiggMC4wMDAwOTA1MzcgKTtcclxuXHRjb25zdCBiID0gY29sb3IubXVsKCBjb2xvci5hZGQoIDAuNDMyOTUxMCApLm11bCggMC45ODM3MjkgKSApLmFkZCggMC4yMzgwODEgKTtcclxuXHJcblx0cmV0dXJuIGEuZGl2KCBiICk7XHJcblxyXG59ICk7XHJcblxyXG4vKipcclxuICogQUNFU0ZpbG1pYyB0b25lIG1hcHBpbmcuXHJcbiAqXHJcbiAqIFJlZmVyZW5jZToge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9zZWxmc2hhZG93L2x0Y19jb2RlL2Jsb2IvbWFzdGVyL3dlYmdsL3NoYWRlcnMvbHRjL2x0Y19ibGl0LmZzfVxyXG4gKlxyXG4gKiBAbWV0aG9kXHJcbiAqIEBwYXJhbSB7Tm9kZTx2ZWMzPn0gY29sb3IgLSBUaGUgY29sb3IgdGhhdCBzaG91bGQgYmUgdG9uZSBtYXBwZWQuXHJcbiAqIEBwYXJhbSB7Tm9kZTxmbG9hdD59IGV4cG9zdXJlIC0gVGhlIGV4cG9zdXJlLlxyXG4gKiBAcmV0dXJuIHtOb2RlPHZlYzM+fSBUaGUgdG9uZSBtYXBwZWQgY29sb3IuXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgYWNlc0ZpbG1pY1RvbmVNYXBwaW5nID0gLypAX19QVVJFX18qLyBGbiggKCBbIGNvbG9yLCBleHBvc3VyZSBdICkgPT4ge1xyXG5cclxuXHQvLyBzUkdCID0+IFhZWiA9PiBENjVfMl9ENjAgPT4gQVAxID0+IFJSVF9TQVRcclxuXHRjb25zdCBBQ0VTSW5wdXRNYXQgPSBtYXQzKFxyXG5cdFx0MC41OTcxOSwgMC4zNTQ1OCwgMC4wNDgyMyxcclxuXHRcdDAuMDc2MDAsIDAuOTA4MzQsIDAuMDE1NjYsXHJcblx0XHQwLjAyODQwLCAwLjEzMzgzLCAwLjgzNzc3XHJcblx0KTtcclxuXHJcblx0Ly8gT0RUX1NBVCA9PiBYWVogPT4gRDYwXzJfRDY1ID0+IHNSR0JcclxuXHRjb25zdCBBQ0VTT3V0cHV0TWF0ID0gbWF0MyhcclxuXHRcdDEuNjA0NzUsIC0gMC41MzEwOCwgLSAwLjA3MzY3LFxyXG5cdFx0LSAwLjEwMjA4LCAxLjEwODEzLCAtIDAuMDA2MDUsXHJcblx0XHQtIDAuMDAzMjcsIC0gMC4wNzI3NiwgMS4wNzYwMlxyXG5cdCk7XHJcblxyXG5cdGNvbG9yID0gY29sb3IubXVsKCBleHBvc3VyZSApLmRpdiggMC42ICk7XHJcblxyXG5cdGNvbG9yID0gQUNFU0lucHV0TWF0Lm11bCggY29sb3IgKTtcclxuXHJcblx0Ly8gQXBwbHkgUlJUIGFuZCBPRFRcclxuXHRjb2xvciA9IFJSVEFuZE9EVEZpdCggY29sb3IgKTtcclxuXHJcblx0Y29sb3IgPSBBQ0VTT3V0cHV0TWF0Lm11bCggY29sb3IgKTtcclxuXHJcblx0Ly8gQ2xhbXAgdG8gWzAsIDFdXHJcblx0cmV0dXJuIGNvbG9yLmNsYW1wKCk7XHJcblxyXG59ICkuc2V0TGF5b3V0KCB7XHJcblx0bmFtZTogJ2FjZXNGaWxtaWNUb25lTWFwcGluZycsXHJcblx0dHlwZTogJ3ZlYzMnLFxyXG5cdGlucHV0czogW1xyXG5cdFx0eyBuYW1lOiAnY29sb3InLCB0eXBlOiAndmVjMycgfSxcclxuXHRcdHsgbmFtZTogJ2V4cG9zdXJlJywgdHlwZTogJ2Zsb2F0JyB9XHJcblx0XVxyXG59ICk7XHJcblxyXG5jb25zdCBMSU5FQVJfUkVDMjAyMF9UT19MSU5FQVJfU1JHQiA9IC8qQF9fUFVSRV9fKi8gbWF0MyggdmVjMyggMS42NjA1LCAtIDAuMTI0NiwgLSAwLjAxODIgKSwgdmVjMyggLSAwLjU4NzYsIDEuMTMyOSwgLSAwLjEwMDYgKSwgdmVjMyggLSAwLjA3MjgsIC0gMC4wMDgzLCAxLjExODcgKSApO1xyXG5jb25zdCBMSU5FQVJfU1JHQl9UT19MSU5FQVJfUkVDMjAyMCA9IC8qQF9fUFVSRV9fKi8gbWF0MyggdmVjMyggMC42Mjc0LCAwLjA2OTEsIDAuMDE2NCApLCB2ZWMzKCAwLjMyOTMsIDAuOTE5NSwgMC4wODgwICksIHZlYzMoIDAuMDQzMywgMC4wMTEzLCAwLjg5NTYgKSApO1xyXG5cclxuY29uc3QgYWd4RGVmYXVsdENvbnRyYXN0QXBwcm94ID0gLypAX19QVVJFX18qLyBGbiggKCBbIHhfaW1tdXRhYmxlIF0gKSA9PiB7XHJcblxyXG5cdGNvbnN0IHggPSB2ZWMzKCB4X2ltbXV0YWJsZSApLnRvVmFyKCk7XHJcblx0Y29uc3QgeDIgPSB2ZWMzKCB4Lm11bCggeCApICkudG9WYXIoKTtcclxuXHRjb25zdCB4NCA9IHZlYzMoIHgyLm11bCggeDIgKSApLnRvVmFyKCk7XHJcblxyXG5cdHJldHVybiBmbG9hdCggMTUuNSApLm11bCggeDQubXVsKCB4MiApICkuc3ViKCBtdWwoIDQwLjE0LCB4NC5tdWwoIHggKSApICkuYWRkKCBtdWwoIDMxLjk2LCB4NCApLnN1YiggbXVsKCA2Ljg2OCwgeDIubXVsKCB4ICkgKSApLmFkZCggbXVsKCAwLjQyOTgsIHgyICkuYWRkKCBtdWwoIDAuMTE5MSwgeCApLnN1YiggMC4wMDIzMiApICkgKSApO1xyXG5cclxufSApO1xyXG5cclxuLyoqXHJcbiAqIEFnWCB0b25lIG1hcHBpbmcuXHJcbiAqXHJcbiAqIEBtZXRob2RcclxuICogQHBhcmFtIHtOb2RlPHZlYzM+fSBjb2xvciAtIFRoZSBjb2xvciB0aGF0IHNob3VsZCBiZSB0b25lIG1hcHBlZC5cclxuICogQHBhcmFtIHtOb2RlPGZsb2F0Pn0gZXhwb3N1cmUgLSBUaGUgZXhwb3N1cmUuXHJcbiAqIEByZXR1cm4ge05vZGU8dmVjMz59IFRoZSB0b25lIG1hcHBlZCBjb2xvci5cclxuICovXHJcbmV4cG9ydCBjb25zdCBhZ3hUb25lTWFwcGluZyA9IC8qQF9fUFVSRV9fKi8gRm4oICggWyBjb2xvciwgZXhwb3N1cmUgXSApID0+IHtcclxuXHJcblx0Y29uc3QgY29sb3J0b25lID0gdmVjMyggY29sb3IgKS50b1ZhcigpO1xyXG5cdGNvbnN0IEFnWEluc2V0TWF0cml4ID0gbWF0MyggdmVjMyggMC44NTY2MjcxNTMzMTU5ODMsIDAuMTM3MzE4OTcyOTI5ODQ3LCAwLjExMTg5ODIxMjk5OTk1ICksIHZlYzMoIDAuMDk1MTIxMjQwNTM4MTU4OCwgMC43NjEyNDE5OTA2MDI1OTEsIDAuMDc2Nzk5NDE4NjAzMTkwMyApLCB2ZWMzKCAwLjA0ODI1MTYwNjE0NTg1ODMsIDAuMTAxNDM5MDM2NDY3NTYyLCAwLjgxMTMwMjM2ODM5Njg1OSApICk7XHJcblx0Y29uc3QgQWdYT3V0c2V0TWF0cml4ID0gbWF0MyggdmVjMyggMS4xMjcxMDA1ODE4MTQ0MzY4LCAtIDAuMTQxMzI5NzYzNDk4NDM4MywgLSAwLjE0MTMyOTc2MzQ5ODQzODI2ICksIHZlYzMoIC0gMC4xMTA2MDY2NDMwOTY2MDMyMywgMS4xNTc4MjM3MDIyMTYyNzIsIC0gMC4xMTA2MDY2NDMwOTY2MDI5NCApLCB2ZWMzKCAtIDAuMDE2NDkzOTM4NzE3ODM0NTczLCAtIDAuMDE2NDkzOTM4NzE3ODM0MjU3LCAxLjI1MTkzNjQwNjU5NTA0MDUgKSApO1xyXG5cdGNvbnN0IEFneE1pbkV2ID0gZmxvYXQoIC0gMTIuNDczOTMgKTtcclxuXHRjb25zdCBBZ3hNYXhFdiA9IGZsb2F0KCA0LjAyNjA2OSApO1xyXG5cdGNvbG9ydG9uZS5tdWxBc3NpZ24oIGV4cG9zdXJlICk7XHJcblx0Y29sb3J0b25lLmFzc2lnbiggTElORUFSX1NSR0JfVE9fTElORUFSX1JFQzIwMjAubXVsKCBjb2xvcnRvbmUgKSApO1xyXG5cdGNvbG9ydG9uZS5hc3NpZ24oIEFnWEluc2V0TWF0cml4Lm11bCggY29sb3J0b25lICkgKTtcclxuXHRjb2xvcnRvbmUuYXNzaWduKCBtYXgoIGNvbG9ydG9uZSwgMWUtMTAgKSApO1xyXG5cdGNvbG9ydG9uZS5hc3NpZ24oIGxvZzIoIGNvbG9ydG9uZSApICk7XHJcblx0Y29sb3J0b25lLmFzc2lnbiggY29sb3J0b25lLnN1YiggQWd4TWluRXYgKS5kaXYoIEFneE1heEV2LnN1YiggQWd4TWluRXYgKSApICk7XHJcblx0Y29sb3J0b25lLmFzc2lnbiggY2xhbXAoIGNvbG9ydG9uZSwgMC4wLCAxLjAgKSApO1xyXG5cdGNvbG9ydG9uZS5hc3NpZ24oIGFneERlZmF1bHRDb250cmFzdEFwcHJveCggY29sb3J0b25lICkgKTtcclxuXHRjb2xvcnRvbmUuYXNzaWduKCBBZ1hPdXRzZXRNYXRyaXgubXVsKCBjb2xvcnRvbmUgKSApO1xyXG5cdGNvbG9ydG9uZS5hc3NpZ24oIHBvdyggbWF4KCB2ZWMzKCAwLjAgKSwgY29sb3J0b25lICksIHZlYzMoIDIuMiApICkgKTtcclxuXHRjb2xvcnRvbmUuYXNzaWduKCBMSU5FQVJfUkVDMjAyMF9UT19MSU5FQVJfU1JHQi5tdWwoIGNvbG9ydG9uZSApICk7XHJcblx0Y29sb3J0b25lLmFzc2lnbiggY2xhbXAoIGNvbG9ydG9uZSwgMC4wLCAxLjAgKSApO1xyXG5cclxuXHRyZXR1cm4gY29sb3J0b25lO1xyXG5cclxufSApLnNldExheW91dCgge1xyXG5cdG5hbWU6ICdhZ3hUb25lTWFwcGluZycsXHJcblx0dHlwZTogJ3ZlYzMnLFxyXG5cdGlucHV0czogW1xyXG5cdFx0eyBuYW1lOiAnY29sb3InLCB0eXBlOiAndmVjMycgfSxcclxuXHRcdHsgbmFtZTogJ2V4cG9zdXJlJywgdHlwZTogJ2Zsb2F0JyB9XHJcblx0XVxyXG59ICk7XHJcblxyXG4vKipcclxuICogTmV1dHJhbCB0b25lIG1hcHBpbmcuXHJcbiAqXHJcbiAqIFJlZmVyZW5jZToge0BsaW5rIGh0dHBzOi8vbW9kZWx2aWV3ZXIuZGV2L2V4YW1wbGVzL3RvbmUtbWFwcGluZ31cclxuICpcclxuICogQG1ldGhvZFxyXG4gKiBAcGFyYW0ge05vZGU8dmVjMz59IGNvbG9yIC0gVGhlIGNvbG9yIHRoYXQgc2hvdWxkIGJlIHRvbmUgbWFwcGVkLlxyXG4gKiBAcGFyYW0ge05vZGU8ZmxvYXQ+fSBleHBvc3VyZSAtIFRoZSBleHBvc3VyZS5cclxuICogQHJldHVybiB7Tm9kZTx2ZWMzPn0gVGhlIHRvbmUgbWFwcGVkIGNvbG9yLlxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IG5ldXRyYWxUb25lTWFwcGluZyA9IC8qQF9fUFVSRV9fKi8gRm4oICggWyBjb2xvciwgZXhwb3N1cmUgXSApID0+IHtcclxuXHJcblx0Y29uc3QgU3RhcnRDb21wcmVzc2lvbiA9IGZsb2F0KCAwLjggLSAwLjA0ICk7XHJcblx0Y29uc3QgRGVzYXR1cmF0aW9uID0gZmxvYXQoIDAuMTUgKTtcclxuXHJcblx0Y29sb3IgPSBjb2xvci5tdWwoIGV4cG9zdXJlICk7XHJcblxyXG5cdGNvbnN0IHggPSBtaW4oIGNvbG9yLnIsIG1pbiggY29sb3IuZywgY29sb3IuYiApICk7XHJcblx0Y29uc3Qgb2Zmc2V0ID0gc2VsZWN0KCB4Lmxlc3NUaGFuKCAwLjA4ICksIHguc3ViKCBtdWwoIDYuMjUsIHgubXVsKCB4ICkgKSApLCAwLjA0ICk7XHJcblxyXG5cdGNvbG9yLnN1YkFzc2lnbiggb2Zmc2V0ICk7XHJcblxyXG5cdGNvbnN0IHBlYWsgPSBtYXgoIGNvbG9yLnIsIG1heCggY29sb3IuZywgY29sb3IuYiApICk7XHJcblxyXG5cdElmKCBwZWFrLmxlc3NUaGFuKCBTdGFydENvbXByZXNzaW9uICksICgpID0+IHtcclxuXHJcblx0XHRyZXR1cm4gY29sb3I7XHJcblxyXG5cdH0gKTtcclxuXHJcblx0Y29uc3QgZCA9IHN1YiggMSwgU3RhcnRDb21wcmVzc2lvbiApO1xyXG5cdGNvbnN0IG5ld1BlYWsgPSBzdWIoIDEsIGQubXVsKCBkICkuZGl2KCBwZWFrLmFkZCggZC5zdWIoIFN0YXJ0Q29tcHJlc3Npb24gKSApICkgKTtcclxuXHRjb2xvci5tdWxBc3NpZ24oIG5ld1BlYWsuZGl2KCBwZWFrICkgKTtcclxuXHRjb25zdCBnID0gc3ViKCAxLCBkaXYoIDEsIERlc2F0dXJhdGlvbi5tdWwoIHBlYWsuc3ViKCBuZXdQZWFrICkgKS5hZGQoIDEgKSApICk7XHJcblxyXG5cdHJldHVybiBtaXgoIGNvbG9yLCB2ZWMzKCBuZXdQZWFrICksIGcgKTtcclxuXHJcbn0gKS5zZXRMYXlvdXQoIHtcclxuXHRuYW1lOiAnbmV1dHJhbFRvbmVNYXBwaW5nJyxcclxuXHR0eXBlOiAndmVjMycsXHJcblx0aW5wdXRzOiBbXHJcblx0XHR7IG5hbWU6ICdjb2xvcicsIHR5cGU6ICd2ZWMzJyB9LFxyXG5cdFx0eyBuYW1lOiAnZXhwb3N1cmUnLCB0eXBlOiAnZmxvYXQnIH1cclxuXHRdXHJcbn0gKTtcclxuIiwiaW1wb3J0IE5vZGUgZnJvbSAnLi4vY29yZS9Ob2RlLmpzJztcclxuaW1wb3J0IHsgbm9kZVByb3h5IH0gZnJvbSAnLi4vdHNsL1RTTEJhc2UuanMnO1xyXG5cclxuLyoqIEBtb2R1bGUgQ29kZU5vZGUgKiovXHJcblxyXG4vKipcclxuICogVGhpcyBjbGFzcyByZXByZXNlbnRzIG5hdGl2ZSBjb2RlIHNlY3Rpb25zLiBJdCBpcyB0aGUgYmFzZVxyXG4gKiBjbGFzcyBmb3IgbW9kdWxlcyBsaWtlIHtAbGluayBGdW5jdGlvbk5vZGV9IHdoaWNoIGFsbG93cyB0byBpbXBsZW1lbnRcclxuICogZnVuY3Rpb25zIHdpdGggbmF0aXZlIHNoYWRlciBsYW5ndWFnZXMuXHJcbiAqXHJcbiAqIEBhdWdtZW50cyBOb2RlXHJcbiAqL1xyXG5jbGFzcyBDb2RlTm9kZSBleHRlbmRzIE5vZGUge1xyXG5cclxuXHRzdGF0aWMgZ2V0IHR5cGUoKSB7XHJcblxyXG5cdFx0cmV0dXJuICdDb2RlTm9kZSc7XHJcblxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogQ29uc3RydWN0cyBhIG5ldyBjb2RlIG5vZGUuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge1N0cmluZ30gW2NvZGU9JyddIC0gVGhlIG5hdGl2ZSBjb2RlLlxyXG5cdCAqIEBwYXJhbSB7QXJyYXk8Tm9kZT59IFtpbmNsdWRlcz1bXV0gLSBBbiBhcnJheSBvZiBpbmNsdWRlcy5cclxuXHQgKiBAcGFyYW0geygnanMnfCd3Z3NsJ3wnZ2xzbCcpfSBbbGFuZ3VhZ2U9JyddIC0gVGhlIHVzZWQgbGFuZ3VhZ2UuXHJcblx0ICovXHJcblx0Y29uc3RydWN0b3IoIGNvZGUgPSAnJywgaW5jbHVkZXMgPSBbXSwgbGFuZ3VhZ2UgPSAnJyApIHtcclxuXHJcblx0XHRzdXBlciggJ2NvZGUnICk7XHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBUaGlzIGZsYWcgY2FuIGJlIHVzZWQgZm9yIHR5cGUgdGVzdGluZy5cclxuXHRcdCAqXHJcblx0XHQgKiBAdHlwZSB7Qm9vbGVhbn1cclxuXHRcdCAqIEByZWFkb25seVxyXG5cdFx0ICogQGRlZmF1bHQgdHJ1ZVxyXG5cdFx0ICovXHJcblx0XHR0aGlzLmlzQ29kZU5vZGUgPSB0cnVlO1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogVGhlIG5hdGl2ZSBjb2RlLlxyXG5cdFx0ICpcclxuXHRcdCAqIEB0eXBlIHtTdHJpbmd9XHJcblx0XHQgKiBAZGVmYXVsdCAnJ1xyXG5cdFx0ICovXHJcblx0XHR0aGlzLmNvZGUgPSBjb2RlO1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogQW4gYXJyYXkgb2YgaW5jbHVkZXNcclxuXHRcdCAqXHJcblx0XHQgKiBAdHlwZSB7QXJyYXk8Tm9kZT59XHJcblx0XHQgKiBAZGVmYXVsdCBbXVxyXG5cdFx0ICovXHJcblx0XHR0aGlzLmluY2x1ZGVzID0gaW5jbHVkZXM7XHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBUaGUgdXNlZCBsYW5ndWFnZS5cclxuXHRcdCAqXHJcblx0XHQgKiBAdHlwZSB7KCdqcyd8J3dnc2wnfCdnbHNsJyl9XHJcblx0XHQgKiBAZGVmYXVsdCAnJ1xyXG5cdFx0ICovXHJcblx0XHR0aGlzLmxhbmd1YWdlID0gbGFuZ3VhZ2U7XHJcblxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogVGhlIG1ldGhvZCBpcyBvdmVyd3JpdHRlbiBzbyBpdCBhbHdheXMgcmV0dXJucyBgdHJ1ZWAuXHJcblx0ICpcclxuXHQgKiBAcmV0dXJuIHtCb29sZWFufSBXaGV0aGVyIHRoaXMgbm9kZSBpcyBnbG9iYWwgb3Igbm90LlxyXG5cdCAqL1xyXG5cdGlzR2xvYmFsKCkge1xyXG5cclxuXHRcdHJldHVybiB0cnVlO1xyXG5cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFNldHMgdGhlIGluY2x1ZGVzIG9mIHRoaXMgY29kZSBub2RlLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtBcnJheTxOb2RlPn0gaW5jbHVkZXMgLSBUaGUgaW5jbHVkZXMgdG8gc2V0LlxyXG5cdCAqIEByZXR1cm4ge0NvZGVOb2RlfSBBIHJlZmVyZW5jZSB0byB0aGlzIG5vZGUuXHJcblx0ICovXHJcblx0c2V0SW5jbHVkZXMoIGluY2x1ZGVzICkge1xyXG5cclxuXHRcdHRoaXMuaW5jbHVkZXMgPSBpbmNsdWRlcztcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBSZXR1cm5zIHRoZSBpbmNsdWRlcyBvZiB0aGlzIGNvZGUgbm9kZS5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7Tm9kZUJ1aWxkZXJ9IGJ1aWxkZXIgLSBUaGUgY3VycmVudCBub2RlIGJ1aWxkZXIuXHJcblx0ICogQHJldHVybiB7QXJyYXk8Tm9kZT59IFRoZSBpbmNsdWRlcy5cclxuXHQgKi9cclxuXHRnZXRJbmNsdWRlcyggLypidWlsZGVyKi8gKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuaW5jbHVkZXM7XHJcblxyXG5cdH1cclxuXHJcblx0Z2VuZXJhdGUoIGJ1aWxkZXIgKSB7XHJcblxyXG5cdFx0Y29uc3QgaW5jbHVkZXMgPSB0aGlzLmdldEluY2x1ZGVzKCBidWlsZGVyICk7XHJcblxyXG5cdFx0Zm9yICggY29uc3QgaW5jbHVkZSBvZiBpbmNsdWRlcyApIHtcclxuXHJcblx0XHRcdGluY2x1ZGUuYnVpbGQoIGJ1aWxkZXIgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Y29uc3Qgbm9kZUNvZGUgPSBidWlsZGVyLmdldENvZGVGcm9tTm9kZSggdGhpcywgdGhpcy5nZXROb2RlVHlwZSggYnVpbGRlciApICk7XHJcblx0XHRub2RlQ29kZS5jb2RlID0gdGhpcy5jb2RlO1xyXG5cclxuXHRcdHJldHVybiBub2RlQ29kZS5jb2RlO1xyXG5cclxuXHR9XHJcblxyXG5cdHNlcmlhbGl6ZSggZGF0YSApIHtcclxuXHJcblx0XHRzdXBlci5zZXJpYWxpemUoIGRhdGEgKTtcclxuXHJcblx0XHRkYXRhLmNvZGUgPSB0aGlzLmNvZGU7XHJcblx0XHRkYXRhLmxhbmd1YWdlID0gdGhpcy5sYW5ndWFnZTtcclxuXHJcblx0fVxyXG5cclxuXHRkZXNlcmlhbGl6ZSggZGF0YSApIHtcclxuXHJcblx0XHRzdXBlci5kZXNlcmlhbGl6ZSggZGF0YSApO1xyXG5cclxuXHRcdHRoaXMuY29kZSA9IGRhdGEuY29kZTtcclxuXHRcdHRoaXMubGFuZ3VhZ2UgPSBkYXRhLmxhbmd1YWdlO1xyXG5cclxuXHR9XHJcblxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBDb2RlTm9kZTtcclxuXHJcbi8qKlxyXG4gKiBUU0wgZnVuY3Rpb24gZm9yIGNyZWF0aW5nIGEgY29kZSBub2RlLlxyXG4gKlxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHtTdHJpbmd9IFtjb2RlPScnXSAtIFRoZSBuYXRpdmUgY29kZS5cclxuICogQHBhcmFtIHtBcnJheTxOb2RlPn0gW2luY2x1ZGVzPVtdXSAtIEFuIGFycmF5IG9mIGluY2x1ZGVzLlxyXG4gKiBAcGFyYW0geygnanMnfCd3Z3NsJ3wnZ2xzbCcpfSBbbGFuZ3VhZ2U9JyddIC0gVGhlIHVzZWQgbGFuZ3VhZ2UuXHJcbiAqIEByZXR1cm5zIHtDb2RlTm9kZX1cclxuICovXHJcbmV4cG9ydCBjb25zdCBjb2RlID0gLypAX19QVVJFX18qLyBub2RlUHJveHkoIENvZGVOb2RlICk7XHJcblxyXG4vKipcclxuICogVFNMIGZ1bmN0aW9uIGZvciBjcmVhdGluZyBhIEpTIGNvZGUgbm9kZS5cclxuICpcclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBzcmMgLSBUaGUgbmF0aXZlIGNvZGUuXHJcbiAqIEBwYXJhbSB7QXJyYXk8Tm9kZT59IGluY2x1ZGVzIC0gQW4gYXJyYXkgb2YgaW5jbHVkZXMuXHJcbiAqIEByZXR1cm5zIHtDb2RlTm9kZX1cclxuICovXHJcbmV4cG9ydCBjb25zdCBqcyA9ICggc3JjLCBpbmNsdWRlcyApID0+IGNvZGUoIHNyYywgaW5jbHVkZXMsICdqcycgKTtcclxuXHJcbi8qKlxyXG4gKiBUU0wgZnVuY3Rpb24gZm9yIGNyZWF0aW5nIGEgV0dTTCBjb2RlIG5vZGUuXHJcbiAqXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0ge1N0cmluZ30gc3JjIC0gVGhlIG5hdGl2ZSBjb2RlLlxyXG4gKiBAcGFyYW0ge0FycmF5PE5vZGU+fSBpbmNsdWRlcyAtIEFuIGFycmF5IG9mIGluY2x1ZGVzLlxyXG4gKiBAcmV0dXJucyB7Q29kZU5vZGV9XHJcbiAqL1xyXG5leHBvcnQgY29uc3Qgd2dzbCA9ICggc3JjLCBpbmNsdWRlcyApID0+IGNvZGUoIHNyYywgaW5jbHVkZXMsICd3Z3NsJyApO1xyXG5cclxuLyoqXHJcbiAqIFRTTCBmdW5jdGlvbiBmb3IgY3JlYXRpbmcgYSBHTFNMIGNvZGUgbm9kZS5cclxuICpcclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBzcmMgLSBUaGUgbmF0aXZlIGNvZGUuXHJcbiAqIEBwYXJhbSB7QXJyYXk8Tm9kZT59IGluY2x1ZGVzIC0gQW4gYXJyYXkgb2YgaW5jbHVkZXMuXHJcbiAqIEByZXR1cm5zIHtDb2RlTm9kZX1cclxuICovXHJcbmV4cG9ydCBjb25zdCBnbHNsID0gKCBzcmMsIGluY2x1ZGVzICkgPT4gY29kZSggc3JjLCBpbmNsdWRlcywgJ2dsc2wnICk7XHJcbiIsImltcG9ydCBDb2RlTm9kZSBmcm9tICcuL0NvZGVOb2RlLmpzJztcclxuaW1wb3J0IHsgbm9kZU9iamVjdCB9IGZyb20gJy4uL3RzbC9UU0xCYXNlLmpzJztcclxuXHJcbi8qKlxyXG4gKiBUaGlzIGNsYXNzIHJlcHJlc2VudHMgYSBuYXRpdmUgc2hhZGVyIGZ1bmN0aW9uLiBJdCBjYW4gYmUgdXNlZCB0byBpbXBsZW1lbnRcclxuICogY2VydGFpbiBhc3BlY3RzIG9mIGEgbm9kZSBtYXRlcmlhbCB3aXRoIG5hdGl2ZSBzaGFkZXIgY29kZS4gVGhlcmUgYXJlIHR3byBwcmVkZWZpbmVkXHJcbiAqIFRTTCBmdW5jdGlvbnMgZm9yIGVhc2llciB1c2FnZS5cclxuICpcclxuICogLSBgd2dzbEZuYDogQ3JlYXRlcyBhIFdHU0wgZnVuY3Rpb24gbm9kZS5cclxuICogLSBgZ2xzbEZuYDogQ3JlYXRlcyBhIEdMU0wgZnVuY3Rpb24gbm9kZS5cclxuICpcclxuICogQSBiYXNpYyBleGFtcGxlIHdpdGggb25lIGluY2x1ZGUgbG9va3MgbGlrZSBzbzpcclxuICpcclxuICogYGBganNcclxuICogY29uc3QgZGVzYXR1cmF0ZVdHU0xGbiA9IHdnc2xGbiggYFxyXG4gKlx0Zm4gZGVzYXR1cmF0ZSggY29sb3I6dmVjMzxmMzI+ICkgLT4gdmVjMzxmMzI+IHtcclxuICpcdFx0bGV0IGx1bSA9IHZlYzM8ZjMyPiggMC4yOTksIDAuNTg3LCAwLjExNCApO1xyXG4gKlx0XHRyZXR1cm4gdmVjMzxmMzI+KCBkb3QoIGx1bSwgY29sb3IgKSApO1xyXG4gKlx0fWBcclxuICopO1xyXG4gKiBjb25zdCBzb21lV0dTTEZuID0gd2dzbEZuKCBgXHJcbiAqXHRmbiBzb21lRm4oIGNvbG9yOnZlYzM8ZjMyPiApIC0+IHZlYzM8ZjMyPiB7XHJcbiAqIFx0XHRyZXR1cm4gZGVzYXR1cmF0ZSggY29sb3IgKTtcclxuICogXHR9XHJcbiAqIGAsIFsgZGVzYXR1cmF0ZVdHU0xGbiBdICk7XHJcbiAqIG1hdGVyaWFsLmNvbG9yTm9kZSA9IHNvbWVXR1NMRm4oIHsgY29sb3I6IHRleHR1cmUoIG1hcCApIH0gKTtcclxuICpgYGBcclxuICogQGF1Z21lbnRzIENvZGVOb2RlXHJcbiAqL1xyXG5jbGFzcyBGdW5jdGlvbk5vZGUgZXh0ZW5kcyBDb2RlTm9kZSB7XHJcblxyXG5cdHN0YXRpYyBnZXQgdHlwZSgpIHtcclxuXHJcblx0XHRyZXR1cm4gJ0Z1bmN0aW9uTm9kZSc7XHJcblxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogQ29uc3RydWN0cyBhIG5ldyBmdW5jdGlvbiBub2RlLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtTdHJpbmd9IFtjb2RlPScnXSAtIFRoZSBuYXRpdmUgY29kZS5cclxuXHQgKiBAcGFyYW0ge0FycmF5PE5vZGU+fSBbaW5jbHVkZXM9W11dIC0gQW4gYXJyYXkgb2YgaW5jbHVkZXMuXHJcblx0ICogQHBhcmFtIHsoJ2pzJ3wnd2dzbCd8J2dsc2wnKX0gW2xhbmd1YWdlPScnXSAtIFRoZSB1c2VkIGxhbmd1YWdlLlxyXG5cdCAqL1xyXG5cdGNvbnN0cnVjdG9yKCBjb2RlID0gJycsIGluY2x1ZGVzID0gW10sIGxhbmd1YWdlID0gJycgKSB7XHJcblxyXG5cdFx0c3VwZXIoIGNvZGUsIGluY2x1ZGVzLCBsYW5ndWFnZSApO1xyXG5cclxuXHR9XHJcblxyXG5cdGdldE5vZGVUeXBlKCBidWlsZGVyICkge1xyXG5cclxuXHRcdHJldHVybiB0aGlzLmdldE5vZGVGdW5jdGlvbiggYnVpbGRlciApLnR5cGU7XHJcblxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogUmV0dXJucyB0aGUgaW5wdXRzIG9mIHRoaXMgZnVuY3Rpb24gbm9kZS5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7Tm9kZUJ1aWxkZXJ9IGJ1aWxkZXIgLSBUaGUgY3VycmVudCBub2RlIGJ1aWxkZXIuXHJcblx0ICogQHJldHVybiB7QXJyYXk8Tm9kZUZ1bmN0aW9uSW5wdXQ+fSBUaGUgaW5wdXRzLlxyXG5cdCAqL1xyXG5cdGdldElucHV0cyggYnVpbGRlciApIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5nZXROb2RlRnVuY3Rpb24oIGJ1aWxkZXIgKS5pbnB1dHM7XHJcblxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogUmV0dXJucyB0aGUgbm9kZSBmdW5jdGlvbiBmb3IgdGhpcyBmdW5jdGlvbiBub2RlLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtOb2RlQnVpbGRlcn0gYnVpbGRlciAtIFRoZSBjdXJyZW50IG5vZGUgYnVpbGRlci5cclxuXHQgKiBAcmV0dXJuIHtOb2RlRnVuY3Rpb259IFRoZSBub2RlIGZ1bmN0aW9uLlxyXG5cdCAqL1xyXG5cdGdldE5vZGVGdW5jdGlvbiggYnVpbGRlciApIHtcclxuXHJcblx0XHRjb25zdCBub2RlRGF0YSA9IGJ1aWxkZXIuZ2V0RGF0YUZyb21Ob2RlKCB0aGlzICk7XHJcblxyXG5cdFx0bGV0IG5vZGVGdW5jdGlvbiA9IG5vZGVEYXRhLm5vZGVGdW5jdGlvbjtcclxuXHJcblx0XHRpZiAoIG5vZGVGdW5jdGlvbiA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0bm9kZUZ1bmN0aW9uID0gYnVpbGRlci5wYXJzZXIucGFyc2VGdW5jdGlvbiggdGhpcy5jb2RlICk7XHJcblxyXG5cdFx0XHRub2RlRGF0YS5ub2RlRnVuY3Rpb24gPSBub2RlRnVuY3Rpb247XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBub2RlRnVuY3Rpb247XHJcblxyXG5cdH1cclxuXHJcblx0Z2VuZXJhdGUoIGJ1aWxkZXIsIG91dHB1dCApIHtcclxuXHJcblx0XHRzdXBlci5nZW5lcmF0ZSggYnVpbGRlciApO1xyXG5cclxuXHRcdGNvbnN0IG5vZGVGdW5jdGlvbiA9IHRoaXMuZ2V0Tm9kZUZ1bmN0aW9uKCBidWlsZGVyICk7XHJcblxyXG5cdFx0Y29uc3QgbmFtZSA9IG5vZGVGdW5jdGlvbi5uYW1lO1xyXG5cdFx0Y29uc3QgdHlwZSA9IG5vZGVGdW5jdGlvbi50eXBlO1xyXG5cclxuXHRcdGNvbnN0IG5vZGVDb2RlID0gYnVpbGRlci5nZXRDb2RlRnJvbU5vZGUoIHRoaXMsIHR5cGUgKTtcclxuXHJcblx0XHRpZiAoIG5hbWUgIT09ICcnICkge1xyXG5cclxuXHRcdFx0Ly8gdXNlIGEgY3VzdG9tIHByb3BlcnR5IG5hbWVcclxuXHJcblx0XHRcdG5vZGVDb2RlLm5hbWUgPSBuYW1lO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRjb25zdCBwcm9wZXJ0eU5hbWUgPSBidWlsZGVyLmdldFByb3BlcnR5TmFtZSggbm9kZUNvZGUgKTtcclxuXHJcblx0XHRjb25zdCBjb2RlID0gdGhpcy5nZXROb2RlRnVuY3Rpb24oIGJ1aWxkZXIgKS5nZXRDb2RlKCBwcm9wZXJ0eU5hbWUgKTtcclxuXHJcblx0XHRub2RlQ29kZS5jb2RlID0gY29kZSArICdcXG4nO1xyXG5cclxuXHRcdGlmICggb3V0cHV0ID09PSAncHJvcGVydHknICkge1xyXG5cclxuXHRcdFx0cmV0dXJuIHByb3BlcnR5TmFtZTtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0cmV0dXJuIGJ1aWxkZXIuZm9ybWF0KCBgJHsgcHJvcGVydHlOYW1lIH0oKWAsIHR5cGUsIG91dHB1dCApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgRnVuY3Rpb25Ob2RlO1xyXG5cclxuY29uc3QgbmF0aXZlRm4gPSAoIGNvZGUsIGluY2x1ZGVzID0gW10sIGxhbmd1YWdlID0gJycgKSA9PiB7XHJcblxyXG5cdGZvciAoIGxldCBpID0gMDsgaSA8IGluY2x1ZGVzLmxlbmd0aDsgaSArKyApIHtcclxuXHJcblx0XHRjb25zdCBpbmNsdWRlID0gaW5jbHVkZXNbIGkgXTtcclxuXHJcblx0XHQvLyBUU0wgRnVuY3Rpb246IGdsc2xGbiwgd2dzbEZuXHJcblxyXG5cdFx0aWYgKCB0eXBlb2YgaW5jbHVkZSA9PT0gJ2Z1bmN0aW9uJyApIHtcclxuXHJcblx0XHRcdGluY2x1ZGVzWyBpIF0gPSBpbmNsdWRlLmZ1bmN0aW9uTm9kZTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0Y29uc3QgZnVuY3Rpb25Ob2RlID0gbm9kZU9iamVjdCggbmV3IEZ1bmN0aW9uTm9kZSggY29kZSwgaW5jbHVkZXMsIGxhbmd1YWdlICkgKTtcclxuXHJcblx0Y29uc3QgZm4gPSAoIC4uLnBhcmFtcyApID0+IGZ1bmN0aW9uTm9kZS5jYWxsKCAuLi5wYXJhbXMgKTtcclxuXHRmbi5mdW5jdGlvbk5vZGUgPSBmdW5jdGlvbk5vZGU7XHJcblxyXG5cdHJldHVybiBmbjtcclxuXHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgZ2xzbEZuID0gKCBjb2RlLCBpbmNsdWRlcyApID0+IG5hdGl2ZUZuKCBjb2RlLCBpbmNsdWRlcywgJ2dsc2wnICk7XHJcbmV4cG9ydCBjb25zdCB3Z3NsRm4gPSAoIGNvZGUsIGluY2x1ZGVzICkgPT4gbmF0aXZlRm4oIGNvZGUsIGluY2x1ZGVzLCAnd2dzbCcgKTtcclxuIiwiaW1wb3J0IE5vZGUgZnJvbSAnLi4vY29yZS9Ob2RlLmpzJztcclxuaW1wb3J0IHsgYXJyYXlCdWZmZXJUb0Jhc2U2NCwgYmFzZTY0VG9BcnJheUJ1ZmZlciB9IGZyb20gJy4uL2NvcmUvTm9kZVV0aWxzLmpzJztcclxuaW1wb3J0IHsgbm9kZVByb3h5LCBmbG9hdCB9IGZyb20gJy4uL3RzbC9UU0xCYXNlLmpzJztcclxuXHJcbmltcG9ydCB7IEV2ZW50RGlzcGF0Y2hlciB9IGZyb20gJy4uLy4uL2NvcmUvRXZlbnREaXNwYXRjaGVyLmpzJztcclxuXHJcbmNsYXNzIFNjcmlwdGFibGVWYWx1ZU5vZGUgZXh0ZW5kcyBOb2RlIHtcclxuXHJcblx0c3RhdGljIGdldCB0eXBlKCkge1xyXG5cclxuXHRcdHJldHVybiAnU2NyaXB0YWJsZVZhbHVlTm9kZSc7XHJcblxyXG5cdH1cclxuXHJcblx0Y29uc3RydWN0b3IoIHZhbHVlID0gbnVsbCApIHtcclxuXHJcblx0XHRzdXBlcigpO1xyXG5cclxuXHRcdHRoaXMuX3ZhbHVlID0gdmFsdWU7XHJcblx0XHR0aGlzLl9jYWNoZSA9IG51bGw7XHJcblxyXG5cdFx0dGhpcy5pbnB1dFR5cGUgPSBudWxsO1xyXG5cdFx0dGhpcy5vdXRwdXRUeXBlID0gbnVsbDtcclxuXHJcblx0XHR0aGlzLmV2ZW50cyA9IG5ldyBFdmVudERpc3BhdGNoZXIoKTtcclxuXHJcblx0XHR0aGlzLmlzU2NyaXB0YWJsZVZhbHVlTm9kZSA9IHRydWU7XHJcblxyXG5cdH1cclxuXHJcblx0Z2V0IGlzU2NyaXB0YWJsZU91dHB1dE5vZGUoKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMub3V0cHV0VHlwZSAhPT0gbnVsbDtcclxuXHJcblx0fVxyXG5cclxuXHRzZXQgdmFsdWUoIHZhbCApIHtcclxuXHJcblx0XHRpZiAoIHRoaXMuX3ZhbHVlID09PSB2YWwgKSByZXR1cm47XHJcblxyXG5cdFx0aWYgKCB0aGlzLl9jYWNoZSAmJiB0aGlzLmlucHV0VHlwZSA9PT0gJ1VSTCcgJiYgdGhpcy52YWx1ZS52YWx1ZSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyICkge1xyXG5cclxuXHRcdFx0VVJMLnJldm9rZU9iamVjdFVSTCggdGhpcy5fY2FjaGUgKTtcclxuXHJcblx0XHRcdHRoaXMuX2NhY2hlID0gbnVsbDtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fdmFsdWUgPSB2YWw7XHJcblxyXG5cdFx0dGhpcy5ldmVudHMuZGlzcGF0Y2hFdmVudCggeyB0eXBlOiAnY2hhbmdlJyB9ICk7XHJcblxyXG5cdFx0dGhpcy5yZWZyZXNoKCk7XHJcblxyXG5cdH1cclxuXHJcblx0Z2V0IHZhbHVlKCkge1xyXG5cclxuXHRcdHJldHVybiB0aGlzLl92YWx1ZTtcclxuXHJcblx0fVxyXG5cclxuXHRyZWZyZXNoKCkge1xyXG5cclxuXHRcdHRoaXMuZXZlbnRzLmRpc3BhdGNoRXZlbnQoIHsgdHlwZTogJ3JlZnJlc2gnIH0gKTtcclxuXHJcblx0fVxyXG5cclxuXHRnZXRWYWx1ZSgpIHtcclxuXHJcblx0XHRjb25zdCB2YWx1ZSA9IHRoaXMudmFsdWU7XHJcblxyXG5cdFx0aWYgKCB2YWx1ZSAmJiB0aGlzLl9jYWNoZSA9PT0gbnVsbCAmJiB0aGlzLmlucHV0VHlwZSA9PT0gJ1VSTCcgJiYgdmFsdWUudmFsdWUgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlciApIHtcclxuXHJcblx0XHRcdHRoaXMuX2NhY2hlID0gVVJMLmNyZWF0ZU9iamVjdFVSTCggbmV3IEJsb2IoIFsgdmFsdWUudmFsdWUgXSApICk7XHJcblxyXG5cdFx0fSBlbHNlIGlmICggdmFsdWUgJiYgdmFsdWUudmFsdWUgIT09IG51bGwgJiYgdmFsdWUudmFsdWUgIT09IHVuZGVmaW5lZCAmJiAoXHJcblx0XHRcdCggKCB0aGlzLmlucHV0VHlwZSA9PT0gJ1VSTCcgfHwgdGhpcy5pbnB1dFR5cGUgPT09ICdTdHJpbmcnICkgJiYgdHlwZW9mIHZhbHVlLnZhbHVlID09PSAnc3RyaW5nJyApIHx8XHJcblx0XHRcdCggdGhpcy5pbnB1dFR5cGUgPT09ICdOdW1iZXInICYmIHR5cGVvZiB2YWx1ZS52YWx1ZSA9PT0gJ251bWJlcicgKSB8fFxyXG5cdFx0XHQoIHRoaXMuaW5wdXRUeXBlID09PSAnVmVjdG9yMicgJiYgdmFsdWUudmFsdWUuaXNWZWN0b3IyICkgfHxcclxuXHRcdFx0KCB0aGlzLmlucHV0VHlwZSA9PT0gJ1ZlY3RvcjMnICYmIHZhbHVlLnZhbHVlLmlzVmVjdG9yMyApIHx8XHJcblx0XHRcdCggdGhpcy5pbnB1dFR5cGUgPT09ICdWZWN0b3I0JyAmJiB2YWx1ZS52YWx1ZS5pc1ZlY3RvcjQgKSB8fFxyXG5cdFx0XHQoIHRoaXMuaW5wdXRUeXBlID09PSAnQ29sb3InICYmIHZhbHVlLnZhbHVlLmlzQ29sb3IgKSB8fFxyXG5cdFx0XHQoIHRoaXMuaW5wdXRUeXBlID09PSAnTWF0cml4MycgJiYgdmFsdWUudmFsdWUuaXNNYXRyaXgzICkgfHxcclxuXHRcdFx0KCB0aGlzLmlucHV0VHlwZSA9PT0gJ01hdHJpeDQnICYmIHZhbHVlLnZhbHVlLmlzTWF0cml4NCApXHJcblx0XHQpICkge1xyXG5cclxuXHRcdFx0cmV0dXJuIHZhbHVlLnZhbHVlO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcy5fY2FjaGUgfHwgdmFsdWU7XHJcblxyXG5cdH1cclxuXHJcblx0Z2V0Tm9kZVR5cGUoIGJ1aWxkZXIgKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMudmFsdWUgJiYgdGhpcy52YWx1ZS5pc05vZGUgPyB0aGlzLnZhbHVlLmdldE5vZGVUeXBlKCBidWlsZGVyICkgOiAnZmxvYXQnO1xyXG5cclxuXHR9XHJcblxyXG5cdHNldHVwKCkge1xyXG5cclxuXHRcdHJldHVybiB0aGlzLnZhbHVlICYmIHRoaXMudmFsdWUuaXNOb2RlID8gdGhpcy52YWx1ZSA6IGZsb2F0KCk7XHJcblxyXG5cdH1cclxuXHJcblx0c2VyaWFsaXplKCBkYXRhICkge1xyXG5cclxuXHRcdHN1cGVyLnNlcmlhbGl6ZSggZGF0YSApO1xyXG5cclxuXHRcdGlmICggdGhpcy52YWx1ZSAhPT0gbnVsbCApIHtcclxuXHJcblx0XHRcdGlmICggdGhpcy5pbnB1dFR5cGUgPT09ICdBcnJheUJ1ZmZlcicgKSB7XHJcblxyXG5cdFx0XHRcdGRhdGEudmFsdWUgPSBhcnJheUJ1ZmZlclRvQmFzZTY0KCB0aGlzLnZhbHVlICk7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRkYXRhLnZhbHVlID0gdGhpcy52YWx1ZSA/IHRoaXMudmFsdWUudG9KU09OKCBkYXRhLm1ldGEgKS51dWlkIDogbnVsbDtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0ZGF0YS52YWx1ZSA9IG51bGw7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGRhdGEuaW5wdXRUeXBlID0gdGhpcy5pbnB1dFR5cGU7XHJcblx0XHRkYXRhLm91dHB1dFR5cGUgPSB0aGlzLm91dHB1dFR5cGU7XHJcblxyXG5cdH1cclxuXHJcblx0ZGVzZXJpYWxpemUoIGRhdGEgKSB7XHJcblxyXG5cdFx0c3VwZXIuZGVzZXJpYWxpemUoIGRhdGEgKTtcclxuXHJcblx0XHRsZXQgdmFsdWUgPSBudWxsO1xyXG5cclxuXHRcdGlmICggZGF0YS52YWx1ZSAhPT0gbnVsbCApIHtcclxuXHJcblx0XHRcdGlmICggZGF0YS5pbnB1dFR5cGUgPT09ICdBcnJheUJ1ZmZlcicgKSB7XHJcblxyXG5cdFx0XHRcdHZhbHVlID0gYmFzZTY0VG9BcnJheUJ1ZmZlciggZGF0YS52YWx1ZSApO1xyXG5cclxuXHRcdFx0fSBlbHNlIGlmICggZGF0YS5pbnB1dFR5cGUgPT09ICdUZXh0dXJlJyApIHtcclxuXHJcblx0XHRcdFx0dmFsdWUgPSBkYXRhLm1ldGEudGV4dHVyZXNbIGRhdGEudmFsdWUgXTtcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdHZhbHVlID0gZGF0YS5tZXRhLm5vZGVzWyBkYXRhLnZhbHVlIF0gfHwgbnVsbDtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy52YWx1ZSA9IHZhbHVlO1xyXG5cclxuXHRcdHRoaXMuaW5wdXRUeXBlID0gZGF0YS5pbnB1dFR5cGU7XHJcblx0XHR0aGlzLm91dHB1dFR5cGUgPSBkYXRhLm91dHB1dFR5cGU7XHJcblxyXG5cdH1cclxuXHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IFNjcmlwdGFibGVWYWx1ZU5vZGU7XHJcblxyXG5leHBvcnQgY29uc3Qgc2NyaXB0YWJsZVZhbHVlID0gLypAX19QVVJFX18qLyBub2RlUHJveHkoIFNjcmlwdGFibGVWYWx1ZU5vZGUgKTtcclxuIiwiaW1wb3J0IE5vZGUgZnJvbSAnLi4vY29yZS9Ob2RlLmpzJztcclxuaW1wb3J0IHsgc2NyaXB0YWJsZVZhbHVlIH0gZnJvbSAnLi9TY3JpcHRhYmxlVmFsdWVOb2RlLmpzJztcclxuaW1wb3J0IHsgbm9kZVByb3h5LCBmbG9hdCB9IGZyb20gJy4uL3RzbC9UU0xCYXNlLmpzJztcclxuaW1wb3J0IHsgaGFzaEFycmF5LCBoYXNoU3RyaW5nIH0gZnJvbSAnLi4vY29yZS9Ob2RlVXRpbHMuanMnO1xyXG5cclxuY2xhc3MgUmVzb3VyY2VzIGV4dGVuZHMgTWFwIHtcclxuXHJcblx0Z2V0KCBrZXksIGNhbGxiYWNrID0gbnVsbCwgLi4ucGFyYW1zICkge1xyXG5cclxuXHRcdGlmICggdGhpcy5oYXMoIGtleSApICkgcmV0dXJuIHN1cGVyLmdldCgga2V5ICk7XHJcblxyXG5cdFx0aWYgKCBjYWxsYmFjayAhPT0gbnVsbCApIHtcclxuXHJcblx0XHRcdGNvbnN0IHZhbHVlID0gY2FsbGJhY2soIC4uLnBhcmFtcyApO1xyXG5cdFx0XHR0aGlzLnNldCgga2V5LCB2YWx1ZSApO1xyXG5cdFx0XHRyZXR1cm4gdmFsdWU7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG59XHJcblxyXG5jbGFzcyBQYXJhbWV0ZXJzIHtcclxuXHJcblx0Y29uc3RydWN0b3IoIHNjcmlwdGFibGVOb2RlICkge1xyXG5cclxuXHRcdHRoaXMuc2NyaXB0YWJsZU5vZGUgPSBzY3JpcHRhYmxlTm9kZTtcclxuXHJcblx0fVxyXG5cclxuXHRnZXQgcGFyYW1ldGVycygpIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5zY3JpcHRhYmxlTm9kZS5wYXJhbWV0ZXJzO1xyXG5cclxuXHR9XHJcblxyXG5cdGdldCBsYXlvdXQoKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuc2NyaXB0YWJsZU5vZGUuZ2V0TGF5b3V0KCk7XHJcblxyXG5cdH1cclxuXHJcblx0Z2V0SW5wdXRMYXlvdXQoIGlkICkge1xyXG5cclxuXHRcdHJldHVybiB0aGlzLnNjcmlwdGFibGVOb2RlLmdldElucHV0TGF5b3V0KCBpZCApO1xyXG5cclxuXHR9XHJcblxyXG5cdGdldCggbmFtZSApIHtcclxuXHJcblx0XHRjb25zdCBwYXJhbSA9IHRoaXMucGFyYW1ldGVyc1sgbmFtZSBdO1xyXG5cdFx0Y29uc3QgdmFsdWUgPSBwYXJhbSA/IHBhcmFtLmdldFZhbHVlKCkgOiBudWxsO1xyXG5cclxuXHRcdHJldHVybiB2YWx1ZTtcclxuXHJcblx0fVxyXG5cclxufVxyXG5cclxuZXhwb3J0IGNvbnN0IFNjcmlwdGFibGVOb2RlUmVzb3VyY2VzID0gbmV3IFJlc291cmNlcygpO1xyXG5cclxuY2xhc3MgU2NyaXB0YWJsZU5vZGUgZXh0ZW5kcyBOb2RlIHtcclxuXHJcblx0c3RhdGljIGdldCB0eXBlKCkge1xyXG5cclxuXHRcdHJldHVybiAnU2NyaXB0YWJsZU5vZGUnO1xyXG5cclxuXHR9XHJcblxyXG5cdGNvbnN0cnVjdG9yKCBjb2RlTm9kZSA9IG51bGwsIHBhcmFtZXRlcnMgPSB7fSApIHtcclxuXHJcblx0XHRzdXBlcigpO1xyXG5cclxuXHRcdHRoaXMuY29kZU5vZGUgPSBjb2RlTm9kZTtcclxuXHRcdHRoaXMucGFyYW1ldGVycyA9IHBhcmFtZXRlcnM7XHJcblxyXG5cdFx0dGhpcy5fbG9jYWwgPSBuZXcgUmVzb3VyY2VzKCk7XHJcblx0XHR0aGlzLl9vdXRwdXQgPSBzY3JpcHRhYmxlVmFsdWUoKTtcclxuXHRcdHRoaXMuX291dHB1dHMgPSB7fTtcclxuXHRcdHRoaXMuX3NvdXJjZSA9IHRoaXMuc291cmNlO1xyXG5cdFx0dGhpcy5fbWV0aG9kID0gbnVsbDtcclxuXHRcdHRoaXMuX29iamVjdCA9IG51bGw7XHJcblx0XHR0aGlzLl92YWx1ZSA9IG51bGw7XHJcblx0XHR0aGlzLl9uZWVkc091dHB1dFVwZGF0ZSA9IHRydWU7XHJcblxyXG5cdFx0dGhpcy5vblJlZnJlc2ggPSB0aGlzLm9uUmVmcmVzaC5iaW5kKCB0aGlzICk7XHJcblxyXG5cdFx0dGhpcy5pc1NjcmlwdGFibGVOb2RlID0gdHJ1ZTtcclxuXHJcblx0fVxyXG5cclxuXHRnZXQgc291cmNlKCkge1xyXG5cclxuXHRcdHJldHVybiB0aGlzLmNvZGVOb2RlID8gdGhpcy5jb2RlTm9kZS5jb2RlIDogJyc7XHJcblxyXG5cdH1cclxuXHJcblx0c2V0TG9jYWwoIG5hbWUsIHZhbHVlICkge1xyXG5cclxuXHRcdHJldHVybiB0aGlzLl9sb2NhbC5zZXQoIG5hbWUsIHZhbHVlICk7XHJcblxyXG5cdH1cclxuXHJcblx0Z2V0TG9jYWwoIG5hbWUgKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuX2xvY2FsLmdldCggbmFtZSApO1xyXG5cclxuXHR9XHJcblxyXG5cdG9uUmVmcmVzaCgpIHtcclxuXHJcblx0XHR0aGlzLl9yZWZyZXNoKCk7XHJcblxyXG5cdH1cclxuXHJcblx0Z2V0SW5wdXRMYXlvdXQoIGlkICkge1xyXG5cclxuXHRcdGZvciAoIGNvbnN0IGVsZW1lbnQgb2YgdGhpcy5nZXRMYXlvdXQoKSApIHtcclxuXHJcblx0XHRcdGlmICggZWxlbWVudC5pbnB1dFR5cGUgJiYgKCBlbGVtZW50LmlkID09PSBpZCB8fCBlbGVtZW50Lm5hbWUgPT09IGlkICkgKSB7XHJcblxyXG5cdFx0XHRcdHJldHVybiBlbGVtZW50O1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHRnZXRPdXRwdXRMYXlvdXQoIGlkICkge1xyXG5cclxuXHRcdGZvciAoIGNvbnN0IGVsZW1lbnQgb2YgdGhpcy5nZXRMYXlvdXQoKSApIHtcclxuXHJcblx0XHRcdGlmICggZWxlbWVudC5vdXRwdXRUeXBlICYmICggZWxlbWVudC5pZCA9PT0gaWQgfHwgZWxlbWVudC5uYW1lID09PSBpZCApICkge1xyXG5cclxuXHRcdFx0XHRyZXR1cm4gZWxlbWVudDtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0c2V0T3V0cHV0KCBuYW1lLCB2YWx1ZSApIHtcclxuXHJcblx0XHRjb25zdCBvdXRwdXRzID0gdGhpcy5fb3V0cHV0cztcclxuXHJcblx0XHRpZiAoIG91dHB1dHNbIG5hbWUgXSA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0b3V0cHV0c1sgbmFtZSBdID0gc2NyaXB0YWJsZVZhbHVlKCB2YWx1ZSApO1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRvdXRwdXRzWyBuYW1lIF0udmFsdWUgPSB2YWx1ZTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHJcblx0Z2V0T3V0cHV0KCBuYW1lICkge1xyXG5cclxuXHRcdHJldHVybiB0aGlzLl9vdXRwdXRzWyBuYW1lIF07XHJcblxyXG5cdH1cclxuXHJcblx0Z2V0UGFyYW1ldGVyKCBuYW1lICkge1xyXG5cclxuXHRcdHJldHVybiB0aGlzLnBhcmFtZXRlcnNbIG5hbWUgXTtcclxuXHJcblx0fVxyXG5cclxuXHRzZXRQYXJhbWV0ZXIoIG5hbWUsIHZhbHVlICkge1xyXG5cclxuXHRcdGNvbnN0IHBhcmFtZXRlcnMgPSB0aGlzLnBhcmFtZXRlcnM7XHJcblxyXG5cdFx0aWYgKCB2YWx1ZSAmJiB2YWx1ZS5pc1NjcmlwdGFibGVOb2RlICkge1xyXG5cclxuXHRcdFx0dGhpcy5kZWxldGVQYXJhbWV0ZXIoIG5hbWUgKTtcclxuXHJcblx0XHRcdHBhcmFtZXRlcnNbIG5hbWUgXSA9IHZhbHVlO1xyXG5cdFx0XHRwYXJhbWV0ZXJzWyBuYW1lIF0uZ2V0RGVmYXVsdE91dHB1dCgpLmV2ZW50cy5hZGRFdmVudExpc3RlbmVyKCAncmVmcmVzaCcsIHRoaXMub25SZWZyZXNoICk7XHJcblxyXG5cdFx0fSBlbHNlIGlmICggdmFsdWUgJiYgdmFsdWUuaXNTY3JpcHRhYmxlVmFsdWVOb2RlICkge1xyXG5cclxuXHRcdFx0dGhpcy5kZWxldGVQYXJhbWV0ZXIoIG5hbWUgKTtcclxuXHJcblx0XHRcdHBhcmFtZXRlcnNbIG5hbWUgXSA9IHZhbHVlO1xyXG5cdFx0XHRwYXJhbWV0ZXJzWyBuYW1lIF0uZXZlbnRzLmFkZEV2ZW50TGlzdGVuZXIoICdyZWZyZXNoJywgdGhpcy5vblJlZnJlc2ggKTtcclxuXHJcblx0XHR9IGVsc2UgaWYgKCBwYXJhbWV0ZXJzWyBuYW1lIF0gPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdHBhcmFtZXRlcnNbIG5hbWUgXSA9IHNjcmlwdGFibGVWYWx1ZSggdmFsdWUgKTtcclxuXHRcdFx0cGFyYW1ldGVyc1sgbmFtZSBdLmV2ZW50cy5hZGRFdmVudExpc3RlbmVyKCAncmVmcmVzaCcsIHRoaXMub25SZWZyZXNoICk7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdHBhcmFtZXRlcnNbIG5hbWUgXS52YWx1ZSA9IHZhbHVlO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fVxyXG5cclxuXHRnZXRWYWx1ZSgpIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5nZXREZWZhdWx0T3V0cHV0KCkuZ2V0VmFsdWUoKTtcclxuXHJcblx0fVxyXG5cclxuXHRkZWxldGVQYXJhbWV0ZXIoIG5hbWUgKSB7XHJcblxyXG5cdFx0bGV0IHZhbHVlTm9kZSA9IHRoaXMucGFyYW1ldGVyc1sgbmFtZSBdO1xyXG5cclxuXHRcdGlmICggdmFsdWVOb2RlICkge1xyXG5cclxuXHRcdFx0aWYgKCB2YWx1ZU5vZGUuaXNTY3JpcHRhYmxlTm9kZSApIHZhbHVlTm9kZSA9IHZhbHVlTm9kZS5nZXREZWZhdWx0T3V0cHV0KCk7XHJcblxyXG5cdFx0XHR2YWx1ZU5vZGUuZXZlbnRzLnJlbW92ZUV2ZW50TGlzdGVuZXIoICdyZWZyZXNoJywgdGhpcy5vblJlZnJlc2ggKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHJcblx0Y2xlYXJQYXJhbWV0ZXJzKCkge1xyXG5cclxuXHRcdGZvciAoIGNvbnN0IG5hbWUgb2YgT2JqZWN0LmtleXMoIHRoaXMucGFyYW1ldGVycyApICkge1xyXG5cclxuXHRcdFx0dGhpcy5kZWxldGVQYXJhbWV0ZXIoIG5hbWUgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5uZWVkc1VwZGF0ZSA9IHRydWU7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHJcblx0Y2FsbCggbmFtZSwgLi4ucGFyYW1zICkge1xyXG5cclxuXHRcdGNvbnN0IG9iamVjdCA9IHRoaXMuZ2V0T2JqZWN0KCk7XHJcblx0XHRjb25zdCBtZXRob2QgPSBvYmplY3RbIG5hbWUgXTtcclxuXHJcblx0XHRpZiAoIHR5cGVvZiBtZXRob2QgPT09ICdmdW5jdGlvbicgKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gbWV0aG9kKCAuLi5wYXJhbXMgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0YXN5bmMgY2FsbEFzeW5jKCBuYW1lLCAuLi5wYXJhbXMgKSB7XHJcblxyXG5cdFx0Y29uc3Qgb2JqZWN0ID0gdGhpcy5nZXRPYmplY3QoKTtcclxuXHRcdGNvbnN0IG1ldGhvZCA9IG9iamVjdFsgbmFtZSBdO1xyXG5cclxuXHRcdGlmICggdHlwZW9mIG1ldGhvZCA9PT0gJ2Z1bmN0aW9uJyApIHtcclxuXHJcblx0XHRcdHJldHVybiBtZXRob2QuY29uc3RydWN0b3IubmFtZSA9PT0gJ0FzeW5jRnVuY3Rpb24nID8gYXdhaXQgbWV0aG9kKCAuLi5wYXJhbXMgKSA6IG1ldGhvZCggLi4ucGFyYW1zICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdGdldE5vZGVUeXBlKCBidWlsZGVyICkge1xyXG5cclxuXHRcdHJldHVybiB0aGlzLmdldERlZmF1bHRPdXRwdXROb2RlKCkuZ2V0Tm9kZVR5cGUoIGJ1aWxkZXIgKTtcclxuXHJcblx0fVxyXG5cclxuXHRyZWZyZXNoKCBvdXRwdXQgPSBudWxsICkge1xyXG5cclxuXHRcdGlmICggb3V0cHV0ICE9PSBudWxsICkge1xyXG5cclxuXHRcdFx0dGhpcy5nZXRPdXRwdXQoIG91dHB1dCApLnJlZnJlc2goKTtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0dGhpcy5fcmVmcmVzaCgpO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHRnZXRPYmplY3QoKSB7XHJcblxyXG5cdFx0aWYgKCB0aGlzLm5lZWRzVXBkYXRlICkgdGhpcy5kaXNwb3NlKCk7XHJcblx0XHRpZiAoIHRoaXMuX29iamVjdCAhPT0gbnVsbCApIHJldHVybiB0aGlzLl9vYmplY3Q7XHJcblxyXG5cdFx0Ly9cclxuXHJcblx0XHRjb25zdCByZWZyZXNoID0gKCkgPT4gdGhpcy5yZWZyZXNoKCk7XHJcblx0XHRjb25zdCBzZXRPdXRwdXQgPSAoIGlkLCB2YWx1ZSApID0+IHRoaXMuc2V0T3V0cHV0KCBpZCwgdmFsdWUgKTtcclxuXHJcblx0XHRjb25zdCBwYXJhbWV0ZXJzID0gbmV3IFBhcmFtZXRlcnMoIHRoaXMgKTtcclxuXHJcblx0XHRjb25zdCBUSFJFRSA9IFNjcmlwdGFibGVOb2RlUmVzb3VyY2VzLmdldCggJ1RIUkVFJyApO1xyXG5cdFx0Y29uc3QgVFNMID0gU2NyaXB0YWJsZU5vZGVSZXNvdXJjZXMuZ2V0KCAnVFNMJyApO1xyXG5cclxuXHRcdGNvbnN0IG1ldGhvZCA9IHRoaXMuZ2V0TWV0aG9kKCB0aGlzLmNvZGVOb2RlICk7XHJcblx0XHRjb25zdCBwYXJhbXMgPSBbIHBhcmFtZXRlcnMsIHRoaXMuX2xvY2FsLCBTY3JpcHRhYmxlTm9kZVJlc291cmNlcywgcmVmcmVzaCwgc2V0T3V0cHV0LCBUSFJFRSwgVFNMIF07XHJcblxyXG5cdFx0dGhpcy5fb2JqZWN0ID0gbWV0aG9kKCAuLi5wYXJhbXMgKTtcclxuXHJcblx0XHRjb25zdCBsYXlvdXQgPSB0aGlzLl9vYmplY3QubGF5b3V0O1xyXG5cclxuXHRcdGlmICggbGF5b3V0ICkge1xyXG5cclxuXHRcdFx0aWYgKCBsYXlvdXQuY2FjaGUgPT09IGZhbHNlICkge1xyXG5cclxuXHRcdFx0XHR0aGlzLl9sb2NhbC5jbGVhcigpO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gZGVmYXVsdCBvdXRwdXRcclxuXHRcdFx0dGhpcy5fb3V0cHV0Lm91dHB1dFR5cGUgPSBsYXlvdXQub3V0cHV0VHlwZSB8fCBudWxsO1xyXG5cclxuXHRcdFx0aWYgKCBBcnJheS5pc0FycmF5KCBsYXlvdXQuZWxlbWVudHMgKSApIHtcclxuXHJcblx0XHRcdFx0Zm9yICggY29uc3QgZWxlbWVudCBvZiBsYXlvdXQuZWxlbWVudHMgKSB7XHJcblxyXG5cdFx0XHRcdFx0Y29uc3QgaWQgPSBlbGVtZW50LmlkIHx8IGVsZW1lbnQubmFtZTtcclxuXHJcblx0XHRcdFx0XHRpZiAoIGVsZW1lbnQuaW5wdXRUeXBlICkge1xyXG5cclxuXHRcdFx0XHRcdFx0aWYgKCB0aGlzLmdldFBhcmFtZXRlciggaWQgKSA9PT0gdW5kZWZpbmVkICkgdGhpcy5zZXRQYXJhbWV0ZXIoIGlkLCBudWxsICk7XHJcblxyXG5cdFx0XHRcdFx0XHR0aGlzLmdldFBhcmFtZXRlciggaWQgKS5pbnB1dFR5cGUgPSBlbGVtZW50LmlucHV0VHlwZTtcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0aWYgKCBlbGVtZW50Lm91dHB1dFR5cGUgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRpZiAoIHRoaXMuZ2V0T3V0cHV0KCBpZCApID09PSB1bmRlZmluZWQgKSB0aGlzLnNldE91dHB1dCggaWQsIG51bGwgKTtcclxuXHJcblx0XHRcdFx0XHRcdHRoaXMuZ2V0T3V0cHV0KCBpZCApLm91dHB1dFR5cGUgPSBlbGVtZW50Lm91dHB1dFR5cGU7XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzLl9vYmplY3Q7XHJcblxyXG5cdH1cclxuXHJcblx0ZGVzZXJpYWxpemUoIGRhdGEgKSB7XHJcblxyXG5cdFx0c3VwZXIuZGVzZXJpYWxpemUoIGRhdGEgKTtcclxuXHJcblx0XHRmb3IgKCBjb25zdCBuYW1lIGluIHRoaXMucGFyYW1ldGVycyApIHtcclxuXHJcblx0XHRcdGxldCB2YWx1ZU5vZGUgPSB0aGlzLnBhcmFtZXRlcnNbIG5hbWUgXTtcclxuXHJcblx0XHRcdGlmICggdmFsdWVOb2RlLmlzU2NyaXB0YWJsZU5vZGUgKSB2YWx1ZU5vZGUgPSB2YWx1ZU5vZGUuZ2V0RGVmYXVsdE91dHB1dCgpO1xyXG5cclxuXHRcdFx0dmFsdWVOb2RlLmV2ZW50cy5hZGRFdmVudExpc3RlbmVyKCAncmVmcmVzaCcsIHRoaXMub25SZWZyZXNoICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdGdldExheW91dCgpIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5nZXRPYmplY3QoKS5sYXlvdXQ7XHJcblxyXG5cdH1cclxuXHJcblx0Z2V0RGVmYXVsdE91dHB1dE5vZGUoKSB7XHJcblxyXG5cdFx0Y29uc3Qgb3V0cHV0ID0gdGhpcy5nZXREZWZhdWx0T3V0cHV0KCkudmFsdWU7XHJcblxyXG5cdFx0aWYgKCBvdXRwdXQgJiYgb3V0cHV0LmlzTm9kZSApIHtcclxuXHJcblx0XHRcdHJldHVybiBvdXRwdXQ7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBmbG9hdCgpO1xyXG5cclxuXHR9XHJcblxyXG5cdGdldERlZmF1bHRPdXRwdXQoKVx0e1xyXG5cclxuXHRcdHJldHVybiB0aGlzLl9leGVjKCkuX291dHB1dDtcclxuXHJcblx0fVxyXG5cclxuXHRnZXRNZXRob2QoKSB7XHJcblxyXG5cdFx0aWYgKCB0aGlzLm5lZWRzVXBkYXRlICkgdGhpcy5kaXNwb3NlKCk7XHJcblx0XHRpZiAoIHRoaXMuX21ldGhvZCAhPT0gbnVsbCApIHJldHVybiB0aGlzLl9tZXRob2Q7XHJcblxyXG5cdFx0Ly9cclxuXHJcblx0XHRjb25zdCBwYXJhbWV0ZXJzUHJvcHMgPSBbICdwYXJhbWV0ZXJzJywgJ2xvY2FsJywgJ2dsb2JhbCcsICdyZWZyZXNoJywgJ3NldE91dHB1dCcsICdUSFJFRScsICdUU0wnIF07XHJcblx0XHRjb25zdCBpbnRlcmZhY2VQcm9wcyA9IFsgJ2xheW91dCcsICdpbml0JywgJ21haW4nLCAnZGlzcG9zZScgXTtcclxuXHJcblx0XHRjb25zdCBwcm9wZXJ0aWVzID0gaW50ZXJmYWNlUHJvcHMuam9pbiggJywgJyApO1xyXG5cdFx0Y29uc3QgZGVjbGFyYXRpb25zID0gJ3ZhciAnICsgcHJvcGVydGllcyArICc7IHZhciBvdXRwdXQgPSB7fTtcXG4nO1xyXG5cdFx0Y29uc3QgcmV0dXJucyA9ICdcXG5yZXR1cm4geyAuLi5vdXRwdXQsICcgKyBwcm9wZXJ0aWVzICsgJyB9Oyc7XHJcblxyXG5cdFx0Y29uc3QgY29kZSA9IGRlY2xhcmF0aW9ucyArIHRoaXMuY29kZU5vZGUuY29kZSArIHJldHVybnM7XHJcblxyXG5cdFx0Ly9cclxuXHJcblx0XHR0aGlzLl9tZXRob2QgPSBuZXcgRnVuY3Rpb24oIC4uLnBhcmFtZXRlcnNQcm9wcywgY29kZSApO1xyXG5cclxuXHRcdHJldHVybiB0aGlzLl9tZXRob2Q7XHJcblxyXG5cdH1cclxuXHJcblx0ZGlzcG9zZSgpIHtcclxuXHJcblx0XHRpZiAoIHRoaXMuX21ldGhvZCA9PT0gbnVsbCApIHJldHVybjtcclxuXHJcblx0XHRpZiAoIHRoaXMuX29iamVjdCAmJiB0eXBlb2YgdGhpcy5fb2JqZWN0LmRpc3Bvc2UgPT09ICdmdW5jdGlvbicgKSB7XHJcblxyXG5cdFx0XHR0aGlzLl9vYmplY3QuZGlzcG9zZSgpO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9tZXRob2QgPSBudWxsO1xyXG5cdFx0dGhpcy5fb2JqZWN0ID0gbnVsbDtcclxuXHRcdHRoaXMuX3NvdXJjZSA9IG51bGw7XHJcblx0XHR0aGlzLl92YWx1ZSA9IG51bGw7XHJcblx0XHR0aGlzLl9uZWVkc091dHB1dFVwZGF0ZSA9IHRydWU7XHJcblx0XHR0aGlzLl9vdXRwdXQudmFsdWUgPSBudWxsO1xyXG5cdFx0dGhpcy5fb3V0cHV0cyA9IHt9O1xyXG5cclxuXHR9XHJcblxyXG5cdHNldHVwKCkge1xyXG5cclxuXHRcdHJldHVybiB0aGlzLmdldERlZmF1bHRPdXRwdXROb2RlKCk7XHJcblxyXG5cdH1cclxuXHJcblx0Z2V0Q2FjaGVLZXkoIGZvcmNlICkge1xyXG5cclxuXHRcdGNvbnN0IHZhbHVlcyA9IFsgaGFzaFN0cmluZyggdGhpcy5zb3VyY2UgKSwgdGhpcy5nZXREZWZhdWx0T3V0cHV0Tm9kZSgpLmdldENhY2hlS2V5KCBmb3JjZSApIF07XHJcblxyXG5cdFx0Zm9yICggY29uc3QgcGFyYW0gaW4gdGhpcy5wYXJhbWV0ZXJzICkge1xyXG5cclxuXHRcdFx0dmFsdWVzLnB1c2goIHRoaXMucGFyYW1ldGVyc1sgcGFyYW0gXS5nZXRDYWNoZUtleSggZm9yY2UgKSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gaGFzaEFycmF5KCB2YWx1ZXMgKTtcclxuXHJcblx0fVxyXG5cclxuXHRzZXQgbmVlZHNVcGRhdGUoIHZhbHVlICkge1xyXG5cclxuXHRcdGlmICggdmFsdWUgPT09IHRydWUgKSB0aGlzLmRpc3Bvc2UoKTtcclxuXHJcblx0fVxyXG5cclxuXHRnZXQgbmVlZHNVcGRhdGUoKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuc291cmNlICE9PSB0aGlzLl9zb3VyY2U7XHJcblxyXG5cdH1cclxuXHJcblx0X2V4ZWMoKVx0e1xyXG5cclxuXHRcdGlmICggdGhpcy5jb2RlTm9kZSA9PT0gbnVsbCApIHJldHVybiB0aGlzO1xyXG5cclxuXHRcdGlmICggdGhpcy5fbmVlZHNPdXRwdXRVcGRhdGUgPT09IHRydWUgKSB7XHJcblxyXG5cdFx0XHR0aGlzLl92YWx1ZSA9IHRoaXMuY2FsbCggJ21haW4nICk7XHJcblxyXG5cdFx0XHR0aGlzLl9uZWVkc091dHB1dFVwZGF0ZSA9IGZhbHNlO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9vdXRwdXQudmFsdWUgPSB0aGlzLl92YWx1ZTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fVxyXG5cclxuXHRfcmVmcmVzaCgpIHtcclxuXHJcblx0XHR0aGlzLm5lZWRzVXBkYXRlID0gdHJ1ZTtcclxuXHJcblx0XHR0aGlzLl9leGVjKCk7XHJcblxyXG5cdFx0dGhpcy5fb3V0cHV0LnJlZnJlc2goKTtcclxuXHJcblx0fVxyXG5cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgU2NyaXB0YWJsZU5vZGU7XHJcblxyXG5leHBvcnQgY29uc3Qgc2NyaXB0YWJsZSA9IC8qQF9fUFVSRV9fKi8gbm9kZVByb3h5KCBTY3JpcHRhYmxlTm9kZSApO1xyXG4iLCJpbXBvcnQgeyBwb3NpdGlvblZpZXcgfSBmcm9tICcuLi9hY2Nlc3NvcnMvUG9zaXRpb24uanMnO1xyXG5pbXBvcnQgeyBzbW9vdGhzdGVwIH0gZnJvbSAnLi4vbWF0aC9NYXRoTm9kZS5qcyc7XHJcbmltcG9ydCB7IEZuLCBvdXRwdXQsIHZlYzQgfSBmcm9tICcuLi90c2wvVFNMQmFzZS5qcyc7XHJcblxyXG4vKiogQG1vZHVsZSBGb2cgKiovXHJcblxyXG4vKipcclxuICogUmV0dXJucyBhIG5vZGUgdGhhdCByZXByZXNlbnRzIHRoZSBgemAgY29vcmRpbmF0ZSBpbiB2aWV3IHNwYWNlXHJcbiAqIGZvciB0aGUgY3VycmVudCBmcmFnbWVudC4gSXQncyBhIGRpZmZlcmVudCByZXByZXNlbnRhdGlvbiBvZiB0aGVcclxuICogZGVmYXVsdCBkZXB0aCB2YWx1ZS5cclxuICpcclxuICogVGhpcyB2YWx1ZSBjYW4gYmUgcGFydCBvZiBhIGNvbXB1dGF0aW9uIHRoYXQgZGVmaW5lcyBob3cgdGhlIGZvZ1xyXG4gKiBkZW5zaXR5IGluY3JlYXNlcyB3aGVuIG1vdmluZyBhd2F5IGZyb20gdGhlIGNhbWVyYS5cclxuICpcclxuICogQHBhcmFtIHtOb2RlQnVpbGRlcn0gYnVpbGRlciAtIFRoZSBjdXJyZW50IG5vZGUgYnVpbGRlci5cclxuICogQHJldHVybiB7Tm9kZX0gVGhlIHZpZXdaIG5vZGUuXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRWaWV3Wk5vZGUoIGJ1aWxkZXIgKSB7XHJcblxyXG5cdGxldCB2aWV3WjtcclxuXHJcblx0Y29uc3QgZ2V0Vmlld1ogPSBidWlsZGVyLmNvbnRleHQuZ2V0Vmlld1o7XHJcblxyXG5cdGlmICggZ2V0Vmlld1ogIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHR2aWV3WiA9IGdldFZpZXdaKCB0aGlzICk7XHJcblxyXG5cdH1cclxuXHJcblx0cmV0dXJuICggdmlld1ogfHwgcG9zaXRpb25WaWV3LnogKS5uZWdhdGUoKTtcclxuXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDb25zdHJ1Y3RzIGEgbmV3IHJhbmdlIGZhY3RvciBub2RlLlxyXG4gKlxyXG4gKiBAcGFyYW0ge05vZGV9IG5lYXIgLSBEZWZpbmVzIHRoZSBuZWFyIHZhbHVlLlxyXG4gKiBAcGFyYW0ge05vZGV9IGZhciAtIERlZmluZXMgdGhlIGZhciB2YWx1ZS5cclxuICovXHJcbmV4cG9ydCBjb25zdCByYW5nZUZvZ0ZhY3RvciA9IEZuKCAoIFsgbmVhciwgZmFyIF0sIGJ1aWxkZXIgKSA9PiB7XHJcblxyXG5cdGNvbnN0IHZpZXdaID0gZ2V0Vmlld1pOb2RlKCBidWlsZGVyICk7XHJcblxyXG5cdHJldHVybiBzbW9vdGhzdGVwKCBuZWFyLCBmYXIsIHZpZXdaICk7XHJcblxyXG59ICk7XHJcblxyXG4vKipcclxuICogUmVwcmVzZW50cyBhbiBleHBvbmVudGlhbCBzcXVhcmVkIGZvZy4gVGhpcyB0eXBlIG9mIGZvZyBnaXZlc1xyXG4gKiBhIGNsZWFyIHZpZXcgbmVhciB0aGUgY2FtZXJhIGFuZCBhIGZhc3RlciB0aGFuIGV4cG9uZW50aWFsbHlcclxuICogZGVuc2VuaW5nIGZvZyBmYXJ0aGVyIGZyb20gdGhlIGNhbWVyYS5cclxuICpcclxuICogQHBhcmFtIHtOb2RlfSBkZW5zaXR5IC0gRGVmaW5lcyB0aGUgZm9nIGRlbnNpdHkuXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgZGVuc2l0eUZvZ0ZhY3RvciA9IEZuKCAoIFsgZGVuc2l0eSBdLCBidWlsZGVyICkgPT4ge1xyXG5cclxuXHRjb25zdCB2aWV3WiA9IGdldFZpZXdaTm9kZSggYnVpbGRlciApO1xyXG5cclxuXHRyZXR1cm4gZGVuc2l0eS5tdWwoIGRlbnNpdHksIHZpZXdaLCB2aWV3WiApLm5lZ2F0ZSgpLmV4cCgpLm9uZU1pbnVzKCk7XHJcblxyXG59ICk7XHJcblxyXG4vKipcclxuICogVGhpcyBjbGFzcyBjYW4gYmUgdXNlZCB0byBjb25maWd1cmUgYSBmb2cgZm9yIHRoZSBzY2VuZS5cclxuICogTm9kZXMgb2YgdGhpcyB0eXBlIGFyZSBhc3NpZ25lZCB0byBgU2NlbmUuZm9nTm9kZWAuXHJcbiAqXHJcbiAqIEBwYXJhbSB7Tm9kZX0gY29sb3IgLSBEZWZpbmVzIHRoZSBjb2xvciBvZiB0aGUgZm9nLlxyXG4gKiBAcGFyYW0ge05vZGV9IGZhY3RvciAtIERlZmluZXMgaG93IHRoZSBmb2cgaXMgZmFjdG9yZWQgaW4gdGhlIHNjZW5lLlxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IGZvZyA9IEZuKCAoIFsgY29sb3IsIGZhY3RvciBdICkgPT4ge1xyXG5cclxuXHRyZXR1cm4gdmVjNCggZmFjdG9yLnRvRmxvYXQoKS5taXgoIG91dHB1dC5yZ2IsIGNvbG9yLnRvVmVjMygpICksIG91dHB1dC5hICk7XHJcblxyXG59ICk7XHJcblxyXG4vLyBEZXByZWNhdGVkXHJcblxyXG5leHBvcnQgZnVuY3Rpb24gcmFuZ2VGb2coIGNvbG9yLCBuZWFyLCBmYXIgKSB7IC8vIEBkZXByZWNhdGVkLCByMTcxXHJcblxyXG5cdGNvbnNvbGUud2FybiggJ1RIUkVFLlRTTDogXCJyYW5nZUZvZyggY29sb3IsIG5lYXIsIGZhciApXCIgaXMgZGVwcmVjYXRlZC4gVXNlIFwiZm9nKCBjb2xvciwgcmFuZ2VGb2dGYWN0b3IoIG5lYXIsIGZhciApIClcIiBpbnN0ZWFkLicgKTtcclxuXHRyZXR1cm4gZm9nKCBjb2xvciwgcmFuZ2VGb2dGYWN0b3IoIG5lYXIsIGZhciApICk7XHJcblxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZGVuc2l0eUZvZyggY29sb3IsIGRlbnNpdHkgKSB7IC8vIEBkZXByZWNhdGVkLCByMTcxXHJcblxyXG5cdGNvbnNvbGUud2FybiggJ1RIUkVFLlRTTDogXCJkZW5zaXR5Rm9nKCBjb2xvciwgZGVuc2l0eSApXCIgaXMgZGVwcmVjYXRlZC4gVXNlIFwiZm9nKCBjb2xvciwgZGVuc2l0eUZvZ0ZhY3RvciggZGVuc2l0eSApIClcIiBpbnN0ZWFkLicgKTtcclxuXHRyZXR1cm4gZm9nKCBjb2xvciwgZGVuc2l0eUZvZ0ZhY3RvciggZGVuc2l0eSApICk7XHJcblxyXG59XHJcbiIsImltcG9ydCBOb2RlIGZyb20gJy4uL2NvcmUvTm9kZS5qcyc7XHJcbmltcG9ydCB7IGdldFZhbHVlVHlwZSB9IGZyb20gJy4uL2NvcmUvTm9kZVV0aWxzLmpzJztcclxuaW1wb3J0IHsgYnVmZmVyIH0gZnJvbSAnLi4vYWNjZXNzb3JzL0J1ZmZlck5vZGUuanMnO1xyXG5pbXBvcnQgeyBpbnN0YW5jZWRCdWZmZXJBdHRyaWJ1dGUgfSBmcm9tICcuLi9hY2Nlc3NvcnMvQnVmZmVyQXR0cmlidXRlTm9kZS5qcyc7XHJcbmltcG9ydCB7IGluc3RhbmNlSW5kZXggfSBmcm9tICcuLi9jb3JlL0luZGV4Tm9kZS5qcyc7XHJcbmltcG9ydCB7IG5vZGVQcm94eSwgZmxvYXQgfSBmcm9tICcuLi90c2wvVFNMQmFzZS5qcyc7XHJcblxyXG5pbXBvcnQgeyBWZWN0b3I0IH0gZnJvbSAnLi4vLi4vbWF0aC9WZWN0b3I0LmpzJztcclxuaW1wb3J0IHsgTWF0aFV0aWxzIH0gZnJvbSAnLi4vLi4vbWF0aC9NYXRoVXRpbHMuanMnO1xyXG5pbXBvcnQgeyBJbnN0YW5jZWRCdWZmZXJBdHRyaWJ1dGUgfSBmcm9tICcuLi8uLi9jb3JlL0luc3RhbmNlZEJ1ZmZlckF0dHJpYnV0ZS5qcyc7XHJcblxyXG4vKiogQG1vZHVsZSBSYW5nZU5vZGUgKiovXHJcblxyXG5sZXQgbWluID0gbnVsbDtcclxubGV0IG1heCA9IG51bGw7XHJcblxyXG4vKipcclxuICogYFJhbmdlTm9kZWAgZ2VuZXJhdGVzIHJhbmRvbSBpbnN0YW5jZWQgYXR0cmlidXRlIGRhdGEgaW4gYSBkZWZpbmVkIHJhbmdlLlxyXG4gKiBBbiBleGVtcGxhcnkgdXNlIGNhc2UgZm9yIHRoaXMgdXRpbGl0eSBub2RlIGlzIHRvIGdlbmVyYXRlIHJhbmRvbSBwZXItaW5zdGFuY2VcclxuICogY29sb3JzOlxyXG4gKiBgYGBqc1xyXG4gKiBjb25zdCBtYXRlcmlhbCA9IG5ldyBNZXNoQmFzaWNOb2RlTWF0ZXJpYWwoKTtcclxuICogbWF0ZXJpYWwuY29sb3JOb2RlID0gcmFuZ2UoIG5ldyBDb2xvciggMHgwMDAwMDAgKSwgbmV3IENvbG9yKCAweEZGRkZGRiApICk7XHJcbiAqIGNvbnN0IG1lc2ggPSBuZXcgSW5zdGFuY2VkTWVzaCggZ2VvbWV0cnksIG1hdGVyaWFsLCBjb3VudCApO1xyXG4gKiBgYGBcclxuICogQGF1Z21lbnRzIE5vZGVcclxuICovXHJcbmNsYXNzIFJhbmdlTm9kZSBleHRlbmRzIE5vZGUge1xyXG5cclxuXHRzdGF0aWMgZ2V0IHR5cGUoKSB7XHJcblxyXG5cdFx0cmV0dXJuICdSYW5nZU5vZGUnO1xyXG5cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIENvbnN0cnVjdHMgYSBuZXcgcmFuZ2Ugbm9kZS5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7Tm9kZTxhbnk+fSBbbWluTm9kZT1mbG9hdCgpXSAtIEEgbm9kZSBkZWZpbmluZyB0aGUgbG93ZXIgYm91bmQgb2YgdGhlIHJhbmdlLlxyXG5cdCAqIEBwYXJhbSB7Tm9kZTxhbnk+fSBbbWF4Tm9kZT1mbG9hdCgpXSAtIEEgbm9kZSBkZWZpbmluZyB0aGUgdXBwZXIgYm91bmQgb2YgdGhlIHJhbmdlLlxyXG5cdCAqL1xyXG5cdGNvbnN0cnVjdG9yKCBtaW5Ob2RlID0gZmxvYXQoKSwgbWF4Tm9kZSA9IGZsb2F0KCkgKSB7XHJcblxyXG5cdFx0c3VwZXIoKTtcclxuXHJcblx0XHQvKipcclxuXHRcdCAqICBBIG5vZGUgZGVmaW5pbmcgdGhlIGxvd2VyIGJvdW5kIG9mIHRoZSByYW5nZS5cclxuXHRcdCAqXHJcblx0XHQgKiBAdHlwZSB7Tm9kZTxhbnk+fVxyXG5cdFx0ICogQGRlZmF1bHQgZmxvYXQoKVxyXG5cdFx0ICovXHJcblx0XHR0aGlzLm1pbk5vZGUgPSBtaW5Ob2RlO1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogIEEgbm9kZSBkZWZpbmluZyB0aGUgdXBwZXIgYm91bmQgb2YgdGhlIHJhbmdlLlxyXG5cdFx0ICpcclxuXHRcdCAqIEB0eXBlIHtOb2RlPGFueT59XHJcblx0XHQgKiBAZGVmYXVsdCBmbG9hdCgpXHJcblx0XHQgKi9cclxuXHRcdHRoaXMubWF4Tm9kZSA9IG1heE5vZGU7XHJcblxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogUmV0dXJucyB0aGUgdmVjdG9yIGxlbmd0aCB3aGljaCBpcyBjb21wdXRlZCBiYXNlZCBvbiB0aGUgcmFuZ2UgZGVmaW5pdGlvbi5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7Tm9kZUJ1aWxkZXJ9IGJ1aWxkZXIgLSBUaGUgY3VycmVudCBub2RlIGJ1aWxkZXIuXHJcblx0ICogQHJldHVybiB7TnVtYmVyfSBUaGUgdmVjdG9yIGxlbmd0aC5cclxuXHQgKi9cclxuXHRnZXRWZWN0b3JMZW5ndGgoIGJ1aWxkZXIgKSB7XHJcblxyXG5cdFx0Y29uc3QgbWluTGVuZ3RoID0gYnVpbGRlci5nZXRUeXBlTGVuZ3RoKCBnZXRWYWx1ZVR5cGUoIHRoaXMubWluTm9kZS52YWx1ZSApICk7XHJcblx0XHRjb25zdCBtYXhMZW5ndGggPSBidWlsZGVyLmdldFR5cGVMZW5ndGgoIGdldFZhbHVlVHlwZSggdGhpcy5tYXhOb2RlLnZhbHVlICkgKTtcclxuXHJcblx0XHRyZXR1cm4gbWluTGVuZ3RoID4gbWF4TGVuZ3RoID8gbWluTGVuZ3RoIDogbWF4TGVuZ3RoO1xyXG5cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFRoaXMgbWV0aG9kIGlzIG92ZXJ3cml0dGVuIHNpbmNlIHRoZSBub2RlIHR5cGUgaXMgaW5mZXJyZWQgZnJvbSByYW5nZSBkZWZpbml0aW9uLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtOb2RlQnVpbGRlcn0gYnVpbGRlciAtIFRoZSBjdXJyZW50IG5vZGUgYnVpbGRlci5cclxuXHQgKiBAcmV0dXJuIHtTdHJpbmd9IFRoZSBub2RlIHR5cGUuXHJcblx0ICovXHJcblx0Z2V0Tm9kZVR5cGUoIGJ1aWxkZXIgKSB7XHJcblxyXG5cdFx0cmV0dXJuIGJ1aWxkZXIub2JqZWN0LmNvdW50ID4gMSA/IGJ1aWxkZXIuZ2V0VHlwZUZyb21MZW5ndGgoIHRoaXMuZ2V0VmVjdG9yTGVuZ3RoKCBidWlsZGVyICkgKSA6ICdmbG9hdCc7XHJcblxyXG5cdH1cclxuXHJcblx0c2V0dXAoIGJ1aWxkZXIgKSB7XHJcblxyXG5cdFx0Y29uc3Qgb2JqZWN0ID0gYnVpbGRlci5vYmplY3Q7XHJcblxyXG5cdFx0bGV0IG91dHB1dCA9IG51bGw7XHJcblxyXG5cdFx0aWYgKCBvYmplY3QuY291bnQgPiAxICkge1xyXG5cclxuXHRcdFx0Y29uc3QgbWluVmFsdWUgPSB0aGlzLm1pbk5vZGUudmFsdWU7XHJcblx0XHRcdGNvbnN0IG1heFZhbHVlID0gdGhpcy5tYXhOb2RlLnZhbHVlO1xyXG5cclxuXHRcdFx0Y29uc3QgbWluTGVuZ3RoID0gYnVpbGRlci5nZXRUeXBlTGVuZ3RoKCBnZXRWYWx1ZVR5cGUoIG1pblZhbHVlICkgKTtcclxuXHRcdFx0Y29uc3QgbWF4TGVuZ3RoID0gYnVpbGRlci5nZXRUeXBlTGVuZ3RoKCBnZXRWYWx1ZVR5cGUoIG1heFZhbHVlICkgKTtcclxuXHJcblx0XHRcdG1pbiA9IG1pbiB8fCBuZXcgVmVjdG9yNCgpO1xyXG5cdFx0XHRtYXggPSBtYXggfHwgbmV3IFZlY3RvcjQoKTtcclxuXHJcblx0XHRcdG1pbi5zZXRTY2FsYXIoIDAgKTtcclxuXHRcdFx0bWF4LnNldFNjYWxhciggMCApO1xyXG5cclxuXHRcdFx0aWYgKCBtaW5MZW5ndGggPT09IDEgKSBtaW4uc2V0U2NhbGFyKCBtaW5WYWx1ZSApO1xyXG5cdFx0XHRlbHNlIGlmICggbWluVmFsdWUuaXNDb2xvciApIG1pbi5zZXQoIG1pblZhbHVlLnIsIG1pblZhbHVlLmcsIG1pblZhbHVlLmIsIDEgKTtcclxuXHRcdFx0ZWxzZSBtaW4uc2V0KCBtaW5WYWx1ZS54LCBtaW5WYWx1ZS55LCBtaW5WYWx1ZS56IHx8IDAsIG1pblZhbHVlLncgfHwgMCApO1xyXG5cclxuXHRcdFx0aWYgKCBtYXhMZW5ndGggPT09IDEgKSBtYXguc2V0U2NhbGFyKCBtYXhWYWx1ZSApO1xyXG5cdFx0XHRlbHNlIGlmICggbWF4VmFsdWUuaXNDb2xvciApIG1heC5zZXQoIG1heFZhbHVlLnIsIG1heFZhbHVlLmcsIG1heFZhbHVlLmIsIDEgKTtcclxuXHRcdFx0ZWxzZSBtYXguc2V0KCBtYXhWYWx1ZS54LCBtYXhWYWx1ZS55LCBtYXhWYWx1ZS56IHx8IDAsIG1heFZhbHVlLncgfHwgMCApO1xyXG5cclxuXHRcdFx0Y29uc3Qgc3RyaWRlID0gNDtcclxuXHJcblx0XHRcdGNvbnN0IGxlbmd0aCA9IHN0cmlkZSAqIG9iamVjdC5jb3VudDtcclxuXHRcdFx0Y29uc3QgYXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KCBsZW5ndGggKTtcclxuXHJcblx0XHRcdGZvciAoIGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0Y29uc3QgaW5kZXggPSBpICUgc3RyaWRlO1xyXG5cclxuXHRcdFx0XHRjb25zdCBtaW5FbGVtZW50VmFsdWUgPSBtaW4uZ2V0Q29tcG9uZW50KCBpbmRleCApO1xyXG5cdFx0XHRcdGNvbnN0IG1heEVsZW1lbnRWYWx1ZSA9IG1heC5nZXRDb21wb25lbnQoIGluZGV4ICk7XHJcblxyXG5cdFx0XHRcdGFycmF5WyBpIF0gPSBNYXRoVXRpbHMubGVycCggbWluRWxlbWVudFZhbHVlLCBtYXhFbGVtZW50VmFsdWUsIE1hdGgucmFuZG9tKCkgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGNvbnN0IG5vZGVUeXBlID0gdGhpcy5nZXROb2RlVHlwZSggYnVpbGRlciApO1xyXG5cclxuXHRcdFx0aWYgKCBvYmplY3QuY291bnQgPD0gNDA5NiApIHtcclxuXHJcblx0XHRcdFx0b3V0cHV0ID0gYnVmZmVyKCBhcnJheSwgJ3ZlYzQnLCBvYmplY3QuY291bnQgKS5lbGVtZW50KCBpbnN0YW5jZUluZGV4ICkuY29udmVydCggbm9kZVR5cGUgKTtcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdC8vIFRPRE86IEltcHJvdmUgYW5vbnltb3VzIGJ1ZmZlciBhdHRyaWJ1dGUgY3JlYXRpb24gcmVtb3ZpbmcgdGhpcyBwYXJ0XHJcblx0XHRcdFx0Y29uc3QgYnVmZmVyQXR0cmlidXRlID0gbmV3IEluc3RhbmNlZEJ1ZmZlckF0dHJpYnV0ZSggYXJyYXksIDQgKTtcclxuXHRcdFx0XHRidWlsZGVyLmdlb21ldHJ5LnNldEF0dHJpYnV0ZSggJ19fcmFuZ2UnICsgdGhpcy5pZCwgYnVmZmVyQXR0cmlidXRlICk7XHJcblxyXG5cdFx0XHRcdG91dHB1dCA9IGluc3RhbmNlZEJ1ZmZlckF0dHJpYnV0ZSggYnVmZmVyQXR0cmlidXRlICkuY29udmVydCggbm9kZVR5cGUgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0b3V0cHV0ID0gZmxvYXQoIDAgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIG91dHB1dDtcclxuXHJcblx0fVxyXG5cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgUmFuZ2VOb2RlO1xyXG5cclxuLyoqXHJcbiAqIFRTTCBmdW5jdGlvbiBmb3IgY3JlYXRpbmcgYSByYW5nZSBub2RlLlxyXG4gKlxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHtOb2RlPGFueT59IFttaW5Ob2RlPWZsb2F0KCldIC0gQSBub2RlIGRlZmluaW5nIHRoZSBsb3dlciBib3VuZCBvZiB0aGUgcmFuZ2UuXHJcbiAqIEBwYXJhbSB7Tm9kZTxhbnk+fSBbbWF4Tm9kZT1mbG9hdCgpXSAtIEEgbm9kZSBkZWZpbmluZyB0aGUgdXBwZXIgYm91bmQgb2YgdGhlIHJhbmdlLlxyXG4gKiBAcmV0dXJucyB7UmFuZ2VOb2RlfVxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IHJhbmdlID0gLypAX19QVVJFX18qLyBub2RlUHJveHkoIFJhbmdlTm9kZSApO1xyXG4iLCJpbXBvcnQgTm9kZSBmcm9tICcuLi9jb3JlL05vZGUuanMnO1xyXG5pbXBvcnQgeyBub2RlT2JqZWN0IH0gZnJvbSAnLi4vdHNsL1RTTEJhc2UuanMnO1xyXG5cclxuY2xhc3MgQ29tcHV0ZUJ1aWx0aW5Ob2RlIGV4dGVuZHMgTm9kZSB7XHJcblxyXG5cdHN0YXRpYyBnZXQgdHlwZSgpIHtcclxuXHJcblx0XHRyZXR1cm4gJ0NvbXB1dGVCdWlsdGluTm9kZSc7XHJcblxyXG5cdH1cclxuXHJcblx0Y29uc3RydWN0b3IoIGJ1aWx0aW5OYW1lLCBub2RlVHlwZSApIHtcclxuXHJcblx0XHRzdXBlciggbm9kZVR5cGUgKTtcclxuXHJcblx0XHR0aGlzLl9idWlsdGluTmFtZSA9IGJ1aWx0aW5OYW1lO1xyXG5cclxuXHR9XHJcblxyXG5cdGdldEhhc2goIGJ1aWxkZXIgKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuZ2V0QnVpbHRpbk5hbWUoIGJ1aWxkZXIgKTtcclxuXHJcblx0fVxyXG5cclxuXHRnZXROb2RlVHlwZSggLypidWlsZGVyKi8gKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMubm9kZVR5cGU7XHJcblxyXG5cdH1cclxuXHJcblx0c2V0QnVpbHRpbk5hbWUoIGJ1aWx0aW5OYW1lICkge1xyXG5cclxuXHRcdHRoaXMuX2J1aWx0aW5OYW1lID0gYnVpbHRpbk5hbWU7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHJcblx0Z2V0QnVpbHRpbk5hbWUoIC8qYnVpbGRlciovICkge1xyXG5cclxuXHRcdHJldHVybiB0aGlzLl9idWlsdGluTmFtZTtcclxuXHJcblx0fVxyXG5cclxuXHRoYXNCdWlsdGluKCBidWlsZGVyICkge1xyXG5cclxuXHRcdGJ1aWxkZXIuaGFzQnVpbHRpbiggdGhpcy5fYnVpbHRpbk5hbWUgKTtcclxuXHJcblx0fVxyXG5cclxuXHRnZW5lcmF0ZSggYnVpbGRlciwgb3V0cHV0ICkge1xyXG5cclxuXHRcdGNvbnN0IGJ1aWx0aW5OYW1lID0gdGhpcy5nZXRCdWlsdGluTmFtZSggYnVpbGRlciApO1xyXG5cdFx0Y29uc3Qgbm9kZVR5cGUgPSB0aGlzLmdldE5vZGVUeXBlKCBidWlsZGVyICk7XHJcblxyXG5cdFx0aWYgKCBidWlsZGVyLnNoYWRlclN0YWdlID09PSAnY29tcHV0ZScgKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gYnVpbGRlci5mb3JtYXQoIGJ1aWx0aW5OYW1lLCBub2RlVHlwZSwgb3V0cHV0ICk7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdGNvbnNvbGUud2FybiggYENvbXB1dGVCdWlsdGluTm9kZTogQ29tcHV0ZSBidWlsdC1pbiB2YWx1ZSAke2J1aWx0aW5OYW1lfSBjYW4gbm90IGJlIGFjY2Vzc2VkIGluIHRoZSAke2J1aWxkZXIuc2hhZGVyU3RhZ2V9IHN0YWdlYCApO1xyXG5cdFx0XHRyZXR1cm4gYnVpbGRlci5nZW5lcmF0ZUNvbnN0KCBub2RlVHlwZSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHRzZXJpYWxpemUoIGRhdGEgKSB7XHJcblxyXG5cdFx0c3VwZXIuc2VyaWFsaXplKCBkYXRhICk7XHJcblxyXG5cdFx0ZGF0YS5nbG9iYWwgPSB0aGlzLmdsb2JhbDtcclxuXHRcdGRhdGEuX2J1aWx0aW5OYW1lID0gdGhpcy5fYnVpbHRpbk5hbWU7XHJcblxyXG5cdH1cclxuXHJcblx0ZGVzZXJpYWxpemUoIGRhdGEgKSB7XHJcblxyXG5cdFx0c3VwZXIuZGVzZXJpYWxpemUoIGRhdGEgKTtcclxuXHJcblx0XHR0aGlzLmdsb2JhbCA9IGRhdGEuZ2xvYmFsO1xyXG5cdFx0dGhpcy5fYnVpbHRpbk5hbWUgPSBkYXRhLl9idWlsdGluTmFtZTtcclxuXHJcblx0fVxyXG5cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgQ29tcHV0ZUJ1aWx0aW5Ob2RlO1xyXG5cclxuY29uc3QgY29tcHV0ZUJ1aWx0aW4gPSAoIG5hbWUsIG5vZGVUeXBlICkgPT4gbm9kZU9iamVjdCggbmV3IENvbXB1dGVCdWlsdGluTm9kZSggbmFtZSwgbm9kZVR5cGUgKSApO1xyXG5cclxuZXhwb3J0IGNvbnN0IG51bVdvcmtncm91cHMgPSAvKkBfX1BVUkVfXyovIGNvbXB1dGVCdWlsdGluKCAnbnVtV29ya2dyb3VwcycsICd1dmVjMycgKTtcclxuZXhwb3J0IGNvbnN0IHdvcmtncm91cElkID0gLypAX19QVVJFX18qLyBjb21wdXRlQnVpbHRpbiggJ3dvcmtncm91cElkJywgJ3V2ZWMzJyApO1xyXG5leHBvcnQgY29uc3QgbG9jYWxJZCA9IC8qQF9fUFVSRV9fKi8gY29tcHV0ZUJ1aWx0aW4oICdsb2NhbElkJywgJ3V2ZWMzJyApO1xyXG5leHBvcnQgY29uc3Qgc3ViZ3JvdXBTaXplID0gLypAX19QVVJFX18qLyBjb21wdXRlQnVpbHRpbiggJ3N1Ymdyb3VwU2l6ZScsICd1aW50JyApO1xyXG5cclxuIiwiaW1wb3J0IE5vZGUgZnJvbSAnLi4vY29yZS9Ob2RlLmpzJztcclxuaW1wb3J0IHsgbm9kZVByb3h5IH0gZnJvbSAnLi4vdHNsL1RTTENvcmUuanMnO1xyXG5cclxuY2xhc3MgQmFycmllck5vZGUgZXh0ZW5kcyBOb2RlIHtcclxuXHJcblx0Y29uc3RydWN0b3IoIHNjb3BlICkge1xyXG5cclxuXHRcdHN1cGVyKCk7XHJcblxyXG5cdFx0dGhpcy5zY29wZSA9IHNjb3BlO1xyXG5cclxuXHR9XHJcblxyXG5cdGdlbmVyYXRlKCBidWlsZGVyICkge1xyXG5cclxuXHRcdGNvbnN0IHsgc2NvcGUgfSA9IHRoaXM7XHJcblx0XHRjb25zdCB7IHJlbmRlcmVyIH0gPSBidWlsZGVyO1xyXG5cclxuXHRcdGlmICggcmVuZGVyZXIuYmFja2VuZC5pc1dlYkdMQmFja2VuZCA9PT0gdHJ1ZSApIHtcclxuXHJcblx0XHRcdGJ1aWxkZXIuYWRkRmxvd0NvZGUoIGBcXHQvLyAke3Njb3BlfUJhcnJpZXIgXFxuYCApO1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRidWlsZGVyLmFkZExpbmVGbG93Q29kZSggYCR7c2NvcGV9QmFycmllcigpYCwgdGhpcyApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgQmFycmllck5vZGU7XHJcblxyXG5jb25zdCBiYXJyaWVyID0gbm9kZVByb3h5KCBCYXJyaWVyTm9kZSApO1xyXG5cclxuZXhwb3J0IGNvbnN0IHdvcmtncm91cEJhcnJpZXIgPSAoKSA9PiBiYXJyaWVyKCAnd29ya2dyb3VwJyApLmFwcGVuZCgpO1xyXG5leHBvcnQgY29uc3Qgc3RvcmFnZUJhcnJpZXIgPSAoKSA9PiBiYXJyaWVyKCAnc3RvcmFnZScgKS5hcHBlbmQoKTtcclxuZXhwb3J0IGNvbnN0IHRleHR1cmVCYXJyaWVyID0gKCkgPT4gYmFycmllciggJ3RleHR1cmUnICkuYXBwZW5kKCk7XHJcblxyXG4iLCJpbXBvcnQgQXJyYXlFbGVtZW50Tm9kZSBmcm9tICcuLi91dGlscy9BcnJheUVsZW1lbnROb2RlLmpzJztcclxuaW1wb3J0IHsgbm9kZU9iamVjdCB9IGZyb20gJy4uL3RzbC9UU0xDb3JlLmpzJztcclxuaW1wb3J0IE5vZGUgZnJvbSAnLi4vY29yZS9Ob2RlLmpzJztcclxuXHJcbmNsYXNzIFdvcmtncm91cEluZm9FbGVtZW50Tm9kZSBleHRlbmRzIEFycmF5RWxlbWVudE5vZGUge1xyXG5cclxuXHRjb25zdHJ1Y3Rvciggd29ya2dyb3VwSW5mb05vZGUsIGluZGV4Tm9kZSApIHtcclxuXHJcblx0XHRzdXBlciggd29ya2dyb3VwSW5mb05vZGUsIGluZGV4Tm9kZSApO1xyXG5cclxuXHRcdHRoaXMuaXNXb3JrZ3JvdXBJbmZvRWxlbWVudE5vZGUgPSB0cnVlO1xyXG5cclxuXHR9XHJcblxyXG5cdGdlbmVyYXRlKCBidWlsZGVyLCBvdXRwdXQgKSB7XHJcblxyXG5cdFx0bGV0IHNuaXBwZXQ7XHJcblxyXG5cdFx0Y29uc3QgaXNBc3NpZ25Db250ZXh0ID0gYnVpbGRlci5jb250ZXh0LmFzc2lnbjtcclxuXHRcdHNuaXBwZXQgPSBzdXBlci5nZW5lcmF0ZSggYnVpbGRlciApO1xyXG5cclxuXHRcdGlmICggaXNBc3NpZ25Db250ZXh0ICE9PSB0cnVlICkge1xyXG5cclxuXHRcdFx0Y29uc3QgdHlwZSA9IHRoaXMuZ2V0Tm9kZVR5cGUoIGJ1aWxkZXIgKTtcclxuXHJcblx0XHRcdHNuaXBwZXQgPSBidWlsZGVyLmZvcm1hdCggc25pcHBldCwgdHlwZSwgb3V0cHV0ICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIFRPRE86IFBvc3NpYmx5IGFjdGl2YXRlIGNsaXAgZGlzdGFuY2UgaW5kZXggb24gaW5kZXggYWNjZXNzIHJhdGhlciB0aGFuIGZyb20gY2xpcHBpbmcgY29udGV4dFxyXG5cclxuXHRcdHJldHVybiBzbmlwcGV0O1xyXG5cclxuXHR9XHJcblxyXG59XHJcblxyXG5cclxuY2xhc3MgV29ya2dyb3VwSW5mb05vZGUgZXh0ZW5kcyBOb2RlIHtcclxuXHJcblx0Y29uc3RydWN0b3IoIHNjb3BlLCBidWZmZXJUeXBlLCBidWZmZXJDb3VudCA9IDAgKSB7XHJcblxyXG5cdFx0c3VwZXIoIGJ1ZmZlclR5cGUgKTtcclxuXHJcblx0XHR0aGlzLmJ1ZmZlclR5cGUgPSBidWZmZXJUeXBlO1xyXG5cdFx0dGhpcy5idWZmZXJDb3VudCA9IGJ1ZmZlckNvdW50O1xyXG5cclxuXHRcdHRoaXMuaXNXb3JrZ3JvdXBJbmZvTm9kZSA9IHRydWU7XHJcblxyXG5cdFx0dGhpcy5zY29wZSA9IHNjb3BlO1xyXG5cclxuXHR9XHJcblxyXG5cdGxhYmVsKCBuYW1lICkge1xyXG5cclxuXHRcdHRoaXMubmFtZSA9IG5hbWU7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHJcblx0Z2V0SGFzaCgpIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy51dWlkO1xyXG5cclxuXHR9XHJcblxyXG5cdHNldFNjb3BlKCBzY29wZSApIHtcclxuXHJcblx0XHR0aGlzLnNjb3BlID0gc2NvcGU7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHJcblx0Z2V0SW5wdXRUeXBlKCAvKmJ1aWxkZXIqLyApIHtcclxuXHJcblx0XHRyZXR1cm4gYCR7dGhpcy5zY29wZX1BcnJheWA7XHJcblxyXG5cdH1cclxuXHJcblx0ZWxlbWVudCggaW5kZXhOb2RlICkge1xyXG5cclxuXHRcdHJldHVybiBub2RlT2JqZWN0KCBuZXcgV29ya2dyb3VwSW5mb0VsZW1lbnROb2RlKCB0aGlzLCBpbmRleE5vZGUgKSApO1xyXG5cclxuXHR9XHJcblxyXG5cdGdlbmVyYXRlKCBidWlsZGVyICkge1xyXG5cclxuXHRcdHJldHVybiBidWlsZGVyLmdldFNjb3BlZEFycmF5KCB0aGlzLm5hbWUgfHwgYCR7dGhpcy5zY29wZX1BcnJheV8ke3RoaXMuaWR9YCwgdGhpcy5zY29wZS50b0xvd2VyQ2FzZSgpLCB0aGlzLmJ1ZmZlclR5cGUsIHRoaXMuYnVmZmVyQ291bnQgKTtcclxuXHJcblx0fVxyXG5cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgV29ya2dyb3VwSW5mb05vZGU7XHJcblxyXG5leHBvcnQgY29uc3Qgd29ya2dyb3VwQXJyYXkgPSAoIHR5cGUsIGNvdW50ICkgPT4gbm9kZU9iamVjdCggbmV3IFdvcmtncm91cEluZm9Ob2RlKCAnV29ya2dyb3VwJywgdHlwZSwgY291bnQgKSApO1xyXG5cclxuXHJcbiIsImltcG9ydCBUZW1wTm9kZSBmcm9tICcuLi9jb3JlL1RlbXBOb2RlLmpzJztcclxuaW1wb3J0IHsgbm9kZVByb3h5IH0gZnJvbSAnLi4vdHNsL1RTTENvcmUuanMnO1xyXG5cclxuY2xhc3MgQXRvbWljRnVuY3Rpb25Ob2RlIGV4dGVuZHMgVGVtcE5vZGUge1xyXG5cclxuXHRzdGF0aWMgZ2V0IHR5cGUoKSB7XHJcblxyXG5cdFx0cmV0dXJuICdBdG9taWNGdW5jdGlvbk5vZGUnO1xyXG5cclxuXHR9XHJcblxyXG5cdGNvbnN0cnVjdG9yKCBtZXRob2QsIHBvaW50ZXJOb2RlLCB2YWx1ZU5vZGUsIHN0b3JlTm9kZSA9IG51bGwgKSB7XHJcblxyXG5cdFx0c3VwZXIoICd1aW50JyApO1xyXG5cclxuXHRcdHRoaXMubWV0aG9kID0gbWV0aG9kO1xyXG5cclxuXHRcdHRoaXMucG9pbnRlck5vZGUgPSBwb2ludGVyTm9kZTtcclxuXHRcdHRoaXMudmFsdWVOb2RlID0gdmFsdWVOb2RlO1xyXG5cdFx0dGhpcy5zdG9yZU5vZGUgPSBzdG9yZU5vZGU7XHJcblxyXG5cdH1cclxuXHJcblx0Z2V0SW5wdXRUeXBlKCBidWlsZGVyICkge1xyXG5cclxuXHRcdHJldHVybiB0aGlzLnBvaW50ZXJOb2RlLmdldE5vZGVUeXBlKCBidWlsZGVyICk7XHJcblxyXG5cdH1cclxuXHJcblx0Z2V0Tm9kZVR5cGUoIGJ1aWxkZXIgKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuZ2V0SW5wdXRUeXBlKCBidWlsZGVyICk7XHJcblxyXG5cdH1cclxuXHJcblx0Z2VuZXJhdGUoIGJ1aWxkZXIgKSB7XHJcblxyXG5cdFx0Y29uc3QgbWV0aG9kID0gdGhpcy5tZXRob2Q7XHJcblxyXG5cdFx0Y29uc3QgdHlwZSA9IHRoaXMuZ2V0Tm9kZVR5cGUoIGJ1aWxkZXIgKTtcclxuXHRcdGNvbnN0IGlucHV0VHlwZSA9IHRoaXMuZ2V0SW5wdXRUeXBlKCBidWlsZGVyICk7XHJcblxyXG5cdFx0Y29uc3QgYSA9IHRoaXMucG9pbnRlck5vZGU7XHJcblx0XHRjb25zdCBiID0gdGhpcy52YWx1ZU5vZGU7XHJcblxyXG5cdFx0Y29uc3QgcGFyYW1zID0gW107XHJcblxyXG5cdFx0cGFyYW1zLnB1c2goIGAmJHsgYS5idWlsZCggYnVpbGRlciwgaW5wdXRUeXBlICkgfWAgKTtcclxuXHRcdHBhcmFtcy5wdXNoKCBiLmJ1aWxkKCBidWlsZGVyLCBpbnB1dFR5cGUgKSApO1xyXG5cclxuXHRcdGNvbnN0IG1ldGhvZFNuaXBwZXQgPSBgJHsgYnVpbGRlci5nZXRNZXRob2QoIG1ldGhvZCwgdHlwZSApIH0oICR7cGFyYW1zLmpvaW4oICcsICcgKX0gKWA7XHJcblxyXG5cdFx0aWYgKCB0aGlzLnN0b3JlTm9kZSAhPT0gbnVsbCApIHtcclxuXHJcblx0XHRcdGNvbnN0IHZhclNuaXBwZXQgPSB0aGlzLnN0b3JlTm9kZS5idWlsZCggYnVpbGRlciwgaW5wdXRUeXBlICk7XHJcblxyXG5cdFx0XHRidWlsZGVyLmFkZExpbmVGbG93Q29kZSggYCR7dmFyU25pcHBldH0gPSAke21ldGhvZFNuaXBwZXR9YCwgdGhpcyApO1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRidWlsZGVyLmFkZExpbmVGbG93Q29kZSggbWV0aG9kU25pcHBldCwgdGhpcyApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxufVxyXG5cclxuQXRvbWljRnVuY3Rpb25Ob2RlLkFUT01JQ19MT0FEID0gJ2F0b21pY0xvYWQnO1xyXG5BdG9taWNGdW5jdGlvbk5vZGUuQVRPTUlDX1NUT1JFID0gJ2F0b21pY1N0b3JlJztcclxuQXRvbWljRnVuY3Rpb25Ob2RlLkFUT01JQ19BREQgPSAnYXRvbWljQWRkJztcclxuQXRvbWljRnVuY3Rpb25Ob2RlLkFUT01JQ19TVUIgPSAnYXRvbWljU3ViJztcclxuQXRvbWljRnVuY3Rpb25Ob2RlLkFUT01JQ19NQVggPSAnYXRvbWljTWF4JztcclxuQXRvbWljRnVuY3Rpb25Ob2RlLkFUT01JQ19NSU4gPSAnYXRvbWljTWluJztcclxuQXRvbWljRnVuY3Rpb25Ob2RlLkFUT01JQ19BTkQgPSAnYXRvbWljQW5kJztcclxuQXRvbWljRnVuY3Rpb25Ob2RlLkFUT01JQ19PUiA9ICdhdG9taWNPcic7XHJcbkF0b21pY0Z1bmN0aW9uTm9kZS5BVE9NSUNfWE9SID0gJ2F0b21pY1hvcic7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBBdG9taWNGdW5jdGlvbk5vZGU7XHJcblxyXG5jb25zdCBhdG9taWNOb2RlID0gbm9kZVByb3h5KCBBdG9taWNGdW5jdGlvbk5vZGUgKTtcclxuXHJcbmV4cG9ydCBjb25zdCBhdG9taWNGdW5jID0gKCBtZXRob2QsIHBvaW50ZXJOb2RlLCB2YWx1ZU5vZGUsIHN0b3JlTm9kZSApID0+IHtcclxuXHJcblx0Y29uc3Qgbm9kZSA9IGF0b21pY05vZGUoIG1ldGhvZCwgcG9pbnRlck5vZGUsIHZhbHVlTm9kZSwgc3RvcmVOb2RlICk7XHJcblx0bm9kZS5hcHBlbmQoKTtcclxuXHJcblx0cmV0dXJuIG5vZGU7XHJcblxyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IGF0b21pY1N0b3JlID0gKCBwb2ludGVyTm9kZSwgdmFsdWVOb2RlLCBzdG9yZU5vZGUgPSBudWxsICkgPT4gYXRvbWljRnVuYyggQXRvbWljRnVuY3Rpb25Ob2RlLkFUT01JQ19TVE9SRSwgcG9pbnRlck5vZGUsIHZhbHVlTm9kZSwgc3RvcmVOb2RlICk7XHJcbmV4cG9ydCBjb25zdCBhdG9taWNBZGQgPSAoIHBvaW50ZXJOb2RlLCB2YWx1ZU5vZGUsIHN0b3JlTm9kZSA9IG51bGwgKSA9PiBhdG9taWNGdW5jKCBBdG9taWNGdW5jdGlvbk5vZGUuQVRPTUlDX0FERCwgcG9pbnRlck5vZGUsIHZhbHVlTm9kZSwgc3RvcmVOb2RlICk7XHJcbmV4cG9ydCBjb25zdCBhdG9taWNTdWIgPSAoIHBvaW50ZXJOb2RlLCB2YWx1ZU5vZGUsIHN0b3JlTm9kZSA9IG51bGwgKSA9PiBhdG9taWNGdW5jKCBBdG9taWNGdW5jdGlvbk5vZGUuQVRPTUlDX1NVQiwgcG9pbnRlck5vZGUsIHZhbHVlTm9kZSwgc3RvcmVOb2RlICk7XHJcbmV4cG9ydCBjb25zdCBhdG9taWNNYXggPSAoIHBvaW50ZXJOb2RlLCB2YWx1ZU5vZGUsIHN0b3JlTm9kZSA9IG51bGwgKSA9PiBhdG9taWNGdW5jKCBBdG9taWNGdW5jdGlvbk5vZGUuQVRPTUlDX01BWCwgcG9pbnRlck5vZGUsIHZhbHVlTm9kZSwgc3RvcmVOb2RlICk7XHJcbmV4cG9ydCBjb25zdCBhdG9taWNNaW4gPSAoIHBvaW50ZXJOb2RlLCB2YWx1ZU5vZGUsIHN0b3JlTm9kZSA9IG51bGwgKSA9PiBhdG9taWNGdW5jKCBBdG9taWNGdW5jdGlvbk5vZGUuQVRPTUlDX01JTiwgcG9pbnRlck5vZGUsIHZhbHVlTm9kZSwgc3RvcmVOb2RlICk7XHJcbmV4cG9ydCBjb25zdCBhdG9taWNBbmQgPSAoIHBvaW50ZXJOb2RlLCB2YWx1ZU5vZGUsIHN0b3JlTm9kZSA9IG51bGwgKSA9PiBhdG9taWNGdW5jKCBBdG9taWNGdW5jdGlvbk5vZGUuQVRPTUlDX0FORCwgcG9pbnRlck5vZGUsIHZhbHVlTm9kZSwgc3RvcmVOb2RlICk7XHJcbmV4cG9ydCBjb25zdCBhdG9taWNPciA9ICggcG9pbnRlck5vZGUsIHZhbHVlTm9kZSwgc3RvcmVOb2RlID0gbnVsbCApID0+IGF0b21pY0Z1bmMoIEF0b21pY0Z1bmN0aW9uTm9kZS5BVE9NSUNfT1IsIHBvaW50ZXJOb2RlLCB2YWx1ZU5vZGUsIHN0b3JlTm9kZSApO1xyXG5leHBvcnQgY29uc3QgYXRvbWljWG9yID0gKCBwb2ludGVyTm9kZSwgdmFsdWVOb2RlLCBzdG9yZU5vZGUgPSBudWxsICkgPT4gYXRvbWljRnVuYyggQXRvbWljRnVuY3Rpb25Ob2RlLkFUT01JQ19YT1IsIHBvaW50ZXJOb2RlLCB2YWx1ZU5vZGUsIHN0b3JlTm9kZSApO1xyXG4iLCJpbXBvcnQgeyB1bmlmb3JtIH0gZnJvbSAnLi4vY29yZS9Vbmlmb3JtTm9kZS5qcyc7XHJcbmltcG9ydCB7IHJlbmRlckdyb3VwIH0gZnJvbSAnLi4vY29yZS9Vbmlmb3JtR3JvdXBOb2RlLmpzJztcclxuaW1wb3J0IHsgVmVjdG9yMyB9IGZyb20gJy4uLy4uL21hdGgvVmVjdG9yMy5qcyc7XHJcbmltcG9ydCB7IGNhbWVyYVZpZXdNYXRyaXggfSBmcm9tICcuL0NhbWVyYS5qcyc7XHJcbmltcG9ydCB7IHBvc2l0aW9uV29ybGQgfSBmcm9tICcuL1Bvc2l0aW9uLmpzJztcclxuXHJcbmxldCB1bmlmb3Jtc0xpYjtcclxuXHJcbmZ1bmN0aW9uIGdldExpZ2h0RGF0YSggbGlnaHQgKSB7XHJcblxyXG5cdHVuaWZvcm1zTGliID0gdW5pZm9ybXNMaWIgfHwgbmV3IFdlYWtNYXAoKTtcclxuXHJcblx0bGV0IHVuaWZvcm1zID0gdW5pZm9ybXNMaWIuZ2V0KCBsaWdodCApO1xyXG5cclxuXHRpZiAoIHVuaWZvcm1zID09PSB1bmRlZmluZWQgKSB1bmlmb3Jtc0xpYi5zZXQoIGxpZ2h0LCB1bmlmb3JtcyA9IHt9ICk7XHJcblxyXG5cdHJldHVybiB1bmlmb3JtcztcclxuXHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBsaWdodFNoYWRvd01hdHJpeCggbGlnaHQgKSB7XHJcblxyXG5cdGNvbnN0IGRhdGEgPSBnZXRMaWdodERhdGEoIGxpZ2h0ICk7XHJcblxyXG5cdHJldHVybiBkYXRhLnNoYWRvd01hdHJpeCB8fCAoIGRhdGEuc2hhZG93TWF0cml4ID0gdW5pZm9ybSggJ21hdDQnICkuc2V0R3JvdXAoIHJlbmRlckdyb3VwICkub25SZW5kZXJVcGRhdGUoICgpID0+IHtcclxuXHJcblx0XHRpZiAoIGxpZ2h0LmNhc3RTaGFkb3cgIT09IHRydWUgKSB7XHJcblxyXG5cdFx0XHRsaWdodC5zaGFkb3cudXBkYXRlTWF0cmljZXMoIGxpZ2h0ICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBsaWdodC5zaGFkb3cubWF0cml4O1xyXG5cclxuXHR9ICkgKTtcclxuXHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBsaWdodFByb2plY3Rpb25VViggbGlnaHQgKSB7XHJcblxyXG5cdGNvbnN0IGRhdGEgPSBnZXRMaWdodERhdGEoIGxpZ2h0ICk7XHJcblxyXG5cdGlmICggZGF0YS5wcm9qZWN0aW9uVVYgPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRjb25zdCBzcG90TGlnaHRDb29yZCA9IGxpZ2h0U2hhZG93TWF0cml4KCBsaWdodCApLm11bCggcG9zaXRpb25Xb3JsZCApO1xyXG5cclxuXHRcdGRhdGEucHJvamVjdGlvblVWID0gc3BvdExpZ2h0Q29vcmQueHl6LmRpdiggc3BvdExpZ2h0Q29vcmQudyApO1xyXG5cclxuXHJcblx0fVxyXG5cclxuXHRyZXR1cm4gZGF0YS5wcm9qZWN0aW9uVVY7XHJcblxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gbGlnaHRQb3NpdGlvbiggbGlnaHQgKSB7XHJcblxyXG5cdGNvbnN0IGRhdGEgPSBnZXRMaWdodERhdGEoIGxpZ2h0ICk7XHJcblxyXG5cdHJldHVybiBkYXRhLnBvc2l0aW9uIHx8ICggZGF0YS5wb3NpdGlvbiA9IHVuaWZvcm0oIG5ldyBWZWN0b3IzKCkgKS5zZXRHcm91cCggcmVuZGVyR3JvdXAgKS5vblJlbmRlclVwZGF0ZSggKCBfLCBzZWxmICkgPT4gc2VsZi52YWx1ZS5zZXRGcm9tTWF0cml4UG9zaXRpb24oIGxpZ2h0Lm1hdHJpeFdvcmxkICkgKSApO1xyXG5cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGxpZ2h0VGFyZ2V0UG9zaXRpb24oIGxpZ2h0ICkge1xyXG5cclxuXHRjb25zdCBkYXRhID0gZ2V0TGlnaHREYXRhKCBsaWdodCApO1xyXG5cclxuXHRyZXR1cm4gZGF0YS50YXJnZXRQb3NpdGlvbiB8fCAoIGRhdGEudGFyZ2V0UG9zaXRpb24gPSB1bmlmb3JtKCBuZXcgVmVjdG9yMygpICkuc2V0R3JvdXAoIHJlbmRlckdyb3VwICkub25SZW5kZXJVcGRhdGUoICggXywgc2VsZiApID0+IHNlbGYudmFsdWUuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCBsaWdodC50YXJnZXQubWF0cml4V29ybGQgKSApICk7XHJcblxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gbGlnaHRWaWV3UG9zaXRpb24oIGxpZ2h0ICkge1xyXG5cclxuXHRjb25zdCBkYXRhID0gZ2V0TGlnaHREYXRhKCBsaWdodCApO1xyXG5cclxuXHRyZXR1cm4gZGF0YS52aWV3UG9zaXRpb24gfHwgKCBkYXRhLnZpZXdQb3NpdGlvbiA9IHVuaWZvcm0oIG5ldyBWZWN0b3IzKCkgKS5zZXRHcm91cCggcmVuZGVyR3JvdXAgKS5vblJlbmRlclVwZGF0ZSggKCB7IGNhbWVyYSB9LCBzZWxmICkgPT4ge1xyXG5cclxuXHRcdHNlbGYudmFsdWUgPSBzZWxmLnZhbHVlIHx8IG5ldyBWZWN0b3IzKCk7XHJcblx0XHRzZWxmLnZhbHVlLnNldEZyb21NYXRyaXhQb3NpdGlvbiggbGlnaHQubWF0cml4V29ybGQgKTtcclxuXHJcblx0XHRzZWxmLnZhbHVlLmFwcGx5TWF0cml4NCggY2FtZXJhLm1hdHJpeFdvcmxkSW52ZXJzZSApO1xyXG5cclxuXHR9ICkgKTtcclxuXHJcbn1cclxuXHJcbmV4cG9ydCBjb25zdCBsaWdodFRhcmdldERpcmVjdGlvbiA9ICggbGlnaHQgKSA9PiBjYW1lcmFWaWV3TWF0cml4LnRyYW5zZm9ybURpcmVjdGlvbiggbGlnaHRQb3NpdGlvbiggbGlnaHQgKS5zdWIoIGxpZ2h0VGFyZ2V0UG9zaXRpb24oIGxpZ2h0ICkgKSApO1xyXG4iLCJpbXBvcnQgTm9kZSBmcm9tICcuLi9jb3JlL05vZGUuanMnO1xyXG5pbXBvcnQgeyBub2RlT2JqZWN0LCB2ZWMzIH0gZnJvbSAnLi4vdHNsL1RTTEJhc2UuanMnO1xyXG5pbXBvcnQgeyBoYXNoQXJyYXkgfSBmcm9tICcuLi9jb3JlL05vZGVVdGlscy5qcyc7XHJcblxyXG4vKiogQG1vZHVsZSBMaWdodHNOb2RlICoqL1xyXG5cclxuY29uc3Qgc29ydExpZ2h0cyA9ICggbGlnaHRzICkgPT4ge1xyXG5cclxuXHRyZXR1cm4gbGlnaHRzLnNvcnQoICggYSwgYiApID0+IGEuaWQgLSBiLmlkICk7XHJcblxyXG59O1xyXG5cclxuY29uc3QgZ2V0TGlnaHROb2RlQnlJZCA9ICggaWQsIGxpZ2h0Tm9kZXMgKSA9PiB7XHJcblxyXG5cdGZvciAoIGNvbnN0IGxpZ2h0Tm9kZSBvZiBsaWdodE5vZGVzICkge1xyXG5cclxuXHRcdGlmICggbGlnaHROb2RlLmlzQW5hbHl0aWNMaWdodE5vZGUgJiYgbGlnaHROb2RlLmxpZ2h0LmlkID09PSBpZCApIHtcclxuXHJcblx0XHRcdHJldHVybiBsaWdodE5vZGU7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdHJldHVybiBudWxsO1xyXG5cclxufTtcclxuXHJcbmNvbnN0IF9saWdodHNOb2RlUmVmID0gLypAX19QVVJFX18qLyBuZXcgV2Vha01hcCgpO1xyXG5cclxuLyoqXHJcbiAqIFRoaXMgbm9kZSByZXByZXNlbnRzIHRoZSBzY2VuZSdzIGxpZ2h0aW5nIGFuZCBtYW5hZ2VzIHRoZSBsaWdodGluZyBtb2RlbCdzIGxpZmUgY3ljbGVcclxuICogZm9yIHRoZSBjdXJyZW50IGJ1aWxkIDNEIG9iamVjdC4gSXQgaXMgcmVzcG9uc2libGUgZm9yIGNvbXB1dGluZyB0aGUgdG90YWwgb3V0Z29pbmdcclxuICogbGlnaHQgaW4gYSBnaXZlbiBsaWdodGluZyBjb250ZXh0LlxyXG4gKlxyXG4gKiBAYXVnbWVudHMgTm9kZVxyXG4gKi9cclxuY2xhc3MgTGlnaHRzTm9kZSBleHRlbmRzIE5vZGUge1xyXG5cclxuXHRzdGF0aWMgZ2V0IHR5cGUoKSB7XHJcblxyXG5cdFx0cmV0dXJuICdMaWdodHNOb2RlJztcclxuXHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBDb25zdHJ1Y3RzIGEgbmV3IGxpZ2h0cyBub2RlLlxyXG5cdCAqL1xyXG5cdGNvbnN0cnVjdG9yKCkge1xyXG5cclxuXHRcdHN1cGVyKCAndmVjMycgKTtcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIEEgbm9kZSByZXByZXNlbnRpbmcgdGhlIHRvdGFsIGRpZmZ1c2UgbGlnaHQuXHJcblx0XHQgKlxyXG5cdFx0ICogQHR5cGUge05vZGU8dmVjMz59XHJcblx0XHQgKi9cclxuXHRcdHRoaXMudG90YWxEaWZmdXNlTm9kZSA9IHZlYzMoKS50b1ZhciggJ3RvdGFsRGlmZnVzZScgKTtcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIEEgbm9kZSByZXByZXNlbnRpbmcgdGhlIHRvdGFsIHNwZWN1bGFyIGxpZ2h0LlxyXG5cdFx0ICpcclxuXHRcdCAqIEB0eXBlIHtOb2RlPHZlYzM+fVxyXG5cdFx0ICovXHJcblx0XHR0aGlzLnRvdGFsU3BlY3VsYXJOb2RlID0gdmVjMygpLnRvVmFyKCAndG90YWxTcGVjdWxhcicgKTtcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIEEgbm9kZSByZXByZXNlbnRpbmcgdGhlIG91dGdvaW5nIGxpZ2h0LlxyXG5cdFx0ICpcclxuXHRcdCAqIEB0eXBlIHtOb2RlPHZlYzM+fVxyXG5cdFx0ICovXHJcblx0XHR0aGlzLm91dGdvaW5nTGlnaHROb2RlID0gdmVjMygpLnRvVmFyKCAnb3V0Z29pbmdMaWdodCcgKTtcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIEFuIGFycmF5IHJlcHJlc2VudGluZyB0aGUgbGlnaHRzIGluIHRoZSBzY2VuZS5cclxuXHRcdCAqXHJcblx0XHQgKiBAcHJpdmF0ZVxyXG5cdFx0ICogQHR5cGUge0FycmF5PExpZ2h0Pn1cclxuXHRcdCAqL1xyXG5cdFx0dGhpcy5fbGlnaHRzID0gW107XHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBGb3IgZWFjaCBsaWdodCBpbiB0aGUgc2NlbmUsIHRoaXMgbm9kZSB3aWxsIGNyZWF0ZSBhXHJcblx0XHQgKiBjb3JyZXNwb25kaW5nIGxpZ2h0IG5vZGUuXHJcblx0XHQgKlxyXG5cdFx0ICogQHByaXZhdGVcclxuXHRcdCAqIEB0eXBlIHtBcnJheTxMaWdodGluZ05vZGU+P31cclxuXHRcdCAqIEBkZWZhdWx0IG51bGxcclxuXHRcdCAqL1xyXG5cdFx0dGhpcy5fbGlnaHROb2RlcyA9IG51bGw7XHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBBIGhhc2ggZm9yIGlkZW50aWZ5aW5nIHRoZSBjdXJyZW50IGxpZ2h0IG5vZGVzIHNldHVwLlxyXG5cdFx0ICpcclxuXHRcdCAqIEBwcml2YXRlXHJcblx0XHQgKiBAdHlwZSB7U3RyaW5nP31cclxuXHRcdCAqIEBkZWZhdWx0IG51bGxcclxuXHRcdCAqL1xyXG5cdFx0dGhpcy5fbGlnaHROb2Rlc0hhc2ggPSBudWxsO1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogYExpZ2h0c05vZGVgIHNldHMgdGhpcyBwcm9wZXJ0eSB0byBgdHJ1ZWAgYnkgZGVmYXVsdC5cclxuXHRcdCAqXHJcblx0XHQgKiBAdHlwZSB7Qm9vbGVhbn1cclxuXHRcdCAqIEBkZWZhdWx0IHRydWVcclxuXHRcdCAqL1xyXG5cdFx0dGhpcy5nbG9iYWwgPSB0cnVlO1xyXG5cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIE92ZXJ3cml0ZXMgdGhlIGRlZmF1bHQge0BsaW5rIE5vZGUjY3VzdG9tQ2FjaGVLZXl9IGltcGxlbWVudGF0aW9uIGJ5IGluY2x1ZGluZyB0aGVcclxuXHQgKiBsaWdodCBJRHMgaW50byB0aGUgY2FjaGUga2V5LlxyXG5cdCAqXHJcblx0ICogQHJldHVybiB7TnVtYmVyfSBUaGUgY3VzdG9tIGNhY2hlIGtleS5cclxuXHQgKi9cclxuXHRjdXN0b21DYWNoZUtleSgpIHtcclxuXHJcblx0XHRjb25zdCBsaWdodElEcyA9IFtdO1xyXG5cclxuXHRcdGZvciAoIGxldCBpID0gMDsgaSA8IGxpZ2h0cy5sZW5ndGg7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRsaWdodElEcy5wdXNoKCBsaWdodHNbIGkgXS5pZCApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gaGFzaEFycmF5KCBsaWdodElEcyApO1xyXG5cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIENvbXB1dGVzIGEgaGFzaCB2YWx1ZSBmb3IgaWRlbnRpZnlpbmcgdGhlIGN1cnJlbnQgbGlnaHQgbm9kZXMgc2V0dXAuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge05vZGVCdWlsZGVyfSBidWlsZGVyIC0gQSByZWZlcmVuY2UgdG8gdGhlIGN1cnJlbnQgbm9kZSBidWlsZGVyLlxyXG5cdCAqIEByZXR1cm4ge1N0cmluZ30gVGhlIGNvbXB1dGVkIGhhc2guXHJcblx0ICovXHJcblx0Z2V0SGFzaCggYnVpbGRlciApIHtcclxuXHJcblx0XHRpZiAoIHRoaXMuX2xpZ2h0Tm9kZXNIYXNoID09PSBudWxsICkge1xyXG5cclxuXHRcdFx0aWYgKCB0aGlzLl9saWdodE5vZGVzID09PSBudWxsICkgdGhpcy5zZXR1cExpZ2h0c05vZGUoIGJ1aWxkZXIgKTtcclxuXHJcblx0XHRcdGNvbnN0IGhhc2ggPSBbXTtcclxuXHJcblx0XHRcdGZvciAoIGNvbnN0IGxpZ2h0Tm9kZSBvZiB0aGlzLl9saWdodE5vZGVzICkge1xyXG5cclxuXHRcdFx0XHRoYXNoLnB1c2goIGxpZ2h0Tm9kZS5nZXRTZWxmKCkuZ2V0SGFzaCgpICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR0aGlzLl9saWdodE5vZGVzSGFzaCA9ICdsaWdodHMtJyArIGhhc2guam9pbiggJywnICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzLl9saWdodE5vZGVzSGFzaDtcclxuXHJcblx0fVxyXG5cclxuXHRhbmFseXplKCBidWlsZGVyICkge1xyXG5cclxuXHRcdGNvbnN0IHByb3BlcnRpZXMgPSBidWlsZGVyLmdldERhdGFGcm9tTm9kZSggdGhpcyApO1xyXG5cclxuXHRcdGZvciAoIGNvbnN0IG5vZGUgb2YgcHJvcGVydGllcy5ub2RlcyApIHtcclxuXHJcblx0XHRcdG5vZGUuYnVpbGQoIGJ1aWxkZXIgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogQ3JlYXRlcyBsaWdodGluZyBub2RlcyBmb3IgZWFjaCBzY2VuZSBsaWdodC4gVGhpcyBtYWtlcyBpdCBwb3NzaWJsZSB0byBmdXJ0aGVyXHJcblx0ICogcHJvY2VzcyBsaWdodHMgaW4gdGhlIG5vZGUgc3lzdGVtLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtOb2RlQnVpbGRlcn0gYnVpbGRlciAtIEEgcmVmZXJlbmNlIHRvIHRoZSBjdXJyZW50IG5vZGUgYnVpbGRlci5cclxuXHQgKi9cclxuXHRzZXR1cExpZ2h0c05vZGUoIGJ1aWxkZXIgKSB7XHJcblxyXG5cdFx0Y29uc3QgbGlnaHROb2RlcyA9IFtdO1xyXG5cclxuXHRcdGNvbnN0IHByZXZpb3VzTGlnaHROb2RlcyA9IHRoaXMuX2xpZ2h0Tm9kZXM7XHJcblxyXG5cdFx0Y29uc3QgbGlnaHRzID0gc29ydExpZ2h0cyggdGhpcy5fbGlnaHRzICk7XHJcblx0XHRjb25zdCBub2RlTGlicmFyeSA9IGJ1aWxkZXIucmVuZGVyZXIubGlicmFyeTtcclxuXHJcblx0XHRmb3IgKCBjb25zdCBsaWdodCBvZiBsaWdodHMgKSB7XHJcblxyXG5cdFx0XHRpZiAoIGxpZ2h0LmlzTm9kZSApIHtcclxuXHJcblx0XHRcdFx0bGlnaHROb2Rlcy5wdXNoKCBub2RlT2JqZWN0KCBsaWdodCApICk7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRsZXQgbGlnaHROb2RlID0gbnVsbDtcclxuXHJcblx0XHRcdFx0aWYgKCBwcmV2aW91c0xpZ2h0Tm9kZXMgIT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHRcdFx0bGlnaHROb2RlID0gZ2V0TGlnaHROb2RlQnlJZCggbGlnaHQuaWQsIHByZXZpb3VzTGlnaHROb2RlcyApOyAvLyByZXVzZSBleGlzdGluZyBsaWdodCBub2RlXHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0aWYgKCBsaWdodE5vZGUgPT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHRcdFx0Ly8gZmluZCB0aGUgY29ycmVzcG9uZGluZyBub2RlIHR5cGUgZm9yIGEgZ2l2ZW4gbGlnaHRcclxuXHJcblx0XHRcdFx0XHRjb25zdCBsaWdodE5vZGVDbGFzcyA9IG5vZGVMaWJyYXJ5LmdldExpZ2h0Tm9kZUNsYXNzKCBsaWdodC5jb25zdHJ1Y3RvciApO1xyXG5cclxuXHRcdFx0XHRcdGlmICggbGlnaHROb2RlQ2xhc3MgPT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRjb25zb2xlLndhcm4oIGBMaWdodHNOb2RlLnNldHVwTm9kZUxpZ2h0czogTGlnaHQgbm9kZSBub3QgZm91bmQgZm9yICR7IGxpZ2h0LmNvbnN0cnVjdG9yLm5hbWUgfWAgKTtcclxuXHRcdFx0XHRcdFx0Y29udGludWU7XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdGxldCBsaWdodE5vZGUgPSBudWxsO1xyXG5cclxuXHRcdFx0XHRcdGlmICggISBfbGlnaHRzTm9kZVJlZi5oYXMoIGxpZ2h0ICkgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRsaWdodE5vZGUgPSBub2RlT2JqZWN0KCBuZXcgbGlnaHROb2RlQ2xhc3MoIGxpZ2h0ICkgKTtcclxuXHRcdFx0XHRcdFx0X2xpZ2h0c05vZGVSZWYuc2V0KCBsaWdodCwgbGlnaHROb2RlICk7XHJcblxyXG5cdFx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHRcdGxpZ2h0Tm9kZSA9IF9saWdodHNOb2RlUmVmLmdldCggbGlnaHQgKTtcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0bGlnaHROb2Rlcy5wdXNoKCBsaWdodE5vZGUgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9saWdodE5vZGVzID0gbGlnaHROb2RlcztcclxuXHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBTZXR1cHMgdGhlIGludGVybmFsIGxpZ2h0cyBieSBidWlsZGluZyBhbGwgcmVzcGVjdGl2ZVxyXG5cdCAqIGxpZ2h0IG5vZGVzLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtOb2RlQnVpbGRlcn0gYnVpbGRlciAtIEEgcmVmZXJlbmNlIHRvIHRoZSBjdXJyZW50IG5vZGUgYnVpbGRlci5cclxuXHQgKiBAcGFyYW0ge0FycmF5PExpZ2h0aW5nTm9kZT59IGxpZ2h0Tm9kZXMgLSBBbiBhcnJheSBvZiBsaWdodGluZyBub2Rlcy5cclxuXHQgKi9cclxuXHRzZXR1cExpZ2h0cyggYnVpbGRlciwgbGlnaHROb2RlcyApIHtcclxuXHJcblx0XHRmb3IgKCBjb25zdCBsaWdodE5vZGUgb2YgbGlnaHROb2RlcyApIHtcclxuXHJcblx0XHRcdGxpZ2h0Tm9kZS5idWlsZCggYnVpbGRlciApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBUaGUgaW1wbGVtZW50YXRpb24gbWFrZXMgc3VyZSB0aGF0IGZvciBlYWNoIGxpZ2h0IGluIHRoZSBzY2VuZVxyXG5cdCAqIHRoZXJlIGlzIGEgY29ycmVzcG9uZGluZyBsaWdodCBub2RlLiBCeSBidWlsZGluZyB0aGUgbGlnaHQgbm9kZXNcclxuXHQgKiBhbmQgZXZhbHVhdGluZyB0aGUgbGlnaHRpbmcgbW9kZWwgdGhlIG91dGdvaW5nIGxpZ2h0IGlzIGNvbXB1dGVkLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtOb2RlQnVpbGRlcn0gYnVpbGRlciAtIEEgcmVmZXJlbmNlIHRvIHRoZSBjdXJyZW50IG5vZGUgYnVpbGRlci5cclxuXHQgKiBAcmV0dXJuIHtOb2RlPHZlYzM+fSBBIG5vZGUgcmVwcmVzZW50aW5nIHRoZSBvdXRnb2luZyBsaWdodC5cclxuXHQgKi9cclxuXHRzZXR1cCggYnVpbGRlciApIHtcclxuXHJcblx0XHRpZiAoIHRoaXMuX2xpZ2h0Tm9kZXMgPT09IG51bGwgKSB0aGlzLnNldHVwTGlnaHRzTm9kZSggYnVpbGRlciApO1xyXG5cclxuXHRcdGNvbnN0IGNvbnRleHQgPSBidWlsZGVyLmNvbnRleHQ7XHJcblx0XHRjb25zdCBsaWdodGluZ01vZGVsID0gY29udGV4dC5saWdodGluZ01vZGVsO1xyXG5cclxuXHRcdGxldCBvdXRnb2luZ0xpZ2h0Tm9kZSA9IHRoaXMub3V0Z29pbmdMaWdodE5vZGU7XHJcblxyXG5cdFx0aWYgKCBsaWdodGluZ01vZGVsICkge1xyXG5cclxuXHRcdFx0Y29uc3QgeyBfbGlnaHROb2RlcywgdG90YWxEaWZmdXNlTm9kZSwgdG90YWxTcGVjdWxhck5vZGUgfSA9IHRoaXM7XHJcblxyXG5cdFx0XHRjb250ZXh0Lm91dGdvaW5nTGlnaHQgPSBvdXRnb2luZ0xpZ2h0Tm9kZTtcclxuXHJcblx0XHRcdGNvbnN0IHN0YWNrID0gYnVpbGRlci5hZGRTdGFjaygpO1xyXG5cclxuXHRcdFx0Ly9cclxuXHJcblx0XHRcdGNvbnN0IHByb3BlcnRpZXMgPSBidWlsZGVyLmdldERhdGFGcm9tTm9kZSggdGhpcyApO1xyXG5cdFx0XHRwcm9wZXJ0aWVzLm5vZGVzID0gc3RhY2subm9kZXM7XHJcblxyXG5cdFx0XHQvL1xyXG5cclxuXHRcdFx0bGlnaHRpbmdNb2RlbC5zdGFydCggY29udGV4dCwgc3RhY2ssIGJ1aWxkZXIgKTtcclxuXHJcblx0XHRcdC8vIGxpZ2h0c1xyXG5cclxuXHRcdFx0dGhpcy5zZXR1cExpZ2h0cyggYnVpbGRlciwgX2xpZ2h0Tm9kZXMgKTtcclxuXHJcblx0XHRcdC8vXHJcblxyXG5cdFx0XHRsaWdodGluZ01vZGVsLmluZGlyZWN0KCBjb250ZXh0LCBzdGFjaywgYnVpbGRlciApO1xyXG5cclxuXHRcdFx0Ly9cclxuXHJcblx0XHRcdGNvbnN0IHsgYmFja2Ryb3AsIGJhY2tkcm9wQWxwaGEgfSA9IGNvbnRleHQ7XHJcblx0XHRcdGNvbnN0IHsgZGlyZWN0RGlmZnVzZSwgZGlyZWN0U3BlY3VsYXIsIGluZGlyZWN0RGlmZnVzZSwgaW5kaXJlY3RTcGVjdWxhciB9ID0gY29udGV4dC5yZWZsZWN0ZWRMaWdodDtcclxuXHJcblx0XHRcdGxldCB0b3RhbERpZmZ1c2UgPSBkaXJlY3REaWZmdXNlLmFkZCggaW5kaXJlY3REaWZmdXNlICk7XHJcblxyXG5cdFx0XHRpZiAoIGJhY2tkcm9wICE9PSBudWxsICkge1xyXG5cclxuXHRcdFx0XHRpZiAoIGJhY2tkcm9wQWxwaGEgIT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHRcdFx0dG90YWxEaWZmdXNlID0gdmVjMyggYmFja2Ryb3BBbHBoYS5taXgoIHRvdGFsRGlmZnVzZSwgYmFja2Ryb3AgKSApO1xyXG5cclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdHRvdGFsRGlmZnVzZSA9IHZlYzMoIGJhY2tkcm9wICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0Y29udGV4dC5tYXRlcmlhbC50cmFuc3BhcmVudCA9IHRydWU7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR0b3RhbERpZmZ1c2VOb2RlLmFzc2lnbiggdG90YWxEaWZmdXNlICk7XHJcblx0XHRcdHRvdGFsU3BlY3VsYXJOb2RlLmFzc2lnbiggZGlyZWN0U3BlY3VsYXIuYWRkKCBpbmRpcmVjdFNwZWN1bGFyICkgKTtcclxuXHJcblx0XHRcdG91dGdvaW5nTGlnaHROb2RlLmFzc2lnbiggdG90YWxEaWZmdXNlTm9kZS5hZGQoIHRvdGFsU3BlY3VsYXJOb2RlICkgKTtcclxuXHJcblx0XHRcdC8vXHJcblxyXG5cdFx0XHRsaWdodGluZ01vZGVsLmZpbmlzaCggY29udGV4dCwgc3RhY2ssIGJ1aWxkZXIgKTtcclxuXHJcblx0XHRcdC8vXHJcblxyXG5cdFx0XHRvdXRnb2luZ0xpZ2h0Tm9kZSA9IG91dGdvaW5nTGlnaHROb2RlLmJ5cGFzcyggYnVpbGRlci5yZW1vdmVTdGFjaygpICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBvdXRnb2luZ0xpZ2h0Tm9kZTtcclxuXHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBDb25maWd1cmVzIHRoaXMgbm9kZSB3aXRoIGFuIGFycmF5IG9mIGxpZ2h0cy5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7QXJyYXk8TGlnaHQ+fSBsaWdodHMgLSBBbiBhcnJheSBvZiBsaWdodHMuXHJcblx0ICogQHJldHVybiB7TGlnaHRzTm9kZX0gQSByZWZlcmVuY2UgdG8gdGhpcyBub2RlLlxyXG5cdCAqL1xyXG5cdHNldExpZ2h0cyggbGlnaHRzICkge1xyXG5cclxuXHRcdHRoaXMuX2xpZ2h0cyA9IGxpZ2h0cztcclxuXHJcblx0XHR0aGlzLl9saWdodE5vZGVzID0gbnVsbDtcclxuXHRcdHRoaXMuX2xpZ2h0Tm9kZXNIYXNoID0gbnVsbDtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBSZXR1cm5zIGFuIGFycmF5IG9mIHRoZSBzY2VuZSdzIGxpZ2h0cy5cclxuXHQgKlxyXG5cdCAqIEByZXR1cm4ge0FycmF5PExpZ2h0Pn0gVGhlIHNjZW5lJ3MgbGlnaHRzLlxyXG5cdCAqL1xyXG5cdGdldExpZ2h0cygpIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5fbGlnaHRzO1xyXG5cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFdoZXRoZXIgdGhlIHNjZW5lIGhhcyBsaWdodHMgb3Igbm90LlxyXG5cdCAqXHJcblx0ICogQHR5cGUge0Jvb2xlYW59XHJcblx0ICovXHJcblx0Z2V0IGhhc0xpZ2h0cygpIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5fbGlnaHRzLmxlbmd0aCA+IDA7XHJcblxyXG5cdH1cclxuXHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IExpZ2h0c05vZGU7XHJcblxyXG4vKipcclxuICogVFNMIGZ1bmN0aW9uIGZvciBjcmVhdGluZyBhbiBpbnN0YW5jZSBvZiBgTGlnaHRzTm9kZWAgYW5kIGNvbmZpZ3VyaW5nXHJcbiAqIGl0IHdpdGggdGhlIGdpdmVuIGFycmF5IG9mIGxpZ2h0cy5cclxuICpcclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7QXJyYXk8TGlnaHQ+fSBsaWdodHMgLSBBbiBhcnJheSBvZiBsaWdodHMuXHJcbiAqIEByZXR1cm4ge0xpZ2h0c05vZGV9IFRoZSBjcmVhdGVkIGxpZ2h0cyBub2RlLlxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IGxpZ2h0cyA9ICggbGlnaHRzID0gW10gKSA9PiBub2RlT2JqZWN0KCBuZXcgTGlnaHRzTm9kZSgpICkuc2V0TGlnaHRzKCBsaWdodHMgKTtcclxuIiwiaW1wb3J0IE5vZGUgZnJvbSAnLi4vY29yZS9Ob2RlLmpzJztcclxuaW1wb3J0IHsgTm9kZVVwZGF0ZVR5cGUgfSBmcm9tICcuLi9jb3JlL2NvbnN0YW50cy5qcyc7XHJcbmltcG9ydCB7IHZlYzMgfSBmcm9tICcuLi90c2wvVFNMQmFzZS5qcyc7XHJcbmltcG9ydCB7IHBvc2l0aW9uV29ybGQgfSBmcm9tICcuLi9hY2Nlc3NvcnMvUG9zaXRpb24uanMnO1xyXG5cclxuLyoqIEBtb2R1bGUgU2hhZG93QmFzZU5vZGUgKiovXHJcblxyXG4vKipcclxuICogQmFzZSBjbGFzcyBmb3IgYWxsIHNoYWRvdyBub2Rlcy5cclxuICpcclxuICogU2hhZG93IG5vZGVzIGVuY2Fwc3VsYXRlIHNoYWRvdyByZWxhdGVkIGxvZ2ljIGFuZCBhcmUgYWx3YXlzIGNvdXBsZWQgdG8gbGlnaHRpbmcgbm9kZXMuXHJcbiAqIExpZ2h0aW5nIG5vZGVzIG1pZ2h0IHNoYXJlIHRoZSBzYW1lIHNoYWRvdyBub2RlIHR5cGUgb3IgdXNlIHNwZWNpZmljIG9uZXMgZGVwZW5kaW5nIG9uXHJcbiAqIHRoZWlyIHJlcXVpcmVtZW50cy5cclxuICpcclxuICogQGF1Z21lbnRzIE5vZGVcclxuICovXHJcbmNsYXNzIFNoYWRvd0Jhc2VOb2RlIGV4dGVuZHMgTm9kZSB7XHJcblxyXG5cdHN0YXRpYyBnZXQgdHlwZSgpIHtcclxuXHJcblx0XHRyZXR1cm4gJ1NoYWRvd0Jhc2VOb2RlJztcclxuXHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBDb25zdHJ1Y3RzIGEgbmV3IHNoYWRvdyBiYXNlIG5vZGUuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge0xpZ2h0fSBsaWdodCAtIFRoZSBzaGFkb3cgY2FzdGluZyBsaWdodC5cclxuXHQgKi9cclxuXHRjb25zdHJ1Y3RvciggbGlnaHQgKSB7XHJcblxyXG5cdFx0c3VwZXIoKTtcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIFRoZSBzaGFkb3cgY2FzdGluZyBsaWdodC5cclxuXHRcdCAqXHJcblx0XHQgKiBAdHlwZSB7TGlnaHR9XHJcblx0XHQgKi9cclxuXHRcdHRoaXMubGlnaHQgPSBsaWdodDtcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIE92ZXJ3cml0dGVuIHNpbmNlIHNoYWRvd3MgYXJlIHVwZGF0ZWQgYnkgZGVmYXVsdCBwZXIgcmVuZGVyLlxyXG5cdFx0ICpcclxuXHRcdCAqIEB0eXBlIHtTdHJpbmd9XHJcblx0XHQgKiBAZGVmYXVsdCAncmVuZGVyJ1xyXG5cdFx0ICovXHJcblx0XHR0aGlzLnVwZGF0ZUJlZm9yZVR5cGUgPSBOb2RlVXBkYXRlVHlwZS5SRU5ERVI7XHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBUaGlzIGZsYWcgY2FuIGJlIHVzZWQgZm9yIHR5cGUgdGVzdGluZy5cclxuXHRcdCAqXHJcblx0XHQgKiBAdHlwZSB7Qm9vbGVhbn1cclxuXHRcdCAqIEByZWFkb25seVxyXG5cdFx0ICogQGRlZmF1bHQgdHJ1ZVxyXG5cdFx0ICovXHJcblx0XHR0aGlzLmlzU2hhZG93QmFzZU5vZGUgPSB0cnVlO1xyXG5cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFNldHVwcyB0aGUgc2hhZG93IHBvc2l0aW9uIG5vZGUgd2hpY2ggaXMgYnkgZGVmYXVsdCB0aGUgcHJlZGVmaW5lZCBUU0wgbm9kZSBvYmplY3QgYHNoYWRvd1dvcmxkUG9zaXRpb25gLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHsoTm9kZUJ1aWxkZXJ8e01hdGVyaWFsfSl9IG9iamVjdCAtIEEgY29uZmlndXJhdGlvbiBvYmplY3QgdGhhdCBtdXN0IGF0IGxlYXN0IGhvbGQgYSBtYXRlcmlhbCByZWZlcmVuY2UuXHJcblx0ICovXHJcblx0c2V0dXBTaGFkb3dQb3NpdGlvbiggeyBtYXRlcmlhbCB9ICkge1xyXG5cclxuXHRcdC8vIFVzZSBhc3NpZ24gaW5zaWRlIGFuIEZuKClcclxuXHJcblx0XHRzaGFkb3dXb3JsZFBvc2l0aW9uLmFzc2lnbiggbWF0ZXJpYWwuc2hhZG93UG9zaXRpb25Ob2RlIHx8IHBvc2l0aW9uV29ybGQgKTtcclxuXHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBDYW4gYmUgY2FsbGVkIHdoZW4gdGhlIHNoYWRvdyBpc24ndCByZXF1aXJlZCBhbnltb3JlLiBUaGF0IGNhbiBoYXBwZW4gd2hlblxyXG5cdCAqIGEgbGlnaHRpbmcgbm9kZSBzdG9wcyBjYXN0aW5nIHNoYWRvd3MgYnkgc2V0dGluZyB7QGxpbmsgT2JqZWN0M0QjY2FzdFNoYWRvd31cclxuXHQgKiB0byBgZmFsc2VgLlxyXG5cdCAqL1xyXG5cdGRpc3Bvc2UoKSB7XHJcblxyXG5cdFx0dGhpcy51cGRhdGVCZWZvcmVUeXBlID0gTm9kZVVwZGF0ZVR5cGUuTk9ORTtcclxuXHJcblx0fVxyXG5cclxufVxyXG5cclxuLyoqXHJcbiAqIFRTTCBvYmplY3QgdGhhdCByZXByZXNlbnRzIHRoZSB2ZXJ0ZXggcG9zaXRpb24gaW4gd29ybGQgc3BhY2UgZHVyaW5nIHRoZSBzaGFkb3cgcGFzcy5cclxuICpcclxuICogQHR5cGUge05vZGU8dmVjMz59XHJcbiAqL1xyXG5leHBvcnQgY29uc3Qgc2hhZG93V29ybGRQb3NpdGlvbiA9IC8qQF9fUFVSRV9fKi8gdmVjMygpLnRvVmFyKCAnc2hhZG93V29ybGRQb3NpdGlvbicgKTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IFNoYWRvd0Jhc2VOb2RlO1xyXG4iLCJpbXBvcnQgU2hhZG93QmFzZU5vZGUsIHsgc2hhZG93V29ybGRQb3NpdGlvbiB9IGZyb20gJy4vU2hhZG93QmFzZU5vZGUuanMnO1xyXG5pbXBvcnQgeyBmbG9hdCwgdmVjMiwgdmVjMywgdmVjNCwgSWYsIGludCwgRm4sIG5vZGVPYmplY3QgfSBmcm9tICcuLi90c2wvVFNMQmFzZS5qcyc7XHJcbmltcG9ydCB7IHJlZmVyZW5jZSB9IGZyb20gJy4uL2FjY2Vzc29ycy9SZWZlcmVuY2VOb2RlLmpzJztcclxuaW1wb3J0IHsgdGV4dHVyZSB9IGZyb20gJy4uL2FjY2Vzc29ycy9UZXh0dXJlTm9kZS5qcyc7XHJcbmltcG9ydCB7IHBvc2l0aW9uV29ybGQgfSBmcm9tICcuLi9hY2Nlc3NvcnMvUG9zaXRpb24uanMnO1xyXG5pbXBvcnQgeyB0cmFuc2Zvcm1lZE5vcm1hbFdvcmxkIH0gZnJvbSAnLi4vYWNjZXNzb3JzL05vcm1hbC5qcyc7XHJcbmltcG9ydCB7IG1peCwgZnJhY3QsIHN0ZXAsIG1heCwgY2xhbXAsIHNxcnQgfSBmcm9tICcuLi9tYXRoL01hdGhOb2RlLmpzJztcclxuaW1wb3J0IHsgYWRkLCBzdWIgfSBmcm9tICcuLi9tYXRoL09wZXJhdG9yTm9kZS5qcyc7XHJcbmltcG9ydCB7IERlcHRoVGV4dHVyZSB9IGZyb20gJy4uLy4uL3RleHR1cmVzL0RlcHRoVGV4dHVyZS5qcyc7XHJcbmltcG9ydCBOb2RlTWF0ZXJpYWwgZnJvbSAnLi4vLi4vbWF0ZXJpYWxzL25vZGVzL05vZGVNYXRlcmlhbC5qcyc7XHJcbmltcG9ydCBRdWFkTWVzaCBmcm9tICcuLi8uLi9yZW5kZXJlcnMvY29tbW9uL1F1YWRNZXNoLmpzJztcclxuaW1wb3J0IHsgTG9vcCB9IGZyb20gJy4uL3V0aWxzL0xvb3BOb2RlLmpzJztcclxuaW1wb3J0IHsgc2NyZWVuQ29vcmRpbmF0ZSB9IGZyb20gJy4uL2Rpc3BsYXkvU2NyZWVuTm9kZS5qcyc7XHJcbmltcG9ydCB7IEhhbGZGbG9hdFR5cGUsIExlc3NDb21wYXJlLCBSR0Zvcm1hdCwgVlNNU2hhZG93TWFwLCBXZWJHUFVDb29yZGluYXRlU3lzdGVtIH0gZnJvbSAnLi4vLi4vY29uc3RhbnRzLmpzJztcclxuaW1wb3J0IHsgcmVuZGVyR3JvdXAgfSBmcm9tICcuLi9jb3JlL1VuaWZvcm1Hcm91cE5vZGUuanMnO1xyXG5pbXBvcnQgeyB2aWV3WlRvTG9nYXJpdGhtaWNEZXB0aCB9IGZyb20gJy4uL2Rpc3BsYXkvVmlld3BvcnREZXB0aE5vZGUuanMnO1xyXG5pbXBvcnQgeyBvYmplY3RQb3NpdGlvbiB9IGZyb20gJy4uL2FjY2Vzc29ycy9PYmplY3QzRE5vZGUuanMnO1xyXG5pbXBvcnQgeyBsaWdodFNoYWRvd01hdHJpeCB9IGZyb20gJy4uL2FjY2Vzc29ycy9MaWdodHMuanMnO1xyXG5cclxuLyoqIEBtb2R1bGUgU2hhZG93Tm9kZSAqKi9cclxuXHJcbmNvbnN0IHNoYWRvd01hdGVyaWFsTGliID0gLypAX19QVVJFX18qLyBuZXcgV2Vha01hcCgpO1xyXG5jb25zdCBsaW5lYXJEaXN0YW5jZSA9IC8qQF9fUFVSRV9fKi8gRm4oICggWyBwb3NpdGlvbiwgY2FtZXJhTmVhciwgY2FtZXJhRmFyIF0gKSA9PiB7XHJcblxyXG5cdGxldCBkaXN0ID0gcG9zaXRpb25Xb3JsZC5zdWIoIHBvc2l0aW9uICkubGVuZ3RoKCk7XHJcblx0ZGlzdCA9IGRpc3Quc3ViKCBjYW1lcmFOZWFyICkuZGl2KCBjYW1lcmFGYXIuc3ViKCBjYW1lcmFOZWFyICkgKTtcclxuXHRkaXN0ID0gZGlzdC5zYXR1cmF0ZSgpOyAvLyBjbGFtcCB0byBbIDAsIDEgXVxyXG5cclxuXHRyZXR1cm4gZGlzdDtcclxuXHJcbn0gKTtcclxuXHJcbmNvbnN0IGxpbmVhclNoYWRvd0Rpc3RhbmNlID0gKCBsaWdodCApID0+IHtcclxuXHJcblx0Y29uc3QgY2FtZXJhID0gbGlnaHQuc2hhZG93LmNhbWVyYTtcclxuXHJcblx0Y29uc3QgbmVhckRpc3RhbmNlID0gcmVmZXJlbmNlKCAnbmVhcicsICdmbG9hdCcsIGNhbWVyYSApLnNldEdyb3VwKCByZW5kZXJHcm91cCApO1xyXG5cdGNvbnN0IGZhckRpc3RhbmNlID0gcmVmZXJlbmNlKCAnZmFyJywgJ2Zsb2F0JywgY2FtZXJhICkuc2V0R3JvdXAoIHJlbmRlckdyb3VwICk7XHJcblxyXG5cdGNvbnN0IHJlZmVyZW5jZVBvc2l0aW9uID0gb2JqZWN0UG9zaXRpb24oIGxpZ2h0ICk7XHJcblxyXG5cdHJldHVybiBsaW5lYXJEaXN0YW5jZSggcmVmZXJlbmNlUG9zaXRpb24sIG5lYXJEaXN0YW5jZSwgZmFyRGlzdGFuY2UgKTtcclxuXHJcbn07XHJcblxyXG5jb25zdCBnZXRTaGFkb3dNYXRlcmlhbCA9ICggbGlnaHQgKSA9PiB7XHJcblxyXG5cdGxldCBtYXRlcmlhbCA9IHNoYWRvd01hdGVyaWFsTGliLmdldCggbGlnaHQgKTtcclxuXHJcblx0aWYgKCBtYXRlcmlhbCA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdGNvbnN0IGRlcHRoTm9kZSA9IGxpZ2h0LmlzUG9pbnRMaWdodCA/IGxpbmVhclNoYWRvd0Rpc3RhbmNlKCBsaWdodCApIDogbnVsbDtcclxuXHJcblx0XHRtYXRlcmlhbCA9IG5ldyBOb2RlTWF0ZXJpYWwoKTtcclxuXHRcdG1hdGVyaWFsLmNvbG9yTm9kZSA9IHZlYzQoIDAsIDAsIDAsIDEgKTtcclxuXHRcdG1hdGVyaWFsLmRlcHRoTm9kZSA9IGRlcHRoTm9kZTtcclxuXHRcdG1hdGVyaWFsLmlzU2hhZG93Tm9kZU1hdGVyaWFsID0gdHJ1ZTsgLy8gVXNlIHRvIGF2b2lkIG90aGVyIG92ZXJyaWRlTWF0ZXJpYWwgb3ZlcnJpZGUgbWF0ZXJpYWwuY29sb3JOb2RlIHVuaW50ZW50aW9uYWxseSB3aGVuIHVzaW5nIG1hdGVyaWFsLnNoYWRvd05vZGVcclxuXHRcdG1hdGVyaWFsLm5hbWUgPSAnU2hhZG93TWF0ZXJpYWwnO1xyXG5cclxuXHRcdHNoYWRvd01hdGVyaWFsTGliLnNldCggbGlnaHQsIG1hdGVyaWFsICk7XHJcblxyXG5cdH1cclxuXHJcblx0cmV0dXJuIG1hdGVyaWFsO1xyXG5cclxufTtcclxuXHJcbi8qKlxyXG4gKiBBIHNoYWRvdyBmaWx0ZXJpbmcgZnVuY3Rpb24gcGVyZm9ybWluZyBiYXNpYyBmaWx0ZXJpbmcuIFRoaXMgaXMgaW4gZmFjdCBhbiB1bmZpbHRlcmVkIHZlcnNpb24gb2YgdGhlIHNoYWRvdyBtYXBcclxuICogd2l0aCBhIGJpbmFyeSBgWzAsMV1gIHJlc3VsdC5cclxuICpcclxuICogQG1ldGhvZFxyXG4gKiBAcGFyYW0ge09iamVjdH0gaW5wdXRzIC0gVGhlIGlucHV0IHBhcmFtZXRlciBvYmplY3QuXHJcbiAqIEBwYXJhbSB7RGVwdGhUZXh0dXJlfSBpbnB1dHMuZGVwdGhUZXh0dXJlIC0gQSByZWZlcmVuY2UgdG8gdGhlIHNoYWRvdyBtYXAncyB0ZXh0dXJlIGRhdGEuXHJcbiAqIEBwYXJhbSB7Tm9kZTx2ZWMzPn0gaW5wdXRzLnNoYWRvd0Nvb3JkIC0gVGhlIHNoYWRvdyBjb29yZGluYXRlcy5cclxuICogQHJldHVybiB7Tm9kZTxmbG9hdD59IFRoZSBmaWx0ZXJpbmcgcmVzdWx0LlxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IEJhc2ljU2hhZG93RmlsdGVyID0gLypAX19QVVJFX18qLyBGbiggKCB7IGRlcHRoVGV4dHVyZSwgc2hhZG93Q29vcmQgfSApID0+IHtcclxuXHJcblx0cmV0dXJuIHRleHR1cmUoIGRlcHRoVGV4dHVyZSwgc2hhZG93Q29vcmQueHkgKS5jb21wYXJlKCBzaGFkb3dDb29yZC56ICk7XHJcblxyXG59ICk7XHJcblxyXG4vKipcclxuICogQSBzaGFkb3cgZmlsdGVyaW5nIGZ1bmN0aW9uIHBlcmZvcm1pbmcgUENGIGZpbHRlcmluZy5cclxuICpcclxuICogQG1ldGhvZFxyXG4gKiBAcGFyYW0ge09iamVjdH0gaW5wdXRzIC0gVGhlIGlucHV0IHBhcmFtZXRlciBvYmplY3QuXHJcbiAqIEBwYXJhbSB7RGVwdGhUZXh0dXJlfSBpbnB1dHMuZGVwdGhUZXh0dXJlIC0gQSByZWZlcmVuY2UgdG8gdGhlIHNoYWRvdyBtYXAncyB0ZXh0dXJlIGRhdGEuXHJcbiAqIEBwYXJhbSB7Tm9kZTx2ZWMzPn0gaW5wdXRzLnNoYWRvd0Nvb3JkIC0gVGhlIHNoYWRvdyBjb29yZGluYXRlcy5cclxuICogQHBhcmFtIHtMaWdodFNoYWRvd30gaW5wdXRzLnNoYWRvdyAtIFRoZSBsaWdodCBzaGFkb3cuXHJcbiAqIEByZXR1cm4ge05vZGU8ZmxvYXQ+fSBUaGUgZmlsdGVyaW5nIHJlc3VsdC5cclxuICovXHJcbmV4cG9ydCBjb25zdCBQQ0ZTaGFkb3dGaWx0ZXIgPSAvKkBfX1BVUkVfXyovIEZuKCAoIHsgZGVwdGhUZXh0dXJlLCBzaGFkb3dDb29yZCwgc2hhZG93IH0gKSA9PiB7XHJcblxyXG5cdGNvbnN0IGRlcHRoQ29tcGFyZSA9ICggdXYsIGNvbXBhcmUgKSA9PiB0ZXh0dXJlKCBkZXB0aFRleHR1cmUsIHV2ICkuY29tcGFyZSggY29tcGFyZSApO1xyXG5cclxuXHRjb25zdCBtYXBTaXplID0gcmVmZXJlbmNlKCAnbWFwU2l6ZScsICd2ZWMyJywgc2hhZG93ICkuc2V0R3JvdXAoIHJlbmRlckdyb3VwICk7XHJcblx0Y29uc3QgcmFkaXVzID0gcmVmZXJlbmNlKCAncmFkaXVzJywgJ2Zsb2F0Jywgc2hhZG93ICkuc2V0R3JvdXAoIHJlbmRlckdyb3VwICk7XHJcblxyXG5cdGNvbnN0IHRleGVsU2l6ZSA9IHZlYzIoIDEgKS5kaXYoIG1hcFNpemUgKTtcclxuXHRjb25zdCBkeDAgPSB0ZXhlbFNpemUueC5uZWdhdGUoKS5tdWwoIHJhZGl1cyApO1xyXG5cdGNvbnN0IGR5MCA9IHRleGVsU2l6ZS55Lm5lZ2F0ZSgpLm11bCggcmFkaXVzICk7XHJcblx0Y29uc3QgZHgxID0gdGV4ZWxTaXplLngubXVsKCByYWRpdXMgKTtcclxuXHRjb25zdCBkeTEgPSB0ZXhlbFNpemUueS5tdWwoIHJhZGl1cyApO1xyXG5cdGNvbnN0IGR4MiA9IGR4MC5kaXYoIDIgKTtcclxuXHRjb25zdCBkeTIgPSBkeTAuZGl2KCAyICk7XHJcblx0Y29uc3QgZHgzID0gZHgxLmRpdiggMiApO1xyXG5cdGNvbnN0IGR5MyA9IGR5MS5kaXYoIDIgKTtcclxuXHJcblx0cmV0dXJuIGFkZChcclxuXHRcdGRlcHRoQ29tcGFyZSggc2hhZG93Q29vcmQueHkuYWRkKCB2ZWMyKCBkeDAsIGR5MCApICksIHNoYWRvd0Nvb3JkLnogKSxcclxuXHRcdGRlcHRoQ29tcGFyZSggc2hhZG93Q29vcmQueHkuYWRkKCB2ZWMyKCAwLCBkeTAgKSApLCBzaGFkb3dDb29yZC56ICksXHJcblx0XHRkZXB0aENvbXBhcmUoIHNoYWRvd0Nvb3JkLnh5LmFkZCggdmVjMiggZHgxLCBkeTAgKSApLCBzaGFkb3dDb29yZC56ICksXHJcblx0XHRkZXB0aENvbXBhcmUoIHNoYWRvd0Nvb3JkLnh5LmFkZCggdmVjMiggZHgyLCBkeTIgKSApLCBzaGFkb3dDb29yZC56ICksXHJcblx0XHRkZXB0aENvbXBhcmUoIHNoYWRvd0Nvb3JkLnh5LmFkZCggdmVjMiggMCwgZHkyICkgKSwgc2hhZG93Q29vcmQueiApLFxyXG5cdFx0ZGVwdGhDb21wYXJlKCBzaGFkb3dDb29yZC54eS5hZGQoIHZlYzIoIGR4MywgZHkyICkgKSwgc2hhZG93Q29vcmQueiApLFxyXG5cdFx0ZGVwdGhDb21wYXJlKCBzaGFkb3dDb29yZC54eS5hZGQoIHZlYzIoIGR4MCwgMCApICksIHNoYWRvd0Nvb3JkLnogKSxcclxuXHRcdGRlcHRoQ29tcGFyZSggc2hhZG93Q29vcmQueHkuYWRkKCB2ZWMyKCBkeDIsIDAgKSApLCBzaGFkb3dDb29yZC56ICksXHJcblx0XHRkZXB0aENvbXBhcmUoIHNoYWRvd0Nvb3JkLnh5LCBzaGFkb3dDb29yZC56ICksXHJcblx0XHRkZXB0aENvbXBhcmUoIHNoYWRvd0Nvb3JkLnh5LmFkZCggdmVjMiggZHgzLCAwICkgKSwgc2hhZG93Q29vcmQueiApLFxyXG5cdFx0ZGVwdGhDb21wYXJlKCBzaGFkb3dDb29yZC54eS5hZGQoIHZlYzIoIGR4MSwgMCApICksIHNoYWRvd0Nvb3JkLnogKSxcclxuXHRcdGRlcHRoQ29tcGFyZSggc2hhZG93Q29vcmQueHkuYWRkKCB2ZWMyKCBkeDIsIGR5MyApICksIHNoYWRvd0Nvb3JkLnogKSxcclxuXHRcdGRlcHRoQ29tcGFyZSggc2hhZG93Q29vcmQueHkuYWRkKCB2ZWMyKCAwLCBkeTMgKSApLCBzaGFkb3dDb29yZC56ICksXHJcblx0XHRkZXB0aENvbXBhcmUoIHNoYWRvd0Nvb3JkLnh5LmFkZCggdmVjMiggZHgzLCBkeTMgKSApLCBzaGFkb3dDb29yZC56ICksXHJcblx0XHRkZXB0aENvbXBhcmUoIHNoYWRvd0Nvb3JkLnh5LmFkZCggdmVjMiggZHgwLCBkeTEgKSApLCBzaGFkb3dDb29yZC56ICksXHJcblx0XHRkZXB0aENvbXBhcmUoIHNoYWRvd0Nvb3JkLnh5LmFkZCggdmVjMiggMCwgZHkxICkgKSwgc2hhZG93Q29vcmQueiApLFxyXG5cdFx0ZGVwdGhDb21wYXJlKCBzaGFkb3dDb29yZC54eS5hZGQoIHZlYzIoIGR4MSwgZHkxICkgKSwgc2hhZG93Q29vcmQueiApXHJcblx0KS5tdWwoIDEgLyAxNyApO1xyXG5cclxufSApO1xyXG5cclxuLyoqXHJcbiAqIEEgc2hhZG93IGZpbHRlcmluZyBmdW5jdGlvbiBwZXJmb3JtaW5nIFBDRiBzb2Z0IGZpbHRlcmluZy5cclxuICpcclxuICogQG1ldGhvZFxyXG4gKiBAcGFyYW0ge09iamVjdH0gaW5wdXRzIC0gVGhlIGlucHV0IHBhcmFtZXRlciBvYmplY3QuXHJcbiAqIEBwYXJhbSB7RGVwdGhUZXh0dXJlfSBpbnB1dHMuZGVwdGhUZXh0dXJlIC0gQSByZWZlcmVuY2UgdG8gdGhlIHNoYWRvdyBtYXAncyB0ZXh0dXJlIGRhdGEuXHJcbiAqIEBwYXJhbSB7Tm9kZTx2ZWMzPn0gaW5wdXRzLnNoYWRvd0Nvb3JkIC0gVGhlIHNoYWRvdyBjb29yZGluYXRlcy5cclxuICogQHBhcmFtIHtMaWdodFNoYWRvd30gaW5wdXRzLnNoYWRvdyAtIFRoZSBsaWdodCBzaGFkb3cuXHJcbiAqIEByZXR1cm4ge05vZGU8ZmxvYXQ+fSBUaGUgZmlsdGVyaW5nIHJlc3VsdC5cclxuICovXHJcbmV4cG9ydCBjb25zdCBQQ0ZTb2Z0U2hhZG93RmlsdGVyID0gLypAX19QVVJFX18qLyBGbiggKCB7IGRlcHRoVGV4dHVyZSwgc2hhZG93Q29vcmQsIHNoYWRvdyB9ICkgPT4ge1xyXG5cclxuXHRjb25zdCBkZXB0aENvbXBhcmUgPSAoIHV2LCBjb21wYXJlICkgPT4gdGV4dHVyZSggZGVwdGhUZXh0dXJlLCB1diApLmNvbXBhcmUoIGNvbXBhcmUgKTtcclxuXHJcblx0Y29uc3QgbWFwU2l6ZSA9IHJlZmVyZW5jZSggJ21hcFNpemUnLCAndmVjMicsIHNoYWRvdyApLnNldEdyb3VwKCByZW5kZXJHcm91cCApO1xyXG5cclxuXHRjb25zdCB0ZXhlbFNpemUgPSB2ZWMyKCAxICkuZGl2KCBtYXBTaXplICk7XHJcblx0Y29uc3QgZHggPSB0ZXhlbFNpemUueDtcclxuXHRjb25zdCBkeSA9IHRleGVsU2l6ZS55O1xyXG5cclxuXHRjb25zdCB1diA9IHNoYWRvd0Nvb3JkLnh5O1xyXG5cdGNvbnN0IGYgPSBmcmFjdCggdXYubXVsKCBtYXBTaXplICkuYWRkKCAwLjUgKSApO1xyXG5cdHV2LnN1YkFzc2lnbiggZi5tdWwoIHRleGVsU2l6ZSApICk7XHJcblxyXG5cdHJldHVybiBhZGQoXHJcblx0XHRkZXB0aENvbXBhcmUoIHV2LCBzaGFkb3dDb29yZC56ICksXHJcblx0XHRkZXB0aENvbXBhcmUoIHV2LmFkZCggdmVjMiggZHgsIDAgKSApLCBzaGFkb3dDb29yZC56ICksXHJcblx0XHRkZXB0aENvbXBhcmUoIHV2LmFkZCggdmVjMiggMCwgZHkgKSApLCBzaGFkb3dDb29yZC56ICksXHJcblx0XHRkZXB0aENvbXBhcmUoIHV2LmFkZCggdGV4ZWxTaXplICksIHNoYWRvd0Nvb3JkLnogKSxcclxuXHRcdG1peChcclxuXHRcdFx0ZGVwdGhDb21wYXJlKCB1di5hZGQoIHZlYzIoIGR4Lm5lZ2F0ZSgpLCAwICkgKSwgc2hhZG93Q29vcmQueiApLFxyXG5cdFx0XHRkZXB0aENvbXBhcmUoIHV2LmFkZCggdmVjMiggZHgubXVsKCAyICksIDAgKSApLCBzaGFkb3dDb29yZC56ICksXHJcblx0XHRcdGYueFxyXG5cdFx0KSxcclxuXHRcdG1peChcclxuXHRcdFx0ZGVwdGhDb21wYXJlKCB1di5hZGQoIHZlYzIoIGR4Lm5lZ2F0ZSgpLCBkeSApICksIHNoYWRvd0Nvb3JkLnogKSxcclxuXHRcdFx0ZGVwdGhDb21wYXJlKCB1di5hZGQoIHZlYzIoIGR4Lm11bCggMiApLCBkeSApICksIHNoYWRvd0Nvb3JkLnogKSxcclxuXHRcdFx0Zi54XHJcblx0XHQpLFxyXG5cdFx0bWl4KFxyXG5cdFx0XHRkZXB0aENvbXBhcmUoIHV2LmFkZCggdmVjMiggMCwgZHkubmVnYXRlKCkgKSApLCBzaGFkb3dDb29yZC56ICksXHJcblx0XHRcdGRlcHRoQ29tcGFyZSggdXYuYWRkKCB2ZWMyKCAwLCBkeS5tdWwoIDIgKSApICksIHNoYWRvd0Nvb3JkLnogKSxcclxuXHRcdFx0Zi55XHJcblx0XHQpLFxyXG5cdFx0bWl4KFxyXG5cdFx0XHRkZXB0aENvbXBhcmUoIHV2LmFkZCggdmVjMiggZHgsIGR5Lm5lZ2F0ZSgpICkgKSwgc2hhZG93Q29vcmQueiApLFxyXG5cdFx0XHRkZXB0aENvbXBhcmUoIHV2LmFkZCggdmVjMiggZHgsIGR5Lm11bCggMiApICkgKSwgc2hhZG93Q29vcmQueiApLFxyXG5cdFx0XHRmLnlcclxuXHRcdCksXHJcblx0XHRtaXgoXHJcblx0XHRcdG1peChcclxuXHRcdFx0XHRkZXB0aENvbXBhcmUoIHV2LmFkZCggdmVjMiggZHgubmVnYXRlKCksIGR5Lm5lZ2F0ZSgpICkgKSwgc2hhZG93Q29vcmQueiApLFxyXG5cdFx0XHRcdGRlcHRoQ29tcGFyZSggdXYuYWRkKCB2ZWMyKCBkeC5tdWwoIDIgKSwgZHkubmVnYXRlKCkgKSApLCBzaGFkb3dDb29yZC56ICksXHJcblx0XHRcdFx0Zi54XHJcblx0XHRcdCksXHJcblx0XHRcdG1peChcclxuXHRcdFx0XHRkZXB0aENvbXBhcmUoIHV2LmFkZCggdmVjMiggZHgubmVnYXRlKCksIGR5Lm11bCggMiApICkgKSwgc2hhZG93Q29vcmQueiApLFxyXG5cdFx0XHRcdGRlcHRoQ29tcGFyZSggdXYuYWRkKCB2ZWMyKCBkeC5tdWwoIDIgKSwgZHkubXVsKCAyICkgKSApLCBzaGFkb3dDb29yZC56ICksXHJcblx0XHRcdFx0Zi54XHJcblx0XHRcdCksXHJcblx0XHRcdGYueVxyXG5cdFx0KVxyXG5cdCkubXVsKCAxIC8gOSApO1xyXG5cclxufSApO1xyXG5cclxuLyoqXHJcbiAqIEEgc2hhZG93IGZpbHRlcmluZyBmdW5jdGlvbiBwZXJmb3JtaW5nIFZTTSBmaWx0ZXJpbmcuXHJcbiAqXHJcbiAqIEBtZXRob2RcclxuICogQHBhcmFtIHtPYmplY3R9IGlucHV0cyAtIFRoZSBpbnB1dCBwYXJhbWV0ZXIgb2JqZWN0LlxyXG4gKiBAcGFyYW0ge0RlcHRoVGV4dHVyZX0gaW5wdXRzLmRlcHRoVGV4dHVyZSAtIEEgcmVmZXJlbmNlIHRvIHRoZSBzaGFkb3cgbWFwJ3MgdGV4dHVyZSBkYXRhLlxyXG4gKiBAcGFyYW0ge05vZGU8dmVjMz59IGlucHV0cy5zaGFkb3dDb29yZCAtIFRoZSBzaGFkb3cgY29vcmRpbmF0ZXMuXHJcbiAqIEByZXR1cm4ge05vZGU8ZmxvYXQ+fSBUaGUgZmlsdGVyaW5nIHJlc3VsdC5cclxuICovXHJcbmV4cG9ydCBjb25zdCBWU01TaGFkb3dGaWx0ZXIgPSAvKkBfX1BVUkVfXyovIEZuKCAoIHsgZGVwdGhUZXh0dXJlLCBzaGFkb3dDb29yZCB9ICkgPT4ge1xyXG5cclxuXHRjb25zdCBvY2NsdXNpb24gPSBmbG9hdCggMSApLnRvVmFyKCk7XHJcblxyXG5cdGNvbnN0IGRpc3RyaWJ1dGlvbiA9IHRleHR1cmUoIGRlcHRoVGV4dHVyZSApLnNhbXBsZSggc2hhZG93Q29vcmQueHkgKS5yZztcclxuXHJcblx0Y29uc3QgaGFyZFNoYWRvdyA9IHN0ZXAoIHNoYWRvd0Nvb3JkLnosIGRpc3RyaWJ1dGlvbi54ICk7XHJcblxyXG5cdElmKCBoYXJkU2hhZG93Lm5vdEVxdWFsKCBmbG9hdCggMS4wICkgKSwgKCkgPT4ge1xyXG5cclxuXHRcdGNvbnN0IGRpc3RhbmNlID0gc2hhZG93Q29vcmQuei5zdWIoIGRpc3RyaWJ1dGlvbi54ICk7XHJcblx0XHRjb25zdCB2YXJpYW5jZSA9IG1heCggMCwgZGlzdHJpYnV0aW9uLnkubXVsKCBkaXN0cmlidXRpb24ueSApICk7XHJcblx0XHRsZXQgc29mdG5lc3NQcm9iYWJpbGl0eSA9IHZhcmlhbmNlLmRpdiggdmFyaWFuY2UuYWRkKCBkaXN0YW5jZS5tdWwoIGRpc3RhbmNlICkgKSApOyAvLyBDaGViZXlzaGV2cyBpbmVxdWFsaXR5XHJcblx0XHRzb2Z0bmVzc1Byb2JhYmlsaXR5ID0gY2xhbXAoIHN1Yiggc29mdG5lc3NQcm9iYWJpbGl0eSwgMC4zICkuZGl2KCAwLjk1IC0gMC4zICkgKTtcclxuXHRcdG9jY2x1c2lvbi5hc3NpZ24oIGNsYW1wKCBtYXgoIGhhcmRTaGFkb3csIHNvZnRuZXNzUHJvYmFiaWxpdHkgKSApICk7XHJcblxyXG5cdH0gKTtcclxuXHJcblx0cmV0dXJuIG9jY2x1c2lvbjtcclxuXHJcbn0gKTtcclxuXHJcbi8qKlxyXG4gKiBSZXByZXNlbnRzIHRoZSBzaGFkZXIgY29kZSBmb3IgdGhlIGZpcnN0IFZTTSByZW5kZXIgcGFzcy5cclxuICpcclxuICogQG1ldGhvZFxyXG4gKiBAcGFyYW0ge09iamVjdH0gaW5wdXRzIC0gVGhlIGlucHV0IHBhcmFtZXRlciBvYmplY3QuXHJcbiAqIEBwYXJhbSB7Tm9kZTxmbG9hdD59IGlucHV0cy5zYW1wbGVzIC0gVGhlIG51bWJlciBvZiBzYW1wbGVzXHJcbiAqIEBwYXJhbSB7Tm9kZTxmbG9hdD59IGlucHV0cy5yYWRpdXMgLSBUaGUgcmFkaXVzLlxyXG4gKiBAcGFyYW0ge05vZGU8ZmxvYXQ+fSBpbnB1dHMuc2l6ZSAtIFRoZSBzaXplLlxyXG4gKiBAcGFyYW0ge1RleHR1cmVOb2RlfSBpbnB1dHMuc2hhZG93UGFzcyAtIEEgcmVmZXJlbmNlIHRvIHRoZSByZW5kZXIgdGFyZ2V0J3MgZGVwdGggZGF0YS5cclxuICogQHJldHVybiB7Tm9kZTx2ZWMyPn0gVGhlIFZTTSBvdXRwdXQuXHJcbiAqL1xyXG5jb25zdCBWU01QYXNzVmVydGljYWwgPSAvKkBfX1BVUkVfXyovIEZuKCAoIHsgc2FtcGxlcywgcmFkaXVzLCBzaXplLCBzaGFkb3dQYXNzIH0gKSA9PiB7XHJcblxyXG5cdGNvbnN0IG1lYW4gPSBmbG9hdCggMCApLnRvVmFyKCk7XHJcblx0Y29uc3Qgc3F1YXJlZE1lYW4gPSBmbG9hdCggMCApLnRvVmFyKCk7XHJcblxyXG5cdGNvbnN0IHV2U3RyaWRlID0gc2FtcGxlcy5sZXNzVGhhbkVxdWFsKCBmbG9hdCggMSApICkuc2VsZWN0KCBmbG9hdCggMCApLCBmbG9hdCggMiApLmRpdiggc2FtcGxlcy5zdWIoIDEgKSApICk7XHJcblx0Y29uc3QgdXZTdGFydCA9IHNhbXBsZXMubGVzc1RoYW5FcXVhbCggZmxvYXQoIDEgKSApLnNlbGVjdCggZmxvYXQoIDAgKSwgZmxvYXQoIC0gMSApICk7XHJcblxyXG5cdExvb3AoIHsgc3RhcnQ6IGludCggMCApLCBlbmQ6IGludCggc2FtcGxlcyApLCB0eXBlOiAnaW50JywgY29uZGl0aW9uOiAnPCcgfSwgKCB7IGkgfSApID0+IHtcclxuXHJcblx0XHRjb25zdCB1dk9mZnNldCA9IHV2U3RhcnQuYWRkKCBmbG9hdCggaSApLm11bCggdXZTdHJpZGUgKSApO1xyXG5cclxuXHRcdGNvbnN0IGRlcHRoID0gc2hhZG93UGFzcy5zYW1wbGUoIGFkZCggc2NyZWVuQ29vcmRpbmF0ZS54eSwgdmVjMiggMCwgdXZPZmZzZXQgKS5tdWwoIHJhZGl1cyApICkuZGl2KCBzaXplICkgKS54O1xyXG5cdFx0bWVhbi5hZGRBc3NpZ24oIGRlcHRoICk7XHJcblx0XHRzcXVhcmVkTWVhbi5hZGRBc3NpZ24oIGRlcHRoLm11bCggZGVwdGggKSApO1xyXG5cclxuXHR9ICk7XHJcblxyXG5cdG1lYW4uZGl2QXNzaWduKCBzYW1wbGVzICk7XHJcblx0c3F1YXJlZE1lYW4uZGl2QXNzaWduKCBzYW1wbGVzICk7XHJcblxyXG5cdGNvbnN0IHN0ZF9kZXYgPSBzcXJ0KCBzcXVhcmVkTWVhbi5zdWIoIG1lYW4ubXVsKCBtZWFuICkgKSApO1xyXG5cdHJldHVybiB2ZWMyKCBtZWFuLCBzdGRfZGV2ICk7XHJcblxyXG59ICk7XHJcblxyXG4vKipcclxuICogUmVwcmVzZW50cyB0aGUgc2hhZGVyIGNvZGUgZm9yIHRoZSBzZWNvbmQgVlNNIHJlbmRlciBwYXNzLlxyXG4gKlxyXG4gKiBAbWV0aG9kXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dHMgLSBUaGUgaW5wdXQgcGFyYW1ldGVyIG9iamVjdC5cclxuICogQHBhcmFtIHtOb2RlPGZsb2F0Pn0gaW5wdXRzLnNhbXBsZXMgLSBUaGUgbnVtYmVyIG9mIHNhbXBsZXNcclxuICogQHBhcmFtIHtOb2RlPGZsb2F0Pn0gaW5wdXRzLnJhZGl1cyAtIFRoZSByYWRpdXMuXHJcbiAqIEBwYXJhbSB7Tm9kZTxmbG9hdD59IGlucHV0cy5zaXplIC0gVGhlIHNpemUuXHJcbiAqIEBwYXJhbSB7VGV4dHVyZU5vZGV9IGlucHV0cy5zaGFkb3dQYXNzIC0gVGhlIHJlc3VsdCBvZiB0aGUgZmlyc3QgVlNNIHJlbmRlciBwYXNzLlxyXG4gKiBAcmV0dXJuIHtOb2RlPHZlYzI+fSBUaGUgVlNNIG91dHB1dC5cclxuICovXHJcbmNvbnN0IFZTTVBhc3NIb3Jpem9udGFsID0gLypAX19QVVJFX18qLyBGbiggKCB7IHNhbXBsZXMsIHJhZGl1cywgc2l6ZSwgc2hhZG93UGFzcyB9ICkgPT4ge1xyXG5cclxuXHRjb25zdCBtZWFuID0gZmxvYXQoIDAgKS50b1ZhcigpO1xyXG5cdGNvbnN0IHNxdWFyZWRNZWFuID0gZmxvYXQoIDAgKS50b1ZhcigpO1xyXG5cclxuXHRjb25zdCB1dlN0cmlkZSA9IHNhbXBsZXMubGVzc1RoYW5FcXVhbCggZmxvYXQoIDEgKSApLnNlbGVjdCggZmxvYXQoIDAgKSwgZmxvYXQoIDIgKS5kaXYoIHNhbXBsZXMuc3ViKCAxICkgKSApO1xyXG5cdGNvbnN0IHV2U3RhcnQgPSBzYW1wbGVzLmxlc3NUaGFuRXF1YWwoIGZsb2F0KCAxICkgKS5zZWxlY3QoIGZsb2F0KCAwICksIGZsb2F0KCAtIDEgKSApO1xyXG5cclxuXHRMb29wKCB7IHN0YXJ0OiBpbnQoIDAgKSwgZW5kOiBpbnQoIHNhbXBsZXMgKSwgdHlwZTogJ2ludCcsIGNvbmRpdGlvbjogJzwnIH0sICggeyBpIH0gKSA9PiB7XHJcblxyXG5cdFx0Y29uc3QgdXZPZmZzZXQgPSB1dlN0YXJ0LmFkZCggZmxvYXQoIGkgKS5tdWwoIHV2U3RyaWRlICkgKTtcclxuXHJcblx0XHRjb25zdCBkaXN0cmlidXRpb24gPSBzaGFkb3dQYXNzLnNhbXBsZSggYWRkKCBzY3JlZW5Db29yZGluYXRlLnh5LCB2ZWMyKCB1dk9mZnNldCwgMCApLm11bCggcmFkaXVzICkgKS5kaXYoIHNpemUgKSApO1xyXG5cdFx0bWVhbi5hZGRBc3NpZ24oIGRpc3RyaWJ1dGlvbi54ICk7XHJcblx0XHRzcXVhcmVkTWVhbi5hZGRBc3NpZ24oIGFkZCggZGlzdHJpYnV0aW9uLnkubXVsKCBkaXN0cmlidXRpb24ueSApLCBkaXN0cmlidXRpb24ueC5tdWwoIGRpc3RyaWJ1dGlvbi54ICkgKSApO1xyXG5cclxuXHR9ICk7XHJcblxyXG5cdG1lYW4uZGl2QXNzaWduKCBzYW1wbGVzICk7XHJcblx0c3F1YXJlZE1lYW4uZGl2QXNzaWduKCBzYW1wbGVzICk7XHJcblxyXG5cdGNvbnN0IHN0ZF9kZXYgPSBzcXJ0KCBzcXVhcmVkTWVhbi5zdWIoIG1lYW4ubXVsKCBtZWFuICkgKSApO1xyXG5cdHJldHVybiB2ZWMyKCBtZWFuLCBzdGRfZGV2ICk7XHJcblxyXG59ICk7XHJcblxyXG5jb25zdCBfc2hhZG93RmlsdGVyTGliID0gWyBCYXNpY1NoYWRvd0ZpbHRlciwgUENGU2hhZG93RmlsdGVyLCBQQ0ZTb2Z0U2hhZG93RmlsdGVyLCBWU01TaGFkb3dGaWx0ZXIgXTtcclxuXHJcbi8vXHJcblxyXG5jb25zdCBfcXVhZE1lc2ggPSAvKkBfX1BVUkVfXyovIG5ldyBRdWFkTWVzaCgpO1xyXG5cclxuLyoqXHJcbiAqIFJlcHJlc2VudHMgdGhlIGRlZmF1bHQgc2hhZG93IGltcGxlbWVudGF0aW9uIGZvciBsaWdodGluZyBub2Rlcy5cclxuICpcclxuICogQGF1Z21lbnRzIG1vZHVsZTpTaGFkb3dCYXNlTm9kZX5TaGFkb3dCYXNlTm9kZVxyXG4gKi9cclxuY2xhc3MgU2hhZG93Tm9kZSBleHRlbmRzIFNoYWRvd0Jhc2VOb2RlIHtcclxuXHJcblx0c3RhdGljIGdldCB0eXBlKCkge1xyXG5cclxuXHRcdHJldHVybiAnU2hhZG93Tm9kZSc7XHJcblxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogQ29uc3RydWN0cyBhIG5ldyBzaGFkb3cgbm9kZS5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7TGlnaHR9IGxpZ2h0IC0gVGhlIHNoYWRvdyBjYXN0aW5nIGxpZ2h0LlxyXG5cdCAqIEBwYXJhbSB7TGlnaHRTaGFkb3c/fSBbc2hhZG93PW51bGxdIC0gQW4gb3B0aW9uYWwgbGlnaHQgc2hhZG93LlxyXG5cdCAqL1xyXG5cdGNvbnN0cnVjdG9yKCBsaWdodCwgc2hhZG93ID0gbnVsbCApIHtcclxuXHJcblx0XHRzdXBlciggbGlnaHQgKTtcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIFRoZSBsaWdodCBzaGFkb3cgd2hpY2ggZGVmaW5lcyB0aGUgcHJvcGVydGllcyBsaWdodCdzXHJcblx0XHQgKiBzaGFkb3cuXHJcblx0XHQgKlxyXG5cdFx0ICogQHR5cGUge0xpZ2h0U2hhZG93P31cclxuXHRcdCAqIEBkZWZhdWx0IG51bGxcclxuXHRcdCAqL1xyXG5cdFx0dGhpcy5zaGFkb3cgPSBzaGFkb3cgfHwgbGlnaHQuc2hhZG93O1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogQSByZWZlcmVuY2UgdG8gdGhlIHNoYWRvdyBtYXAgd2hpY2ggaXMgYSByZW5kZXIgdGFyZ2V0LlxyXG5cdFx0ICpcclxuXHRcdCAqIEB0eXBlIHtSZW5kZXJUYXJnZXQ/fVxyXG5cdFx0ICogQGRlZmF1bHQgbnVsbFxyXG5cdFx0ICovXHJcblx0XHR0aGlzLnNoYWRvd01hcCA9IG51bGw7XHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBPbmx5IHJlbGV2YW50IGZvciBWU00gc2hhZG93cy4gUmVuZGVyIHRhcmdldCBmb3IgdGhlXHJcblx0XHQgKiBmaXJzdCBWU00gcmVuZGVyIHBhc3MuXHJcblx0XHQgKlxyXG5cdFx0ICogQHR5cGUge1JlbmRlclRhcmdldD99XHJcblx0XHQgKiBAZGVmYXVsdCBudWxsXHJcblx0XHQgKi9cclxuXHRcdHRoaXMudnNtU2hhZG93TWFwVmVydGljYWwgPSBudWxsO1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogT25seSByZWxldmFudCBmb3IgVlNNIHNoYWRvd3MuIFJlbmRlciB0YXJnZXQgZm9yIHRoZVxyXG5cdFx0ICogc2Vjb25kIFZTTSByZW5kZXIgcGFzcy5cclxuXHRcdCAqXHJcblx0XHQgKiBAdHlwZSB7UmVuZGVyVGFyZ2V0P31cclxuXHRcdCAqIEBkZWZhdWx0IG51bGxcclxuXHRcdCAqL1xyXG5cdFx0dGhpcy52c21TaGFkb3dNYXBIb3Jpem9udGFsID0gbnVsbDtcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIE9ubHkgcmVsZXZhbnQgZm9yIFZTTSBzaGFkb3dzLiBOb2RlIG1hdGVyaWFsIHdoaWNoXHJcblx0XHQgKiBpcyB1c2VkIHRvIHJlbmRlciB0aGUgZmlyc3QgVlNNIHBhc3MuXHJcblx0XHQgKlxyXG5cdFx0ICogQHR5cGUge05vZGVNYXRlcmlhbD99XHJcblx0XHQgKiBAZGVmYXVsdCBudWxsXHJcblx0XHQgKi9cclxuXHRcdHRoaXMudnNtTWF0ZXJpYWxWZXJ0aWNhbCA9IG51bGw7XHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBPbmx5IHJlbGV2YW50IGZvciBWU00gc2hhZG93cy4gTm9kZSBtYXRlcmlhbCB3aGljaFxyXG5cdFx0ICogaXMgdXNlZCB0byByZW5kZXIgdGhlIHNlY29uZCBWU00gcGFzcy5cclxuXHRcdCAqXHJcblx0XHQgKiBAdHlwZSB7Tm9kZU1hdGVyaWFsP31cclxuXHRcdCAqIEBkZWZhdWx0IG51bGxcclxuXHRcdCAqL1xyXG5cdFx0dGhpcy52c21NYXRlcmlhbEhvcml6b250YWwgPSBudWxsO1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogQSByZWZlcmVuY2UgdG8gdGhlIG91dHB1dCBub2RlIHdoaWNoIGRlZmluZXMgdGhlXHJcblx0XHQgKiBmaW5hbCByZXN1bHQgb2YgdGhpcyBzaGFkb3cgbm9kZS5cclxuXHRcdCAqXHJcblx0XHQgKiBAdHlwZSB7Tm9kZT99XHJcblx0XHQgKiBAcHJpdmF0ZVxyXG5cdFx0ICogQGRlZmF1bHQgbnVsbFxyXG5cdFx0ICovXHJcblx0XHR0aGlzLl9ub2RlID0gbnVsbDtcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIFRoaXMgZmxhZyBjYW4gYmUgdXNlZCBmb3IgdHlwZSB0ZXN0aW5nLlxyXG5cdFx0ICpcclxuXHRcdCAqIEB0eXBlIHtCb29sZWFufVxyXG5cdFx0ICogQHJlYWRvbmx5XHJcblx0XHQgKiBAZGVmYXVsdCB0cnVlXHJcblx0XHQgKi9cclxuXHRcdHRoaXMuaXNTaGFkb3dOb2RlID0gdHJ1ZTtcclxuXHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBTZXR1cHMgdGhlIHNoYWRvdyBmaWx0ZXJpbmcuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge05vZGVCdWlsZGVyfSBidWlsZGVyIC0gQSByZWZlcmVuY2UgdG8gdGhlIGN1cnJlbnQgbm9kZSBidWlsZGVyLlxyXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dHMgLSBBIGNvbmZpZ3VyYXRpb24gb2JqZWN0IHRoYXQgZGVmaW5lcyB0aGUgc2hhZG93IGZpbHRlcmluZy5cclxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpbnB1dHMuZmlsdGVyRm4gLSBUaGlzIGZ1bmN0aW9uIGRlZmluZXMgdGhlIGZpbHRlcmluZyB0eXBlIG9mIHRoZSBzaGFkb3cgbWFwIGUuZy4gUENGLlxyXG5cdCAqIEBwYXJhbSB7RGVwdGhUZXh0dXJlfSBpbnB1dHMuZGVwdGhUZXh0dXJlIC0gQSByZWZlcmVuY2UgdG8gdGhlIHNoYWRvdyBtYXAncyB0ZXh0dXJlIGRhdGEuXHJcblx0ICogQHBhcmFtIHtOb2RlPHZlYzM+fSBpbnB1dHMuc2hhZG93Q29vcmQgLSBTaGFkb3cgY29vcmRpbmF0ZXMgd2hpY2ggYXJlIHVzZWQgdG8gc2FtcGxlIGZyb20gdGhlIHNoYWRvdyBtYXAuXHJcblx0ICogQHBhcmFtIHtMaWdodFNoYWRvd30gaW5wdXRzLnNoYWRvdyAtIFRoZSBsaWdodCBzaGFkb3cuXHJcblx0ICogQHJldHVybiB7Tm9kZTxmbG9hdD59IFRoZSByZXN1bHQgbm9kZSBvZiB0aGUgc2hhZG93IGZpbHRlcmluZy5cclxuXHQgKi9cclxuXHRzZXR1cFNoYWRvd0ZpbHRlciggYnVpbGRlciwgeyBmaWx0ZXJGbiwgZGVwdGhUZXh0dXJlLCBzaGFkb3dDb29yZCwgc2hhZG93IH0gKSB7XHJcblxyXG5cdFx0Y29uc3QgZnJ1c3R1bVRlc3QgPSBzaGFkb3dDb29yZC54LmdyZWF0ZXJUaGFuRXF1YWwoIDAgKVxyXG5cdFx0XHQuYW5kKCBzaGFkb3dDb29yZC54Lmxlc3NUaGFuRXF1YWwoIDEgKSApXHJcblx0XHRcdC5hbmQoIHNoYWRvd0Nvb3JkLnkuZ3JlYXRlclRoYW5FcXVhbCggMCApIClcclxuXHRcdFx0LmFuZCggc2hhZG93Q29vcmQueS5sZXNzVGhhbkVxdWFsKCAxICkgKVxyXG5cdFx0XHQuYW5kKCBzaGFkb3dDb29yZC56Lmxlc3NUaGFuRXF1YWwoIDEgKSApO1xyXG5cclxuXHRcdGNvbnN0IHNoYWRvd05vZGUgPSBmaWx0ZXJGbiggeyBkZXB0aFRleHR1cmUsIHNoYWRvd0Nvb3JkLCBzaGFkb3cgfSApO1xyXG5cclxuXHRcdHJldHVybiBmcnVzdHVtVGVzdC5zZWxlY3QoIHNoYWRvd05vZGUsIGZsb2F0KCAxICkgKTtcclxuXHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBTZXR1cHMgdGhlIHNoYWRvdyBjb29yZGluYXRlcy5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7Tm9kZUJ1aWxkZXJ9IGJ1aWxkZXIgLSBBIHJlZmVyZW5jZSB0byB0aGUgY3VycmVudCBub2RlIGJ1aWxkZXIuXHJcblx0ICogQHBhcmFtIHtOb2RlPHZlYzM+fSBzaGFkb3dQb3NpdGlvbiAtIEEgbm9kZSByZXByZXNlbnRpbmcgdGhlIHNoYWRvdyBwb3NpdGlvbi5cclxuXHQgKiBAcmV0dXJuIHtOb2RlPHZlYzM+fSBUaGUgc2hhZG93IGNvb3JkaW5hdGVzLlxyXG5cdCAqL1xyXG5cdHNldHVwU2hhZG93Q29vcmQoIGJ1aWxkZXIsIHNoYWRvd1Bvc2l0aW9uICkge1xyXG5cclxuXHRcdGNvbnN0IHsgc2hhZG93IH0gPSB0aGlzO1xyXG5cdFx0Y29uc3QgeyByZW5kZXJlciB9ID0gYnVpbGRlcjtcclxuXHJcblx0XHRjb25zdCBiaWFzID0gcmVmZXJlbmNlKCAnYmlhcycsICdmbG9hdCcsIHNoYWRvdyApLnNldEdyb3VwKCByZW5kZXJHcm91cCApO1xyXG5cclxuXHRcdGxldCBzaGFkb3dDb29yZCA9IHNoYWRvd1Bvc2l0aW9uO1xyXG5cdFx0bGV0IGNvb3JkWjtcclxuXHJcblx0XHRpZiAoIHNoYWRvdy5jYW1lcmEuaXNPcnRob2dyYXBoaWNDYW1lcmEgfHwgcmVuZGVyZXIubG9nYXJpdGhtaWNEZXB0aEJ1ZmZlciAhPT0gdHJ1ZSApIHtcclxuXHJcblx0XHRcdHNoYWRvd0Nvb3JkID0gc2hhZG93Q29vcmQueHl6LmRpdiggc2hhZG93Q29vcmQudyApO1xyXG5cclxuXHRcdFx0Y29vcmRaID0gc2hhZG93Q29vcmQuejtcclxuXHJcblx0XHRcdGlmICggcmVuZGVyZXIuY29vcmRpbmF0ZVN5c3RlbSA9PT0gV2ViR1BVQ29vcmRpbmF0ZVN5c3RlbSApIHtcclxuXHJcblx0XHRcdFx0Y29vcmRaID0gY29vcmRaLm11bCggMiApLnN1YiggMSApOyAvLyBXZWJHUFU6IENvbnZlcnNpb24gWyAwLCAxIF0gdG8gWyAtIDEsIDEgXVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRjb25zdCB3ID0gc2hhZG93Q29vcmQudztcclxuXHRcdFx0c2hhZG93Q29vcmQgPSBzaGFkb3dDb29yZC54eS5kaXYoIHcgKTsgLy8gPC0tIE9ubHkgZGl2aWRlIFgvWSBjb29yZHMgc2luY2Ugd2UgZG9uJ3QgbmVlZCBaXHJcblxyXG5cdFx0XHQvLyBUaGUgbm9ybWFsbHkgYXZhaWxhYmxlIFwiY2FtZXJhTmVhclwiIGFuZCBcImNhbWVyYUZhclwiIG5vZGVzIGNhbm5vdCBiZSB1c2VkIGhlcmUgYmVjYXVzZSB0aGV5IGRvIG5vdCBnZXRcclxuXHRcdFx0Ly8gdXBkYXRlZCB0byB1c2UgdGhlIHNoYWRvdyBjYW1lcmEuIFNvLCB3ZSBoYXZlIHRvIGRlY2xhcmUgb3VyIG93biBcImxvY2FsXCIgb25lcyBoZXJlLlxyXG5cdFx0XHQvLyBUT0RPOiBIb3cgZG8gd2UgZ2V0IHRoZSBjYW1lcmFOZWFyL2NhbWVyYUZhciBub2RlcyB0byB1c2UgdGhlIHNoYWRvdyBjYW1lcmEgc28gd2UgZG9uJ3QgaGF2ZSB0byBkZWNsYXJlIGxvY2FsIG9uZXMgaGVyZT9cclxuXHRcdFx0Y29uc3QgY2FtZXJhTmVhckxvY2FsID0gcmVmZXJlbmNlKCAnbmVhcicsICdmbG9hdCcsIHNoYWRvdy5jYW1lcmEgKS5zZXRHcm91cCggcmVuZGVyR3JvdXAgKTtcclxuXHRcdFx0Y29uc3QgY2FtZXJhRmFyTG9jYWwgPSByZWZlcmVuY2UoICdmYXInLCAnZmxvYXQnLCBzaGFkb3cuY2FtZXJhICkuc2V0R3JvdXAoIHJlbmRlckdyb3VwICk7XHJcblxyXG5cdFx0XHRjb29yZFogPSB2aWV3WlRvTG9nYXJpdGhtaWNEZXB0aCggdy5uZWdhdGUoKSwgY2FtZXJhTmVhckxvY2FsLCBjYW1lcmFGYXJMb2NhbCApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRzaGFkb3dDb29yZCA9IHZlYzMoXHJcblx0XHRcdHNoYWRvd0Nvb3JkLngsXHJcblx0XHRcdHNoYWRvd0Nvb3JkLnkub25lTWludXMoKSwgLy8gZm9sbG93IHdlYmdwdSBzdGFuZGFyZHNcclxuXHRcdFx0Y29vcmRaLmFkZCggYmlhcyApXHJcblx0XHQpO1xyXG5cclxuXHRcdHJldHVybiBzaGFkb3dDb29yZDtcclxuXHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBSZXR1cm5zIHRoZSBzaGFkb3cgZmlsdGVyaW5nIGZ1bmN0aW9uIGZvciB0aGUgZ2l2ZW4gc2hhZG93IHR5cGUuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge051bWJlcn0gdHlwZSAtIFRoZSBzaGFkb3cgdHlwZS5cclxuXHQgKiBAcmV0dXJuIHtGdW5jdGlvbn0gVGhlIGZpbHRlcmluZyBmdW5jdGlvbi5cclxuXHQgKi9cclxuXHRnZXRTaGFkb3dGaWx0ZXJGbiggdHlwZSApIHtcclxuXHJcblx0XHRyZXR1cm4gX3NoYWRvd0ZpbHRlckxpYlsgdHlwZSBdO1xyXG5cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFNldHVwcyB0aGUgc2hhZG93IG91dHB1dCBub2RlLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtOb2RlQnVpbGRlcn0gYnVpbGRlciAtIEEgcmVmZXJlbmNlIHRvIHRoZSBjdXJyZW50IG5vZGUgYnVpbGRlci5cclxuXHQgKiBAcmV0dXJuIHtOb2RlPHZlYzM+fSBUaGUgc2hhZG93IG91dHB1dCBub2RlLlxyXG5cdCAqL1xyXG5cdHNldHVwU2hhZG93KCBidWlsZGVyICkge1xyXG5cclxuXHRcdGNvbnN0IHsgcmVuZGVyZXIgfSA9IGJ1aWxkZXI7XHJcblxyXG5cdFx0Y29uc3QgeyBsaWdodCwgc2hhZG93IH0gPSB0aGlzO1xyXG5cclxuXHRcdGNvbnN0IHNoYWRvd01hcFR5cGUgPSByZW5kZXJlci5zaGFkb3dNYXAudHlwZTtcclxuXHJcblx0XHRjb25zdCBkZXB0aFRleHR1cmUgPSBuZXcgRGVwdGhUZXh0dXJlKCBzaGFkb3cubWFwU2l6ZS53aWR0aCwgc2hhZG93Lm1hcFNpemUuaGVpZ2h0ICk7XHJcblx0XHRkZXB0aFRleHR1cmUuY29tcGFyZUZ1bmN0aW9uID0gTGVzc0NvbXBhcmU7XHJcblxyXG5cdFx0Y29uc3Qgc2hhZG93TWFwID0gYnVpbGRlci5jcmVhdGVSZW5kZXJUYXJnZXQoIHNoYWRvdy5tYXBTaXplLndpZHRoLCBzaGFkb3cubWFwU2l6ZS5oZWlnaHQgKTtcclxuXHRcdHNoYWRvd01hcC5kZXB0aFRleHR1cmUgPSBkZXB0aFRleHR1cmU7XHJcblxyXG5cdFx0c2hhZG93LmNhbWVyYS51cGRhdGVQcm9qZWN0aW9uTWF0cml4KCk7XHJcblxyXG5cdFx0Ly8gVlNNXHJcblxyXG5cdFx0aWYgKCBzaGFkb3dNYXBUeXBlID09PSBWU01TaGFkb3dNYXAgKSB7XHJcblxyXG5cdFx0XHRkZXB0aFRleHR1cmUuY29tcGFyZUZ1bmN0aW9uID0gbnVsbDsgLy8gVlNNIGRvZXMgbm90IHVzZSB0ZXh0dXJlU2FtcGxlQ29tcGFyZSgpL3RleHR1cmUyRENvbXBhcmUoKVxyXG5cclxuXHRcdFx0dGhpcy52c21TaGFkb3dNYXBWZXJ0aWNhbCA9IGJ1aWxkZXIuY3JlYXRlUmVuZGVyVGFyZ2V0KCBzaGFkb3cubWFwU2l6ZS53aWR0aCwgc2hhZG93Lm1hcFNpemUuaGVpZ2h0LCB7IGZvcm1hdDogUkdGb3JtYXQsIHR5cGU6IEhhbGZGbG9hdFR5cGUgfSApO1xyXG5cdFx0XHR0aGlzLnZzbVNoYWRvd01hcEhvcml6b250YWwgPSBidWlsZGVyLmNyZWF0ZVJlbmRlclRhcmdldCggc2hhZG93Lm1hcFNpemUud2lkdGgsIHNoYWRvdy5tYXBTaXplLmhlaWdodCwgeyBmb3JtYXQ6IFJHRm9ybWF0LCB0eXBlOiBIYWxmRmxvYXRUeXBlIH0gKTtcclxuXHJcblx0XHRcdGNvbnN0IHNoYWRvd1Bhc3NWZXJ0aWNhbCA9IHRleHR1cmUoIGRlcHRoVGV4dHVyZSApO1xyXG5cdFx0XHRjb25zdCBzaGFkb3dQYXNzSG9yaXpvbnRhbCA9IHRleHR1cmUoIHRoaXMudnNtU2hhZG93TWFwVmVydGljYWwudGV4dHVyZSApO1xyXG5cclxuXHRcdFx0Y29uc3Qgc2FtcGxlcyA9IHJlZmVyZW5jZSggJ2JsdXJTYW1wbGVzJywgJ2Zsb2F0Jywgc2hhZG93ICkuc2V0R3JvdXAoIHJlbmRlckdyb3VwICk7XHJcblx0XHRcdGNvbnN0IHJhZGl1cyA9IHJlZmVyZW5jZSggJ3JhZGl1cycsICdmbG9hdCcsIHNoYWRvdyApLnNldEdyb3VwKCByZW5kZXJHcm91cCApO1xyXG5cdFx0XHRjb25zdCBzaXplID0gcmVmZXJlbmNlKCAnbWFwU2l6ZScsICd2ZWMyJywgc2hhZG93ICkuc2V0R3JvdXAoIHJlbmRlckdyb3VwICk7XHJcblxyXG5cdFx0XHRsZXQgbWF0ZXJpYWwgPSB0aGlzLnZzbU1hdGVyaWFsVmVydGljYWwgfHwgKCB0aGlzLnZzbU1hdGVyaWFsVmVydGljYWwgPSBuZXcgTm9kZU1hdGVyaWFsKCkgKTtcclxuXHRcdFx0bWF0ZXJpYWwuZnJhZ21lbnROb2RlID0gVlNNUGFzc1ZlcnRpY2FsKCB7IHNhbXBsZXMsIHJhZGl1cywgc2l6ZSwgc2hhZG93UGFzczogc2hhZG93UGFzc1ZlcnRpY2FsIH0gKS5jb250ZXh0KCBidWlsZGVyLmdldFNoYXJlZENvbnRleHQoKSApO1xyXG5cdFx0XHRtYXRlcmlhbC5uYW1lID0gJ1ZTTVZlcnRpY2FsJztcclxuXHJcblx0XHRcdG1hdGVyaWFsID0gdGhpcy52c21NYXRlcmlhbEhvcml6b250YWwgfHwgKCB0aGlzLnZzbU1hdGVyaWFsSG9yaXpvbnRhbCA9IG5ldyBOb2RlTWF0ZXJpYWwoKSApO1xyXG5cdFx0XHRtYXRlcmlhbC5mcmFnbWVudE5vZGUgPSBWU01QYXNzSG9yaXpvbnRhbCggeyBzYW1wbGVzLCByYWRpdXMsIHNpemUsIHNoYWRvd1Bhc3M6IHNoYWRvd1Bhc3NIb3Jpem9udGFsIH0gKS5jb250ZXh0KCBidWlsZGVyLmdldFNoYXJlZENvbnRleHQoKSApO1xyXG5cdFx0XHRtYXRlcmlhbC5uYW1lID0gJ1ZTTUhvcml6b250YWwnO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvL1xyXG5cclxuXHRcdGNvbnN0IHNoYWRvd0ludGVuc2l0eSA9IHJlZmVyZW5jZSggJ2ludGVuc2l0eScsICdmbG9hdCcsIHNoYWRvdyApLnNldEdyb3VwKCByZW5kZXJHcm91cCApO1xyXG5cdFx0Y29uc3Qgbm9ybWFsQmlhcyA9IHJlZmVyZW5jZSggJ25vcm1hbEJpYXMnLCAnZmxvYXQnLCBzaGFkb3cgKS5zZXRHcm91cCggcmVuZGVyR3JvdXAgKTtcclxuXHJcblx0XHRjb25zdCBzaGFkb3dQb3NpdGlvbiA9IGxpZ2h0U2hhZG93TWF0cml4KCBsaWdodCApLm11bCggc2hhZG93V29ybGRQb3NpdGlvbi5hZGQoIHRyYW5zZm9ybWVkTm9ybWFsV29ybGQubXVsKCBub3JtYWxCaWFzICkgKSApO1xyXG5cdFx0Y29uc3Qgc2hhZG93Q29vcmQgPSB0aGlzLnNldHVwU2hhZG93Q29vcmQoIGJ1aWxkZXIsIHNoYWRvd1Bvc2l0aW9uICk7XHJcblxyXG5cdFx0Ly9cclxuXHJcblx0XHRjb25zdCBmaWx0ZXJGbiA9IHNoYWRvdy5maWx0ZXJOb2RlIHx8IHRoaXMuZ2V0U2hhZG93RmlsdGVyRm4oIHJlbmRlcmVyLnNoYWRvd01hcC50eXBlICkgfHwgbnVsbDtcclxuXHJcblx0XHRpZiAoIGZpbHRlckZuID09PSBudWxsICkge1xyXG5cclxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCAnVEhSRUUuV2ViR1BVUmVuZGVyZXI6IFNoYWRvdyBtYXAgdHlwZSBub3Qgc3VwcG9ydGVkIHlldC4nICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGNvbnN0IHNoYWRvd0RlcHRoVGV4dHVyZSA9ICggc2hhZG93TWFwVHlwZSA9PT0gVlNNU2hhZG93TWFwICkgPyB0aGlzLnZzbVNoYWRvd01hcEhvcml6b250YWwudGV4dHVyZSA6IGRlcHRoVGV4dHVyZTtcclxuXHJcblx0XHRjb25zdCBzaGFkb3dOb2RlID0gdGhpcy5zZXR1cFNoYWRvd0ZpbHRlciggYnVpbGRlciwgeyBmaWx0ZXJGbiwgc2hhZG93VGV4dHVyZTogc2hhZG93TWFwLnRleHR1cmUsIGRlcHRoVGV4dHVyZTogc2hhZG93RGVwdGhUZXh0dXJlLCBzaGFkb3dDb29yZCwgc2hhZG93IH0gKTtcclxuXHJcblx0XHRjb25zdCBzaGFkb3dDb2xvciA9IHRleHR1cmUoIHNoYWRvd01hcC50ZXh0dXJlLCBzaGFkb3dDb29yZCApO1xyXG5cdFx0Y29uc3Qgc2hhZG93T3V0cHV0ID0gbWl4KCAxLCBzaGFkb3dOb2RlLnJnYi5taXgoIHNoYWRvd0NvbG9yLCAxICksIHNoYWRvd0ludGVuc2l0eS5tdWwoIHNoYWRvd0NvbG9yLmEgKSApLnRvVmFyKCk7XHJcblxyXG5cdFx0dGhpcy5zaGFkb3dNYXAgPSBzaGFkb3dNYXA7XHJcblx0XHR0aGlzLnNoYWRvdy5tYXAgPSBzaGFkb3dNYXA7XHJcblxyXG5cdFx0cmV0dXJuIHNoYWRvd091dHB1dDtcclxuXHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBUaGUgaW1wbGVtZW50YXRpb24gcGVyZm9ybXMgdGhlIHNldHVwIG9mIHRoZSBvdXRwdXQgbm9kZS4gQW4gb3V0cHV0IGlzIG9ubHlcclxuXHQgKiBwcm9kdWNlcyBpZiBzaGFkb3cgbWFwcGluZyBpcyBnbG9iYWxseSBlbmFibGVkIGluIHRoZSByZW5kZXJlci5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7Tm9kZUJ1aWxkZXJ9IGJ1aWxkZXIgLSBBIHJlZmVyZW5jZSB0byB0aGUgY3VycmVudCBub2RlIGJ1aWxkZXIuXHJcblx0ICogQHJldHVybiB7U2hhZGVyQ2FsbE5vZGVJbnRlcm5hbH0gVGhlIG91dHB1dCBub2RlLlxyXG5cdCAqL1xyXG5cdHNldHVwKCBidWlsZGVyICkge1xyXG5cclxuXHRcdGlmICggYnVpbGRlci5yZW5kZXJlci5zaGFkb3dNYXAuZW5hYmxlZCA9PT0gZmFsc2UgKSByZXR1cm47XHJcblxyXG5cdFx0cmV0dXJuIEZuKCAoKSA9PiB7XHJcblxyXG5cdFx0XHRsZXQgbm9kZSA9IHRoaXMuX25vZGU7XHJcblxyXG5cdFx0XHR0aGlzLnNldHVwU2hhZG93UG9zaXRpb24oIGJ1aWxkZXIgKTtcclxuXHJcblx0XHRcdGlmICggbm9kZSA9PT0gbnVsbCApIHtcclxuXHJcblx0XHRcdFx0dGhpcy5fbm9kZSA9IG5vZGUgPSB0aGlzLnNldHVwU2hhZG93KCBidWlsZGVyICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoIGJ1aWxkZXIubWF0ZXJpYWwuc2hhZG93Tm9kZSApIHsgLy8gQGRlcHJlY2F0ZWQsIHIxNzFcclxuXHJcblx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuTm9kZU1hdGVyaWFsOiBcIi5zaGFkb3dOb2RlXCIgaXMgZGVwcmVjYXRlZC4gVXNlIFwiLmNhc3RTaGFkb3dOb2RlXCIgaW5zdGVhZC4nICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoIGJ1aWxkZXIubWF0ZXJpYWwucmVjZWl2ZWRTaGFkb3dOb2RlICkge1xyXG5cclxuXHRcdFx0XHRub2RlID0gYnVpbGRlci5tYXRlcmlhbC5yZWNlaXZlZFNoYWRvd05vZGUoIG5vZGUgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHJldHVybiBub2RlO1xyXG5cclxuXHRcdH0gKSgpO1xyXG5cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFJlbmRlcnMgdGhlIHNoYWRvdy4gVGhlIGxvZ2ljIG9mIHRoaXMgZnVuY3Rpb24gY291bGQgYmUgaW5jbHVkZWRcclxuXHQgKiBpbnRvIHtAbGluayBTaGFkb3dOb2RlI3VwZGF0ZVNoYWRvd30gaG93ZXZlciBtb3JlIHNwZWNpYWxpemVkIHNoYWRvd1xyXG5cdCAqIG5vZGVzIG1pZ2h0IHJlcXVpcmUgYSBjdXN0b20gc2hhZG93IG1hcCByZW5kZXJpbmcuIEJ5IGhhdmluZyBhXHJcblx0ICogZGVkaWNhdGVkIG1ldGhvZCwgaXQncyBlYXNpZXIgdG8gb3ZlcndyaXRlIHRoZSBkZWZhdWx0IGJlaGF2aW9yLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtOb2RlRnJhbWV9IGZyYW1lIC0gQSByZWZlcmVuY2UgdG8gdGhlIGN1cnJlbnQgbm9kZSBmcmFtZS5cclxuXHQgKi9cclxuXHRyZW5kZXJTaGFkb3coIGZyYW1lICkge1xyXG5cclxuXHRcdGNvbnN0IHsgc2hhZG93LCBzaGFkb3dNYXAsIGxpZ2h0IH0gPSB0aGlzO1xyXG5cdFx0Y29uc3QgeyByZW5kZXJlciwgc2NlbmUgfSA9IGZyYW1lO1xyXG5cclxuXHRcdHNoYWRvdy51cGRhdGVNYXRyaWNlcyggbGlnaHQgKTtcclxuXHJcblx0XHRzaGFkb3dNYXAuc2V0U2l6ZSggc2hhZG93Lm1hcFNpemUud2lkdGgsIHNoYWRvdy5tYXBTaXplLmhlaWdodCApO1xyXG5cclxuXHRcdHJlbmRlcmVyLnJlbmRlciggc2NlbmUsIHNoYWRvdy5jYW1lcmEgKTtcclxuXHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBVcGRhdGVzIHRoZSBzaGFkb3cuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge05vZGVGcm1lfSBmcmFtZSAtIEEgcmVmZXJlbmNlIHRvIHRoZSBjdXJyZW50IG5vZGUgZnJhbWUuXHJcblx0ICovXHJcblx0dXBkYXRlU2hhZG93KCBmcmFtZSApIHtcclxuXHJcblx0XHRjb25zdCB7IHNoYWRvd01hcCwgbGlnaHQsIHNoYWRvdyB9ID0gdGhpcztcclxuXHRcdGNvbnN0IHsgcmVuZGVyZXIsIHNjZW5lLCBjYW1lcmEgfSA9IGZyYW1lO1xyXG5cclxuXHRcdGNvbnN0IHNoYWRvd1R5cGUgPSByZW5kZXJlci5zaGFkb3dNYXAudHlwZTtcclxuXHJcblx0XHRjb25zdCBkZXB0aFZlcnNpb24gPSBzaGFkb3dNYXAuZGVwdGhUZXh0dXJlLnZlcnNpb247XHJcblx0XHR0aGlzLl9kZXB0aFZlcnNpb25DYWNoZWQgPSBkZXB0aFZlcnNpb247XHJcblxyXG5cdFx0Y29uc3QgY3VycmVudE92ZXJyaWRlTWF0ZXJpYWwgPSBzY2VuZS5vdmVycmlkZU1hdGVyaWFsO1xyXG5cclxuXHRcdHNjZW5lLm92ZXJyaWRlTWF0ZXJpYWwgPSBnZXRTaGFkb3dNYXRlcmlhbCggbGlnaHQgKTtcclxuXHJcblx0XHRzaGFkb3cuY2FtZXJhLmxheWVycy5tYXNrID0gY2FtZXJhLmxheWVycy5tYXNrO1xyXG5cclxuXHRcdGNvbnN0IGN1cnJlbnRSZW5kZXJUYXJnZXQgPSByZW5kZXJlci5nZXRSZW5kZXJUYXJnZXQoKTtcclxuXHRcdGNvbnN0IGN1cnJlbnRSZW5kZXJPYmplY3RGdW5jdGlvbiA9IHJlbmRlcmVyLmdldFJlbmRlck9iamVjdEZ1bmN0aW9uKCk7XHJcblx0XHRjb25zdCBjdXJyZW50TVJUID0gcmVuZGVyZXIuZ2V0TVJUKCk7XHJcblxyXG5cdFx0cmVuZGVyZXIuc2V0TVJUKCBudWxsICk7XHJcblxyXG5cdFx0cmVuZGVyZXIuc2V0UmVuZGVyT2JqZWN0RnVuY3Rpb24oICggb2JqZWN0LCBzY2VuZSwgX2NhbWVyYSwgZ2VvbWV0cnksIG1hdGVyaWFsLCBncm91cCwgLi4ucGFyYW1zICkgPT4ge1xyXG5cclxuXHRcdFx0aWYgKCBvYmplY3QuY2FzdFNoYWRvdyA9PT0gdHJ1ZSB8fCAoIG9iamVjdC5yZWNlaXZlU2hhZG93ICYmIHNoYWRvd1R5cGUgPT09IFZTTVNoYWRvd01hcCApICkge1xyXG5cclxuXHRcdFx0XHRvYmplY3Qub25CZWZvcmVTaGFkb3coIHJlbmRlcmVyLCBvYmplY3QsIGNhbWVyYSwgc2hhZG93LmNhbWVyYSwgZ2VvbWV0cnksIHNjZW5lLm92ZXJyaWRlTWF0ZXJpYWwsIGdyb3VwICk7XHJcblxyXG5cdFx0XHRcdHJlbmRlcmVyLnJlbmRlck9iamVjdCggb2JqZWN0LCBzY2VuZSwgX2NhbWVyYSwgZ2VvbWV0cnksIG1hdGVyaWFsLCBncm91cCwgLi4ucGFyYW1zICk7XHJcblxyXG5cdFx0XHRcdG9iamVjdC5vbkFmdGVyU2hhZG93KCByZW5kZXJlciwgb2JqZWN0LCBjYW1lcmEsIHNoYWRvdy5jYW1lcmEsIGdlb21ldHJ5LCBzY2VuZS5vdmVycmlkZU1hdGVyaWFsLCBncm91cCApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH0gKTtcclxuXHJcblx0XHRyZW5kZXJlci5zZXRSZW5kZXJUYXJnZXQoIHNoYWRvd01hcCApO1xyXG5cclxuXHRcdHRoaXMucmVuZGVyU2hhZG93KCBmcmFtZSApO1xyXG5cclxuXHRcdHJlbmRlcmVyLnNldFJlbmRlck9iamVjdEZ1bmN0aW9uKCBjdXJyZW50UmVuZGVyT2JqZWN0RnVuY3Rpb24gKTtcclxuXHJcblx0XHQvLyB2c20gYmx1ciBwYXNzXHJcblxyXG5cdFx0aWYgKCBsaWdodC5pc1BvaW50TGlnaHQgIT09IHRydWUgJiYgc2hhZG93VHlwZSA9PT0gVlNNU2hhZG93TWFwICkge1xyXG5cclxuXHRcdFx0dGhpcy52c21QYXNzKCByZW5kZXJlciApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZW5kZXJlci5zZXRSZW5kZXJUYXJnZXQoIGN1cnJlbnRSZW5kZXJUYXJnZXQgKTtcclxuXHJcblx0XHRyZW5kZXJlci5zZXRNUlQoIGN1cnJlbnRNUlQgKTtcclxuXHJcblx0XHRzY2VuZS5vdmVycmlkZU1hdGVyaWFsID0gY3VycmVudE92ZXJyaWRlTWF0ZXJpYWw7XHJcblxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogRm9yIFZTTSBhZGRpdGlvbmFsIHJlbmRlciBwYXNzZXMgYXJlIHJlcXVpcmVkLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtSZW5kZXJlcn0gcmVuZGVyZXIgLSBBIHJlZmVyZW5jZSB0byB0aGUgY3VycmVudCByZW5kZXJlci5cclxuXHQgKi9cclxuXHR2c21QYXNzKCByZW5kZXJlciApIHtcclxuXHJcblx0XHRjb25zdCB7IHNoYWRvdyB9ID0gdGhpcztcclxuXHJcblx0XHR0aGlzLnZzbVNoYWRvd01hcFZlcnRpY2FsLnNldFNpemUoIHNoYWRvdy5tYXBTaXplLndpZHRoLCBzaGFkb3cubWFwU2l6ZS5oZWlnaHQgKTtcclxuXHRcdHRoaXMudnNtU2hhZG93TWFwSG9yaXpvbnRhbC5zZXRTaXplKCBzaGFkb3cubWFwU2l6ZS53aWR0aCwgc2hhZG93Lm1hcFNpemUuaGVpZ2h0ICk7XHJcblxyXG5cdFx0cmVuZGVyZXIuc2V0UmVuZGVyVGFyZ2V0KCB0aGlzLnZzbVNoYWRvd01hcFZlcnRpY2FsICk7XHJcblx0XHRfcXVhZE1lc2gubWF0ZXJpYWwgPSB0aGlzLnZzbU1hdGVyaWFsVmVydGljYWw7XHJcblx0XHRfcXVhZE1lc2gucmVuZGVyKCByZW5kZXJlciApO1xyXG5cclxuXHRcdHJlbmRlcmVyLnNldFJlbmRlclRhcmdldCggdGhpcy52c21TaGFkb3dNYXBIb3Jpem9udGFsICk7XHJcblx0XHRfcXVhZE1lc2gubWF0ZXJpYWwgPSB0aGlzLnZzbU1hdGVyaWFsSG9yaXpvbnRhbDtcclxuXHRcdF9xdWFkTWVzaC5yZW5kZXIoIHJlbmRlcmVyICk7XHJcblxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogRnJlZXMgdGhlIGludGVybmFsIHJlc291cmNlcyBvZiB0aGlzIHNoYWRvdyBub2RlLlxyXG5cdCAqL1xyXG5cdGRpc3Bvc2UoKSB7XHJcblxyXG5cdFx0dGhpcy5zaGFkb3dNYXAuZGlzcG9zZSgpO1xyXG5cdFx0dGhpcy5zaGFkb3dNYXAgPSBudWxsO1xyXG5cclxuXHRcdGlmICggdGhpcy52c21TaGFkb3dNYXBWZXJ0aWNhbCAhPT0gbnVsbCApIHtcclxuXHJcblx0XHRcdHRoaXMudnNtU2hhZG93TWFwVmVydGljYWwuZGlzcG9zZSgpO1xyXG5cdFx0XHR0aGlzLnZzbVNoYWRvd01hcFZlcnRpY2FsID0gbnVsbDtcclxuXHJcblx0XHRcdHRoaXMudnNtTWF0ZXJpYWxWZXJ0aWNhbC5kaXNwb3NlKCk7XHJcblx0XHRcdHRoaXMudnNtTWF0ZXJpYWxWZXJ0aWNhbCA9IG51bGw7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggdGhpcy52c21TaGFkb3dNYXBIb3Jpem9udGFsICE9PSBudWxsICkge1xyXG5cclxuXHRcdFx0dGhpcy52c21TaGFkb3dNYXBIb3Jpem9udGFsLmRpc3Bvc2UoKTtcclxuXHRcdFx0dGhpcy52c21TaGFkb3dNYXBIb3Jpem9udGFsID0gbnVsbDtcclxuXHJcblx0XHRcdHRoaXMudnNtTWF0ZXJpYWxIb3Jpem9udGFsLmRpc3Bvc2UoKTtcclxuXHRcdFx0dGhpcy52c21NYXRlcmlhbEhvcml6b250YWwgPSBudWxsO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRzdXBlci5kaXNwb3NlKCk7XHJcblxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogVGhlIGltcGxlbWVudGF0aW9uIHBlcmZvcm1zIHRoZSB1cGRhdGUgb2YgdGhlIHNoYWRvdyBtYXAgaWYgbmVjZXNzYXJ5LlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtOb2RlRnJhbWV9IGZyYW1lIC0gQSByZWZlcmVuY2UgdG8gdGhlIGN1cnJlbnQgbm9kZSBmcmFtZS5cclxuXHQgKi9cclxuXHR1cGRhdGVCZWZvcmUoIGZyYW1lICkge1xyXG5cclxuXHRcdGNvbnN0IHsgc2hhZG93IH0gPSB0aGlzO1xyXG5cclxuXHRcdGNvbnN0IG5lZWRzVXBkYXRlID0gc2hhZG93Lm5lZWRzVXBkYXRlIHx8IHNoYWRvdy5hdXRvVXBkYXRlO1xyXG5cclxuXHRcdGlmICggbmVlZHNVcGRhdGUgKSB7XHJcblxyXG5cdFx0XHR0aGlzLnVwZGF0ZVNoYWRvdyggZnJhbWUgKTtcclxuXHJcblx0XHRcdGlmICggdGhpcy5zaGFkb3dNYXAuZGVwdGhUZXh0dXJlLnZlcnNpb24gPT09IHRoaXMuX2RlcHRoVmVyc2lvbkNhY2hlZCApIHtcclxuXHJcblx0XHRcdFx0c2hhZG93Lm5lZWRzVXBkYXRlID0gZmFsc2U7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBTaGFkb3dOb2RlO1xyXG5cclxuLyoqXHJcbiAqIFRTTCBmdW5jdGlvbiBmb3IgY3JlYXRpbmcgYW4gaW5zdGFuY2Ugb2YgYFNoYWRvd05vZGVgLlxyXG4gKlxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHtMaWdodH0gbGlnaHQgLSBUaGUgc2hhZG93IGNhc3RpbmcgbGlnaHQuXHJcbiAqIEBwYXJhbSB7TGlnaHRTaGFkb3d9IHNoYWRvdyAtIFRoZSBsaWdodCBzaGFkb3cuXHJcbiAqIEByZXR1cm4ge1NoYWRvd05vZGV9IFRoZSBjcmVhdGVkIHNoYWRvdyBub2RlLlxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IHNoYWRvdyA9ICggbGlnaHQsIHNoYWRvdyApID0+IG5vZGVPYmplY3QoIG5ldyBTaGFkb3dOb2RlKCBsaWdodCwgc2hhZG93ICkgKTtcclxuIiwiaW1wb3J0IExpZ2h0aW5nTm9kZSBmcm9tICcuL0xpZ2h0aW5nTm9kZS5qcyc7XHJcbmltcG9ydCB7IE5vZGVVcGRhdGVUeXBlIH0gZnJvbSAnLi4vY29yZS9jb25zdGFudHMuanMnO1xyXG5pbXBvcnQgeyB1bmlmb3JtIH0gZnJvbSAnLi4vY29yZS9Vbmlmb3JtTm9kZS5qcyc7XHJcbmltcG9ydCB7IENvbG9yIH0gZnJvbSAnLi4vLi4vbWF0aC9Db2xvci5qcyc7XHJcbmltcG9ydCB7IHJlbmRlckdyb3VwIH0gZnJvbSAnLi4vY29yZS9Vbmlmb3JtR3JvdXBOb2RlLmpzJztcclxuaW1wb3J0IHsgaGFzaCB9IGZyb20gJy4uL2NvcmUvTm9kZVV0aWxzLmpzJztcclxuaW1wb3J0IHsgc2hhZG93IH0gZnJvbSAnLi9TaGFkb3dOb2RlLmpzJztcclxuaW1wb3J0IHsgbm9kZU9iamVjdCB9IGZyb20gJy4uL3RzbC9UU0xDb3JlLmpzJztcclxuXHJcbi8qKlxyXG4gKiBCYXNlIGNsYXNzIGZvciBhbmFseXRpYyBsaWdodCBub2Rlcy5cclxuICpcclxuICogQGF1Z21lbnRzIExpZ2h0aW5nTm9kZVxyXG4gKi9cclxuY2xhc3MgQW5hbHl0aWNMaWdodE5vZGUgZXh0ZW5kcyBMaWdodGluZ05vZGUge1xyXG5cclxuXHRzdGF0aWMgZ2V0IHR5cGUoKSB7XHJcblxyXG5cdFx0cmV0dXJuICdBbmFseXRpY0xpZ2h0Tm9kZSc7XHJcblxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogQ29uc3RydWN0cyBhIG5ldyBhbmFseXRpYyBsaWdodCBub2RlLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtMaWdodD99IFtsaWdodD1udWxsXSAtIFRoZSBsaWdodCBzb3VyY2UuXHJcblx0ICovXHJcblx0Y29uc3RydWN0b3IoIGxpZ2h0ID0gbnVsbCApIHtcclxuXHJcblx0XHRzdXBlcigpO1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogVGhlIGxpZ2h0IHNvdXJjZS5cclxuXHRcdCAqXHJcblx0XHQgKiBAdHlwZSB7TGlnaHQ/fVxyXG5cdFx0ICogQGRlZmF1bHQgbnVsbFxyXG5cdFx0ICovXHJcblx0XHR0aGlzLmxpZ2h0ID0gbGlnaHQ7XHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBUaGUgbGlnaHQncyBjb2xvciB2YWx1ZS5cclxuXHRcdCAqXHJcblx0XHQgKiBAdHlwZSB7Q29sb3J9XHJcblx0XHQgKi9cclxuXHRcdHRoaXMuY29sb3IgPSBuZXcgQ29sb3IoKTtcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIFRoZSBsaWdodCdzIGNvbG9yIG5vZGUuIFBvaW50cyB0byBgY29sb3JOb2RlYCBvZiB0aGUgbGlnaHQgc291cmNlLCBpZiBzZXQuIE90aGVyd2lzZVxyXG5cdFx0ICogaXQgY3JlYXRlcyBhIHVuaWZvcm0gbm9kZSBiYXNlZCBvbiB7QGxpbmsgQW5hbHl0aWNMaWdodE5vZGUjY29sb3J9LlxyXG5cdFx0ICpcclxuXHRcdCAqIEB0eXBlIHtOb2RlfVxyXG5cdFx0ICovXHJcblx0XHR0aGlzLmNvbG9yTm9kZSA9ICggbGlnaHQgJiYgbGlnaHQuY29sb3JOb2RlICkgfHwgdW5pZm9ybSggdGhpcy5jb2xvciApLnNldEdyb3VwKCByZW5kZXJHcm91cCApO1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogVGhpcyBwcm9wZXJ0eSBpcyB1c2VkIHRvIHJldGFpbiBhIHJlZmVyZW5jZSB0byB0aGUgb3JpZ2luYWwgdmFsdWUgb2Yge0BsaW5rIEFuYWx5dGljTGlnaHROb2RlI2NvbG9yTm9kZX0uXHJcblx0XHQgKiBUaGUgZmluYWwgY29sb3Igbm9kZSBpcyByZXByZXNlbnRlZCBieSBhIGRpZmZlcmVudCBub2RlIHdoZW4gdXNpbmcgc2hhZG93cy5cclxuXHRcdCAqXHJcblx0XHQgKiBAdHlwZSB7Tm9kZT99XHJcblx0XHQgKiBAZGVmYXVsdCBudWxsXHJcblx0XHQgKi9cclxuXHRcdHRoaXMuYmFzZUNvbG9yTm9kZSA9IG51bGw7XHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBSZXByZXNlbnRzIHRoZSBsaWdodCdzIHNoYWRvdy5cclxuXHRcdCAqXHJcblx0XHQgKiBAdHlwZSB7U2hhZG93Tm9kZT99XHJcbiAgIFx0XHQgKiBAZGVmYXVsdCBudWxsXHJcblx0XHQgKi9cclxuXHRcdHRoaXMuc2hhZG93Tm9kZSA9IG51bGw7XHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBSZXByZXNlbnRzIHRoZSBsaWdodCdzIHNoYWRvdyBjb2xvci5cclxuXHRcdCAqXHJcblx0XHQgKiBAdHlwZSB7Tm9kZT99XHJcbiAgIFx0XHQgKiBAZGVmYXVsdCBudWxsXHJcblx0XHQgKi9cclxuXHRcdHRoaXMuc2hhZG93Q29sb3JOb2RlID0gbnVsbDtcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIFRoaXMgZmxhZyBjYW4gYmUgdXNlZCBmb3IgdHlwZSB0ZXN0aW5nLlxyXG5cdFx0ICpcclxuXHRcdCAqIEB0eXBlIHtCb29sZWFufVxyXG5cdFx0ICogQHJlYWRvbmx5XHJcblx0XHQgKiBAZGVmYXVsdCB0cnVlXHJcblx0XHQgKi9cclxuXHRcdHRoaXMuaXNBbmFseXRpY0xpZ2h0Tm9kZSA9IHRydWU7XHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBPdmVyd3JpdHRlbiBzaW5jZSBhbmFseXRpYyBsaWdodCBub2RlcyBhcmUgdXBkYXRlZFxyXG5cdFx0ICogb25jZSBwZXIgZnJhbWUuXHJcblx0XHQgKlxyXG5cdFx0ICogQHR5cGUge1N0cmluZ31cclxuXHRcdCAqIEBkZWZhdWx0ICdmcmFtZSdcclxuXHRcdCAqL1xyXG5cdFx0dGhpcy51cGRhdGVUeXBlID0gTm9kZVVwZGF0ZVR5cGUuRlJBTUU7XHJcblxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogT3ZlcndyaXRlcyB0aGUgZGVmYXVsdCB7QGxpbmsgTm9kZSNjdXN0b21DYWNoZUtleX0gaW1wbGVtZW50YXRpb24gYnkgaW5jbHVkaW5nIHRoZVxyXG5cdCAqIGBsaWdodC5pZGAgYW5kIGBsaWdodC5jYXN0U2hhZG93YCBpbnRvIHRoZSBjYWNoZSBrZXkuXHJcblx0ICpcclxuXHQgKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSBjdXN0b20gY2FjaGUga2V5LlxyXG5cdCAqL1xyXG5cdGN1c3RvbUNhY2hlS2V5KCkge1xyXG5cclxuXHRcdHJldHVybiBoYXNoKCB0aGlzLmxpZ2h0LmlkLCB0aGlzLmxpZ2h0LmNhc3RTaGFkb3cgPyAxIDogMCApO1xyXG5cclxuXHR9XHJcblxyXG5cdGdldEhhc2goKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMubGlnaHQudXVpZDtcclxuXHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBTZXR1cHMgdGhlIHNoYWRvdyBub2RlIGZvciB0aGlzIGxpZ2h0LiBUaGUgbWV0aG9kIGV4aXN0cyBzbyBjb25jcmV0ZSBsaWdodCBjbGFzc2VzXHJcblx0ICogY2FuIHNldHVwIGRpZmZlcmVudCB0eXBlcyBvZiBzaGFkb3cgbm9kZXMuXHJcblx0ICpcclxuXHQgKiBAcmV0dXJuIHtTaGFkb3dOb2RlfSBUaGUgY3JlYXRlZCBzaGFkb3cgbm9kZS5cclxuXHQgKi9cclxuXHRzZXR1cFNoYWRvd05vZGUoKSB7XHJcblxyXG5cdFx0cmV0dXJuIHNoYWRvdyggdGhpcy5saWdodCApO1xyXG5cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFNldHVwcyB0aGUgc2hhZG93IGZvciB0aGlzIGxpZ2h0LiBUaGlzIG1ldGhvZCBpcyBvbmx5IGV4ZWN1dGVkIGlmIHRoZSBsaWdodFxyXG5cdCAqIGNhc3Qgc2hhZG93cyBhbmQgdGhlIGN1cnJlbnQgYnVpbGQgb2JqZWN0IHJlY2VpdmVzIHNoYWRvd3MuIEl0IGluY29ycG9yYXRlc1xyXG5cdCAqIHNoYWRvd3MgaW50byB0aGUgbGlnaHRpbmcgY29tcHV0YXRpb24uXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge05vZGVCdWlsZGVyfSBidWlsZGVyIC0gVGhlIGN1cnJlbnQgbm9kZSBidWlsZGVyLlxyXG5cdCAqL1xyXG5cdHNldHVwU2hhZG93KCBidWlsZGVyICkge1xyXG5cclxuXHRcdGNvbnN0IHsgcmVuZGVyZXIgfSA9IGJ1aWxkZXI7XHJcblxyXG5cdFx0aWYgKCByZW5kZXJlci5zaGFkb3dNYXAuZW5hYmxlZCA9PT0gZmFsc2UgKSByZXR1cm47XHJcblxyXG5cdFx0bGV0IHNoYWRvd0NvbG9yTm9kZSA9IHRoaXMuc2hhZG93Q29sb3JOb2RlO1xyXG5cclxuXHRcdGlmICggc2hhZG93Q29sb3JOb2RlID09PSBudWxsICkge1xyXG5cclxuXHRcdFx0Y29uc3QgY3VzdG9tU2hhZG93Tm9kZSA9IHRoaXMubGlnaHQuc2hhZG93LnNoYWRvd05vZGU7XHJcblxyXG5cdFx0XHRsZXQgc2hhZG93Tm9kZTtcclxuXHJcblx0XHRcdGlmICggY3VzdG9tU2hhZG93Tm9kZSAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRzaGFkb3dOb2RlID0gbm9kZU9iamVjdCggY3VzdG9tU2hhZG93Tm9kZSApO1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0c2hhZG93Tm9kZSA9IHRoaXMuc2V0dXBTaGFkb3dOb2RlKCBidWlsZGVyICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR0aGlzLnNoYWRvd05vZGUgPSBzaGFkb3dOb2RlO1xyXG5cclxuXHRcdFx0dGhpcy5zaGFkb3dDb2xvck5vZGUgPSBzaGFkb3dDb2xvck5vZGUgPSB0aGlzLmNvbG9yTm9kZS5tdWwoIHNoYWRvd05vZGUgKTtcclxuXHJcblx0XHRcdHRoaXMuYmFzZUNvbG9yTm9kZSA9IHRoaXMuY29sb3JOb2RlO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvL1xyXG5cclxuXHRcdHRoaXMuY29sb3JOb2RlID0gc2hhZG93Q29sb3JOb2RlO1xyXG5cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFVubGlrZSBtb3N0IG90aGVyIG5vZGVzLCBsaWdodGluZyBub2RlcyBkbyBub3QgcmV0dXJuIGEgb3V0cHV0IG5vZGUgaW4ge0BsaW5rIE5vZGUjc2V0dXB9LlxyXG5cdCAqIFRoZSBtYWluIHB1cnBvc2Ugb2YgbGlnaHRpbmcgbm9kZXMgaXMgdG8gY29uZmlndXJlIHRoZSBjdXJyZW50IHtAbGluayBMaWdodGluZ01vZGVsfSBhbmQvb3JcclxuXHQgKiBpbnZvY2F0ZSB0aGUgcmVzcGVjdGl2ZSBpbnRlcmZhY2UgbWV0aG9kcy5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7Tm9kZUJ1aWxkZXJ9IGJ1aWxkZXIgLSBUaGUgY3VycmVudCBub2RlIGJ1aWxkZXIuXHJcblx0ICovXHJcblx0c2V0dXAoIGJ1aWxkZXIgKSB7XHJcblxyXG5cdFx0dGhpcy5jb2xvck5vZGUgPSB0aGlzLmJhc2VDb2xvck5vZGUgfHwgdGhpcy5jb2xvck5vZGU7XHJcblxyXG5cdFx0aWYgKCB0aGlzLmxpZ2h0LmNhc3RTaGFkb3cgKSB7XHJcblxyXG5cdFx0XHRpZiAoIGJ1aWxkZXIub2JqZWN0LnJlY2VpdmVTaGFkb3cgKSB7XHJcblxyXG5cdFx0XHRcdHRoaXMuc2V0dXBTaGFkb3coIGJ1aWxkZXIgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9IGVsc2UgaWYgKCB0aGlzLnNoYWRvd05vZGUgIT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHR0aGlzLnNoYWRvd05vZGUuZGlzcG9zZSgpO1xyXG5cdFx0XHR0aGlzLnNoYWRvd05vZGUgPSBudWxsO1xyXG5cdFx0XHR0aGlzLnNoYWRvd0NvbG9yTm9kZSA9IG51bGw7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFRoZSB1cGRhdGUgbWV0aG9kIGlzIHVzZWQgdG8gdXBkYXRlIGxpZ2h0IHVuaWZvcm1zIHBlciBmcmFtZS5cclxuXHQgKiBQb3RlbnRpYWxseSBvdmVyd3JpdHRlbiBpbiBjb25jcmV0ZSBsaWdodCBub2RlcyB0byB1cGRhdGUgbGlnaHRcclxuXHQgKiBzcGVjaWZpYyB1bmlmb3Jtcy5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7Tm9kZUZyYW1lfSBmcmFtZSAtIEEgcmVmZXJlbmNlIHRvIHRoZSBjdXJyZW50IG5vZGUgZnJhbWUuXHJcblx0ICovXHJcblx0dXBkYXRlKCAvKmZyYW1lKi8gKSB7XHJcblxyXG5cdFx0Y29uc3QgeyBsaWdodCB9ID0gdGhpcztcclxuXHJcblx0XHR0aGlzLmNvbG9yLmNvcHkoIGxpZ2h0LmNvbG9yICkubXVsdGlwbHlTY2FsYXIoIGxpZ2h0LmludGVuc2l0eSApO1xyXG5cclxuXHR9XHJcblxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBBbmFseXRpY0xpZ2h0Tm9kZTtcclxuIiwiaW1wb3J0IHsgRm4gfSBmcm9tICcuLi90c2wvVFNMQmFzZS5qcyc7XHJcblxyXG4vKiogQG1vZHVsZSBMaWdodFV0aWxzICoqL1xyXG5cclxuLyoqXHJcbiAqIFJlcHJlc2VudHMgYSBgZGlzY2FyZGAgc2hhZGVyIG9wZXJhdGlvbiBpbiBUU0wuXHJcbiAqXHJcbiAqIEBtZXRob2RcclxuICogQHBhcmFtIHtPYmplY3R9IGlucHV0cyAtIFRoZSBpbnB1dCBwYXJhbWV0ZXIgb2JqZWN0LlxyXG4gKiBAcGFyYW0ge05vZGU8ZmxvYXQ+fSBpbnB1dHMubGlnaHREaXN0YW5jZSAtIFRoZSBkaXN0YW5jZSBvZiB0aGUgbGlnaHQncyBwb3NpdGlvbiB0byB0aGUgY3VycmVudCBmcmFnbWVudCBwb3NpdGlvbi5cclxuICogQHBhcmFtIHtOb2RlPGZsb2F0Pn0gaW5wdXRzLmN1dG9mZkRpc3RhbmNlIC0gVGhlIGxpZ2h0J3MgY3V0b2ZmIGRpc3RhbmNlLlxyXG4gKiBAcGFyYW0ge05vZGU8ZmxvYXQ+fSBpbnB1dHMuZGVjYXlFeHBvbmVudCAtIFRoZSBsaWdodCdzIGRlY2F5IGV4cG9uZW50LlxyXG4gKiBAcmV0dXJuIHtOb2RlPGZsb2F0Pn0gVGhlIGRpc3RhbmNlIGZhbGxvZmYuXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgZ2V0RGlzdGFuY2VBdHRlbnVhdGlvbiA9IC8qQF9fUFVSRV9fKi8gRm4oICggaW5wdXRzICkgPT4ge1xyXG5cclxuXHRjb25zdCB7IGxpZ2h0RGlzdGFuY2UsIGN1dG9mZkRpc3RhbmNlLCBkZWNheUV4cG9uZW50IH0gPSBpbnB1dHM7XHJcblxyXG5cdC8vIGJhc2VkIHVwb24gRnJvc3RiaXRlIDMgTW92aW5nIHRvIFBoeXNpY2FsbHktYmFzZWQgUmVuZGVyaW5nXHJcblx0Ly8gcGFnZSAzMiwgZXF1YXRpb24gMjY6IEVbd2luZG93MV1cclxuXHQvLyBodHRwczovL3NlYmxhZ2FyZGUuZmlsZXMud29yZHByZXNzLmNvbS8yMDE1LzA3L2NvdXJzZV9ub3Rlc19tb3ZpbmdfZnJvc3RiaXRlX3RvX3Bicl92MzIucGRmXHJcblx0Y29uc3QgZGlzdGFuY2VGYWxsb2ZmID0gbGlnaHREaXN0YW5jZS5wb3coIGRlY2F5RXhwb25lbnQgKS5tYXgoIDAuMDEgKS5yZWNpcHJvY2FsKCk7XHJcblxyXG5cdHJldHVybiBjdXRvZmZEaXN0YW5jZS5ncmVhdGVyVGhhbiggMCApLnNlbGVjdChcclxuXHRcdGRpc3RhbmNlRmFsbG9mZi5tdWwoIGxpZ2h0RGlzdGFuY2UuZGl2KCBjdXRvZmZEaXN0YW5jZSApLnBvdzQoKS5vbmVNaW51cygpLmNsYW1wKCkucG93MigpICksXHJcblx0XHRkaXN0YW5jZUZhbGxvZmZcclxuXHQpO1xyXG5cclxufSApOyAvLyB2YWxpZGF0ZWRcclxuIiwiaW1wb3J0IFNoYWRvd05vZGUgZnJvbSAnLi9TaGFkb3dOb2RlLmpzJztcclxuaW1wb3J0IHsgdW5pZm9ybSB9IGZyb20gJy4uL2NvcmUvVW5pZm9ybU5vZGUuanMnO1xyXG5pbXBvcnQgeyBmbG9hdCwgdmVjMiwgSWYsIEZuLCBub2RlT2JqZWN0IH0gZnJvbSAnLi4vdHNsL1RTTEJhc2UuanMnO1xyXG5pbXBvcnQgeyByZWZlcmVuY2UgfSBmcm9tICcuLi9hY2Nlc3NvcnMvUmVmZXJlbmNlTm9kZS5qcyc7XHJcbmltcG9ydCB7IHRleHR1cmUgfSBmcm9tICcuLi9hY2Nlc3NvcnMvVGV4dHVyZU5vZGUuanMnO1xyXG5pbXBvcnQgeyBtYXgsIGFicywgc2lnbiB9IGZyb20gJy4uL21hdGgvTWF0aE5vZGUuanMnO1xyXG5pbXBvcnQgeyBzdWIsIGRpdiB9IGZyb20gJy4uL21hdGgvT3BlcmF0b3JOb2RlLmpzJztcclxuaW1wb3J0IHsgcmVuZGVyR3JvdXAgfSBmcm9tICcuLi9jb3JlL1VuaWZvcm1Hcm91cE5vZGUuanMnO1xyXG5pbXBvcnQgeyBWZWN0b3IyIH0gZnJvbSAnLi4vLi4vbWF0aC9WZWN0b3IyLmpzJztcclxuaW1wb3J0IHsgVmVjdG9yNCB9IGZyb20gJy4uLy4uL21hdGgvVmVjdG9yNC5qcyc7XHJcbmltcG9ydCB7IENvbG9yIH0gZnJvbSAnLi4vLi4vbWF0aC9Db2xvci5qcyc7XHJcbmltcG9ydCB7IEJhc2ljU2hhZG93TWFwIH0gZnJvbSAnLi4vLi4vY29uc3RhbnRzLmpzJztcclxuXHJcbi8qKiBAbW9kdWxlIFBvaW50U2hhZG93Tm9kZSAqKi9cclxuXHJcbmNvbnN0IF9jbGVhckNvbG9yID0gLypAX19QVVJFX18qLyBuZXcgQ29sb3IoKTtcclxuXHJcbi8vIGN1YmVUb1VWKCkgbWFwcyBhIDNEIGRpcmVjdGlvbiB2ZWN0b3Igc3VpdGFibGUgZm9yIGN1YmUgdGV4dHVyZSBtYXBwaW5nIHRvIGEgMkRcclxuLy8gdmVjdG9yIHN1aXRhYmxlIGZvciAyRCB0ZXh0dXJlIG1hcHBpbmcuIFRoaXMgY29kZSB1c2VzIHRoZSBmb2xsb3dpbmcgbGF5b3V0IGZvciB0aGVcclxuLy8gMkQgdGV4dHVyZTpcclxuLy9cclxuLy8geHpYWlxyXG4vLyAgeSBZXHJcbi8vXHJcbi8vIFkgLSBQb3NpdGl2ZSB5IGRpcmVjdGlvblxyXG4vLyB5IC0gTmVnYXRpdmUgeSBkaXJlY3Rpb25cclxuLy8gWCAtIFBvc2l0aXZlIHggZGlyZWN0aW9uXHJcbi8vIHggLSBOZWdhdGl2ZSB4IGRpcmVjdGlvblxyXG4vLyBaIC0gUG9zaXRpdmUgeiBkaXJlY3Rpb25cclxuLy8geiAtIE5lZ2F0aXZlIHogZGlyZWN0aW9uXHJcbi8vXHJcbi8vIFNvdXJjZSBhbmQgdGVzdCBiZWQ6XHJcbi8vIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL3RzY2h3L2RhMTBjNDNjNDY3Y2U4YWZkMGM0XHJcblxyXG5leHBvcnQgY29uc3QgY3ViZVRvVVYgPSAvKkBfX1BVUkVfXyovIEZuKCAoIFsgcG9zLCB0ZXhlbFNpemVZIF0gKSA9PiB7XHJcblxyXG5cdGNvbnN0IHYgPSBwb3MudG9WYXIoKTtcclxuXHJcblx0Ly8gTnVtYmVyIG9mIHRleGVscyB0byBhdm9pZCBhdCB0aGUgZWRnZSBvZiBlYWNoIHNxdWFyZVxyXG5cclxuXHRjb25zdCBhYnNWID0gYWJzKCB2ICk7XHJcblxyXG5cdC8vIEludGVyc2VjdCB1bml0IGN1YmVcclxuXHJcblx0Y29uc3Qgc2NhbGVUb0N1YmUgPSBkaXYoIDEuMCwgbWF4KCBhYnNWLngsIG1heCggYWJzVi55LCBhYnNWLnogKSApICk7XHJcblx0YWJzVi5tdWxBc3NpZ24oIHNjYWxlVG9DdWJlICk7XHJcblxyXG5cdC8vIEFwcGx5IHNjYWxlIHRvIGF2b2lkIHNlYW1zXHJcblxyXG5cdC8vIHR3byB0ZXhlbHMgbGVzcyBwZXIgc3F1YXJlIChvbmUgdGV4ZWwgd2lsbCBkbyBmb3IgTkVBUkVTVClcclxuXHR2Lm11bEFzc2lnbiggc2NhbGVUb0N1YmUubXVsKCB0ZXhlbFNpemVZLm11bCggMiApLm9uZU1pbnVzKCkgKSApO1xyXG5cclxuXHQvLyBVbndyYXBcclxuXHJcblx0Ly8gc3BhY2U6IC0xIC4uLiAxIHJhbmdlIGZvciBlYWNoIHNxdWFyZVxyXG5cdC8vXHJcblx0Ly8gI1gjI1x0XHRkaW0gICAgOj0gKCA0ICwgMiApXHJcblx0Ly8gICMgI1x0XHRjZW50ZXIgOj0gKCAxICwgMSApXHJcblxyXG5cdGNvbnN0IHBsYW5hciA9IHZlYzIoIHYueHkgKS50b1ZhcigpO1xyXG5cclxuXHRjb25zdCBhbG1vc3RBVGV4ZWwgPSB0ZXhlbFNpemVZLm11bCggMS41ICk7XHJcblx0Y29uc3QgYWxtb3N0T25lID0gYWxtb3N0QVRleGVsLm9uZU1pbnVzKCk7XHJcblxyXG5cdElmKCBhYnNWLnouZ3JlYXRlclRoYW5FcXVhbCggYWxtb3N0T25lICksICgpID0+IHtcclxuXHJcblx0XHRJZiggdi56LmdyZWF0ZXJUaGFuKCAwLjAgKSwgKCkgPT4ge1xyXG5cclxuXHRcdFx0cGxhbmFyLnguYXNzaWduKCBzdWIoIDQuMCwgdi54ICkgKTtcclxuXHJcblx0XHR9ICk7XHJcblxyXG5cdH0gKS5FbHNlSWYoIGFic1YueC5ncmVhdGVyVGhhbkVxdWFsKCBhbG1vc3RPbmUgKSwgKCkgPT4ge1xyXG5cclxuXHRcdGNvbnN0IHNpZ25YID0gc2lnbiggdi54ICk7XHJcblx0XHRwbGFuYXIueC5hc3NpZ24oIHYuei5tdWwoIHNpZ25YICkuYWRkKCBzaWduWC5tdWwoIDIuMCApICkgKTtcclxuXHJcblx0fSApLkVsc2VJZiggYWJzVi55LmdyZWF0ZXJUaGFuRXF1YWwoIGFsbW9zdE9uZSApLCAoKSA9PiB7XHJcblxyXG5cdFx0Y29uc3Qgc2lnblkgPSBzaWduKCB2LnkgKTtcclxuXHRcdHBsYW5hci54LmFzc2lnbiggdi54LmFkZCggc2lnblkubXVsKCAyLjAgKSApLmFkZCggMi4wICkgKTtcclxuXHRcdHBsYW5hci55LmFzc2lnbiggdi56Lm11bCggc2lnblkgKS5zdWIoIDIuMCApICk7XHJcblxyXG5cdH0gKTtcclxuXHJcblx0Ly8gVHJhbnNmb3JtIHRvIFVWIHNwYWNlXHJcblxyXG5cdC8vIHNjYWxlIDo9IDAuNSAvIGRpbVxyXG5cdC8vIHRyYW5zbGF0ZSA6PSAoIGNlbnRlciArIDAuNSApIC8gZGltXHJcblx0cmV0dXJuIHZlYzIoIDAuMTI1LCAwLjI1ICkubXVsKCBwbGFuYXIgKS5hZGQoIHZlYzIoIDAuMzc1LCAwLjc1ICkgKS5mbGlwWSgpO1xyXG5cclxufSApLnNldExheW91dCgge1xyXG5cdG5hbWU6ICdjdWJlVG9VVicsXHJcblx0dHlwZTogJ3ZlYzInLFxyXG5cdGlucHV0czogW1xyXG5cdFx0eyBuYW1lOiAncG9zJywgdHlwZTogJ3ZlYzMnIH0sXHJcblx0XHR7IG5hbWU6ICd0ZXhlbFNpemVZJywgdHlwZTogJ2Zsb2F0JyB9XHJcblx0XVxyXG59ICk7XHJcblxyXG5leHBvcnQgY29uc3QgQmFzaWNQb2ludFNoYWRvd0ZpbHRlciA9IC8qQF9fUFVSRV9fKi8gRm4oICggeyBkZXB0aFRleHR1cmUsIGJkM0QsIGRwLCB0ZXhlbFNpemUgfSApID0+IHtcclxuXHJcblx0cmV0dXJuIHRleHR1cmUoIGRlcHRoVGV4dHVyZSwgY3ViZVRvVVYoIGJkM0QsIHRleGVsU2l6ZS55ICkgKS5jb21wYXJlKCBkcCApO1xyXG5cclxufSApO1xyXG5cclxuZXhwb3J0IGNvbnN0IFBvaW50U2hhZG93RmlsdGVyID0gLypAX19QVVJFX18qLyBGbiggKCB7IGRlcHRoVGV4dHVyZSwgYmQzRCwgZHAsIHRleGVsU2l6ZSwgc2hhZG93IH0gKSA9PiB7XHJcblxyXG5cdGNvbnN0IHJhZGl1cyA9IHJlZmVyZW5jZSggJ3JhZGl1cycsICdmbG9hdCcsIHNoYWRvdyApLnNldEdyb3VwKCByZW5kZXJHcm91cCApO1xyXG5cdGNvbnN0IG9mZnNldCA9IHZlYzIoIC0gMS4wLCAxLjAgKS5tdWwoIHJhZGl1cyApLm11bCggdGV4ZWxTaXplLnkgKTtcclxuXHJcblx0cmV0dXJuIHRleHR1cmUoIGRlcHRoVGV4dHVyZSwgY3ViZVRvVVYoIGJkM0QuYWRkKCBvZmZzZXQueHl5ICksIHRleGVsU2l6ZS55ICkgKS5jb21wYXJlKCBkcCApXHJcblx0XHQuYWRkKCB0ZXh0dXJlKCBkZXB0aFRleHR1cmUsIGN1YmVUb1VWKCBiZDNELmFkZCggb2Zmc2V0Lnl5eSApLCB0ZXhlbFNpemUueSApICkuY29tcGFyZSggZHAgKSApXHJcblx0XHQuYWRkKCB0ZXh0dXJlKCBkZXB0aFRleHR1cmUsIGN1YmVUb1VWKCBiZDNELmFkZCggb2Zmc2V0Lnh5eCApLCB0ZXhlbFNpemUueSApICkuY29tcGFyZSggZHAgKSApXHJcblx0XHQuYWRkKCB0ZXh0dXJlKCBkZXB0aFRleHR1cmUsIGN1YmVUb1VWKCBiZDNELmFkZCggb2Zmc2V0Lnl5eCApLCB0ZXhlbFNpemUueSApICkuY29tcGFyZSggZHAgKSApXHJcblx0XHQuYWRkKCB0ZXh0dXJlKCBkZXB0aFRleHR1cmUsIGN1YmVUb1VWKCBiZDNELCB0ZXhlbFNpemUueSApICkuY29tcGFyZSggZHAgKSApXHJcblx0XHQuYWRkKCB0ZXh0dXJlKCBkZXB0aFRleHR1cmUsIGN1YmVUb1VWKCBiZDNELmFkZCggb2Zmc2V0Lnh4eSApLCB0ZXhlbFNpemUueSApICkuY29tcGFyZSggZHAgKSApXHJcblx0XHQuYWRkKCB0ZXh0dXJlKCBkZXB0aFRleHR1cmUsIGN1YmVUb1VWKCBiZDNELmFkZCggb2Zmc2V0Lnl4eSApLCB0ZXhlbFNpemUueSApICkuY29tcGFyZSggZHAgKSApXHJcblx0XHQuYWRkKCB0ZXh0dXJlKCBkZXB0aFRleHR1cmUsIGN1YmVUb1VWKCBiZDNELmFkZCggb2Zmc2V0Lnh4eCApLCB0ZXhlbFNpemUueSApICkuY29tcGFyZSggZHAgKSApXHJcblx0XHQuYWRkKCB0ZXh0dXJlKCBkZXB0aFRleHR1cmUsIGN1YmVUb1VWKCBiZDNELmFkZCggb2Zmc2V0Lnl4eCApLCB0ZXhlbFNpemUueSApICkuY29tcGFyZSggZHAgKSApXHJcblx0XHQubXVsKCAxLjAgLyA5LjAgKTtcclxuXHJcbn0gKTtcclxuXHJcbmNvbnN0IHBvaW50U2hhZG93RmlsdGVyID0gLypAX19QVVJFX18qLyBGbiggKCB7IGZpbHRlckZuLCBkZXB0aFRleHR1cmUsIHNoYWRvd0Nvb3JkLCBzaGFkb3cgfSApID0+IHtcclxuXHJcblx0Ly8gZm9yIHBvaW50IGxpZ2h0cywgdGhlIHVuaWZvcm0gQHZTaGFkb3dDb29yZCBpcyByZS1wdXJwb3NlZCB0byBob2xkXHJcblx0Ly8gdGhlIHZlY3RvciBmcm9tIHRoZSBsaWdodCB0byB0aGUgd29ybGQtc3BhY2UgcG9zaXRpb24gb2YgdGhlIGZyYWdtZW50LlxyXG5cdGNvbnN0IGxpZ2h0VG9Qb3NpdGlvbiA9IHNoYWRvd0Nvb3JkLnh5ei50b1ZhcigpO1xyXG5cdGNvbnN0IGxpZ2h0VG9Qb3NpdGlvbkxlbmd0aCA9IGxpZ2h0VG9Qb3NpdGlvbi5sZW5ndGgoKTtcclxuXHJcblx0Y29uc3QgY2FtZXJhTmVhckxvY2FsID0gdW5pZm9ybSggJ2Zsb2F0JyApLnNldEdyb3VwKCByZW5kZXJHcm91cCApLm9uUmVuZGVyVXBkYXRlKCAoKSA9PiBzaGFkb3cuY2FtZXJhLm5lYXIgKTtcclxuXHRjb25zdCBjYW1lcmFGYXJMb2NhbCA9IHVuaWZvcm0oICdmbG9hdCcgKS5zZXRHcm91cCggcmVuZGVyR3JvdXAgKS5vblJlbmRlclVwZGF0ZSggKCkgPT4gc2hhZG93LmNhbWVyYS5mYXIgKTtcclxuXHRjb25zdCBiaWFzID0gcmVmZXJlbmNlKCAnYmlhcycsICdmbG9hdCcsIHNoYWRvdyApLnNldEdyb3VwKCByZW5kZXJHcm91cCApO1xyXG5cdGNvbnN0IG1hcFNpemUgPSB1bmlmb3JtKCBzaGFkb3cubWFwU2l6ZSApLnNldEdyb3VwKCByZW5kZXJHcm91cCApO1xyXG5cclxuXHRjb25zdCByZXN1bHQgPSBmbG9hdCggMS4wICkudG9WYXIoKTtcclxuXHJcblx0SWYoIGxpZ2h0VG9Qb3NpdGlvbkxlbmd0aC5zdWIoIGNhbWVyYUZhckxvY2FsICkubGVzc1RoYW5FcXVhbCggMC4wICkuYW5kKCBsaWdodFRvUG9zaXRpb25MZW5ndGguc3ViKCBjYW1lcmFOZWFyTG9jYWwgKS5ncmVhdGVyVGhhbkVxdWFsKCAwLjAgKSApLCAoKSA9PiB7XHJcblxyXG5cdFx0Ly8gZHAgPSBub3JtYWxpemVkIGRpc3RhbmNlIGZyb20gbGlnaHQgdG8gZnJhZ21lbnQgcG9zaXRpb25cclxuXHRcdGNvbnN0IGRwID0gbGlnaHRUb1Bvc2l0aW9uTGVuZ3RoLnN1YiggY2FtZXJhTmVhckxvY2FsICkuZGl2KCBjYW1lcmFGYXJMb2NhbC5zdWIoIGNhbWVyYU5lYXJMb2NhbCApICkudG9WYXIoKTsgLy8gbmVlZCB0byBjbGFtcD9cclxuXHRcdGRwLmFkZEFzc2lnbiggYmlhcyApO1xyXG5cclxuXHRcdC8vIGJkM0QgPSBiYXNlIGRpcmVjdGlvbiAzRFxyXG5cdFx0Y29uc3QgYmQzRCA9IGxpZ2h0VG9Qb3NpdGlvbi5ub3JtYWxpemUoKTtcclxuXHRcdGNvbnN0IHRleGVsU2l6ZSA9IHZlYzIoIDEuMCApLmRpdiggbWFwU2l6ZS5tdWwoIHZlYzIoIDQuMCwgMi4wICkgKSApO1xyXG5cclxuXHRcdC8vIHBlcmNlbnRhZ2UtY2xvc2VyIGZpbHRlcmluZ1xyXG5cdFx0cmVzdWx0LmFzc2lnbiggZmlsdGVyRm4oIHsgZGVwdGhUZXh0dXJlLCBiZDNELCBkcCwgdGV4ZWxTaXplLCBzaGFkb3cgfSApICk7XHJcblxyXG5cdH0gKTtcclxuXHJcblx0cmV0dXJuIHJlc3VsdDtcclxuXHJcbn0gKTtcclxuXHJcbmNvbnN0IF92aWV3cG9ydCA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjQoKTtcclxuY29uc3QgX3ZpZXdwb3J0U2l6ZSA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjIoKTtcclxuY29uc3QgX3NoYWRvd01hcFNpemUgPSAvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IyKCk7XHJcblxyXG5cclxuLyoqXHJcbiAqIFJlcHJlc2VudHMgdGhlIHNoYWRvdyBpbXBsZW1lbnRhdGlvbiBmb3IgcG9pbnQgbGlnaHQgbm9kZXMuXHJcbiAqXHJcbiAqIEBhdWdtZW50cyBtb2R1bGU6U2hhZG93Tm9kZX5TaGFkb3dOb2RlXHJcbiAqL1xyXG5jbGFzcyBQb2ludFNoYWRvd05vZGUgZXh0ZW5kcyBTaGFkb3dOb2RlIHtcclxuXHJcblx0c3RhdGljIGdldCB0eXBlKCkge1xyXG5cclxuXHRcdHJldHVybiAnUG9pbnRTaGFkb3dOb2RlJztcclxuXHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBDb25zdHJ1Y3RzIGEgbmV3IHBvaW50IHNoYWRvdyBub2RlLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtQb2ludExpZ2h0fSBsaWdodCAtIFRoZSBzaGFkb3cgY2FzdGluZyBwb2ludCBsaWdodC5cclxuXHQgKiBAcGFyYW0ge1BvaW50TGlnaHRTaGFkb3c/fSBbc2hhZG93PW51bGxdIC0gQW4gb3B0aW9uYWwgcG9pbnQgbGlnaHQgc2hhZG93LlxyXG5cdCAqL1xyXG5cdGNvbnN0cnVjdG9yKCBsaWdodCwgc2hhZG93ID0gbnVsbCApIHtcclxuXHJcblx0XHRzdXBlciggbGlnaHQsIHNoYWRvdyApO1xyXG5cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIE92ZXJ3cml0ZXMgdGhlIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gdG8gcmV0dXJuIHBvaW50IGxpZ2h0IHNoYWRvdyBzcGVjaWZpY1xyXG5cdCAqIGZpbHRlcmluZyBmdW5jdGlvbnMuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge051bWJlcn0gdHlwZSAtIFRoZSBzaGFkb3cgdHlwZS5cclxuXHQgKiBAcmV0dXJuIHtGdW5jdGlvbn0gVGhlIGZpbHRlcmluZyBmdW5jdGlvbi5cclxuXHQgKi9cclxuXHRnZXRTaGFkb3dGaWx0ZXJGbiggdHlwZSApIHtcclxuXHJcblx0XHRyZXR1cm4gdHlwZSA9PT0gQmFzaWNTaGFkb3dNYXAgPyBCYXNpY1BvaW50U2hhZG93RmlsdGVyIDogUG9pbnRTaGFkb3dGaWx0ZXI7XHJcblxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogT3ZlcndyaXRlcyB0aGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiBzbyB0aGUgdW5hbHRlcmVkIHNoYWRvdyBwb3NpdGlvbiBpcyB1c2VkLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtOb2RlQnVpbGRlcn0gYnVpbGRlciAtIEEgcmVmZXJlbmNlIHRvIHRoZSBjdXJyZW50IG5vZGUgYnVpbGRlci5cclxuXHQgKiBAcGFyYW0ge05vZGU8dmVjMz59IHNoYWRvd1Bvc2l0aW9uIC0gQSBub2RlIHJlcHJlc2VudGluZyB0aGUgc2hhZG93IHBvc2l0aW9uLlxyXG5cdCAqIEByZXR1cm4ge05vZGU8dmVjMz59IFRoZSBzaGFkb3cgY29vcmRpbmF0ZXMuXHJcblx0ICovXHJcblx0c2V0dXBTaGFkb3dDb29yZCggYnVpbGRlciwgc2hhZG93UG9zaXRpb24gKSB7XHJcblxyXG5cdFx0cmV0dXJuIHNoYWRvd1Bvc2l0aW9uO1xyXG5cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIE92ZXJ3cml0ZXMgdGhlIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gdG8gb25seSB1c2UgcG9pbnQgbGlnaHQgc3BlY2lmaWNcclxuXHQgKiBzaGFkb3cgZmlsdGVyIGZ1bmN0aW9ucy5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7Tm9kZUJ1aWxkZXJ9IGJ1aWxkZXIgLSBBIHJlZmVyZW5jZSB0byB0aGUgY3VycmVudCBub2RlIGJ1aWxkZXIuXHJcblx0ICogQHBhcmFtIHtPYmplY3R9IGlucHV0cyAtIEEgY29uZmlndXJhdGlvbiBvYmplY3QgdGhhdCBkZWZpbmVzIHRoZSBzaGFkb3cgZmlsdGVyaW5nLlxyXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IGlucHV0cy5maWx0ZXJGbiAtIFRoaXMgZnVuY3Rpb24gZGVmaW5lcyB0aGUgZmlsdGVyaW5nIHR5cGUgb2YgdGhlIHNoYWRvdyBtYXAgZS5nLiBQQ0YuXHJcblx0ICogQHBhcmFtIHtUZXh0dXJlfSBpbnB1dHMuc2hhZG93VGV4dHVyZSAtIEEgcmVmZXJlbmNlIHRvIHRoZSBzaGFkb3cgbWFwJ3MgdGV4dHVyZS5cclxuXHQgKiBAcGFyYW0ge0RlcHRoVGV4dHVyZX0gaW5wdXRzLmRlcHRoVGV4dHVyZSAtIEEgcmVmZXJlbmNlIHRvIHRoZSBzaGFkb3cgbWFwJ3MgdGV4dHVyZSBkYXRhLlxyXG5cdCAqIEBwYXJhbSB7Tm9kZTx2ZWMzPn0gaW5wdXRzLnNoYWRvd0Nvb3JkIC0gU2hhZG93IGNvb3JkaW5hdGVzIHdoaWNoIGFyZSB1c2VkIHRvIHNhbXBsZSBmcm9tIHRoZSBzaGFkb3cgbWFwLlxyXG5cdCAqIEBwYXJhbSB7TGlnaHRTaGFkb3d9IGlucHV0cy5zaGFkb3cgLSBUaGUgbGlnaHQgc2hhZG93LlxyXG5cdCAqIEByZXR1cm4ge05vZGU8ZmxvYXQ+fSBUaGUgcmVzdWx0IG5vZGUgb2YgdGhlIHNoYWRvdyBmaWx0ZXJpbmcuXHJcblx0ICovXHJcblx0c2V0dXBTaGFkb3dGaWx0ZXIoIGJ1aWxkZXIsIHsgZmlsdGVyRm4sIHNoYWRvd1RleHR1cmUsIGRlcHRoVGV4dHVyZSwgc2hhZG93Q29vcmQsIHNoYWRvdyB9ICkge1xyXG5cclxuXHRcdHJldHVybiBwb2ludFNoYWRvd0ZpbHRlciggeyBmaWx0ZXJGbiwgc2hhZG93VGV4dHVyZSwgZGVwdGhUZXh0dXJlLCBzaGFkb3dDb29yZCwgc2hhZG93IH0gKTtcclxuXHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBPdmVyd3JpdGVzIHRoZSBkZWZhdWx0IGltcGxlbWVudGF0aW9uIHdpdGggcG9pbnQgbGlnaHQgc3BlY2lmaWNcclxuXHQgKiByZW5kZXJpbmcgY29kZS5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7Tm9kZUZybWV9IGZyYW1lIC0gQSByZWZlcmVuY2UgdG8gdGhlIGN1cnJlbnQgbm9kZSBmcmFtZS5cclxuXHQgKi9cclxuXHRyZW5kZXJTaGFkb3coIGZyYW1lICkge1xyXG5cclxuXHRcdGNvbnN0IHsgc2hhZG93LCBzaGFkb3dNYXAsIGxpZ2h0IH0gPSB0aGlzO1xyXG5cdFx0Y29uc3QgeyByZW5kZXJlciwgc2NlbmUgfSA9IGZyYW1lO1xyXG5cclxuXHRcdGNvbnN0IHNoYWRvd0ZyYW1lRXh0ZW50cyA9IHNoYWRvdy5nZXRGcmFtZUV4dGVudHMoKTtcclxuXHJcblx0XHRfc2hhZG93TWFwU2l6ZS5jb3B5KCBzaGFkb3cubWFwU2l6ZSApO1xyXG5cdFx0X3NoYWRvd01hcFNpemUubXVsdGlwbHkoIHNoYWRvd0ZyYW1lRXh0ZW50cyApO1xyXG5cclxuXHRcdHNoYWRvd01hcC5zZXRTaXplKCBfc2hhZG93TWFwU2l6ZS53aWR0aCwgX3NoYWRvd01hcFNpemUuaGVpZ2h0ICk7XHJcblxyXG5cdFx0X3ZpZXdwb3J0U2l6ZS5jb3B5KCBzaGFkb3cubWFwU2l6ZSApO1xyXG5cclxuXHRcdC8vXHJcblxyXG5cdFx0Y29uc3QgcHJldmlvdXNBdXRvQ2xlYXIgPSByZW5kZXJlci5hdXRvQ2xlYXI7XHJcblxyXG5cdFx0Y29uc3QgcHJldmlvdXNDbGVhckNvbG9yID0gcmVuZGVyZXIuZ2V0Q2xlYXJDb2xvciggX2NsZWFyQ29sb3IgKTtcclxuXHRcdGNvbnN0IHByZXZpb3VzQ2xlYXJBbHBoYSA9IHJlbmRlcmVyLmdldENsZWFyQWxwaGEoKTtcclxuXHJcblx0XHRyZW5kZXJlci5hdXRvQ2xlYXIgPSBmYWxzZTtcclxuXHRcdHJlbmRlcmVyLnNldENsZWFyQ29sb3IoIHNoYWRvdy5jbGVhckNvbG9yLCBzaGFkb3cuY2xlYXJBbHBoYSApO1xyXG5cdFx0cmVuZGVyZXIuY2xlYXIoKTtcclxuXHJcblx0XHRjb25zdCB2aWV3cG9ydENvdW50ID0gc2hhZG93LmdldFZpZXdwb3J0Q291bnQoKTtcclxuXHJcblx0XHRmb3IgKCBsZXQgdnAgPSAwOyB2cCA8IHZpZXdwb3J0Q291bnQ7IHZwICsrICkge1xyXG5cclxuXHRcdFx0Y29uc3Qgdmlld3BvcnQgPSBzaGFkb3cuZ2V0Vmlld3BvcnQoIHZwICk7XHJcblxyXG5cdFx0XHRjb25zdCB4ID0gX3ZpZXdwb3J0U2l6ZS54ICogdmlld3BvcnQueDtcclxuXHRcdFx0Y29uc3QgeSA9IF9zaGFkb3dNYXBTaXplLnkgLSBfdmlld3BvcnRTaXplLnkgLSAoIF92aWV3cG9ydFNpemUueSAqIHZpZXdwb3J0LnkgKTtcclxuXHJcblx0XHRcdF92aWV3cG9ydC5zZXQoXHJcblx0XHRcdFx0eCxcclxuXHRcdFx0XHR5LFxyXG5cdFx0XHRcdF92aWV3cG9ydFNpemUueCAqIHZpZXdwb3J0LnosXHJcblx0XHRcdFx0X3ZpZXdwb3J0U2l6ZS55ICogdmlld3BvcnQud1xyXG5cdFx0XHQpO1xyXG5cclxuXHRcdFx0c2hhZG93TWFwLnZpZXdwb3J0LmNvcHkoIF92aWV3cG9ydCApO1xyXG5cclxuXHRcdFx0c2hhZG93LnVwZGF0ZU1hdHJpY2VzKCBsaWdodCwgdnAgKTtcclxuXHJcblx0XHRcdHJlbmRlcmVyLnJlbmRlciggc2NlbmUsIHNoYWRvdy5jYW1lcmEgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly9cclxuXHJcblx0XHRyZW5kZXJlci5hdXRvQ2xlYXIgPSBwcmV2aW91c0F1dG9DbGVhcjtcclxuXHRcdHJlbmRlcmVyLnNldENsZWFyQ29sb3IoIHByZXZpb3VzQ2xlYXJDb2xvciwgcHJldmlvdXNDbGVhckFscGhhICk7XHJcblxyXG5cdH1cclxuXHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IFBvaW50U2hhZG93Tm9kZTtcclxuXHJcbi8qKlxyXG4gKiBUU0wgZnVuY3Rpb24gZm9yIGNyZWF0aW5nIGFuIGluc3RhbmNlIG9mIGBQb2ludFNoYWRvd05vZGVgLlxyXG4gKlxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHtQb2ludExpZ2h0fSBsaWdodCAtIFRoZSBzaGFkb3cgY2FzdGluZyBwb2ludCBsaWdodC5cclxuICogQHBhcmFtIHtQb2ludExpZ2h0U2hhZG93P30gW3NoYWRvdz1udWxsXSAtIEFuIG9wdGlvbmFsIHBvaW50IGxpZ2h0IHNoYWRvdy5cclxuICogQHJldHVybiB7UG9pbnRTaGFkb3dOb2RlfSBUaGUgY3JlYXRlZCBwb2ludCBzaGFkb3cgbm9kZS5cclxuICovXHJcbmV4cG9ydCBjb25zdCBwb2ludFNoYWRvdyA9ICggbGlnaHQsIHNoYWRvdyApID0+IG5vZGVPYmplY3QoIG5ldyBQb2ludFNoYWRvd05vZGUoIGxpZ2h0LCBzaGFkb3cgKSApO1xyXG4iLCJpbXBvcnQgQW5hbHl0aWNMaWdodE5vZGUgZnJvbSAnLi9BbmFseXRpY0xpZ2h0Tm9kZS5qcyc7XHJcbmltcG9ydCB7IGdldERpc3RhbmNlQXR0ZW51YXRpb24gfSBmcm9tICcuL0xpZ2h0VXRpbHMuanMnO1xyXG5pbXBvcnQgeyB1bmlmb3JtIH0gZnJvbSAnLi4vY29yZS9Vbmlmb3JtTm9kZS5qcyc7XHJcbmltcG9ydCB7IGxpZ2h0Vmlld1Bvc2l0aW9uIH0gZnJvbSAnLi4vYWNjZXNzb3JzL0xpZ2h0cy5qcyc7XHJcbmltcG9ydCB7IHBvc2l0aW9uVmlldyB9IGZyb20gJy4uL2FjY2Vzc29ycy9Qb3NpdGlvbi5qcyc7XHJcbmltcG9ydCB7IEZuIH0gZnJvbSAnLi4vdHNsL1RTTEJhc2UuanMnO1xyXG5pbXBvcnQgeyByZW5kZXJHcm91cCB9IGZyb20gJy4uL2NvcmUvVW5pZm9ybUdyb3VwTm9kZS5qcyc7XHJcbmltcG9ydCB7IHBvaW50U2hhZG93IH0gZnJvbSAnLi9Qb2ludFNoYWRvd05vZGUuanMnO1xyXG5cclxuZXhwb3J0IGNvbnN0IGRpcmVjdFBvaW50TGlnaHQgPSBGbiggKCB7IGNvbG9yLCBsaWdodFZpZXdQb3NpdGlvbiwgY3V0b2ZmRGlzdGFuY2UsIGRlY2F5RXhwb25lbnQgfSwgYnVpbGRlciApID0+IHtcclxuXHJcblx0Y29uc3QgbGlnaHRpbmdNb2RlbCA9IGJ1aWxkZXIuY29udGV4dC5saWdodGluZ01vZGVsO1xyXG5cclxuXHRjb25zdCBsVmVjdG9yID0gbGlnaHRWaWV3UG9zaXRpb24uc3ViKCBwb3NpdGlvblZpZXcgKTsgLy8gQFRPRE86IEFkZCBpdCBpbnRvIExpZ2h0Tm9kZVxyXG5cclxuXHRjb25zdCBsaWdodERpcmVjdGlvbiA9IGxWZWN0b3Iubm9ybWFsaXplKCk7XHJcblx0Y29uc3QgbGlnaHREaXN0YW5jZSA9IGxWZWN0b3IubGVuZ3RoKCk7XHJcblxyXG5cdGNvbnN0IGxpZ2h0QXR0ZW51YXRpb24gPSBnZXREaXN0YW5jZUF0dGVudWF0aW9uKCB7XHJcblx0XHRsaWdodERpc3RhbmNlLFxyXG5cdFx0Y3V0b2ZmRGlzdGFuY2UsXHJcblx0XHRkZWNheUV4cG9uZW50XHJcblx0fSApO1xyXG5cclxuXHRjb25zdCBsaWdodENvbG9yID0gY29sb3IubXVsKCBsaWdodEF0dGVudWF0aW9uICk7XHJcblxyXG5cdGNvbnN0IHJlZmxlY3RlZExpZ2h0ID0gYnVpbGRlci5jb250ZXh0LnJlZmxlY3RlZExpZ2h0O1xyXG5cclxuXHRsaWdodGluZ01vZGVsLmRpcmVjdCgge1xyXG5cdFx0bGlnaHREaXJlY3Rpb24sXHJcblx0XHRsaWdodENvbG9yLFxyXG5cdFx0cmVmbGVjdGVkTGlnaHRcclxuXHR9LCBidWlsZGVyLnN0YWNrLCBidWlsZGVyICk7XHJcblxyXG59ICk7XHJcblxyXG4vKipcclxuICogTW9kdWxlIGZvciByZXByZXNlbnRpbmcgcG9pbnQgbGlnaHRzIGFzIG5vZGVzLlxyXG4gKlxyXG4gKiBAYXVnbWVudHMgQW5hbHl0aWNMaWdodE5vZGVcclxuICovXHJcbmNsYXNzIFBvaW50TGlnaHROb2RlIGV4dGVuZHMgQW5hbHl0aWNMaWdodE5vZGUge1xyXG5cclxuXHRzdGF0aWMgZ2V0IHR5cGUoKSB7XHJcblxyXG5cdFx0cmV0dXJuICdQb2ludExpZ2h0Tm9kZSc7XHJcblxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogQ29uc3RydWN0cyBhIG5ldyBwb2ludCBsaWdodCBub2RlLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtQb2ludExpZ2h0P30gW2xpZ2h0PW51bGxdIC0gVGhlIHBvaW50IGxpZ2h0IHNvdXJjZS5cclxuXHQgKi9cclxuXHRjb25zdHJ1Y3RvciggbGlnaHQgPSBudWxsICkge1xyXG5cclxuXHRcdHN1cGVyKCBsaWdodCApO1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogVW5pZm9ybSBub2RlIHJlcHJlc2VudGluZyB0aGUgY3V0b2ZmIGRpc3RhbmNlLlxyXG5cdFx0ICpcclxuXHRcdCAqIEB0eXBlIHtVbmlmb3JtTm9kZTxmbG9hdD59XHJcblx0XHQgKi9cclxuXHRcdHRoaXMuY3V0b2ZmRGlzdGFuY2VOb2RlID0gdW5pZm9ybSggMCApLnNldEdyb3VwKCByZW5kZXJHcm91cCApO1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogVW5pZm9ybSBub2RlIHJlcHJlc2VudGluZyB0aGUgZGVjYXkgZXhwb25lbnQuXHJcblx0XHQgKlxyXG5cdFx0ICogQHR5cGUge1VuaWZvcm1Ob2RlPGZsb2F0Pn1cclxuXHRcdCAqL1xyXG5cdFx0dGhpcy5kZWNheUV4cG9uZW50Tm9kZSA9IHVuaWZvcm0oIDIgKS5zZXRHcm91cCggcmVuZGVyR3JvdXAgKTtcclxuXHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBPdmVyd3JpdHRlbiB0byB1cGRhdGVkIHBvaW50IGxpZ2h0IHNwZWNpZmljIHVuaWZvcm1zLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtOb2RlRnJhbWV9IGZyYW1lIC0gQSByZWZlcmVuY2UgdG8gdGhlIGN1cnJlbnQgbm9kZSBmcmFtZS5cclxuXHQgKi9cclxuXHR1cGRhdGUoIGZyYW1lICkge1xyXG5cclxuXHRcdGNvbnN0IHsgbGlnaHQgfSA9IHRoaXM7XHJcblxyXG5cdFx0c3VwZXIudXBkYXRlKCBmcmFtZSApO1xyXG5cclxuXHRcdHRoaXMuY3V0b2ZmRGlzdGFuY2VOb2RlLnZhbHVlID0gbGlnaHQuZGlzdGFuY2U7XHJcblx0XHR0aGlzLmRlY2F5RXhwb25lbnROb2RlLnZhbHVlID0gbGlnaHQuZGVjYXk7XHJcblxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogT3ZlcndyaXR0ZW4gdG8gc2V0dXAgcG9pbnQgbGlnaHQgc3BlY2lmaWMgc2hhZG93LlxyXG5cdCAqXHJcblx0ICogQHJldHVybiB7UG9pbnRTaGFkb3dOb2RlfVxyXG5cdCAqL1xyXG5cdHNldHVwU2hhZG93Tm9kZSgpIHtcclxuXHJcblx0XHRyZXR1cm4gcG9pbnRTaGFkb3coIHRoaXMubGlnaHQgKTtcclxuXHJcblx0fVxyXG5cclxuXHRzZXR1cCggYnVpbGRlciApIHtcclxuXHJcblx0XHRzdXBlci5zZXR1cCggYnVpbGRlciApO1xyXG5cclxuXHRcdGRpcmVjdFBvaW50TGlnaHQoIHtcclxuXHRcdFx0Y29sb3I6IHRoaXMuY29sb3JOb2RlLFxyXG5cdFx0XHRsaWdodFZpZXdQb3NpdGlvbjogbGlnaHRWaWV3UG9zaXRpb24oIHRoaXMubGlnaHQgKSxcclxuXHRcdFx0Y3V0b2ZmRGlzdGFuY2U6IHRoaXMuY3V0b2ZmRGlzdGFuY2VOb2RlLFxyXG5cdFx0XHRkZWNheUV4cG9uZW50OiB0aGlzLmRlY2F5RXhwb25lbnROb2RlXHJcblx0XHR9ICkuYXBwZW5kKCk7XHJcblxyXG5cdH1cclxuXHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IFBvaW50TGlnaHROb2RlO1xyXG4iLCJpbXBvcnQgeyB1diB9IGZyb20gJy4uL2FjY2Vzc29ycy9VVi5qcyc7XHJcbmltcG9ydCB7IEZuIH0gZnJvbSAnLi4vdHNsL1RTTEJhc2UuanMnO1xyXG5cclxuLyoqIEBtb2R1bGUgUHJvY2VkdXJhbCAqKi9cclxuXHJcbi8qKlxyXG4gKiBDcmVhdGVzIGEgMngyIGNoZWNrZXJib2FyZCBwYXR0ZXJuIHRoYXQgY2FuIGJlIHVzZWQgYXMgcHJvY2VkdXJhbCB0ZXh0dXJlIGRhdGEuXHJcbiAqXHJcbiAqIEBtZXRob2RcclxuICogQHBhcmFtIHtOb2RlPHZlYzI+fSBjb29yZCAtIFRoZSB1diBjb29yZGluYXRlcy5cclxuICogQHJldHVybiB7Tm9kZTxmbG9hdD59IFRoZSByZXN1bHQgZGF0YS5cclxuICovXHJcbmV4cG9ydCBjb25zdCBjaGVja2VyID0gLypAX19QVVJFX18qLyBGbiggKCBbIGNvb3JkID0gdXYoKSBdICkgPT4ge1xyXG5cclxuXHRjb25zdCB1diA9IGNvb3JkLm11bCggMi4wICk7XHJcblxyXG5cdGNvbnN0IGN4ID0gdXYueC5mbG9vcigpO1xyXG5cdGNvbnN0IGN5ID0gdXYueS5mbG9vcigpO1xyXG5cdGNvbnN0IHJlc3VsdCA9IGN4LmFkZCggY3kgKS5tb2QoIDIuMCApO1xyXG5cclxuXHRyZXR1cm4gcmVzdWx0LnNpZ24oKTtcclxuXHJcbn0gKTtcclxuIiwiLy8gVGhyZWUuanMgVHJhbnNwaWxlclxyXG4vLyBodHRwczovL3Jhdy5naXRodWJ1c2VyY29udGVudC5jb20vQWNhZGVteVNvZnR3YXJlRm91bmRhdGlvbi9NYXRlcmlhbFgvbWFpbi9saWJyYXJpZXMvc3RkbGliL2dlbmdsc2wvbGliL214X25vaXNlLmdsc2xcclxuXHJcbmltcG9ydCB7IGludCwgdWludCwgZmxvYXQsIHZlYzMsIGJvb2wsIHV2ZWMzLCB2ZWMyLCB2ZWM0LCBJZiwgRm4gfSBmcm9tICcuLi8uLi90c2wvVFNMQmFzZS5qcyc7XHJcbmltcG9ydCB7IHNlbGVjdCB9IGZyb20gJy4uLy4uL21hdGgvQ29uZGl0aW9uYWxOb2RlLmpzJztcclxuaW1wb3J0IHsgc3ViLCBtdWwgfSBmcm9tICcuLi8uLi9tYXRoL09wZXJhdG9yTm9kZS5qcyc7XHJcbmltcG9ydCB7IGZsb29yLCBhYnMsIG1heCwgZG90LCBtaW4sIHNxcnQgfSBmcm9tICcuLi8uLi9tYXRoL01hdGhOb2RlLmpzJztcclxuaW1wb3J0IHsgb3ZlcmxvYWRpbmdGbiB9IGZyb20gJy4uLy4uL3V0aWxzL0Z1bmN0aW9uT3ZlcmxvYWRpbmdOb2RlLmpzJztcclxuaW1wb3J0IHsgTG9vcCB9IGZyb20gJy4uLy4uL3V0aWxzL0xvb3BOb2RlLmpzJztcclxuXHJcblxyXG5leHBvcnQgY29uc3QgbXhfc2VsZWN0ID0gLypAX19QVVJFX18qLyBGbiggKCBbIGJfaW1tdXRhYmxlLCB0X2ltbXV0YWJsZSwgZl9pbW11dGFibGUgXSApID0+IHtcclxuXHJcblx0Y29uc3QgZiA9IGZsb2F0KCBmX2ltbXV0YWJsZSApLnRvVmFyKCk7XHJcblx0Y29uc3QgdCA9IGZsb2F0KCB0X2ltbXV0YWJsZSApLnRvVmFyKCk7XHJcblx0Y29uc3QgYiA9IGJvb2woIGJfaW1tdXRhYmxlICkudG9WYXIoKTtcclxuXHJcblx0cmV0dXJuIHNlbGVjdCggYiwgdCwgZiApO1xyXG5cclxufSApLnNldExheW91dCgge1xyXG5cdG5hbWU6ICdteF9zZWxlY3QnLFxyXG5cdHR5cGU6ICdmbG9hdCcsXHJcblx0aW5wdXRzOiBbXHJcblx0XHR7IG5hbWU6ICdiJywgdHlwZTogJ2Jvb2wnIH0sXHJcblx0XHR7IG5hbWU6ICd0JywgdHlwZTogJ2Zsb2F0JyB9LFxyXG5cdFx0eyBuYW1lOiAnZicsIHR5cGU6ICdmbG9hdCcgfVxyXG5cdF1cclxufSApO1xyXG5cclxuZXhwb3J0IGNvbnN0IG14X25lZ2F0ZV9pZiA9IC8qQF9fUFVSRV9fKi8gRm4oICggWyB2YWxfaW1tdXRhYmxlLCBiX2ltbXV0YWJsZSBdICkgPT4ge1xyXG5cclxuXHRjb25zdCBiID0gYm9vbCggYl9pbW11dGFibGUgKS50b1ZhcigpO1xyXG5cdGNvbnN0IHZhbCA9IGZsb2F0KCB2YWxfaW1tdXRhYmxlICkudG9WYXIoKTtcclxuXHJcblx0cmV0dXJuIHNlbGVjdCggYiwgdmFsLm5lZ2F0ZSgpLCB2YWwgKTtcclxuXHJcbn0gKS5zZXRMYXlvdXQoIHtcclxuXHRuYW1lOiAnbXhfbmVnYXRlX2lmJyxcclxuXHR0eXBlOiAnZmxvYXQnLFxyXG5cdGlucHV0czogW1xyXG5cdFx0eyBuYW1lOiAndmFsJywgdHlwZTogJ2Zsb2F0JyB9LFxyXG5cdFx0eyBuYW1lOiAnYicsIHR5cGU6ICdib29sJyB9XHJcblx0XVxyXG59ICk7XHJcblxyXG5leHBvcnQgY29uc3QgbXhfZmxvb3IgPSAvKkBfX1BVUkVfXyovIEZuKCAoIFsgeF9pbW11dGFibGUgXSApID0+IHtcclxuXHJcblx0Y29uc3QgeCA9IGZsb2F0KCB4X2ltbXV0YWJsZSApLnRvVmFyKCk7XHJcblxyXG5cdHJldHVybiBpbnQoIGZsb29yKCB4ICkgKTtcclxuXHJcbn0gKS5zZXRMYXlvdXQoIHtcclxuXHRuYW1lOiAnbXhfZmxvb3InLFxyXG5cdHR5cGU6ICdpbnQnLFxyXG5cdGlucHV0czogW1xyXG5cdFx0eyBuYW1lOiAneCcsIHR5cGU6ICdmbG9hdCcgfVxyXG5cdF1cclxufSApO1xyXG5cclxuZXhwb3J0IGNvbnN0IG14X2Zsb29yZnJhYyA9IC8qQF9fUFVSRV9fKi8gRm4oICggWyB4X2ltbXV0YWJsZSwgaSBdICkgPT4ge1xyXG5cclxuXHRjb25zdCB4ID0gZmxvYXQoIHhfaW1tdXRhYmxlICkudG9WYXIoKTtcclxuXHRpLmFzc2lnbiggbXhfZmxvb3IoIHggKSApO1xyXG5cclxuXHRyZXR1cm4geC5zdWIoIGZsb2F0KCBpICkgKTtcclxuXHJcbn0gKTtcclxuXHJcbmV4cG9ydCBjb25zdCBteF9iaWxlcnBfMCA9IC8qQF9fUFVSRV9fKi8gRm4oICggWyB2MF9pbW11dGFibGUsIHYxX2ltbXV0YWJsZSwgdjJfaW1tdXRhYmxlLCB2M19pbW11dGFibGUsIHNfaW1tdXRhYmxlLCB0X2ltbXV0YWJsZSBdICkgPT4ge1xyXG5cclxuXHRjb25zdCB0ID0gZmxvYXQoIHRfaW1tdXRhYmxlICkudG9WYXIoKTtcclxuXHRjb25zdCBzID0gZmxvYXQoIHNfaW1tdXRhYmxlICkudG9WYXIoKTtcclxuXHRjb25zdCB2MyA9IGZsb2F0KCB2M19pbW11dGFibGUgKS50b1ZhcigpO1xyXG5cdGNvbnN0IHYyID0gZmxvYXQoIHYyX2ltbXV0YWJsZSApLnRvVmFyKCk7XHJcblx0Y29uc3QgdjEgPSBmbG9hdCggdjFfaW1tdXRhYmxlICkudG9WYXIoKTtcclxuXHRjb25zdCB2MCA9IGZsb2F0KCB2MF9pbW11dGFibGUgKS50b1ZhcigpO1xyXG5cdGNvbnN0IHMxID0gZmxvYXQoIHN1YiggMS4wLCBzICkgKS50b1ZhcigpO1xyXG5cclxuXHRyZXR1cm4gc3ViKCAxLjAsIHQgKS5tdWwoIHYwLm11bCggczEgKS5hZGQoIHYxLm11bCggcyApICkgKS5hZGQoIHQubXVsKCB2Mi5tdWwoIHMxICkuYWRkKCB2My5tdWwoIHMgKSApICkgKTtcclxuXHJcbn0gKS5zZXRMYXlvdXQoIHtcclxuXHRuYW1lOiAnbXhfYmlsZXJwXzAnLFxyXG5cdHR5cGU6ICdmbG9hdCcsXHJcblx0aW5wdXRzOiBbXHJcblx0XHR7IG5hbWU6ICd2MCcsIHR5cGU6ICdmbG9hdCcgfSxcclxuXHRcdHsgbmFtZTogJ3YxJywgdHlwZTogJ2Zsb2F0JyB9LFxyXG5cdFx0eyBuYW1lOiAndjInLCB0eXBlOiAnZmxvYXQnIH0sXHJcblx0XHR7IG5hbWU6ICd2MycsIHR5cGU6ICdmbG9hdCcgfSxcclxuXHRcdHsgbmFtZTogJ3MnLCB0eXBlOiAnZmxvYXQnIH0sXHJcblx0XHR7IG5hbWU6ICd0JywgdHlwZTogJ2Zsb2F0JyB9XHJcblx0XVxyXG59ICk7XHJcblxyXG5leHBvcnQgY29uc3QgbXhfYmlsZXJwXzEgPSAvKkBfX1BVUkVfXyovIEZuKCAoIFsgdjBfaW1tdXRhYmxlLCB2MV9pbW11dGFibGUsIHYyX2ltbXV0YWJsZSwgdjNfaW1tdXRhYmxlLCBzX2ltbXV0YWJsZSwgdF9pbW11dGFibGUgXSApID0+IHtcclxuXHJcblx0Y29uc3QgdCA9IGZsb2F0KCB0X2ltbXV0YWJsZSApLnRvVmFyKCk7XHJcblx0Y29uc3QgcyA9IGZsb2F0KCBzX2ltbXV0YWJsZSApLnRvVmFyKCk7XHJcblx0Y29uc3QgdjMgPSB2ZWMzKCB2M19pbW11dGFibGUgKS50b1ZhcigpO1xyXG5cdGNvbnN0IHYyID0gdmVjMyggdjJfaW1tdXRhYmxlICkudG9WYXIoKTtcclxuXHRjb25zdCB2MSA9IHZlYzMoIHYxX2ltbXV0YWJsZSApLnRvVmFyKCk7XHJcblx0Y29uc3QgdjAgPSB2ZWMzKCB2MF9pbW11dGFibGUgKS50b1ZhcigpO1xyXG5cdGNvbnN0IHMxID0gZmxvYXQoIHN1YiggMS4wLCBzICkgKS50b1ZhcigpO1xyXG5cclxuXHRyZXR1cm4gc3ViKCAxLjAsIHQgKS5tdWwoIHYwLm11bCggczEgKS5hZGQoIHYxLm11bCggcyApICkgKS5hZGQoIHQubXVsKCB2Mi5tdWwoIHMxICkuYWRkKCB2My5tdWwoIHMgKSApICkgKTtcclxuXHJcbn0gKS5zZXRMYXlvdXQoIHtcclxuXHRuYW1lOiAnbXhfYmlsZXJwXzEnLFxyXG5cdHR5cGU6ICd2ZWMzJyxcclxuXHRpbnB1dHM6IFtcclxuXHRcdHsgbmFtZTogJ3YwJywgdHlwZTogJ3ZlYzMnIH0sXHJcblx0XHR7IG5hbWU6ICd2MScsIHR5cGU6ICd2ZWMzJyB9LFxyXG5cdFx0eyBuYW1lOiAndjInLCB0eXBlOiAndmVjMycgfSxcclxuXHRcdHsgbmFtZTogJ3YzJywgdHlwZTogJ3ZlYzMnIH0sXHJcblx0XHR7IG5hbWU6ICdzJywgdHlwZTogJ2Zsb2F0JyB9LFxyXG5cdFx0eyBuYW1lOiAndCcsIHR5cGU6ICdmbG9hdCcgfVxyXG5cdF1cclxufSApO1xyXG5cclxuZXhwb3J0IGNvbnN0IG14X2JpbGVycCA9IC8qQF9fUFVSRV9fKi8gb3ZlcmxvYWRpbmdGbiggWyBteF9iaWxlcnBfMCwgbXhfYmlsZXJwXzEgXSApO1xyXG5cclxuZXhwb3J0IGNvbnN0IG14X3RyaWxlcnBfMCA9IC8qQF9fUFVSRV9fKi8gRm4oICggWyB2MF9pbW11dGFibGUsIHYxX2ltbXV0YWJsZSwgdjJfaW1tdXRhYmxlLCB2M19pbW11dGFibGUsIHY0X2ltbXV0YWJsZSwgdjVfaW1tdXRhYmxlLCB2Nl9pbW11dGFibGUsIHY3X2ltbXV0YWJsZSwgc19pbW11dGFibGUsIHRfaW1tdXRhYmxlLCByX2ltbXV0YWJsZSBdICkgPT4ge1xyXG5cclxuXHRjb25zdCByID0gZmxvYXQoIHJfaW1tdXRhYmxlICkudG9WYXIoKTtcclxuXHRjb25zdCB0ID0gZmxvYXQoIHRfaW1tdXRhYmxlICkudG9WYXIoKTtcclxuXHRjb25zdCBzID0gZmxvYXQoIHNfaW1tdXRhYmxlICkudG9WYXIoKTtcclxuXHRjb25zdCB2NyA9IGZsb2F0KCB2N19pbW11dGFibGUgKS50b1ZhcigpO1xyXG5cdGNvbnN0IHY2ID0gZmxvYXQoIHY2X2ltbXV0YWJsZSApLnRvVmFyKCk7XHJcblx0Y29uc3QgdjUgPSBmbG9hdCggdjVfaW1tdXRhYmxlICkudG9WYXIoKTtcclxuXHRjb25zdCB2NCA9IGZsb2F0KCB2NF9pbW11dGFibGUgKS50b1ZhcigpO1xyXG5cdGNvbnN0IHYzID0gZmxvYXQoIHYzX2ltbXV0YWJsZSApLnRvVmFyKCk7XHJcblx0Y29uc3QgdjIgPSBmbG9hdCggdjJfaW1tdXRhYmxlICkudG9WYXIoKTtcclxuXHRjb25zdCB2MSA9IGZsb2F0KCB2MV9pbW11dGFibGUgKS50b1ZhcigpO1xyXG5cdGNvbnN0IHYwID0gZmxvYXQoIHYwX2ltbXV0YWJsZSApLnRvVmFyKCk7XHJcblx0Y29uc3QgczEgPSBmbG9hdCggc3ViKCAxLjAsIHMgKSApLnRvVmFyKCk7XHJcblx0Y29uc3QgdDEgPSBmbG9hdCggc3ViKCAxLjAsIHQgKSApLnRvVmFyKCk7XHJcblx0Y29uc3QgcjEgPSBmbG9hdCggc3ViKCAxLjAsIHIgKSApLnRvVmFyKCk7XHJcblxyXG5cdHJldHVybiByMS5tdWwoIHQxLm11bCggdjAubXVsKCBzMSApLmFkZCggdjEubXVsKCBzICkgKSApLmFkZCggdC5tdWwoIHYyLm11bCggczEgKS5hZGQoIHYzLm11bCggcyApICkgKSApICkuYWRkKCByLm11bCggdDEubXVsKCB2NC5tdWwoIHMxICkuYWRkKCB2NS5tdWwoIHMgKSApICkuYWRkKCB0Lm11bCggdjYubXVsKCBzMSApLmFkZCggdjcubXVsKCBzICkgKSApICkgKSApO1xyXG5cclxufSApLnNldExheW91dCgge1xyXG5cdG5hbWU6ICdteF90cmlsZXJwXzAnLFxyXG5cdHR5cGU6ICdmbG9hdCcsXHJcblx0aW5wdXRzOiBbXHJcblx0XHR7IG5hbWU6ICd2MCcsIHR5cGU6ICdmbG9hdCcgfSxcclxuXHRcdHsgbmFtZTogJ3YxJywgdHlwZTogJ2Zsb2F0JyB9LFxyXG5cdFx0eyBuYW1lOiAndjInLCB0eXBlOiAnZmxvYXQnIH0sXHJcblx0XHR7IG5hbWU6ICd2MycsIHR5cGU6ICdmbG9hdCcgfSxcclxuXHRcdHsgbmFtZTogJ3Y0JywgdHlwZTogJ2Zsb2F0JyB9LFxyXG5cdFx0eyBuYW1lOiAndjUnLCB0eXBlOiAnZmxvYXQnIH0sXHJcblx0XHR7IG5hbWU6ICd2NicsIHR5cGU6ICdmbG9hdCcgfSxcclxuXHRcdHsgbmFtZTogJ3Y3JywgdHlwZTogJ2Zsb2F0JyB9LFxyXG5cdFx0eyBuYW1lOiAncycsIHR5cGU6ICdmbG9hdCcgfSxcclxuXHRcdHsgbmFtZTogJ3QnLCB0eXBlOiAnZmxvYXQnIH0sXHJcblx0XHR7IG5hbWU6ICdyJywgdHlwZTogJ2Zsb2F0JyB9XHJcblx0XVxyXG59ICk7XHJcblxyXG5leHBvcnQgY29uc3QgbXhfdHJpbGVycF8xID0gLypAX19QVVJFX18qLyBGbiggKCBbIHYwX2ltbXV0YWJsZSwgdjFfaW1tdXRhYmxlLCB2Ml9pbW11dGFibGUsIHYzX2ltbXV0YWJsZSwgdjRfaW1tdXRhYmxlLCB2NV9pbW11dGFibGUsIHY2X2ltbXV0YWJsZSwgdjdfaW1tdXRhYmxlLCBzX2ltbXV0YWJsZSwgdF9pbW11dGFibGUsIHJfaW1tdXRhYmxlIF0gKSA9PiB7XHJcblxyXG5cdGNvbnN0IHIgPSBmbG9hdCggcl9pbW11dGFibGUgKS50b1ZhcigpO1xyXG5cdGNvbnN0IHQgPSBmbG9hdCggdF9pbW11dGFibGUgKS50b1ZhcigpO1xyXG5cdGNvbnN0IHMgPSBmbG9hdCggc19pbW11dGFibGUgKS50b1ZhcigpO1xyXG5cdGNvbnN0IHY3ID0gdmVjMyggdjdfaW1tdXRhYmxlICkudG9WYXIoKTtcclxuXHRjb25zdCB2NiA9IHZlYzMoIHY2X2ltbXV0YWJsZSApLnRvVmFyKCk7XHJcblx0Y29uc3QgdjUgPSB2ZWMzKCB2NV9pbW11dGFibGUgKS50b1ZhcigpO1xyXG5cdGNvbnN0IHY0ID0gdmVjMyggdjRfaW1tdXRhYmxlICkudG9WYXIoKTtcclxuXHRjb25zdCB2MyA9IHZlYzMoIHYzX2ltbXV0YWJsZSApLnRvVmFyKCk7XHJcblx0Y29uc3QgdjIgPSB2ZWMzKCB2Ml9pbW11dGFibGUgKS50b1ZhcigpO1xyXG5cdGNvbnN0IHYxID0gdmVjMyggdjFfaW1tdXRhYmxlICkudG9WYXIoKTtcclxuXHRjb25zdCB2MCA9IHZlYzMoIHYwX2ltbXV0YWJsZSApLnRvVmFyKCk7XHJcblx0Y29uc3QgczEgPSBmbG9hdCggc3ViKCAxLjAsIHMgKSApLnRvVmFyKCk7XHJcblx0Y29uc3QgdDEgPSBmbG9hdCggc3ViKCAxLjAsIHQgKSApLnRvVmFyKCk7XHJcblx0Y29uc3QgcjEgPSBmbG9hdCggc3ViKCAxLjAsIHIgKSApLnRvVmFyKCk7XHJcblxyXG5cdHJldHVybiByMS5tdWwoIHQxLm11bCggdjAubXVsKCBzMSApLmFkZCggdjEubXVsKCBzICkgKSApLmFkZCggdC5tdWwoIHYyLm11bCggczEgKS5hZGQoIHYzLm11bCggcyApICkgKSApICkuYWRkKCByLm11bCggdDEubXVsKCB2NC5tdWwoIHMxICkuYWRkKCB2NS5tdWwoIHMgKSApICkuYWRkKCB0Lm11bCggdjYubXVsKCBzMSApLmFkZCggdjcubXVsKCBzICkgKSApICkgKSApO1xyXG5cclxufSApLnNldExheW91dCgge1xyXG5cdG5hbWU6ICdteF90cmlsZXJwXzEnLFxyXG5cdHR5cGU6ICd2ZWMzJyxcclxuXHRpbnB1dHM6IFtcclxuXHRcdHsgbmFtZTogJ3YwJywgdHlwZTogJ3ZlYzMnIH0sXHJcblx0XHR7IG5hbWU6ICd2MScsIHR5cGU6ICd2ZWMzJyB9LFxyXG5cdFx0eyBuYW1lOiAndjInLCB0eXBlOiAndmVjMycgfSxcclxuXHRcdHsgbmFtZTogJ3YzJywgdHlwZTogJ3ZlYzMnIH0sXHJcblx0XHR7IG5hbWU6ICd2NCcsIHR5cGU6ICd2ZWMzJyB9LFxyXG5cdFx0eyBuYW1lOiAndjUnLCB0eXBlOiAndmVjMycgfSxcclxuXHRcdHsgbmFtZTogJ3Y2JywgdHlwZTogJ3ZlYzMnIH0sXHJcblx0XHR7IG5hbWU6ICd2NycsIHR5cGU6ICd2ZWMzJyB9LFxyXG5cdFx0eyBuYW1lOiAncycsIHR5cGU6ICdmbG9hdCcgfSxcclxuXHRcdHsgbmFtZTogJ3QnLCB0eXBlOiAnZmxvYXQnIH0sXHJcblx0XHR7IG5hbWU6ICdyJywgdHlwZTogJ2Zsb2F0JyB9XHJcblx0XVxyXG59ICk7XHJcblxyXG5leHBvcnQgY29uc3QgbXhfdHJpbGVycCA9IC8qQF9fUFVSRV9fKi8gb3ZlcmxvYWRpbmdGbiggWyBteF90cmlsZXJwXzAsIG14X3RyaWxlcnBfMSBdICk7XHJcblxyXG5leHBvcnQgY29uc3QgbXhfZ3JhZGllbnRfZmxvYXRfMCA9IC8qQF9fUFVSRV9fKi8gRm4oICggWyBoYXNoX2ltbXV0YWJsZSwgeF9pbW11dGFibGUsIHlfaW1tdXRhYmxlIF0gKSA9PiB7XHJcblxyXG5cdGNvbnN0IHkgPSBmbG9hdCggeV9pbW11dGFibGUgKS50b1ZhcigpO1xyXG5cdGNvbnN0IHggPSBmbG9hdCggeF9pbW11dGFibGUgKS50b1ZhcigpO1xyXG5cdGNvbnN0IGhhc2ggPSB1aW50KCBoYXNoX2ltbXV0YWJsZSApLnRvVmFyKCk7XHJcblx0Y29uc3QgaCA9IHVpbnQoIGhhc2guYml0QW5kKCB1aW50KCA3ICkgKSApLnRvVmFyKCk7XHJcblx0Y29uc3QgdSA9IGZsb2F0KCBteF9zZWxlY3QoIGgubGVzc1RoYW4oIHVpbnQoIDQgKSApLCB4LCB5ICkgKS50b1ZhcigpO1xyXG5cdGNvbnN0IHYgPSBmbG9hdCggbXVsKCAyLjAsIG14X3NlbGVjdCggaC5sZXNzVGhhbiggdWludCggNCApICksIHksIHggKSApICkudG9WYXIoKTtcclxuXHJcblx0cmV0dXJuIG14X25lZ2F0ZV9pZiggdSwgYm9vbCggaC5iaXRBbmQoIHVpbnQoIDEgKSApICkgKS5hZGQoIG14X25lZ2F0ZV9pZiggdiwgYm9vbCggaC5iaXRBbmQoIHVpbnQoIDIgKSApICkgKSApO1xyXG5cclxufSApLnNldExheW91dCgge1xyXG5cdG5hbWU6ICdteF9ncmFkaWVudF9mbG9hdF8wJyxcclxuXHR0eXBlOiAnZmxvYXQnLFxyXG5cdGlucHV0czogW1xyXG5cdFx0eyBuYW1lOiAnaGFzaCcsIHR5cGU6ICd1aW50JyB9LFxyXG5cdFx0eyBuYW1lOiAneCcsIHR5cGU6ICdmbG9hdCcgfSxcclxuXHRcdHsgbmFtZTogJ3knLCB0eXBlOiAnZmxvYXQnIH1cclxuXHRdXHJcbn0gKTtcclxuXHJcbmV4cG9ydCBjb25zdCBteF9ncmFkaWVudF9mbG9hdF8xID0gLypAX19QVVJFX18qLyBGbiggKCBbIGhhc2hfaW1tdXRhYmxlLCB4X2ltbXV0YWJsZSwgeV9pbW11dGFibGUsIHpfaW1tdXRhYmxlIF0gKSA9PiB7XHJcblxyXG5cdGNvbnN0IHogPSBmbG9hdCggel9pbW11dGFibGUgKS50b1ZhcigpO1xyXG5cdGNvbnN0IHkgPSBmbG9hdCggeV9pbW11dGFibGUgKS50b1ZhcigpO1xyXG5cdGNvbnN0IHggPSBmbG9hdCggeF9pbW11dGFibGUgKS50b1ZhcigpO1xyXG5cdGNvbnN0IGhhc2ggPSB1aW50KCBoYXNoX2ltbXV0YWJsZSApLnRvVmFyKCk7XHJcblx0Y29uc3QgaCA9IHVpbnQoIGhhc2guYml0QW5kKCB1aW50KCAxNSApICkgKS50b1ZhcigpO1xyXG5cdGNvbnN0IHUgPSBmbG9hdCggbXhfc2VsZWN0KCBoLmxlc3NUaGFuKCB1aW50KCA4ICkgKSwgeCwgeSApICkudG9WYXIoKTtcclxuXHRjb25zdCB2ID0gZmxvYXQoIG14X3NlbGVjdCggaC5sZXNzVGhhbiggdWludCggNCApICksIHksIG14X3NlbGVjdCggaC5lcXVhbCggdWludCggMTIgKSApLm9yKCBoLmVxdWFsKCB1aW50KCAxNCApICkgKSwgeCwgeiApICkgKS50b1ZhcigpO1xyXG5cclxuXHRyZXR1cm4gbXhfbmVnYXRlX2lmKCB1LCBib29sKCBoLmJpdEFuZCggdWludCggMSApICkgKSApLmFkZCggbXhfbmVnYXRlX2lmKCB2LCBib29sKCBoLmJpdEFuZCggdWludCggMiApICkgKSApICk7XHJcblxyXG59ICkuc2V0TGF5b3V0KCB7XHJcblx0bmFtZTogJ214X2dyYWRpZW50X2Zsb2F0XzEnLFxyXG5cdHR5cGU6ICdmbG9hdCcsXHJcblx0aW5wdXRzOiBbXHJcblx0XHR7IG5hbWU6ICdoYXNoJywgdHlwZTogJ3VpbnQnIH0sXHJcblx0XHR7IG5hbWU6ICd4JywgdHlwZTogJ2Zsb2F0JyB9LFxyXG5cdFx0eyBuYW1lOiAneScsIHR5cGU6ICdmbG9hdCcgfSxcclxuXHRcdHsgbmFtZTogJ3onLCB0eXBlOiAnZmxvYXQnIH1cclxuXHRdXHJcbn0gKTtcclxuXHJcbmV4cG9ydCBjb25zdCBteF9ncmFkaWVudF9mbG9hdCA9IC8qQF9fUFVSRV9fKi8gb3ZlcmxvYWRpbmdGbiggWyBteF9ncmFkaWVudF9mbG9hdF8wLCBteF9ncmFkaWVudF9mbG9hdF8xIF0gKTtcclxuXHJcbmV4cG9ydCBjb25zdCBteF9ncmFkaWVudF92ZWMzXzAgPSAvKkBfX1BVUkVfXyovIEZuKCAoIFsgaGFzaF9pbW11dGFibGUsIHhfaW1tdXRhYmxlLCB5X2ltbXV0YWJsZSBdICkgPT4ge1xyXG5cclxuXHRjb25zdCB5ID0gZmxvYXQoIHlfaW1tdXRhYmxlICkudG9WYXIoKTtcclxuXHRjb25zdCB4ID0gZmxvYXQoIHhfaW1tdXRhYmxlICkudG9WYXIoKTtcclxuXHRjb25zdCBoYXNoID0gdXZlYzMoIGhhc2hfaW1tdXRhYmxlICkudG9WYXIoKTtcclxuXHJcblx0cmV0dXJuIHZlYzMoIG14X2dyYWRpZW50X2Zsb2F0KCBoYXNoLngsIHgsIHkgKSwgbXhfZ3JhZGllbnRfZmxvYXQoIGhhc2gueSwgeCwgeSApLCBteF9ncmFkaWVudF9mbG9hdCggaGFzaC56LCB4LCB5ICkgKTtcclxuXHJcbn0gKS5zZXRMYXlvdXQoIHtcclxuXHRuYW1lOiAnbXhfZ3JhZGllbnRfdmVjM18wJyxcclxuXHR0eXBlOiAndmVjMycsXHJcblx0aW5wdXRzOiBbXHJcblx0XHR7IG5hbWU6ICdoYXNoJywgdHlwZTogJ3V2ZWMzJyB9LFxyXG5cdFx0eyBuYW1lOiAneCcsIHR5cGU6ICdmbG9hdCcgfSxcclxuXHRcdHsgbmFtZTogJ3knLCB0eXBlOiAnZmxvYXQnIH1cclxuXHRdXHJcbn0gKTtcclxuXHJcbmV4cG9ydCBjb25zdCBteF9ncmFkaWVudF92ZWMzXzEgPSAvKkBfX1BVUkVfXyovIEZuKCAoIFsgaGFzaF9pbW11dGFibGUsIHhfaW1tdXRhYmxlLCB5X2ltbXV0YWJsZSwgel9pbW11dGFibGUgXSApID0+IHtcclxuXHJcblx0Y29uc3QgeiA9IGZsb2F0KCB6X2ltbXV0YWJsZSApLnRvVmFyKCk7XHJcblx0Y29uc3QgeSA9IGZsb2F0KCB5X2ltbXV0YWJsZSApLnRvVmFyKCk7XHJcblx0Y29uc3QgeCA9IGZsb2F0KCB4X2ltbXV0YWJsZSApLnRvVmFyKCk7XHJcblx0Y29uc3QgaGFzaCA9IHV2ZWMzKCBoYXNoX2ltbXV0YWJsZSApLnRvVmFyKCk7XHJcblxyXG5cdHJldHVybiB2ZWMzKCBteF9ncmFkaWVudF9mbG9hdCggaGFzaC54LCB4LCB5LCB6ICksIG14X2dyYWRpZW50X2Zsb2F0KCBoYXNoLnksIHgsIHksIHogKSwgbXhfZ3JhZGllbnRfZmxvYXQoIGhhc2gueiwgeCwgeSwgeiApICk7XHJcblxyXG59ICkuc2V0TGF5b3V0KCB7XHJcblx0bmFtZTogJ214X2dyYWRpZW50X3ZlYzNfMScsXHJcblx0dHlwZTogJ3ZlYzMnLFxyXG5cdGlucHV0czogW1xyXG5cdFx0eyBuYW1lOiAnaGFzaCcsIHR5cGU6ICd1dmVjMycgfSxcclxuXHRcdHsgbmFtZTogJ3gnLCB0eXBlOiAnZmxvYXQnIH0sXHJcblx0XHR7IG5hbWU6ICd5JywgdHlwZTogJ2Zsb2F0JyB9LFxyXG5cdFx0eyBuYW1lOiAneicsIHR5cGU6ICdmbG9hdCcgfVxyXG5cdF1cclxufSApO1xyXG5cclxuZXhwb3J0IGNvbnN0IG14X2dyYWRpZW50X3ZlYzMgPSAvKkBfX1BVUkVfXyovIG92ZXJsb2FkaW5nRm4oIFsgbXhfZ3JhZGllbnRfdmVjM18wLCBteF9ncmFkaWVudF92ZWMzXzEgXSApO1xyXG5cclxuZXhwb3J0IGNvbnN0IG14X2dyYWRpZW50X3NjYWxlMmRfMCA9IC8qQF9fUFVSRV9fKi8gRm4oICggWyB2X2ltbXV0YWJsZSBdICkgPT4ge1xyXG5cclxuXHRjb25zdCB2ID0gZmxvYXQoIHZfaW1tdXRhYmxlICkudG9WYXIoKTtcclxuXHJcblx0cmV0dXJuIG11bCggMC42NjE2LCB2ICk7XHJcblxyXG59ICkuc2V0TGF5b3V0KCB7XHJcblx0bmFtZTogJ214X2dyYWRpZW50X3NjYWxlMmRfMCcsXHJcblx0dHlwZTogJ2Zsb2F0JyxcclxuXHRpbnB1dHM6IFtcclxuXHRcdHsgbmFtZTogJ3YnLCB0eXBlOiAnZmxvYXQnIH1cclxuXHRdXHJcbn0gKTtcclxuXHJcbmV4cG9ydCBjb25zdCBteF9ncmFkaWVudF9zY2FsZTNkXzAgPSAvKkBfX1BVUkVfXyovIEZuKCAoIFsgdl9pbW11dGFibGUgXSApID0+IHtcclxuXHJcblx0Y29uc3QgdiA9IGZsb2F0KCB2X2ltbXV0YWJsZSApLnRvVmFyKCk7XHJcblxyXG5cdHJldHVybiBtdWwoIDAuOTgyMCwgdiApO1xyXG5cclxufSApLnNldExheW91dCgge1xyXG5cdG5hbWU6ICdteF9ncmFkaWVudF9zY2FsZTNkXzAnLFxyXG5cdHR5cGU6ICdmbG9hdCcsXHJcblx0aW5wdXRzOiBbXHJcblx0XHR7IG5hbWU6ICd2JywgdHlwZTogJ2Zsb2F0JyB9XHJcblx0XVxyXG59ICk7XHJcblxyXG5leHBvcnQgY29uc3QgbXhfZ3JhZGllbnRfc2NhbGUyZF8xID0gLypAX19QVVJFX18qLyBGbiggKCBbIHZfaW1tdXRhYmxlIF0gKSA9PiB7XHJcblxyXG5cdGNvbnN0IHYgPSB2ZWMzKCB2X2ltbXV0YWJsZSApLnRvVmFyKCk7XHJcblxyXG5cdHJldHVybiBtdWwoIDAuNjYxNiwgdiApO1xyXG5cclxufSApLnNldExheW91dCgge1xyXG5cdG5hbWU6ICdteF9ncmFkaWVudF9zY2FsZTJkXzEnLFxyXG5cdHR5cGU6ICd2ZWMzJyxcclxuXHRpbnB1dHM6IFtcclxuXHRcdHsgbmFtZTogJ3YnLCB0eXBlOiAndmVjMycgfVxyXG5cdF1cclxufSApO1xyXG5cclxuZXhwb3J0IGNvbnN0IG14X2dyYWRpZW50X3NjYWxlMmQgPSAvKkBfX1BVUkVfXyovIG92ZXJsb2FkaW5nRm4oIFsgbXhfZ3JhZGllbnRfc2NhbGUyZF8wLCBteF9ncmFkaWVudF9zY2FsZTJkXzEgXSApO1xyXG5cclxuZXhwb3J0IGNvbnN0IG14X2dyYWRpZW50X3NjYWxlM2RfMSA9IC8qQF9fUFVSRV9fKi8gRm4oICggWyB2X2ltbXV0YWJsZSBdICkgPT4ge1xyXG5cclxuXHRjb25zdCB2ID0gdmVjMyggdl9pbW11dGFibGUgKS50b1ZhcigpO1xyXG5cclxuXHRyZXR1cm4gbXVsKCAwLjk4MjAsIHYgKTtcclxuXHJcbn0gKS5zZXRMYXlvdXQoIHtcclxuXHRuYW1lOiAnbXhfZ3JhZGllbnRfc2NhbGUzZF8xJyxcclxuXHR0eXBlOiAndmVjMycsXHJcblx0aW5wdXRzOiBbXHJcblx0XHR7IG5hbWU6ICd2JywgdHlwZTogJ3ZlYzMnIH1cclxuXHRdXHJcbn0gKTtcclxuXHJcbmV4cG9ydCBjb25zdCBteF9ncmFkaWVudF9zY2FsZTNkID0gLypAX19QVVJFX18qLyBvdmVybG9hZGluZ0ZuKCBbIG14X2dyYWRpZW50X3NjYWxlM2RfMCwgbXhfZ3JhZGllbnRfc2NhbGUzZF8xIF0gKTtcclxuXHJcbmV4cG9ydCBjb25zdCBteF9yb3RsMzIgPSAvKkBfX1BVUkVfXyovIEZuKCAoIFsgeF9pbW11dGFibGUsIGtfaW1tdXRhYmxlIF0gKSA9PiB7XHJcblxyXG5cdGNvbnN0IGsgPSBpbnQoIGtfaW1tdXRhYmxlICkudG9WYXIoKTtcclxuXHRjb25zdCB4ID0gdWludCggeF9pbW11dGFibGUgKS50b1ZhcigpO1xyXG5cclxuXHRyZXR1cm4geC5zaGlmdExlZnQoIGsgKS5iaXRPciggeC5zaGlmdFJpZ2h0KCBpbnQoIDMyICkuc3ViKCBrICkgKSApO1xyXG5cclxufSApLnNldExheW91dCgge1xyXG5cdG5hbWU6ICdteF9yb3RsMzInLFxyXG5cdHR5cGU6ICd1aW50JyxcclxuXHRpbnB1dHM6IFtcclxuXHRcdHsgbmFtZTogJ3gnLCB0eXBlOiAndWludCcgfSxcclxuXHRcdHsgbmFtZTogJ2snLCB0eXBlOiAnaW50JyB9XHJcblx0XVxyXG59ICk7XHJcblxyXG5leHBvcnQgY29uc3QgbXhfYmptaXggPSAvKkBfX1BVUkVfXyovIEZuKCAoIFsgYSwgYiwgYyBdICkgPT4ge1xyXG5cclxuXHRhLnN1YkFzc2lnbiggYyApO1xyXG5cdGEuYml0WG9yQXNzaWduKCBteF9yb3RsMzIoIGMsIGludCggNCApICkgKTtcclxuXHRjLmFkZEFzc2lnbiggYiApO1xyXG5cdGIuc3ViQXNzaWduKCBhICk7XHJcblx0Yi5iaXRYb3JBc3NpZ24oIG14X3JvdGwzMiggYSwgaW50KCA2ICkgKSApO1xyXG5cdGEuYWRkQXNzaWduKCBjICk7XHJcblx0Yy5zdWJBc3NpZ24oIGIgKTtcclxuXHRjLmJpdFhvckFzc2lnbiggbXhfcm90bDMyKCBiLCBpbnQoIDggKSApICk7XHJcblx0Yi5hZGRBc3NpZ24oIGEgKTtcclxuXHRhLnN1YkFzc2lnbiggYyApO1xyXG5cdGEuYml0WG9yQXNzaWduKCBteF9yb3RsMzIoIGMsIGludCggMTYgKSApICk7XHJcblx0Yy5hZGRBc3NpZ24oIGIgKTtcclxuXHRiLnN1YkFzc2lnbiggYSApO1xyXG5cdGIuYml0WG9yQXNzaWduKCBteF9yb3RsMzIoIGEsIGludCggMTkgKSApICk7XHJcblx0YS5hZGRBc3NpZ24oIGMgKTtcclxuXHRjLnN1YkFzc2lnbiggYiApO1xyXG5cdGMuYml0WG9yQXNzaWduKCBteF9yb3RsMzIoIGIsIGludCggNCApICkgKTtcclxuXHRiLmFkZEFzc2lnbiggYSApO1xyXG5cclxufSApO1xyXG5cclxuZXhwb3J0IGNvbnN0IG14X2JqZmluYWwgPSAvKkBfX1BVUkVfXyovIEZuKCAoIFsgYV9pbW11dGFibGUsIGJfaW1tdXRhYmxlLCBjX2ltbXV0YWJsZSBdICkgPT4ge1xyXG5cclxuXHRjb25zdCBjID0gdWludCggY19pbW11dGFibGUgKS50b1ZhcigpO1xyXG5cdGNvbnN0IGIgPSB1aW50KCBiX2ltbXV0YWJsZSApLnRvVmFyKCk7XHJcblx0Y29uc3QgYSA9IHVpbnQoIGFfaW1tdXRhYmxlICkudG9WYXIoKTtcclxuXHRjLmJpdFhvckFzc2lnbiggYiApO1xyXG5cdGMuc3ViQXNzaWduKCBteF9yb3RsMzIoIGIsIGludCggMTQgKSApICk7XHJcblx0YS5iaXRYb3JBc3NpZ24oIGMgKTtcclxuXHRhLnN1YkFzc2lnbiggbXhfcm90bDMyKCBjLCBpbnQoIDExICkgKSApO1xyXG5cdGIuYml0WG9yQXNzaWduKCBhICk7XHJcblx0Yi5zdWJBc3NpZ24oIG14X3JvdGwzMiggYSwgaW50KCAyNSApICkgKTtcclxuXHRjLmJpdFhvckFzc2lnbiggYiApO1xyXG5cdGMuc3ViQXNzaWduKCBteF9yb3RsMzIoIGIsIGludCggMTYgKSApICk7XHJcblx0YS5iaXRYb3JBc3NpZ24oIGMgKTtcclxuXHRhLnN1YkFzc2lnbiggbXhfcm90bDMyKCBjLCBpbnQoIDQgKSApICk7XHJcblx0Yi5iaXRYb3JBc3NpZ24oIGEgKTtcclxuXHRiLnN1YkFzc2lnbiggbXhfcm90bDMyKCBhLCBpbnQoIDE0ICkgKSApO1xyXG5cdGMuYml0WG9yQXNzaWduKCBiICk7XHJcblx0Yy5zdWJBc3NpZ24oIG14X3JvdGwzMiggYiwgaW50KCAyNCApICkgKTtcclxuXHJcblx0cmV0dXJuIGM7XHJcblxyXG59ICkuc2V0TGF5b3V0KCB7XHJcblx0bmFtZTogJ214X2JqZmluYWwnLFxyXG5cdHR5cGU6ICd1aW50JyxcclxuXHRpbnB1dHM6IFtcclxuXHRcdHsgbmFtZTogJ2EnLCB0eXBlOiAndWludCcgfSxcclxuXHRcdHsgbmFtZTogJ2InLCB0eXBlOiAndWludCcgfSxcclxuXHRcdHsgbmFtZTogJ2MnLCB0eXBlOiAndWludCcgfVxyXG5cdF1cclxufSApO1xyXG5cclxuZXhwb3J0IGNvbnN0IG14X2JpdHNfdG9fMDEgPSAvKkBfX1BVUkVfXyovIEZuKCAoIFsgYml0c19pbW11dGFibGUgXSApID0+IHtcclxuXHJcblx0Y29uc3QgYml0cyA9IHVpbnQoIGJpdHNfaW1tdXRhYmxlICkudG9WYXIoKTtcclxuXHJcblx0cmV0dXJuIGZsb2F0KCBiaXRzICkuZGl2KCBmbG9hdCggdWludCggaW50KCAweGZmZmZmZmZmICkgKSApICk7XHJcblxyXG59ICkuc2V0TGF5b3V0KCB7XHJcblx0bmFtZTogJ214X2JpdHNfdG9fMDEnLFxyXG5cdHR5cGU6ICdmbG9hdCcsXHJcblx0aW5wdXRzOiBbXHJcblx0XHR7IG5hbWU6ICdiaXRzJywgdHlwZTogJ3VpbnQnIH1cclxuXHRdXHJcbn0gKTtcclxuXHJcbmV4cG9ydCBjb25zdCBteF9mYWRlID0gLypAX19QVVJFX18qLyBGbiggKCBbIHRfaW1tdXRhYmxlIF0gKSA9PiB7XHJcblxyXG5cdGNvbnN0IHQgPSBmbG9hdCggdF9pbW11dGFibGUgKS50b1ZhcigpO1xyXG5cclxuXHRyZXR1cm4gdC5tdWwoIHQgKS5tdWwoIHQgKS5tdWwoIHQubXVsKCB0Lm11bCggNi4wICkuc3ViKCAxNS4wICkgKS5hZGQoIDEwLjAgKSApO1xyXG5cclxufSApLnNldExheW91dCgge1xyXG5cdG5hbWU6ICdteF9mYWRlJyxcclxuXHR0eXBlOiAnZmxvYXQnLFxyXG5cdGlucHV0czogW1xyXG5cdFx0eyBuYW1lOiAndCcsIHR5cGU6ICdmbG9hdCcgfVxyXG5cdF1cclxufSApO1xyXG5cclxuZXhwb3J0IGNvbnN0IG14X2hhc2hfaW50XzAgPSAvKkBfX1BVUkVfXyovIEZuKCAoIFsgeF9pbW11dGFibGUgXSApID0+IHtcclxuXHJcblx0Y29uc3QgeCA9IGludCggeF9pbW11dGFibGUgKS50b1ZhcigpO1xyXG5cdGNvbnN0IGxlbiA9IHVpbnQoIHVpbnQoIDEgKSApLnRvVmFyKCk7XHJcblx0Y29uc3Qgc2VlZCA9IHVpbnQoIHVpbnQoIGludCggMHhkZWFkYmVlZiApICkuYWRkKCBsZW4uc2hpZnRMZWZ0KCB1aW50KCAyICkgKSApLmFkZCggdWludCggMTMgKSApICkudG9WYXIoKTtcclxuXHJcblx0cmV0dXJuIG14X2JqZmluYWwoIHNlZWQuYWRkKCB1aW50KCB4ICkgKSwgc2VlZCwgc2VlZCApO1xyXG5cclxufSApLnNldExheW91dCgge1xyXG5cdG5hbWU6ICdteF9oYXNoX2ludF8wJyxcclxuXHR0eXBlOiAndWludCcsXHJcblx0aW5wdXRzOiBbXHJcblx0XHR7IG5hbWU6ICd4JywgdHlwZTogJ2ludCcgfVxyXG5cdF1cclxufSApO1xyXG5cclxuZXhwb3J0IGNvbnN0IG14X2hhc2hfaW50XzEgPSAvKkBfX1BVUkVfXyovIEZuKCAoIFsgeF9pbW11dGFibGUsIHlfaW1tdXRhYmxlIF0gKSA9PiB7XHJcblxyXG5cdGNvbnN0IHkgPSBpbnQoIHlfaW1tdXRhYmxlICkudG9WYXIoKTtcclxuXHRjb25zdCB4ID0gaW50KCB4X2ltbXV0YWJsZSApLnRvVmFyKCk7XHJcblx0Y29uc3QgbGVuID0gdWludCggdWludCggMiApICkudG9WYXIoKTtcclxuXHRjb25zdCBhID0gdWludCgpLnRvVmFyKCksIGIgPSB1aW50KCkudG9WYXIoKSwgYyA9IHVpbnQoKS50b1ZhcigpO1xyXG5cdGEuYXNzaWduKCBiLmFzc2lnbiggYy5hc3NpZ24oIHVpbnQoIGludCggMHhkZWFkYmVlZiApICkuYWRkKCBsZW4uc2hpZnRMZWZ0KCB1aW50KCAyICkgKSApLmFkZCggdWludCggMTMgKSApICkgKSApO1xyXG5cdGEuYWRkQXNzaWduKCB1aW50KCB4ICkgKTtcclxuXHRiLmFkZEFzc2lnbiggdWludCggeSApICk7XHJcblxyXG5cdHJldHVybiBteF9iamZpbmFsKCBhLCBiLCBjICk7XHJcblxyXG59ICkuc2V0TGF5b3V0KCB7XHJcblx0bmFtZTogJ214X2hhc2hfaW50XzEnLFxyXG5cdHR5cGU6ICd1aW50JyxcclxuXHRpbnB1dHM6IFtcclxuXHRcdHsgbmFtZTogJ3gnLCB0eXBlOiAnaW50JyB9LFxyXG5cdFx0eyBuYW1lOiAneScsIHR5cGU6ICdpbnQnIH1cclxuXHRdXHJcbn0gKTtcclxuXHJcbmV4cG9ydCBjb25zdCBteF9oYXNoX2ludF8yID0gLypAX19QVVJFX18qLyBGbiggKCBbIHhfaW1tdXRhYmxlLCB5X2ltbXV0YWJsZSwgel9pbW11dGFibGUgXSApID0+IHtcclxuXHJcblx0Y29uc3QgeiA9IGludCggel9pbW11dGFibGUgKS50b1ZhcigpO1xyXG5cdGNvbnN0IHkgPSBpbnQoIHlfaW1tdXRhYmxlICkudG9WYXIoKTtcclxuXHRjb25zdCB4ID0gaW50KCB4X2ltbXV0YWJsZSApLnRvVmFyKCk7XHJcblx0Y29uc3QgbGVuID0gdWludCggdWludCggMyApICkudG9WYXIoKTtcclxuXHRjb25zdCBhID0gdWludCgpLnRvVmFyKCksIGIgPSB1aW50KCkudG9WYXIoKSwgYyA9IHVpbnQoKS50b1ZhcigpO1xyXG5cdGEuYXNzaWduKCBiLmFzc2lnbiggYy5hc3NpZ24oIHVpbnQoIGludCggMHhkZWFkYmVlZiApICkuYWRkKCBsZW4uc2hpZnRMZWZ0KCB1aW50KCAyICkgKSApLmFkZCggdWludCggMTMgKSApICkgKSApO1xyXG5cdGEuYWRkQXNzaWduKCB1aW50KCB4ICkgKTtcclxuXHRiLmFkZEFzc2lnbiggdWludCggeSApICk7XHJcblx0Yy5hZGRBc3NpZ24oIHVpbnQoIHogKSApO1xyXG5cclxuXHRyZXR1cm4gbXhfYmpmaW5hbCggYSwgYiwgYyApO1xyXG5cclxufSApLnNldExheW91dCgge1xyXG5cdG5hbWU6ICdteF9oYXNoX2ludF8yJyxcclxuXHR0eXBlOiAndWludCcsXHJcblx0aW5wdXRzOiBbXHJcblx0XHR7IG5hbWU6ICd4JywgdHlwZTogJ2ludCcgfSxcclxuXHRcdHsgbmFtZTogJ3knLCB0eXBlOiAnaW50JyB9LFxyXG5cdFx0eyBuYW1lOiAneicsIHR5cGU6ICdpbnQnIH1cclxuXHRdXHJcbn0gKTtcclxuXHJcbmV4cG9ydCBjb25zdCBteF9oYXNoX2ludF8zID0gLypAX19QVVJFX18qLyBGbiggKCBbIHhfaW1tdXRhYmxlLCB5X2ltbXV0YWJsZSwgel9pbW11dGFibGUsIHh4X2ltbXV0YWJsZSBdICkgPT4ge1xyXG5cclxuXHRjb25zdCB4eCA9IGludCggeHhfaW1tdXRhYmxlICkudG9WYXIoKTtcclxuXHRjb25zdCB6ID0gaW50KCB6X2ltbXV0YWJsZSApLnRvVmFyKCk7XHJcblx0Y29uc3QgeSA9IGludCggeV9pbW11dGFibGUgKS50b1ZhcigpO1xyXG5cdGNvbnN0IHggPSBpbnQoIHhfaW1tdXRhYmxlICkudG9WYXIoKTtcclxuXHRjb25zdCBsZW4gPSB1aW50KCB1aW50KCA0ICkgKS50b1ZhcigpO1xyXG5cdGNvbnN0IGEgPSB1aW50KCkudG9WYXIoKSwgYiA9IHVpbnQoKS50b1ZhcigpLCBjID0gdWludCgpLnRvVmFyKCk7XHJcblx0YS5hc3NpZ24oIGIuYXNzaWduKCBjLmFzc2lnbiggdWludCggaW50KCAweGRlYWRiZWVmICkgKS5hZGQoIGxlbi5zaGlmdExlZnQoIHVpbnQoIDIgKSApICkuYWRkKCB1aW50KCAxMyApICkgKSApICk7XHJcblx0YS5hZGRBc3NpZ24oIHVpbnQoIHggKSApO1xyXG5cdGIuYWRkQXNzaWduKCB1aW50KCB5ICkgKTtcclxuXHRjLmFkZEFzc2lnbiggdWludCggeiApICk7XHJcblx0bXhfYmptaXgoIGEsIGIsIGMgKTtcclxuXHRhLmFkZEFzc2lnbiggdWludCggeHggKSApO1xyXG5cclxuXHRyZXR1cm4gbXhfYmpmaW5hbCggYSwgYiwgYyApO1xyXG5cclxufSApLnNldExheW91dCgge1xyXG5cdG5hbWU6ICdteF9oYXNoX2ludF8zJyxcclxuXHR0eXBlOiAndWludCcsXHJcblx0aW5wdXRzOiBbXHJcblx0XHR7IG5hbWU6ICd4JywgdHlwZTogJ2ludCcgfSxcclxuXHRcdHsgbmFtZTogJ3knLCB0eXBlOiAnaW50JyB9LFxyXG5cdFx0eyBuYW1lOiAneicsIHR5cGU6ICdpbnQnIH0sXHJcblx0XHR7IG5hbWU6ICd4eCcsIHR5cGU6ICdpbnQnIH1cclxuXHRdXHJcbn0gKTtcclxuXHJcbmV4cG9ydCBjb25zdCBteF9oYXNoX2ludF80ID0gLypAX19QVVJFX18qLyBGbiggKCBbIHhfaW1tdXRhYmxlLCB5X2ltbXV0YWJsZSwgel9pbW11dGFibGUsIHh4X2ltbXV0YWJsZSwgeXlfaW1tdXRhYmxlIF0gKSA9PiB7XHJcblxyXG5cdGNvbnN0IHl5ID0gaW50KCB5eV9pbW11dGFibGUgKS50b1ZhcigpO1xyXG5cdGNvbnN0IHh4ID0gaW50KCB4eF9pbW11dGFibGUgKS50b1ZhcigpO1xyXG5cdGNvbnN0IHogPSBpbnQoIHpfaW1tdXRhYmxlICkudG9WYXIoKTtcclxuXHRjb25zdCB5ID0gaW50KCB5X2ltbXV0YWJsZSApLnRvVmFyKCk7XHJcblx0Y29uc3QgeCA9IGludCggeF9pbW11dGFibGUgKS50b1ZhcigpO1xyXG5cdGNvbnN0IGxlbiA9IHVpbnQoIHVpbnQoIDUgKSApLnRvVmFyKCk7XHJcblx0Y29uc3QgYSA9IHVpbnQoKS50b1ZhcigpLCBiID0gdWludCgpLnRvVmFyKCksIGMgPSB1aW50KCkudG9WYXIoKTtcclxuXHRhLmFzc2lnbiggYi5hc3NpZ24oIGMuYXNzaWduKCB1aW50KCBpbnQoIDB4ZGVhZGJlZWYgKSApLmFkZCggbGVuLnNoaWZ0TGVmdCggdWludCggMiApICkgKS5hZGQoIHVpbnQoIDEzICkgKSApICkgKTtcclxuXHRhLmFkZEFzc2lnbiggdWludCggeCApICk7XHJcblx0Yi5hZGRBc3NpZ24oIHVpbnQoIHkgKSApO1xyXG5cdGMuYWRkQXNzaWduKCB1aW50KCB6ICkgKTtcclxuXHRteF9iam1peCggYSwgYiwgYyApO1xyXG5cdGEuYWRkQXNzaWduKCB1aW50KCB4eCApICk7XHJcblx0Yi5hZGRBc3NpZ24oIHVpbnQoIHl5ICkgKTtcclxuXHJcblx0cmV0dXJuIG14X2JqZmluYWwoIGEsIGIsIGMgKTtcclxuXHJcbn0gKS5zZXRMYXlvdXQoIHtcclxuXHRuYW1lOiAnbXhfaGFzaF9pbnRfNCcsXHJcblx0dHlwZTogJ3VpbnQnLFxyXG5cdGlucHV0czogW1xyXG5cdFx0eyBuYW1lOiAneCcsIHR5cGU6ICdpbnQnIH0sXHJcblx0XHR7IG5hbWU6ICd5JywgdHlwZTogJ2ludCcgfSxcclxuXHRcdHsgbmFtZTogJ3onLCB0eXBlOiAnaW50JyB9LFxyXG5cdFx0eyBuYW1lOiAneHgnLCB0eXBlOiAnaW50JyB9LFxyXG5cdFx0eyBuYW1lOiAneXknLCB0eXBlOiAnaW50JyB9XHJcblx0XVxyXG59ICk7XHJcblxyXG5leHBvcnQgY29uc3QgbXhfaGFzaF9pbnQgPSAvKkBfX1BVUkVfXyovIG92ZXJsb2FkaW5nRm4oIFsgbXhfaGFzaF9pbnRfMCwgbXhfaGFzaF9pbnRfMSwgbXhfaGFzaF9pbnRfMiwgbXhfaGFzaF9pbnRfMywgbXhfaGFzaF9pbnRfNCBdICk7XHJcblxyXG5leHBvcnQgY29uc3QgbXhfaGFzaF92ZWMzXzAgPSAvKkBfX1BVUkVfXyovIEZuKCAoIFsgeF9pbW11dGFibGUsIHlfaW1tdXRhYmxlIF0gKSA9PiB7XHJcblxyXG5cdGNvbnN0IHkgPSBpbnQoIHlfaW1tdXRhYmxlICkudG9WYXIoKTtcclxuXHRjb25zdCB4ID0gaW50KCB4X2ltbXV0YWJsZSApLnRvVmFyKCk7XHJcblx0Y29uc3QgaCA9IHVpbnQoIG14X2hhc2hfaW50KCB4LCB5ICkgKS50b1ZhcigpO1xyXG5cdGNvbnN0IHJlc3VsdCA9IHV2ZWMzKCkudG9WYXIoKTtcclxuXHRyZXN1bHQueC5hc3NpZ24oIGguYml0QW5kKCBpbnQoIDB4RkYgKSApICk7XHJcblx0cmVzdWx0LnkuYXNzaWduKCBoLnNoaWZ0UmlnaHQoIGludCggOCApICkuYml0QW5kKCBpbnQoIDB4RkYgKSApICk7XHJcblx0cmVzdWx0LnouYXNzaWduKCBoLnNoaWZ0UmlnaHQoIGludCggMTYgKSApLmJpdEFuZCggaW50KCAweEZGICkgKSApO1xyXG5cclxuXHRyZXR1cm4gcmVzdWx0O1xyXG5cclxufSApLnNldExheW91dCgge1xyXG5cdG5hbWU6ICdteF9oYXNoX3ZlYzNfMCcsXHJcblx0dHlwZTogJ3V2ZWMzJyxcclxuXHRpbnB1dHM6IFtcclxuXHRcdHsgbmFtZTogJ3gnLCB0eXBlOiAnaW50JyB9LFxyXG5cdFx0eyBuYW1lOiAneScsIHR5cGU6ICdpbnQnIH1cclxuXHRdXHJcbn0gKTtcclxuXHJcbmV4cG9ydCBjb25zdCBteF9oYXNoX3ZlYzNfMSA9IC8qQF9fUFVSRV9fKi8gRm4oICggWyB4X2ltbXV0YWJsZSwgeV9pbW11dGFibGUsIHpfaW1tdXRhYmxlIF0gKSA9PiB7XHJcblxyXG5cdGNvbnN0IHogPSBpbnQoIHpfaW1tdXRhYmxlICkudG9WYXIoKTtcclxuXHRjb25zdCB5ID0gaW50KCB5X2ltbXV0YWJsZSApLnRvVmFyKCk7XHJcblx0Y29uc3QgeCA9IGludCggeF9pbW11dGFibGUgKS50b1ZhcigpO1xyXG5cdGNvbnN0IGggPSB1aW50KCBteF9oYXNoX2ludCggeCwgeSwgeiApICkudG9WYXIoKTtcclxuXHRjb25zdCByZXN1bHQgPSB1dmVjMygpLnRvVmFyKCk7XHJcblx0cmVzdWx0LnguYXNzaWduKCBoLmJpdEFuZCggaW50KCAweEZGICkgKSApO1xyXG5cdHJlc3VsdC55LmFzc2lnbiggaC5zaGlmdFJpZ2h0KCBpbnQoIDggKSApLmJpdEFuZCggaW50KCAweEZGICkgKSApO1xyXG5cdHJlc3VsdC56LmFzc2lnbiggaC5zaGlmdFJpZ2h0KCBpbnQoIDE2ICkgKS5iaXRBbmQoIGludCggMHhGRiApICkgKTtcclxuXHJcblx0cmV0dXJuIHJlc3VsdDtcclxuXHJcbn0gKS5zZXRMYXlvdXQoIHtcclxuXHRuYW1lOiAnbXhfaGFzaF92ZWMzXzEnLFxyXG5cdHR5cGU6ICd1dmVjMycsXHJcblx0aW5wdXRzOiBbXHJcblx0XHR7IG5hbWU6ICd4JywgdHlwZTogJ2ludCcgfSxcclxuXHRcdHsgbmFtZTogJ3knLCB0eXBlOiAnaW50JyB9LFxyXG5cdFx0eyBuYW1lOiAneicsIHR5cGU6ICdpbnQnIH1cclxuXHRdXHJcbn0gKTtcclxuXHJcbmV4cG9ydCBjb25zdCBteF9oYXNoX3ZlYzMgPSAvKkBfX1BVUkVfXyovIG92ZXJsb2FkaW5nRm4oIFsgbXhfaGFzaF92ZWMzXzAsIG14X2hhc2hfdmVjM18xIF0gKTtcclxuXHJcbmV4cG9ydCBjb25zdCBteF9wZXJsaW5fbm9pc2VfZmxvYXRfMCA9IC8qQF9fUFVSRV9fKi8gRm4oICggWyBwX2ltbXV0YWJsZSBdICkgPT4ge1xyXG5cclxuXHRjb25zdCBwID0gdmVjMiggcF9pbW11dGFibGUgKS50b1ZhcigpO1xyXG5cdGNvbnN0IFggPSBpbnQoKS50b1ZhcigpLCBZID0gaW50KCkudG9WYXIoKTtcclxuXHRjb25zdCBmeCA9IGZsb2F0KCBteF9mbG9vcmZyYWMoIHAueCwgWCApICkudG9WYXIoKTtcclxuXHRjb25zdCBmeSA9IGZsb2F0KCBteF9mbG9vcmZyYWMoIHAueSwgWSApICkudG9WYXIoKTtcclxuXHRjb25zdCB1ID0gZmxvYXQoIG14X2ZhZGUoIGZ4ICkgKS50b1ZhcigpO1xyXG5cdGNvbnN0IHYgPSBmbG9hdCggbXhfZmFkZSggZnkgKSApLnRvVmFyKCk7XHJcblx0Y29uc3QgcmVzdWx0ID0gZmxvYXQoIG14X2JpbGVycCggbXhfZ3JhZGllbnRfZmxvYXQoIG14X2hhc2hfaW50KCBYLCBZICksIGZ4LCBmeSApLCBteF9ncmFkaWVudF9mbG9hdCggbXhfaGFzaF9pbnQoIFguYWRkKCBpbnQoIDEgKSApLCBZICksIGZ4LnN1YiggMS4wICksIGZ5ICksIG14X2dyYWRpZW50X2Zsb2F0KCBteF9oYXNoX2ludCggWCwgWS5hZGQoIGludCggMSApICkgKSwgZngsIGZ5LnN1YiggMS4wICkgKSwgbXhfZ3JhZGllbnRfZmxvYXQoIG14X2hhc2hfaW50KCBYLmFkZCggaW50KCAxICkgKSwgWS5hZGQoIGludCggMSApICkgKSwgZnguc3ViKCAxLjAgKSwgZnkuc3ViKCAxLjAgKSApLCB1LCB2ICkgKS50b1ZhcigpO1xyXG5cclxuXHRyZXR1cm4gbXhfZ3JhZGllbnRfc2NhbGUyZCggcmVzdWx0ICk7XHJcblxyXG59ICkuc2V0TGF5b3V0KCB7XHJcblx0bmFtZTogJ214X3Blcmxpbl9ub2lzZV9mbG9hdF8wJyxcclxuXHR0eXBlOiAnZmxvYXQnLFxyXG5cdGlucHV0czogW1xyXG5cdFx0eyBuYW1lOiAncCcsIHR5cGU6ICd2ZWMyJyB9XHJcblx0XVxyXG59ICk7XHJcblxyXG5leHBvcnQgY29uc3QgbXhfcGVybGluX25vaXNlX2Zsb2F0XzEgPSAvKkBfX1BVUkVfXyovIEZuKCAoIFsgcF9pbW11dGFibGUgXSApID0+IHtcclxuXHJcblx0Y29uc3QgcCA9IHZlYzMoIHBfaW1tdXRhYmxlICkudG9WYXIoKTtcclxuXHRjb25zdCBYID0gaW50KCkudG9WYXIoKSwgWSA9IGludCgpLnRvVmFyKCksIFogPSBpbnQoKS50b1ZhcigpO1xyXG5cdGNvbnN0IGZ4ID0gZmxvYXQoIG14X2Zsb29yZnJhYyggcC54LCBYICkgKS50b1ZhcigpO1xyXG5cdGNvbnN0IGZ5ID0gZmxvYXQoIG14X2Zsb29yZnJhYyggcC55LCBZICkgKS50b1ZhcigpO1xyXG5cdGNvbnN0IGZ6ID0gZmxvYXQoIG14X2Zsb29yZnJhYyggcC56LCBaICkgKS50b1ZhcigpO1xyXG5cdGNvbnN0IHUgPSBmbG9hdCggbXhfZmFkZSggZnggKSApLnRvVmFyKCk7XHJcblx0Y29uc3QgdiA9IGZsb2F0KCBteF9mYWRlKCBmeSApICkudG9WYXIoKTtcclxuXHRjb25zdCB3ID0gZmxvYXQoIG14X2ZhZGUoIGZ6ICkgKS50b1ZhcigpO1xyXG5cdGNvbnN0IHJlc3VsdCA9IGZsb2F0KCBteF90cmlsZXJwKCBteF9ncmFkaWVudF9mbG9hdCggbXhfaGFzaF9pbnQoIFgsIFksIFogKSwgZngsIGZ5LCBmeiApLCBteF9ncmFkaWVudF9mbG9hdCggbXhfaGFzaF9pbnQoIFguYWRkKCBpbnQoIDEgKSApLCBZLCBaICksIGZ4LnN1YiggMS4wICksIGZ5LCBmeiApLCBteF9ncmFkaWVudF9mbG9hdCggbXhfaGFzaF9pbnQoIFgsIFkuYWRkKCBpbnQoIDEgKSApLCBaICksIGZ4LCBmeS5zdWIoIDEuMCApLCBmeiApLCBteF9ncmFkaWVudF9mbG9hdCggbXhfaGFzaF9pbnQoIFguYWRkKCBpbnQoIDEgKSApLCBZLmFkZCggaW50KCAxICkgKSwgWiApLCBmeC5zdWIoIDEuMCApLCBmeS5zdWIoIDEuMCApLCBmeiApLCBteF9ncmFkaWVudF9mbG9hdCggbXhfaGFzaF9pbnQoIFgsIFksIFouYWRkKCBpbnQoIDEgKSApICksIGZ4LCBmeSwgZnouc3ViKCAxLjAgKSApLCBteF9ncmFkaWVudF9mbG9hdCggbXhfaGFzaF9pbnQoIFguYWRkKCBpbnQoIDEgKSApLCBZLCBaLmFkZCggaW50KCAxICkgKSApLCBmeC5zdWIoIDEuMCApLCBmeSwgZnouc3ViKCAxLjAgKSApLCBteF9ncmFkaWVudF9mbG9hdCggbXhfaGFzaF9pbnQoIFgsIFkuYWRkKCBpbnQoIDEgKSApLCBaLmFkZCggaW50KCAxICkgKSApLCBmeCwgZnkuc3ViKCAxLjAgKSwgZnouc3ViKCAxLjAgKSApLCBteF9ncmFkaWVudF9mbG9hdCggbXhfaGFzaF9pbnQoIFguYWRkKCBpbnQoIDEgKSApLCBZLmFkZCggaW50KCAxICkgKSwgWi5hZGQoIGludCggMSApICkgKSwgZnguc3ViKCAxLjAgKSwgZnkuc3ViKCAxLjAgKSwgZnouc3ViKCAxLjAgKSApLCB1LCB2LCB3ICkgKS50b1ZhcigpO1xyXG5cclxuXHRyZXR1cm4gbXhfZ3JhZGllbnRfc2NhbGUzZCggcmVzdWx0ICk7XHJcblxyXG59ICkuc2V0TGF5b3V0KCB7XHJcblx0bmFtZTogJ214X3Blcmxpbl9ub2lzZV9mbG9hdF8xJyxcclxuXHR0eXBlOiAnZmxvYXQnLFxyXG5cdGlucHV0czogW1xyXG5cdFx0eyBuYW1lOiAncCcsIHR5cGU6ICd2ZWMzJyB9XHJcblx0XVxyXG59ICk7XHJcblxyXG5leHBvcnQgY29uc3QgbXhfcGVybGluX25vaXNlX2Zsb2F0ID0gLypAX19QVVJFX18qLyBvdmVybG9hZGluZ0ZuKCBbIG14X3Blcmxpbl9ub2lzZV9mbG9hdF8wLCBteF9wZXJsaW5fbm9pc2VfZmxvYXRfMSBdICk7XHJcblxyXG5leHBvcnQgY29uc3QgbXhfcGVybGluX25vaXNlX3ZlYzNfMCA9IC8qQF9fUFVSRV9fKi8gRm4oICggWyBwX2ltbXV0YWJsZSBdICkgPT4ge1xyXG5cclxuXHRjb25zdCBwID0gdmVjMiggcF9pbW11dGFibGUgKS50b1ZhcigpO1xyXG5cdGNvbnN0IFggPSBpbnQoKS50b1ZhcigpLCBZID0gaW50KCkudG9WYXIoKTtcclxuXHRjb25zdCBmeCA9IGZsb2F0KCBteF9mbG9vcmZyYWMoIHAueCwgWCApICkudG9WYXIoKTtcclxuXHRjb25zdCBmeSA9IGZsb2F0KCBteF9mbG9vcmZyYWMoIHAueSwgWSApICkudG9WYXIoKTtcclxuXHRjb25zdCB1ID0gZmxvYXQoIG14X2ZhZGUoIGZ4ICkgKS50b1ZhcigpO1xyXG5cdGNvbnN0IHYgPSBmbG9hdCggbXhfZmFkZSggZnkgKSApLnRvVmFyKCk7XHJcblx0Y29uc3QgcmVzdWx0ID0gdmVjMyggbXhfYmlsZXJwKCBteF9ncmFkaWVudF92ZWMzKCBteF9oYXNoX3ZlYzMoIFgsIFkgKSwgZngsIGZ5ICksIG14X2dyYWRpZW50X3ZlYzMoIG14X2hhc2hfdmVjMyggWC5hZGQoIGludCggMSApICksIFkgKSwgZnguc3ViKCAxLjAgKSwgZnkgKSwgbXhfZ3JhZGllbnRfdmVjMyggbXhfaGFzaF92ZWMzKCBYLCBZLmFkZCggaW50KCAxICkgKSApLCBmeCwgZnkuc3ViKCAxLjAgKSApLCBteF9ncmFkaWVudF92ZWMzKCBteF9oYXNoX3ZlYzMoIFguYWRkKCBpbnQoIDEgKSApLCBZLmFkZCggaW50KCAxICkgKSApLCBmeC5zdWIoIDEuMCApLCBmeS5zdWIoIDEuMCApICksIHUsIHYgKSApLnRvVmFyKCk7XHJcblxyXG5cdHJldHVybiBteF9ncmFkaWVudF9zY2FsZTJkKCByZXN1bHQgKTtcclxuXHJcbn0gKS5zZXRMYXlvdXQoIHtcclxuXHRuYW1lOiAnbXhfcGVybGluX25vaXNlX3ZlYzNfMCcsXHJcblx0dHlwZTogJ3ZlYzMnLFxyXG5cdGlucHV0czogW1xyXG5cdFx0eyBuYW1lOiAncCcsIHR5cGU6ICd2ZWMyJyB9XHJcblx0XVxyXG59ICk7XHJcblxyXG5leHBvcnQgY29uc3QgbXhfcGVybGluX25vaXNlX3ZlYzNfMSA9IC8qQF9fUFVSRV9fKi8gRm4oICggWyBwX2ltbXV0YWJsZSBdICkgPT4ge1xyXG5cclxuXHRjb25zdCBwID0gdmVjMyggcF9pbW11dGFibGUgKS50b1ZhcigpO1xyXG5cdGNvbnN0IFggPSBpbnQoKS50b1ZhcigpLCBZID0gaW50KCkudG9WYXIoKSwgWiA9IGludCgpLnRvVmFyKCk7XHJcblx0Y29uc3QgZnggPSBmbG9hdCggbXhfZmxvb3JmcmFjKCBwLngsIFggKSApLnRvVmFyKCk7XHJcblx0Y29uc3QgZnkgPSBmbG9hdCggbXhfZmxvb3JmcmFjKCBwLnksIFkgKSApLnRvVmFyKCk7XHJcblx0Y29uc3QgZnogPSBmbG9hdCggbXhfZmxvb3JmcmFjKCBwLnosIFogKSApLnRvVmFyKCk7XHJcblx0Y29uc3QgdSA9IGZsb2F0KCBteF9mYWRlKCBmeCApICkudG9WYXIoKTtcclxuXHRjb25zdCB2ID0gZmxvYXQoIG14X2ZhZGUoIGZ5ICkgKS50b1ZhcigpO1xyXG5cdGNvbnN0IHcgPSBmbG9hdCggbXhfZmFkZSggZnogKSApLnRvVmFyKCk7XHJcblx0Y29uc3QgcmVzdWx0ID0gdmVjMyggbXhfdHJpbGVycCggbXhfZ3JhZGllbnRfdmVjMyggbXhfaGFzaF92ZWMzKCBYLCBZLCBaICksIGZ4LCBmeSwgZnogKSwgbXhfZ3JhZGllbnRfdmVjMyggbXhfaGFzaF92ZWMzKCBYLmFkZCggaW50KCAxICkgKSwgWSwgWiApLCBmeC5zdWIoIDEuMCApLCBmeSwgZnogKSwgbXhfZ3JhZGllbnRfdmVjMyggbXhfaGFzaF92ZWMzKCBYLCBZLmFkZCggaW50KCAxICkgKSwgWiApLCBmeCwgZnkuc3ViKCAxLjAgKSwgZnogKSwgbXhfZ3JhZGllbnRfdmVjMyggbXhfaGFzaF92ZWMzKCBYLmFkZCggaW50KCAxICkgKSwgWS5hZGQoIGludCggMSApICksIFogKSwgZnguc3ViKCAxLjAgKSwgZnkuc3ViKCAxLjAgKSwgZnogKSwgbXhfZ3JhZGllbnRfdmVjMyggbXhfaGFzaF92ZWMzKCBYLCBZLCBaLmFkZCggaW50KCAxICkgKSApLCBmeCwgZnksIGZ6LnN1YiggMS4wICkgKSwgbXhfZ3JhZGllbnRfdmVjMyggbXhfaGFzaF92ZWMzKCBYLmFkZCggaW50KCAxICkgKSwgWSwgWi5hZGQoIGludCggMSApICkgKSwgZnguc3ViKCAxLjAgKSwgZnksIGZ6LnN1YiggMS4wICkgKSwgbXhfZ3JhZGllbnRfdmVjMyggbXhfaGFzaF92ZWMzKCBYLCBZLmFkZCggaW50KCAxICkgKSwgWi5hZGQoIGludCggMSApICkgKSwgZngsIGZ5LnN1YiggMS4wICksIGZ6LnN1YiggMS4wICkgKSwgbXhfZ3JhZGllbnRfdmVjMyggbXhfaGFzaF92ZWMzKCBYLmFkZCggaW50KCAxICkgKSwgWS5hZGQoIGludCggMSApICksIFouYWRkKCBpbnQoIDEgKSApICksIGZ4LnN1YiggMS4wICksIGZ5LnN1YiggMS4wICksIGZ6LnN1YiggMS4wICkgKSwgdSwgdiwgdyApICkudG9WYXIoKTtcclxuXHJcblx0cmV0dXJuIG14X2dyYWRpZW50X3NjYWxlM2QoIHJlc3VsdCApO1xyXG5cclxufSApLnNldExheW91dCgge1xyXG5cdG5hbWU6ICdteF9wZXJsaW5fbm9pc2VfdmVjM18xJyxcclxuXHR0eXBlOiAndmVjMycsXHJcblx0aW5wdXRzOiBbXHJcblx0XHR7IG5hbWU6ICdwJywgdHlwZTogJ3ZlYzMnIH1cclxuXHRdXHJcbn0gKTtcclxuXHJcbmV4cG9ydCBjb25zdCBteF9wZXJsaW5fbm9pc2VfdmVjMyA9IC8qQF9fUFVSRV9fKi8gb3ZlcmxvYWRpbmdGbiggWyBteF9wZXJsaW5fbm9pc2VfdmVjM18wLCBteF9wZXJsaW5fbm9pc2VfdmVjM18xIF0gKTtcclxuXHJcbmV4cG9ydCBjb25zdCBteF9jZWxsX25vaXNlX2Zsb2F0XzAgPSAvKkBfX1BVUkVfXyovIEZuKCAoIFsgcF9pbW11dGFibGUgXSApID0+IHtcclxuXHJcblx0Y29uc3QgcCA9IGZsb2F0KCBwX2ltbXV0YWJsZSApLnRvVmFyKCk7XHJcblx0Y29uc3QgaXggPSBpbnQoIG14X2Zsb29yKCBwICkgKS50b1ZhcigpO1xyXG5cclxuXHRyZXR1cm4gbXhfYml0c190b18wMSggbXhfaGFzaF9pbnQoIGl4ICkgKTtcclxuXHJcbn0gKS5zZXRMYXlvdXQoIHtcclxuXHRuYW1lOiAnbXhfY2VsbF9ub2lzZV9mbG9hdF8wJyxcclxuXHR0eXBlOiAnZmxvYXQnLFxyXG5cdGlucHV0czogW1xyXG5cdFx0eyBuYW1lOiAncCcsIHR5cGU6ICdmbG9hdCcgfVxyXG5cdF1cclxufSApO1xyXG5cclxuZXhwb3J0IGNvbnN0IG14X2NlbGxfbm9pc2VfZmxvYXRfMSA9IC8qQF9fUFVSRV9fKi8gRm4oICggWyBwX2ltbXV0YWJsZSBdICkgPT4ge1xyXG5cclxuXHRjb25zdCBwID0gdmVjMiggcF9pbW11dGFibGUgKS50b1ZhcigpO1xyXG5cdGNvbnN0IGl4ID0gaW50KCBteF9mbG9vciggcC54ICkgKS50b1ZhcigpO1xyXG5cdGNvbnN0IGl5ID0gaW50KCBteF9mbG9vciggcC55ICkgKS50b1ZhcigpO1xyXG5cclxuXHRyZXR1cm4gbXhfYml0c190b18wMSggbXhfaGFzaF9pbnQoIGl4LCBpeSApICk7XHJcblxyXG59ICkuc2V0TGF5b3V0KCB7XHJcblx0bmFtZTogJ214X2NlbGxfbm9pc2VfZmxvYXRfMScsXHJcblx0dHlwZTogJ2Zsb2F0JyxcclxuXHRpbnB1dHM6IFtcclxuXHRcdHsgbmFtZTogJ3AnLCB0eXBlOiAndmVjMicgfVxyXG5cdF1cclxufSApO1xyXG5cclxuZXhwb3J0IGNvbnN0IG14X2NlbGxfbm9pc2VfZmxvYXRfMiA9IC8qQF9fUFVSRV9fKi8gRm4oICggWyBwX2ltbXV0YWJsZSBdICkgPT4ge1xyXG5cclxuXHRjb25zdCBwID0gdmVjMyggcF9pbW11dGFibGUgKS50b1ZhcigpO1xyXG5cdGNvbnN0IGl4ID0gaW50KCBteF9mbG9vciggcC54ICkgKS50b1ZhcigpO1xyXG5cdGNvbnN0IGl5ID0gaW50KCBteF9mbG9vciggcC55ICkgKS50b1ZhcigpO1xyXG5cdGNvbnN0IGl6ID0gaW50KCBteF9mbG9vciggcC56ICkgKS50b1ZhcigpO1xyXG5cclxuXHRyZXR1cm4gbXhfYml0c190b18wMSggbXhfaGFzaF9pbnQoIGl4LCBpeSwgaXogKSApO1xyXG5cclxufSApLnNldExheW91dCgge1xyXG5cdG5hbWU6ICdteF9jZWxsX25vaXNlX2Zsb2F0XzInLFxyXG5cdHR5cGU6ICdmbG9hdCcsXHJcblx0aW5wdXRzOiBbXHJcblx0XHR7IG5hbWU6ICdwJywgdHlwZTogJ3ZlYzMnIH1cclxuXHRdXHJcbn0gKTtcclxuXHJcbmV4cG9ydCBjb25zdCBteF9jZWxsX25vaXNlX2Zsb2F0XzMgPSAvKkBfX1BVUkVfXyovIEZuKCAoIFsgcF9pbW11dGFibGUgXSApID0+IHtcclxuXHJcblx0Y29uc3QgcCA9IHZlYzQoIHBfaW1tdXRhYmxlICkudG9WYXIoKTtcclxuXHRjb25zdCBpeCA9IGludCggbXhfZmxvb3IoIHAueCApICkudG9WYXIoKTtcclxuXHRjb25zdCBpeSA9IGludCggbXhfZmxvb3IoIHAueSApICkudG9WYXIoKTtcclxuXHRjb25zdCBpeiA9IGludCggbXhfZmxvb3IoIHAueiApICkudG9WYXIoKTtcclxuXHRjb25zdCBpdyA9IGludCggbXhfZmxvb3IoIHAudyApICkudG9WYXIoKTtcclxuXHJcblx0cmV0dXJuIG14X2JpdHNfdG9fMDEoIG14X2hhc2hfaW50KCBpeCwgaXksIGl6LCBpdyApICk7XHJcblxyXG59ICkuc2V0TGF5b3V0KCB7XHJcblx0bmFtZTogJ214X2NlbGxfbm9pc2VfZmxvYXRfMycsXHJcblx0dHlwZTogJ2Zsb2F0JyxcclxuXHRpbnB1dHM6IFtcclxuXHRcdHsgbmFtZTogJ3AnLCB0eXBlOiAndmVjNCcgfVxyXG5cdF1cclxufSApO1xyXG5cclxuZXhwb3J0IGNvbnN0IG14X2NlbGxfbm9pc2VfZmxvYXQgPSAvKkBfX1BVUkVfXyovIG92ZXJsb2FkaW5nRm4oIFsgbXhfY2VsbF9ub2lzZV9mbG9hdF8wLCBteF9jZWxsX25vaXNlX2Zsb2F0XzEsIG14X2NlbGxfbm9pc2VfZmxvYXRfMiwgbXhfY2VsbF9ub2lzZV9mbG9hdF8zIF0gKTtcclxuXHJcbmV4cG9ydCBjb25zdCBteF9jZWxsX25vaXNlX3ZlYzNfMCA9IC8qQF9fUFVSRV9fKi8gRm4oICggWyBwX2ltbXV0YWJsZSBdICkgPT4ge1xyXG5cclxuXHRjb25zdCBwID0gZmxvYXQoIHBfaW1tdXRhYmxlICkudG9WYXIoKTtcclxuXHRjb25zdCBpeCA9IGludCggbXhfZmxvb3IoIHAgKSApLnRvVmFyKCk7XHJcblxyXG5cdHJldHVybiB2ZWMzKCBteF9iaXRzX3RvXzAxKCBteF9oYXNoX2ludCggaXgsIGludCggMCApICkgKSwgbXhfYml0c190b18wMSggbXhfaGFzaF9pbnQoIGl4LCBpbnQoIDEgKSApICksIG14X2JpdHNfdG9fMDEoIG14X2hhc2hfaW50KCBpeCwgaW50KCAyICkgKSApICk7XHJcblxyXG59ICkuc2V0TGF5b3V0KCB7XHJcblx0bmFtZTogJ214X2NlbGxfbm9pc2VfdmVjM18wJyxcclxuXHR0eXBlOiAndmVjMycsXHJcblx0aW5wdXRzOiBbXHJcblx0XHR7IG5hbWU6ICdwJywgdHlwZTogJ2Zsb2F0JyB9XHJcblx0XVxyXG59ICk7XHJcblxyXG5leHBvcnQgY29uc3QgbXhfY2VsbF9ub2lzZV92ZWMzXzEgPSAvKkBfX1BVUkVfXyovIEZuKCAoIFsgcF9pbW11dGFibGUgXSApID0+IHtcclxuXHJcblx0Y29uc3QgcCA9IHZlYzIoIHBfaW1tdXRhYmxlICkudG9WYXIoKTtcclxuXHRjb25zdCBpeCA9IGludCggbXhfZmxvb3IoIHAueCApICkudG9WYXIoKTtcclxuXHRjb25zdCBpeSA9IGludCggbXhfZmxvb3IoIHAueSApICkudG9WYXIoKTtcclxuXHJcblx0cmV0dXJuIHZlYzMoIG14X2JpdHNfdG9fMDEoIG14X2hhc2hfaW50KCBpeCwgaXksIGludCggMCApICkgKSwgbXhfYml0c190b18wMSggbXhfaGFzaF9pbnQoIGl4LCBpeSwgaW50KCAxICkgKSApLCBteF9iaXRzX3RvXzAxKCBteF9oYXNoX2ludCggaXgsIGl5LCBpbnQoIDIgKSApICkgKTtcclxuXHJcbn0gKS5zZXRMYXlvdXQoIHtcclxuXHRuYW1lOiAnbXhfY2VsbF9ub2lzZV92ZWMzXzEnLFxyXG5cdHR5cGU6ICd2ZWMzJyxcclxuXHRpbnB1dHM6IFtcclxuXHRcdHsgbmFtZTogJ3AnLCB0eXBlOiAndmVjMicgfVxyXG5cdF1cclxufSApO1xyXG5cclxuZXhwb3J0IGNvbnN0IG14X2NlbGxfbm9pc2VfdmVjM18yID0gLypAX19QVVJFX18qLyBGbiggKCBbIHBfaW1tdXRhYmxlIF0gKSA9PiB7XHJcblxyXG5cdGNvbnN0IHAgPSB2ZWMzKCBwX2ltbXV0YWJsZSApLnRvVmFyKCk7XHJcblx0Y29uc3QgaXggPSBpbnQoIG14X2Zsb29yKCBwLnggKSApLnRvVmFyKCk7XHJcblx0Y29uc3QgaXkgPSBpbnQoIG14X2Zsb29yKCBwLnkgKSApLnRvVmFyKCk7XHJcblx0Y29uc3QgaXogPSBpbnQoIG14X2Zsb29yKCBwLnogKSApLnRvVmFyKCk7XHJcblxyXG5cdHJldHVybiB2ZWMzKCBteF9iaXRzX3RvXzAxKCBteF9oYXNoX2ludCggaXgsIGl5LCBpeiwgaW50KCAwICkgKSApLCBteF9iaXRzX3RvXzAxKCBteF9oYXNoX2ludCggaXgsIGl5LCBpeiwgaW50KCAxICkgKSApLCBteF9iaXRzX3RvXzAxKCBteF9oYXNoX2ludCggaXgsIGl5LCBpeiwgaW50KCAyICkgKSApICk7XHJcblxyXG59ICkuc2V0TGF5b3V0KCB7XHJcblx0bmFtZTogJ214X2NlbGxfbm9pc2VfdmVjM18yJyxcclxuXHR0eXBlOiAndmVjMycsXHJcblx0aW5wdXRzOiBbXHJcblx0XHR7IG5hbWU6ICdwJywgdHlwZTogJ3ZlYzMnIH1cclxuXHRdXHJcbn0gKTtcclxuXHJcbmV4cG9ydCBjb25zdCBteF9jZWxsX25vaXNlX3ZlYzNfMyA9IC8qQF9fUFVSRV9fKi8gRm4oICggWyBwX2ltbXV0YWJsZSBdICkgPT4ge1xyXG5cclxuXHRjb25zdCBwID0gdmVjNCggcF9pbW11dGFibGUgKS50b1ZhcigpO1xyXG5cdGNvbnN0IGl4ID0gaW50KCBteF9mbG9vciggcC54ICkgKS50b1ZhcigpO1xyXG5cdGNvbnN0IGl5ID0gaW50KCBteF9mbG9vciggcC55ICkgKS50b1ZhcigpO1xyXG5cdGNvbnN0IGl6ID0gaW50KCBteF9mbG9vciggcC56ICkgKS50b1ZhcigpO1xyXG5cdGNvbnN0IGl3ID0gaW50KCBteF9mbG9vciggcC53ICkgKS50b1ZhcigpO1xyXG5cclxuXHRyZXR1cm4gdmVjMyggbXhfYml0c190b18wMSggbXhfaGFzaF9pbnQoIGl4LCBpeSwgaXosIGl3LCBpbnQoIDAgKSApICksIG14X2JpdHNfdG9fMDEoIG14X2hhc2hfaW50KCBpeCwgaXksIGl6LCBpdywgaW50KCAxICkgKSApLCBteF9iaXRzX3RvXzAxKCBteF9oYXNoX2ludCggaXgsIGl5LCBpeiwgaXcsIGludCggMiApICkgKSApO1xyXG5cclxufSApLnNldExheW91dCgge1xyXG5cdG5hbWU6ICdteF9jZWxsX25vaXNlX3ZlYzNfMycsXHJcblx0dHlwZTogJ3ZlYzMnLFxyXG5cdGlucHV0czogW1xyXG5cdFx0eyBuYW1lOiAncCcsIHR5cGU6ICd2ZWM0JyB9XHJcblx0XVxyXG59ICk7XHJcblxyXG5leHBvcnQgY29uc3QgbXhfY2VsbF9ub2lzZV92ZWMzID0gLypAX19QVVJFX18qLyBvdmVybG9hZGluZ0ZuKCBbIG14X2NlbGxfbm9pc2VfdmVjM18wLCBteF9jZWxsX25vaXNlX3ZlYzNfMSwgbXhfY2VsbF9ub2lzZV92ZWMzXzIsIG14X2NlbGxfbm9pc2VfdmVjM18zIF0gKTtcclxuXHJcbmV4cG9ydCBjb25zdCBteF9mcmFjdGFsX25vaXNlX2Zsb2F0ID0gLypAX19QVVJFX18qLyBGbiggKCBbIHBfaW1tdXRhYmxlLCBvY3RhdmVzX2ltbXV0YWJsZSwgbGFjdW5hcml0eV9pbW11dGFibGUsIGRpbWluaXNoX2ltbXV0YWJsZSBdICkgPT4ge1xyXG5cclxuXHRjb25zdCBkaW1pbmlzaCA9IGZsb2F0KCBkaW1pbmlzaF9pbW11dGFibGUgKS50b1ZhcigpO1xyXG5cdGNvbnN0IGxhY3VuYXJpdHkgPSBmbG9hdCggbGFjdW5hcml0eV9pbW11dGFibGUgKS50b1ZhcigpO1xyXG5cdGNvbnN0IG9jdGF2ZXMgPSBpbnQoIG9jdGF2ZXNfaW1tdXRhYmxlICkudG9WYXIoKTtcclxuXHRjb25zdCBwID0gdmVjMyggcF9pbW11dGFibGUgKS50b1ZhcigpO1xyXG5cdGNvbnN0IHJlc3VsdCA9IGZsb2F0KCAwLjAgKS50b1ZhcigpO1xyXG5cdGNvbnN0IGFtcGxpdHVkZSA9IGZsb2F0KCAxLjAgKS50b1ZhcigpO1xyXG5cclxuXHRMb29wKCBvY3RhdmVzLCAoKSA9PiB7XHJcblxyXG5cdFx0cmVzdWx0LmFkZEFzc2lnbiggYW1wbGl0dWRlLm11bCggbXhfcGVybGluX25vaXNlX2Zsb2F0KCBwICkgKSApO1xyXG5cdFx0YW1wbGl0dWRlLm11bEFzc2lnbiggZGltaW5pc2ggKTtcclxuXHRcdHAubXVsQXNzaWduKCBsYWN1bmFyaXR5ICk7XHJcblxyXG5cdH0gKTtcclxuXHJcblx0cmV0dXJuIHJlc3VsdDtcclxuXHJcbn0gKS5zZXRMYXlvdXQoIHtcclxuXHRuYW1lOiAnbXhfZnJhY3RhbF9ub2lzZV9mbG9hdCcsXHJcblx0dHlwZTogJ2Zsb2F0JyxcclxuXHRpbnB1dHM6IFtcclxuXHRcdHsgbmFtZTogJ3AnLCB0eXBlOiAndmVjMycgfSxcclxuXHRcdHsgbmFtZTogJ29jdGF2ZXMnLCB0eXBlOiAnaW50JyB9LFxyXG5cdFx0eyBuYW1lOiAnbGFjdW5hcml0eScsIHR5cGU6ICdmbG9hdCcgfSxcclxuXHRcdHsgbmFtZTogJ2RpbWluaXNoJywgdHlwZTogJ2Zsb2F0JyB9XHJcblx0XVxyXG59ICk7XHJcblxyXG5leHBvcnQgY29uc3QgbXhfZnJhY3RhbF9ub2lzZV92ZWMzID0gLypAX19QVVJFX18qLyBGbiggKCBbIHBfaW1tdXRhYmxlLCBvY3RhdmVzX2ltbXV0YWJsZSwgbGFjdW5hcml0eV9pbW11dGFibGUsIGRpbWluaXNoX2ltbXV0YWJsZSBdICkgPT4ge1xyXG5cclxuXHRjb25zdCBkaW1pbmlzaCA9IGZsb2F0KCBkaW1pbmlzaF9pbW11dGFibGUgKS50b1ZhcigpO1xyXG5cdGNvbnN0IGxhY3VuYXJpdHkgPSBmbG9hdCggbGFjdW5hcml0eV9pbW11dGFibGUgKS50b1ZhcigpO1xyXG5cdGNvbnN0IG9jdGF2ZXMgPSBpbnQoIG9jdGF2ZXNfaW1tdXRhYmxlICkudG9WYXIoKTtcclxuXHRjb25zdCBwID0gdmVjMyggcF9pbW11dGFibGUgKS50b1ZhcigpO1xyXG5cdGNvbnN0IHJlc3VsdCA9IHZlYzMoIDAuMCApLnRvVmFyKCk7XHJcblx0Y29uc3QgYW1wbGl0dWRlID0gZmxvYXQoIDEuMCApLnRvVmFyKCk7XHJcblxyXG5cdExvb3AoIG9jdGF2ZXMsICgpID0+IHtcclxuXHJcblx0XHRyZXN1bHQuYWRkQXNzaWduKCBhbXBsaXR1ZGUubXVsKCBteF9wZXJsaW5fbm9pc2VfdmVjMyggcCApICkgKTtcclxuXHRcdGFtcGxpdHVkZS5tdWxBc3NpZ24oIGRpbWluaXNoICk7XHJcblx0XHRwLm11bEFzc2lnbiggbGFjdW5hcml0eSApO1xyXG5cclxuXHR9ICk7XHJcblxyXG5cdHJldHVybiByZXN1bHQ7XHJcblxyXG59ICkuc2V0TGF5b3V0KCB7XHJcblx0bmFtZTogJ214X2ZyYWN0YWxfbm9pc2VfdmVjMycsXHJcblx0dHlwZTogJ3ZlYzMnLFxyXG5cdGlucHV0czogW1xyXG5cdFx0eyBuYW1lOiAncCcsIHR5cGU6ICd2ZWMzJyB9LFxyXG5cdFx0eyBuYW1lOiAnb2N0YXZlcycsIHR5cGU6ICdpbnQnIH0sXHJcblx0XHR7IG5hbWU6ICdsYWN1bmFyaXR5JywgdHlwZTogJ2Zsb2F0JyB9LFxyXG5cdFx0eyBuYW1lOiAnZGltaW5pc2gnLCB0eXBlOiAnZmxvYXQnIH1cclxuXHRdXHJcbn0gKTtcclxuXHJcbmV4cG9ydCBjb25zdCBteF9mcmFjdGFsX25vaXNlX3ZlYzIgPSAvKkBfX1BVUkVfXyovIEZuKCAoIFsgcF9pbW11dGFibGUsIG9jdGF2ZXNfaW1tdXRhYmxlLCBsYWN1bmFyaXR5X2ltbXV0YWJsZSwgZGltaW5pc2hfaW1tdXRhYmxlIF0gKSA9PiB7XHJcblxyXG5cdGNvbnN0IGRpbWluaXNoID0gZmxvYXQoIGRpbWluaXNoX2ltbXV0YWJsZSApLnRvVmFyKCk7XHJcblx0Y29uc3QgbGFjdW5hcml0eSA9IGZsb2F0KCBsYWN1bmFyaXR5X2ltbXV0YWJsZSApLnRvVmFyKCk7XHJcblx0Y29uc3Qgb2N0YXZlcyA9IGludCggb2N0YXZlc19pbW11dGFibGUgKS50b1ZhcigpO1xyXG5cdGNvbnN0IHAgPSB2ZWMzKCBwX2ltbXV0YWJsZSApLnRvVmFyKCk7XHJcblxyXG5cdHJldHVybiB2ZWMyKCBteF9mcmFjdGFsX25vaXNlX2Zsb2F0KCBwLCBvY3RhdmVzLCBsYWN1bmFyaXR5LCBkaW1pbmlzaCApLCBteF9mcmFjdGFsX25vaXNlX2Zsb2F0KCBwLmFkZCggdmVjMyggaW50KCAxOSApLCBpbnQoIDE5MyApLCBpbnQoIDE3ICkgKSApLCBvY3RhdmVzLCBsYWN1bmFyaXR5LCBkaW1pbmlzaCApICk7XHJcblxyXG59ICkuc2V0TGF5b3V0KCB7XHJcblx0bmFtZTogJ214X2ZyYWN0YWxfbm9pc2VfdmVjMicsXHJcblx0dHlwZTogJ3ZlYzInLFxyXG5cdGlucHV0czogW1xyXG5cdFx0eyBuYW1lOiAncCcsIHR5cGU6ICd2ZWMzJyB9LFxyXG5cdFx0eyBuYW1lOiAnb2N0YXZlcycsIHR5cGU6ICdpbnQnIH0sXHJcblx0XHR7IG5hbWU6ICdsYWN1bmFyaXR5JywgdHlwZTogJ2Zsb2F0JyB9LFxyXG5cdFx0eyBuYW1lOiAnZGltaW5pc2gnLCB0eXBlOiAnZmxvYXQnIH1cclxuXHRdXHJcbn0gKTtcclxuXHJcbmV4cG9ydCBjb25zdCBteF9mcmFjdGFsX25vaXNlX3ZlYzQgPSAvKkBfX1BVUkVfXyovIEZuKCAoIFsgcF9pbW11dGFibGUsIG9jdGF2ZXNfaW1tdXRhYmxlLCBsYWN1bmFyaXR5X2ltbXV0YWJsZSwgZGltaW5pc2hfaW1tdXRhYmxlIF0gKSA9PiB7XHJcblxyXG5cdGNvbnN0IGRpbWluaXNoID0gZmxvYXQoIGRpbWluaXNoX2ltbXV0YWJsZSApLnRvVmFyKCk7XHJcblx0Y29uc3QgbGFjdW5hcml0eSA9IGZsb2F0KCBsYWN1bmFyaXR5X2ltbXV0YWJsZSApLnRvVmFyKCk7XHJcblx0Y29uc3Qgb2N0YXZlcyA9IGludCggb2N0YXZlc19pbW11dGFibGUgKS50b1ZhcigpO1xyXG5cdGNvbnN0IHAgPSB2ZWMzKCBwX2ltbXV0YWJsZSApLnRvVmFyKCk7XHJcblx0Y29uc3QgYyA9IHZlYzMoIG14X2ZyYWN0YWxfbm9pc2VfdmVjMyggcCwgb2N0YXZlcywgbGFjdW5hcml0eSwgZGltaW5pc2ggKSApLnRvVmFyKCk7XHJcblx0Y29uc3QgZiA9IGZsb2F0KCBteF9mcmFjdGFsX25vaXNlX2Zsb2F0KCBwLmFkZCggdmVjMyggaW50KCAxOSApLCBpbnQoIDE5MyApLCBpbnQoIDE3ICkgKSApLCBvY3RhdmVzLCBsYWN1bmFyaXR5LCBkaW1pbmlzaCApICkudG9WYXIoKTtcclxuXHJcblx0cmV0dXJuIHZlYzQoIGMsIGYgKTtcclxuXHJcbn0gKS5zZXRMYXlvdXQoIHtcclxuXHRuYW1lOiAnbXhfZnJhY3RhbF9ub2lzZV92ZWM0JyxcclxuXHR0eXBlOiAndmVjNCcsXHJcblx0aW5wdXRzOiBbXHJcblx0XHR7IG5hbWU6ICdwJywgdHlwZTogJ3ZlYzMnIH0sXHJcblx0XHR7IG5hbWU6ICdvY3RhdmVzJywgdHlwZTogJ2ludCcgfSxcclxuXHRcdHsgbmFtZTogJ2xhY3VuYXJpdHknLCB0eXBlOiAnZmxvYXQnIH0sXHJcblx0XHR7IG5hbWU6ICdkaW1pbmlzaCcsIHR5cGU6ICdmbG9hdCcgfVxyXG5cdF1cclxufSApO1xyXG5cclxuZXhwb3J0IGNvbnN0IG14X3dvcmxleV9kaXN0YW5jZV8wID0gLypAX19QVVJFX18qLyBGbiggKCBbIHBfaW1tdXRhYmxlLCB4X2ltbXV0YWJsZSwgeV9pbW11dGFibGUsIHhvZmZfaW1tdXRhYmxlLCB5b2ZmX2ltbXV0YWJsZSwgaml0dGVyX2ltbXV0YWJsZSwgbWV0cmljX2ltbXV0YWJsZSBdICkgPT4ge1xyXG5cclxuXHRjb25zdCBtZXRyaWMgPSBpbnQoIG1ldHJpY19pbW11dGFibGUgKS50b1ZhcigpO1xyXG5cdGNvbnN0IGppdHRlciA9IGZsb2F0KCBqaXR0ZXJfaW1tdXRhYmxlICkudG9WYXIoKTtcclxuXHRjb25zdCB5b2ZmID0gaW50KCB5b2ZmX2ltbXV0YWJsZSApLnRvVmFyKCk7XHJcblx0Y29uc3QgeG9mZiA9IGludCggeG9mZl9pbW11dGFibGUgKS50b1ZhcigpO1xyXG5cdGNvbnN0IHkgPSBpbnQoIHlfaW1tdXRhYmxlICkudG9WYXIoKTtcclxuXHRjb25zdCB4ID0gaW50KCB4X2ltbXV0YWJsZSApLnRvVmFyKCk7XHJcblx0Y29uc3QgcCA9IHZlYzIoIHBfaW1tdXRhYmxlICkudG9WYXIoKTtcclxuXHRjb25zdCB0bXAgPSB2ZWMzKCBteF9jZWxsX25vaXNlX3ZlYzMoIHZlYzIoIHguYWRkKCB4b2ZmICksIHkuYWRkKCB5b2ZmICkgKSApICkudG9WYXIoKTtcclxuXHRjb25zdCBvZmYgPSB2ZWMyKCB0bXAueCwgdG1wLnkgKS50b1ZhcigpO1xyXG5cdG9mZi5zdWJBc3NpZ24oIDAuNSApO1xyXG5cdG9mZi5tdWxBc3NpZ24oIGppdHRlciApO1xyXG5cdG9mZi5hZGRBc3NpZ24oIDAuNSApO1xyXG5cdGNvbnN0IGNlbGxwb3MgPSB2ZWMyKCB2ZWMyKCBmbG9hdCggeCApLCBmbG9hdCggeSApICkuYWRkKCBvZmYgKSApLnRvVmFyKCk7XHJcblx0Y29uc3QgZGlmZiA9IHZlYzIoIGNlbGxwb3Muc3ViKCBwICkgKS50b1ZhcigpO1xyXG5cclxuXHRJZiggbWV0cmljLmVxdWFsKCBpbnQoIDIgKSApLCAoKSA9PiB7XHJcblxyXG5cdFx0cmV0dXJuIGFicyggZGlmZi54ICkuYWRkKCBhYnMoIGRpZmYueSApICk7XHJcblxyXG5cdH0gKTtcclxuXHJcblx0SWYoIG1ldHJpYy5lcXVhbCggaW50KCAzICkgKSwgKCkgPT4ge1xyXG5cclxuXHRcdHJldHVybiBtYXgoIGFicyggZGlmZi54ICksIGFicyggZGlmZi55ICkgKTtcclxuXHJcblx0fSApO1xyXG5cclxuXHRyZXR1cm4gZG90KCBkaWZmLCBkaWZmICk7XHJcblxyXG59ICkuc2V0TGF5b3V0KCB7XHJcblx0bmFtZTogJ214X3dvcmxleV9kaXN0YW5jZV8wJyxcclxuXHR0eXBlOiAnZmxvYXQnLFxyXG5cdGlucHV0czogW1xyXG5cdFx0eyBuYW1lOiAncCcsIHR5cGU6ICd2ZWMyJyB9LFxyXG5cdFx0eyBuYW1lOiAneCcsIHR5cGU6ICdpbnQnIH0sXHJcblx0XHR7IG5hbWU6ICd5JywgdHlwZTogJ2ludCcgfSxcclxuXHRcdHsgbmFtZTogJ3hvZmYnLCB0eXBlOiAnaW50JyB9LFxyXG5cdFx0eyBuYW1lOiAneW9mZicsIHR5cGU6ICdpbnQnIH0sXHJcblx0XHR7IG5hbWU6ICdqaXR0ZXInLCB0eXBlOiAnZmxvYXQnIH0sXHJcblx0XHR7IG5hbWU6ICdtZXRyaWMnLCB0eXBlOiAnaW50JyB9XHJcblx0XVxyXG59ICk7XHJcblxyXG5leHBvcnQgY29uc3QgbXhfd29ybGV5X2Rpc3RhbmNlXzEgPSAvKkBfX1BVUkVfXyovIEZuKCAoIFsgcF9pbW11dGFibGUsIHhfaW1tdXRhYmxlLCB5X2ltbXV0YWJsZSwgel9pbW11dGFibGUsIHhvZmZfaW1tdXRhYmxlLCB5b2ZmX2ltbXV0YWJsZSwgem9mZl9pbW11dGFibGUsIGppdHRlcl9pbW11dGFibGUsIG1ldHJpY19pbW11dGFibGUgXSApID0+IHtcclxuXHJcblx0Y29uc3QgbWV0cmljID0gaW50KCBtZXRyaWNfaW1tdXRhYmxlICkudG9WYXIoKTtcclxuXHRjb25zdCBqaXR0ZXIgPSBmbG9hdCggaml0dGVyX2ltbXV0YWJsZSApLnRvVmFyKCk7XHJcblx0Y29uc3Qgem9mZiA9IGludCggem9mZl9pbW11dGFibGUgKS50b1ZhcigpO1xyXG5cdGNvbnN0IHlvZmYgPSBpbnQoIHlvZmZfaW1tdXRhYmxlICkudG9WYXIoKTtcclxuXHRjb25zdCB4b2ZmID0gaW50KCB4b2ZmX2ltbXV0YWJsZSApLnRvVmFyKCk7XHJcblx0Y29uc3QgeiA9IGludCggel9pbW11dGFibGUgKS50b1ZhcigpO1xyXG5cdGNvbnN0IHkgPSBpbnQoIHlfaW1tdXRhYmxlICkudG9WYXIoKTtcclxuXHRjb25zdCB4ID0gaW50KCB4X2ltbXV0YWJsZSApLnRvVmFyKCk7XHJcblx0Y29uc3QgcCA9IHZlYzMoIHBfaW1tdXRhYmxlICkudG9WYXIoKTtcclxuXHRjb25zdCBvZmYgPSB2ZWMzKCBteF9jZWxsX25vaXNlX3ZlYzMoIHZlYzMoIHguYWRkKCB4b2ZmICksIHkuYWRkKCB5b2ZmICksIHouYWRkKCB6b2ZmICkgKSApICkudG9WYXIoKTtcclxuXHRvZmYuc3ViQXNzaWduKCAwLjUgKTtcclxuXHRvZmYubXVsQXNzaWduKCBqaXR0ZXIgKTtcclxuXHRvZmYuYWRkQXNzaWduKCAwLjUgKTtcclxuXHRjb25zdCBjZWxscG9zID0gdmVjMyggdmVjMyggZmxvYXQoIHggKSwgZmxvYXQoIHkgKSwgZmxvYXQoIHogKSApLmFkZCggb2ZmICkgKS50b1ZhcigpO1xyXG5cdGNvbnN0IGRpZmYgPSB2ZWMzKCBjZWxscG9zLnN1YiggcCApICkudG9WYXIoKTtcclxuXHJcblx0SWYoIG1ldHJpYy5lcXVhbCggaW50KCAyICkgKSwgKCkgPT4ge1xyXG5cclxuXHRcdHJldHVybiBhYnMoIGRpZmYueCApLmFkZCggYWJzKCBkaWZmLnkgKSApLmFkZCggYWJzKCBkaWZmLnogKSApO1xyXG5cclxuXHR9ICk7XHJcblxyXG5cdElmKCBtZXRyaWMuZXF1YWwoIGludCggMyApICksICgpID0+IHtcclxuXHJcblx0XHRyZXR1cm4gbWF4KCBtYXgoIGFicyggZGlmZi54ICksIGFicyggZGlmZi55ICkgKSwgYWJzKCBkaWZmLnogKSApO1xyXG5cclxuXHR9ICk7XHJcblxyXG5cdHJldHVybiBkb3QoIGRpZmYsIGRpZmYgKTtcclxuXHJcbn0gKS5zZXRMYXlvdXQoIHtcclxuXHRuYW1lOiAnbXhfd29ybGV5X2Rpc3RhbmNlXzEnLFxyXG5cdHR5cGU6ICdmbG9hdCcsXHJcblx0aW5wdXRzOiBbXHJcblx0XHR7IG5hbWU6ICdwJywgdHlwZTogJ3ZlYzMnIH0sXHJcblx0XHR7IG5hbWU6ICd4JywgdHlwZTogJ2ludCcgfSxcclxuXHRcdHsgbmFtZTogJ3knLCB0eXBlOiAnaW50JyB9LFxyXG5cdFx0eyBuYW1lOiAneicsIHR5cGU6ICdpbnQnIH0sXHJcblx0XHR7IG5hbWU6ICd4b2ZmJywgdHlwZTogJ2ludCcgfSxcclxuXHRcdHsgbmFtZTogJ3lvZmYnLCB0eXBlOiAnaW50JyB9LFxyXG5cdFx0eyBuYW1lOiAnem9mZicsIHR5cGU6ICdpbnQnIH0sXHJcblx0XHR7IG5hbWU6ICdqaXR0ZXInLCB0eXBlOiAnZmxvYXQnIH0sXHJcblx0XHR7IG5hbWU6ICdtZXRyaWMnLCB0eXBlOiAnaW50JyB9XHJcblx0XVxyXG59ICk7XHJcblxyXG5leHBvcnQgY29uc3QgbXhfd29ybGV5X2Rpc3RhbmNlID0gLypAX19QVVJFX18qLyBvdmVybG9hZGluZ0ZuKCBbIG14X3dvcmxleV9kaXN0YW5jZV8wLCBteF93b3JsZXlfZGlzdGFuY2VfMSBdICk7XHJcblxyXG5leHBvcnQgY29uc3QgbXhfd29ybGV5X25vaXNlX2Zsb2F0XzAgPSAvKkBfX1BVUkVfXyovIEZuKCAoIFsgcF9pbW11dGFibGUsIGppdHRlcl9pbW11dGFibGUsIG1ldHJpY19pbW11dGFibGUgXSApID0+IHtcclxuXHJcblx0Y29uc3QgbWV0cmljID0gaW50KCBtZXRyaWNfaW1tdXRhYmxlICkudG9WYXIoKTtcclxuXHRjb25zdCBqaXR0ZXIgPSBmbG9hdCggaml0dGVyX2ltbXV0YWJsZSApLnRvVmFyKCk7XHJcblx0Y29uc3QgcCA9IHZlYzIoIHBfaW1tdXRhYmxlICkudG9WYXIoKTtcclxuXHRjb25zdCBYID0gaW50KCkudG9WYXIoKSwgWSA9IGludCgpLnRvVmFyKCk7XHJcblx0Y29uc3QgbG9jYWxwb3MgPSB2ZWMyKCBteF9mbG9vcmZyYWMoIHAueCwgWCApLCBteF9mbG9vcmZyYWMoIHAueSwgWSApICkudG9WYXIoKTtcclxuXHRjb25zdCBzcWRpc3QgPSBmbG9hdCggMWU2ICkudG9WYXIoKTtcclxuXHJcblx0TG9vcCggeyBzdGFydDogLSAxLCBlbmQ6IGludCggMSApLCBuYW1lOiAneCcsIGNvbmRpdGlvbjogJzw9JyB9LCAoIHsgeCB9ICkgPT4ge1xyXG5cclxuXHRcdExvb3AoIHsgc3RhcnQ6IC0gMSwgZW5kOiBpbnQoIDEgKSwgbmFtZTogJ3knLCBjb25kaXRpb246ICc8PScgfSwgKCB7IHkgfSApID0+IHtcclxuXHJcblx0XHRcdGNvbnN0IGRpc3QgPSBmbG9hdCggbXhfd29ybGV5X2Rpc3RhbmNlKCBsb2NhbHBvcywgeCwgeSwgWCwgWSwgaml0dGVyLCBtZXRyaWMgKSApLnRvVmFyKCk7XHJcblx0XHRcdHNxZGlzdC5hc3NpZ24oIG1pbiggc3FkaXN0LCBkaXN0ICkgKTtcclxuXHJcblx0XHR9ICk7XHJcblxyXG5cdH0gKTtcclxuXHJcblx0SWYoIG1ldHJpYy5lcXVhbCggaW50KCAwICkgKSwgKCkgPT4ge1xyXG5cclxuXHRcdHNxZGlzdC5hc3NpZ24oIHNxcnQoIHNxZGlzdCApICk7XHJcblxyXG5cdH0gKTtcclxuXHJcblx0cmV0dXJuIHNxZGlzdDtcclxuXHJcbn0gKS5zZXRMYXlvdXQoIHtcclxuXHRuYW1lOiAnbXhfd29ybGV5X25vaXNlX2Zsb2F0XzAnLFxyXG5cdHR5cGU6ICdmbG9hdCcsXHJcblx0aW5wdXRzOiBbXHJcblx0XHR7IG5hbWU6ICdwJywgdHlwZTogJ3ZlYzInIH0sXHJcblx0XHR7IG5hbWU6ICdqaXR0ZXInLCB0eXBlOiAnZmxvYXQnIH0sXHJcblx0XHR7IG5hbWU6ICdtZXRyaWMnLCB0eXBlOiAnaW50JyB9XHJcblx0XVxyXG59ICk7XHJcblxyXG5leHBvcnQgY29uc3QgbXhfd29ybGV5X25vaXNlX3ZlYzJfMCA9IC8qQF9fUFVSRV9fKi8gRm4oICggWyBwX2ltbXV0YWJsZSwgaml0dGVyX2ltbXV0YWJsZSwgbWV0cmljX2ltbXV0YWJsZSBdICkgPT4ge1xyXG5cclxuXHRjb25zdCBtZXRyaWMgPSBpbnQoIG1ldHJpY19pbW11dGFibGUgKS50b1ZhcigpO1xyXG5cdGNvbnN0IGppdHRlciA9IGZsb2F0KCBqaXR0ZXJfaW1tdXRhYmxlICkudG9WYXIoKTtcclxuXHRjb25zdCBwID0gdmVjMiggcF9pbW11dGFibGUgKS50b1ZhcigpO1xyXG5cdGNvbnN0IFggPSBpbnQoKS50b1ZhcigpLCBZID0gaW50KCkudG9WYXIoKTtcclxuXHRjb25zdCBsb2NhbHBvcyA9IHZlYzIoIG14X2Zsb29yZnJhYyggcC54LCBYICksIG14X2Zsb29yZnJhYyggcC55LCBZICkgKS50b1ZhcigpO1xyXG5cdGNvbnN0IHNxZGlzdCA9IHZlYzIoIDFlNiwgMWU2ICkudG9WYXIoKTtcclxuXHJcblx0TG9vcCggeyBzdGFydDogLSAxLCBlbmQ6IGludCggMSApLCBuYW1lOiAneCcsIGNvbmRpdGlvbjogJzw9JyB9LCAoIHsgeCB9ICkgPT4ge1xyXG5cclxuXHRcdExvb3AoIHsgc3RhcnQ6IC0gMSwgZW5kOiBpbnQoIDEgKSwgbmFtZTogJ3knLCBjb25kaXRpb246ICc8PScgfSwgKCB7IHkgfSApID0+IHtcclxuXHJcblx0XHRcdGNvbnN0IGRpc3QgPSBmbG9hdCggbXhfd29ybGV5X2Rpc3RhbmNlKCBsb2NhbHBvcywgeCwgeSwgWCwgWSwgaml0dGVyLCBtZXRyaWMgKSApLnRvVmFyKCk7XHJcblxyXG5cdFx0XHRJZiggZGlzdC5sZXNzVGhhbiggc3FkaXN0LnggKSwgKCkgPT4ge1xyXG5cclxuXHRcdFx0XHRzcWRpc3QueS5hc3NpZ24oIHNxZGlzdC54ICk7XHJcblx0XHRcdFx0c3FkaXN0LnguYXNzaWduKCBkaXN0ICk7XHJcblxyXG5cdFx0XHR9ICkuRWxzZUlmKCBkaXN0Lmxlc3NUaGFuKCBzcWRpc3QueSApLCAoKSA9PiB7XHJcblxyXG5cdFx0XHRcdHNxZGlzdC55LmFzc2lnbiggZGlzdCApO1xyXG5cclxuXHRcdFx0fSApO1xyXG5cclxuXHRcdH0gKTtcclxuXHJcblx0fSApO1xyXG5cclxuXHRJZiggbWV0cmljLmVxdWFsKCBpbnQoIDAgKSApLCAoKSA9PiB7XHJcblxyXG5cdFx0c3FkaXN0LmFzc2lnbiggc3FydCggc3FkaXN0ICkgKTtcclxuXHJcblx0fSApO1xyXG5cclxuXHRyZXR1cm4gc3FkaXN0O1xyXG5cclxufSApLnNldExheW91dCgge1xyXG5cdG5hbWU6ICdteF93b3JsZXlfbm9pc2VfdmVjMl8wJyxcclxuXHR0eXBlOiAndmVjMicsXHJcblx0aW5wdXRzOiBbXHJcblx0XHR7IG5hbWU6ICdwJywgdHlwZTogJ3ZlYzInIH0sXHJcblx0XHR7IG5hbWU6ICdqaXR0ZXInLCB0eXBlOiAnZmxvYXQnIH0sXHJcblx0XHR7IG5hbWU6ICdtZXRyaWMnLCB0eXBlOiAnaW50JyB9XHJcblx0XVxyXG59ICk7XHJcblxyXG5leHBvcnQgY29uc3QgbXhfd29ybGV5X25vaXNlX3ZlYzNfMCA9IC8qQF9fUFVSRV9fKi8gRm4oICggWyBwX2ltbXV0YWJsZSwgaml0dGVyX2ltbXV0YWJsZSwgbWV0cmljX2ltbXV0YWJsZSBdICkgPT4ge1xyXG5cclxuXHRjb25zdCBtZXRyaWMgPSBpbnQoIG1ldHJpY19pbW11dGFibGUgKS50b1ZhcigpO1xyXG5cdGNvbnN0IGppdHRlciA9IGZsb2F0KCBqaXR0ZXJfaW1tdXRhYmxlICkudG9WYXIoKTtcclxuXHRjb25zdCBwID0gdmVjMiggcF9pbW11dGFibGUgKS50b1ZhcigpO1xyXG5cdGNvbnN0IFggPSBpbnQoKS50b1ZhcigpLCBZID0gaW50KCkudG9WYXIoKTtcclxuXHRjb25zdCBsb2NhbHBvcyA9IHZlYzIoIG14X2Zsb29yZnJhYyggcC54LCBYICksIG14X2Zsb29yZnJhYyggcC55LCBZICkgKS50b1ZhcigpO1xyXG5cdGNvbnN0IHNxZGlzdCA9IHZlYzMoIDFlNiwgMWU2LCAxZTYgKS50b1ZhcigpO1xyXG5cclxuXHRMb29wKCB7IHN0YXJ0OiAtIDEsIGVuZDogaW50KCAxICksIG5hbWU6ICd4JywgY29uZGl0aW9uOiAnPD0nIH0sICggeyB4IH0gKSA9PiB7XHJcblxyXG5cdFx0TG9vcCggeyBzdGFydDogLSAxLCBlbmQ6IGludCggMSApLCBuYW1lOiAneScsIGNvbmRpdGlvbjogJzw9JyB9LCAoIHsgeSB9ICkgPT4ge1xyXG5cclxuXHRcdFx0Y29uc3QgZGlzdCA9IGZsb2F0KCBteF93b3JsZXlfZGlzdGFuY2UoIGxvY2FscG9zLCB4LCB5LCBYLCBZLCBqaXR0ZXIsIG1ldHJpYyApICkudG9WYXIoKTtcclxuXHJcblx0XHRcdElmKCBkaXN0Lmxlc3NUaGFuKCBzcWRpc3QueCApLCAoKSA9PiB7XHJcblxyXG5cdFx0XHRcdHNxZGlzdC56LmFzc2lnbiggc3FkaXN0LnkgKTtcclxuXHRcdFx0XHRzcWRpc3QueS5hc3NpZ24oIHNxZGlzdC54ICk7XHJcblx0XHRcdFx0c3FkaXN0LnguYXNzaWduKCBkaXN0ICk7XHJcblxyXG5cdFx0XHR9ICkuRWxzZUlmKCBkaXN0Lmxlc3NUaGFuKCBzcWRpc3QueSApLCAoKSA9PiB7XHJcblxyXG5cdFx0XHRcdHNxZGlzdC56LmFzc2lnbiggc3FkaXN0LnkgKTtcclxuXHRcdFx0XHRzcWRpc3QueS5hc3NpZ24oIGRpc3QgKTtcclxuXHJcblx0XHRcdH0gKS5FbHNlSWYoIGRpc3QubGVzc1RoYW4oIHNxZGlzdC56ICksICgpID0+IHtcclxuXHJcblx0XHRcdFx0c3FkaXN0LnouYXNzaWduKCBkaXN0ICk7XHJcblxyXG5cdFx0XHR9ICk7XHJcblxyXG5cdFx0fSApO1xyXG5cclxuXHR9ICk7XHJcblxyXG5cdElmKCBtZXRyaWMuZXF1YWwoIGludCggMCApICksICgpID0+IHtcclxuXHJcblx0XHRzcWRpc3QuYXNzaWduKCBzcXJ0KCBzcWRpc3QgKSApO1xyXG5cclxuXHR9ICk7XHJcblxyXG5cdHJldHVybiBzcWRpc3Q7XHJcblxyXG59ICkuc2V0TGF5b3V0KCB7XHJcblx0bmFtZTogJ214X3dvcmxleV9ub2lzZV92ZWMzXzAnLFxyXG5cdHR5cGU6ICd2ZWMzJyxcclxuXHRpbnB1dHM6IFtcclxuXHRcdHsgbmFtZTogJ3AnLCB0eXBlOiAndmVjMicgfSxcclxuXHRcdHsgbmFtZTogJ2ppdHRlcicsIHR5cGU6ICdmbG9hdCcgfSxcclxuXHRcdHsgbmFtZTogJ21ldHJpYycsIHR5cGU6ICdpbnQnIH1cclxuXHRdXHJcbn0gKTtcclxuXHJcbmV4cG9ydCBjb25zdCBteF93b3JsZXlfbm9pc2VfZmxvYXRfMSA9IC8qQF9fUFVSRV9fKi8gRm4oICggWyBwX2ltbXV0YWJsZSwgaml0dGVyX2ltbXV0YWJsZSwgbWV0cmljX2ltbXV0YWJsZSBdICkgPT4ge1xyXG5cclxuXHRjb25zdCBtZXRyaWMgPSBpbnQoIG1ldHJpY19pbW11dGFibGUgKS50b1ZhcigpO1xyXG5cdGNvbnN0IGppdHRlciA9IGZsb2F0KCBqaXR0ZXJfaW1tdXRhYmxlICkudG9WYXIoKTtcclxuXHRjb25zdCBwID0gdmVjMyggcF9pbW11dGFibGUgKS50b1ZhcigpO1xyXG5cdGNvbnN0IFggPSBpbnQoKS50b1ZhcigpLCBZID0gaW50KCkudG9WYXIoKSwgWiA9IGludCgpLnRvVmFyKCk7XHJcblx0Y29uc3QgbG9jYWxwb3MgPSB2ZWMzKCBteF9mbG9vcmZyYWMoIHAueCwgWCApLCBteF9mbG9vcmZyYWMoIHAueSwgWSApLCBteF9mbG9vcmZyYWMoIHAueiwgWiApICkudG9WYXIoKTtcclxuXHRjb25zdCBzcWRpc3QgPSBmbG9hdCggMWU2ICkudG9WYXIoKTtcclxuXHJcblx0TG9vcCggeyBzdGFydDogLSAxLCBlbmQ6IGludCggMSApLCBuYW1lOiAneCcsIGNvbmRpdGlvbjogJzw9JyB9LCAoIHsgeCB9ICkgPT4ge1xyXG5cclxuXHRcdExvb3AoIHsgc3RhcnQ6IC0gMSwgZW5kOiBpbnQoIDEgKSwgbmFtZTogJ3knLCBjb25kaXRpb246ICc8PScgfSwgKCB7IHkgfSApID0+IHtcclxuXHJcblx0XHRcdExvb3AoIHsgc3RhcnQ6IC0gMSwgZW5kOiBpbnQoIDEgKSwgbmFtZTogJ3onLCBjb25kaXRpb246ICc8PScgfSwgKCB7IHogfSApID0+IHtcclxuXHJcblx0XHRcdFx0Y29uc3QgZGlzdCA9IGZsb2F0KCBteF93b3JsZXlfZGlzdGFuY2UoIGxvY2FscG9zLCB4LCB5LCB6LCBYLCBZLCBaLCBqaXR0ZXIsIG1ldHJpYyApICkudG9WYXIoKTtcclxuXHRcdFx0XHRzcWRpc3QuYXNzaWduKCBtaW4oIHNxZGlzdCwgZGlzdCApICk7XHJcblxyXG5cdFx0XHR9ICk7XHJcblxyXG5cdFx0fSApO1xyXG5cclxuXHR9ICk7XHJcblxyXG5cdElmKCBtZXRyaWMuZXF1YWwoIGludCggMCApICksICgpID0+IHtcclxuXHJcblx0XHRzcWRpc3QuYXNzaWduKCBzcXJ0KCBzcWRpc3QgKSApO1xyXG5cclxuXHR9ICk7XHJcblxyXG5cdHJldHVybiBzcWRpc3Q7XHJcblxyXG59ICkuc2V0TGF5b3V0KCB7XHJcblx0bmFtZTogJ214X3dvcmxleV9ub2lzZV9mbG9hdF8xJyxcclxuXHR0eXBlOiAnZmxvYXQnLFxyXG5cdGlucHV0czogW1xyXG5cdFx0eyBuYW1lOiAncCcsIHR5cGU6ICd2ZWMzJyB9LFxyXG5cdFx0eyBuYW1lOiAnaml0dGVyJywgdHlwZTogJ2Zsb2F0JyB9LFxyXG5cdFx0eyBuYW1lOiAnbWV0cmljJywgdHlwZTogJ2ludCcgfVxyXG5cdF1cclxufSApO1xyXG5cclxuZXhwb3J0IGNvbnN0IG14X3dvcmxleV9ub2lzZV9mbG9hdCA9IC8qQF9fUFVSRV9fKi8gb3ZlcmxvYWRpbmdGbiggWyBteF93b3JsZXlfbm9pc2VfZmxvYXRfMCwgbXhfd29ybGV5X25vaXNlX2Zsb2F0XzEgXSApO1xyXG5cclxuZXhwb3J0IGNvbnN0IG14X3dvcmxleV9ub2lzZV92ZWMyXzEgPSAvKkBfX1BVUkVfXyovIEZuKCAoIFsgcF9pbW11dGFibGUsIGppdHRlcl9pbW11dGFibGUsIG1ldHJpY19pbW11dGFibGUgXSApID0+IHtcclxuXHJcblx0Y29uc3QgbWV0cmljID0gaW50KCBtZXRyaWNfaW1tdXRhYmxlICkudG9WYXIoKTtcclxuXHRjb25zdCBqaXR0ZXIgPSBmbG9hdCggaml0dGVyX2ltbXV0YWJsZSApLnRvVmFyKCk7XHJcblx0Y29uc3QgcCA9IHZlYzMoIHBfaW1tdXRhYmxlICkudG9WYXIoKTtcclxuXHRjb25zdCBYID0gaW50KCkudG9WYXIoKSwgWSA9IGludCgpLnRvVmFyKCksIFogPSBpbnQoKS50b1ZhcigpO1xyXG5cdGNvbnN0IGxvY2FscG9zID0gdmVjMyggbXhfZmxvb3JmcmFjKCBwLngsIFggKSwgbXhfZmxvb3JmcmFjKCBwLnksIFkgKSwgbXhfZmxvb3JmcmFjKCBwLnosIFogKSApLnRvVmFyKCk7XHJcblx0Y29uc3Qgc3FkaXN0ID0gdmVjMiggMWU2LCAxZTYgKS50b1ZhcigpO1xyXG5cclxuXHRMb29wKCB7IHN0YXJ0OiAtIDEsIGVuZDogaW50KCAxICksIG5hbWU6ICd4JywgY29uZGl0aW9uOiAnPD0nIH0sICggeyB4IH0gKSA9PiB7XHJcblxyXG5cdFx0TG9vcCggeyBzdGFydDogLSAxLCBlbmQ6IGludCggMSApLCBuYW1lOiAneScsIGNvbmRpdGlvbjogJzw9JyB9LCAoIHsgeSB9ICkgPT4ge1xyXG5cclxuXHRcdFx0TG9vcCggeyBzdGFydDogLSAxLCBlbmQ6IGludCggMSApLCBuYW1lOiAneicsIGNvbmRpdGlvbjogJzw9JyB9LCAoIHsgeiB9ICkgPT4ge1xyXG5cclxuXHRcdFx0XHRjb25zdCBkaXN0ID0gZmxvYXQoIG14X3dvcmxleV9kaXN0YW5jZSggbG9jYWxwb3MsIHgsIHksIHosIFgsIFksIFosIGppdHRlciwgbWV0cmljICkgKS50b1ZhcigpO1xyXG5cclxuXHRcdFx0XHRJZiggZGlzdC5sZXNzVGhhbiggc3FkaXN0LnggKSwgKCkgPT4ge1xyXG5cclxuXHRcdFx0XHRcdHNxZGlzdC55LmFzc2lnbiggc3FkaXN0LnggKTtcclxuXHRcdFx0XHRcdHNxZGlzdC54LmFzc2lnbiggZGlzdCApO1xyXG5cclxuXHRcdFx0XHR9ICkuRWxzZUlmKCBkaXN0Lmxlc3NUaGFuKCBzcWRpc3QueSApLCAoKSA9PiB7XHJcblxyXG5cdFx0XHRcdFx0c3FkaXN0LnkuYXNzaWduKCBkaXN0ICk7XHJcblxyXG5cdFx0XHRcdH0gKTtcclxuXHJcblx0XHRcdH0gKTtcclxuXHJcblx0XHR9ICk7XHJcblxyXG5cdH0gKTtcclxuXHJcblx0SWYoIG1ldHJpYy5lcXVhbCggaW50KCAwICkgKSwgKCkgPT4ge1xyXG5cclxuXHRcdHNxZGlzdC5hc3NpZ24oIHNxcnQoIHNxZGlzdCApICk7XHJcblxyXG5cdH0gKTtcclxuXHJcblx0cmV0dXJuIHNxZGlzdDtcclxuXHJcbn0gKS5zZXRMYXlvdXQoIHtcclxuXHRuYW1lOiAnbXhfd29ybGV5X25vaXNlX3ZlYzJfMScsXHJcblx0dHlwZTogJ3ZlYzInLFxyXG5cdGlucHV0czogW1xyXG5cdFx0eyBuYW1lOiAncCcsIHR5cGU6ICd2ZWMzJyB9LFxyXG5cdFx0eyBuYW1lOiAnaml0dGVyJywgdHlwZTogJ2Zsb2F0JyB9LFxyXG5cdFx0eyBuYW1lOiAnbWV0cmljJywgdHlwZTogJ2ludCcgfVxyXG5cdF1cclxufSApO1xyXG5cclxuZXhwb3J0IGNvbnN0IG14X3dvcmxleV9ub2lzZV92ZWMyID0gLypAX19QVVJFX18qLyBvdmVybG9hZGluZ0ZuKCBbIG14X3dvcmxleV9ub2lzZV92ZWMyXzAsIG14X3dvcmxleV9ub2lzZV92ZWMyXzEgXSApO1xyXG5cclxuZXhwb3J0IGNvbnN0IG14X3dvcmxleV9ub2lzZV92ZWMzXzEgPSAvKkBfX1BVUkVfXyovIEZuKCAoIFsgcF9pbW11dGFibGUsIGppdHRlcl9pbW11dGFibGUsIG1ldHJpY19pbW11dGFibGUgXSApID0+IHtcclxuXHJcblx0Y29uc3QgbWV0cmljID0gaW50KCBtZXRyaWNfaW1tdXRhYmxlICkudG9WYXIoKTtcclxuXHRjb25zdCBqaXR0ZXIgPSBmbG9hdCggaml0dGVyX2ltbXV0YWJsZSApLnRvVmFyKCk7XHJcblx0Y29uc3QgcCA9IHZlYzMoIHBfaW1tdXRhYmxlICkudG9WYXIoKTtcclxuXHRjb25zdCBYID0gaW50KCkudG9WYXIoKSwgWSA9IGludCgpLnRvVmFyKCksIFogPSBpbnQoKS50b1ZhcigpO1xyXG5cdGNvbnN0IGxvY2FscG9zID0gdmVjMyggbXhfZmxvb3JmcmFjKCBwLngsIFggKSwgbXhfZmxvb3JmcmFjKCBwLnksIFkgKSwgbXhfZmxvb3JmcmFjKCBwLnosIFogKSApLnRvVmFyKCk7XHJcblx0Y29uc3Qgc3FkaXN0ID0gdmVjMyggMWU2LCAxZTYsIDFlNiApLnRvVmFyKCk7XHJcblxyXG5cdExvb3AoIHsgc3RhcnQ6IC0gMSwgZW5kOiBpbnQoIDEgKSwgbmFtZTogJ3gnLCBjb25kaXRpb246ICc8PScgfSwgKCB7IHggfSApID0+IHtcclxuXHJcblx0XHRMb29wKCB7IHN0YXJ0OiAtIDEsIGVuZDogaW50KCAxICksIG5hbWU6ICd5JywgY29uZGl0aW9uOiAnPD0nIH0sICggeyB5IH0gKSA9PiB7XHJcblxyXG5cdFx0XHRMb29wKCB7IHN0YXJ0OiAtIDEsIGVuZDogaW50KCAxICksIG5hbWU6ICd6JywgY29uZGl0aW9uOiAnPD0nIH0sICggeyB6IH0gKSA9PiB7XHJcblxyXG5cdFx0XHRcdGNvbnN0IGRpc3QgPSBmbG9hdCggbXhfd29ybGV5X2Rpc3RhbmNlKCBsb2NhbHBvcywgeCwgeSwgeiwgWCwgWSwgWiwgaml0dGVyLCBtZXRyaWMgKSApLnRvVmFyKCk7XHJcblxyXG5cdFx0XHRcdElmKCBkaXN0Lmxlc3NUaGFuKCBzcWRpc3QueCApLCAoKSA9PiB7XHJcblxyXG5cdFx0XHRcdFx0c3FkaXN0LnouYXNzaWduKCBzcWRpc3QueSApO1xyXG5cdFx0XHRcdFx0c3FkaXN0LnkuYXNzaWduKCBzcWRpc3QueCApO1xyXG5cdFx0XHRcdFx0c3FkaXN0LnguYXNzaWduKCBkaXN0ICk7XHJcblxyXG5cdFx0XHRcdH0gKS5FbHNlSWYoIGRpc3QubGVzc1RoYW4oIHNxZGlzdC55ICksICgpID0+IHtcclxuXHJcblx0XHRcdFx0XHRzcWRpc3Quei5hc3NpZ24oIHNxZGlzdC55ICk7XHJcblx0XHRcdFx0XHRzcWRpc3QueS5hc3NpZ24oIGRpc3QgKTtcclxuXHJcblx0XHRcdFx0fSApLkVsc2VJZiggZGlzdC5sZXNzVGhhbiggc3FkaXN0LnogKSwgKCkgPT4ge1xyXG5cclxuXHRcdFx0XHRcdHNxZGlzdC56LmFzc2lnbiggZGlzdCApO1xyXG5cclxuXHRcdFx0XHR9ICk7XHJcblxyXG5cdFx0XHR9ICk7XHJcblxyXG5cdFx0fSApO1xyXG5cclxuXHR9ICk7XHJcblxyXG5cdElmKCBtZXRyaWMuZXF1YWwoIGludCggMCApICksICgpID0+IHtcclxuXHJcblx0XHRzcWRpc3QuYXNzaWduKCBzcXJ0KCBzcWRpc3QgKSApO1xyXG5cclxuXHR9ICk7XHJcblxyXG5cdHJldHVybiBzcWRpc3Q7XHJcblxyXG59ICkuc2V0TGF5b3V0KCB7XHJcblx0bmFtZTogJ214X3dvcmxleV9ub2lzZV92ZWMzXzEnLFxyXG5cdHR5cGU6ICd2ZWMzJyxcclxuXHRpbnB1dHM6IFtcclxuXHRcdHsgbmFtZTogJ3AnLCB0eXBlOiAndmVjMycgfSxcclxuXHRcdHsgbmFtZTogJ2ppdHRlcicsIHR5cGU6ICdmbG9hdCcgfSxcclxuXHRcdHsgbmFtZTogJ21ldHJpYycsIHR5cGU6ICdpbnQnIH1cclxuXHRdXHJcbn0gKTtcclxuXHJcbmV4cG9ydCBjb25zdCBteF93b3JsZXlfbm9pc2VfdmVjMyA9IC8qQF9fUFVSRV9fKi8gb3ZlcmxvYWRpbmdGbiggWyBteF93b3JsZXlfbm9pc2VfdmVjM18wLCBteF93b3JsZXlfbm9pc2VfdmVjM18xIF0gKTtcclxuIiwiLy8gVGhyZWUuanMgVHJhbnNwaWxlclxyXG4vLyBodHRwczovL2dpdGh1Yi5jb20vQWNhZGVteVNvZnR3YXJlRm91bmRhdGlvbi9NYXRlcmlhbFgvYmxvYi9tYWluL2xpYnJhcmllcy9zdGRsaWIvZ2VuZ2xzbC9saWIvbXhfaHN2Lmdsc2xcclxuXHJcbmltcG9ydCB7IGludCwgZmxvYXQsIHZlYzMsIElmLCBGbiB9IGZyb20gJy4uLy4uL3RzbC9UU0xCYXNlLmpzJztcclxuaW1wb3J0IHsgYWRkIH0gZnJvbSAnLi4vLi4vbWF0aC9PcGVyYXRvck5vZGUuanMnO1xyXG5pbXBvcnQgeyBmbG9vciwgdHJ1bmMsIG1heCwgbWluIH0gZnJvbSAnLi4vLi4vbWF0aC9NYXRoTm9kZS5qcyc7XHJcblxyXG5leHBvcnQgY29uc3QgbXhfaHN2dG9yZ2IgPSAvKkBfX1BVUkVfXyovIEZuKCAoIFsgaHN2IF0gKSA9PiB7XHJcblxyXG5cdGNvbnN0IHMgPSBoc3YueTtcclxuXHRjb25zdCB2ID0gaHN2Lno7XHJcblxyXG5cdGNvbnN0IHJlc3VsdCA9IHZlYzMoKS50b1ZhcigpO1xyXG5cclxuXHRJZiggcy5sZXNzVGhhbiggMC4wMDAxICksICgpID0+IHtcclxuXHJcblx0XHRyZXN1bHQuYXNzaWduKCB2ZWMzKCB2LCB2LCB2ICkgKTtcclxuXHJcblx0fSApLkVsc2UoICgpID0+IHtcclxuXHJcblx0XHRsZXQgaCA9IGhzdi54O1xyXG5cdFx0aCA9IGguc3ViKCBmbG9vciggaCApICkubXVsKCA2LjAgKS50b1ZhcigpOyAvLyBUT0RPOiBjaGVjayB3aGF0IC50b1ZhcigpIGlzIG5lZWRlZCBpbiBub2RlIHN5c3RlbSBjYWNoZVxyXG5cdFx0Y29uc3QgaGkgPSBpbnQoIHRydW5jKCBoICkgKTtcclxuXHRcdGNvbnN0IGYgPSBoLnN1YiggZmxvYXQoIGhpICkgKTtcclxuXHRcdGNvbnN0IHAgPSB2Lm11bCggcy5vbmVNaW51cygpICk7XHJcblx0XHRjb25zdCBxID0gdi5tdWwoIHMubXVsKCBmICkub25lTWludXMoKSApO1xyXG5cdFx0Y29uc3QgdCA9IHYubXVsKCBzLm11bCggZi5vbmVNaW51cygpICkub25lTWludXMoKSApO1xyXG5cclxuXHRcdElmKCBoaS5lcXVhbCggaW50KCAwICkgKSwgKCkgPT4ge1xyXG5cclxuXHRcdFx0cmVzdWx0LmFzc2lnbiggdmVjMyggdiwgdCwgcCApICk7XHJcblxyXG5cdFx0fSApLkVsc2VJZiggaGkuZXF1YWwoIGludCggMSApICksICgpID0+IHtcclxuXHJcblx0XHRcdHJlc3VsdC5hc3NpZ24oIHZlYzMoIHEsIHYsIHAgKSApO1xyXG5cclxuXHRcdH0gKS5FbHNlSWYoIGhpLmVxdWFsKCBpbnQoIDIgKSApLCAoKSA9PiB7XHJcblxyXG5cdFx0XHRyZXN1bHQuYXNzaWduKCB2ZWMzKCBwLCB2LCB0ICkgKTtcclxuXHJcblx0XHR9ICkuRWxzZUlmKCBoaS5lcXVhbCggaW50KCAzICkgKSwgKCkgPT4ge1xyXG5cclxuXHRcdFx0cmVzdWx0LmFzc2lnbiggdmVjMyggcCwgcSwgdiApICk7XHJcblxyXG5cdFx0fSApLkVsc2VJZiggaGkuZXF1YWwoIGludCggNCApICksICgpID0+IHtcclxuXHJcblx0XHRcdHJlc3VsdC5hc3NpZ24oIHZlYzMoIHQsIHAsIHYgKSApO1xyXG5cclxuXHRcdH0gKS5FbHNlKCAoKSA9PiB7XHJcblxyXG5cdFx0XHRyZXN1bHQuYXNzaWduKCB2ZWMzKCB2LCBwLCBxICkgKTtcclxuXHJcblx0XHR9ICk7XHJcblxyXG5cdH0gKTtcclxuXHJcblx0cmV0dXJuIHJlc3VsdDtcclxuXHJcbn0gKS5zZXRMYXlvdXQoIHtcclxuXHRuYW1lOiAnbXhfaHN2dG9yZ2InLFxyXG5cdHR5cGU6ICd2ZWMzJyxcclxuXHRpbnB1dHM6IFtcclxuXHRcdHsgbmFtZTogJ2hzdicsIHR5cGU6ICd2ZWMzJyB9XHJcblx0XVxyXG59ICk7XHJcblxyXG5leHBvcnQgY29uc3QgbXhfcmdidG9oc3YgPSAvKkBfX1BVUkVfXyovIEZuKCAoIFsgY19pbW11dGFibGUgXSApID0+IHtcclxuXHJcblx0Y29uc3QgYyA9IHZlYzMoIGNfaW1tdXRhYmxlICkudG9WYXIoKTtcclxuXHRjb25zdCByID0gZmxvYXQoIGMueCApLnRvVmFyKCk7XHJcblx0Y29uc3QgZyA9IGZsb2F0KCBjLnkgKS50b1ZhcigpO1xyXG5cdGNvbnN0IGIgPSBmbG9hdCggYy56ICkudG9WYXIoKTtcclxuXHRjb25zdCBtaW5jb21wID0gZmxvYXQoIG1pbiggciwgbWluKCBnLCBiICkgKSApLnRvVmFyKCk7XHJcblx0Y29uc3QgbWF4Y29tcCA9IGZsb2F0KCBtYXgoIHIsIG1heCggZywgYiApICkgKS50b1ZhcigpO1xyXG5cdGNvbnN0IGRlbHRhID0gZmxvYXQoIG1heGNvbXAuc3ViKCBtaW5jb21wICkgKS50b1ZhcigpO1xyXG5cdGNvbnN0IGggPSBmbG9hdCgpLnRvVmFyKCksIHMgPSBmbG9hdCgpLnRvVmFyKCksIHYgPSBmbG9hdCgpLnRvVmFyKCk7XHJcblx0di5hc3NpZ24oIG1heGNvbXAgKTtcclxuXHJcblx0SWYoIG1heGNvbXAuZ3JlYXRlclRoYW4oIDAuMCApLCAoKSA9PiB7XHJcblxyXG5cdFx0cy5hc3NpZ24oIGRlbHRhLmRpdiggbWF4Y29tcCApICk7XHJcblxyXG5cdH0gKS5FbHNlKCAoKSA9PiB7XHJcblxyXG5cdFx0cy5hc3NpZ24oIDAuMCApO1xyXG5cclxuXHR9ICk7XHJcblxyXG5cdElmKCBzLmxlc3NUaGFuRXF1YWwoIDAuMCApLCAoKSA9PiB7XHJcblxyXG5cdFx0aC5hc3NpZ24oIDAuMCApO1xyXG5cclxuXHR9ICkuRWxzZSggKCkgPT4ge1xyXG5cclxuXHRcdElmKCByLmdyZWF0ZXJUaGFuRXF1YWwoIG1heGNvbXAgKSwgKCkgPT4ge1xyXG5cclxuXHRcdFx0aC5hc3NpZ24oIGcuc3ViKCBiICkuZGl2KCBkZWx0YSApICk7XHJcblxyXG5cdFx0fSApLkVsc2VJZiggZy5ncmVhdGVyVGhhbkVxdWFsKCBtYXhjb21wICksICgpID0+IHtcclxuXHJcblx0XHRcdGguYXNzaWduKCBhZGQoIDIuMCwgYi5zdWIoIHIgKS5kaXYoIGRlbHRhICkgKSApO1xyXG5cclxuXHRcdH0gKS5FbHNlKCAoKSA9PiB7XHJcblxyXG5cdFx0XHRoLmFzc2lnbiggYWRkKCA0LjAsIHIuc3ViKCBnICkuZGl2KCBkZWx0YSApICkgKTtcclxuXHJcblx0XHR9ICk7XHJcblxyXG5cdFx0aC5tdWxBc3NpZ24oIDEuMCAvIDYuMCApO1xyXG5cclxuXHRcdElmKCBoLmxlc3NUaGFuKCAwLjAgKSwgKCkgPT4ge1xyXG5cclxuXHRcdFx0aC5hZGRBc3NpZ24oIDEuMCApO1xyXG5cclxuXHRcdH0gKTtcclxuXHJcblx0fSApO1xyXG5cclxuXHRyZXR1cm4gdmVjMyggaCwgcywgdiApO1xyXG5cclxufSApLnNldExheW91dCgge1xyXG5cdG5hbWU6ICdteF9yZ2J0b2hzdicsXHJcblx0dHlwZTogJ3ZlYzMnLFxyXG5cdGlucHV0czogW1xyXG5cdFx0eyBuYW1lOiAnYycsIHR5cGU6ICd2ZWMzJyB9XHJcblx0XVxyXG59ICk7XHJcbiIsIi8vIFRocmVlLmpzIFRyYW5zcGlsZXJcclxuLy8gaHR0cHM6Ly9naXRodWIuY29tL0FjYWRlbXlTb2Z0d2FyZUZvdW5kYXRpb24vTWF0ZXJpYWxYL2Jsb2IvbWFpbi9saWJyYXJpZXMvc3RkbGliL2dlbmdsc2wvbGliL214X3RyYW5zZm9ybV9jb2xvci5nbHNsXHJcblxyXG5pbXBvcnQgeyBidmVjMywgdmVjMywgRm4gfSBmcm9tICcuLi8uLi90c2wvVFNMQmFzZS5qcyc7XHJcbmltcG9ydCB7IGdyZWF0ZXJUaGFuIH0gZnJvbSAnLi4vLi4vbWF0aC9PcGVyYXRvck5vZGUuanMnO1xyXG5pbXBvcnQgeyBtYXgsIHBvdywgbWl4IH0gZnJvbSAnLi4vLi4vbWF0aC9NYXRoTm9kZS5qcyc7XHJcblxyXG5leHBvcnQgY29uc3QgbXhfc3JnYl90ZXh0dXJlX3RvX2xpbl9yZWM3MDkgPSAvKkBfX1BVUkVfXyovIEZuKCAoIFsgY29sb3JfaW1tdXRhYmxlIF0gKSA9PiB7XHJcblxyXG5cdGNvbnN0IGNvbG9yID0gdmVjMyggY29sb3JfaW1tdXRhYmxlICkudG9WYXIoKTtcclxuXHRjb25zdCBpc0Fib3ZlID0gYnZlYzMoIGdyZWF0ZXJUaGFuKCBjb2xvciwgdmVjMyggMC4wNDA0NSApICkgKS50b1ZhcigpO1xyXG5cdGNvbnN0IGxpblNlZyA9IHZlYzMoIGNvbG9yLmRpdiggMTIuOTIgKSApLnRvVmFyKCk7XHJcblx0Y29uc3QgcG93U2VnID0gdmVjMyggcG93KCBtYXgoIGNvbG9yLmFkZCggdmVjMyggMC4wNTUgKSApLCB2ZWMzKCAwLjAgKSApLmRpdiggMS4wNTUgKSwgdmVjMyggMi40ICkgKSApLnRvVmFyKCk7XHJcblxyXG5cdHJldHVybiBtaXgoIGxpblNlZywgcG93U2VnLCBpc0Fib3ZlICk7XHJcblxyXG59ICkuc2V0TGF5b3V0KCB7XHJcblx0bmFtZTogJ214X3NyZ2JfdGV4dHVyZV90b19saW5fcmVjNzA5JyxcclxuXHR0eXBlOiAndmVjMycsXHJcblx0aW5wdXRzOiBbXHJcblx0XHR7IG5hbWU6ICdjb2xvcicsIHR5cGU6ICd2ZWMzJyB9XHJcblx0XVxyXG59ICk7XHJcbiIsImltcG9ydCB7XHJcblx0bXhfcGVybGluX25vaXNlX2Zsb2F0LCBteF9wZXJsaW5fbm9pc2VfdmVjMyxcclxuXHRteF93b3JsZXlfbm9pc2VfZmxvYXQgYXMgd29ybGV5X25vaXNlX2Zsb2F0LCBteF93b3JsZXlfbm9pc2VfdmVjMiBhcyB3b3JsZXlfbm9pc2VfdmVjMiwgbXhfd29ybGV5X25vaXNlX3ZlYzMgYXMgd29ybGV5X25vaXNlX3ZlYzMsXHJcblx0bXhfY2VsbF9ub2lzZV9mbG9hdCBhcyBjZWxsX25vaXNlX2Zsb2F0LFxyXG5cdG14X2ZyYWN0YWxfbm9pc2VfZmxvYXQgYXMgZnJhY3RhbF9ub2lzZV9mbG9hdCwgbXhfZnJhY3RhbF9ub2lzZV92ZWMyIGFzIGZyYWN0YWxfbm9pc2VfdmVjMiwgbXhfZnJhY3RhbF9ub2lzZV92ZWMzIGFzIGZyYWN0YWxfbm9pc2VfdmVjMywgbXhfZnJhY3RhbF9ub2lzZV92ZWM0IGFzIGZyYWN0YWxfbm9pc2VfdmVjNFxyXG59IGZyb20gJy4vbGliL214X25vaXNlLmpzJztcclxuaW1wb3J0IHsgbXhfaHN2dG9yZ2IsIG14X3JnYnRvaHN2IH0gZnJvbSAnLi9saWIvbXhfaHN2LmpzJztcclxuaW1wb3J0IHsgbXhfc3JnYl90ZXh0dXJlX3RvX2xpbl9yZWM3MDkgfSBmcm9tICcuL2xpYi9teF90cmFuc2Zvcm1fY29sb3IuanMnO1xyXG5pbXBvcnQgeyBtaXgsIHNtb290aHN0ZXAgfSBmcm9tICcuLi9tYXRoL01hdGhOb2RlLmpzJztcclxuaW1wb3J0IHsgdXYgfSBmcm9tICcuLi9hY2Nlc3NvcnMvVVYuanMnO1xyXG5pbXBvcnQgeyBmbG9hdCwgdmVjMiwgdmVjNCwgaW50IH0gZnJvbSAnLi4vdHNsL1RTTEJhc2UuanMnO1xyXG5cclxuZXhwb3J0IGNvbnN0IG14X2Fhc3RlcCA9ICggdGhyZXNob2xkLCB2YWx1ZSApID0+IHtcclxuXHJcblx0dGhyZXNob2xkID0gZmxvYXQoIHRocmVzaG9sZCApO1xyXG5cdHZhbHVlID0gZmxvYXQoIHZhbHVlICk7XHJcblxyXG5cdGNvbnN0IGFmd2lkdGggPSB2ZWMyKCB2YWx1ZS5kRmR4KCksIHZhbHVlLmRGZHkoKSApLmxlbmd0aCgpLm11bCggMC43MDcxMDY3ODExODY1NDc1NyApO1xyXG5cclxuXHRyZXR1cm4gc21vb3Roc3RlcCggdGhyZXNob2xkLnN1YiggYWZ3aWR0aCApLCB0aHJlc2hvbGQuYWRkKCBhZndpZHRoICksIHZhbHVlICk7XHJcblxyXG59O1xyXG5cclxuY29uc3QgX3JhbXAgPSAoIGEsIGIsIHV2LCBwICkgPT4gbWl4KCBhLCBiLCB1dlsgcCBdLmNsYW1wKCkgKTtcclxuZXhwb3J0IGNvbnN0IG14X3JhbXBsciA9ICggdmFsdWVsLCB2YWx1ZXIsIHRleGNvb3JkID0gdXYoKSApID0+IF9yYW1wKCB2YWx1ZWwsIHZhbHVlciwgdGV4Y29vcmQsICd4JyApO1xyXG5leHBvcnQgY29uc3QgbXhfcmFtcHRiID0gKCB2YWx1ZXQsIHZhbHVlYiwgdGV4Y29vcmQgPSB1digpICkgPT4gX3JhbXAoIHZhbHVldCwgdmFsdWViLCB0ZXhjb29yZCwgJ3knICk7XHJcblxyXG5jb25zdCBfc3BsaXQgPSAoIGEsIGIsIGNlbnRlciwgdXYsIHAgKSA9PiBtaXgoIGEsIGIsIG14X2Fhc3RlcCggY2VudGVyLCB1dlsgcCBdICkgKTtcclxuZXhwb3J0IGNvbnN0IG14X3NwbGl0bHIgPSAoIHZhbHVlbCwgdmFsdWVyLCBjZW50ZXIsIHRleGNvb3JkID0gdXYoKSApID0+IF9zcGxpdCggdmFsdWVsLCB2YWx1ZXIsIGNlbnRlciwgdGV4Y29vcmQsICd4JyApO1xyXG5leHBvcnQgY29uc3QgbXhfc3BsaXR0YiA9ICggdmFsdWV0LCB2YWx1ZWIsIGNlbnRlciwgdGV4Y29vcmQgPSB1digpICkgPT4gX3NwbGl0KCB2YWx1ZXQsIHZhbHVlYiwgY2VudGVyLCB0ZXhjb29yZCwgJ3knICk7XHJcblxyXG5leHBvcnQgY29uc3QgbXhfdHJhbnNmb3JtX3V2ID0gKCB1dl9zY2FsZSA9IDEsIHV2X29mZnNldCA9IDAsIHV2X2dlbyA9IHV2KCkgKSA9PiB1dl9nZW8ubXVsKCB1dl9zY2FsZSApLmFkZCggdXZfb2Zmc2V0ICk7XHJcblxyXG5leHBvcnQgY29uc3QgbXhfc2FmZXBvd2VyID0gKCBpbjEsIGluMiA9IDEgKSA9PiB7XHJcblxyXG5cdGluMSA9IGZsb2F0KCBpbjEgKTtcclxuXHJcblx0cmV0dXJuIGluMS5hYnMoKS5wb3coIGluMiApLm11bCggaW4xLnNpZ24oKSApO1xyXG5cclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBteF9jb250cmFzdCA9ICggaW5wdXQsIGFtb3VudCA9IDEsIHBpdm90ID0gLjUgKSA9PiBmbG9hdCggaW5wdXQgKS5zdWIoIHBpdm90ICkubXVsKCBhbW91bnQgKS5hZGQoIHBpdm90ICk7XHJcblxyXG5leHBvcnQgY29uc3QgbXhfbm9pc2VfZmxvYXQgPSAoIHRleGNvb3JkID0gdXYoKSwgYW1wbGl0dWRlID0gMSwgcGl2b3QgPSAwICkgPT4gbXhfcGVybGluX25vaXNlX2Zsb2F0KCB0ZXhjb29yZC5jb252ZXJ0KCAndmVjMnx2ZWMzJyApICkubXVsKCBhbXBsaXR1ZGUgKS5hZGQoIHBpdm90ICk7XHJcbi8vZXhwb3J0IGNvbnN0IG14X25vaXNlX3ZlYzIgPSAoIHRleGNvb3JkID0gdXYoKSwgYW1wbGl0dWRlID0gMSwgcGl2b3QgPSAwICkgPT4gbXhfcGVybGluX25vaXNlX3ZlYzMoIHRleGNvb3JkLmNvbnZlcnQoICd2ZWMyfHZlYzMnICkgKS5tdWwoIGFtcGxpdHVkZSApLmFkZCggcGl2b3QgKTtcclxuZXhwb3J0IGNvbnN0IG14X25vaXNlX3ZlYzMgPSAoIHRleGNvb3JkID0gdXYoKSwgYW1wbGl0dWRlID0gMSwgcGl2b3QgPSAwICkgPT4gbXhfcGVybGluX25vaXNlX3ZlYzMoIHRleGNvb3JkLmNvbnZlcnQoICd2ZWMyfHZlYzMnICkgKS5tdWwoIGFtcGxpdHVkZSApLmFkZCggcGl2b3QgKTtcclxuZXhwb3J0IGNvbnN0IG14X25vaXNlX3ZlYzQgPSAoIHRleGNvb3JkID0gdXYoKSwgYW1wbGl0dWRlID0gMSwgcGl2b3QgPSAwICkgPT4ge1xyXG5cclxuXHR0ZXhjb29yZCA9IHRleGNvb3JkLmNvbnZlcnQoICd2ZWMyfHZlYzMnICk7IC8vIG92ZXJsb2FkaW5nIHR5cGVcclxuXHJcblx0Y29uc3Qgbm9pc2VfdmVjNCA9IHZlYzQoIG14X3Blcmxpbl9ub2lzZV92ZWMzKCB0ZXhjb29yZCApLCBteF9wZXJsaW5fbm9pc2VfZmxvYXQoIHRleGNvb3JkLmFkZCggdmVjMiggMTksIDczICkgKSApICk7XHJcblxyXG5cdHJldHVybiBub2lzZV92ZWM0Lm11bCggYW1wbGl0dWRlICkuYWRkKCBwaXZvdCApO1xyXG5cclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBteF93b3JsZXlfbm9pc2VfZmxvYXQgPSAoIHRleGNvb3JkID0gdXYoKSwgaml0dGVyID0gMSApID0+IHdvcmxleV9ub2lzZV9mbG9hdCggdGV4Y29vcmQuY29udmVydCggJ3ZlYzJ8dmVjMycgKSwgaml0dGVyLCBpbnQoIDEgKSApO1xyXG5leHBvcnQgY29uc3QgbXhfd29ybGV5X25vaXNlX3ZlYzIgPSAoIHRleGNvb3JkID0gdXYoKSwgaml0dGVyID0gMSApID0+IHdvcmxleV9ub2lzZV92ZWMyKCB0ZXhjb29yZC5jb252ZXJ0KCAndmVjMnx2ZWMzJyApLCBqaXR0ZXIsIGludCggMSApICk7XHJcbmV4cG9ydCBjb25zdCBteF93b3JsZXlfbm9pc2VfdmVjMyA9ICggdGV4Y29vcmQgPSB1digpLCBqaXR0ZXIgPSAxICkgPT4gd29ybGV5X25vaXNlX3ZlYzMoIHRleGNvb3JkLmNvbnZlcnQoICd2ZWMyfHZlYzMnICksIGppdHRlciwgaW50KCAxICkgKTtcclxuXHJcbmV4cG9ydCBjb25zdCBteF9jZWxsX25vaXNlX2Zsb2F0ID0gKCB0ZXhjb29yZCA9IHV2KCkgKSA9PiBjZWxsX25vaXNlX2Zsb2F0KCB0ZXhjb29yZC5jb252ZXJ0KCAndmVjMnx2ZWMzJyApICk7XHJcblxyXG5leHBvcnQgY29uc3QgbXhfZnJhY3RhbF9ub2lzZV9mbG9hdCA9ICggcG9zaXRpb24gPSB1digpLCBvY3RhdmVzID0gMywgbGFjdW5hcml0eSA9IDIsIGRpbWluaXNoID0gLjUsIGFtcGxpdHVkZSA9IDEgKSA9PiBmcmFjdGFsX25vaXNlX2Zsb2F0KCBwb3NpdGlvbiwgaW50KCBvY3RhdmVzICksIGxhY3VuYXJpdHksIGRpbWluaXNoICkubXVsKCBhbXBsaXR1ZGUgKTtcclxuZXhwb3J0IGNvbnN0IG14X2ZyYWN0YWxfbm9pc2VfdmVjMiA9ICggcG9zaXRpb24gPSB1digpLCBvY3RhdmVzID0gMywgbGFjdW5hcml0eSA9IDIsIGRpbWluaXNoID0gLjUsIGFtcGxpdHVkZSA9IDEgKSA9PiBmcmFjdGFsX25vaXNlX3ZlYzIoIHBvc2l0aW9uLCBpbnQoIG9jdGF2ZXMgKSwgbGFjdW5hcml0eSwgZGltaW5pc2ggKS5tdWwoIGFtcGxpdHVkZSApO1xyXG5leHBvcnQgY29uc3QgbXhfZnJhY3RhbF9ub2lzZV92ZWMzID0gKCBwb3NpdGlvbiA9IHV2KCksIG9jdGF2ZXMgPSAzLCBsYWN1bmFyaXR5ID0gMiwgZGltaW5pc2ggPSAuNSwgYW1wbGl0dWRlID0gMSApID0+IGZyYWN0YWxfbm9pc2VfdmVjMyggcG9zaXRpb24sIGludCggb2N0YXZlcyApLCBsYWN1bmFyaXR5LCBkaW1pbmlzaCApLm11bCggYW1wbGl0dWRlICk7XHJcbmV4cG9ydCBjb25zdCBteF9mcmFjdGFsX25vaXNlX3ZlYzQgPSAoIHBvc2l0aW9uID0gdXYoKSwgb2N0YXZlcyA9IDMsIGxhY3VuYXJpdHkgPSAyLCBkaW1pbmlzaCA9IC41LCBhbXBsaXR1ZGUgPSAxICkgPT4gZnJhY3RhbF9ub2lzZV92ZWM0KCBwb3NpdGlvbiwgaW50KCBvY3RhdmVzICksIGxhY3VuYXJpdHksIGRpbWluaXNoICkubXVsKCBhbXBsaXR1ZGUgKTtcclxuXHJcbmV4cG9ydCB7IG14X2hzdnRvcmdiLCBteF9yZ2J0b2hzdiwgbXhfc3JnYl90ZXh0dXJlX3RvX2xpbl9yZWM3MDkgfTtcclxuIiwiaW1wb3J0IHsgcG9zaXRpb25Xb3JsZCB9IGZyb20gJy4uLy4uL2FjY2Vzc29ycy9Qb3NpdGlvbi5qcyc7XHJcbmltcG9ydCB7IGZsb2F0LCBGbiwgbWluLCBub3JtYWxpemUsIHN1YiwgdmVjMyB9IGZyb20gJy4uLy4uL3RzbC9UU0xCYXNlLmpzJztcclxuXHJcbi8vIGh0dHBzOi8vZGV2bG9nLW1hcnRpbnNoLmJsb2dzcG90LmNvbS8yMDExLzA5L2JveC1wcm9qZWN0ZWQtY3ViZS1lbnZpcm9ubWVudC1tYXBwaW5nLmh0bWxcclxuXHJcbmNvbnN0IGdldFBhcmFsbGF4Q29ycmVjdE5vcm1hbCA9IC8qQF9fUFVSRV9fKi8gRm4oICggWyBub3JtYWwsIGN1YmVTaXplLCBjdWJlUG9zIF0gKSA9PiB7XHJcblxyXG5cdGNvbnN0IG5EaXIgPSBub3JtYWxpemUoIG5vcm1hbCApLnRvVmFyKCAnbkRpcicgKTtcclxuXHRjb25zdCByYm1heCA9IHN1YiggZmxvYXQoIDAuNSApLm11bCggY3ViZVNpemUuc3ViKCBjdWJlUG9zICkgKSwgcG9zaXRpb25Xb3JsZCApLmRpdiggbkRpciApLnRvVmFyKCAncmJtYXgnICk7XHJcblx0Y29uc3QgcmJtaW4gPSBzdWIoIGZsb2F0KCAtIDAuNSApLm11bCggY3ViZVNpemUuc3ViKCBjdWJlUG9zICkgKSwgcG9zaXRpb25Xb3JsZCApLmRpdiggbkRpciApLnRvVmFyKCAncmJtaW4nICk7XHJcblx0Y29uc3QgcmJtaW5tYXggPSB2ZWMzKCkudG9WYXIoICdyYm1pbm1heCcgKTtcclxuXHRyYm1pbm1heC54ID0gbkRpci54LmdyZWF0ZXJUaGFuKCBmbG9hdCggMCApICkuc2VsZWN0KCByYm1heC54LCByYm1pbi54ICk7XHJcblx0cmJtaW5tYXgueSA9IG5EaXIueS5ncmVhdGVyVGhhbiggZmxvYXQoIDAgKSApLnNlbGVjdCggcmJtYXgueSwgcmJtaW4ueSApO1xyXG5cdHJibWlubWF4LnogPSBuRGlyLnouZ3JlYXRlclRoYW4oIGZsb2F0KCAwICkgKS5zZWxlY3QoIHJibWF4LnosIHJibWluLnogKTtcclxuXHJcblx0Y29uc3QgY29ycmVjdGlvbiA9IG1pbiggbWluKCByYm1pbm1heC54LCByYm1pbm1heC55ICksIHJibWlubWF4LnogKS50b1ZhciggJ2NvcnJlY3Rpb24nICk7XHJcblx0Y29uc3QgYm94SW50ZXJzZWN0aW9uID0gcG9zaXRpb25Xb3JsZC5hZGQoIG5EaXIubXVsKCBjb3JyZWN0aW9uICkgKS50b1ZhciggJ2JveEludGVyc2VjdGlvbicgKTtcclxuXHRyZXR1cm4gYm94SW50ZXJzZWN0aW9uLnN1YiggY3ViZVBvcyApO1xyXG5cclxufSApO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgZ2V0UGFyYWxsYXhDb3JyZWN0Tm9ybWFsO1xyXG4iLCJpbXBvcnQgeyBGbiwgbXVsIH0gZnJvbSAnLi4vLi4vdHNsL1RTTEJhc2UuanMnO1xyXG5cclxuY29uc3QgZ2V0U2hJcnJhZGlhbmNlQXQgPSAvKkBfX1BVUkVfXyovIEZuKCAoIFsgbm9ybWFsLCBzaENvZWZmaWNpZW50cyBdICkgPT4ge1xyXG5cclxuXHQvLyBub3JtYWwgaXMgYXNzdW1lZCB0byBoYXZlIHVuaXQgbGVuZ3RoXHJcblxyXG5cdGNvbnN0IHggPSBub3JtYWwueCwgeSA9IG5vcm1hbC55LCB6ID0gbm9ybWFsLno7XHJcblxyXG5cdC8vIGJhbmQgMFxyXG5cdGxldCByZXN1bHQgPSBzaENvZWZmaWNpZW50cy5lbGVtZW50KCAwICkubXVsKCAwLjg4NjIyNyApO1xyXG5cclxuXHQvLyBiYW5kIDFcclxuXHRyZXN1bHQgPSByZXN1bHQuYWRkKCBzaENvZWZmaWNpZW50cy5lbGVtZW50KCAxICkubXVsKCAyLjAgKiAwLjUxMTY2NCApLm11bCggeSApICk7XHJcblx0cmVzdWx0ID0gcmVzdWx0LmFkZCggc2hDb2VmZmljaWVudHMuZWxlbWVudCggMiApLm11bCggMi4wICogMC41MTE2NjQgKS5tdWwoIHogKSApO1xyXG5cdHJlc3VsdCA9IHJlc3VsdC5hZGQoIHNoQ29lZmZpY2llbnRzLmVsZW1lbnQoIDMgKS5tdWwoIDIuMCAqIDAuNTExNjY0ICkubXVsKCB4ICkgKTtcclxuXHJcblx0Ly8gYmFuZCAyXHJcblx0cmVzdWx0ID0gcmVzdWx0LmFkZCggc2hDb2VmZmljaWVudHMuZWxlbWVudCggNCApLm11bCggMi4wICogMC40MjkwNDMgKS5tdWwoIHggKS5tdWwoIHkgKSApO1xyXG5cdHJlc3VsdCA9IHJlc3VsdC5hZGQoIHNoQ29lZmZpY2llbnRzLmVsZW1lbnQoIDUgKS5tdWwoIDIuMCAqIDAuNDI5MDQzICkubXVsKCB5ICkubXVsKCB6ICkgKTtcclxuXHRyZXN1bHQgPSByZXN1bHQuYWRkKCBzaENvZWZmaWNpZW50cy5lbGVtZW50KCA2ICkubXVsKCB6Lm11bCggeiApLm11bCggMC43NDMxMjUgKS5zdWIoIDAuMjQ3NzA4ICkgKSApO1xyXG5cdHJlc3VsdCA9IHJlc3VsdC5hZGQoIHNoQ29lZmZpY2llbnRzLmVsZW1lbnQoIDcgKS5tdWwoIDIuMCAqIDAuNDI5MDQzICkubXVsKCB4ICkubXVsKCB6ICkgKTtcclxuXHRyZXN1bHQgPSByZXN1bHQuYWRkKCBzaENvZWZmaWNpZW50cy5lbGVtZW50KCA4ICkubXVsKCAwLjQyOTA0MyApLm11bCggbXVsKCB4LCB4ICkuc3ViKCBtdWwoIHksIHkgKSApICkgKTtcclxuXHJcblx0cmV0dXJuIHJlc3VsdDtcclxuXHJcbn0gKTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGdldFNoSXJyYWRpYW5jZUF0O1xyXG4iLCIvLyBjb25zdGFudHNcclxuZXhwb3J0ICogZnJvbSAnLi9jb3JlL2NvbnN0YW50cy5qcyc7XHJcblxyXG4vLyBjb3JlXHJcbmV4cG9ydCAqIGZyb20gJy4vY29yZS9Bc3NpZ25Ob2RlLmpzJztcclxuZXhwb3J0ICogZnJvbSAnLi9jb3JlL0F0dHJpYnV0ZU5vZGUuanMnO1xyXG5leHBvcnQgKiBmcm9tICcuL2NvcmUvQnlwYXNzTm9kZS5qcyc7XHJcbmV4cG9ydCAqIGZyb20gJy4vY29yZS9DYWNoZU5vZGUuanMnO1xyXG5leHBvcnQgKiBmcm9tICcuL2NvcmUvQ29udGV4dE5vZGUuanMnO1xyXG5leHBvcnQgKiBmcm9tICcuL2NvcmUvSW5kZXhOb2RlLmpzJztcclxuZXhwb3J0ICogZnJvbSAnLi9jb3JlL1BhcmFtZXRlck5vZGUuanMnO1xyXG5leHBvcnQgKiBmcm9tICcuL2NvcmUvUHJvcGVydHlOb2RlLmpzJztcclxuZXhwb3J0ICogZnJvbSAnLi9jb3JlL1N0YWNrTm9kZS5qcyc7XHJcbmV4cG9ydCAqIGZyb20gJy4vY29yZS9Vbmlmb3JtR3JvdXBOb2RlLmpzJztcclxuZXhwb3J0ICogZnJvbSAnLi9jb3JlL1VuaWZvcm1Ob2RlLmpzJztcclxuZXhwb3J0ICogZnJvbSAnLi9jb3JlL1ZhcnlpbmdOb2RlLmpzJztcclxuZXhwb3J0ICogZnJvbSAnLi9jb3JlL091dHB1dFN0cnVjdE5vZGUuanMnO1xyXG5leHBvcnQgKiBmcm9tICcuL2NvcmUvTVJUTm9kZS5qcyc7XHJcblxyXG4vLyBtYXRoXHJcbmV4cG9ydCAqIGZyb20gJy4vbWF0aC9IYXNoLmpzJztcclxuZXhwb3J0ICogZnJvbSAnLi9tYXRoL01hdGhVdGlscy5qcyc7XHJcbmV4cG9ydCAqIGZyb20gJy4vbWF0aC9UcmlOb2lzZTNELmpzJztcclxuXHJcbi8vIHV0aWxzXHJcbmV4cG9ydCAqIGZyb20gJy4vdXRpbHMvRXF1aXJlY3RVVk5vZGUuanMnO1xyXG5leHBvcnQgKiBmcm9tICcuL3V0aWxzL0Z1bmN0aW9uT3ZlcmxvYWRpbmdOb2RlLmpzJztcclxuZXhwb3J0ICogZnJvbSAnLi91dGlscy9Mb29wTm9kZS5qcyc7XHJcbmV4cG9ydCAqIGZyb20gJy4vdXRpbHMvTWF0Y2FwVVZOb2RlLmpzJztcclxuZXhwb3J0ICogZnJvbSAnLi91dGlscy9NYXhNaXBMZXZlbE5vZGUuanMnO1xyXG5leHBvcnQgKiBmcm9tICcuL3V0aWxzL09zY2lsbGF0b3JzLmpzJztcclxuZXhwb3J0ICogZnJvbSAnLi91dGlscy9QYWNraW5nLmpzJztcclxuZXhwb3J0ICogZnJvbSAnLi91dGlscy9SZW1hcE5vZGUuanMnO1xyXG5leHBvcnQgKiBmcm9tICcuL3V0aWxzL1VWVXRpbHMuanMnO1xyXG5leHBvcnQgKiBmcm9tICcuL3V0aWxzL1Nwcml0ZVV0aWxzLmpzJztcclxuZXhwb3J0ICogZnJvbSAnLi91dGlscy9WaWV3cG9ydFV0aWxzLmpzJztcclxuZXhwb3J0ICogZnJvbSAnLi91dGlscy9Sb3RhdGVOb2RlLmpzJztcclxuZXhwb3J0ICogZnJvbSAnLi91dGlscy9TcHJpdGVTaGVldFVWTm9kZS5qcyc7XHJcbmV4cG9ydCAqIGZyb20gJy4vdXRpbHMvVGltZXIuanMnO1xyXG5leHBvcnQgKiBmcm9tICcuL3V0aWxzL1RyaXBsYW5hclRleHR1cmVzTm9kZS5qcyc7XHJcbmV4cG9ydCAqIGZyb20gJy4vdXRpbHMvUmVmbGVjdG9yTm9kZS5qcyc7XHJcbmV4cG9ydCAqIGZyb20gJy4vdXRpbHMvUlRUTm9kZS5qcyc7XHJcbmV4cG9ydCAqIGZyb20gJy4vdXRpbHMvUG9zdFByb2Nlc3NpbmdVdGlscy5qcyc7XHJcblxyXG4vLyB0aHJlZS5qcyBzaGFkaW5nIGxhbmd1YWdlXHJcbmV4cG9ydCAqIGZyb20gJy4vdHNsL1RTTEJhc2UuanMnO1xyXG5cclxuLy8gYWNjZXNzb3JzXHJcbmV4cG9ydCAqIGZyb20gJy4vYWNjZXNzb3JzL0FjY2Vzc29yc1V0aWxzLmpzJztcclxuZXhwb3J0ICogZnJvbSAnLi9hY2Nlc3NvcnMvQXJyYXlzLmpzJztcclxuZXhwb3J0ICogZnJvbSAnLi9hY2Nlc3NvcnMvVW5pZm9ybUFycmF5Tm9kZS5qcyc7XHJcbmV4cG9ydCAqIGZyb20gJy4vYWNjZXNzb3JzL0JpdGFuZ2VudC5qcyc7XHJcbmV4cG9ydCAqIGZyb20gJy4vYWNjZXNzb3JzL0J1ZmZlckF0dHJpYnV0ZU5vZGUuanMnO1xyXG5leHBvcnQgKiBmcm9tICcuL2FjY2Vzc29ycy9CdWZmZXJOb2RlLmpzJztcclxuZXhwb3J0ICogZnJvbSAnLi9hY2Nlc3NvcnMvQ2FtZXJhLmpzJztcclxuZXhwb3J0ICogZnJvbSAnLi9hY2Nlc3NvcnMvVmVydGV4Q29sb3JOb2RlLmpzJztcclxuZXhwb3J0ICogZnJvbSAnLi9hY2Nlc3NvcnMvQ3ViZVRleHR1cmVOb2RlLmpzJztcclxuZXhwb3J0ICogZnJvbSAnLi9hY2Nlc3NvcnMvSW5zdGFuY2VOb2RlLmpzJztcclxuZXhwb3J0ICogZnJvbSAnLi9hY2Nlc3NvcnMvSW5zdGFuY2VkTWVzaE5vZGUuanMnO1xyXG5leHBvcnQgKiBmcm9tICcuL2FjY2Vzc29ycy9CYXRjaE5vZGUuanMnO1xyXG5leHBvcnQgKiBmcm9tICcuL2FjY2Vzc29ycy9NYXRlcmlhbE5vZGUuanMnO1xyXG5leHBvcnQgKiBmcm9tICcuL2FjY2Vzc29ycy9NYXRlcmlhbFByb3BlcnRpZXMuanMnO1xyXG5leHBvcnQgKiBmcm9tICcuL2FjY2Vzc29ycy9NYXRlcmlhbFJlZmVyZW5jZU5vZGUuanMnO1xyXG5leHBvcnQgKiBmcm9tICcuL2FjY2Vzc29ycy9SZW5kZXJlclJlZmVyZW5jZU5vZGUuanMnO1xyXG5leHBvcnQgKiBmcm9tICcuL2FjY2Vzc29ycy9Nb3JwaE5vZGUuanMnO1xyXG5leHBvcnQgKiBmcm9tICcuL2FjY2Vzc29ycy9UZXh0dXJlQmljdWJpYy5qcyc7XHJcbmV4cG9ydCAqIGZyb20gJy4vYWNjZXNzb3JzL01vZGVsTm9kZS5qcyc7XHJcbmV4cG9ydCAqIGZyb20gJy4vYWNjZXNzb3JzL01vZGVsVmlld1Byb2plY3Rpb25Ob2RlLmpzJztcclxuZXhwb3J0ICogZnJvbSAnLi9hY2Nlc3NvcnMvTm9ybWFsLmpzJztcclxuZXhwb3J0ICogZnJvbSAnLi9hY2Nlc3NvcnMvT2JqZWN0M0ROb2RlLmpzJztcclxuZXhwb3J0ICogZnJvbSAnLi9hY2Nlc3NvcnMvUG9pbnRVVk5vZGUuanMnO1xyXG5leHBvcnQgKiBmcm9tICcuL2FjY2Vzc29ycy9Qb3NpdGlvbi5qcyc7XHJcbmV4cG9ydCAqIGZyb20gJy4vYWNjZXNzb3JzL1JlZmVyZW5jZU5vZGUuanMnO1xyXG5leHBvcnQgKiBmcm9tICcuL2FjY2Vzc29ycy9SZWZsZWN0VmVjdG9yLmpzJztcclxuZXhwb3J0ICogZnJvbSAnLi9hY2Nlc3NvcnMvU2tpbm5pbmdOb2RlLmpzJztcclxuZXhwb3J0ICogZnJvbSAnLi9hY2Nlc3NvcnMvU2NlbmVOb2RlLmpzJztcclxuZXhwb3J0ICogZnJvbSAnLi9hY2Nlc3NvcnMvU3RvcmFnZUJ1ZmZlck5vZGUuanMnO1xyXG5leHBvcnQgKiBmcm9tICcuL2FjY2Vzc29ycy9UYW5nZW50LmpzJztcclxuZXhwb3J0ICogZnJvbSAnLi9hY2Nlc3NvcnMvVGV4dHVyZU5vZGUuanMnO1xyXG5leHBvcnQgKiBmcm9tICcuL2FjY2Vzc29ycy9UZXh0dXJlU2l6ZU5vZGUuanMnO1xyXG5leHBvcnQgKiBmcm9tICcuL2FjY2Vzc29ycy9TdG9yYWdlVGV4dHVyZU5vZGUuanMnO1xyXG5leHBvcnQgKiBmcm9tICcuL2FjY2Vzc29ycy9UZXh0dXJlM0ROb2RlLmpzJztcclxuZXhwb3J0ICogZnJvbSAnLi9hY2Nlc3NvcnMvVVYuanMnO1xyXG5leHBvcnQgKiBmcm9tICcuL2FjY2Vzc29ycy9Vc2VyRGF0YU5vZGUuanMnO1xyXG5leHBvcnQgKiBmcm9tICcuL2FjY2Vzc29ycy9WZWxvY2l0eU5vZGUuanMnO1xyXG5cclxuLy8gZGlzcGxheVxyXG5leHBvcnQgKiBmcm9tICcuL2Rpc3BsYXkvQmxlbmRNb2Rlcy5qcyc7XHJcbmV4cG9ydCAqIGZyb20gJy4vZGlzcGxheS9CdW1wTWFwTm9kZS5qcyc7XHJcbmV4cG9ydCAqIGZyb20gJy4vZGlzcGxheS9Db2xvckFkanVzdG1lbnQuanMnO1xyXG5leHBvcnQgKiBmcm9tICcuL2Rpc3BsYXkvQ29sb3JTcGFjZU5vZGUuanMnO1xyXG5leHBvcnQgKiBmcm9tICcuL2Rpc3BsYXkvRnJvbnRGYWNpbmdOb2RlLmpzJztcclxuZXhwb3J0ICogZnJvbSAnLi9kaXNwbGF5L05vcm1hbE1hcE5vZGUuanMnO1xyXG5leHBvcnQgKiBmcm9tICcuL2Rpc3BsYXkvUG9zdGVyaXplTm9kZS5qcyc7XHJcbmV4cG9ydCAqIGZyb20gJy4vZGlzcGxheS9Ub25lTWFwcGluZ05vZGUuanMnO1xyXG5leHBvcnQgKiBmcm9tICcuL2Rpc3BsYXkvU2NyZWVuTm9kZS5qcyc7XHJcbmV4cG9ydCAqIGZyb20gJy4vZGlzcGxheS9WaWV3cG9ydFRleHR1cmVOb2RlLmpzJztcclxuZXhwb3J0ICogZnJvbSAnLi9kaXNwbGF5L1ZpZXdwb3J0U2hhcmVkVGV4dHVyZU5vZGUuanMnO1xyXG5leHBvcnQgKiBmcm9tICcuL2Rpc3BsYXkvVmlld3BvcnREZXB0aFRleHR1cmVOb2RlLmpzJztcclxuZXhwb3J0ICogZnJvbSAnLi9kaXNwbGF5L1ZpZXdwb3J0RGVwdGhOb2RlLmpzJztcclxuZXhwb3J0ICogZnJvbSAnLi9kaXNwbGF5L1JlbmRlck91dHB1dE5vZGUuanMnO1xyXG5leHBvcnQgKiBmcm9tICcuL2Rpc3BsYXkvVG9vbk91dGxpbmVQYXNzTm9kZS5qcyc7XHJcblxyXG5leHBvcnQgKiBmcm9tICcuL2Rpc3BsYXkvUGFzc05vZGUuanMnO1xyXG5cclxuZXhwb3J0ICogZnJvbSAnLi9kaXNwbGF5L0NvbG9yU3BhY2VGdW5jdGlvbnMuanMnO1xyXG5leHBvcnQgKiBmcm9tICcuL2Rpc3BsYXkvVG9uZU1hcHBpbmdGdW5jdGlvbnMuanMnO1xyXG5cclxuLy8gY29kZVxyXG5leHBvcnQgKiBmcm9tICcuL2NvZGUvRXhwcmVzc2lvbk5vZGUuanMnO1xyXG5leHBvcnQgKiBmcm9tICcuL2NvZGUvQ29kZU5vZGUuanMnO1xyXG5leHBvcnQgKiBmcm9tICcuL2NvZGUvRnVuY3Rpb25DYWxsTm9kZS5qcyc7XHJcbmV4cG9ydCAqIGZyb20gJy4vY29kZS9GdW5jdGlvbk5vZGUuanMnO1xyXG5leHBvcnQgKiBmcm9tICcuL2NvZGUvU2NyaXB0YWJsZU5vZGUuanMnO1xyXG5leHBvcnQgKiBmcm9tICcuL2NvZGUvU2NyaXB0YWJsZVZhbHVlTm9kZS5qcyc7XHJcblxyXG4vLyBmb2dcclxuZXhwb3J0ICogZnJvbSAnLi9mb2cvRm9nLmpzJztcclxuXHJcbi8vIGdlb21ldHJ5XHJcbmV4cG9ydCAqIGZyb20gJy4vZ2VvbWV0cnkvUmFuZ2VOb2RlLmpzJztcclxuXHJcbi8vIGdwZ3B1XHJcbmV4cG9ydCAqIGZyb20gJy4vZ3BncHUvQ29tcHV0ZU5vZGUuanMnO1xyXG5leHBvcnQgKiBmcm9tICcuL2dwZ3B1L0NvbXB1dGVCdWlsdGluTm9kZS5qcyc7XHJcbmV4cG9ydCAqIGZyb20gJy4vZ3BncHUvQmFycmllck5vZGUuanMnO1xyXG5leHBvcnQgKiBmcm9tICcuL2dwZ3B1L1dvcmtncm91cEluZm9Ob2RlLmpzJztcclxuZXhwb3J0ICogZnJvbSAnLi9ncGdwdS9BdG9taWNGdW5jdGlvbk5vZGUuanMnO1xyXG5cclxuLy8gbGlnaHRpbmdcclxuZXhwb3J0ICogZnJvbSAnLi9hY2Nlc3NvcnMvTGlnaHRzLmpzJztcclxuZXhwb3J0ICogZnJvbSAnLi9saWdodGluZy9MaWdodHNOb2RlLmpzJztcclxuZXhwb3J0ICogZnJvbSAnLi9saWdodGluZy9MaWdodGluZ0NvbnRleHROb2RlLmpzJztcclxuZXhwb3J0ICogZnJvbSAnLi9saWdodGluZy9TaGFkb3dOb2RlLmpzJztcclxuZXhwb3J0ICogZnJvbSAnLi9saWdodGluZy9Qb2ludExpZ2h0Tm9kZS5qcyc7XHJcblxyXG4vLyBwbXJlbVxyXG5leHBvcnQgKiBmcm9tICcuL3BtcmVtL1BNUkVNTm9kZS5qcyc7XHJcbmV4cG9ydCAqIGZyb20gJy4vcG1yZW0vUE1SRU1VdGlscy5qcyc7XHJcblxyXG4vLyBwcm9jZWR1cmFsXHJcbmV4cG9ydCAqIGZyb20gJy4vcHJvY2VkdXJhbC9DaGVja2VyLmpzJztcclxuXHJcbi8vIG1hdGVyaWFsWFxyXG5leHBvcnQgKiBmcm9tICcuL21hdGVyaWFseC9NYXRlcmlhbFhOb2Rlcy5qcyc7XHJcblxyXG4vLyBmdW5jdGlvbnNcclxuZXhwb3J0IHsgZGVmYXVsdCBhcyBCUkRGX0dHWCB9IGZyb20gJy4vZnVuY3Rpb25zL0JTREYvQlJERl9HR1guanMnO1xyXG5leHBvcnQgeyBkZWZhdWx0IGFzIEJSREZfTGFtYmVydCB9IGZyb20gJy4vZnVuY3Rpb25zL0JTREYvQlJERl9MYW1iZXJ0LmpzJztcclxuZXhwb3J0IHsgZGVmYXVsdCBhcyBEX0dHWCB9IGZyb20gJy4vZnVuY3Rpb25zL0JTREYvRF9HR1guanMnO1xyXG5leHBvcnQgeyBkZWZhdWx0IGFzIERGR0FwcHJveCB9IGZyb20gJy4vZnVuY3Rpb25zL0JTREYvREZHQXBwcm94LmpzJztcclxuZXhwb3J0IHsgZGVmYXVsdCBhcyBGX1NjaGxpY2sgfSBmcm9tICcuL2Z1bmN0aW9ucy9CU0RGL0ZfU2NobGljay5qcyc7XHJcbmV4cG9ydCB7IGRlZmF1bHQgYXMgU2NobGlja190b19GMCB9IGZyb20gJy4vZnVuY3Rpb25zL0JTREYvU2NobGlja190b19GMC5qcyc7XHJcbmV4cG9ydCB7IGRlZmF1bHQgYXMgVl9HR1hfU21pdGhDb3JyZWxhdGVkIH0gZnJvbSAnLi9mdW5jdGlvbnMvQlNERi9WX0dHWF9TbWl0aENvcnJlbGF0ZWQuanMnO1xyXG5cclxuZXhwb3J0ICogZnJvbSAnLi9saWdodGluZy9MaWdodFV0aWxzLmpzJztcclxuXHJcbmV4cG9ydCB7IGRlZmF1bHQgYXMgZ2V0R2VvbWV0cnlSb3VnaG5lc3MgfSBmcm9tICcuL2Z1bmN0aW9ucy9tYXRlcmlhbC9nZXRHZW9tZXRyeVJvdWdobmVzcy5qcyc7XHJcbmV4cG9ydCB7IGRlZmF1bHQgYXMgZ2V0UGFyYWxsYXhDb3JyZWN0Tm9ybWFsIH0gZnJvbSAnLi9mdW5jdGlvbnMvbWF0ZXJpYWwvZ2V0UGFyYWxsYXhDb3JyZWN0Tm9ybWFsLmpzJztcclxuZXhwb3J0IHsgZGVmYXVsdCBhcyBnZXRSb3VnaG5lc3MgfSBmcm9tICcuL2Z1bmN0aW9ucy9tYXRlcmlhbC9nZXRSb3VnaG5lc3MuanMnO1xyXG5leHBvcnQgeyBkZWZhdWx0IGFzIGdldFNoSXJyYWRpYW5jZUF0IH0gZnJvbSAnLi9mdW5jdGlvbnMvbWF0ZXJpYWwvZ2V0U2hJcnJhZGlhbmNlQXQuanMnO1xyXG4iLCJpbXBvcnQgRGF0YU1hcCBmcm9tICcuL0RhdGFNYXAuanMnO1xyXG5pbXBvcnQgQ29sb3I0IGZyb20gJy4vQ29sb3I0LmpzJztcclxuaW1wb3J0IHsgdmVjNCwgY29udGV4dCwgbm9ybWFsV29ybGQsIGJhY2tncm91bmRCbHVycmluZXNzLCBiYWNrZ3JvdW5kSW50ZW5zaXR5LCBiYWNrZ3JvdW5kUm90YXRpb24sIG1vZGVsVmlld1Byb2plY3Rpb24gfSBmcm9tICcuLi8uLi9ub2Rlcy9UU0wuanMnO1xyXG5pbXBvcnQgTm9kZU1hdGVyaWFsIGZyb20gJy4uLy4uL21hdGVyaWFscy9ub2Rlcy9Ob2RlTWF0ZXJpYWwuanMnO1xyXG5cclxuaW1wb3J0IHsgTWVzaCB9IGZyb20gJy4uLy4uL29iamVjdHMvTWVzaC5qcyc7XHJcbmltcG9ydCB7IFNwaGVyZUdlb21ldHJ5IH0gZnJvbSAnLi4vLi4vZ2VvbWV0cmllcy9TcGhlcmVHZW9tZXRyeS5qcyc7XHJcbmltcG9ydCB7IEJhY2tTaWRlLCBMaW5lYXJTUkdCQ29sb3JTcGFjZSB9IGZyb20gJy4uLy4uL2NvbnN0YW50cy5qcyc7XHJcblxyXG5jb25zdCBfY2xlYXJDb2xvciA9IC8qQF9fUFVSRV9fKi8gbmV3IENvbG9yNCgpO1xyXG5cclxuY2xhc3MgQmFja2dyb3VuZCBleHRlbmRzIERhdGFNYXAge1xyXG5cclxuXHRjb25zdHJ1Y3RvciggcmVuZGVyZXIsIG5vZGVzICkge1xyXG5cclxuXHRcdHN1cGVyKCk7XHJcblxyXG5cdFx0dGhpcy5yZW5kZXJlciA9IHJlbmRlcmVyO1xyXG5cdFx0dGhpcy5ub2RlcyA9IG5vZGVzO1xyXG5cclxuXHR9XHJcblxyXG5cdHVwZGF0ZSggc2NlbmUsIHJlbmRlckxpc3QsIHJlbmRlckNvbnRleHQgKSB7XHJcblxyXG5cdFx0Y29uc3QgcmVuZGVyZXIgPSB0aGlzLnJlbmRlcmVyO1xyXG5cdFx0Y29uc3QgYmFja2dyb3VuZCA9IHRoaXMubm9kZXMuZ2V0QmFja2dyb3VuZE5vZGUoIHNjZW5lICkgfHwgc2NlbmUuYmFja2dyb3VuZDtcclxuXHJcblx0XHRsZXQgZm9yY2VDbGVhciA9IGZhbHNlO1xyXG5cclxuXHRcdGlmICggYmFja2dyb3VuZCA9PT0gbnVsbCApIHtcclxuXHJcblx0XHRcdC8vIG5vIGJhY2tncm91bmQgc2V0dGluZ3MsIHVzZSBjbGVhciBjb2xvciBjb25maWd1cmF0aW9uIGZyb20gdGhlIHJlbmRlcmVyXHJcblxyXG5cdFx0XHRyZW5kZXJlci5fY2xlYXJDb2xvci5nZXRSR0IoIF9jbGVhckNvbG9yLCBMaW5lYXJTUkdCQ29sb3JTcGFjZSApO1xyXG5cdFx0XHRfY2xlYXJDb2xvci5hID0gcmVuZGVyZXIuX2NsZWFyQ29sb3IuYTtcclxuXHJcblx0XHR9IGVsc2UgaWYgKCBiYWNrZ3JvdW5kLmlzQ29sb3IgPT09IHRydWUgKSB7XHJcblxyXG5cdFx0XHQvLyBiYWNrZ3JvdW5kIGlzIGFuIG9wYXF1ZSBjb2xvclxyXG5cclxuXHRcdFx0YmFja2dyb3VuZC5nZXRSR0IoIF9jbGVhckNvbG9yLCBMaW5lYXJTUkdCQ29sb3JTcGFjZSApO1xyXG5cdFx0XHRfY2xlYXJDb2xvci5hID0gMTtcclxuXHJcblx0XHRcdGZvcmNlQ2xlYXIgPSB0cnVlO1xyXG5cclxuXHRcdH0gZWxzZSBpZiAoIGJhY2tncm91bmQuaXNOb2RlID09PSB0cnVlICkge1xyXG5cclxuXHRcdFx0Y29uc3Qgc2NlbmVEYXRhID0gdGhpcy5nZXQoIHNjZW5lICk7XHJcblx0XHRcdGNvbnN0IGJhY2tncm91bmROb2RlID0gYmFja2dyb3VuZDtcclxuXHJcblx0XHRcdF9jbGVhckNvbG9yLmNvcHkoIHJlbmRlcmVyLl9jbGVhckNvbG9yICk7XHJcblxyXG5cdFx0XHRsZXQgYmFja2dyb3VuZE1lc2ggPSBzY2VuZURhdGEuYmFja2dyb3VuZE1lc2g7XHJcblxyXG5cdFx0XHRpZiAoIGJhY2tncm91bmRNZXNoID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdGNvbnN0IGJhY2tncm91bmRNZXNoTm9kZSA9IGNvbnRleHQoIHZlYzQoIGJhY2tncm91bmROb2RlICkubXVsKCBiYWNrZ3JvdW5kSW50ZW5zaXR5ICksIHtcclxuXHRcdFx0XHRcdC8vIEBUT0RPOiBBZGQgVGV4dHVyZTJEIHN1cHBvcnQgdXNpbmcgbm9kZSBjb250ZXh0XHJcblx0XHRcdFx0XHRnZXRVVjogKCkgPT4gYmFja2dyb3VuZFJvdGF0aW9uLm11bCggbm9ybWFsV29ybGQgKSxcclxuXHRcdFx0XHRcdGdldFRleHR1cmVMZXZlbDogKCkgPT4gYmFja2dyb3VuZEJsdXJyaW5lc3NcclxuXHRcdFx0XHR9ICk7XHJcblxyXG5cdFx0XHRcdGxldCB2aWV3UHJvaiA9IG1vZGVsVmlld1Byb2plY3Rpb247XHJcblx0XHRcdFx0dmlld1Byb2ogPSB2aWV3UHJvai5zZXRaKCB2aWV3UHJvai53ICk7XHJcblxyXG5cdFx0XHRcdGNvbnN0IG5vZGVNYXRlcmlhbCA9IG5ldyBOb2RlTWF0ZXJpYWwoKTtcclxuXHRcdFx0XHRub2RlTWF0ZXJpYWwubmFtZSA9ICdCYWNrZ3JvdW5kLm1hdGVyaWFsJztcclxuXHRcdFx0XHRub2RlTWF0ZXJpYWwuc2lkZSA9IEJhY2tTaWRlO1xyXG5cdFx0XHRcdG5vZGVNYXRlcmlhbC5kZXB0aFRlc3QgPSBmYWxzZTtcclxuXHRcdFx0XHRub2RlTWF0ZXJpYWwuZGVwdGhXcml0ZSA9IGZhbHNlO1xyXG5cdFx0XHRcdG5vZGVNYXRlcmlhbC5mb2cgPSBmYWxzZTtcclxuXHRcdFx0XHRub2RlTWF0ZXJpYWwubGlnaHRzID0gZmFsc2U7XHJcblx0XHRcdFx0bm9kZU1hdGVyaWFsLnZlcnRleE5vZGUgPSB2aWV3UHJvajtcclxuXHRcdFx0XHRub2RlTWF0ZXJpYWwuY29sb3JOb2RlID0gYmFja2dyb3VuZE1lc2hOb2RlO1xyXG5cclxuXHRcdFx0XHRzY2VuZURhdGEuYmFja2dyb3VuZE1lc2hOb2RlID0gYmFja2dyb3VuZE1lc2hOb2RlO1xyXG5cdFx0XHRcdHNjZW5lRGF0YS5iYWNrZ3JvdW5kTWVzaCA9IGJhY2tncm91bmRNZXNoID0gbmV3IE1lc2goIG5ldyBTcGhlcmVHZW9tZXRyeSggMSwgMzIsIDMyICksIG5vZGVNYXRlcmlhbCApO1xyXG5cdFx0XHRcdGJhY2tncm91bmRNZXNoLmZydXN0dW1DdWxsZWQgPSBmYWxzZTtcclxuXHRcdFx0XHRiYWNrZ3JvdW5kTWVzaC5uYW1lID0gJ0JhY2tncm91bmQubWVzaCc7XHJcblxyXG5cdFx0XHRcdGJhY2tncm91bmRNZXNoLm9uQmVmb3JlUmVuZGVyID0gZnVuY3Rpb24gKCByZW5kZXJlciwgc2NlbmUsIGNhbWVyYSApIHtcclxuXHJcblx0XHRcdFx0XHR0aGlzLm1hdHJpeFdvcmxkLmNvcHlQb3NpdGlvbiggY2FtZXJhLm1hdHJpeFdvcmxkICk7XHJcblxyXG5cdFx0XHRcdH07XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRjb25zdCBiYWNrZ3JvdW5kQ2FjaGVLZXkgPSBiYWNrZ3JvdW5kTm9kZS5nZXRDYWNoZUtleSgpO1xyXG5cclxuXHRcdFx0aWYgKCBzY2VuZURhdGEuYmFja2dyb3VuZENhY2hlS2V5ICE9PSBiYWNrZ3JvdW5kQ2FjaGVLZXkgKSB7XHJcblxyXG5cdFx0XHRcdHNjZW5lRGF0YS5iYWNrZ3JvdW5kTWVzaE5vZGUubm9kZSA9IHZlYzQoIGJhY2tncm91bmROb2RlICkubXVsKCBiYWNrZ3JvdW5kSW50ZW5zaXR5ICk7XHJcblx0XHRcdFx0c2NlbmVEYXRhLmJhY2tncm91bmRNZXNoTm9kZS5uZWVkc1VwZGF0ZSA9IHRydWU7XHJcblxyXG5cdFx0XHRcdGJhY2tncm91bmRNZXNoLm1hdGVyaWFsLm5lZWRzVXBkYXRlID0gdHJ1ZTtcclxuXHJcblx0XHRcdFx0c2NlbmVEYXRhLmJhY2tncm91bmRDYWNoZUtleSA9IGJhY2tncm91bmRDYWNoZUtleTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHJlbmRlckxpc3QudW5zaGlmdCggYmFja2dyb3VuZE1lc2gsIGJhY2tncm91bmRNZXNoLmdlb21ldHJ5LCBiYWNrZ3JvdW5kTWVzaC5tYXRlcmlhbCwgMCwgMCwgbnVsbCwgbnVsbCApO1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuUmVuZGVyZXI6IFVuc3VwcG9ydGVkIGJhY2tncm91bmQgY29uZmlndXJhdGlvbi4nLCBiYWNrZ3JvdW5kICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vXHJcblxyXG5cdFx0aWYgKCByZW5kZXJlci5hdXRvQ2xlYXIgPT09IHRydWUgfHwgZm9yY2VDbGVhciA9PT0gdHJ1ZSApIHtcclxuXHJcblx0XHRcdGNvbnN0IGNsZWFyQ29sb3JWYWx1ZSA9IHJlbmRlckNvbnRleHQuY2xlYXJDb2xvclZhbHVlO1xyXG5cclxuXHRcdFx0Y2xlYXJDb2xvclZhbHVlLnIgPSBfY2xlYXJDb2xvci5yO1xyXG5cdFx0XHRjbGVhckNvbG9yVmFsdWUuZyA9IF9jbGVhckNvbG9yLmc7XHJcblx0XHRcdGNsZWFyQ29sb3JWYWx1ZS5iID0gX2NsZWFyQ29sb3IuYjtcclxuXHRcdFx0Y2xlYXJDb2xvclZhbHVlLmEgPSBfY2xlYXJDb2xvci5hO1xyXG5cclxuXHRcdFx0Ly8gcHJlbXVsdGlwbHkgYWxwaGFcclxuXHJcblx0XHRcdGlmICggcmVuZGVyZXIuYmFja2VuZC5pc1dlYkdMQmFja2VuZCA9PT0gdHJ1ZSB8fCByZW5kZXJlci5hbHBoYSA9PT0gdHJ1ZSApIHtcclxuXHJcblx0XHRcdFx0Y2xlYXJDb2xvclZhbHVlLnIgKj0gY2xlYXJDb2xvclZhbHVlLmE7XHJcblx0XHRcdFx0Y2xlYXJDb2xvclZhbHVlLmcgKj0gY2xlYXJDb2xvclZhbHVlLmE7XHJcblx0XHRcdFx0Y2xlYXJDb2xvclZhbHVlLmIgKj0gY2xlYXJDb2xvclZhbHVlLmE7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvL1xyXG5cclxuXHRcdFx0cmVuZGVyQ29udGV4dC5kZXB0aENsZWFyVmFsdWUgPSByZW5kZXJlci5fY2xlYXJEZXB0aDtcclxuXHRcdFx0cmVuZGVyQ29udGV4dC5zdGVuY2lsQ2xlYXJWYWx1ZSA9IHJlbmRlcmVyLl9jbGVhclN0ZW5jaWw7XHJcblxyXG5cdFx0XHRyZW5kZXJDb250ZXh0LmNsZWFyQ29sb3IgPSByZW5kZXJlci5hdXRvQ2xlYXJDb2xvciA9PT0gdHJ1ZTtcclxuXHRcdFx0cmVuZGVyQ29udGV4dC5jbGVhckRlcHRoID0gcmVuZGVyZXIuYXV0b0NsZWFyRGVwdGggPT09IHRydWU7XHJcblx0XHRcdHJlbmRlckNvbnRleHQuY2xlYXJTdGVuY2lsID0gcmVuZGVyZXIuYXV0b0NsZWFyU3RlbmNpbCA9PT0gdHJ1ZTtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0cmVuZGVyQ29udGV4dC5jbGVhckNvbG9yID0gZmFsc2U7XHJcblx0XHRcdHJlbmRlckNvbnRleHQuY2xlYXJEZXB0aCA9IGZhbHNlO1xyXG5cdFx0XHRyZW5kZXJDb250ZXh0LmNsZWFyU3RlbmNpbCA9IGZhbHNlO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgQmFja2dyb3VuZDtcclxuIiwibGV0IF9pZCA9IDA7XHJcblxyXG5jbGFzcyBCaW5kR3JvdXAge1xyXG5cclxuXHRjb25zdHJ1Y3RvciggbmFtZSA9ICcnLCBiaW5kaW5ncyA9IFtdLCBpbmRleCA9IDAsIGJpbmRpbmdzUmVmZXJlbmNlID0gW10gKSB7XHJcblxyXG5cdFx0dGhpcy5uYW1lID0gbmFtZTtcclxuXHRcdHRoaXMuYmluZGluZ3MgPSBiaW5kaW5ncztcclxuXHRcdHRoaXMuaW5kZXggPSBpbmRleDtcclxuXHRcdHRoaXMuYmluZGluZ3NSZWZlcmVuY2UgPSBiaW5kaW5nc1JlZmVyZW5jZTtcclxuXHJcblx0XHR0aGlzLmlkID0gX2lkICsrO1xyXG5cclxuXHR9XHJcblxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBCaW5kR3JvdXA7XHJcbiIsImltcG9ydCBCaW5kR3JvdXAgZnJvbSAnLi4vQmluZEdyb3VwLmpzJztcclxuXHJcbmNsYXNzIE5vZGVCdWlsZGVyU3RhdGUge1xyXG5cclxuXHRjb25zdHJ1Y3RvciggdmVydGV4U2hhZGVyLCBmcmFnbWVudFNoYWRlciwgY29tcHV0ZVNoYWRlciwgbm9kZUF0dHJpYnV0ZXMsIGJpbmRpbmdzLCB1cGRhdGVOb2RlcywgdXBkYXRlQmVmb3JlTm9kZXMsIHVwZGF0ZUFmdGVyTm9kZXMsIG1vbml0b3IsIHRyYW5zZm9ybXMgPSBbXSApIHtcclxuXHJcblx0XHR0aGlzLnZlcnRleFNoYWRlciA9IHZlcnRleFNoYWRlcjtcclxuXHRcdHRoaXMuZnJhZ21lbnRTaGFkZXIgPSBmcmFnbWVudFNoYWRlcjtcclxuXHRcdHRoaXMuY29tcHV0ZVNoYWRlciA9IGNvbXB1dGVTaGFkZXI7XHJcblx0XHR0aGlzLnRyYW5zZm9ybXMgPSB0cmFuc2Zvcm1zO1xyXG5cclxuXHRcdHRoaXMubm9kZUF0dHJpYnV0ZXMgPSBub2RlQXR0cmlidXRlcztcclxuXHRcdHRoaXMuYmluZGluZ3MgPSBiaW5kaW5ncztcclxuXHJcblx0XHR0aGlzLnVwZGF0ZU5vZGVzID0gdXBkYXRlTm9kZXM7XHJcblx0XHR0aGlzLnVwZGF0ZUJlZm9yZU5vZGVzID0gdXBkYXRlQmVmb3JlTm9kZXM7XHJcblx0XHR0aGlzLnVwZGF0ZUFmdGVyTm9kZXMgPSB1cGRhdGVBZnRlck5vZGVzO1xyXG5cclxuXHRcdHRoaXMubW9uaXRvciA9IG1vbml0b3I7XHJcblxyXG5cdFx0dGhpcy51c2VkVGltZXMgPSAwO1xyXG5cclxuXHR9XHJcblxyXG5cdGNyZWF0ZUJpbmRpbmdzKCkge1xyXG5cclxuXHRcdGNvbnN0IGJpbmRpbmdzID0gW107XHJcblxyXG5cdFx0Zm9yICggY29uc3QgaW5zdGFuY2VHcm91cCBvZiB0aGlzLmJpbmRpbmdzICkge1xyXG5cclxuXHRcdFx0Y29uc3Qgc2hhcmVkID0gaW5zdGFuY2VHcm91cC5iaW5kaW5nc1sgMCBdLmdyb3VwTm9kZS5zaGFyZWQ7XHJcblxyXG5cdFx0XHRpZiAoIHNoYXJlZCAhPT0gdHJ1ZSApIHtcclxuXHJcblx0XHRcdFx0Y29uc3QgYmluZGluZ3NHcm91cCA9IG5ldyBCaW5kR3JvdXAoIGluc3RhbmNlR3JvdXAubmFtZSwgW10sIGluc3RhbmNlR3JvdXAuaW5kZXgsIGluc3RhbmNlR3JvdXAgKTtcclxuXHRcdFx0XHRiaW5kaW5ncy5wdXNoKCBiaW5kaW5nc0dyb3VwICk7XHJcblxyXG5cdFx0XHRcdGZvciAoIGNvbnN0IGluc3RhbmNlQmluZGluZyBvZiBpbnN0YW5jZUdyb3VwLmJpbmRpbmdzICkge1xyXG5cclxuXHRcdFx0XHRcdGJpbmRpbmdzR3JvdXAuYmluZGluZ3MucHVzaCggaW5zdGFuY2VCaW5kaW5nLmNsb25lKCkgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0YmluZGluZ3MucHVzaCggaW5zdGFuY2VHcm91cCApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gYmluZGluZ3M7XHJcblxyXG5cdH1cclxuXHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IE5vZGVCdWlsZGVyU3RhdGU7XHJcbiIsIi8qKlxyXG4gKiB7QGxpbmsgTm9kZUJ1aWxkZXJ9IGlzIGdvaW5nIHRvIGNyZWF0ZSBpbnN0YW5jZXMgb2YgdGhpcyBjbGFzcyBkdXJpbmcgdGhlIGJ1aWxkIHByb2Nlc3NcclxuICogb2Ygbm9kZXMuIFRoZXkgcmVwcmVzZW50IHRoZSBmaW5hbCBzaGFkZXIgYXR0cmlidXRlcyB0aGF0IGFyZSBnb2luZyB0byBiZSBnZW5lcmF0ZWRcclxuICogYnkgdGhlIGJ1aWxkZXIuIEFycmF5cyBvZiBub2RlIGF0dHJpYnV0ZXMgaXMgbWFpbnRhaW5lZCBpbiB7QGxpbmsgTm9kZUJ1aWxkZXIjYXR0cmlidXRlc31cclxuICogYW5kIHtAbGluayBOb2RlQnVpbGRlciNidWZmZXJBdHRyaWJ1dGVzfSBmb3IgdGhpcyBwdXJwb3NlLlxyXG4gKi9cclxuY2xhc3MgTm9kZUF0dHJpYnV0ZSB7XHJcblxyXG5cdC8qKlxyXG5cdCAqIENvbnN0cnVjdHMgYSBuZXcgbm9kZSBhdHRyaWJ1dGUuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBhdHRyaWJ1dGUuXHJcblx0ICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgLSBUaGUgdHlwZSBvZiB0aGUgYXR0cmlidXRlLlxyXG5cdCAqIEBwYXJhbSB7Tm9kZT99IG5vZGUgLSBBbiBvcHRpb25hbCByZWZlcmVuY2UgdG8gdGhlIG5vZGUuXHJcblx0ICovXHJcblx0Y29uc3RydWN0b3IoIG5hbWUsIHR5cGUsIG5vZGUgPSBudWxsICkge1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogVGhpcyBmbGFnIGNhbiBiZSB1c2VkIGZvciB0eXBlIHRlc3RpbmcuXHJcblx0XHQgKlxyXG5cdFx0ICogQHR5cGUge0Jvb2xlYW59XHJcblx0XHQgKiBAcmVhZG9ubHlcclxuXHRcdCAqIEBkZWZhdWx0IHRydWVcclxuXHRcdCAqL1xyXG5cdFx0dGhpcy5pc05vZGVBdHRyaWJ1dGUgPSB0cnVlO1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogVGhlIG5hbWUgb2YgdGhlIGF0dHJpYnV0ZS5cclxuXHRcdCAqXHJcblx0XHQgKiBAdHlwZSB7U3RyaW5nfVxyXG5cdFx0ICovXHJcblx0XHR0aGlzLm5hbWUgPSBuYW1lO1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogVGhlIHR5cGUgb2YgdGhlIGF0dHJpYnV0ZS5cclxuXHRcdCAqXHJcblx0XHQgKiBAdHlwZSB7U3RyaW5nfVxyXG5cdFx0ICovXHJcblx0XHR0aGlzLnR5cGUgPSB0eXBlO1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogQW4gb3B0aW9uYWwgcmVmZXJlbmNlIHRvIHRoZSBub2RlLlxyXG5cdFx0ICpcclxuXHRcdCAqIEB0eXBlIHtOb2RlP31cclxuXHRcdCAqIEBkZWZhdWx0IG51bGxcclxuXHRcdCAqL1xyXG5cdFx0dGhpcy5ub2RlID0gbm9kZTtcclxuXHJcblx0fVxyXG5cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgTm9kZUF0dHJpYnV0ZTtcclxuIiwiLyoqXHJcbiAqIHtAbGluayBOb2RlQnVpbGRlcn0gaXMgZ29pbmcgdG8gY3JlYXRlIGluc3RhbmNlcyBvZiB0aGlzIGNsYXNzIGR1cmluZyB0aGUgYnVpbGQgcHJvY2Vzc1xyXG4gKiBvZiBub2Rlcy4gVGhleSByZXByZXNlbnQgdGhlIGZpbmFsIHNoYWRlciB1bmlmb3JtcyB0aGF0IGFyZSBnb2luZyB0byBiZSBnZW5lcmF0ZWRcclxuICogYnkgdGhlIGJ1aWxkZXIuIEEgZGljdGlvbmFyeSBvZiBub2RlIHVuaWZvcm1zIGlzIG1haW50YWluZWQgaW4ge0BsaW5rIE5vZGVCdWlsZGVyI3VuaWZvcm1zfVxyXG4gKiBmb3IgdGhpcyBwdXJwb3NlLlxyXG4gKi9cclxuY2xhc3MgTm9kZVVuaWZvcm0ge1xyXG5cclxuXHQvKipcclxuXHQgKiBDb25zdHJ1Y3RzIGEgbmV3IG5vZGUgdW5pZm9ybS5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIC0gVGhlIG5hbWUgb2YgdGhlIHVuaWZvcm0uXHJcblx0ICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgLSBUaGUgdHlwZSBvZiB0aGUgdW5pZm9ybS5cclxuXHQgKiBAcGFyYW0ge1VuaWZvcm1Ob2RlfSBub2RlIC0gQW4gcmVmZXJlbmNlIHRvIHRoZSBub2RlLlxyXG5cdCAqL1xyXG5cdGNvbnN0cnVjdG9yKCBuYW1lLCB0eXBlLCBub2RlICkge1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogVGhpcyBmbGFnIGNhbiBiZSB1c2VkIGZvciB0eXBlIHRlc3RpbmcuXHJcblx0XHQgKlxyXG5cdFx0ICogQHR5cGUge0Jvb2xlYW59XHJcblx0XHQgKiBAcmVhZG9ubHlcclxuXHRcdCAqIEBkZWZhdWx0IHRydWVcclxuXHRcdCAqL1xyXG5cdFx0dGhpcy5pc05vZGVVbmlmb3JtID0gdHJ1ZTtcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIFRoZSBuYW1lIG9mIHRoZSB1bmlmb3JtLlxyXG5cdFx0ICpcclxuXHRcdCAqIEB0eXBlIHtTdHJpbmd9XHJcblx0XHQgKi9cclxuXHRcdHRoaXMubmFtZSA9IG5hbWU7XHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBUaGUgdHlwZSBvZiB0aGUgdW5pZm9ybS5cclxuXHRcdCAqXHJcblx0XHQgKiBAdHlwZSB7U3RyaW5nfVxyXG5cdFx0ICovXHJcblx0XHR0aGlzLnR5cGUgPSB0eXBlO1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogQW4gcmVmZXJlbmNlIHRvIHRoZSBub2RlLlxyXG5cdFx0ICpcclxuXHRcdCAqIEB0eXBlIHtVbmlmb3JtTm9kZX1cclxuXHRcdCAqL1xyXG5cdFx0dGhpcy5ub2RlID0gbm9kZS5nZXRTZWxmKCk7XHJcblxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogVGhlIHZhbHVlIG9mIHRoZSB1bmlmb3JtIG5vZGUuXHJcblx0ICpcclxuXHQgKiBAdHlwZSB7QW55fVxyXG5cdCAqL1xyXG5cdGdldCB2YWx1ZSgpIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5ub2RlLnZhbHVlO1xyXG5cclxuXHR9XHJcblxyXG5cdHNldCB2YWx1ZSggdmFsICkge1xyXG5cclxuXHRcdHRoaXMubm9kZS52YWx1ZSA9IHZhbDtcclxuXHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBUaGUgaWQgb2YgdGhlIHVuaWZvcm0gbm9kZS5cclxuXHQgKlxyXG5cdCAqIEB0eXBlIHtOdW1iZXJ9XHJcblx0ICovXHJcblx0Z2V0IGlkKCkge1xyXG5cclxuXHRcdHJldHVybiB0aGlzLm5vZGUuaWQ7XHJcblxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogVGhlIHVuaWZvcm0gbm9kZSdzIGdyb3VwLlxyXG5cdCAqXHJcblx0ICogQHR5cGUge1VuaWZvcm1Hcm91cE5vZGV9XHJcblx0ICovXHJcblx0Z2V0IGdyb3VwTm9kZSgpIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5ub2RlLmdyb3VwTm9kZTtcclxuXHJcblx0fVxyXG5cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgTm9kZVVuaWZvcm07XHJcbiIsIi8qKlxyXG4gKiB7QGxpbmsgTm9kZUJ1aWxkZXJ9IGlzIGdvaW5nIHRvIGNyZWF0ZSBpbnN0YW5jZXMgb2YgdGhpcyBjbGFzcyBkdXJpbmcgdGhlIGJ1aWxkIHByb2Nlc3NcclxuICogb2Ygbm9kZXMuIFRoZXkgcmVwcmVzZW50IHRoZSBmaW5hbCBzaGFkZXIgdmFyaWFibGVzIHRoYXQgYXJlIGdvaW5nIHRvIGJlIGdlbmVyYXRlZFxyXG4gKiBieSB0aGUgYnVpbGRlci4gQSBkaWN0aW9uYXJ5IG9mIG5vZGUgdmFyaWFibGVzIGlzIG1haW50YWluZWQgaW4ge0BsaW5rIE5vZGVCdWlsZGVyI3ZhcnN9IGZvclxyXG4gKiB0aGlzIHB1cnBvc2UuXHJcbiAqL1xyXG5jbGFzcyBOb2RlVmFyIHtcclxuXHJcblx0LyoqXHJcblx0ICogQ29uc3RydWN0cyBhIG5ldyBub2RlIHZhcmlhYmxlLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgdmFyaWFibGUuXHJcblx0ICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgLSBUaGUgdHlwZSBvZiB0aGUgdmFyaWFibGUuXHJcblx0ICovXHJcblx0Y29uc3RydWN0b3IoIG5hbWUsIHR5cGUgKSB7XHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBUaGlzIGZsYWcgY2FuIGJlIHVzZWQgZm9yIHR5cGUgdGVzdGluZy5cclxuXHRcdCAqXHJcblx0XHQgKiBAdHlwZSB7Qm9vbGVhbn1cclxuXHRcdCAqIEByZWFkb25seVxyXG5cdFx0ICogQGRlZmF1bHQgdHJ1ZVxyXG5cdFx0ICovXHJcblx0XHR0aGlzLmlzTm9kZVZhciA9IHRydWU7XHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBUaGUgbmFtZSBvZiB0aGUgdmFyaWFibGUuXHJcblx0XHQgKlxyXG5cdFx0ICogQHR5cGUge1N0cmluZ31cclxuXHRcdCAqL1xyXG5cdFx0dGhpcy5uYW1lID0gbmFtZTtcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIFRoZSB0eXBlIG9mIHRoZSB2YXJpYWJsZS5cclxuXHRcdCAqXHJcblx0XHQgKiBAdHlwZSB7U3RyaW5nfVxyXG5cdFx0ICovXHJcblx0XHR0aGlzLnR5cGUgPSB0eXBlO1xyXG5cclxuXHR9XHJcblxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBOb2RlVmFyO1xyXG4iLCJpbXBvcnQgTm9kZVZhciBmcm9tICcuL05vZGVWYXIuanMnO1xyXG5cclxuLyoqXHJcbiAqIHtAbGluayBOb2RlQnVpbGRlcn0gaXMgZ29pbmcgdG8gY3JlYXRlIGluc3RhbmNlcyBvZiB0aGlzIGNsYXNzIGR1cmluZyB0aGUgYnVpbGQgcHJvY2Vzc1xyXG4gKiBvZiBub2Rlcy4gVGhleSByZXByZXNlbnQgdGhlIGZpbmFsIHNoYWRlciB2YXJ5aW5ncyB0aGF0IGFyZSBnb2luZyB0byBiZSBnZW5lcmF0ZWRcclxuICogYnkgdGhlIGJ1aWxkZXIuIEFuIGFycmF5IG9mIG5vZGUgdmFyeWluZ3MgaXMgbWFpbnRhaW5lZCBpbiB7QGxpbmsgTm9kZUJ1aWxkZXIjdmFyeWluZ3N9IGZvclxyXG4gKiB0aGlzIHB1cnBvc2UuXHJcbiAqXHJcbiAqIEBhdWdtZW50cyBOb2RlVmFyXHJcbiAqL1xyXG5jbGFzcyBOb2RlVmFyeWluZyBleHRlbmRzIE5vZGVWYXIge1xyXG5cclxuXHQvKipcclxuXHQgKiBDb25zdHJ1Y3RzIGEgbmV3IG5vZGUgdmFyeWluZy5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIC0gVGhlIG5hbWUgb2YgdGhlIHZhcnlpbmcuXHJcblx0ICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgLSBUaGUgdHlwZSBvZiB0aGUgdmFyeWluZy5cclxuXHQgKi9cclxuXHRjb25zdHJ1Y3RvciggbmFtZSwgdHlwZSApIHtcclxuXHJcblx0XHRzdXBlciggbmFtZSwgdHlwZSApO1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogV2hldGhlciB0aGlzIHZhcnlpbmcgcmVxdWlyZXMgaW50ZXJwb2xhdGlvbiBvciBub3QuIFRoaXMgcHJvcGVydHkgY2FuIGJlIHVzZWRcclxuXHRcdCAqIHRvIGNoZWNrIGlmIHRoZSB2YXJ5aW5nIGNhbiBiZSBvcHRpbWl6ZWQgZm9yIGEgdmFyaWFibGUuXHJcblx0XHQgKlxyXG5cdFx0ICogQHR5cGUge0Jvb2xlYW59XHJcblx0XHQgKiBAZGVmYXVsdCBmYWxzZVxyXG5cdFx0ICovXHJcblx0XHR0aGlzLm5lZWRzSW50ZXJwb2xhdGlvbiA9IGZhbHNlO1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogVGhpcyBmbGFnIGNhbiBiZSB1c2VkIGZvciB0eXBlIHRlc3RpbmcuXHJcblx0XHQgKlxyXG5cdFx0ICogQHR5cGUge0Jvb2xlYW59XHJcblx0XHQgKiBAcmVhZG9ubHlcclxuXHRcdCAqIEBkZWZhdWx0IHRydWVcclxuXHRcdCAqL1xyXG5cdFx0dGhpcy5pc05vZGVWYXJ5aW5nID0gdHJ1ZTtcclxuXHJcblx0fVxyXG5cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgTm9kZVZhcnlpbmc7XHJcbiIsIi8qKlxyXG4gKiB7QGxpbmsgTm9kZUJ1aWxkZXJ9IGlzIGdvaW5nIHRvIGNyZWF0ZSBpbnN0YW5jZXMgb2YgdGhpcyBjbGFzcyBkdXJpbmcgdGhlIGJ1aWxkIHByb2Nlc3NcclxuICogb2Ygbm9kZXMuIFRoZXkgcmVwcmVzZW50IHVzZXItZGVmaW5lZCwgbmF0aXZlIHNoYWRlciBjb2RlIHBvcnRpb25zIHRoYXQgYXJlIGdvaW5nIHRvIGJlXHJcbiAqIGluamVjdGVkIGJ5IHRoZSBidWlsZGVyLiBBIGRpY3Rpb25hcnkgb2Ygbm9kZSBjb2RlcyBpcyBtYWludGFpbmVkIGluIHtAbGluayBOb2RlQnVpbGRlciNjb2Rlc31cclxuICogZm9yIHRoaXMgcHVycG9zZS5cclxuICovXHJcbmNsYXNzIE5vZGVDb2RlIHtcclxuXHJcblx0LyoqXHJcblx0ICogQ29uc3RydWN0cyBhIG5ldyBjb2RlIG5vZGUuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBjb2RlLlxyXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIC0gVGhlIG5vZGUgdHlwZS5cclxuXHQgKiBAcGFyYW0ge1N0cmluZ30gW2NvZGU9JyddIC0gVGhlIG5hdGl2ZSBzaGFkZXIgY29kZS5cclxuXHQgKi9cclxuXHRjb25zdHJ1Y3RvciggbmFtZSwgdHlwZSwgY29kZSA9ICcnICkge1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogVGhlIG5hbWUgb2YgdGhlIGNvZGUuXHJcblx0XHQgKlxyXG5cdFx0ICogQHR5cGUge1N0cmluZ31cclxuXHRcdCAqL1xyXG5cdFx0dGhpcy5uYW1lID0gbmFtZTtcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIFRoZSBub2RlIHR5cGUuXHJcblx0XHQgKlxyXG5cdFx0ICogQHR5cGUge1N0cmluZ31cclxuXHRcdCAqL1xyXG5cdFx0dGhpcy50eXBlID0gdHlwZTtcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIFRoZSBuYXRpdmUgc2hhZGVyIGNvZGUuXHJcblx0XHQgKlxyXG5cdFx0ICogQHR5cGUge1N0cmluZ31cclxuXHRcdCAqIEBkZWZhdWx0ICcnXHJcblx0XHQgKi9cclxuXHRcdHRoaXMuY29kZSA9IGNvZGU7XHJcblxyXG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KCB0aGlzLCAnaXNOb2RlQ29kZScsIHsgdmFsdWU6IHRydWUgfSApO1xyXG5cclxuXHR9XHJcblxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBOb2RlQ29kZTtcclxuIiwibGV0IF9pZCA9IDA7XHJcblxyXG4vKipcclxuICogVGhpcyB1dGlsaXR5IGNsYXNzIGlzIHVzZWQgaW4ge0BsaW5rIE5vZGVCdWlsZGVyfSBhcyBhbiBpbnRlcm5hbFxyXG4gKiBjYWNoZSBkYXRhIHN0cnVjdHVyZSBmb3Igbm9kZSBkYXRhLlxyXG4gKi9cclxuY2xhc3MgTm9kZUNhY2hlIHtcclxuXHJcblx0LyoqXHJcblx0ICogQ29uc3RydWN0cyBhIG5ldyBub2RlIGNhY2hlLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtOb2RlQ2FjaGU/fSBwYXJlbnQgLSBBIHJlZmVyZW5jZSB0byBhIHBhcmVudCBjYWNoZS5cclxuXHQgKi9cclxuXHRjb25zdHJ1Y3RvciggcGFyZW50ID0gbnVsbCApIHtcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIFRoZSBpZCBvZiB0aGUgY2FjaGUuXHJcblx0XHQgKlxyXG5cdFx0ICogQHR5cGUge051bWJlcn1cclxuXHRcdCAqIEByZWFkb25seVxyXG5cdFx0ICovXHJcblx0XHR0aGlzLmlkID0gX2lkICsrO1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogQSB3ZWFrIG1hcCBmb3IgbWFuYWdpbmcgbm9kZSBkYXRhLlxyXG5cdFx0ICpcclxuXHRcdCAqIEB0eXBlIHtXZWFrTWFwPE5vZGUsIE9iamVjdD59XHJcblx0XHQgKi9cclxuXHRcdHRoaXMubm9kZXNEYXRhID0gbmV3IFdlYWtNYXAoKTtcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIFJlZmVyZW5jZSB0byBhIHBhcmVudCBub2RlIGNhY2hlLlxyXG5cdFx0ICpcclxuXHRcdCAqIEB0eXBlIHtOb2RlQ2FjaGU/fVxyXG5cdFx0ICogQGRlZmF1bHQgbnVsbFxyXG5cdFx0ICovXHJcblx0XHR0aGlzLnBhcmVudCA9IHBhcmVudDtcclxuXHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBSZXR1cm5zIHRoZSBkYXRhIGZvciB0aGUgZ2l2ZW4gbm9kZS5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7Tm9kZX0gbm9kZSAtIFRoZSBub2RlLlxyXG5cdCAqIEByZXR1cm4ge09iamVjdD99IFRoZSBkYXRhIGZvciB0aGUgbm9kZS5cclxuXHQgKi9cclxuXHRnZXREYXRhKCBub2RlICkge1xyXG5cclxuXHRcdGxldCBkYXRhID0gdGhpcy5ub2Rlc0RhdGEuZ2V0KCBub2RlICk7XHJcblxyXG5cdFx0aWYgKCBkYXRhID09PSB1bmRlZmluZWQgJiYgdGhpcy5wYXJlbnQgIT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHRkYXRhID0gdGhpcy5wYXJlbnQuZ2V0RGF0YSggbm9kZSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gZGF0YTtcclxuXHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBTZXRzIHRoZSBkYXRhIGZvciBhIGdpdmVuIG5vZGUuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge05vZGV9IG5vZGUgLSBUaGUgbm9kZS5cclxuXHQgKiBAcGFyYW0ge09iamVjdH0gZGF0YSAtIFRoZSBkYXRhIHRoYXQgc2hvdWxkIGJlIGNhY2hlZC5cclxuXHQgKi9cclxuXHRzZXREYXRhKCBub2RlLCBkYXRhICkge1xyXG5cclxuXHRcdHRoaXMubm9kZXNEYXRhLnNldCggbm9kZSwgZGF0YSApO1xyXG5cclxuXHR9XHJcblxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBOb2RlQ2FjaGU7XHJcbiIsImltcG9ydCBOb2RlIGZyb20gJy4vTm9kZS5qcyc7XHJcblxyXG4vKipcclxuICoge0BsaW5rIE5vZGVCdWlsZGVyfSBpcyBnb2luZyB0byBjcmVhdGUgaW5zdGFuY2VzIG9mIHRoaXMgY2xhc3MgZHVyaW5nIHRoZSBidWlsZCBwcm9jZXNzXHJcbiAqIG9mIG5vZGVzLiBUaGV5IHJlcHJlc2VudCB0aGUgZmluYWwgc2hhZGVyIHN0cnVjdCBkYXRhIHRoYXQgYXJlIGdvaW5nIHRvIGJlIGdlbmVyYXRlZFxyXG4gKiBieSB0aGUgYnVpbGRlci4gQSBkaWN0aW9uYXJ5IG9mIHN0cnVjdCB0eXBlcyBpcyBtYWludGFpbmVkIGluIHtAbGluayBOb2RlQnVpbGRlciNzdHJ1Y3RzfVxyXG4gKiBmb3IgdGhpcyBwdXJwb3NlLlxyXG4gKi9cclxuY2xhc3MgU3RydWN0VHlwZU5vZGUgZXh0ZW5kcyBOb2RlIHtcclxuXHJcblx0c3RhdGljIGdldCB0eXBlKCkge1xyXG5cclxuXHRcdHJldHVybiAnU3RydWN0VHlwZU5vZGUnO1xyXG5cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIENvbnN0cnVjdHMgYSBuZXcgc3RydWN0IHR5cGUgbm9kZS5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIC0gVGhlIG5hbWUgb2YgdGhlIHN0cnVjdC5cclxuXHQgKiBAcGFyYW0ge0FycmF5PFN0cmluZz59IHR5cGVzIC0gQW4gYXJyYXkgb2YgdHlwZXMuXHJcblx0ICovXHJcblx0Y29uc3RydWN0b3IoIG5hbWUsIHR5cGVzICkge1xyXG5cclxuXHRcdHN1cGVyKCk7XHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBUaGUgbmFtZSBvZiB0aGUgc3RydWN0LlxyXG5cdFx0ICpcclxuXHRcdCAqIEB0eXBlIHtTdHJpbmd9XHJcblx0XHQgKi9cclxuXHRcdHRoaXMubmFtZSA9IG5hbWU7XHJcblxyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogQW4gYXJyYXkgb2YgdHlwZXMuXHJcblx0XHQgKlxyXG5cdFx0ICogQHR5cGUge0FycmF5PFN0cmluZz59XHJcblx0XHQgKi9cclxuXHRcdHRoaXMudHlwZXMgPSB0eXBlcztcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIFRoaXMgZmxhZyBjYW4gYmUgdXNlZCBmb3IgdHlwZSB0ZXN0aW5nLlxyXG5cdFx0ICpcclxuXHRcdCAqIEB0eXBlIHtCb29sZWFufVxyXG5cdFx0ICogQHJlYWRvbmx5XHJcblx0XHQgKiBAZGVmYXVsdCB0cnVlXHJcblx0XHQgKi9cclxuXHRcdHRoaXMuaXNTdHJ1Y3RUeXBlTm9kZSA9IHRydWU7XHJcblxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogUmV0dXJucyB0aGUgbWVtYmVyIHR5cGVzLlxyXG5cdCAqXHJcblx0ICogQHJldHVybiB7QXJyYXk8U3RyaW5nPn0gVGhlIHR5cGVzLlxyXG5cdCAqL1xyXG5cdGdldE1lbWJlclR5cGVzKCkge1xyXG5cclxuXHRcdHJldHVybiB0aGlzLnR5cGVzO1xyXG5cclxuXHR9XHJcblxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBTdHJ1Y3RUeXBlTm9kZTtcclxuIiwiaW1wb3J0IHsgQ29sb3IgfSBmcm9tICcuLi8uLi9tYXRoL0NvbG9yLmpzJztcclxuaW1wb3J0IHsgTWF0cml4MyB9IGZyb20gJy4uLy4uL21hdGgvTWF0cml4My5qcyc7XHJcbmltcG9ydCB7IE1hdHJpeDQgfSBmcm9tICcuLi8uLi9tYXRoL01hdHJpeDQuanMnO1xyXG5pbXBvcnQgeyBWZWN0b3IyIH0gZnJvbSAnLi4vLi4vbWF0aC9WZWN0b3IyLmpzJztcclxuaW1wb3J0IHsgVmVjdG9yMyB9IGZyb20gJy4uLy4uL21hdGgvVmVjdG9yMy5qcyc7XHJcbmltcG9ydCB7IFZlY3RvcjQgfSBmcm9tICcuLi8uLi9tYXRoL1ZlY3RvcjQuanMnO1xyXG5cclxuY2xhc3MgVW5pZm9ybSB7XHJcblxyXG5cdGNvbnN0cnVjdG9yKCBuYW1lLCB2YWx1ZSApIHtcclxuXHJcblx0XHR0aGlzLm5hbWUgPSBuYW1lO1xyXG5cdFx0dGhpcy52YWx1ZSA9IHZhbHVlO1xyXG5cclxuXHRcdHRoaXMuYm91bmRhcnkgPSAwOyAvLyB1c2VkIHRvIGJ1aWxkIHRoZSB1bmlmb3JtIGJ1ZmZlciBhY2NvcmRpbmcgdG8gdGhlIFNURDE0MCBsYXlvdXRcclxuXHRcdHRoaXMuaXRlbVNpemUgPSAwO1xyXG5cclxuXHRcdHRoaXMub2Zmc2V0ID0gMDsgLy8gdGhpcyBwcm9wZXJ0eSBpcyBzZXQgYnkgV2ViR1BVVW5pZm9ybXNHcm91cCBhbmQgbWFya3MgdGhlIHN0YXJ0IHBvc2l0aW9uIGluIHRoZSB1bmlmb3JtIGJ1ZmZlclxyXG5cclxuXHR9XHJcblxyXG5cdHNldFZhbHVlKCB2YWx1ZSApIHtcclxuXHJcblx0XHR0aGlzLnZhbHVlID0gdmFsdWU7XHJcblxyXG5cdH1cclxuXHJcblx0Z2V0VmFsdWUoKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMudmFsdWU7XHJcblxyXG5cdH1cclxuXHJcbn1cclxuXHJcbmNsYXNzIE51bWJlclVuaWZvcm0gZXh0ZW5kcyBVbmlmb3JtIHtcclxuXHJcblx0Y29uc3RydWN0b3IoIG5hbWUsIHZhbHVlID0gMCApIHtcclxuXHJcblx0XHRzdXBlciggbmFtZSwgdmFsdWUgKTtcclxuXHJcblx0XHR0aGlzLmlzTnVtYmVyVW5pZm9ybSA9IHRydWU7XHJcblxyXG5cdFx0dGhpcy5ib3VuZGFyeSA9IDQ7XHJcblx0XHR0aGlzLml0ZW1TaXplID0gMTtcclxuXHJcblx0fVxyXG5cclxufVxyXG5cclxuY2xhc3MgVmVjdG9yMlVuaWZvcm0gZXh0ZW5kcyBVbmlmb3JtIHtcclxuXHJcblx0Y29uc3RydWN0b3IoIG5hbWUsIHZhbHVlID0gbmV3IFZlY3RvcjIoKSApIHtcclxuXHJcblx0XHRzdXBlciggbmFtZSwgdmFsdWUgKTtcclxuXHJcblx0XHR0aGlzLmlzVmVjdG9yMlVuaWZvcm0gPSB0cnVlO1xyXG5cclxuXHRcdHRoaXMuYm91bmRhcnkgPSA4O1xyXG5cdFx0dGhpcy5pdGVtU2l6ZSA9IDI7XHJcblxyXG5cdH1cclxuXHJcbn1cclxuXHJcbmNsYXNzIFZlY3RvcjNVbmlmb3JtIGV4dGVuZHMgVW5pZm9ybSB7XHJcblxyXG5cdGNvbnN0cnVjdG9yKCBuYW1lLCB2YWx1ZSA9IG5ldyBWZWN0b3IzKCkgKSB7XHJcblxyXG5cdFx0c3VwZXIoIG5hbWUsIHZhbHVlICk7XHJcblxyXG5cdFx0dGhpcy5pc1ZlY3RvcjNVbmlmb3JtID0gdHJ1ZTtcclxuXHJcblx0XHR0aGlzLmJvdW5kYXJ5ID0gMTY7XHJcblx0XHR0aGlzLml0ZW1TaXplID0gMztcclxuXHJcblx0fVxyXG5cclxufVxyXG5cclxuY2xhc3MgVmVjdG9yNFVuaWZvcm0gZXh0ZW5kcyBVbmlmb3JtIHtcclxuXHJcblx0Y29uc3RydWN0b3IoIG5hbWUsIHZhbHVlID0gbmV3IFZlY3RvcjQoKSApIHtcclxuXHJcblx0XHRzdXBlciggbmFtZSwgdmFsdWUgKTtcclxuXHJcblx0XHR0aGlzLmlzVmVjdG9yNFVuaWZvcm0gPSB0cnVlO1xyXG5cclxuXHRcdHRoaXMuYm91bmRhcnkgPSAxNjtcclxuXHRcdHRoaXMuaXRlbVNpemUgPSA0O1xyXG5cclxuXHR9XHJcblxyXG59XHJcblxyXG5jbGFzcyBDb2xvclVuaWZvcm0gZXh0ZW5kcyBVbmlmb3JtIHtcclxuXHJcblx0Y29uc3RydWN0b3IoIG5hbWUsIHZhbHVlID0gbmV3IENvbG9yKCkgKSB7XHJcblxyXG5cdFx0c3VwZXIoIG5hbWUsIHZhbHVlICk7XHJcblxyXG5cdFx0dGhpcy5pc0NvbG9yVW5pZm9ybSA9IHRydWU7XHJcblxyXG5cdFx0dGhpcy5ib3VuZGFyeSA9IDE2O1xyXG5cdFx0dGhpcy5pdGVtU2l6ZSA9IDM7XHJcblxyXG5cdH1cclxuXHJcbn1cclxuXHJcbmNsYXNzIE1hdHJpeDNVbmlmb3JtIGV4dGVuZHMgVW5pZm9ybSB7XHJcblxyXG5cdGNvbnN0cnVjdG9yKCBuYW1lLCB2YWx1ZSA9IG5ldyBNYXRyaXgzKCkgKSB7XHJcblxyXG5cdFx0c3VwZXIoIG5hbWUsIHZhbHVlICk7XHJcblxyXG5cdFx0dGhpcy5pc01hdHJpeDNVbmlmb3JtID0gdHJ1ZTtcclxuXHJcblx0XHR0aGlzLmJvdW5kYXJ5ID0gNDg7XHJcblx0XHR0aGlzLml0ZW1TaXplID0gMTI7XHJcblxyXG5cdH1cclxuXHJcbn1cclxuXHJcbmNsYXNzIE1hdHJpeDRVbmlmb3JtIGV4dGVuZHMgVW5pZm9ybSB7XHJcblxyXG5cdGNvbnN0cnVjdG9yKCBuYW1lLCB2YWx1ZSA9IG5ldyBNYXRyaXg0KCkgKSB7XHJcblxyXG5cdFx0c3VwZXIoIG5hbWUsIHZhbHVlICk7XHJcblxyXG5cdFx0dGhpcy5pc01hdHJpeDRVbmlmb3JtID0gdHJ1ZTtcclxuXHJcblx0XHR0aGlzLmJvdW5kYXJ5ID0gNjQ7XHJcblx0XHR0aGlzLml0ZW1TaXplID0gMTY7XHJcblxyXG5cdH1cclxuXHJcbn1cclxuXHJcbmV4cG9ydCB7XHJcblx0TnVtYmVyVW5pZm9ybSxcclxuXHRWZWN0b3IyVW5pZm9ybSwgVmVjdG9yM1VuaWZvcm0sIFZlY3RvcjRVbmlmb3JtLCBDb2xvclVuaWZvcm0sXHJcblx0TWF0cml4M1VuaWZvcm0sIE1hdHJpeDRVbmlmb3JtXHJcbn07XHJcbiIsImltcG9ydCB7XHJcblx0TnVtYmVyVW5pZm9ybSwgVmVjdG9yMlVuaWZvcm0sIFZlY3RvcjNVbmlmb3JtLCBWZWN0b3I0VW5pZm9ybSxcclxuXHRDb2xvclVuaWZvcm0sIE1hdHJpeDNVbmlmb3JtLCBNYXRyaXg0VW5pZm9ybVxyXG59IGZyb20gJy4uL1VuaWZvcm0uanMnO1xyXG5cclxuY2xhc3MgTnVtYmVyTm9kZVVuaWZvcm0gZXh0ZW5kcyBOdW1iZXJVbmlmb3JtIHtcclxuXHJcblx0Y29uc3RydWN0b3IoIG5vZGVVbmlmb3JtICkge1xyXG5cclxuXHRcdHN1cGVyKCBub2RlVW5pZm9ybS5uYW1lLCBub2RlVW5pZm9ybS52YWx1ZSApO1xyXG5cclxuXHRcdHRoaXMubm9kZVVuaWZvcm0gPSBub2RlVW5pZm9ybTtcclxuXHJcblx0fVxyXG5cclxuXHRnZXRWYWx1ZSgpIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5ub2RlVW5pZm9ybS52YWx1ZTtcclxuXHJcblx0fVxyXG5cclxuXHRnZXRUeXBlKCkge1xyXG5cclxuXHRcdHJldHVybiB0aGlzLm5vZGVVbmlmb3JtLnR5cGU7XHJcblxyXG5cdH1cclxuXHJcbn1cclxuXHJcbmNsYXNzIFZlY3RvcjJOb2RlVW5pZm9ybSBleHRlbmRzIFZlY3RvcjJVbmlmb3JtIHtcclxuXHJcblx0Y29uc3RydWN0b3IoIG5vZGVVbmlmb3JtICkge1xyXG5cclxuXHRcdHN1cGVyKCBub2RlVW5pZm9ybS5uYW1lLCBub2RlVW5pZm9ybS52YWx1ZSApO1xyXG5cclxuXHRcdHRoaXMubm9kZVVuaWZvcm0gPSBub2RlVW5pZm9ybTtcclxuXHJcblx0fVxyXG5cclxuXHRnZXRWYWx1ZSgpIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5ub2RlVW5pZm9ybS52YWx1ZTtcclxuXHJcblx0fVxyXG5cclxuXHRnZXRUeXBlKCkge1xyXG5cclxuXHRcdHJldHVybiB0aGlzLm5vZGVVbmlmb3JtLnR5cGU7XHJcblxyXG5cdH1cclxuXHJcbn1cclxuXHJcbmNsYXNzIFZlY3RvcjNOb2RlVW5pZm9ybSBleHRlbmRzIFZlY3RvcjNVbmlmb3JtIHtcclxuXHJcblx0Y29uc3RydWN0b3IoIG5vZGVVbmlmb3JtICkge1xyXG5cclxuXHRcdHN1cGVyKCBub2RlVW5pZm9ybS5uYW1lLCBub2RlVW5pZm9ybS52YWx1ZSApO1xyXG5cclxuXHRcdHRoaXMubm9kZVVuaWZvcm0gPSBub2RlVW5pZm9ybTtcclxuXHJcblx0fVxyXG5cclxuXHRnZXRWYWx1ZSgpIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5ub2RlVW5pZm9ybS52YWx1ZTtcclxuXHJcblx0fVxyXG5cclxuXHRnZXRUeXBlKCkge1xyXG5cclxuXHRcdHJldHVybiB0aGlzLm5vZGVVbmlmb3JtLnR5cGU7XHJcblxyXG5cdH1cclxuXHJcbn1cclxuXHJcbmNsYXNzIFZlY3RvcjROb2RlVW5pZm9ybSBleHRlbmRzIFZlY3RvcjRVbmlmb3JtIHtcclxuXHJcblx0Y29uc3RydWN0b3IoIG5vZGVVbmlmb3JtICkge1xyXG5cclxuXHRcdHN1cGVyKCBub2RlVW5pZm9ybS5uYW1lLCBub2RlVW5pZm9ybS52YWx1ZSApO1xyXG5cclxuXHRcdHRoaXMubm9kZVVuaWZvcm0gPSBub2RlVW5pZm9ybTtcclxuXHJcblx0fVxyXG5cclxuXHRnZXRWYWx1ZSgpIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5ub2RlVW5pZm9ybS52YWx1ZTtcclxuXHJcblx0fVxyXG5cclxuXHRnZXRUeXBlKCkge1xyXG5cclxuXHRcdHJldHVybiB0aGlzLm5vZGVVbmlmb3JtLnR5cGU7XHJcblxyXG5cdH1cclxuXHJcbn1cclxuXHJcbmNsYXNzIENvbG9yTm9kZVVuaWZvcm0gZXh0ZW5kcyBDb2xvclVuaWZvcm0ge1xyXG5cclxuXHRjb25zdHJ1Y3Rvciggbm9kZVVuaWZvcm0gKSB7XHJcblxyXG5cdFx0c3VwZXIoIG5vZGVVbmlmb3JtLm5hbWUsIG5vZGVVbmlmb3JtLnZhbHVlICk7XHJcblxyXG5cdFx0dGhpcy5ub2RlVW5pZm9ybSA9IG5vZGVVbmlmb3JtO1xyXG5cclxuXHR9XHJcblxyXG5cdGdldFZhbHVlKCkge1xyXG5cclxuXHRcdHJldHVybiB0aGlzLm5vZGVVbmlmb3JtLnZhbHVlO1xyXG5cclxuXHR9XHJcblxyXG5cdGdldFR5cGUoKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMubm9kZVVuaWZvcm0udHlwZTtcclxuXHJcblx0fVxyXG5cclxufVxyXG5cclxuY2xhc3MgTWF0cml4M05vZGVVbmlmb3JtIGV4dGVuZHMgTWF0cml4M1VuaWZvcm0ge1xyXG5cclxuXHRjb25zdHJ1Y3Rvciggbm9kZVVuaWZvcm0gKSB7XHJcblxyXG5cdFx0c3VwZXIoIG5vZGVVbmlmb3JtLm5hbWUsIG5vZGVVbmlmb3JtLnZhbHVlICk7XHJcblxyXG5cdFx0dGhpcy5ub2RlVW5pZm9ybSA9IG5vZGVVbmlmb3JtO1xyXG5cclxuXHR9XHJcblxyXG5cdGdldFZhbHVlKCkge1xyXG5cclxuXHRcdHJldHVybiB0aGlzLm5vZGVVbmlmb3JtLnZhbHVlO1xyXG5cclxuXHR9XHJcblxyXG5cdGdldFR5cGUoKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMubm9kZVVuaWZvcm0udHlwZTtcclxuXHJcblx0fVxyXG5cclxufVxyXG5cclxuY2xhc3MgTWF0cml4NE5vZGVVbmlmb3JtIGV4dGVuZHMgTWF0cml4NFVuaWZvcm0ge1xyXG5cclxuXHRjb25zdHJ1Y3Rvciggbm9kZVVuaWZvcm0gKSB7XHJcblxyXG5cdFx0c3VwZXIoIG5vZGVVbmlmb3JtLm5hbWUsIG5vZGVVbmlmb3JtLnZhbHVlICk7XHJcblxyXG5cdFx0dGhpcy5ub2RlVW5pZm9ybSA9IG5vZGVVbmlmb3JtO1xyXG5cclxuXHR9XHJcblxyXG5cdGdldFZhbHVlKCkge1xyXG5cclxuXHRcdHJldHVybiB0aGlzLm5vZGVVbmlmb3JtLnZhbHVlO1xyXG5cclxuXHR9XHJcblxyXG5cdGdldFR5cGUoKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMubm9kZVVuaWZvcm0udHlwZTtcclxuXHJcblx0fVxyXG5cclxufVxyXG5cclxuZXhwb3J0IHtcclxuXHROdW1iZXJOb2RlVW5pZm9ybSwgVmVjdG9yMk5vZGVVbmlmb3JtLCBWZWN0b3IzTm9kZVVuaWZvcm0sIFZlY3RvcjROb2RlVW5pZm9ybSxcclxuXHRDb2xvck5vZGVVbmlmb3JtLCBNYXRyaXgzTm9kZVVuaWZvcm0sIE1hdHJpeDROb2RlVW5pZm9ybVxyXG59O1xyXG4iLCJpbXBvcnQgTm9kZU1hdGVyaWFsIGZyb20gJy4uLy4uLy4uL21hdGVyaWFscy9ub2Rlcy9Ob2RlTWF0ZXJpYWwuanMnO1xyXG5pbXBvcnQgeyBnZXREaXJlY3Rpb24sIGJsdXIgfSBmcm9tICcuLi8uLi8uLi9ub2Rlcy9wbXJlbS9QTVJFTVV0aWxzLmpzJztcclxuaW1wb3J0IHsgZXF1aXJlY3RVViB9IGZyb20gJy4uLy4uLy4uL25vZGVzL3V0aWxzL0VxdWlyZWN0VVZOb2RlLmpzJztcclxuaW1wb3J0IHsgdW5pZm9ybSB9IGZyb20gJy4uLy4uLy4uL25vZGVzL2NvcmUvVW5pZm9ybU5vZGUuanMnO1xyXG5pbXBvcnQgeyB1bmlmb3JtQXJyYXkgfSBmcm9tICcuLi8uLi8uLi9ub2Rlcy9hY2Nlc3NvcnMvVW5pZm9ybUFycmF5Tm9kZS5qcyc7XHJcbmltcG9ydCB7IHRleHR1cmUgfSBmcm9tICcuLi8uLi8uLi9ub2Rlcy9hY2Nlc3NvcnMvVGV4dHVyZU5vZGUuanMnO1xyXG5pbXBvcnQgeyBjdWJlVGV4dHVyZSB9IGZyb20gJy4uLy4uLy4uL25vZGVzL2FjY2Vzc29ycy9DdWJlVGV4dHVyZU5vZGUuanMnO1xyXG5pbXBvcnQgeyBmbG9hdCwgdmVjMyB9IGZyb20gJy4uLy4uLy4uL25vZGVzL3RzbC9UU0xCYXNlLmpzJztcclxuaW1wb3J0IHsgdXYgfSBmcm9tICcuLi8uLi8uLi9ub2Rlcy9hY2Nlc3NvcnMvVVYuanMnO1xyXG5pbXBvcnQgeyBhdHRyaWJ1dGUgfSBmcm9tICcuLi8uLi8uLi9ub2Rlcy9jb3JlL0F0dHJpYnV0ZU5vZGUuanMnO1xyXG5cclxuaW1wb3J0IHsgT3J0aG9ncmFwaGljQ2FtZXJhIH0gZnJvbSAnLi4vLi4vLi4vY2FtZXJhcy9PcnRob2dyYXBoaWNDYW1lcmEuanMnO1xyXG5pbXBvcnQgeyBDb2xvciB9IGZyb20gJy4uLy4uLy4uL21hdGgvQ29sb3IuanMnO1xyXG5pbXBvcnQgeyBWZWN0b3IzIH0gZnJvbSAnLi4vLi4vLi4vbWF0aC9WZWN0b3IzLmpzJztcclxuaW1wb3J0IHsgQnVmZmVyR2VvbWV0cnkgfSBmcm9tICcuLi8uLi8uLi9jb3JlL0J1ZmZlckdlb21ldHJ5LmpzJztcclxuaW1wb3J0IHsgQnVmZmVyQXR0cmlidXRlIH0gZnJvbSAnLi4vLi4vLi4vY29yZS9CdWZmZXJBdHRyaWJ1dGUuanMnO1xyXG5pbXBvcnQgeyBSZW5kZXJUYXJnZXQgfSBmcm9tICcuLi8uLi8uLi9jb3JlL1JlbmRlclRhcmdldC5qcyc7XHJcbmltcG9ydCB7IE1lc2ggfSBmcm9tICcuLi8uLi8uLi9vYmplY3RzL01lc2guanMnO1xyXG5pbXBvcnQgeyBQZXJzcGVjdGl2ZUNhbWVyYSB9IGZyb20gJy4uLy4uLy4uL2NhbWVyYXMvUGVyc3BlY3RpdmVDYW1lcmEuanMnO1xyXG5pbXBvcnQgeyBNZXNoQmFzaWNNYXRlcmlhbCB9IGZyb20gJy4uLy4uLy4uL21hdGVyaWFscy9NZXNoQmFzaWNNYXRlcmlhbC5qcyc7XHJcbmltcG9ydCB7IEJveEdlb21ldHJ5IH0gZnJvbSAnLi4vLi4vLi4vZ2VvbWV0cmllcy9Cb3hHZW9tZXRyeS5qcyc7XHJcbmltcG9ydCB7XHJcblx0Q3ViZVJlZmxlY3Rpb25NYXBwaW5nLFxyXG5cdEN1YmVSZWZyYWN0aW9uTWFwcGluZyxcclxuXHRDdWJlVVZSZWZsZWN0aW9uTWFwcGluZyxcclxuXHRMaW5lYXJGaWx0ZXIsXHJcblx0Tm9CbGVuZGluZyxcclxuXHRSR0JBRm9ybWF0LFxyXG5cdEhhbGZGbG9hdFR5cGUsXHJcblx0QmFja1NpZGUsXHJcblx0TGluZWFyU1JHQkNvbG9yU3BhY2VcclxufSBmcm9tICcuLi8uLi8uLi9jb25zdGFudHMuanMnO1xyXG5cclxuY29uc3QgTE9EX01JTiA9IDQ7XHJcblxyXG4vLyBUaGUgc3RhbmRhcmQgZGV2aWF0aW9ucyAocmFkaWFucykgYXNzb2NpYXRlZCB3aXRoIHRoZSBleHRyYSBtaXBzLiBUaGVzZSBhcmVcclxuLy8gY2hvc2VuIHRvIGFwcHJveGltYXRlIGEgVHJvd2JyaWRnZS1SZWl0eiBkaXN0cmlidXRpb24gZnVuY3Rpb24gdGltZXMgdGhlXHJcbi8vIGdlb21ldHJpYyBzaGFkb3dpbmcgZnVuY3Rpb24uIFRoZXNlIHNpZ21hIHZhbHVlcyBzcXVhcmVkIG11c3QgbWF0Y2ggdGhlXHJcbi8vIHZhcmlhbmNlICNkZWZpbmVzIGluIGN1YmVfdXZfcmVmbGVjdGlvbl9mcmFnbWVudC5nbHNsLmpzLlxyXG5jb25zdCBFWFRSQV9MT0RfU0lHTUEgPSBbIDAuMTI1LCAwLjIxNSwgMC4zNSwgMC40NDYsIDAuNTI2LCAwLjU4MiBdO1xyXG5cclxuLy8gVGhlIG1heGltdW0gbGVuZ3RoIG9mIHRoZSBibHVyIGZvciBsb29wLiBTbWFsbGVyIHNpZ21hcyB3aWxsIHVzZSBmZXdlclxyXG4vLyBzYW1wbGVzIGFuZCBleGl0IGVhcmx5LCBidXQgbm90IHJlY29tcGlsZSB0aGUgc2hhZGVyLlxyXG5jb25zdCBNQVhfU0FNUExFUyA9IDIwO1xyXG5cclxuY29uc3QgX2ZsYXRDYW1lcmEgPSAvKkBfX1BVUkVfXyovIG5ldyBPcnRob2dyYXBoaWNDYW1lcmEoIC0gMSwgMSwgMSwgLSAxLCAwLCAxICk7XHJcbmNvbnN0IF9jdWJlQ2FtZXJhID0gLypAX19QVVJFX18qLyBuZXcgUGVyc3BlY3RpdmVDYW1lcmEoIDkwLCAxICk7XHJcbmNvbnN0IF9jbGVhckNvbG9yID0gLypAX19QVVJFX18qLyBuZXcgQ29sb3IoKTtcclxubGV0IF9vbGRUYXJnZXQgPSBudWxsO1xyXG5sZXQgX29sZEFjdGl2ZUN1YmVGYWNlID0gMDtcclxubGV0IF9vbGRBY3RpdmVNaXBtYXBMZXZlbCA9IDA7XHJcblxyXG4vLyBHb2xkZW4gUmF0aW9cclxuY29uc3QgUEhJID0gKCAxICsgTWF0aC5zcXJ0KCA1ICkgKSAvIDI7XHJcbmNvbnN0IElOVl9QSEkgPSAxIC8gUEhJO1xyXG5cclxuLy8gVmVydGljZXMgb2YgYSBkb2RlY2FoZWRyb24gKGV4Y2VwdCB0aGUgb3Bwb3NpdGVzLCB3aGljaCByZXByZXNlbnQgdGhlXHJcbi8vIHNhbWUgYXhpcyksIHVzZWQgYXMgYXhpcyBkaXJlY3Rpb25zIGV2ZW5seSBzcHJlYWQgb24gYSBzcGhlcmUuXHJcbmNvbnN0IF9heGlzRGlyZWN0aW9ucyA9IFtcclxuXHQvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IzKCAtIFBISSwgSU5WX1BISSwgMCApLFxyXG5cdC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoIFBISSwgSU5WX1BISSwgMCApLFxyXG5cdC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoIC0gSU5WX1BISSwgMCwgUEhJICksXHJcblx0LypAX19QVVJFX18qLyBuZXcgVmVjdG9yMyggSU5WX1BISSwgMCwgUEhJICksXHJcblx0LypAX19QVVJFX18qLyBuZXcgVmVjdG9yMyggMCwgUEhJLCAtIElOVl9QSEkgKSxcclxuXHQvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IzKCAwLCBQSEksIElOVl9QSEkgKSxcclxuXHQvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IzKCAtIDEsIDEsIC0gMSApLFxyXG5cdC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoIDEsIDEsIC0gMSApLFxyXG5cdC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoIC0gMSwgMSwgMSApLFxyXG5cdC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoIDEsIDEsIDEgKVxyXG5dO1xyXG5cclxuLy9cclxuXHJcbi8vIFdlYkdQVSBGYWNlIGluZGljZXNcclxuY29uc3QgX2ZhY2VMaWIgPSBbXHJcblx0MywgMSwgNSxcclxuXHQwLCA0LCAyXHJcbl07XHJcblxyXG5jb25zdCBkaXJlY3Rpb24gPSBnZXREaXJlY3Rpb24oIHV2KCksIGF0dHJpYnV0ZSggJ2ZhY2VJbmRleCcgKSApLm5vcm1hbGl6ZSgpO1xyXG5jb25zdCBvdXRwdXREaXJlY3Rpb24gPSB2ZWMzKCBkaXJlY3Rpb24ueCwgZGlyZWN0aW9uLnksIGRpcmVjdGlvbi56ICk7XHJcblxyXG4vKipcclxuICogVGhpcyBjbGFzcyBnZW5lcmF0ZXMgYSBQcmVmaWx0ZXJlZCwgTWlwbWFwcGVkIFJhZGlhbmNlIEVudmlyb25tZW50IE1hcFxyXG4gKiAoUE1SRU0pIGZyb20gYSBjdWJlTWFwIGVudmlyb25tZW50IHRleHR1cmUuIFRoaXMgYWxsb3dzIGRpZmZlcmVudCBsZXZlbHMgb2ZcclxuICogYmx1ciB0byBiZSBxdWlja2x5IGFjY2Vzc2VkIGJhc2VkIG9uIG1hdGVyaWFsIHJvdWdobmVzcy4gSXQgaXMgcGFja2VkIGludG8gYVxyXG4gKiBzcGVjaWFsIEN1YmVVViBmb3JtYXQgdGhhdCBhbGxvd3MgdXMgdG8gcGVyZm9ybSBjdXN0b20gaW50ZXJwb2xhdGlvbiBzbyB0aGF0XHJcbiAqIHdlIGNhbiBzdXBwb3J0IG5vbmxpbmVhciBmb3JtYXRzIHN1Y2ggYXMgUkdCRS4gVW5saWtlIGEgdHJhZGl0aW9uYWwgbWlwbWFwXHJcbiAqIGNoYWluLCBpdCBvbmx5IGdvZXMgZG93biB0byB0aGUgTE9EX01JTiBsZXZlbCAoYWJvdmUpLCBhbmQgdGhlbiBjcmVhdGVzIGV4dHJhXHJcbiAqIGV2ZW4gbW9yZSBmaWx0ZXJlZCAnbWlwcycgYXQgdGhlIHNhbWUgTE9EX01JTiByZXNvbHV0aW9uLCBhc3NvY2lhdGVkIHdpdGhcclxuICogaGlnaGVyIHJvdWdobmVzcyBsZXZlbHMuIEluIHRoaXMgd2F5IHdlIG1haW50YWluIHJlc29sdXRpb24gdG8gc21vb3RobHlcclxuICogaW50ZXJwb2xhdGUgZGlmZnVzZSBsaWdodGluZyB3aGlsZSBsaW1pdGluZyBzYW1wbGluZyBjb21wdXRhdGlvbi5cclxuICpcclxuICogUGFwZXI6IEZhc3QsIEFjY3VyYXRlIEltYWdlLUJhc2VkIExpZ2h0aW5nXHJcbiAqIGh0dHBzOi8vZHJpdmUuZ29vZ2xlLmNvbS9maWxlL2QvMTV5OHJfVXBLbFU5U3ZWNElMYjBDM3FDUGVjUzhwdkx6L3ZpZXdcclxuKi9cclxuXHJcbmNsYXNzIFBNUkVNR2VuZXJhdG9yIHtcclxuXHJcblx0Y29uc3RydWN0b3IoIHJlbmRlcmVyICkge1xyXG5cclxuXHRcdHRoaXMuX3JlbmRlcmVyID0gcmVuZGVyZXI7XHJcblx0XHR0aGlzLl9waW5nUG9uZ1JlbmRlclRhcmdldCA9IG51bGw7XHJcblxyXG5cdFx0dGhpcy5fbG9kTWF4ID0gMDtcclxuXHRcdHRoaXMuX2N1YmVTaXplID0gMDtcclxuXHRcdHRoaXMuX2xvZFBsYW5lcyA9IFtdO1xyXG5cdFx0dGhpcy5fc2l6ZUxvZHMgPSBbXTtcclxuXHRcdHRoaXMuX3NpZ21hcyA9IFtdO1xyXG5cdFx0dGhpcy5fbG9kTWVzaGVzID0gW107XHJcblxyXG5cdFx0dGhpcy5fYmx1ck1hdGVyaWFsID0gbnVsbDtcclxuXHRcdHRoaXMuX2N1YmVtYXBNYXRlcmlhbCA9IG51bGw7XHJcblx0XHR0aGlzLl9lcXVpcmVjdE1hdGVyaWFsID0gbnVsbDtcclxuXHRcdHRoaXMuX2JhY2tncm91bmRCb3ggPSBudWxsO1xyXG5cclxuXHR9XHJcblxyXG5cdGdldCBfaGFzSW5pdGlhbGl6ZWQoKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuX3JlbmRlcmVyLmhhc0luaXRpYWxpemVkKCk7XHJcblxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogR2VuZXJhdGVzIGEgUE1SRU0gZnJvbSBhIHN1cHBsaWVkIFNjZW5lLCB3aGljaCBjYW4gYmUgZmFzdGVyIHRoYW4gdXNpbmcgYW5cclxuXHQgKiBpbWFnZSBpZiBuZXR3b3JraW5nIGJhbmR3aWR0aCBpcyBsb3cuIE9wdGlvbmFsIHNpZ21hIHNwZWNpZmllcyBhIGJsdXIgcmFkaXVzXHJcblx0ICogaW4gcmFkaWFucyB0byBiZSBhcHBsaWVkIHRvIHRoZSBzY2VuZSBiZWZvcmUgUE1SRU0gZ2VuZXJhdGlvbi4gT3B0aW9uYWwgbmVhclxyXG5cdCAqIGFuZCBmYXIgcGxhbmVzIGVuc3VyZSB0aGUgc2NlbmUgaXMgcmVuZGVyZWQgaW4gaXRzIGVudGlyZXR5ICh0aGUgY3ViZUNhbWVyYVxyXG5cdCAqIGlzIHBsYWNlZCBhdCB0aGUgb3JpZ2luKS5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7U2NlbmV9IHNjZW5lIC0gVGhlIHNjZW5lIHRvIGJlIGNhcHR1cmVkLlxyXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbc2lnbWE9MF0gLSBUaGUgYmx1ciByYWRpdXMgaW4gcmFkaWFucy5cclxuXHQgKiBAcGFyYW0ge051bWJlcn0gW25lYXI9MC4xXSAtIFRoZSBuZWFyIHBsYW5lIGRpc3RhbmNlLlxyXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbZmFyPTEwMF0gLSBUaGUgZmFyIHBsYW5lIGRpc3RhbmNlLlxyXG5cdCAqIEBwYXJhbSB7UmVuZGVyVGFyZ2V0P30gW3JlbmRlclRhcmdldD1udWxsXSAtIFRoZSByZW5kZXIgdGFyZ2V0IHRvIHVzZS5cclxuXHQgKiBAcmV0dXJuIHtSZW5kZXJUYXJnZXR9IFRoZSByZXN1bHRpbmcgUE1SRU0uXHJcblx0ICovXHJcblx0ZnJvbVNjZW5lKCBzY2VuZSwgc2lnbWEgPSAwLCBuZWFyID0gMC4xLCBmYXIgPSAxMDAsIHJlbmRlclRhcmdldCA9IG51bGwgKSB7XHJcblxyXG5cdFx0dGhpcy5fc2V0U2l6ZSggMjU2ICk7XHJcblxyXG5cdFx0aWYgKCB0aGlzLl9oYXNJbml0aWFsaXplZCA9PT0gZmFsc2UgKSB7XHJcblxyXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5QTVJFTUdlbmVyYXRvcjogLmZyb21TY2VuZSgpIGNhbGxlZCBiZWZvcmUgdGhlIGJhY2tlbmQgaXMgaW5pdGlhbGl6ZWQuIFRyeSB1c2luZyAuZnJvbVNjZW5lQXN5bmMoKSBpbnN0ZWFkLicgKTtcclxuXHJcblx0XHRcdGNvbnN0IGN1YmVVVlJlbmRlclRhcmdldCA9IHJlbmRlclRhcmdldCB8fCB0aGlzLl9hbGxvY2F0ZVRhcmdldHMoKTtcclxuXHJcblx0XHRcdHRoaXMuZnJvbVNjZW5lQXN5bmMoIHNjZW5lLCBzaWdtYSwgbmVhciwgZmFyLCBjdWJlVVZSZW5kZXJUYXJnZXQgKTtcclxuXHJcblx0XHRcdHJldHVybiBjdWJlVVZSZW5kZXJUYXJnZXQ7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdF9vbGRUYXJnZXQgPSB0aGlzLl9yZW5kZXJlci5nZXRSZW5kZXJUYXJnZXQoKTtcclxuXHRcdF9vbGRBY3RpdmVDdWJlRmFjZSA9IHRoaXMuX3JlbmRlcmVyLmdldEFjdGl2ZUN1YmVGYWNlKCk7XHJcblx0XHRfb2xkQWN0aXZlTWlwbWFwTGV2ZWwgPSB0aGlzLl9yZW5kZXJlci5nZXRBY3RpdmVNaXBtYXBMZXZlbCgpO1xyXG5cclxuXHRcdGNvbnN0IGN1YmVVVlJlbmRlclRhcmdldCA9IHJlbmRlclRhcmdldCB8fCB0aGlzLl9hbGxvY2F0ZVRhcmdldHMoKTtcclxuXHRcdGN1YmVVVlJlbmRlclRhcmdldC5kZXB0aEJ1ZmZlciA9IHRydWU7XHJcblxyXG5cdFx0dGhpcy5fc2NlbmVUb0N1YmVVViggc2NlbmUsIG5lYXIsIGZhciwgY3ViZVVWUmVuZGVyVGFyZ2V0ICk7XHJcblxyXG5cdFx0aWYgKCBzaWdtYSA+IDAgKSB7XHJcblxyXG5cdFx0XHR0aGlzLl9ibHVyKCBjdWJlVVZSZW5kZXJUYXJnZXQsIDAsIDAsIHNpZ21hICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX2FwcGx5UE1SRU0oIGN1YmVVVlJlbmRlclRhcmdldCApO1xyXG5cclxuXHRcdHRoaXMuX2NsZWFudXAoIGN1YmVVVlJlbmRlclRhcmdldCApO1xyXG5cclxuXHRcdHJldHVybiBjdWJlVVZSZW5kZXJUYXJnZXQ7XHJcblxyXG5cdH1cclxuXHJcblx0YXN5bmMgZnJvbVNjZW5lQXN5bmMoIHNjZW5lLCBzaWdtYSA9IDAsIG5lYXIgPSAwLjEsIGZhciA9IDEwMCwgcmVuZGVyVGFyZ2V0ID0gbnVsbCApIHtcclxuXHJcblx0XHRpZiAoIHRoaXMuX2hhc0luaXRpYWxpemVkID09PSBmYWxzZSApIGF3YWl0IHRoaXMuX3JlbmRlcmVyLmluaXQoKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5mcm9tU2NlbmUoIHNjZW5lLCBzaWdtYSwgbmVhciwgZmFyLCByZW5kZXJUYXJnZXQgKTtcclxuXHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBHZW5lcmF0ZXMgYSBQTVJFTSBmcm9tIGFuIGVxdWlyZWN0YW5ndWxhciB0ZXh0dXJlLCB3aGljaCBjYW4gYmUgZWl0aGVyIExEUlxyXG5cdCAqIG9yIEhEUi4gVGhlIGlkZWFsIGlucHV0IGltYWdlIHNpemUgaXMgMWsgKDEwMjQgeCA1MTIpLFxyXG5cdCAqIGFzIHRoaXMgbWF0Y2hlcyBiZXN0IHdpdGggdGhlIDI1NiB4IDI1NiBjdWJlbWFwIG91dHB1dC5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7VGV4dHVyZX0gZXF1aXJlY3Rhbmd1bGFyIC0gVGhlIGVxdWlyZWN0YW5ndWxhciB0ZXh0dXJlIHRvIGJlIGNvbnZlcnRlZC5cclxuXHQgKiBAcGFyYW0ge1JlbmRlclRhcmdldD99IFtyZW5kZXJUYXJnZXQ9bnVsbF0gLSBUaGUgcmVuZGVyIHRhcmdldCB0byB1c2UuXHJcblx0ICogQHJldHVybiB7UmVuZGVyVGFyZ2V0fSBUaGUgcmVzdWx0aW5nIFBNUkVNLlxyXG5cdCAqL1xyXG5cdGZyb21FcXVpcmVjdGFuZ3VsYXIoIGVxdWlyZWN0YW5ndWxhciwgcmVuZGVyVGFyZ2V0ID0gbnVsbCApIHtcclxuXHJcblx0XHRpZiAoIHRoaXMuX2hhc0luaXRpYWxpemVkID09PSBmYWxzZSApIHtcclxuXHJcblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLlBNUkVNR2VuZXJhdG9yOiAuZnJvbUVxdWlyZWN0YW5ndWxhcigpIGNhbGxlZCBiZWZvcmUgdGhlIGJhY2tlbmQgaXMgaW5pdGlhbGl6ZWQuIFRyeSB1c2luZyAuZnJvbUVxdWlyZWN0YW5ndWxhckFzeW5jKCkgaW5zdGVhZC4nICk7XHJcblxyXG5cdFx0XHR0aGlzLl9zZXRTaXplRnJvbVRleHR1cmUoIGVxdWlyZWN0YW5ndWxhciApO1xyXG5cclxuXHRcdFx0Y29uc3QgY3ViZVVWUmVuZGVyVGFyZ2V0ID0gcmVuZGVyVGFyZ2V0IHx8IHRoaXMuX2FsbG9jYXRlVGFyZ2V0cygpO1xyXG5cclxuXHRcdFx0dGhpcy5mcm9tRXF1aXJlY3Rhbmd1bGFyQXN5bmMoIGVxdWlyZWN0YW5ndWxhciwgY3ViZVVWUmVuZGVyVGFyZ2V0ICk7XHJcblxyXG5cdFx0XHRyZXR1cm4gY3ViZVVWUmVuZGVyVGFyZ2V0O1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcy5fZnJvbVRleHR1cmUoIGVxdWlyZWN0YW5ndWxhciwgcmVuZGVyVGFyZ2V0ICk7XHJcblxyXG5cdH1cclxuXHJcblx0YXN5bmMgZnJvbUVxdWlyZWN0YW5ndWxhckFzeW5jKCBlcXVpcmVjdGFuZ3VsYXIsIHJlbmRlclRhcmdldCA9IG51bGwgKSB7XHJcblxyXG5cdFx0aWYgKCB0aGlzLl9oYXNJbml0aWFsaXplZCA9PT0gZmFsc2UgKSBhd2FpdCB0aGlzLl9yZW5kZXJlci5pbml0KCk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuX2Zyb21UZXh0dXJlKCBlcXVpcmVjdGFuZ3VsYXIsIHJlbmRlclRhcmdldCApO1xyXG5cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEdlbmVyYXRlcyBhIFBNUkVNIGZyb20gYW4gY3ViZW1hcCB0ZXh0dXJlLCB3aGljaCBjYW4gYmUgZWl0aGVyIExEUlxyXG5cdCAqIG9yIEhEUi4gVGhlIGlkZWFsIGlucHV0IGN1YmUgc2l6ZSBpcyAyNTYgeCAyNTYsXHJcblx0ICogYXMgdGhpcyBtYXRjaGVzIGJlc3Qgd2l0aCB0aGUgMjU2IHggMjU2IGN1YmVtYXAgb3V0cHV0LlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtUZXh0dXJlfSBjdWJlbWFwIC0gVGhlIGN1YmVtYXAgdGV4dHVyZSB0byBiZSBjb252ZXJ0ZWQuXHJcblx0ICogQHBhcmFtIHtSZW5kZXJUYXJnZXQ/fSBbcmVuZGVyVGFyZ2V0PW51bGxdIC0gVGhlIHJlbmRlciB0YXJnZXQgdG8gdXNlLlxyXG5cdCAqIEByZXR1cm4ge1JlbmRlclRhcmdldH0gVGhlIHJlc3VsdGluZyBQTVJFTS5cclxuXHQgKi9cclxuXHRmcm9tQ3ViZW1hcCggY3ViZW1hcCwgcmVuZGVyVGFyZ2V0ID0gbnVsbCApIHtcclxuXHJcblx0XHRpZiAoIHRoaXMuX2hhc0luaXRpYWxpemVkID09PSBmYWxzZSApIHtcclxuXHJcblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLlBNUkVNR2VuZXJhdG9yOiAuZnJvbUN1YmVtYXAoKSBjYWxsZWQgYmVmb3JlIHRoZSBiYWNrZW5kIGlzIGluaXRpYWxpemVkLiBUcnkgdXNpbmcgLmZyb21DdWJlbWFwQXN5bmMoKSBpbnN0ZWFkLicgKTtcclxuXHJcblx0XHRcdHRoaXMuX3NldFNpemVGcm9tVGV4dHVyZSggY3ViZW1hcCApO1xyXG5cclxuXHRcdFx0Y29uc3QgY3ViZVVWUmVuZGVyVGFyZ2V0ID0gcmVuZGVyVGFyZ2V0IHx8IHRoaXMuX2FsbG9jYXRlVGFyZ2V0cygpO1xyXG5cclxuXHRcdFx0dGhpcy5mcm9tQ3ViZW1hcEFzeW5jKCBjdWJlbWFwLCByZW5kZXJUYXJnZXQgKTtcclxuXHJcblx0XHRcdHJldHVybiBjdWJlVVZSZW5kZXJUYXJnZXQ7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzLl9mcm9tVGV4dHVyZSggY3ViZW1hcCwgcmVuZGVyVGFyZ2V0ICk7XHJcblxyXG5cdH1cclxuXHJcblx0YXN5bmMgZnJvbUN1YmVtYXBBc3luYyggY3ViZW1hcCwgcmVuZGVyVGFyZ2V0ID0gbnVsbCApIHtcclxuXHJcblx0XHRpZiAoIHRoaXMuX2hhc0luaXRpYWxpemVkID09PSBmYWxzZSApIGF3YWl0IHRoaXMuX3JlbmRlcmVyLmluaXQoKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5fZnJvbVRleHR1cmUoIGN1YmVtYXAsIHJlbmRlclRhcmdldCApO1xyXG5cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFByZS1jb21waWxlcyB0aGUgY3ViZW1hcCBzaGFkZXIuIFlvdSBjYW4gZ2V0IGZhc3RlciBzdGFydC11cCBieSBpbnZva2luZyB0aGlzIG1ldGhvZCBkdXJpbmdcclxuXHQgKiB5b3VyIHRleHR1cmUncyBuZXR3b3JrIGZldGNoIGZvciBpbmNyZWFzZWQgY29uY3VycmVuY3kuXHJcblx0ICovXHJcblx0YXN5bmMgY29tcGlsZUN1YmVtYXBTaGFkZXIoKSB7XHJcblxyXG5cdFx0aWYgKCB0aGlzLl9jdWJlbWFwTWF0ZXJpYWwgPT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHR0aGlzLl9jdWJlbWFwTWF0ZXJpYWwgPSBfZ2V0Q3ViZW1hcE1hdGVyaWFsKCk7XHJcblx0XHRcdGF3YWl0IHRoaXMuX2NvbXBpbGVNYXRlcmlhbCggdGhpcy5fY3ViZW1hcE1hdGVyaWFsICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFByZS1jb21waWxlcyB0aGUgZXF1aXJlY3Rhbmd1bGFyIHNoYWRlci4gWW91IGNhbiBnZXQgZmFzdGVyIHN0YXJ0LXVwIGJ5IGludm9raW5nIHRoaXMgbWV0aG9kIGR1cmluZ1xyXG5cdCAqIHlvdXIgdGV4dHVyZSdzIG5ldHdvcmsgZmV0Y2ggZm9yIGluY3JlYXNlZCBjb25jdXJyZW5jeS5cclxuXHQgKi9cclxuXHRhc3luYyBjb21waWxlRXF1aXJlY3Rhbmd1bGFyU2hhZGVyKCkge1xyXG5cclxuXHRcdGlmICggdGhpcy5fZXF1aXJlY3RNYXRlcmlhbCA9PT0gbnVsbCApIHtcclxuXHJcblx0XHRcdHRoaXMuX2VxdWlyZWN0TWF0ZXJpYWwgPSBfZ2V0RXF1aXJlY3RNYXRlcmlhbCgpO1xyXG5cdFx0XHRhd2FpdCB0aGlzLl9jb21waWxlTWF0ZXJpYWwoIHRoaXMuX2VxdWlyZWN0TWF0ZXJpYWwgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogRGlzcG9zZXMgb2YgdGhlIFBNUkVNR2VuZXJhdG9yJ3MgaW50ZXJuYWwgbWVtb3J5LiBOb3RlIHRoYXQgUE1SRU1HZW5lcmF0b3IgaXMgYSBzdGF0aWMgY2xhc3MsXHJcblx0ICogc28geW91IHNob3VsZCBub3QgbmVlZCBtb3JlIHRoYW4gb25lIFBNUkVNR2VuZXJhdG9yIG9iamVjdC4gSWYgeW91IGRvLCBjYWxsaW5nIGRpc3Bvc2UoKSBvblxyXG5cdCAqIG9uZSBvZiB0aGVtIHdpbGwgY2F1c2UgYW55IG90aGVycyB0byBhbHNvIGJlY29tZSB1bnVzYWJsZS5cclxuXHQgKi9cclxuXHRkaXNwb3NlKCkge1xyXG5cclxuXHRcdHRoaXMuX2Rpc3Bvc2UoKTtcclxuXHJcblx0XHRpZiAoIHRoaXMuX2N1YmVtYXBNYXRlcmlhbCAhPT0gbnVsbCApIHRoaXMuX2N1YmVtYXBNYXRlcmlhbC5kaXNwb3NlKCk7XHJcblx0XHRpZiAoIHRoaXMuX2VxdWlyZWN0TWF0ZXJpYWwgIT09IG51bGwgKSB0aGlzLl9lcXVpcmVjdE1hdGVyaWFsLmRpc3Bvc2UoKTtcclxuXHRcdGlmICggdGhpcy5fYmFja2dyb3VuZEJveCAhPT0gbnVsbCApIHtcclxuXHJcblx0XHRcdHRoaXMuX2JhY2tncm91bmRCb3guZ2VvbWV0cnkuZGlzcG9zZSgpO1xyXG5cdFx0XHR0aGlzLl9iYWNrZ3JvdW5kQm94Lm1hdGVyaWFsLmRpc3Bvc2UoKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0Ly8gcHJpdmF0ZSBpbnRlcmZhY2VcclxuXHJcblx0X3NldFNpemVGcm9tVGV4dHVyZSggdGV4dHVyZSApIHtcclxuXHJcblx0XHRpZiAoIHRleHR1cmUubWFwcGluZyA9PT0gQ3ViZVJlZmxlY3Rpb25NYXBwaW5nIHx8IHRleHR1cmUubWFwcGluZyA9PT0gQ3ViZVJlZnJhY3Rpb25NYXBwaW5nICkge1xyXG5cclxuXHRcdFx0dGhpcy5fc2V0U2l6ZSggdGV4dHVyZS5pbWFnZS5sZW5ndGggPT09IDAgPyAxNiA6ICggdGV4dHVyZS5pbWFnZVsgMCBdLndpZHRoIHx8IHRleHR1cmUuaW1hZ2VbIDAgXS5pbWFnZS53aWR0aCApICk7XHJcblxyXG5cdFx0fSBlbHNlIHsgLy8gRXF1aXJlY3Rhbmd1bGFyXHJcblxyXG5cdFx0XHR0aGlzLl9zZXRTaXplKCB0ZXh0dXJlLmltYWdlLndpZHRoIC8gNCApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHRfc2V0U2l6ZSggY3ViZVNpemUgKSB7XHJcblxyXG5cdFx0dGhpcy5fbG9kTWF4ID0gTWF0aC5mbG9vciggTWF0aC5sb2cyKCBjdWJlU2l6ZSApICk7XHJcblx0XHR0aGlzLl9jdWJlU2l6ZSA9IE1hdGgucG93KCAyLCB0aGlzLl9sb2RNYXggKTtcclxuXHJcblx0fVxyXG5cclxuXHRfZGlzcG9zZSgpIHtcclxuXHJcblx0XHRpZiAoIHRoaXMuX2JsdXJNYXRlcmlhbCAhPT0gbnVsbCApIHRoaXMuX2JsdXJNYXRlcmlhbC5kaXNwb3NlKCk7XHJcblxyXG5cdFx0aWYgKCB0aGlzLl9waW5nUG9uZ1JlbmRlclRhcmdldCAhPT0gbnVsbCApIHRoaXMuX3BpbmdQb25nUmVuZGVyVGFyZ2V0LmRpc3Bvc2UoKTtcclxuXHJcblx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCB0aGlzLl9sb2RQbGFuZXMubGVuZ3RoOyBpICsrICkge1xyXG5cclxuXHRcdFx0dGhpcy5fbG9kUGxhbmVzWyBpIF0uZGlzcG9zZSgpO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHRfY2xlYW51cCggb3V0cHV0VGFyZ2V0ICkge1xyXG5cclxuXHRcdHRoaXMuX3JlbmRlcmVyLnNldFJlbmRlclRhcmdldCggX29sZFRhcmdldCwgX29sZEFjdGl2ZUN1YmVGYWNlLCBfb2xkQWN0aXZlTWlwbWFwTGV2ZWwgKTtcclxuXHRcdG91dHB1dFRhcmdldC5zY2lzc29yVGVzdCA9IGZhbHNlO1xyXG5cdFx0X3NldFZpZXdwb3J0KCBvdXRwdXRUYXJnZXQsIDAsIDAsIG91dHB1dFRhcmdldC53aWR0aCwgb3V0cHV0VGFyZ2V0LmhlaWdodCApO1xyXG5cclxuXHR9XHJcblxyXG5cdF9mcm9tVGV4dHVyZSggdGV4dHVyZSwgcmVuZGVyVGFyZ2V0ICkge1xyXG5cclxuXHRcdHRoaXMuX3NldFNpemVGcm9tVGV4dHVyZSggdGV4dHVyZSApO1xyXG5cclxuXHRcdF9vbGRUYXJnZXQgPSB0aGlzLl9yZW5kZXJlci5nZXRSZW5kZXJUYXJnZXQoKTtcclxuXHRcdF9vbGRBY3RpdmVDdWJlRmFjZSA9IHRoaXMuX3JlbmRlcmVyLmdldEFjdGl2ZUN1YmVGYWNlKCk7XHJcblx0XHRfb2xkQWN0aXZlTWlwbWFwTGV2ZWwgPSB0aGlzLl9yZW5kZXJlci5nZXRBY3RpdmVNaXBtYXBMZXZlbCgpO1xyXG5cclxuXHRcdGNvbnN0IGN1YmVVVlJlbmRlclRhcmdldCA9IHJlbmRlclRhcmdldCB8fCB0aGlzLl9hbGxvY2F0ZVRhcmdldHMoKTtcclxuXHRcdHRoaXMuX3RleHR1cmVUb0N1YmVVViggdGV4dHVyZSwgY3ViZVVWUmVuZGVyVGFyZ2V0ICk7XHJcblx0XHR0aGlzLl9hcHBseVBNUkVNKCBjdWJlVVZSZW5kZXJUYXJnZXQgKTtcclxuXHRcdHRoaXMuX2NsZWFudXAoIGN1YmVVVlJlbmRlclRhcmdldCApO1xyXG5cclxuXHRcdHJldHVybiBjdWJlVVZSZW5kZXJUYXJnZXQ7XHJcblxyXG5cdH1cclxuXHJcblx0X2FsbG9jYXRlVGFyZ2V0cygpIHtcclxuXHJcblx0XHRjb25zdCB3aWR0aCA9IDMgKiBNYXRoLm1heCggdGhpcy5fY3ViZVNpemUsIDE2ICogNyApO1xyXG5cdFx0Y29uc3QgaGVpZ2h0ID0gNCAqIHRoaXMuX2N1YmVTaXplO1xyXG5cclxuXHRcdGNvbnN0IHBhcmFtcyA9IHtcclxuXHRcdFx0bWFnRmlsdGVyOiBMaW5lYXJGaWx0ZXIsXHJcblx0XHRcdG1pbkZpbHRlcjogTGluZWFyRmlsdGVyLFxyXG5cdFx0XHRnZW5lcmF0ZU1pcG1hcHM6IGZhbHNlLFxyXG5cdFx0XHR0eXBlOiBIYWxmRmxvYXRUeXBlLFxyXG5cdFx0XHRmb3JtYXQ6IFJHQkFGb3JtYXQsXHJcblx0XHRcdGNvbG9yU3BhY2U6IExpbmVhclNSR0JDb2xvclNwYWNlLFxyXG5cdFx0XHQvL2RlcHRoQnVmZmVyOiBmYWxzZVxyXG5cdFx0fTtcclxuXHJcblx0XHRjb25zdCBjdWJlVVZSZW5kZXJUYXJnZXQgPSBfY3JlYXRlUmVuZGVyVGFyZ2V0KCB3aWR0aCwgaGVpZ2h0LCBwYXJhbXMgKTtcclxuXHJcblx0XHRpZiAoIHRoaXMuX3BpbmdQb25nUmVuZGVyVGFyZ2V0ID09PSBudWxsIHx8IHRoaXMuX3BpbmdQb25nUmVuZGVyVGFyZ2V0LndpZHRoICE9PSB3aWR0aCB8fCB0aGlzLl9waW5nUG9uZ1JlbmRlclRhcmdldC5oZWlnaHQgIT09IGhlaWdodCApIHtcclxuXHJcblx0XHRcdGlmICggdGhpcy5fcGluZ1BvbmdSZW5kZXJUYXJnZXQgIT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHRcdHRoaXMuX2Rpc3Bvc2UoKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHRoaXMuX3BpbmdQb25nUmVuZGVyVGFyZ2V0ID0gX2NyZWF0ZVJlbmRlclRhcmdldCggd2lkdGgsIGhlaWdodCwgcGFyYW1zICk7XHJcblxyXG5cdFx0XHRjb25zdCB7IF9sb2RNYXggfSA9IHRoaXM7XHJcblx0XHRcdCggeyBzaXplTG9kczogdGhpcy5fc2l6ZUxvZHMsIGxvZFBsYW5lczogdGhpcy5fbG9kUGxhbmVzLCBzaWdtYXM6IHRoaXMuX3NpZ21hcywgbG9kTWVzaGVzOiB0aGlzLl9sb2RNZXNoZXMgfSA9IF9jcmVhdGVQbGFuZXMoIF9sb2RNYXggKSApO1xyXG5cclxuXHRcdFx0dGhpcy5fYmx1ck1hdGVyaWFsID0gX2dldEJsdXJTaGFkZXIoIF9sb2RNYXgsIHdpZHRoLCBoZWlnaHQgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGN1YmVVVlJlbmRlclRhcmdldDtcclxuXHJcblx0fVxyXG5cclxuXHRhc3luYyBfY29tcGlsZU1hdGVyaWFsKCBtYXRlcmlhbCApIHtcclxuXHJcblx0XHRjb25zdCB0bXBNZXNoID0gbmV3IE1lc2goIHRoaXMuX2xvZFBsYW5lc1sgMCBdLCBtYXRlcmlhbCApO1xyXG5cdFx0YXdhaXQgdGhpcy5fcmVuZGVyZXIuY29tcGlsZSggdG1wTWVzaCwgX2ZsYXRDYW1lcmEgKTtcclxuXHJcblx0fVxyXG5cclxuXHRfc2NlbmVUb0N1YmVVViggc2NlbmUsIG5lYXIsIGZhciwgY3ViZVVWUmVuZGVyVGFyZ2V0ICkge1xyXG5cclxuXHRcdGNvbnN0IGN1YmVDYW1lcmEgPSBfY3ViZUNhbWVyYTtcclxuXHRcdGN1YmVDYW1lcmEubmVhciA9IG5lYXI7XHJcblx0XHRjdWJlQ2FtZXJhLmZhciA9IGZhcjtcclxuXHJcblx0XHQvLyBweCwgcHksIHB6LCBueCwgbnksIG56XHJcblx0XHRjb25zdCB1cFNpZ24gPSBbIDEsIDEsIDEsIDEsIC0gMSwgMSBdO1xyXG5cdFx0Y29uc3QgZm9yd2FyZFNpZ24gPSBbIDEsIC0gMSwgMSwgLSAxLCAxLCAtIDEgXTtcclxuXHJcblx0XHRjb25zdCByZW5kZXJlciA9IHRoaXMuX3JlbmRlcmVyO1xyXG5cclxuXHRcdGNvbnN0IG9yaWdpbmFsQXV0b0NsZWFyID0gcmVuZGVyZXIuYXV0b0NsZWFyO1xyXG5cclxuXHRcdHJlbmRlcmVyLmdldENsZWFyQ29sb3IoIF9jbGVhckNvbG9yICk7XHJcblxyXG5cdFx0cmVuZGVyZXIuYXV0b0NsZWFyID0gZmFsc2U7XHJcblxyXG5cdFx0bGV0IGJhY2tncm91bmRCb3ggPSB0aGlzLl9iYWNrZ3JvdW5kQm94O1xyXG5cclxuXHRcdGlmICggYmFja2dyb3VuZEJveCA9PT0gbnVsbCApIHtcclxuXHJcblx0XHRcdGNvbnN0IGJhY2tncm91bmRNYXRlcmlhbCA9IG5ldyBNZXNoQmFzaWNNYXRlcmlhbCgge1xyXG5cdFx0XHRcdG5hbWU6ICdQTVJFTS5CYWNrZ3JvdW5kJyxcclxuXHRcdFx0XHRzaWRlOiBCYWNrU2lkZSxcclxuXHRcdFx0XHRkZXB0aFdyaXRlOiBmYWxzZSxcclxuXHRcdFx0XHRkZXB0aFRlc3Q6IGZhbHNlXHJcblx0XHRcdH0gKTtcclxuXHJcblx0XHRcdGJhY2tncm91bmRCb3ggPSBuZXcgTWVzaCggbmV3IEJveEdlb21ldHJ5KCksIGJhY2tncm91bmRNYXRlcmlhbCApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRsZXQgdXNlU29saWRDb2xvciA9IGZhbHNlO1xyXG5cdFx0Y29uc3QgYmFja2dyb3VuZCA9IHNjZW5lLmJhY2tncm91bmQ7XHJcblxyXG5cdFx0aWYgKCBiYWNrZ3JvdW5kICkge1xyXG5cclxuXHRcdFx0aWYgKCBiYWNrZ3JvdW5kLmlzQ29sb3IgKSB7XHJcblxyXG5cdFx0XHRcdGJhY2tncm91bmRCb3gubWF0ZXJpYWwuY29sb3IuY29weSggYmFja2dyb3VuZCApO1xyXG5cdFx0XHRcdHNjZW5lLmJhY2tncm91bmQgPSBudWxsO1xyXG5cdFx0XHRcdHVzZVNvbGlkQ29sb3IgPSB0cnVlO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRiYWNrZ3JvdW5kQm94Lm1hdGVyaWFsLmNvbG9yLmNvcHkoIF9jbGVhckNvbG9yICk7XHJcblx0XHRcdHVzZVNvbGlkQ29sb3IgPSB0cnVlO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZW5kZXJlci5zZXRSZW5kZXJUYXJnZXQoIGN1YmVVVlJlbmRlclRhcmdldCApO1xyXG5cclxuXHRcdHJlbmRlcmVyLmNsZWFyKCk7XHJcblxyXG5cdFx0aWYgKCB1c2VTb2xpZENvbG9yICkge1xyXG5cclxuXHRcdFx0cmVuZGVyZXIucmVuZGVyKCBiYWNrZ3JvdW5kQm94LCBjdWJlQ2FtZXJhICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGZvciAoIGxldCBpID0gMDsgaSA8IDY7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRjb25zdCBjb2wgPSBpICUgMztcclxuXHJcblx0XHRcdGlmICggY29sID09PSAwICkge1xyXG5cclxuXHRcdFx0XHRjdWJlQ2FtZXJhLnVwLnNldCggMCwgdXBTaWduWyBpIF0sIDAgKTtcclxuXHRcdFx0XHRjdWJlQ2FtZXJhLmxvb2tBdCggZm9yd2FyZFNpZ25bIGkgXSwgMCwgMCApO1xyXG5cclxuXHRcdFx0fSBlbHNlIGlmICggY29sID09PSAxICkge1xyXG5cclxuXHRcdFx0XHRjdWJlQ2FtZXJhLnVwLnNldCggMCwgMCwgdXBTaWduWyBpIF0gKTtcclxuXHRcdFx0XHRjdWJlQ2FtZXJhLmxvb2tBdCggMCwgZm9yd2FyZFNpZ25bIGkgXSwgMCApO1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0Y3ViZUNhbWVyYS51cC5zZXQoIDAsIHVwU2lnblsgaSBdLCAwICk7XHJcblx0XHRcdFx0Y3ViZUNhbWVyYS5sb29rQXQoIDAsIDAsIGZvcndhcmRTaWduWyBpIF0gKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGNvbnN0IHNpemUgPSB0aGlzLl9jdWJlU2l6ZTtcclxuXHJcblx0XHRcdF9zZXRWaWV3cG9ydCggY3ViZVVWUmVuZGVyVGFyZ2V0LCBjb2wgKiBzaXplLCBpID4gMiA/IHNpemUgOiAwLCBzaXplLCBzaXplICk7XHJcblxyXG5cdFx0XHRyZW5kZXJlci5yZW5kZXIoIHNjZW5lLCBjdWJlQ2FtZXJhICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJlbmRlcmVyLmF1dG9DbGVhciA9IG9yaWdpbmFsQXV0b0NsZWFyO1xyXG5cdFx0c2NlbmUuYmFja2dyb3VuZCA9IGJhY2tncm91bmQ7XHJcblxyXG5cdH1cclxuXHJcblx0X3RleHR1cmVUb0N1YmVVViggdGV4dHVyZSwgY3ViZVVWUmVuZGVyVGFyZ2V0ICkge1xyXG5cclxuXHRcdGNvbnN0IHJlbmRlcmVyID0gdGhpcy5fcmVuZGVyZXI7XHJcblxyXG5cdFx0Y29uc3QgaXNDdWJlVGV4dHVyZSA9ICggdGV4dHVyZS5tYXBwaW5nID09PSBDdWJlUmVmbGVjdGlvbk1hcHBpbmcgfHwgdGV4dHVyZS5tYXBwaW5nID09PSBDdWJlUmVmcmFjdGlvbk1hcHBpbmcgKTtcclxuXHJcblx0XHRpZiAoIGlzQ3ViZVRleHR1cmUgKSB7XHJcblxyXG5cdFx0XHRpZiAoIHRoaXMuX2N1YmVtYXBNYXRlcmlhbCA9PT0gbnVsbCApIHtcclxuXHJcblx0XHRcdFx0dGhpcy5fY3ViZW1hcE1hdGVyaWFsID0gX2dldEN1YmVtYXBNYXRlcmlhbCggdGV4dHVyZSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRpZiAoIHRoaXMuX2VxdWlyZWN0TWF0ZXJpYWwgPT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHRcdHRoaXMuX2VxdWlyZWN0TWF0ZXJpYWwgPSBfZ2V0RXF1aXJlY3RNYXRlcmlhbCggdGV4dHVyZSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRjb25zdCBtYXRlcmlhbCA9IGlzQ3ViZVRleHR1cmUgPyB0aGlzLl9jdWJlbWFwTWF0ZXJpYWwgOiB0aGlzLl9lcXVpcmVjdE1hdGVyaWFsO1xyXG5cdFx0bWF0ZXJpYWwuZnJhZ21lbnROb2RlLnZhbHVlID0gdGV4dHVyZTtcclxuXHJcblx0XHRjb25zdCBtZXNoID0gdGhpcy5fbG9kTWVzaGVzWyAwIF07XHJcblx0XHRtZXNoLm1hdGVyaWFsID0gbWF0ZXJpYWw7XHJcblxyXG5cdFx0Y29uc3Qgc2l6ZSA9IHRoaXMuX2N1YmVTaXplO1xyXG5cclxuXHRcdF9zZXRWaWV3cG9ydCggY3ViZVVWUmVuZGVyVGFyZ2V0LCAwLCAwLCAzICogc2l6ZSwgMiAqIHNpemUgKTtcclxuXHJcblx0XHRyZW5kZXJlci5zZXRSZW5kZXJUYXJnZXQoIGN1YmVVVlJlbmRlclRhcmdldCApO1xyXG5cdFx0cmVuZGVyZXIucmVuZGVyKCBtZXNoLCBfZmxhdENhbWVyYSApO1xyXG5cclxuXHR9XHJcblxyXG5cdF9hcHBseVBNUkVNKCBjdWJlVVZSZW5kZXJUYXJnZXQgKSB7XHJcblxyXG5cdFx0Y29uc3QgcmVuZGVyZXIgPSB0aGlzLl9yZW5kZXJlcjtcclxuXHRcdGNvbnN0IGF1dG9DbGVhciA9IHJlbmRlcmVyLmF1dG9DbGVhcjtcclxuXHRcdHJlbmRlcmVyLmF1dG9DbGVhciA9IGZhbHNlO1xyXG5cdFx0Y29uc3QgbiA9IHRoaXMuX2xvZFBsYW5lcy5sZW5ndGg7XHJcblxyXG5cdFx0Zm9yICggbGV0IGkgPSAxOyBpIDwgbjsgaSArKyApIHtcclxuXHJcblx0XHRcdGNvbnN0IHNpZ21hID0gTWF0aC5zcXJ0KCB0aGlzLl9zaWdtYXNbIGkgXSAqIHRoaXMuX3NpZ21hc1sgaSBdIC0gdGhpcy5fc2lnbWFzWyBpIC0gMSBdICogdGhpcy5fc2lnbWFzWyBpIC0gMSBdICk7XHJcblxyXG5cdFx0XHRjb25zdCBwb2xlQXhpcyA9IF9heGlzRGlyZWN0aW9uc1sgKCBuIC0gaSAtIDEgKSAlIF9heGlzRGlyZWN0aW9ucy5sZW5ndGggXTtcclxuXHJcblx0XHRcdHRoaXMuX2JsdXIoIGN1YmVVVlJlbmRlclRhcmdldCwgaSAtIDEsIGksIHNpZ21hLCBwb2xlQXhpcyApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZW5kZXJlci5hdXRvQ2xlYXIgPSBhdXRvQ2xlYXI7XHJcblxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogVGhpcyBpcyBhIHR3by1wYXNzIEdhdXNzaWFuIGJsdXIgZm9yIGEgY3ViZW1hcC4gTm9ybWFsbHkgdGhpcyBpcyBkb25lXHJcblx0ICogdmVydGljYWxseSBhbmQgaG9yaXpvbnRhbGx5LCBidXQgdGhpcyBicmVha3MgZG93biBvbiBhIGN1YmUuIEhlcmUgd2UgYXBwbHlcclxuXHQgKiB0aGUgYmx1ciBsYXRpdHVkaW5hbGx5IChhcm91bmQgdGhlIHBvbGVzKSwgYW5kIHRoZW4gbG9uZ2l0dWRpbmFsbHkgKHRvd2FyZHNcclxuXHQgKiB0aGUgcG9sZXMpIHRvIGFwcHJveGltYXRlIHRoZSBvcnRob2dvbmFsbHktc2VwYXJhYmxlIGJsdXIuIEl0IGlzIGxlYXN0XHJcblx0ICogYWNjdXJhdGUgYXQgdGhlIHBvbGVzLCBidXQgc3RpbGwgZG9lcyBhIGRlY2VudCBqb2IuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge1JlbmRlclRhcmdldH0gY3ViZVVWUmVuZGVyVGFyZ2V0IC0gVGhlIGN1YmVtYXAgcmVuZGVyIHRhcmdldC5cclxuXHQgKiBAcGFyYW0ge051bWJlcn0gbG9kSW4gLSBUaGUgaW5wdXQgbGV2ZWwtb2YtZGV0YWlsLlxyXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBsb2RPdXQgLSBUaGUgb3V0cHV0IGxldmVsLW9mLWRldGFpbC5cclxuXHQgKiBAcGFyYW0ge051bWJlcn0gc2lnbWEgLSBUaGUgYmx1ciByYWRpdXMgaW4gcmFkaWFucy5cclxuXHQgKiBAcGFyYW0ge1ZlY3RvcjN9IFtwb2xlQXhpc10gLSBUaGUgcG9sZSBheGlzLlxyXG5cdCAqL1xyXG5cdF9ibHVyKCBjdWJlVVZSZW5kZXJUYXJnZXQsIGxvZEluLCBsb2RPdXQsIHNpZ21hLCBwb2xlQXhpcyApIHtcclxuXHJcblx0XHRjb25zdCBwaW5nUG9uZ1JlbmRlclRhcmdldCA9IHRoaXMuX3BpbmdQb25nUmVuZGVyVGFyZ2V0O1xyXG5cclxuXHRcdHRoaXMuX2hhbGZCbHVyKFxyXG5cdFx0XHRjdWJlVVZSZW5kZXJUYXJnZXQsXHJcblx0XHRcdHBpbmdQb25nUmVuZGVyVGFyZ2V0LFxyXG5cdFx0XHRsb2RJbixcclxuXHRcdFx0bG9kT3V0LFxyXG5cdFx0XHRzaWdtYSxcclxuXHRcdFx0J2xhdGl0dWRpbmFsJyxcclxuXHRcdFx0cG9sZUF4aXMgKTtcclxuXHJcblx0XHR0aGlzLl9oYWxmQmx1cihcclxuXHRcdFx0cGluZ1BvbmdSZW5kZXJUYXJnZXQsXHJcblx0XHRcdGN1YmVVVlJlbmRlclRhcmdldCxcclxuXHRcdFx0bG9kT3V0LFxyXG5cdFx0XHRsb2RPdXQsXHJcblx0XHRcdHNpZ21hLFxyXG5cdFx0XHQnbG9uZ2l0dWRpbmFsJyxcclxuXHRcdFx0cG9sZUF4aXMgKTtcclxuXHJcblx0fVxyXG5cclxuXHRfaGFsZkJsdXIoIHRhcmdldEluLCB0YXJnZXRPdXQsIGxvZEluLCBsb2RPdXQsIHNpZ21hUmFkaWFucywgZGlyZWN0aW9uLCBwb2xlQXhpcyApIHtcclxuXHJcblx0XHRjb25zdCByZW5kZXJlciA9IHRoaXMuX3JlbmRlcmVyO1xyXG5cdFx0Y29uc3QgYmx1ck1hdGVyaWFsID0gdGhpcy5fYmx1ck1hdGVyaWFsO1xyXG5cclxuXHRcdGlmICggZGlyZWN0aW9uICE9PSAnbGF0aXR1ZGluYWwnICYmIGRpcmVjdGlvbiAhPT0gJ2xvbmdpdHVkaW5hbCcgKSB7XHJcblxyXG5cdFx0XHRjb25zb2xlLmVycm9yKCAnYmx1ciBkaXJlY3Rpb24gbXVzdCBiZSBlaXRoZXIgbGF0aXR1ZGluYWwgb3IgbG9uZ2l0dWRpbmFsIScgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gTnVtYmVyIG9mIHN0YW5kYXJkIGRldmlhdGlvbnMgYXQgd2hpY2ggdG8gY3V0IG9mZiB0aGUgZGlzY3JldGUgYXBwcm94aW1hdGlvbi5cclxuXHRcdGNvbnN0IFNUQU5EQVJEX0RFVklBVElPTlMgPSAzO1xyXG5cclxuXHRcdGNvbnN0IGJsdXJNZXNoID0gdGhpcy5fbG9kTWVzaGVzWyBsb2RPdXQgXTtcclxuXHRcdGJsdXJNZXNoLm1hdGVyaWFsID0gYmx1ck1hdGVyaWFsO1xyXG5cclxuXHRcdGNvbnN0IGJsdXJVbmlmb3JtcyA9IGJsdXJNYXRlcmlhbC51bmlmb3JtcztcclxuXHJcblx0XHRjb25zdCBwaXhlbHMgPSB0aGlzLl9zaXplTG9kc1sgbG9kSW4gXSAtIDE7XHJcblx0XHRjb25zdCByYWRpYW5zUGVyUGl4ZWwgPSBpc0Zpbml0ZSggc2lnbWFSYWRpYW5zICkgPyBNYXRoLlBJIC8gKCAyICogcGl4ZWxzICkgOiAyICogTWF0aC5QSSAvICggMiAqIE1BWF9TQU1QTEVTIC0gMSApO1xyXG5cdFx0Y29uc3Qgc2lnbWFQaXhlbHMgPSBzaWdtYVJhZGlhbnMgLyByYWRpYW5zUGVyUGl4ZWw7XHJcblx0XHRjb25zdCBzYW1wbGVzID0gaXNGaW5pdGUoIHNpZ21hUmFkaWFucyApID8gMSArIE1hdGguZmxvb3IoIFNUQU5EQVJEX0RFVklBVElPTlMgKiBzaWdtYVBpeGVscyApIDogTUFYX1NBTVBMRVM7XHJcblxyXG5cdFx0aWYgKCBzYW1wbGVzID4gTUFYX1NBTVBMRVMgKSB7XHJcblxyXG5cdFx0XHRjb25zb2xlLndhcm4oIGBzaWdtYVJhZGlhbnMsICR7XHJcblx0XHRcdFx0c2lnbWFSYWRpYW5zfSwgaXMgdG9vIGxhcmdlIGFuZCB3aWxsIGNsaXAsIGFzIGl0IHJlcXVlc3RlZCAke1xyXG5cdFx0XHRcdHNhbXBsZXN9IHNhbXBsZXMgd2hlbiB0aGUgbWF4aW11bSBpcyBzZXQgdG8gJHtNQVhfU0FNUExFU31gICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGNvbnN0IHdlaWdodHMgPSBbXTtcclxuXHRcdGxldCBzdW0gPSAwO1xyXG5cclxuXHRcdGZvciAoIGxldCBpID0gMDsgaSA8IE1BWF9TQU1QTEVTOyArKyBpICkge1xyXG5cclxuXHRcdFx0Y29uc3QgeCA9IGkgLyBzaWdtYVBpeGVscztcclxuXHRcdFx0Y29uc3Qgd2VpZ2h0ID0gTWF0aC5leHAoIC0geCAqIHggLyAyICk7XHJcblx0XHRcdHdlaWdodHMucHVzaCggd2VpZ2h0ICk7XHJcblxyXG5cdFx0XHRpZiAoIGkgPT09IDAgKSB7XHJcblxyXG5cdFx0XHRcdHN1bSArPSB3ZWlnaHQ7XHJcblxyXG5cdFx0XHR9IGVsc2UgaWYgKCBpIDwgc2FtcGxlcyApIHtcclxuXHJcblx0XHRcdFx0c3VtICs9IDIgKiB3ZWlnaHQ7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGZvciAoIGxldCBpID0gMDsgaSA8IHdlaWdodHMubGVuZ3RoOyBpICsrICkge1xyXG5cclxuXHRcdFx0d2VpZ2h0c1sgaSBdID0gd2VpZ2h0c1sgaSBdIC8gc3VtO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR0YXJnZXRJbi50ZXh0dXJlLmZyYW1lID0gKCB0YXJnZXRJbi50ZXh0dXJlLmZyYW1lIHx8IDAgKSArIDE7XHJcblxyXG5cdFx0Ymx1clVuaWZvcm1zLmVudk1hcC52YWx1ZSA9IHRhcmdldEluLnRleHR1cmU7XHJcblx0XHRibHVyVW5pZm9ybXMuc2FtcGxlcy52YWx1ZSA9IHNhbXBsZXM7XHJcblx0XHRibHVyVW5pZm9ybXMud2VpZ2h0cy5hcnJheSA9IHdlaWdodHM7XHJcblx0XHRibHVyVW5pZm9ybXMubGF0aXR1ZGluYWwudmFsdWUgPSBkaXJlY3Rpb24gPT09ICdsYXRpdHVkaW5hbCcgPyAxIDogMDtcclxuXHJcblx0XHRpZiAoIHBvbGVBeGlzICkge1xyXG5cclxuXHRcdFx0Ymx1clVuaWZvcm1zLnBvbGVBeGlzLnZhbHVlID0gcG9sZUF4aXM7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGNvbnN0IHsgX2xvZE1heCB9ID0gdGhpcztcclxuXHRcdGJsdXJVbmlmb3Jtcy5kVGhldGEudmFsdWUgPSByYWRpYW5zUGVyUGl4ZWw7XHJcblx0XHRibHVyVW5pZm9ybXMubWlwSW50LnZhbHVlID0gX2xvZE1heCAtIGxvZEluO1xyXG5cclxuXHRcdGNvbnN0IG91dHB1dFNpemUgPSB0aGlzLl9zaXplTG9kc1sgbG9kT3V0IF07XHJcblx0XHRjb25zdCB4ID0gMyAqIG91dHB1dFNpemUgKiAoIGxvZE91dCA+IF9sb2RNYXggLSBMT0RfTUlOID8gbG9kT3V0IC0gX2xvZE1heCArIExPRF9NSU4gOiAwICk7XHJcblx0XHRjb25zdCB5ID0gNCAqICggdGhpcy5fY3ViZVNpemUgLSBvdXRwdXRTaXplICk7XHJcblxyXG5cdFx0X3NldFZpZXdwb3J0KCB0YXJnZXRPdXQsIHgsIHksIDMgKiBvdXRwdXRTaXplLCAyICogb3V0cHV0U2l6ZSApO1xyXG5cdFx0cmVuZGVyZXIuc2V0UmVuZGVyVGFyZ2V0KCB0YXJnZXRPdXQgKTtcclxuXHRcdHJlbmRlcmVyLnJlbmRlciggYmx1ck1lc2gsIF9mbGF0Q2FtZXJhICk7XHJcblxyXG5cdH1cclxuXHJcbn1cclxuXHJcbmZ1bmN0aW9uIF9jcmVhdGVQbGFuZXMoIGxvZE1heCApIHtcclxuXHJcblx0Y29uc3QgbG9kUGxhbmVzID0gW107XHJcblx0Y29uc3Qgc2l6ZUxvZHMgPSBbXTtcclxuXHRjb25zdCBzaWdtYXMgPSBbXTtcclxuXHRjb25zdCBsb2RNZXNoZXMgPSBbXTtcclxuXHJcblx0bGV0IGxvZCA9IGxvZE1heDtcclxuXHJcblx0Y29uc3QgdG90YWxMb2RzID0gbG9kTWF4IC0gTE9EX01JTiArIDEgKyBFWFRSQV9MT0RfU0lHTUEubGVuZ3RoO1xyXG5cclxuXHRmb3IgKCBsZXQgaSA9IDA7IGkgPCB0b3RhbExvZHM7IGkgKysgKSB7XHJcblxyXG5cdFx0Y29uc3Qgc2l6ZUxvZCA9IE1hdGgucG93KCAyLCBsb2QgKTtcclxuXHRcdHNpemVMb2RzLnB1c2goIHNpemVMb2QgKTtcclxuXHRcdGxldCBzaWdtYSA9IDEuMCAvIHNpemVMb2Q7XHJcblxyXG5cdFx0aWYgKCBpID4gbG9kTWF4IC0gTE9EX01JTiApIHtcclxuXHJcblx0XHRcdHNpZ21hID0gRVhUUkFfTE9EX1NJR01BWyBpIC0gbG9kTWF4ICsgTE9EX01JTiAtIDEgXTtcclxuXHJcblx0XHR9IGVsc2UgaWYgKCBpID09PSAwICkge1xyXG5cclxuXHRcdFx0c2lnbWEgPSAwO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRzaWdtYXMucHVzaCggc2lnbWEgKTtcclxuXHJcblx0XHRjb25zdCB0ZXhlbFNpemUgPSAxLjAgLyAoIHNpemVMb2QgLSAyICk7XHJcblx0XHRjb25zdCBtaW4gPSAtIHRleGVsU2l6ZTtcclxuXHRcdGNvbnN0IG1heCA9IDEgKyB0ZXhlbFNpemU7XHJcblx0XHRjb25zdCB1djEgPSBbIG1pbiwgbWluLCBtYXgsIG1pbiwgbWF4LCBtYXgsIG1pbiwgbWluLCBtYXgsIG1heCwgbWluLCBtYXggXTtcclxuXHJcblx0XHRjb25zdCBjdWJlRmFjZXMgPSA2O1xyXG5cdFx0Y29uc3QgdmVydGljZXMgPSA2O1xyXG5cdFx0Y29uc3QgcG9zaXRpb25TaXplID0gMztcclxuXHRcdGNvbnN0IHV2U2l6ZSA9IDI7XHJcblx0XHRjb25zdCBmYWNlSW5kZXhTaXplID0gMTtcclxuXHJcblx0XHRjb25zdCBwb3NpdGlvbiA9IG5ldyBGbG9hdDMyQXJyYXkoIHBvc2l0aW9uU2l6ZSAqIHZlcnRpY2VzICogY3ViZUZhY2VzICk7XHJcblx0XHRjb25zdCB1diA9IG5ldyBGbG9hdDMyQXJyYXkoIHV2U2l6ZSAqIHZlcnRpY2VzICogY3ViZUZhY2VzICk7XHJcblx0XHRjb25zdCBmYWNlSW5kZXggPSBuZXcgRmxvYXQzMkFycmF5KCBmYWNlSW5kZXhTaXplICogdmVydGljZXMgKiBjdWJlRmFjZXMgKTtcclxuXHJcblx0XHRmb3IgKCBsZXQgZmFjZSA9IDA7IGZhY2UgPCBjdWJlRmFjZXM7IGZhY2UgKysgKSB7XHJcblxyXG5cdFx0XHRjb25zdCB4ID0gKCBmYWNlICUgMyApICogMiAvIDMgLSAxO1xyXG5cdFx0XHRjb25zdCB5ID0gZmFjZSA+IDIgPyAwIDogLSAxO1xyXG5cdFx0XHRjb25zdCBjb29yZGluYXRlcyA9IFtcclxuXHRcdFx0XHR4LCB5LCAwLFxyXG5cdFx0XHRcdHggKyAyIC8gMywgeSwgMCxcclxuXHRcdFx0XHR4ICsgMiAvIDMsIHkgKyAxLCAwLFxyXG5cdFx0XHRcdHgsIHksIDAsXHJcblx0XHRcdFx0eCArIDIgLyAzLCB5ICsgMSwgMCxcclxuXHRcdFx0XHR4LCB5ICsgMSwgMFxyXG5cdFx0XHRdO1xyXG5cclxuXHRcdFx0Y29uc3QgZmFjZUlkeCA9IF9mYWNlTGliWyBmYWNlIF07XHJcblx0XHRcdHBvc2l0aW9uLnNldCggY29vcmRpbmF0ZXMsIHBvc2l0aW9uU2l6ZSAqIHZlcnRpY2VzICogZmFjZUlkeCApO1xyXG5cdFx0XHR1di5zZXQoIHV2MSwgdXZTaXplICogdmVydGljZXMgKiBmYWNlSWR4ICk7XHJcblx0XHRcdGNvbnN0IGZpbGwgPSBbIGZhY2VJZHgsIGZhY2VJZHgsIGZhY2VJZHgsIGZhY2VJZHgsIGZhY2VJZHgsIGZhY2VJZHggXTtcclxuXHRcdFx0ZmFjZUluZGV4LnNldCggZmlsbCwgZmFjZUluZGV4U2l6ZSAqIHZlcnRpY2VzICogZmFjZUlkeCApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRjb25zdCBwbGFuZXMgPSBuZXcgQnVmZmVyR2VvbWV0cnkoKTtcclxuXHRcdHBsYW5lcy5zZXRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIG5ldyBCdWZmZXJBdHRyaWJ1dGUoIHBvc2l0aW9uLCBwb3NpdGlvblNpemUgKSApO1xyXG5cdFx0cGxhbmVzLnNldEF0dHJpYnV0ZSggJ3V2JywgbmV3IEJ1ZmZlckF0dHJpYnV0ZSggdXYsIHV2U2l6ZSApICk7XHJcblx0XHRwbGFuZXMuc2V0QXR0cmlidXRlKCAnZmFjZUluZGV4JywgbmV3IEJ1ZmZlckF0dHJpYnV0ZSggZmFjZUluZGV4LCBmYWNlSW5kZXhTaXplICkgKTtcclxuXHRcdGxvZFBsYW5lcy5wdXNoKCBwbGFuZXMgKTtcclxuXHRcdGxvZE1lc2hlcy5wdXNoKCBuZXcgTWVzaCggcGxhbmVzLCBudWxsICkgKTtcclxuXHJcblx0XHRpZiAoIGxvZCA+IExPRF9NSU4gKSB7XHJcblxyXG5cdFx0XHRsb2QgLS07XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdHJldHVybiB7IGxvZFBsYW5lcywgc2l6ZUxvZHMsIHNpZ21hcywgbG9kTWVzaGVzIH07XHJcblxyXG59XHJcblxyXG5mdW5jdGlvbiBfY3JlYXRlUmVuZGVyVGFyZ2V0KCB3aWR0aCwgaGVpZ2h0LCBwYXJhbXMgKSB7XHJcblxyXG5cdGNvbnN0IGN1YmVVVlJlbmRlclRhcmdldCA9IG5ldyBSZW5kZXJUYXJnZXQoIHdpZHRoLCBoZWlnaHQsIHBhcmFtcyApO1xyXG5cdGN1YmVVVlJlbmRlclRhcmdldC50ZXh0dXJlLm1hcHBpbmcgPSBDdWJlVVZSZWZsZWN0aW9uTWFwcGluZztcclxuXHRjdWJlVVZSZW5kZXJUYXJnZXQudGV4dHVyZS5uYW1lID0gJ1BNUkVNLmN1YmVVdic7XHJcblx0Y3ViZVVWUmVuZGVyVGFyZ2V0LnRleHR1cmUuaXNQTVJFTVRleHR1cmUgPSB0cnVlO1xyXG5cdGN1YmVVVlJlbmRlclRhcmdldC5zY2lzc29yVGVzdCA9IHRydWU7XHJcblx0cmV0dXJuIGN1YmVVVlJlbmRlclRhcmdldDtcclxuXHJcbn1cclxuXHJcbmZ1bmN0aW9uIF9zZXRWaWV3cG9ydCggdGFyZ2V0LCB4LCB5LCB3aWR0aCwgaGVpZ2h0ICkge1xyXG5cclxuXHR0YXJnZXQudmlld3BvcnQuc2V0KCB4LCB5LCB3aWR0aCwgaGVpZ2h0ICk7XHJcblx0dGFyZ2V0LnNjaXNzb3Iuc2V0KCB4LCB5LCB3aWR0aCwgaGVpZ2h0ICk7XHJcblxyXG59XHJcblxyXG5mdW5jdGlvbiBfZ2V0TWF0ZXJpYWwoIHR5cGUgKSB7XHJcblxyXG5cdGNvbnN0IG1hdGVyaWFsID0gbmV3IE5vZGVNYXRlcmlhbCgpO1xyXG5cdG1hdGVyaWFsLmRlcHRoVGVzdCA9IGZhbHNlO1xyXG5cdG1hdGVyaWFsLmRlcHRoV3JpdGUgPSBmYWxzZTtcclxuXHRtYXRlcmlhbC5ibGVuZGluZyA9IE5vQmxlbmRpbmc7XHJcblx0bWF0ZXJpYWwubmFtZSA9IGBQTVJFTV8keyB0eXBlIH1gO1xyXG5cclxuXHRyZXR1cm4gbWF0ZXJpYWw7XHJcblxyXG59XHJcblxyXG5mdW5jdGlvbiBfZ2V0Qmx1clNoYWRlciggbG9kTWF4LCB3aWR0aCwgaGVpZ2h0ICkge1xyXG5cclxuXHRjb25zdCB3ZWlnaHRzID0gdW5pZm9ybUFycmF5KCBuZXcgQXJyYXkoIE1BWF9TQU1QTEVTICkuZmlsbCggMCApICk7XHJcblx0Y29uc3QgcG9sZUF4aXMgPSB1bmlmb3JtKCBuZXcgVmVjdG9yMyggMCwgMSwgMCApICk7XHJcblx0Y29uc3QgZFRoZXRhID0gdW5pZm9ybSggMCApO1xyXG5cdGNvbnN0IG4gPSBmbG9hdCggTUFYX1NBTVBMRVMgKTtcclxuXHRjb25zdCBsYXRpdHVkaW5hbCA9IHVuaWZvcm0oIDAgKTsgLy8gZmFsc2UsIGJvb2xcclxuXHRjb25zdCBzYW1wbGVzID0gdW5pZm9ybSggMSApOyAvLyBpbnRcclxuXHRjb25zdCBlbnZNYXAgPSB0ZXh0dXJlKCBudWxsICk7XHJcblx0Y29uc3QgbWlwSW50ID0gdW5pZm9ybSggMCApOyAvLyBpbnRcclxuXHRjb25zdCBDVUJFVVZfVEVYRUxfV0lEVEggPSBmbG9hdCggMSAvIHdpZHRoICk7XHJcblx0Y29uc3QgQ1VCRVVWX1RFWEVMX0hFSUdIVCA9IGZsb2F0KCAxIC8gaGVpZ2h0ICk7XHJcblx0Y29uc3QgQ1VCRVVWX01BWF9NSVAgPSBmbG9hdCggbG9kTWF4ICk7XHJcblxyXG5cdGNvbnN0IG1hdGVyaWFsVW5pZm9ybXMgPSB7XHJcblx0XHRuLFxyXG5cdFx0bGF0aXR1ZGluYWwsXHJcblx0XHR3ZWlnaHRzLFxyXG5cdFx0cG9sZUF4aXMsXHJcblx0XHRvdXRwdXREaXJlY3Rpb24sXHJcblx0XHRkVGhldGEsXHJcblx0XHRzYW1wbGVzLFxyXG5cdFx0ZW52TWFwLFxyXG5cdFx0bWlwSW50LFxyXG5cdFx0Q1VCRVVWX1RFWEVMX1dJRFRILFxyXG5cdFx0Q1VCRVVWX1RFWEVMX0hFSUdIVCxcclxuXHRcdENVQkVVVl9NQVhfTUlQXHJcblx0fTtcclxuXHJcblx0Y29uc3QgbWF0ZXJpYWwgPSBfZ2V0TWF0ZXJpYWwoICdibHVyJyApO1xyXG5cdG1hdGVyaWFsLnVuaWZvcm1zID0gbWF0ZXJpYWxVbmlmb3JtczsgLy8gVE9ETzogTW92ZSB0byBvdXRzaWRlIG9mIHRoZSBtYXRlcmlhbFxyXG5cdG1hdGVyaWFsLmZyYWdtZW50Tm9kZSA9IGJsdXIoIHsgLi4ubWF0ZXJpYWxVbmlmb3JtcywgbGF0aXR1ZGluYWw6IGxhdGl0dWRpbmFsLmVxdWFsKCAxICkgfSApO1xyXG5cclxuXHRyZXR1cm4gbWF0ZXJpYWw7XHJcblxyXG59XHJcblxyXG5mdW5jdGlvbiBfZ2V0Q3ViZW1hcE1hdGVyaWFsKCBlbnZUZXh0dXJlICkge1xyXG5cclxuXHRjb25zdCBtYXRlcmlhbCA9IF9nZXRNYXRlcmlhbCggJ2N1YmVtYXAnICk7XHJcblx0bWF0ZXJpYWwuZnJhZ21lbnROb2RlID0gY3ViZVRleHR1cmUoIGVudlRleHR1cmUsIG91dHB1dERpcmVjdGlvbiApO1xyXG5cclxuXHRyZXR1cm4gbWF0ZXJpYWw7XHJcblxyXG59XHJcblxyXG5mdW5jdGlvbiBfZ2V0RXF1aXJlY3RNYXRlcmlhbCggZW52VGV4dHVyZSApIHtcclxuXHJcblx0Y29uc3QgbWF0ZXJpYWwgPSBfZ2V0TWF0ZXJpYWwoICdlcXVpcmVjdCcgKTtcclxuXHRtYXRlcmlhbC5mcmFnbWVudE5vZGUgPSB0ZXh0dXJlKCBlbnZUZXh0dXJlLCBlcXVpcmVjdFVWKCBvdXRwdXREaXJlY3Rpb24gKSwgMCApO1xyXG5cclxuXHRyZXR1cm4gbWF0ZXJpYWw7XHJcblxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBQTVJFTUdlbmVyYXRvcjtcclxuIiwiaW1wb3J0IE5vZGVVbmlmb3JtIGZyb20gJy4vTm9kZVVuaWZvcm0uanMnO1xyXG5pbXBvcnQgTm9kZUF0dHJpYnV0ZSBmcm9tICcuL05vZGVBdHRyaWJ1dGUuanMnO1xyXG5pbXBvcnQgTm9kZVZhcnlpbmcgZnJvbSAnLi9Ob2RlVmFyeWluZy5qcyc7XHJcbmltcG9ydCBOb2RlVmFyIGZyb20gJy4vTm9kZVZhci5qcyc7XHJcbmltcG9ydCBOb2RlQ29kZSBmcm9tICcuL05vZGVDb2RlLmpzJztcclxuaW1wb3J0IE5vZGVDYWNoZSBmcm9tICcuL05vZGVDYWNoZS5qcyc7XHJcbmltcG9ydCBQYXJhbWV0ZXJOb2RlIGZyb20gJy4vUGFyYW1ldGVyTm9kZS5qcyc7XHJcbmltcG9ydCBTdHJ1Y3RUeXBlTm9kZSBmcm9tICcuL1N0cnVjdFR5cGVOb2RlLmpzJztcclxuaW1wb3J0IEZ1bmN0aW9uTm9kZSBmcm9tICcuLi9jb2RlL0Z1bmN0aW9uTm9kZS5qcyc7XHJcbmltcG9ydCBOb2RlTWF0ZXJpYWwgZnJvbSAnLi4vLi4vbWF0ZXJpYWxzL25vZGVzL05vZGVNYXRlcmlhbC5qcyc7XHJcbmltcG9ydCB7IGdldFR5cGVGcm9tTGVuZ3RoIH0gZnJvbSAnLi9Ob2RlVXRpbHMuanMnO1xyXG5pbXBvcnQgeyBOb2RlVXBkYXRlVHlwZSwgZGVmYXVsdEJ1aWxkU3RhZ2VzLCBzaGFkZXJTdGFnZXMgfSBmcm9tICcuL2NvbnN0YW50cy5qcyc7XHJcblxyXG5pbXBvcnQge1xyXG5cdE51bWJlck5vZGVVbmlmb3JtLCBWZWN0b3IyTm9kZVVuaWZvcm0sIFZlY3RvcjNOb2RlVW5pZm9ybSwgVmVjdG9yNE5vZGVVbmlmb3JtLFxyXG5cdENvbG9yTm9kZVVuaWZvcm0sIE1hdHJpeDNOb2RlVW5pZm9ybSwgTWF0cml4NE5vZGVVbmlmb3JtXHJcbn0gZnJvbSAnLi4vLi4vcmVuZGVyZXJzL2NvbW1vbi9ub2Rlcy9Ob2RlVW5pZm9ybS5qcyc7XHJcblxyXG5pbXBvcnQgeyBzdGFjayB9IGZyb20gJy4vU3RhY2tOb2RlLmpzJztcclxuaW1wb3J0IHsgZ2V0Q3VycmVudFN0YWNrLCBzZXRDdXJyZW50U3RhY2sgfSBmcm9tICcuLi90c2wvVFNMQmFzZS5qcyc7XHJcblxyXG5pbXBvcnQgQ3ViZVJlbmRlclRhcmdldCBmcm9tICcuLi8uLi9yZW5kZXJlcnMvY29tbW9uL0N1YmVSZW5kZXJUYXJnZXQuanMnO1xyXG5pbXBvcnQgQ2hhaW5NYXAgZnJvbSAnLi4vLi4vcmVuZGVyZXJzL2NvbW1vbi9DaGFpbk1hcC5qcyc7XHJcblxyXG5pbXBvcnQgUE1SRU1HZW5lcmF0b3IgZnJvbSAnLi4vLi4vcmVuZGVyZXJzL2NvbW1vbi9leHRyYXMvUE1SRU1HZW5lcmF0b3IuanMnO1xyXG5cclxuaW1wb3J0IEJpbmRHcm91cCBmcm9tICcuLi8uLi9yZW5kZXJlcnMvY29tbW9uL0JpbmRHcm91cC5qcyc7XHJcblxyXG5pbXBvcnQgeyBSRVZJU0lPTiwgSW50VHlwZSwgVW5zaWduZWRJbnRUeXBlLCBMaW5lYXJGaWx0ZXIsIExpbmVhck1pcG1hcE5lYXJlc3RGaWx0ZXIsIE5lYXJlc3RNaXBtYXBMaW5lYXJGaWx0ZXIsIExpbmVhck1pcG1hcExpbmVhckZpbHRlciB9IGZyb20gJy4uLy4uL2NvbnN0YW50cy5qcyc7XHJcbmltcG9ydCB7IFJlbmRlclRhcmdldCB9IGZyb20gJy4uLy4uL2NvcmUvUmVuZGVyVGFyZ2V0LmpzJztcclxuaW1wb3J0IHsgQ29sb3IgfSBmcm9tICcuLi8uLi9tYXRoL0NvbG9yLmpzJztcclxuaW1wb3J0IHsgVmVjdG9yMiB9IGZyb20gJy4uLy4uL21hdGgvVmVjdG9yMi5qcyc7XHJcbmltcG9ydCB7IFZlY3RvcjMgfSBmcm9tICcuLi8uLi9tYXRoL1ZlY3RvcjMuanMnO1xyXG5pbXBvcnQgeyBWZWN0b3I0IH0gZnJvbSAnLi4vLi4vbWF0aC9WZWN0b3I0LmpzJztcclxuaW1wb3J0IHsgRmxvYXQxNkJ1ZmZlckF0dHJpYnV0ZSB9IGZyb20gJy4uLy4uL2NvcmUvQnVmZmVyQXR0cmlidXRlLmpzJztcclxuXHJcbmNvbnN0IHJlbmRlcmVyQ2FjaGUgPSBuZXcgV2Vha01hcCgpO1xyXG5cclxuY29uc3QgdHlwZUZyb21BcnJheSA9IG5ldyBNYXAoIFtcclxuXHRbIEludDhBcnJheSwgJ2ludCcgXSxcclxuXHRbIEludDE2QXJyYXksICdpbnQnIF0sXHJcblx0WyBJbnQzMkFycmF5LCAnaW50JyBdLFxyXG5cdFsgVWludDhBcnJheSwgJ3VpbnQnIF0sXHJcblx0WyBVaW50MTZBcnJheSwgJ3VpbnQnIF0sXHJcblx0WyBVaW50MzJBcnJheSwgJ3VpbnQnIF0sXHJcblx0WyBGbG9hdDMyQXJyYXksICdmbG9hdCcgXVxyXG5dICk7XHJcblxyXG5jb25zdCB0b0Zsb2F0ID0gKCB2YWx1ZSApID0+IHtcclxuXHJcblx0aWYgKCAvZS9nLnRlc3QoIHZhbHVlICkgKSB7XHJcblxyXG5cdFx0cmV0dXJuIFN0cmluZyggdmFsdWUgKS5yZXBsYWNlKCAvXFwrL2csICcnICk7XHJcblxyXG5cdH0gZWxzZSB7XHJcblxyXG5cdFx0dmFsdWUgPSBOdW1iZXIoIHZhbHVlICk7XHJcblxyXG5cdFx0cmV0dXJuIHZhbHVlICsgKCB2YWx1ZSAlIDEgPyAnJyA6ICcuMCcgKTtcclxuXHJcblx0fVxyXG5cclxufTtcclxuXHJcbi8qKlxyXG4gKiBCYXNlIGNsYXNzIGZvciBidWlsZGVycyB3aGljaCBnZW5lcmF0ZSBhIHNoYWRlciBwcm9ncmFtIGJhc2VkXHJcbiAqIG9uIGEgM0Qgb2JqZWN0IGFuZCBpdHMgbm9kZSBtYXRlcmlhbCBkZWZpbml0aW9uLlxyXG4gKi9cclxuY2xhc3MgTm9kZUJ1aWxkZXIge1xyXG5cclxuXHQvKipcclxuXHQgKiBDb25zdHJ1Y3RzIGEgbmV3IG5vZGUgYnVpbGRlci5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7T2JqZWN0M0R9IG9iamVjdCAtIFRoZSAzRCBvYmplY3QuXHJcblx0ICogQHBhcmFtIHtSZW5kZXJlcn0gcmVuZGVyZXIgLSBUaGUgY3VycmVudCByZW5kZXJlci5cclxuXHQgKiBAcGFyYW0ge05vZGVQYXJzZXJ9IHBhcnNlciAtIEEgcmVmZXJlbmNlIHRvIGEgbm9kZSBwYXJzZXIuXHJcblx0ICovXHJcblx0Y29uc3RydWN0b3IoIG9iamVjdCwgcmVuZGVyZXIsIHBhcnNlciApIHtcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIFRoZSAzRCBvYmplY3QuXHJcblx0XHQgKlxyXG5cdFx0ICogQHR5cGUge09iamVjdDNEfVxyXG5cdFx0ICovXHJcblx0XHR0aGlzLm9iamVjdCA9IG9iamVjdDtcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIFRoZSBtYXRlcmlhbCBvZiB0aGUgM0Qgb2JqZWN0LlxyXG5cdFx0ICpcclxuXHRcdCAqIEB0eXBlIHtNYXRlcmlhbD99XHJcblx0XHQgKi9cclxuXHRcdHRoaXMubWF0ZXJpYWwgPSAoIG9iamVjdCAmJiBvYmplY3QubWF0ZXJpYWwgKSB8fCBudWxsO1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogVGhlIGdlb21ldHJ5IG9mIHRoZSAzRCBvYmplY3QuXHJcblx0XHQgKlxyXG5cdFx0ICogQHR5cGUge0J1ZmZlckdlb21ldHJ5P31cclxuXHRcdCAqL1xyXG5cdFx0dGhpcy5nZW9tZXRyeSA9ICggb2JqZWN0ICYmIG9iamVjdC5nZW9tZXRyeSApIHx8IG51bGw7XHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBUaGUgY3VycmVudCByZW5kZXJlci5cclxuXHRcdCAqXHJcblx0XHQgKiBAdHlwZSB7UmVuZGVyZXJ9XHJcblx0XHQgKi9cclxuXHRcdHRoaXMucmVuZGVyZXIgPSByZW5kZXJlcjtcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIEEgcmVmZXJlbmNlIHRvIGEgbm9kZSBwYXJzZXIuXHJcblx0XHQgKlxyXG5cdFx0ICogQHR5cGUge05vZGVQYXJzZXJ9XHJcblx0XHQgKi9cclxuXHRcdHRoaXMucGFyc2VyID0gcGFyc2VyO1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogVGhlIHNjZW5lIHRoZSAzRCBvYmplY3QgYmVsb25ncyB0by5cclxuXHRcdCAqXHJcblx0XHQgKiBAdHlwZSB7U2NlbmU/fVxyXG5cdFx0ICogQGRlZmF1bHQgbnVsbFxyXG5cdFx0ICovXHJcblx0XHR0aGlzLnNjZW5lID0gbnVsbDtcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIFRoZSBjYW1lcmEgdGhlIDNEIG9iamVjdCBpcyByZW5kZXJlZCB3aXRoLlxyXG5cdFx0ICpcclxuXHRcdCAqIEB0eXBlIHtDYW1lcmE/fVxyXG5cdFx0ICogQGRlZmF1bHQgbnVsbFxyXG5cdFx0ICovXHJcblx0XHR0aGlzLmNhbWVyYSA9IG51bGw7XHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBBIGxpc3Qgb2YgYWxsIG5vZGVzIHRoZSBidWlsZGVyIGlzIHByb2Nlc3NpbmdcclxuXHRcdCAqIGZvciB0aGlzIDNEIG9iamVjdC5cclxuXHRcdCAqXHJcblx0XHQgKiBAdHlwZSB7QXJyYXk8Tm9kZT59XHJcblx0XHQgKi9cclxuXHRcdHRoaXMubm9kZXMgPSBbXTtcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIEEgbGlzdCBvZiBhbGwgc2VxdWVudGlhbCBub2Rlcy5cclxuXHRcdCAqXHJcblx0XHQgKiBAdHlwZSB7QXJyYXk8Tm9kZT59XHJcblx0XHQgKi9cclxuXHRcdHRoaXMuc2VxdWVudGlhbE5vZGVzID0gW107XHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBBIGxpc3Qgb2YgYWxsIG5vZGVzIHdoaWNoIHtAbGluayBOb2RlI3VwZGF0ZX0gbWV0aG9kIHNob3VsZCBiZSBleGVjdXRlZC5cclxuXHRcdCAqXHJcblx0XHQgKiBAdHlwZSB7QXJyYXk8Tm9kZT59XHJcblx0XHQgKi9cclxuXHRcdHRoaXMudXBkYXRlTm9kZXMgPSBbXTtcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIEEgbGlzdCBvZiBhbGwgbm9kZXMgd2hpY2gge0BsaW5rIE5vZGUjdXBkYXRlQmVmb3JlfSBtZXRob2Qgc2hvdWxkIGJlIGV4ZWN1dGVkLlxyXG5cdFx0ICpcclxuXHRcdCAqIEB0eXBlIHtBcnJheTxOb2RlPn1cclxuXHRcdCAqL1xyXG5cdFx0dGhpcy51cGRhdGVCZWZvcmVOb2RlcyA9IFtdO1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogQSBsaXN0IG9mIGFsbCBub2RlcyB3aGljaCB7QGxpbmsgTm9kZSN1cGRhdGVBZnRlcn0gbWV0aG9kIHNob3VsZCBiZSBleGVjdXRlZC5cclxuXHRcdCAqXHJcblx0XHQgKiBAdHlwZSB7QXJyYXk8Tm9kZT59XHJcblx0XHQgKi9cclxuXHRcdHRoaXMudXBkYXRlQWZ0ZXJOb2RlcyA9IFtdO1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogQSBkaWN0aW9uYXJ5IHRoYXQgYXNzaWducyBlYWNoIG5vZGUgdG8gYSB1bmlxdWUgaGFzaC5cclxuXHRcdCAqXHJcblx0XHQgKiBAdHlwZSB7T2JqZWN0PE51bWJlcixOb2RlPn1cclxuXHRcdCAqL1xyXG5cdFx0dGhpcy5oYXNoTm9kZXMgPSB7fTtcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIEEgcmVmZXJlbmNlIHRvIGEgbm9kZSBtYXRlcmlhbCBvYnNlcnZlci5cclxuXHRcdCAqXHJcblx0XHQgKiBAdHlwZSB7Tm9kZU1hdGVyaWFsT2JzZXJ2ZXI/fVxyXG5cdFx0ICogQGRlZmF1bHQgbnVsbFxyXG5cdFx0ICovXHJcblx0XHR0aGlzLm1vbml0b3IgPSBudWxsO1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogQSByZWZlcmVuY2UgdG8gdGhlIGN1cnJlbnQgbGlnaHRzIG5vZGUuXHJcblx0XHQgKlxyXG5cdFx0ICogQHR5cGUge0xpZ2h0c05vZGU/fVxyXG5cdFx0ICogQGRlZmF1bHQgbnVsbFxyXG5cdFx0ICovXHJcblx0XHR0aGlzLmxpZ2h0c05vZGUgPSBudWxsO1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogQSByZWZlcmVuY2UgdG8gdGhlIGN1cnJlbnQgZW52aXJvbm1lbnQgbm9kZS5cclxuXHRcdCAqXHJcblx0XHQgKiBAdHlwZSB7Tm9kZT99XHJcblx0XHQgKiBAZGVmYXVsdCBudWxsXHJcblx0XHQgKi9cclxuXHRcdHRoaXMuZW52aXJvbm1lbnROb2RlID0gbnVsbDtcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIEEgcmVmZXJlbmNlIHRvIHRoZSBjdXJyZW50IGZvZyBub2RlLlxyXG5cdFx0ICpcclxuXHRcdCAqIEB0eXBlIHtGb2dOb2RlP31cclxuXHRcdCAqIEBkZWZhdWx0IG51bGxcclxuXHRcdCAqL1xyXG5cdFx0dGhpcy5mb2dOb2RlID0gbnVsbDtcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIFRoZSBjdXJyZW50IGNsaXBwaW5nIGNvbnRleHQuXHJcblx0XHQgKlxyXG5cdFx0ICogQHR5cGUge0NsaXBwaW5nQ29udGV4dD99XHJcblx0XHQgKi9cclxuXHRcdHRoaXMuY2xpcHBpbmdDb250ZXh0ID0gbnVsbDtcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIFRoZSBnZW5lcmF0ZWQgdmVydGV4IHNoYWRlci5cclxuXHRcdCAqXHJcblx0XHQgKiBAdHlwZSB7U3RyaW5nP31cclxuXHRcdCAqL1xyXG5cdFx0dGhpcy52ZXJ0ZXhTaGFkZXIgPSBudWxsO1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogVGhlIGdlbmVyYXRlZCBmcmFnbWVudCBzaGFkZXIuXHJcblx0XHQgKlxyXG5cdFx0ICogQHR5cGUge1N0cmluZz99XHJcblx0XHQgKi9cclxuXHRcdHRoaXMuZnJhZ21lbnRTaGFkZXIgPSBudWxsO1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogVGhlIGdlbmVyYXRlZCBjb21wdXRlIHNoYWRlci5cclxuXHRcdCAqXHJcblx0XHQgKiBAdHlwZSB7U3RyaW5nP31cclxuXHRcdCAqL1xyXG5cdFx0dGhpcy5jb21wdXRlU2hhZGVyID0gbnVsbDtcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIE5vZGVzIHVzZWQgaW4gdGhlIHByaW1hcnkgZmxvdyBvZiBjb2RlIGdlbmVyYXRpb24uXHJcblx0XHQgKlxyXG5cdFx0ICogQHR5cGUge09iamVjdDxTdHJpbmcsQXJyYXk8Tm9kZT4+fVxyXG5cdFx0ICovXHJcblx0XHR0aGlzLmZsb3dOb2RlcyA9IHsgdmVydGV4OiBbXSwgZnJhZ21lbnQ6IFtdLCBjb21wdXRlOiBbXSB9O1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogTm9kZXMgY29kZSBmcm9tIGAuZmxvd05vZGVzYC5cclxuXHRcdCAqXHJcblx0XHQgKiBAdHlwZSB7T2JqZWN0PFN0cmluZyxTdHJpbmc+fVxyXG5cdFx0ICovXHJcblx0XHR0aGlzLmZsb3dDb2RlID0geyB2ZXJ0ZXg6ICcnLCBmcmFnbWVudDogJycsIGNvbXB1dGU6ICcnIH07XHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBUaGlzIGRpY3Rpb25hcnkgaG9sZHMgdGhlIG5vZGUgdW5pZm9ybXMgb2YgdGhlIGJ1aWxkZXIuXHJcblx0XHQgKiBUaGUgdW5pZm9ybXMgYXJlIG1haW50YWluZWQgaW4gYW4gYXJyYXkgZm9yIGVhY2ggc2hhZGVyIHN0YWdlLlxyXG5cdFx0ICpcclxuXHRcdCAqIEB0eXBlIHtPYmplY3R9XHJcblx0XHQgKi9cclxuXHRcdHRoaXMudW5pZm9ybXMgPSB7IHZlcnRleDogW10sIGZyYWdtZW50OiBbXSwgY29tcHV0ZTogW10sIGluZGV4OiAwIH07XHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBUaGlzIGRpY3Rpb25hcnkgaG9sZHMgdGhlIG91dHB1dCBzdHJ1Y3RzIG9mIHRoZSBidWlsZGVyLlxyXG5cdFx0ICogVGhlIHN0cnVjdHMgYXJlIG1haW50YWluZWQgaW4gYW4gYXJyYXkgZm9yIGVhY2ggc2hhZGVyIHN0YWdlLlxyXG5cdFx0ICpcclxuXHRcdCAqIEB0eXBlIHtPYmplY3R9XHJcblx0XHQgKi9cclxuXHRcdHRoaXMuc3RydWN0cyA9IHsgdmVydGV4OiBbXSwgZnJhZ21lbnQ6IFtdLCBjb21wdXRlOiBbXSwgaW5kZXg6IDAgfTtcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIFRoaXMgZGljdGlvbmFyeSBob2xkcyB0aGUgYmluZGluZ3MgZm9yIGVhY2ggc2hhZGVyIHN0YWdlLlxyXG5cdFx0ICpcclxuXHRcdCAqIEB0eXBlIHtPYmplY3R9XHJcblx0XHQgKi9cclxuXHRcdHRoaXMuYmluZGluZ3MgPSB7IHZlcnRleDoge30sIGZyYWdtZW50OiB7fSwgY29tcHV0ZToge30gfTtcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIFRoaXMgZGljdGlvbmFyeSBtYWludGFpbnMgdGhlIGJpbmRpbmcgaW5kaWNlcyBwZXIgYmluZCBncm91cC5cclxuXHRcdCAqXHJcblx0XHQgKiBAdHlwZSB7T2JqZWN0fVxyXG5cdFx0ICovXHJcblx0XHR0aGlzLmJpbmRpbmdzSW5kZXhlcyA9IHt9O1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogUmVmZXJlbmNlIHRvIHRoZSBhcnJheSBvZiBiaW5kIGdyb3Vwcy5cclxuXHRcdCAqXHJcblx0XHQgKiBAdHlwZSB7QXJyYXk8QmluZEdyb3VwPj99XHJcblx0XHQgKi9cclxuXHRcdHRoaXMuYmluZEdyb3VwcyA9IG51bGw7XHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBUaGlzIGFycmF5IGhvbGRzIHRoZSBub2RlIGF0dHJpYnV0ZXMgb2YgdGhpcyBidWlsZGVyXHJcblx0XHQgKiBjcmVhdGVkIHZpYSB7QGxpbmsgQXR0cmlidXRlTm9kZX0uXHJcblx0XHQgKlxyXG5cdFx0ICogQHR5cGUge0FycmF5PE5vZGVBdHRyaWJ1dGU+fVxyXG5cdFx0ICovXHJcblx0XHR0aGlzLmF0dHJpYnV0ZXMgPSBbXTtcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIFRoaXMgYXJyYXkgaG9sZHMgdGhlIG5vZGUgYXR0cmlidXRlcyBvZiB0aGlzIGJ1aWxkZXJcclxuXHRcdCAqIGNyZWF0ZWQgdmlhIHtAbGluayBCdWZmZXJBdHRyaWJ1dGVOb2RlfS5cclxuXHRcdCAqXHJcblx0XHQgKiBAdHlwZSB7QXJyYXk8Tm9kZUF0dHJpYnV0ZT59XHJcblx0XHQgKi9cclxuXHRcdHRoaXMuYnVmZmVyQXR0cmlidXRlcyA9IFtdO1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogVGhpcyBhcnJheSBob2xkcyB0aGUgbm9kZSB2YXJ5aW5ncyBvZiB0aGlzIGJ1aWxkZXIuXHJcblx0XHQgKlxyXG5cdFx0ICogQHR5cGUge0FycmF5PE5vZGVWYXJ5aW5nPn1cclxuXHRcdCAqL1xyXG5cdFx0dGhpcy52YXJ5aW5ncyA9IFtdO1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogVGhpcyBkaWN0aW9uYXJ5IGhvbGRzIHRoZSAobmF0aXZlKSBub2RlIGNvZGVzIG9mIHRoaXMgYnVpbGRlci5cclxuXHRcdCAqIFRoZSBjb2RlcyBhcmUgbWFpbnRhaW5lZCBpbiBhbiBhcnJheSBmb3IgZWFjaCBzaGFkZXIgc3RhZ2UuXHJcblx0XHQgKlxyXG5cdFx0ICogQHR5cGUge09iamVjdDxTdHJpbmcsQXJyYXk8Tm9kZUNvZGU+Pn1cclxuXHRcdCAqL1xyXG5cdFx0dGhpcy5jb2RlcyA9IHt9O1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogVGhpcyBkaWN0aW9uYXJ5IGhvbGRzIHRoZSBub2RlIHZhcmlhYmxlcyBvZiB0aGlzIGJ1aWxkZXIuXHJcblx0XHQgKiBUaGUgdmFyaWFibGVzIGFyZSBtYWludGFpbmVkIGluIGFuIGFycmF5IGZvciBlYWNoIHNoYWRlciBzdGFnZS5cclxuXHRcdCAqXHJcblx0XHQgKiBAdHlwZSB7T2JqZWN0PFN0cmluZyxBcnJheTxOb2RlVmFyPj59XHJcblx0XHQgKi9cclxuXHRcdHRoaXMudmFycyA9IHt9O1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogQ3VycmVudCBjb2RlIGZsb3cuXHJcblx0XHQgKiBBbGwgY29kZSBnZW5lcmF0ZWQgaW4gdGhpcyBzdGFjayB3aWxsIGJlIHN0b3JlZCBpbiBgLmZsb3dgLlxyXG5cdFx0ICpcclxuXHRcdCAqIEB0eXBlIHt7Y29kZTogU3RyaW5nfX1cclxuXHRcdCAqL1xyXG5cdFx0dGhpcy5mbG93ID0geyBjb2RlOiAnJyB9O1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogQSBjaGFpbiBvZiBub2Rlcy5cclxuXHRcdCAqIFVzZWQgdG8gY2hlY2sgcmVjdXJzaXZlIGNhbGxzIGluIG5vZGUtZ3JhcGguXHJcblx0XHQgKlxyXG5cdFx0ICogQHR5cGUge0FycmF5PE5vZGU+fVxyXG5cdFx0ICovXHJcblx0XHR0aGlzLmNoYWluaW5nID0gW107XHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBUaGUgY3VycmVudCBzdGFjay5cclxuXHRcdCAqIFRoaXMgcmVmbGVjdHMgdGhlIGN1cnJlbnQgcHJvY2VzcyBpbiB0aGUgY29kZSBibG9jayBoaWVyYXJjaHksXHJcblx0XHQgKiBpdCBpcyB1c2VmdWwgdG8ga25vdyBpZiB0aGUgY3VycmVudCBwcm9jZXNzIGlzIGluc2lkZSBhIGNvbmRpdGlvbmFsIGZvciBleGFtcGxlLlxyXG5cdFx0ICpcclxuXHRcdCAqIEB0eXBlIHtTdGFja05vZGV9XHJcblx0XHQgKi9cclxuXHRcdHRoaXMuc3RhY2sgPSBzdGFjaygpO1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogTGlzdCBvZiBzdGFjayBub2Rlcy5cclxuXHRcdCAqIFRoZSBjdXJyZW50IHN0YWNrIGhpZXJhcmNoeSBpcyBzdG9yZWQgaW4gYW4gYXJyYXkuXHJcblx0XHQgKlxyXG5cdFx0ICogQHR5cGUge0FycmF5PFN0YWNrTm9kZT59XHJcblx0XHQgKi9cclxuXHRcdHRoaXMuc3RhY2tzID0gW107XHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBBIHRhYiB2YWx1ZS4gVXNlZCBmb3Igc2hhZGVyIHN0cmluZyBnZW5lcmF0aW9uLlxyXG5cdFx0ICpcclxuXHRcdCAqIEB0eXBlIHtTdHJpbmd9XHJcblx0XHQgKiBAZGVmYXVsdCAnXFx0J1xyXG5cdFx0ICovXHJcblx0XHR0aGlzLnRhYiA9ICdcXHQnO1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogUmVmZXJlbmNlIHRvIHRoZSBjdXJyZW50IGZ1bmN0aW9uIG5vZGUuXHJcblx0XHQgKlxyXG5cdFx0ICogQHR5cGUge0Z1bmN0aW9uTm9kZT99XHJcblx0XHQgKiBAZGVmYXVsdCBudWxsXHJcblx0XHQgKi9cclxuXHRcdHRoaXMuY3VycmVudEZ1bmN0aW9uTm9kZSA9IG51bGw7XHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBUaGUgYnVpbGRlcidzIGNvbnRleHQuXHJcblx0XHQgKlxyXG5cdFx0ICogQHR5cGUge09iamVjdH1cclxuXHRcdCAqL1xyXG5cdFx0dGhpcy5jb250ZXh0ID0ge1xyXG5cdFx0XHRtYXRlcmlhbDogdGhpcy5tYXRlcmlhbFxyXG5cdFx0fTtcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIFRoZSBidWlsZGVyJ3MgY2FjaGUuXHJcblx0XHQgKlxyXG5cdFx0ICogQHR5cGUge05vZGVDYWNoZX1cclxuXHRcdCAqL1xyXG5cdFx0dGhpcy5jYWNoZSA9IG5ldyBOb2RlQ2FjaGUoKTtcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIFNpbmNlIHRoZSB7QGxpbmsgTm9kZUJ1aWxkZXIjY2FjaGV9IG1pZ2h0IGJlIHRlbXBvcmFyaWx5XHJcblx0XHQgKiBvdmVyd3JpdHRlbiBieSBvdGhlciBjYWNoZXMsIHRoaXMgbWVtYmVyIHJldGFpbnMgdGhlIHJlZmVyZW5jZVxyXG5cdFx0ICogdG8gdGhlIGJ1aWxkZXIncyBvd24gY2FjaGUuXHJcblx0XHQgKlxyXG5cdFx0ICogQHR5cGUge05vZGVDYWNoZX1cclxuXHRcdCAqIEBkZWZhdWx0IHRoaXMuY2FjaGVcclxuXHRcdCAqL1xyXG5cdFx0dGhpcy5nbG9iYWxDYWNoZSA9IHRoaXMuY2FjaGU7XHJcblxyXG5cdFx0dGhpcy5mbG93c0RhdGEgPSBuZXcgV2Vha01hcCgpO1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogVGhlIGN1cnJlbnQgc2hhZGVyIHN0YWdlLlxyXG5cdFx0ICpcclxuXHRcdCAqIEB0eXBlIHsoJ3ZlcnRleCd8J2ZyYWdtZW50J3wnY29tcHV0ZSd8J2FueScpP31cclxuXHRcdCAqL1xyXG5cdFx0dGhpcy5zaGFkZXJTdGFnZSA9IG51bGw7XHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBUaGUgY3VycmVudCBidWlsZCBzdGFnZS5cclxuXHRcdCAqXHJcblx0XHQgKiBAdHlwZSB7KCdzZXR1cCd8J2FuYWx5emUnfCdnZW5lcmF0ZScpP31cclxuXHRcdCAqL1xyXG5cdFx0dGhpcy5idWlsZFN0YWdlID0gbnVsbDtcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIFdoZXRoZXIgY29tcGFyaXNvbiBpbiBzaGFkZXIgY29kZSBhcmUgZ2VuZXJhdGVkIHdpdGggbWV0aG9kcyBvciBub3QuXHJcblx0XHQgKlxyXG5cdFx0ICogQHR5cGUge0Jvb2xlYW59XHJcblx0XHQgKiBAZGVmYXVsdCBmYWxzZVxyXG5cdFx0ICovXHJcblx0XHR0aGlzLnVzZUNvbXBhcmlzb25NZXRob2QgPSBmYWxzZTtcclxuXHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBSZXR1cm5zIHRoZSBiaW5kIGdyb3VwcyBvZiB0aGUgY3VycmVudCByZW5kZXJlci5cclxuXHQgKlxyXG5cdCAqIEByZXR1cm4ge0NoYWluTWFwfSBUaGUgY2FjaGUuXHJcblx0ICovXHJcblx0Z2V0QmluZEdyb3Vwc0NhY2hlKCkge1xyXG5cclxuXHRcdGxldCBiaW5kR3JvdXBzQ2FjaGUgPSByZW5kZXJlckNhY2hlLmdldCggdGhpcy5yZW5kZXJlciApO1xyXG5cclxuXHRcdGlmICggYmluZEdyb3Vwc0NhY2hlID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRiaW5kR3JvdXBzQ2FjaGUgPSBuZXcgQ2hhaW5NYXAoKTtcclxuXHJcblx0XHRcdHJlbmRlcmVyQ2FjaGUuc2V0KCB0aGlzLnJlbmRlcmVyLCBiaW5kR3JvdXBzQ2FjaGUgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGJpbmRHcm91cHNDYWNoZTtcclxuXHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBGYWN0b3J5IG1ldGhvZCBmb3IgY3JlYXRpbmcgYW4gaW5zdGFuY2Ugb2Yge0BsaW5rIFJlbmRlclRhcmdldH0gd2l0aCB0aGUgZ2l2ZW5cclxuXHQgKiBkaW1lbnNpb25zIGFuZCBvcHRpb25zLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHdpZHRoIC0gVGhlIHdpZHRoIG9mIHRoZSByZW5kZXIgdGFyZ2V0LlxyXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBoZWlnaHQgLSBUaGUgaGVpZ2h0IG9mIHRoZSByZW5kZXIgdGFyZ2V0LlxyXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gVGhlIG9wdGlvbnMgb2YgdGhlIHJlbmRlciB0YXJnZXQuXHJcblx0ICogQHJldHVybiB7UmVuZGVyVGFyZ2V0fSBUaGUgcmVuZGVyIHRhcmdldC5cclxuXHQgKi9cclxuXHRjcmVhdGVSZW5kZXJUYXJnZXQoIHdpZHRoLCBoZWlnaHQsIG9wdGlvbnMgKSB7XHJcblxyXG5cdFx0cmV0dXJuIG5ldyBSZW5kZXJUYXJnZXQoIHdpZHRoLCBoZWlnaHQsIG9wdGlvbnMgKTtcclxuXHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBGYWN0b3J5IG1ldGhvZCBmb3IgY3JlYXRpbmcgYW4gaW5zdGFuY2Ugb2Yge0BsaW5rIEN1YmVSZW5kZXJUYXJnZXR9IHdpdGggdGhlIGdpdmVuXHJcblx0ICogZGltZW5zaW9ucyBhbmQgb3B0aW9ucy5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBzaXplIC0gVGhlIHNpemUgb2YgdGhlIGN1YmUgcmVuZGVyIHRhcmdldC5cclxuXHQgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIFRoZSBvcHRpb25zIG9mIHRoZSBjdWJlIHJlbmRlciB0YXJnZXQuXHJcblx0ICogQHJldHVybiB7Q3ViZVJlbmRlclRhcmdldH0gVGhlIGN1YmUgcmVuZGVyIHRhcmdldC5cclxuXHQgKi9cclxuXHRjcmVhdGVDdWJlUmVuZGVyVGFyZ2V0KCBzaXplLCBvcHRpb25zICkge1xyXG5cclxuXHRcdHJldHVybiBuZXcgQ3ViZVJlbmRlclRhcmdldCggc2l6ZSwgb3B0aW9ucyApO1xyXG5cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEZhY3RvcnkgbWV0aG9kIGZvciBjcmVhdGluZyBhbiBpbnN0YW5jZSBvZiB7QGxpbmsgUE1SRU1HZW5lcmF0b3J9LlxyXG5cdCAqXHJcblx0ICogQHJldHVybiB7UE1SRU1HZW5lcmF0b3J9IFRoZSBQTVJFTSBnZW5lcmF0b3IuXHJcblx0ICovXHJcblx0Y3JlYXRlUE1SRU1HZW5lcmF0b3IoKSB7XHJcblxyXG5cdFx0Ly8gVE9ETzogTW92ZSBNYXRlcmlhbHMuanMgdG8gb3V0c2lkZSBvZiB0aGUgTm9kZXMuanMgaW4gb3JkZXIgdG8gcmVtb3ZlIHRoaXMgZnVuY3Rpb24gYW5kIGltcHJvdmUgdHJlZS1zaGFraW5nIHN1cHBvcnRcclxuXHJcblx0XHRyZXR1cm4gbmV3IFBNUkVNR2VuZXJhdG9yKCB0aGlzLnJlbmRlcmVyICk7XHJcblxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogV2hldGhlciB0aGUgZ2l2ZW4gbm9kZSBpcyBpbmNsdWRlZCBpbiB0aGUgaW50ZXJuYWwgYXJyYXkgb2Ygbm9kZXMgb3Igbm90LlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtOb2RlfSBub2RlIC0gVGhlIG5vZGUgdG8gdGVzdC5cclxuXHQgKiBAcmV0dXJuIHtCb29sZWFufSBXaGV0aGVyIHRoZSBnaXZlbiBub2RlIGlzIGluY2x1ZGVkIGluIHRoZSBpbnRlcm5hbCBhcnJheSBvZiBub2RlcyBvciBub3QuXHJcblx0ICovXHJcblx0aW5jbHVkZXMoIG5vZGUgKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMubm9kZXMuaW5jbHVkZXMoIG5vZGUgKTtcclxuXHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBSZXR1cm5zIGEgYmluZCBncm91cCBmb3IgdGhlIGdpdmVuIGdyb3VwIG5hbWUgYW5kIGJpbmRpbmcuXHJcblx0ICpcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBncm91cE5hbWUgLSBUaGUgZ3JvdXAgbmFtZS5cclxuXHQgKiBAcGFyYW0ge0FycmF5PE5vZGVVbmlmb3Jtc0dyb3VwPn0gYmluZGluZ3MgLSBMaXN0IG9mIGJpbmRpbmdzLlxyXG5cdCAqIEByZXR1cm4ge0JpbmRHcm91cH0gVGhlIGJpbmQgZ3JvdXBcclxuXHQgKi9cclxuXHRfZ2V0QmluZEdyb3VwKCBncm91cE5hbWUsIGJpbmRpbmdzICkge1xyXG5cclxuXHRcdGNvbnN0IGJpbmRHcm91cHNDYWNoZSA9IHRoaXMuZ2V0QmluZEdyb3Vwc0NhY2hlKCk7XHJcblxyXG5cdFx0Ly9cclxuXHJcblx0XHRjb25zdCBiaW5kaW5nc0FycmF5ID0gW107XHJcblxyXG5cdFx0bGV0IHNoYXJlZEdyb3VwID0gdHJ1ZTtcclxuXHJcblx0XHRmb3IgKCBjb25zdCBiaW5kaW5nIG9mIGJpbmRpbmdzICkge1xyXG5cclxuXHRcdFx0YmluZGluZ3NBcnJheS5wdXNoKCBiaW5kaW5nICk7XHJcblxyXG5cdFx0XHRzaGFyZWRHcm91cCA9IHNoYXJlZEdyb3VwICYmIGJpbmRpbmcuZ3JvdXBOb2RlLnNoYXJlZCAhPT0gdHJ1ZTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly9cclxuXHJcblx0XHRsZXQgYmluZEdyb3VwO1xyXG5cclxuXHRcdGlmICggc2hhcmVkR3JvdXAgKSB7XHJcblxyXG5cdFx0XHRiaW5kR3JvdXAgPSBiaW5kR3JvdXBzQ2FjaGUuZ2V0KCBiaW5kaW5nc0FycmF5ICk7XHJcblxyXG5cdFx0XHRpZiAoIGJpbmRHcm91cCA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRiaW5kR3JvdXAgPSBuZXcgQmluZEdyb3VwKCBncm91cE5hbWUsIGJpbmRpbmdzQXJyYXksIHRoaXMuYmluZGluZ3NJbmRleGVzWyBncm91cE5hbWUgXS5ncm91cCwgYmluZGluZ3NBcnJheSApO1xyXG5cclxuXHRcdFx0XHRiaW5kR3JvdXBzQ2FjaGUuc2V0KCBiaW5kaW5nc0FycmF5LCBiaW5kR3JvdXAgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0YmluZEdyb3VwID0gbmV3IEJpbmRHcm91cCggZ3JvdXBOYW1lLCBiaW5kaW5nc0FycmF5LCB0aGlzLmJpbmRpbmdzSW5kZXhlc1sgZ3JvdXBOYW1lIF0uZ3JvdXAsIGJpbmRpbmdzQXJyYXkgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGJpbmRHcm91cDtcclxuXHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBSZXR1cm5zIGFuIGFycmF5IG9mIG5vZGUgdW5pZm9ybSBncm91cHMgZm9yIHRoZSBnaXZlbiBncm91cCBuYW1lIGFuZCBzaGFkZXIgc3RhZ2UuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge1N0cmluZ30gZ3JvdXBOYW1lIC0gVGhlIGdyb3VwIG5hbWUuXHJcblx0ICogQHBhcmFtIHsoJ3ZlcnRleCd8J2ZyYWdtZW50J3wnY29tcHV0ZSd8J2FueScpfSBzaGFkZXJTdGFnZSAtIFRoZSBzaGFkZXIgc3RhZ2UuXHJcblx0ICogQHJldHVybiB7QXJyYXk8Tm9kZVVuaWZvcm1zR3JvdXA+fSBUaGUgYXJyYXkgb2Ygbm9kZSB1bmlmb3JtIGdyb3Vwcy5cclxuXHQgKi9cclxuXHRnZXRCaW5kR3JvdXBBcnJheSggZ3JvdXBOYW1lLCBzaGFkZXJTdGFnZSApIHtcclxuXHJcblx0XHRjb25zdCBiaW5kaW5ncyA9IHRoaXMuYmluZGluZ3NbIHNoYWRlclN0YWdlIF07XHJcblxyXG5cdFx0bGV0IGJpbmRHcm91cCA9IGJpbmRpbmdzWyBncm91cE5hbWUgXTtcclxuXHJcblx0XHRpZiAoIGJpbmRHcm91cCA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0aWYgKCB0aGlzLmJpbmRpbmdzSW5kZXhlc1sgZ3JvdXBOYW1lIF0gPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0dGhpcy5iaW5kaW5nc0luZGV4ZXNbIGdyb3VwTmFtZSBdID0geyBiaW5kaW5nOiAwLCBncm91cDogT2JqZWN0LmtleXMoIHRoaXMuYmluZGluZ3NJbmRleGVzICkubGVuZ3RoIH07XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRiaW5kaW5nc1sgZ3JvdXBOYW1lIF0gPSBiaW5kR3JvdXAgPSBbXTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGJpbmRHcm91cDtcclxuXHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBSZXR1cm5zIGEgbGlzdCBiaW5kaW5ncyBvZiBhbGwgc2hhZGVyIHN0YWdlcyBzZXBhcmF0ZWQgYnkgZ3JvdXBzLlxyXG5cdCAqXHJcblx0ICogQHJldHVybiB7QXJyYXk8QmluZEdyb3VwPn0gVGhlIGxpc3Qgb2YgYmluZGluZ3MuXHJcblx0ICovXHJcblx0Z2V0QmluZGluZ3MoKSB7XHJcblxyXG5cdFx0bGV0IGJpbmRpbmdzR3JvdXBzID0gdGhpcy5iaW5kR3JvdXBzO1xyXG5cclxuXHRcdGlmICggYmluZGluZ3NHcm91cHMgPT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHRjb25zdCBncm91cHMgPSB7fTtcclxuXHRcdFx0Y29uc3QgYmluZGluZ3MgPSB0aGlzLmJpbmRpbmdzO1xyXG5cclxuXHRcdFx0Zm9yICggY29uc3Qgc2hhZGVyU3RhZ2Ugb2Ygc2hhZGVyU3RhZ2VzICkge1xyXG5cclxuXHRcdFx0XHRmb3IgKCBjb25zdCBncm91cE5hbWUgaW4gYmluZGluZ3NbIHNoYWRlclN0YWdlIF0gKSB7XHJcblxyXG5cdFx0XHRcdFx0Y29uc3QgdW5pZm9ybXMgPSBiaW5kaW5nc1sgc2hhZGVyU3RhZ2UgXVsgZ3JvdXBOYW1lIF07XHJcblxyXG5cdFx0XHRcdFx0Y29uc3QgZ3JvdXBVbmlmb3JtcyA9IGdyb3Vwc1sgZ3JvdXBOYW1lIF0gfHwgKCBncm91cHNbIGdyb3VwTmFtZSBdID0gW10gKTtcclxuXHRcdFx0XHRcdGdyb3VwVW5pZm9ybXMucHVzaCggLi4udW5pZm9ybXMgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0YmluZGluZ3NHcm91cHMgPSBbXTtcclxuXHJcblx0XHRcdGZvciAoIGNvbnN0IGdyb3VwTmFtZSBpbiBncm91cHMgKSB7XHJcblxyXG5cdFx0XHRcdGNvbnN0IGdyb3VwID0gZ3JvdXBzWyBncm91cE5hbWUgXTtcclxuXHJcblx0XHRcdFx0Y29uc3QgYmluZGluZ3NHcm91cCA9IHRoaXMuX2dldEJpbmRHcm91cCggZ3JvdXBOYW1lLCBncm91cCApO1xyXG5cclxuXHRcdFx0XHRiaW5kaW5nc0dyb3Vwcy5wdXNoKCBiaW5kaW5nc0dyb3VwICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR0aGlzLmJpbmRHcm91cHMgPSBiaW5kaW5nc0dyb3VwcztcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGJpbmRpbmdzR3JvdXBzO1xyXG5cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFNvcnRzIHRoZSBiaW5kIGdyb3VwcyBhbmQgdXBkYXRlcyB7QGxpbmsgTm9kZUJ1aWxkZXIjYmluZGluZ3NJbmRleGVzfS5cclxuXHQgKi9cclxuXHRzb3J0QmluZGluZ0dyb3VwcygpIHtcclxuXHJcblx0XHRjb25zdCBiaW5kaW5nc0dyb3VwcyA9IHRoaXMuZ2V0QmluZGluZ3MoKTtcclxuXHJcblx0XHRiaW5kaW5nc0dyb3Vwcy5zb3J0KCAoIGEsIGIgKSA9PiAoIGEuYmluZGluZ3NbIDAgXS5ncm91cE5vZGUub3JkZXIgLSBiLmJpbmRpbmdzWyAwIF0uZ3JvdXBOb2RlLm9yZGVyICkgKTtcclxuXHJcblx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCBiaW5kaW5nc0dyb3Vwcy5sZW5ndGg7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRjb25zdCBiaW5kaW5nR3JvdXAgPSBiaW5kaW5nc0dyb3Vwc1sgaSBdO1xyXG5cdFx0XHR0aGlzLmJpbmRpbmdzSW5kZXhlc1sgYmluZGluZ0dyb3VwLm5hbWUgXS5ncm91cCA9IGk7XHJcblxyXG5cdFx0XHRiaW5kaW5nR3JvdXAuaW5kZXggPSBpO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBUaGUgYnVpbGRlciBtYWludGFpbnMgZWFjaCBub2RlIGluIGEgaGFzaC1iYXNlZCBkaWN0aW9uYXJ5LlxyXG5cdCAqIFRoaXMgbWV0aG9kIHNldHMgdGhlIGdpdmVuIG5vZGUgKHZhbHVlKSB3aXRoIHRoZSBnaXZlbiBoYXNoIChrZXkpIGludG8gdGhpcyBkaWN0aW9uYXJ5LlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtOb2RlfSBub2RlIC0gVGhlIG5vZGUgdG8gYWRkLlxyXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBoYXNoIC0gVGhlIGhhc2ggb2YgdGhlIG5vZGUuXHJcblx0ICovXHJcblx0c2V0SGFzaE5vZGUoIG5vZGUsIGhhc2ggKSB7XHJcblxyXG5cdFx0dGhpcy5oYXNoTm9kZXNbIGhhc2ggXSA9IG5vZGU7XHJcblxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogQWRkcyBhIG5vZGUgdG8gdGhpcyBidWlsZGVyLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtOb2RlfSBub2RlIC0gVGhlIG5vZGUgdG8gYWRkLlxyXG5cdCAqL1xyXG5cdGFkZE5vZGUoIG5vZGUgKSB7XHJcblxyXG5cdFx0aWYgKCB0aGlzLm5vZGVzLmluY2x1ZGVzKCBub2RlICkgPT09IGZhbHNlICkge1xyXG5cclxuXHRcdFx0dGhpcy5ub2Rlcy5wdXNoKCBub2RlICk7XHJcblxyXG5cdFx0XHR0aGlzLnNldEhhc2hOb2RlKCBub2RlLCBub2RlLmdldEhhc2goIHRoaXMgKSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBJdCBpcyB1c2VkIHRvIGFkZCBOb2RlcyB0aGF0IHdpbGwgYmUgdXNlZCBhcyBGUkFNRSBhbmQgUkVOREVSIGV2ZW50cyxcclxuXHQgKiBhbmQgbmVlZCB0byBmb2xsb3cgYSBjZXJ0YWluIHNlcXVlbmNlIGluIHRoZSBjYWxscyB0byB3b3JrIGNvcnJlY3RseS5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7Tm9kZX0gbm9kZSAtIFRoZSBub2RlIHRvIGFkZC5cclxuXHQgKi9cclxuXHRhZGRTZXF1ZW50aWFsTm9kZSggbm9kZSApIHtcclxuXHJcblx0XHRpZiAoIHRoaXMuc2VxdWVudGlhbE5vZGVzLmluY2x1ZGVzKCBub2RlICkgPT09IGZhbHNlICkge1xyXG5cclxuXHRcdFx0dGhpcy5zZXF1ZW50aWFsTm9kZXMucHVzaCggbm9kZSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBDaGVja3MgdGhlIHVwZGF0ZSB0eXBlcyBvZiBub2Rlc1xyXG5cdCAqL1xyXG5cdGJ1aWxkVXBkYXRlTm9kZXMoKSB7XHJcblxyXG5cdFx0Zm9yICggY29uc3Qgbm9kZSBvZiB0aGlzLm5vZGVzICkge1xyXG5cclxuXHRcdFx0Y29uc3QgdXBkYXRlVHlwZSA9IG5vZGUuZ2V0VXBkYXRlVHlwZSgpO1xyXG5cclxuXHRcdFx0aWYgKCB1cGRhdGVUeXBlICE9PSBOb2RlVXBkYXRlVHlwZS5OT05FICkge1xyXG5cclxuXHRcdFx0XHR0aGlzLnVwZGF0ZU5vZGVzLnB1c2goIG5vZGUuZ2V0U2VsZigpICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGZvciAoIGNvbnN0IG5vZGUgb2YgdGhpcy5zZXF1ZW50aWFsTm9kZXMgKSB7XHJcblxyXG5cdFx0XHRjb25zdCB1cGRhdGVCZWZvcmVUeXBlID0gbm9kZS5nZXRVcGRhdGVCZWZvcmVUeXBlKCk7XHJcblx0XHRcdGNvbnN0IHVwZGF0ZUFmdGVyVHlwZSA9IG5vZGUuZ2V0VXBkYXRlQWZ0ZXJUeXBlKCk7XHJcblxyXG5cdFx0XHRpZiAoIHVwZGF0ZUJlZm9yZVR5cGUgIT09IE5vZGVVcGRhdGVUeXBlLk5PTkUgKSB7XHJcblxyXG5cdFx0XHRcdHRoaXMudXBkYXRlQmVmb3JlTm9kZXMucHVzaCggbm9kZS5nZXRTZWxmKCkgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICggdXBkYXRlQWZ0ZXJUeXBlICE9PSBOb2RlVXBkYXRlVHlwZS5OT05FICkge1xyXG5cclxuXHRcdFx0XHR0aGlzLnVwZGF0ZUFmdGVyTm9kZXMucHVzaCggbm9kZS5nZXRTZWxmKCkgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogQSByZWZlcmVuY2UgdGhlIGN1cnJlbnQgbm9kZSB3aGljaCBpcyB0aGVcclxuXHQgKiBsYXN0IG5vZGUgaW4gdGhlIGNoYWluIG9mIG5vZGVzLlxyXG5cdCAqXHJcblx0ICogQHR5cGUge05vZGV9XHJcblx0ICovXHJcblx0Z2V0IGN1cnJlbnROb2RlKCkge1xyXG5cclxuXHRcdHJldHVybiB0aGlzLmNoYWluaW5nWyB0aGlzLmNoYWluaW5nLmxlbmd0aCAtIDEgXTtcclxuXHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBXaGV0aGVyIHRoZSBnaXZlbiB0ZXh0dXJlIGlzIGZpbHRlcmVkIG9yIG5vdC5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7VGV4dHVyZX0gdGV4dHVyZSAtIFRoZSB0ZXh0dXJlIHRvIGNoZWNrLlxyXG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59IFdoZXRoZXIgdGhlIGdpdmVuIHRleHR1cmUgaXMgZmlsdGVyZWQgb3Igbm90LlxyXG5cdCAqL1xyXG5cdGlzRmlsdGVyZWRUZXh0dXJlKCB0ZXh0dXJlICkge1xyXG5cclxuXHRcdHJldHVybiAoIHRleHR1cmUubWFnRmlsdGVyID09PSBMaW5lYXJGaWx0ZXIgfHwgdGV4dHVyZS5tYWdGaWx0ZXIgPT09IExpbmVhck1pcG1hcE5lYXJlc3RGaWx0ZXIgfHwgdGV4dHVyZS5tYWdGaWx0ZXIgPT09IE5lYXJlc3RNaXBtYXBMaW5lYXJGaWx0ZXIgfHwgdGV4dHVyZS5tYWdGaWx0ZXIgPT09IExpbmVhck1pcG1hcExpbmVhckZpbHRlciB8fFxyXG5cdFx0XHR0ZXh0dXJlLm1pbkZpbHRlciA9PT0gTGluZWFyRmlsdGVyIHx8IHRleHR1cmUubWluRmlsdGVyID09PSBMaW5lYXJNaXBtYXBOZWFyZXN0RmlsdGVyIHx8IHRleHR1cmUubWluRmlsdGVyID09PSBOZWFyZXN0TWlwbWFwTGluZWFyRmlsdGVyIHx8IHRleHR1cmUubWluRmlsdGVyID09PSBMaW5lYXJNaXBtYXBMaW5lYXJGaWx0ZXIgKTtcclxuXHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBBZGRzIHRoZSBnaXZlbiBub2RlIHRvIHRoZSBpbnRlcm5hbCBub2RlIGNoYWluLlxyXG5cdCAqIFRoaXMgaXMgdXNlZCB0byBjaGVjayByZWN1cnNpdmUgY2FsbHMgaW4gbm9kZS1ncmFwaC5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7Tm9kZX0gbm9kZSAtIFRoZSBub2RlIHRvIGFkZC5cclxuXHQgKi9cclxuXHRhZGRDaGFpbiggbm9kZSApIHtcclxuXHJcblx0XHQvKlxyXG5cdFx0aWYgKCB0aGlzLmNoYWluaW5nLmluZGV4T2YoIG5vZGUgKSAhPT0gLSAxICkge1xyXG5cclxuXHRcdFx0Y29uc29sZS53YXJuKCAnUmVjdXJzaXZlIG5vZGU6ICcsIG5vZGUgKTtcclxuXHJcblx0XHR9XHJcblx0XHQqL1xyXG5cclxuXHRcdHRoaXMuY2hhaW5pbmcucHVzaCggbm9kZSApO1xyXG5cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFJlbW92ZXMgdGhlIGdpdmVuIG5vZGUgZnJvbSB0aGUgaW50ZXJuYWwgbm9kZSBjaGFpbi5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7Tm9kZX0gbm9kZSAtIFRoZSBub2RlIHRvIHJlbW92ZS5cclxuXHQgKi9cclxuXHRyZW1vdmVDaGFpbiggbm9kZSApIHtcclxuXHJcblx0XHRjb25zdCBsYXN0Q2hhaW4gPSB0aGlzLmNoYWluaW5nLnBvcCgpO1xyXG5cclxuXHRcdGlmICggbGFzdENoYWluICE9PSBub2RlICkge1xyXG5cclxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCAnTm9kZUJ1aWxkZXI6IEludmFsaWQgbm9kZSBjaGFpbmluZyEnICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFJldHVybnMgdGhlIG5hdGl2ZSBzaGFkZXIgbWV0aG9kIG5hbWUgZm9yIGEgZ2l2ZW4gZ2VuZXJpYyBuYW1lLiBFLmcuXHJcblx0ICogdGhlIG1ldGhvZCBuYW1lIGB0ZXh0dXJlRGltZW5zaW9uc2AgbWF0Y2hlcyB0aGUgV0dTTCBuYW1lIGJ1dCBtdXN0IGJlXHJcblx0ICogcmVzb2x2ZWQgdG8gYHRleHR1cmVTaXplYCBpbiBHTFNMLlxyXG5cdCAqXHJcblx0ICogQGFic3RyYWN0XHJcblx0ICogQHBhcmFtIHtTdHJpbmd9IG1ldGhvZCAtIFRoZSBtZXRob2QgbmFtZSB0byByZXNvbHZlLlxyXG5cdCAqIEByZXR1cm4ge1N0cmluZ30gVGhlIHJlc29sdmVkIG1ldGhvZCBuYW1lLlxyXG5cdCAqL1xyXG5cdGdldE1ldGhvZCggbWV0aG9kICkge1xyXG5cclxuXHRcdHJldHVybiBtZXRob2Q7XHJcblxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogUmV0dXJucyBhIG5vZGUgZm9yIHRoZSBnaXZlbiBoYXNoLCBzZWUge0BsaW5rIE5vZGVCdWlsZGVyI3NldEhhc2hOb2RlfS5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBoYXNoIC0gVGhlIGhhc2ggb2YgdGhlIG5vZGUuXHJcblx0ICogQHJldHVybiB7Tm9kZX0gVGhlIGZvdW5kIG5vZGUuXHJcblx0ICovXHJcblx0Z2V0Tm9kZUZyb21IYXNoKCBoYXNoICkge1xyXG5cclxuXHRcdHJldHVybiB0aGlzLmhhc2hOb2Rlc1sgaGFzaCBdO1xyXG5cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEFkZHMgdGhlIE5vZGUgdG8gYSB0YXJnZXQgZmxvdyBzbyB0aGF0IGl0IGNhbiBnZW5lcmF0ZSBjb2RlIGluIHRoZSAnZ2VuZXJhdGUnIHByb2Nlc3MuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0geygndmVydGV4J3wnZnJhZ21lbnQnfCdjb21wdXRlJyl9IHNoYWRlclN0YWdlIC0gVGhlIHNoYWRlciBzdGFnZS5cclxuXHQgKiBAcGFyYW0ge05vZGV9IG5vZGUgLSBUaGUgbm9kZSB0byBhZGQuXHJcblx0ICogQHJldHVybiB7Tm9kZX0gVGhlIG5vZGUuXHJcblx0ICovXHJcblx0YWRkRmxvdyggc2hhZGVyU3RhZ2UsIG5vZGUgKSB7XHJcblxyXG5cdFx0dGhpcy5mbG93Tm9kZXNbIHNoYWRlclN0YWdlIF0ucHVzaCggbm9kZSApO1xyXG5cclxuXHRcdHJldHVybiBub2RlO1xyXG5cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFNldHMgYnVpbGRlcidzIGNvbnRleHQuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge09iamVjdH0gY29udGV4dCAtIFRoZSBjb250ZXh0IHRvIHNldC5cclxuXHQgKi9cclxuXHRzZXRDb250ZXh0KCBjb250ZXh0ICkge1xyXG5cclxuXHRcdHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XHJcblxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogUmV0dXJucyB0aGUgYnVpbGRlcidzIGN1cnJlbnQgY29udGV4dC5cclxuXHQgKlxyXG5cdCAqIEByZXR1cm4ge09iamVjdH0gVGhlIGJ1aWxkZXIncyBjdXJyZW50IGNvbnRleHQuXHJcblx0ICovXHJcblx0Z2V0Q29udGV4dCgpIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5jb250ZXh0O1xyXG5cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldHMgYSBjb250ZXh0IHVzZWQgaW4gc2hhZGVyIGNvbnN0cnVjdGlvbiB0aGF0IGNhbiBiZSBzaGFyZWQgYWNyb3NzIGRpZmZlcmVudCBtYXRlcmlhbHMuXHJcblx0ICogVGhpcyBpcyBuZWNlc3Nhcnkgc2luY2UgdGhlIHJlbmRlcmVyIGNhY2hlIGNhbiByZXVzZSBzaGFkZXJzIGdlbmVyYXRlZCBpbiBvbmUgbWF0ZXJpYWwgYW5kIHVzZSB0aGVtIGluIGFub3RoZXIuXHJcblx0ICpcclxuXHQgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBidWlsZGVyJ3MgY3VycmVudCBjb250ZXh0IHdpdGhvdXQgbWF0ZXJpYWwuXHJcblx0ICovXHJcblx0Z2V0U2hhcmVkQ29udGV4dCgpIHtcclxuXHJcblx0XHRjb25zdCBjb250ZXh0ID0geyAuLi50aGlzLmNvbnRleHQgfTtcclxuXHJcblx0XHRkZWxldGUgY29udGV4dC5tYXRlcmlhbDtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5jb250ZXh0O1xyXG5cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFNldHMgYnVpbGRlcidzIGNhY2hlLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtOb2RlQ2FjaGV9IGNhY2hlIC0gVGhlIGNhY2hlIHRvIHNldC5cclxuXHQgKi9cclxuXHRzZXRDYWNoZSggY2FjaGUgKSB7XHJcblxyXG5cdFx0dGhpcy5jYWNoZSA9IGNhY2hlO1xyXG5cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFJldHVybnMgdGhlIGJ1aWxkZXIncyBjdXJyZW50IGNhY2hlLlxyXG5cdCAqXHJcblx0ICogQHJldHVybiB7Tm9kZUNhY2hlfSBUaGUgYnVpbGRlcidzIGN1cnJlbnQgY2FjaGUuXHJcblx0ICovXHJcblx0Z2V0Q2FjaGUoKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuY2FjaGU7XHJcblxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogUmV0dXJucyBhIGNhY2hlIGZvciB0aGUgZ2l2ZW4gbm9kZS5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7Tm9kZX0gbm9kZSAtIFRoZSBub2RlLlxyXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gW3BhcmVudD10cnVlXSAtIFdoZXRoZXIgdGhpcyBub2RlIHJlZmVycyB0byBhIHNoYXJlZCBwYXJlbnQgY2FjaGUgb3Igbm90LlxyXG5cdCAqIEByZXR1cm4ge05vZGVDYWNoZX0gVGhlIGNhY2hlLlxyXG5cdCAqL1xyXG5cdGdldENhY2hlRnJvbU5vZGUoIG5vZGUsIHBhcmVudCA9IHRydWUgKSB7XHJcblxyXG5cdFx0Y29uc3QgZGF0YSA9IHRoaXMuZ2V0RGF0YUZyb21Ob2RlKCBub2RlICk7XHJcblx0XHRpZiAoIGRhdGEuY2FjaGUgPT09IHVuZGVmaW5lZCApIGRhdGEuY2FjaGUgPSBuZXcgTm9kZUNhY2hlKCBwYXJlbnQgPyB0aGlzLmdldENhY2hlKCkgOiBudWxsICk7XHJcblxyXG5cdFx0cmV0dXJuIGRhdGEuY2FjaGU7XHJcblxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogV2hldGhlciB0aGUgcmVxdWVzdGVkIGZlYXR1cmUgaXMgYXZhaWxhYmxlIG9yIG5vdC5cclxuXHQgKlxyXG5cdCAqIEBhYnN0cmFjdFxyXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIC0gVGhlIHJlcXVlc3RlZCBmZWF0dXJlLlxyXG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59IFdoZXRoZXIgdGhlIHJlcXVlc3RlZCBmZWF0dXJlIGlzIHN1cHBvcnRlZCBvciBub3QuXHJcblx0ICovXHJcblx0aXNBdmFpbGFibGUoIC8qbmFtZSovICkge1xyXG5cclxuXHRcdHJldHVybiBmYWxzZTtcclxuXHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBSZXR1cm5zIHRoZSB2ZXJ0ZXhJbmRleCBpbnB1dCB2YXJpYWJsZSBhcyBhIG5hdGl2ZSBzaGFkZXIgc3RyaW5nLlxyXG5cdCAqXHJcblx0ICogQGFic3RyYWN0XHJcblx0ICogQHJldHVybiB7U3RyaW5nfSBUaGUgaW5zdGFuY2VJbmRleCBzaGFkZXIgc3RyaW5nLlxyXG5cdCAqL1xyXG5cdGdldFZlcnRleEluZGV4KCkge1xyXG5cclxuXHRcdGNvbnNvbGUud2FybiggJ0Fic3RyYWN0IGZ1bmN0aW9uLicgKTtcclxuXHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBSZXR1cm5zIHRoZSBpbnN0YW5jZUluZGV4IGlucHV0IHZhcmlhYmxlIGFzIGEgbmF0aXZlIHNoYWRlciBzdHJpbmcuXHJcblx0ICpcclxuXHQgKiBAYWJzdHJhY3RcclxuXHQgKiBAcmV0dXJuIHtTdHJpbmd9IFRoZSBpbnN0YW5jZUluZGV4IHNoYWRlciBzdHJpbmcuXHJcblx0ICovXHJcblx0Z2V0SW5zdGFuY2VJbmRleCgpIHtcclxuXHJcblx0XHRjb25zb2xlLndhcm4oICdBYnN0cmFjdCBmdW5jdGlvbi4nICk7XHJcblxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogUmV0dXJucyB0aGUgZHJhd0luZGV4IGlucHV0IHZhcmlhYmxlIGFzIGEgbmF0aXZlIHNoYWRlciBzdHJpbmcuXHJcblx0ICogT25seSByZWxldmFudCBmb3IgV2ViR0wgYW5kIGl0cyBgV0VCR0xfbXVsdGlfZHJhd2AgZXh0ZW5zaW9uLlxyXG5cdCAqXHJcblx0ICogQGFic3RyYWN0XHJcblx0ICogQHJldHVybiB7U3RyaW5nfSBUaGUgZHJhd0luZGV4IHNoYWRlciBzdHJpbmcuXHJcblx0ICovXHJcblx0Z2V0RHJhd0luZGV4KCkge1xyXG5cclxuXHRcdGNvbnNvbGUud2FybiggJ0Fic3RyYWN0IGZ1bmN0aW9uLicgKTtcclxuXHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBSZXR1cm5zIHRoZSBmcm9udEZhY2luZyBpbnB1dCB2YXJpYWJsZSBhcyBhIG5hdGl2ZSBzaGFkZXIgc3RyaW5nLlxyXG5cdCAqXHJcblx0ICogQGFic3RyYWN0XHJcblx0ICogQHJldHVybiB7U3RyaW5nfSBUaGUgZnJvbnRGYWNpbmcgc2hhZGVyIHN0cmluZy5cclxuXHQgKi9cclxuXHRnZXRGcm9udEZhY2luZygpIHtcclxuXHJcblx0XHRjb25zb2xlLndhcm4oICdBYnN0cmFjdCBmdW5jdGlvbi4nICk7XHJcblxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogUmV0dXJucyB0aGUgZnJhZ0Nvb3JkIGlucHV0IHZhcmlhYmxlIGFzIGEgbmF0aXZlIHNoYWRlciBzdHJpbmcuXHJcblx0ICpcclxuXHQgKiBAYWJzdHJhY3RcclxuXHQgKiBAcmV0dXJuIHtTdHJpbmd9IFRoZSBmcmFnQ29vcmQgc2hhZGVyIHN0cmluZy5cclxuXHQgKi9cclxuXHRnZXRGcmFnQ29vcmQoKSB7XHJcblxyXG5cdFx0Y29uc29sZS53YXJuKCAnQWJzdHJhY3QgZnVuY3Rpb24uJyApO1xyXG5cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFdoZXRoZXIgdG8gZmxpcCB0ZXh0dXJlIGRhdGEgYWxvbmcgaXRzIHZlcnRpY2FsIGF4aXMgb3Igbm90LiBXZWJHTCBuZWVkc1xyXG5cdCAqIHRoaXMgbWV0aG9kIGV2YWx1YXRlIHRvIGB0cnVlYCwgV2ViR1BVIHRvIGBmYWxzZWAuXHJcblx0ICpcclxuXHQgKiBAYWJzdHJhY3RcclxuXHQgKiBAcmV0dXJuIHtCb29sZWFufSBXaGV0aGVyIHRvIGZsaXAgdGV4dHVyZSBkYXRhIGFsb25nIGl0cyB2ZXJ0aWNhbCBheGlzIG9yIG5vdC5cclxuXHQgKi9cclxuXHRpc0ZsaXBZKCkge1xyXG5cclxuXHRcdHJldHVybiBmYWxzZTtcclxuXHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBDYWxsaW5nIHRoaXMgbWV0aG9kIGluY3JlYXNlcyB0aGUgdXNhZ2UgY291bnQgZm9yIHRoZSBnaXZlbiBub2RlIGJ5IG9uZS5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7Tm9kZX0gbm9kZSAtIFRoZSBub2RlIHRvIGluY3JlYXNlIHRoZSB1c2FnZSBjb3VudCBmb3IuXHJcblx0ICogQHJldHVybiB7TnVtYmVyfSBUaGUgdXBkYXRlZCB1c2FnZSBjb3VudC5cclxuXHQgKi9cclxuXHRpbmNyZWFzZVVzYWdlKCBub2RlICkge1xyXG5cclxuXHRcdGNvbnN0IG5vZGVEYXRhID0gdGhpcy5nZXREYXRhRnJvbU5vZGUoIG5vZGUgKTtcclxuXHRcdG5vZGVEYXRhLnVzYWdlQ291bnQgPSBub2RlRGF0YS51c2FnZUNvdW50ID09PSB1bmRlZmluZWQgPyAxIDogbm9kZURhdGEudXNhZ2VDb3VudCArIDE7XHJcblxyXG5cdFx0cmV0dXJuIG5vZGVEYXRhLnVzYWdlQ291bnQ7XHJcblxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogR2VuZXJhdGVzIGEgdGV4dHVyZSBzYW1wbGUgc2hhZGVyIHN0cmluZyBmb3IgdGhlIGdpdmVuIHRleHR1cmUgZGF0YS5cclxuXHQgKlxyXG5cdCAqIEBhYnN0cmFjdFxyXG5cdCAqIEBwYXJhbSB7VGV4dHVyZX0gdGV4dHVyZSAtIFRoZSB0ZXh0dXJlLlxyXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSB0ZXh0dXJlUHJvcGVydHkgLSBUaGUgdGV4dHVyZSBwcm9wZXJ0eSBuYW1lLlxyXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSB1dlNuaXBwZXQgLSBTbmlwcGV0IGRlZmluaW5nIHRoZSB0ZXh0dXJlIGNvb3JkaW5hdGVzLlxyXG5cdCAqIEByZXR1cm4ge1N0cmluZ30gVGhlIGdlbmVyYXRlZCBzaGFkZXIgc3RyaW5nLlxyXG5cdCAqL1xyXG5cdGdlbmVyYXRlVGV4dHVyZSggLyogdGV4dHVyZSwgdGV4dHVyZVByb3BlcnR5LCB1dlNuaXBwZXQgKi8gKSB7XHJcblxyXG5cdFx0Y29uc29sZS53YXJuKCAnQWJzdHJhY3QgZnVuY3Rpb24uJyApO1xyXG5cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEdlbmVyYXRlcyBhIHRleHR1cmUgTE9EIHNoYWRlciBzdHJpbmcgZm9yIHRoZSBnaXZlbiB0ZXh0dXJlIGRhdGEuXHJcblx0ICpcclxuXHQgKiBAYWJzdHJhY3RcclxuXHQgKiBAcGFyYW0ge1RleHR1cmV9IHRleHR1cmUgLSBUaGUgdGV4dHVyZS5cclxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdGV4dHVyZVByb3BlcnR5IC0gVGhlIHRleHR1cmUgcHJvcGVydHkgbmFtZS5cclxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdXZTbmlwcGV0IC0gU25pcHBldCBkZWZpbmluZyB0aGUgdGV4dHVyZSBjb29yZGluYXRlcy5cclxuXHQgKiBAcGFyYW0ge1N0cmluZ30gbGV2ZWxTbmlwcGV0IC0gU25pcHBldCBkZWZpbmluZyB0aGUgbWlwIGxldmVsLlxyXG5cdCAqIEByZXR1cm4ge1N0cmluZ30gVGhlIGdlbmVyYXRlZCBzaGFkZXIgc3RyaW5nLlxyXG5cdCAqL1xyXG5cdGdlbmVyYXRlVGV4dHVyZUxvZCggLyogdGV4dHVyZSwgdGV4dHVyZVByb3BlcnR5LCB1dlNuaXBwZXQsIGxldmVsU25pcHBldCAqLyApIHtcclxuXHJcblx0XHRjb25zb2xlLndhcm4oICdBYnN0cmFjdCBmdW5jdGlvbi4nICk7XHJcblxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogR2VuZXJhdGVzIHRoZSBzaGFkZXIgc3RyaW5nIGZvciB0aGUgZ2l2ZW4gdHlwZSBhbmQgdmFsdWUuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSAtIFRoZSB0eXBlLlxyXG5cdCAqIEBwYXJhbSB7QW55P30gW3ZhbHVlPW51bGxdIC0gVGhlIHZhbHVlLlxyXG5cdCAqIEByZXR1cm4ge1N0cmluZ30gVGhlIGdlbmVyYXRlZCB2YWx1ZSBhcyBhIHNoYWRlciBzdHJpbmcuXHJcblx0ICovXHJcblx0Z2VuZXJhdGVDb25zdCggdHlwZSwgdmFsdWUgPSBudWxsICkge1xyXG5cclxuXHRcdGlmICggdmFsdWUgPT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHRpZiAoIHR5cGUgPT09ICdmbG9hdCcgfHwgdHlwZSA9PT0gJ2ludCcgfHwgdHlwZSA9PT0gJ3VpbnQnICkgdmFsdWUgPSAwO1xyXG5cdFx0XHRlbHNlIGlmICggdHlwZSA9PT0gJ2Jvb2wnICkgdmFsdWUgPSBmYWxzZTtcclxuXHRcdFx0ZWxzZSBpZiAoIHR5cGUgPT09ICdjb2xvcicgKSB2YWx1ZSA9IG5ldyBDb2xvcigpO1xyXG5cdFx0XHRlbHNlIGlmICggdHlwZSA9PT0gJ3ZlYzInICkgdmFsdWUgPSBuZXcgVmVjdG9yMigpO1xyXG5cdFx0XHRlbHNlIGlmICggdHlwZSA9PT0gJ3ZlYzMnICkgdmFsdWUgPSBuZXcgVmVjdG9yMygpO1xyXG5cdFx0XHRlbHNlIGlmICggdHlwZSA9PT0gJ3ZlYzQnICkgdmFsdWUgPSBuZXcgVmVjdG9yNCgpO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIHR5cGUgPT09ICdmbG9hdCcgKSByZXR1cm4gdG9GbG9hdCggdmFsdWUgKTtcclxuXHRcdGlmICggdHlwZSA9PT0gJ2ludCcgKSByZXR1cm4gYCR7IE1hdGgucm91bmQoIHZhbHVlICkgfWA7XHJcblx0XHRpZiAoIHR5cGUgPT09ICd1aW50JyApIHJldHVybiB2YWx1ZSA+PSAwID8gYCR7IE1hdGgucm91bmQoIHZhbHVlICkgfXVgIDogJzB1JztcclxuXHRcdGlmICggdHlwZSA9PT0gJ2Jvb2wnICkgcmV0dXJuIHZhbHVlID8gJ3RydWUnIDogJ2ZhbHNlJztcclxuXHRcdGlmICggdHlwZSA9PT0gJ2NvbG9yJyApIHJldHVybiBgJHsgdGhpcy5nZXRUeXBlKCAndmVjMycgKSB9KCAkeyB0b0Zsb2F0KCB2YWx1ZS5yICkgfSwgJHsgdG9GbG9hdCggdmFsdWUuZyApIH0sICR7IHRvRmxvYXQoIHZhbHVlLmIgKSB9IClgO1xyXG5cclxuXHRcdGNvbnN0IHR5cGVMZW5ndGggPSB0aGlzLmdldFR5cGVMZW5ndGgoIHR5cGUgKTtcclxuXHJcblx0XHRjb25zdCBjb21wb25lbnRUeXBlID0gdGhpcy5nZXRDb21wb25lbnRUeXBlKCB0eXBlICk7XHJcblxyXG5cdFx0Y29uc3QgZ2VuZXJhdGVDb25zdCA9IHZhbHVlID0+IHRoaXMuZ2VuZXJhdGVDb25zdCggY29tcG9uZW50VHlwZSwgdmFsdWUgKTtcclxuXHJcblx0XHRpZiAoIHR5cGVMZW5ndGggPT09IDIgKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gYCR7IHRoaXMuZ2V0VHlwZSggdHlwZSApIH0oICR7IGdlbmVyYXRlQ29uc3QoIHZhbHVlLnggKSB9LCAkeyBnZW5lcmF0ZUNvbnN0KCB2YWx1ZS55ICkgfSApYDtcclxuXHJcblx0XHR9IGVsc2UgaWYgKCB0eXBlTGVuZ3RoID09PSAzICkge1xyXG5cclxuXHRcdFx0cmV0dXJuIGAkeyB0aGlzLmdldFR5cGUoIHR5cGUgKSB9KCAkeyBnZW5lcmF0ZUNvbnN0KCB2YWx1ZS54ICkgfSwgJHsgZ2VuZXJhdGVDb25zdCggdmFsdWUueSApIH0sICR7IGdlbmVyYXRlQ29uc3QoIHZhbHVlLnogKSB9IClgO1xyXG5cclxuXHRcdH0gZWxzZSBpZiAoIHR5cGVMZW5ndGggPT09IDQgKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gYCR7IHRoaXMuZ2V0VHlwZSggdHlwZSApIH0oICR7IGdlbmVyYXRlQ29uc3QoIHZhbHVlLnggKSB9LCAkeyBnZW5lcmF0ZUNvbnN0KCB2YWx1ZS55ICkgfSwgJHsgZ2VuZXJhdGVDb25zdCggdmFsdWUueiApIH0sICR7IGdlbmVyYXRlQ29uc3QoIHZhbHVlLncgKSB9IClgO1xyXG5cclxuXHRcdH0gZWxzZSBpZiAoIHR5cGVMZW5ndGggPiA0ICYmIHZhbHVlICYmICggdmFsdWUuaXNNYXRyaXgzIHx8IHZhbHVlLmlzTWF0cml4NCApICkge1xyXG5cclxuXHRcdFx0cmV0dXJuIGAkeyB0aGlzLmdldFR5cGUoIHR5cGUgKSB9KCAkeyB2YWx1ZS5lbGVtZW50cy5tYXAoIGdlbmVyYXRlQ29uc3QgKS5qb2luKCAnLCAnICkgfSApYDtcclxuXHJcblx0XHR9IGVsc2UgaWYgKCB0eXBlTGVuZ3RoID4gNCApIHtcclxuXHJcblx0XHRcdHJldHVybiBgJHsgdGhpcy5nZXRUeXBlKCB0eXBlICkgfSgpYDtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dGhyb3cgbmV3IEVycm9yKCBgTm9kZUJ1aWxkZXI6IFR5cGUgJyR7dHlwZX0nIG5vdCBmb3VuZCBpbiBnZW5lcmF0ZSBjb25zdGFudCBhdHRlbXB0LmAgKTtcclxuXHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBJdCBtaWdodCBiZSBuZWNlc3NhcnkgdG8gY29udmVydCBjZXJ0YWluIGRhdGEgdHlwZXMgdG8gZGlmZmVyZW50IG9uZXNcclxuXHQgKiBzbyB0aGlzIG1ldGhvZCBjYW4gYmUgdXNlZCB0byBoaWRlIHRoZSBjb252ZXJzaW9uLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgLSBUaGUgdHlwZS5cclxuXHQgKiBAcmV0dXJuIHtTdHJpbmd9IFRoZSB1cGRhdGVkIHR5cGUuXHJcblx0ICovXHJcblx0Z2V0VHlwZSggdHlwZSApIHtcclxuXHJcblx0XHRpZiAoIHR5cGUgPT09ICdjb2xvcicgKSByZXR1cm4gJ3ZlYzMnO1xyXG5cclxuXHRcdHJldHVybiB0eXBlO1xyXG5cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFdoZXRoZXIgdGhlIGdpdmVuIGF0dHJpYnV0ZSBuYW1lIGlzIGRlZmluZWQgaW4gdGhlIGdlb21ldHJ5IG9yIG5vdC5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIC0gVGhlIGF0dHJpYnV0ZSBuYW1lLlxyXG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59IFdoZXRoZXIgdGhlIGdpdmVuIGF0dHJpYnV0ZSBuYW1lIGlzIGRlZmluZWQgaW4gdGhlIGdlb21ldHJ5LlxyXG5cdCAqL1xyXG5cdGhhc0dlb21ldHJ5QXR0cmlidXRlKCBuYW1lICkge1xyXG5cclxuXHRcdHJldHVybiB0aGlzLmdlb21ldHJ5ICYmIHRoaXMuZ2VvbWV0cnkuZ2V0QXR0cmlidXRlKCBuYW1lICkgIT09IHVuZGVmaW5lZDtcclxuXHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBSZXR1cm5zIGEgbm9kZSBhdHRyaWJ1dGUgZm9yIHRoZSBnaXZlbiBuYW1lIGFuZCB0eXBlLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgLSBUaGUgYXR0cmlidXRlJ3MgbmFtZS5cclxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSAtIFRoZSBhdHRyaWJ1dGUncyB0eXBlLlxyXG5cdCAqIEByZXR1cm4ge05vZGVBdHRyaWJ1dGV9IFRoZSBub2RlIGF0dHJpYnV0ZS5cclxuXHQgKi9cclxuXHRnZXRBdHRyaWJ1dGUoIG5hbWUsIHR5cGUgKSB7XHJcblxyXG5cdFx0Y29uc3QgYXR0cmlidXRlcyA9IHRoaXMuYXR0cmlidXRlcztcclxuXHJcblx0XHQvLyBmaW5kIGF0dHJpYnV0ZVxyXG5cclxuXHRcdGZvciAoIGNvbnN0IGF0dHJpYnV0ZSBvZiBhdHRyaWJ1dGVzICkge1xyXG5cclxuXHRcdFx0aWYgKCBhdHRyaWJ1dGUubmFtZSA9PT0gbmFtZSApIHtcclxuXHJcblx0XHRcdFx0cmV0dXJuIGF0dHJpYnV0ZTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gY3JlYXRlIGEgbmV3IGlmIG5vIGV4aXN0XHJcblxyXG5cdFx0Y29uc3QgYXR0cmlidXRlID0gbmV3IE5vZGVBdHRyaWJ1dGUoIG5hbWUsIHR5cGUgKTtcclxuXHJcblx0XHRhdHRyaWJ1dGVzLnB1c2goIGF0dHJpYnV0ZSApO1xyXG5cclxuXHRcdHJldHVybiBhdHRyaWJ1dGU7XHJcblxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogUmV0dXJucyBmb3IgdGhlIGdpdmVuIG5vZGUgYW5kIHNoYWRlciBzdGFnZSB0aGUgcHJvcGVydHkgbmFtZSBmb3IgdGhlIHNoYWRlci5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7Tm9kZX0gbm9kZSAtIFRoZSBub2RlLlxyXG5cdCAqIEBwYXJhbSB7KCd2ZXJ0ZXgnfCdmcmFnbWVudCd8J2NvbXB1dGUnfCdhbnknKX0gc2hhZGVyU3RhZ2UgLSBUaGUgc2hhZGVyIHN0YWdlLlxyXG5cdCAqIEByZXR1cm4ge1N0cmluZ30gVGhlIHByb3BlcnR5IG5hbWUuXHJcblx0ICovXHJcblx0Z2V0UHJvcGVydHlOYW1lKCBub2RlLyosIHNoYWRlclN0YWdlKi8gKSB7XHJcblxyXG5cdFx0cmV0dXJuIG5vZGUubmFtZTtcclxuXHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBXaGV0aGVyIHRoZSBnaXZlbiB0eXBlIGlzIGEgdmVjdG9yIHR5cGUgb3Igbm90LlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgLSBUaGUgdHlwZSB0byBjaGVjay5cclxuXHQgKiBAcmV0dXJuIHtCb29sZWFufSBXaGV0aGVyIHRoZSBnaXZlbiB0eXBlIGlzIGEgdmVjdG9yIHR5cGUgb3Igbm90LlxyXG5cdCAqL1xyXG5cdGlzVmVjdG9yKCB0eXBlICkge1xyXG5cclxuXHRcdHJldHVybiAvdmVjXFxkLy50ZXN0KCB0eXBlICk7XHJcblxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogV2hldGhlciB0aGUgZ2l2ZW4gdHlwZSBpcyBhIG1hdHJpeCB0eXBlIG9yIG5vdC5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIC0gVGhlIHR5cGUgdG8gY2hlY2suXHJcblx0ICogQHJldHVybiB7Qm9vbGVhbn0gV2hldGhlciB0aGUgZ2l2ZW4gdHlwZSBpcyBhIG1hdHJpeCB0eXBlIG9yIG5vdC5cclxuXHQgKi9cclxuXHRpc01hdHJpeCggdHlwZSApIHtcclxuXHJcblx0XHRyZXR1cm4gL21hdFxcZC8udGVzdCggdHlwZSApO1xyXG5cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFdoZXRoZXIgdGhlIGdpdmVuIHR5cGUgaXMgYSByZWZlcmVuY2UgdHlwZSBvciBub3QuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSAtIFRoZSB0eXBlIHRvIGNoZWNrLlxyXG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59IFdoZXRoZXIgdGhlIGdpdmVuIHR5cGUgaXMgYSByZWZlcmVuY2UgdHlwZSBvciBub3QuXHJcblx0ICovXHJcblx0aXNSZWZlcmVuY2UoIHR5cGUgKSB7XHJcblxyXG5cdFx0cmV0dXJuIHR5cGUgPT09ICd2b2lkJyB8fCB0eXBlID09PSAncHJvcGVydHknIHx8IHR5cGUgPT09ICdzYW1wbGVyJyB8fCB0eXBlID09PSAndGV4dHVyZScgfHwgdHlwZSA9PT0gJ2N1YmVUZXh0dXJlJyB8fCB0eXBlID09PSAnc3RvcmFnZVRleHR1cmUnIHx8IHR5cGUgPT09ICdkZXB0aFRleHR1cmUnIHx8IHR5cGUgPT09ICd0ZXh0dXJlM0QnO1xyXG5cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFdoZXRoZXIgdGhlIGdpdmVuIHRleHR1cmUgbmVlZHMgYSBjb252ZXJzaW9uIHRvIHdvcmtpbmcgY29sb3Igc3BhY2UuXHJcblx0ICpcclxuXHQgKiBAYWJzdHJhY3RcclxuXHQgKiBAcGFyYW0ge1RleHR1cmV9IHRleHR1cmUgLSBUaGUgdGV4dHVyZSB0byBjaGVjay5cclxuXHQgKiBAcmV0dXJuIHtCb29sZWFufSBXaGV0aGVyIGEgY29sb3Igc3BhY2UgY29udmVyc2lvbiBpcyByZXF1aXJlZCBvciBub3QuXHJcblx0ICovXHJcblx0bmVlZHNUb1dvcmtpbmdDb2xvclNwYWNlKCAvKnRleHR1cmUqLyApIHtcclxuXHJcblx0XHRyZXR1cm4gZmFsc2U7XHJcblxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogUmV0dXJucyB0aGUgY29tcG9uZW50IHR5cGUgb2YgYSBnaXZlbiB0ZXh0dXJlLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtUZXh0dXJlfSB0ZXh0dXJlIC0gVGhlIHRleHR1cmUuXHJcblx0ICogQHJldHVybiB7U3RyaW5nfSBUaGUgY29tcG9uZW50IHR5cGUuXHJcblx0ICovXHJcblx0Z2V0Q29tcG9uZW50VHlwZUZyb21UZXh0dXJlKCB0ZXh0dXJlICkge1xyXG5cclxuXHRcdGNvbnN0IHR5cGUgPSB0ZXh0dXJlLnR5cGU7XHJcblxyXG5cdFx0aWYgKCB0ZXh0dXJlLmlzRGF0YVRleHR1cmUgKSB7XHJcblxyXG5cdFx0XHRpZiAoIHR5cGUgPT09IEludFR5cGUgKSByZXR1cm4gJ2ludCc7XHJcblx0XHRcdGlmICggdHlwZSA9PT0gVW5zaWduZWRJbnRUeXBlICkgcmV0dXJuICd1aW50JztcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuICdmbG9hdCc7XHJcblxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogUmV0dXJucyB0aGUgZWxlbWVudCB0eXBlIGZvciBhIGdpdmVuIHR5cGUuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSAtIFRoZSB0eXBlLlxyXG5cdCAqIEByZXR1cm4ge1N0cmluZ30gVGhlIGVsZW1lbnQgdHlwZS5cclxuXHQgKi9cclxuXHRnZXRFbGVtZW50VHlwZSggdHlwZSApIHtcclxuXHJcblx0XHRpZiAoIHR5cGUgPT09ICdtYXQyJyApIHJldHVybiAndmVjMic7XHJcblx0XHRpZiAoIHR5cGUgPT09ICdtYXQzJyApIHJldHVybiAndmVjMyc7XHJcblx0XHRpZiAoIHR5cGUgPT09ICdtYXQ0JyApIHJldHVybiAndmVjNCc7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuZ2V0Q29tcG9uZW50VHlwZSggdHlwZSApO1xyXG5cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFJldHVybnMgdGhlIGNvbXBvbmVudCB0eXBlIGZvciBhIGdpdmVuIHR5cGUuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSAtIFRoZSB0eXBlLlxyXG5cdCAqIEByZXR1cm4ge1N0cmluZ30gVGhlIGNvbXBvbmVudCB0eXBlLlxyXG5cdCAqL1xyXG5cdGdldENvbXBvbmVudFR5cGUoIHR5cGUgKSB7XHJcblxyXG5cdFx0dHlwZSA9IHRoaXMuZ2V0VmVjdG9yVHlwZSggdHlwZSApO1xyXG5cclxuXHRcdGlmICggdHlwZSA9PT0gJ2Zsb2F0JyB8fCB0eXBlID09PSAnYm9vbCcgfHwgdHlwZSA9PT0gJ2ludCcgfHwgdHlwZSA9PT0gJ3VpbnQnICkgcmV0dXJuIHR5cGU7XHJcblxyXG5cdFx0Y29uc3QgY29tcG9uZW50VHlwZSA9IC8oYnxpfHV8KSh2ZWN8bWF0KShbMi00XSkvLmV4ZWMoIHR5cGUgKTtcclxuXHJcblx0XHRpZiAoIGNvbXBvbmVudFR5cGUgPT09IG51bGwgKSByZXR1cm4gbnVsbDtcclxuXHJcblx0XHRpZiAoIGNvbXBvbmVudFR5cGVbIDEgXSA9PT0gJ2InICkgcmV0dXJuICdib29sJztcclxuXHRcdGlmICggY29tcG9uZW50VHlwZVsgMSBdID09PSAnaScgKSByZXR1cm4gJ2ludCc7XHJcblx0XHRpZiAoIGNvbXBvbmVudFR5cGVbIDEgXSA9PT0gJ3UnICkgcmV0dXJuICd1aW50JztcclxuXHJcblx0XHRyZXR1cm4gJ2Zsb2F0JztcclxuXHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBSZXR1cm5zIHRoZSB2ZWN0b3IgdHlwZSBmb3IgYSBnaXZlbiB0eXBlLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgLSBUaGUgdHlwZS5cclxuXHQgKiBAcmV0dXJuIHtTdHJpbmd9IFRoZSB2ZWN0b3IgdHlwZS5cclxuXHQgKi9cclxuXHRnZXRWZWN0b3JUeXBlKCB0eXBlICkge1xyXG5cclxuXHRcdGlmICggdHlwZSA9PT0gJ2NvbG9yJyApIHJldHVybiAndmVjMyc7XHJcblx0XHRpZiAoIHR5cGUgPT09ICd0ZXh0dXJlJyB8fCB0eXBlID09PSAnY3ViZVRleHR1cmUnIHx8IHR5cGUgPT09ICdzdG9yYWdlVGV4dHVyZScgfHwgdHlwZSA9PT0gJ3RleHR1cmUzRCcgKSByZXR1cm4gJ3ZlYzQnO1xyXG5cclxuXHRcdHJldHVybiB0eXBlO1xyXG5cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFJldHVybnMgdGhlIGRhdGEgdHlwZSBmb3IgdGhlIGdpdmVuIHRoZSBsZW5ndGggYW5kIGNvbXBvbmVudCB0eXBlLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGxlbmd0aCAtIFRoZSBsZW5ndGguXHJcblx0ICogQHBhcmFtIHtTdHJpbmd9IFtjb21wb25lbnRUeXBlPSdmbG9hdCddIC0gVGhlIGNvbXBvbmVudCB0eXBlLlxyXG5cdCAqIEByZXR1cm4ge1N0cmluZ30gVGhlIHR5cGUuXHJcblx0ICovXHJcblx0Z2V0VHlwZUZyb21MZW5ndGgoIGxlbmd0aCwgY29tcG9uZW50VHlwZSA9ICdmbG9hdCcgKSB7XHJcblxyXG5cdFx0aWYgKCBsZW5ndGggPT09IDEgKSByZXR1cm4gY29tcG9uZW50VHlwZTtcclxuXHJcblx0XHRjb25zdCBiYXNlVHlwZSA9IGdldFR5cGVGcm9tTGVuZ3RoKCBsZW5ndGggKTtcclxuXHRcdGNvbnN0IHByZWZpeCA9IGNvbXBvbmVudFR5cGUgPT09ICdmbG9hdCcgPyAnJyA6IGNvbXBvbmVudFR5cGVbIDAgXTtcclxuXHJcblx0XHRyZXR1cm4gcHJlZml4ICsgYmFzZVR5cGU7XHJcblxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogUmV0dXJucyB0aGUgdHlwZSBmb3IgYSBnaXZlbiB0eXBlZCBhcnJheS5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7VHlwZWRBcnJheX0gYXJyYXkgLSBUaGUgdHlwZWQgYXJyYXkuXHJcblx0ICogQHJldHVybiB7U3RyaW5nfSBUaGUgdHlwZS5cclxuXHQgKi9cclxuXHRnZXRUeXBlRnJvbUFycmF5KCBhcnJheSApIHtcclxuXHJcblx0XHRyZXR1cm4gdHlwZUZyb21BcnJheS5nZXQoIGFycmF5LmNvbnN0cnVjdG9yICk7XHJcblxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogUmV0dXJucyB0aGUgdHlwZSBmb3IgYSBnaXZlbiBidWZmZXIgYXR0cmlidXRlLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtCdWZmZXJBdHRyaWJ1dGV9IGF0dHJpYnV0ZSAtIFRoZSBidWZmZXIgYXR0cmlidXRlLlxyXG5cdCAqIEByZXR1cm4ge1N0cmluZ30gVGhlIHR5cGUuXHJcblx0ICovXHJcblx0Z2V0VHlwZUZyb21BdHRyaWJ1dGUoIGF0dHJpYnV0ZSApIHtcclxuXHJcblx0XHRsZXQgZGF0YUF0dHJpYnV0ZSA9IGF0dHJpYnV0ZTtcclxuXHJcblx0XHRpZiAoIGF0dHJpYnV0ZS5pc0ludGVybGVhdmVkQnVmZmVyQXR0cmlidXRlICkgZGF0YUF0dHJpYnV0ZSA9IGF0dHJpYnV0ZS5kYXRhO1xyXG5cclxuXHRcdGNvbnN0IGFycmF5ID0gZGF0YUF0dHJpYnV0ZS5hcnJheTtcclxuXHRcdGNvbnN0IGl0ZW1TaXplID0gYXR0cmlidXRlLml0ZW1TaXplO1xyXG5cdFx0Y29uc3Qgbm9ybWFsaXplZCA9IGF0dHJpYnV0ZS5ub3JtYWxpemVkO1xyXG5cclxuXHRcdGxldCBhcnJheVR5cGU7XHJcblxyXG5cdFx0aWYgKCAhICggYXR0cmlidXRlIGluc3RhbmNlb2YgRmxvYXQxNkJ1ZmZlckF0dHJpYnV0ZSApICYmIG5vcm1hbGl6ZWQgIT09IHRydWUgKSB7XHJcblxyXG5cdFx0XHRhcnJheVR5cGUgPSB0aGlzLmdldFR5cGVGcm9tQXJyYXkoIGFycmF5ICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzLmdldFR5cGVGcm9tTGVuZ3RoKCBpdGVtU2l6ZSwgYXJyYXlUeXBlICk7XHJcblxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogUmV0dXJucyB0aGUgbGVuZ3RoIGZvciB0aGUgZ2l2ZW4gZGF0YSB0eXBlLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgLSBUaGUgZGF0YSB0eXBlLlxyXG5cdCAqIEByZXR1cm4ge051bWJlcn0gVGhlIGxlbmd0aC5cclxuXHQgKi9cclxuXHRnZXRUeXBlTGVuZ3RoKCB0eXBlICkge1xyXG5cclxuXHRcdGNvbnN0IHZlY1R5cGUgPSB0aGlzLmdldFZlY3RvclR5cGUoIHR5cGUgKTtcclxuXHRcdGNvbnN0IHZlY051bSA9IC92ZWMoWzItNF0pLy5leGVjKCB2ZWNUeXBlICk7XHJcblxyXG5cdFx0aWYgKCB2ZWNOdW0gIT09IG51bGwgKSByZXR1cm4gTnVtYmVyKCB2ZWNOdW1bIDEgXSApO1xyXG5cdFx0aWYgKCB2ZWNUeXBlID09PSAnZmxvYXQnIHx8IHZlY1R5cGUgPT09ICdib29sJyB8fCB2ZWNUeXBlID09PSAnaW50JyB8fCB2ZWNUeXBlID09PSAndWludCcgKSByZXR1cm4gMTtcclxuXHRcdGlmICggL21hdDIvLnRlc3QoIHR5cGUgKSA9PT0gdHJ1ZSApIHJldHVybiA0O1xyXG5cdFx0aWYgKCAvbWF0My8udGVzdCggdHlwZSApID09PSB0cnVlICkgcmV0dXJuIDk7XHJcblx0XHRpZiAoIC9tYXQ0Ly50ZXN0KCB0eXBlICkgPT09IHRydWUgKSByZXR1cm4gMTY7XHJcblxyXG5cdFx0cmV0dXJuIDA7XHJcblxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogUmV0dXJucyB0aGUgdmVjdG9yIHR5cGUgZm9yIGEgZ2l2ZW4gbWF0cml4IHR5cGUuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSAtIFRoZSBtYXRyaXggdHlwZS5cclxuXHQgKiBAcmV0dXJuIHtTdHJpbmd9IFRoZSB2ZWN0b3IgdHlwZS5cclxuXHQgKi9cclxuXHRnZXRWZWN0b3JGcm9tTWF0cml4KCB0eXBlICkge1xyXG5cclxuXHRcdHJldHVybiB0eXBlLnJlcGxhY2UoICdtYXQnLCAndmVjJyApO1xyXG5cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEZvciBhIGdpdmVuIHR5cGUgdGhpcyBtZXRob2QgY2hhbmdlcyB0aGUgY29tcG9uZW50IHR5cGUgdG8gdGhlXHJcblx0ICogZ2l2ZW4gdmFsdWUuIEUuZy4gYHZlYzRgIHNob3VsZCBiZSBjaGFuZ2VkIHRvIHRoZSBuZXcgY29tcG9uZW50IHR5cGVcclxuXHQgKiBgdWludGAgd2hpY2ggcmVzdWx0cyBpbiBgdXZlYzRgLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgLSBUaGUgdHlwZS5cclxuXHQgKiBAcGFyYW0ge1N0cmluZ30gbmV3Q29tcG9uZW50VHlwZSAtIFRoZSBuZXcgY29tcG9uZW50IHR5cGUuXHJcblx0ICogQHJldHVybiB7U3RyaW5nfSBUaGUgbmV3IHR5cGUuXHJcblx0ICovXHJcblx0Y2hhbmdlQ29tcG9uZW50VHlwZSggdHlwZSwgbmV3Q29tcG9uZW50VHlwZSApIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5nZXRUeXBlRnJvbUxlbmd0aCggdGhpcy5nZXRUeXBlTGVuZ3RoKCB0eXBlICksIG5ld0NvbXBvbmVudFR5cGUgKTtcclxuXHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBSZXR1cm5zIHRoZSBpbnRlZ2VyIHR5cGUgcGVuZGFudCBmb3IgdGhlIGdpdmVuIHR5cGUuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSAtIFRoZSB0eXBlLlxyXG5cdCAqIEByZXR1cm4ge1N0cmluZ30gVGhlIGludGVnZXIgdHlwZS5cclxuXHQgKi9cclxuXHRnZXRJbnRlZ2VyVHlwZSggdHlwZSApIHtcclxuXHJcblx0XHRjb25zdCBjb21wb25lbnRUeXBlID0gdGhpcy5nZXRDb21wb25lbnRUeXBlKCB0eXBlICk7XHJcblxyXG5cdFx0aWYgKCBjb21wb25lbnRUeXBlID09PSAnaW50JyB8fCBjb21wb25lbnRUeXBlID09PSAndWludCcgKSByZXR1cm4gdHlwZTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5jaGFuZ2VDb21wb25lbnRUeXBlKCB0eXBlLCAnaW50JyApO1xyXG5cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEFkZHMgYSBzdGFjayBub2RlIHRvIHRoZSBpbnRlcm5hbCBzdGFjay5cclxuXHQgKlxyXG5cdCAqIEByZXR1cm4ge1N0YWNrTm9kZX0gVGhlIGFkZGVkIHN0YWNrIG5vZGUuXHJcblx0ICovXHJcblx0YWRkU3RhY2soKSB7XHJcblxyXG5cdFx0dGhpcy5zdGFjayA9IHN0YWNrKCB0aGlzLnN0YWNrICk7XHJcblxyXG5cdFx0dGhpcy5zdGFja3MucHVzaCggZ2V0Q3VycmVudFN0YWNrKCkgfHwgdGhpcy5zdGFjayApO1xyXG5cdFx0c2V0Q3VycmVudFN0YWNrKCB0aGlzLnN0YWNrICk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuc3RhY2s7XHJcblxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogUmVtb3ZlcyB0aGUgbGFzdCBzdGFjayBub2RlIGZyb20gdGhlIGludGVybmFsIHN0YWNrLlxyXG5cdCAqXHJcblx0ICogQHJldHVybiB7U3RhY2tOb2RlfSBUaGUgcmVtb3ZlZCBzdGFjayBub2RlLlxyXG5cdCAqL1xyXG5cdHJlbW92ZVN0YWNrKCkge1xyXG5cclxuXHRcdGNvbnN0IGxhc3RTdGFjayA9IHRoaXMuc3RhY2s7XHJcblx0XHR0aGlzLnN0YWNrID0gbGFzdFN0YWNrLnBhcmVudDtcclxuXHJcblx0XHRzZXRDdXJyZW50U3RhY2soIHRoaXMuc3RhY2tzLnBvcCgpICk7XHJcblxyXG5cdFx0cmV0dXJuIGxhc3RTdGFjaztcclxuXHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBUaGUgYnVpbGRlciBtYWludGFpbnMgKGNhY2hlZCkgZGF0YSBmb3IgZWFjaCBub2RlIGR1cmluZyB0aGUgYnVpbGRpbmcgcHJvY2Vzcy4gVGhpcyBtZXRob2RcclxuXHQgKiBjYW4gYmUgdXNlZCB0byBnZXQgdGhlc2UgZGF0YSBmb3IgYSBzcGVjaWZpYyBzaGFkZXIgc3RhZ2UgYW5kIGNhY2hlLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtOb2RlfSBub2RlIC0gVGhlIG5vZGUgdG8gZ2V0IHRoZSBkYXRhIGZvci5cclxuXHQgKiBAcGFyYW0geygndmVydGV4J3wnZnJhZ21lbnQnfCdjb21wdXRlJ3wnYW55Jyl9IFtzaGFkZXJTdGFnZT10aGlzLnNoYWRlclN0YWdlXSAtIFRoZSBzaGFkZXIgc3RhZ2UuXHJcblx0ICogQHBhcmFtIHtOb2RlQ2FjaGU/fSBjYWNoZSAtIEFuIG9wdGlvbmFsIGNhY2hlLlxyXG5cdCAqIEByZXR1cm4ge09iamVjdH0gVGhlIG5vZGUgZGF0YS5cclxuXHQgKi9cclxuXHRnZXREYXRhRnJvbU5vZGUoIG5vZGUsIHNoYWRlclN0YWdlID0gdGhpcy5zaGFkZXJTdGFnZSwgY2FjaGUgPSBudWxsICkge1xyXG5cclxuXHRcdGNhY2hlID0gY2FjaGUgPT09IG51bGwgPyAoIG5vZGUuaXNHbG9iYWwoIHRoaXMgKSA/IHRoaXMuZ2xvYmFsQ2FjaGUgOiB0aGlzLmNhY2hlICkgOiBjYWNoZTtcclxuXHJcblx0XHRsZXQgbm9kZURhdGEgPSBjYWNoZS5nZXREYXRhKCBub2RlICk7XHJcblxyXG5cdFx0aWYgKCBub2RlRGF0YSA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0bm9kZURhdGEgPSB7fTtcclxuXHJcblx0XHRcdGNhY2hlLnNldERhdGEoIG5vZGUsIG5vZGVEYXRhICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggbm9kZURhdGFbIHNoYWRlclN0YWdlIF0gPT09IHVuZGVmaW5lZCApIG5vZGVEYXRhWyBzaGFkZXJTdGFnZSBdID0ge307XHJcblxyXG5cdFx0cmV0dXJuIG5vZGVEYXRhWyBzaGFkZXJTdGFnZSBdO1xyXG5cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFJldHVybnMgdGhlIHByb3BlcnRpZXMgZm9yIHRoZSBnaXZlbiBub2RlIGFuZCBzaGFkZXIgc3RhZ2UuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge05vZGV9IG5vZGUgLSBUaGUgbm9kZSB0byBnZXQgdGhlIHByb3BlcnRpZXMgZm9yLlxyXG5cdCAqIEBwYXJhbSB7KCd2ZXJ0ZXgnfCdmcmFnbWVudCd8J2NvbXB1dGUnfCdhbnknKX0gW3NoYWRlclN0YWdlPSdhbnknXSAtIFRoZSBzaGFkZXIgc3RhZ2UuXHJcblx0ICogQHJldHVybiB7T2JqZWN0fSBUaGUgbm9kZSBwcm9wZXJ0aWVzLlxyXG5cdCAqL1xyXG5cdGdldE5vZGVQcm9wZXJ0aWVzKCBub2RlLCBzaGFkZXJTdGFnZSA9ICdhbnknICkge1xyXG5cclxuXHRcdGNvbnN0IG5vZGVEYXRhID0gdGhpcy5nZXREYXRhRnJvbU5vZGUoIG5vZGUsIHNoYWRlclN0YWdlICk7XHJcblxyXG5cdFx0cmV0dXJuIG5vZGVEYXRhLnByb3BlcnRpZXMgfHwgKCBub2RlRGF0YS5wcm9wZXJ0aWVzID0geyBvdXRwdXROb2RlOiBudWxsIH0gKTtcclxuXHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBSZXR1cm5zIGFuIGluc3RhbmNlIG9mIHtAbGluayBOb2RlQXR0cmlidXRlfSBmb3IgdGhlIGdpdmVuIGJ1ZmZlciBhdHRyaWJ1dGUgbm9kZS5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7QnVmZmVyQXR0cmlidXRlTm9kZX0gbm9kZSAtIFRoZSBidWZmZXIgYXR0cmlidXRlIG5vZGUuXHJcblx0ICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgLSBUaGUgbm9kZSB0eXBlLlxyXG5cdCAqIEByZXR1cm4ge05vZGVBdHRyaWJ1dGV9IFRoZSBub2RlIGF0dHJpYnV0ZS5cclxuXHQgKi9cclxuXHRnZXRCdWZmZXJBdHRyaWJ1dGVGcm9tTm9kZSggbm9kZSwgdHlwZSApIHtcclxuXHJcblx0XHRjb25zdCBub2RlRGF0YSA9IHRoaXMuZ2V0RGF0YUZyb21Ob2RlKCBub2RlICk7XHJcblxyXG5cdFx0bGV0IGJ1ZmZlckF0dHJpYnV0ZSA9IG5vZGVEYXRhLmJ1ZmZlckF0dHJpYnV0ZTtcclxuXHJcblx0XHRpZiAoIGJ1ZmZlckF0dHJpYnV0ZSA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0Y29uc3QgaW5kZXggPSB0aGlzLnVuaWZvcm1zLmluZGV4ICsrO1xyXG5cclxuXHRcdFx0YnVmZmVyQXR0cmlidXRlID0gbmV3IE5vZGVBdHRyaWJ1dGUoICdub2RlQXR0cmlidXRlJyArIGluZGV4LCB0eXBlLCBub2RlICk7XHJcblxyXG5cdFx0XHR0aGlzLmJ1ZmZlckF0dHJpYnV0ZXMucHVzaCggYnVmZmVyQXR0cmlidXRlICk7XHJcblxyXG5cdFx0XHRub2RlRGF0YS5idWZmZXJBdHRyaWJ1dGUgPSBidWZmZXJBdHRyaWJ1dGU7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBidWZmZXJBdHRyaWJ1dGU7XHJcblxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogUmV0dXJucyBhbiBpbnN0YW5jZSBvZiB7QGxpbmsgU3RydWN0VHlwZU5vZGV9IGZvciB0aGUgZ2l2ZW4gb3V0cHV0IHN0cnVjdCBub2RlLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtPdXRwdXRTdHJ1Y3ROb2RlfSBub2RlIC0gVGhlIG91dHB1dCBzdHJ1Y3Qgbm9kZS5cclxuXHQgKiBAcGFyYW0ge0FycmF5PFN0cmluZz59IHR5cGVzIC0gVGhlIG91dHB1dCBzdHJ1Y3QgdHlwZXMuXHJcblx0ICogQHBhcmFtIHsoJ3ZlcnRleCd8J2ZyYWdtZW50J3wnY29tcHV0ZSd8J2FueScpfSBbc2hhZGVyU3RhZ2U9dGhpcy5zaGFkZXJTdGFnZV0gLSBUaGUgc2hhZGVyIHN0YWdlLlxyXG5cdCAqIEByZXR1cm4ge1N0cnVjdFR5cGVOb2RlfSBUaGUgc3RydWN0IHR5cGUgYXR0cmlidXRlLlxyXG5cdCAqL1xyXG5cdGdldFN0cnVjdFR5cGVGcm9tTm9kZSggbm9kZSwgdHlwZXMsIHNoYWRlclN0YWdlID0gdGhpcy5zaGFkZXJTdGFnZSApIHtcclxuXHJcblx0XHRjb25zdCBub2RlRGF0YSA9IHRoaXMuZ2V0RGF0YUZyb21Ob2RlKCBub2RlLCBzaGFkZXJTdGFnZSApO1xyXG5cclxuXHRcdGxldCBzdHJ1Y3RUeXBlID0gbm9kZURhdGEuc3RydWN0VHlwZTtcclxuXHJcblx0XHRpZiAoIHN0cnVjdFR5cGUgPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdGNvbnN0IGluZGV4ID0gdGhpcy5zdHJ1Y3RzLmluZGV4ICsrO1xyXG5cclxuXHRcdFx0c3RydWN0VHlwZSA9IG5ldyBTdHJ1Y3RUeXBlTm9kZSggJ1N0cnVjdFR5cGUnICsgaW5kZXgsIHR5cGVzICk7XHJcblxyXG5cdFx0XHR0aGlzLnN0cnVjdHNbIHNoYWRlclN0YWdlIF0ucHVzaCggc3RydWN0VHlwZSApO1xyXG5cclxuXHRcdFx0bm9kZURhdGEuc3RydWN0VHlwZSA9IHN0cnVjdFR5cGU7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBzdHJ1Y3RUeXBlO1xyXG5cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFJldHVybnMgYW4gaW5zdGFuY2Ugb2Yge0BsaW5rIE5vZGVVbmlmb3JtfSBmb3IgdGhlIGdpdmVuIHVuaWZvcm0gbm9kZS5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7VW5pZm9ybU5vZGV9IG5vZGUgLSBUaGUgdW5pZm9ybSBub2RlLlxyXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIC0gVGhlIHVuaWZvcm0gdHlwZS5cclxuXHQgKiBAcGFyYW0geygndmVydGV4J3wnZnJhZ21lbnQnfCdjb21wdXRlJ3wnYW55Jyl9IFtzaGFkZXJTdGFnZT10aGlzLnNoYWRlclN0YWdlXSAtIFRoZSBzaGFkZXIgc3RhZ2UuXHJcblx0ICogQHBhcmFtIHtTdHJpbmc/fSBuYW1lIC0gVGhlIG5hbWUgb2YgdGhlIHVuaWZvcm0uXHJcblx0ICogQHJldHVybiB7Tm9kZVVuaWZvcm19IFRoZSBub2RlIHVuaWZvcm0uXHJcblx0ICovXHJcblx0Z2V0VW5pZm9ybUZyb21Ob2RlKCBub2RlLCB0eXBlLCBzaGFkZXJTdGFnZSA9IHRoaXMuc2hhZGVyU3RhZ2UsIG5hbWUgPSBudWxsICkge1xyXG5cclxuXHRcdGNvbnN0IG5vZGVEYXRhID0gdGhpcy5nZXREYXRhRnJvbU5vZGUoIG5vZGUsIHNoYWRlclN0YWdlLCB0aGlzLmdsb2JhbENhY2hlICk7XHJcblxyXG5cdFx0bGV0IG5vZGVVbmlmb3JtID0gbm9kZURhdGEudW5pZm9ybTtcclxuXHJcblx0XHRpZiAoIG5vZGVVbmlmb3JtID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRjb25zdCBpbmRleCA9IHRoaXMudW5pZm9ybXMuaW5kZXggKys7XHJcblxyXG5cdFx0XHRub2RlVW5pZm9ybSA9IG5ldyBOb2RlVW5pZm9ybSggbmFtZSB8fCAoICdub2RlVW5pZm9ybScgKyBpbmRleCApLCB0eXBlLCBub2RlICk7XHJcblxyXG5cdFx0XHR0aGlzLnVuaWZvcm1zWyBzaGFkZXJTdGFnZSBdLnB1c2goIG5vZGVVbmlmb3JtICk7XHJcblxyXG5cdFx0XHRub2RlRGF0YS51bmlmb3JtID0gbm9kZVVuaWZvcm07XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBub2RlVW5pZm9ybTtcclxuXHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBSZXR1cm5zIGFuIGluc3RhbmNlIG9mIHtAbGluayBOb2RlVmFyfSBmb3IgdGhlIGdpdmVuIHZhcmlhYmxlIG5vZGUuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge1Zhck5vZGV9IG5vZGUgLSBUaGUgdmFyaWFibGUgbm9kZS5cclxuXHQgKiBAcGFyYW0ge1N0cmluZz99IG5hbWUgLSBUaGUgdmFyaWFibGUncyBuYW1lLlxyXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBbdHlwZT1ub2RlLmdldE5vZGVUeXBlKCB0aGlzICldIC0gVGhlIHZhcmlhYmxlJ3MgdHlwZS5cclxuXHQgKiBAcGFyYW0geygndmVydGV4J3wnZnJhZ21lbnQnfCdjb21wdXRlJ3wnYW55Jyl9IFtzaGFkZXJTdGFnZT10aGlzLnNoYWRlclN0YWdlXSAtIFRoZSBzaGFkZXIgc3RhZ2UuXHJcblx0ICogQHJldHVybiB7Tm9kZVZhcn0gVGhlIG5vZGUgdmFyaWFibGUuXHJcblx0ICovXHJcblx0Z2V0VmFyRnJvbU5vZGUoIG5vZGUsIG5hbWUgPSBudWxsLCB0eXBlID0gbm9kZS5nZXROb2RlVHlwZSggdGhpcyApLCBzaGFkZXJTdGFnZSA9IHRoaXMuc2hhZGVyU3RhZ2UgKSB7XHJcblxyXG5cdFx0Y29uc3Qgbm9kZURhdGEgPSB0aGlzLmdldERhdGFGcm9tTm9kZSggbm9kZSwgc2hhZGVyU3RhZ2UgKTtcclxuXHJcblx0XHRsZXQgbm9kZVZhciA9IG5vZGVEYXRhLnZhcmlhYmxlO1xyXG5cclxuXHRcdGlmICggbm9kZVZhciA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0Y29uc3QgdmFycyA9IHRoaXMudmFyc1sgc2hhZGVyU3RhZ2UgXSB8fCAoIHRoaXMudmFyc1sgc2hhZGVyU3RhZ2UgXSA9IFtdICk7XHJcblxyXG5cdFx0XHRpZiAoIG5hbWUgPT09IG51bGwgKSBuYW1lID0gJ25vZGVWYXInICsgdmFycy5sZW5ndGg7XHJcblxyXG5cdFx0XHRub2RlVmFyID0gbmV3IE5vZGVWYXIoIG5hbWUsIHR5cGUgKTtcclxuXHJcblx0XHRcdHZhcnMucHVzaCggbm9kZVZhciApO1xyXG5cclxuXHRcdFx0bm9kZURhdGEudmFyaWFibGUgPSBub2RlVmFyO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gbm9kZVZhcjtcclxuXHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBSZXR1cm5zIGFuIGluc3RhbmNlIG9mIHtAbGluayBOb2RlVmFyeWluZ30gZm9yIHRoZSBnaXZlbiB2YXJ5aW5nIG5vZGUuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0geyhWYXJ5aW5nTm9kZXxQcm9wZXJ0eU5vZGUpfSBub2RlIC0gVGhlIHZhcnlpbmcgbm9kZS5cclxuXHQgKiBAcGFyYW0ge1N0cmluZz99IG5hbWUgLSBUaGUgdmFyeWluZydzIG5hbWUuXHJcblx0ICogQHBhcmFtIHtTdHJpbmd9IFt0eXBlPW5vZGUuZ2V0Tm9kZVR5cGUoIHRoaXMgKV0gLSBUaGUgdmFyeWluZydzIHR5cGUuXHJcblx0ICogQHJldHVybiB7Tm9kZVZhcn0gVGhlIG5vZGUgdmFyeWluZy5cclxuXHQgKi9cclxuXHRnZXRWYXJ5aW5nRnJvbU5vZGUoIG5vZGUsIG5hbWUgPSBudWxsLCB0eXBlID0gbm9kZS5nZXROb2RlVHlwZSggdGhpcyApICkge1xyXG5cclxuXHRcdGNvbnN0IG5vZGVEYXRhID0gdGhpcy5nZXREYXRhRnJvbU5vZGUoIG5vZGUsICdhbnknICk7XHJcblxyXG5cdFx0bGV0IG5vZGVWYXJ5aW5nID0gbm9kZURhdGEudmFyeWluZztcclxuXHJcblx0XHRpZiAoIG5vZGVWYXJ5aW5nID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRjb25zdCB2YXJ5aW5ncyA9IHRoaXMudmFyeWluZ3M7XHJcblx0XHRcdGNvbnN0IGluZGV4ID0gdmFyeWluZ3MubGVuZ3RoO1xyXG5cclxuXHRcdFx0aWYgKCBuYW1lID09PSBudWxsICkgbmFtZSA9ICdub2RlVmFyeWluZycgKyBpbmRleDtcclxuXHJcblx0XHRcdG5vZGVWYXJ5aW5nID0gbmV3IE5vZGVWYXJ5aW5nKCBuYW1lLCB0eXBlICk7XHJcblxyXG5cdFx0XHR2YXJ5aW5ncy5wdXNoKCBub2RlVmFyeWluZyApO1xyXG5cclxuXHRcdFx0bm9kZURhdGEudmFyeWluZyA9IG5vZGVWYXJ5aW5nO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gbm9kZVZhcnlpbmc7XHJcblxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogUmV0dXJucyBhbiBpbnN0YW5jZSBvZiB7QGxpbmsgTm9kZUNvZGV9IGZvciB0aGUgZ2l2ZW4gY29kZSBub2RlLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtDb2RlTm9kZX0gbm9kZSAtIFRoZSBjb2RlIG5vZGUuXHJcblx0ICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgLSBUaGUgbm9kZSB0eXBlLlxyXG5cdCAqIEBwYXJhbSB7KCd2ZXJ0ZXgnfCdmcmFnbWVudCd8J2NvbXB1dGUnfCdhbnknKX0gW3NoYWRlclN0YWdlPXRoaXMuc2hhZGVyU3RhZ2VdIC0gVGhlIHNoYWRlciBzdGFnZS5cclxuXHQgKiBAcmV0dXJuIHtOb2RlQ29kZX0gVGhlIG5vZGUgY29kZS5cclxuXHQgKi9cclxuXHRnZXRDb2RlRnJvbU5vZGUoIG5vZGUsIHR5cGUsIHNoYWRlclN0YWdlID0gdGhpcy5zaGFkZXJTdGFnZSApIHtcclxuXHJcblx0XHRjb25zdCBub2RlRGF0YSA9IHRoaXMuZ2V0RGF0YUZyb21Ob2RlKCBub2RlICk7XHJcblxyXG5cdFx0bGV0IG5vZGVDb2RlID0gbm9kZURhdGEuY29kZTtcclxuXHJcblx0XHRpZiAoIG5vZGVDb2RlID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRjb25zdCBjb2RlcyA9IHRoaXMuY29kZXNbIHNoYWRlclN0YWdlIF0gfHwgKCB0aGlzLmNvZGVzWyBzaGFkZXJTdGFnZSBdID0gW10gKTtcclxuXHRcdFx0Y29uc3QgaW5kZXggPSBjb2Rlcy5sZW5ndGg7XHJcblxyXG5cdFx0XHRub2RlQ29kZSA9IG5ldyBOb2RlQ29kZSggJ25vZGVDb2RlJyArIGluZGV4LCB0eXBlICk7XHJcblxyXG5cdFx0XHRjb2Rlcy5wdXNoKCBub2RlQ29kZSApO1xyXG5cclxuXHRcdFx0bm9kZURhdGEuY29kZSA9IG5vZGVDb2RlO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gbm9kZUNvZGU7XHJcblxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogQWRkcyBhIGNvZGUgZmxvdyBiYXNlZCBvbiB0aGUgY29kZS1ibG9jayBoaWVyYXJjaHkuXHJcblxyXG5cdCAqIFRoaXMgaXMgdXNlZCBzbyB0aGF0IGNvZGUtYmxvY2tzIGxpa2UgSWYsRWxzZSBjcmVhdGUgdGhlaXIgdmFyaWFibGVzIGxvY2FsbHkgaWYgdGhlIE5vZGVcclxuXHQgKiBpcyBvbmx5IHVzZWQgaW5zaWRlIG9uZSBvZiB0aGVzZSBjb25kaXRpb25hbHMgaW4gdGhlIGN1cnJlbnQgc2hhZGVyIHN0YWdlLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtOb2RlfSBub2RlIC0gVGhlIG5vZGUgdG8gYWRkLlxyXG5cdCAqIEBwYXJhbSB7Tm9kZX0gbm9kZUJsb2NrIC0gTm9kZS1iYXNlZCBjb2RlLWJsb2NrLiBVc3VhbGx5ICdDb25kaXRpb25hbE5vZGUnLlxyXG5cdCAqL1xyXG5cdGFkZEZsb3dDb2RlSGllcmFyY2h5KCBub2RlLCBub2RlQmxvY2sgKSB7XHJcblxyXG5cdFx0Y29uc3QgeyBmbG93Q29kZXMsIGZsb3dDb2RlQmxvY2sgfSA9IHRoaXMuZ2V0RGF0YUZyb21Ob2RlKCBub2RlICk7XHJcblxyXG5cdFx0bGV0IG5lZWRzRmxvd0NvZGUgPSB0cnVlO1xyXG5cdFx0bGV0IG5vZGVCbG9ja0hpZXJhcmNoeSA9IG5vZGVCbG9jaztcclxuXHJcblx0XHR3aGlsZSAoIG5vZGVCbG9ja0hpZXJhcmNoeSApIHtcclxuXHJcblx0XHRcdGlmICggZmxvd0NvZGVCbG9jay5nZXQoIG5vZGVCbG9ja0hpZXJhcmNoeSApID09PSB0cnVlICkge1xyXG5cclxuXHRcdFx0XHRuZWVkc0Zsb3dDb2RlID0gZmFsc2U7XHJcblx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRub2RlQmxvY2tIaWVyYXJjaHkgPSB0aGlzLmdldERhdGFGcm9tTm9kZSggbm9kZUJsb2NrSGllcmFyY2h5ICkucGFyZW50Tm9kZUJsb2NrO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIG5lZWRzRmxvd0NvZGUgKSB7XHJcblxyXG5cdFx0XHRmb3IgKCBjb25zdCBmbG93Q29kZSBvZiBmbG93Q29kZXMgKSB7XHJcblxyXG5cdFx0XHRcdHRoaXMuYWRkTGluZUZsb3dDb2RlKCBmbG93Q29kZSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBBZGQgYSBpbmxpbmUtY29kZSB0byB0aGUgY3VycmVudCBmbG93IGNvZGUtYmxvY2suXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge05vZGV9IG5vZGUgLSBUaGUgbm9kZSB0byBhZGQuXHJcblx0ICogQHBhcmFtIHtTdHJpbmd9IGNvZGUgLSBUaGUgY29kZSB0byBhZGQuXHJcblx0ICogQHBhcmFtIHtOb2RlfSBub2RlQmxvY2sgLSBDdXJyZW50IENvbmRpdGlvbmFsTm9kZVxyXG5cdCAqL1xyXG5cdGFkZExpbmVGbG93Q29kZUJsb2NrKCBub2RlLCBjb2RlLCBub2RlQmxvY2sgKSB7XHJcblxyXG5cdFx0Y29uc3Qgbm9kZURhdGEgPSB0aGlzLmdldERhdGFGcm9tTm9kZSggbm9kZSApO1xyXG5cdFx0Y29uc3QgZmxvd0NvZGVzID0gbm9kZURhdGEuZmxvd0NvZGVzIHx8ICggbm9kZURhdGEuZmxvd0NvZGVzID0gW10gKTtcclxuXHRcdGNvbnN0IGNvZGVCbG9jayA9IG5vZGVEYXRhLmZsb3dDb2RlQmxvY2sgfHwgKCBub2RlRGF0YS5mbG93Q29kZUJsb2NrID0gbmV3IFdlYWtNYXAoKSApO1xyXG5cclxuXHRcdGZsb3dDb2Rlcy5wdXNoKCBjb2RlICk7XHJcblx0XHRjb2RlQmxvY2suc2V0KCBub2RlQmxvY2ssIHRydWUgKTtcclxuXHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBBZGQgYSBpbmxpbmUtY29kZSB0byB0aGUgY3VycmVudCBmbG93LlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtTdHJpbmd9IGNvZGUgLSBUaGUgY29kZSB0byBhZGQuXHJcblx0ICogQHBhcmFtIHtOb2RlP30gW25vZGU9IG51bGxdIC0gT3B0aW9uYWwgTm9kZSwgY2FuIGhlbHAgdGhlIHN5c3RlbSB1bmRlcnN0YW5kIGlmIHRoZSBOb2RlIGlzIHBhcnQgb2YgYSBjb2RlLWJsb2NrLlxyXG5cdCAqIEByZXR1cm4ge05vZGVCdWlsZGVyfSBBIHJlZmVyZW5jZSB0byB0aGlzIG5vZGUgYnVpbGRlci5cclxuXHQgKi9cclxuXHRhZGRMaW5lRmxvd0NvZGUoIGNvZGUsIG5vZGUgPSBudWxsICkge1xyXG5cclxuXHRcdGlmICggY29kZSA9PT0gJycgKSByZXR1cm4gdGhpcztcclxuXHJcblx0XHRpZiAoIG5vZGUgIT09IG51bGwgJiYgdGhpcy5jb250ZXh0Lm5vZGVCbG9jayApIHtcclxuXHJcblx0XHRcdHRoaXMuYWRkTGluZUZsb3dDb2RlQmxvY2soIG5vZGUsIGNvZGUsIHRoaXMuY29udGV4dC5ub2RlQmxvY2sgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Y29kZSA9IHRoaXMudGFiICsgY29kZTtcclxuXHJcblx0XHRpZiAoICEgLztcXHMqJC8udGVzdCggY29kZSApICkge1xyXG5cclxuXHRcdFx0Y29kZSA9IGNvZGUgKyAnO1xcbic7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuZmxvdy5jb2RlICs9IGNvZGU7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogQWRkcyBhIGNvZGUgdG8gdGhlIGN1cnJlbnQgY29kZSBmbG93LlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtTdHJpbmd9IGNvZGUgLSBTaGFkZXIgY29kZS5cclxuXHQgKiBAcmV0dXJuIHtOb2RlQnVpbGRlcn0gQSByZWZlcmVuY2UgdG8gdGhpcyBub2RlIGJ1aWxkZXIuXHJcblx0ICovXHJcblx0YWRkRmxvd0NvZGUoIGNvZGUgKSB7XHJcblxyXG5cdFx0dGhpcy5mbG93LmNvZGUgKz0gY29kZTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBBZGQgdGFiIGluIHRoZSBjb2RlIHRoYXQgd2lsbCBiZSBnZW5lcmF0ZWQgc28gdGhhdCBvdGhlciBzbmlwcGV0cyByZXNwZWN0IHRoZSBjdXJyZW50IHRhYnVsYXRpb24uXHJcblx0ICogVHlwaWNhbGx5IHVzZWQgaW4gY29kZXMgd2l0aCBJZixFbHNlLlxyXG5cdCAqXHJcblx0ICogQHJldHVybiB7Tm9kZUJ1aWxkZXJ9IEEgcmVmZXJlbmNlIHRvIHRoaXMgbm9kZSBidWlsZGVyLlxyXG5cdCAqL1xyXG5cdGFkZEZsb3dUYWIoKSB7XHJcblxyXG5cdFx0dGhpcy50YWIgKz0gJ1xcdCc7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogUmVtb3ZlcyBhIHRhYi5cclxuXHQgKlxyXG5cdCAqIEByZXR1cm4ge05vZGVCdWlsZGVyfSBBIHJlZmVyZW5jZSB0byB0aGlzIG5vZGUgYnVpbGRlci5cclxuXHQgKi9cclxuXHRyZW1vdmVGbG93VGFiKCkge1xyXG5cclxuXHRcdHRoaXMudGFiID0gdGhpcy50YWIuc2xpY2UoIDAsIC0gMSApO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldHMgdGhlIGN1cnJlbnQgZmxvdyBkYXRhIGJhc2VkIG9uIGEgTm9kZS5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7Tm9kZX0gbm9kZSAtIE5vZGUgdGhhdCB0aGUgZmxvdyB3YXMgc3RhcnRlZC5cclxuXHQgKiBAcGFyYW0geygndmVydGV4J3wnZnJhZ21lbnQnfCdjb21wdXRlJ3wnYW55Jyl9IHNoYWRlclN0YWdlIC0gVGhlIHNoYWRlciBzdGFnZS5cclxuXHQgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBmbG93IGRhdGEuXHJcblx0ICovXHJcblx0Z2V0Rmxvd0RhdGEoIG5vZGUvKiwgc2hhZGVyU3RhZ2UqLyApIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5mbG93c0RhdGEuZ2V0KCBub2RlICk7XHJcblxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogRXhlY3V0ZXMgdGhlIG5vZGUgZmxvdyBiYXNlZCBvbiBhIHJvb3Qgbm9kZSB0byBnZW5lcmF0ZSB0aGUgZmluYWwgc2hhZGVyIGNvZGUuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge05vZGV9IG5vZGUgLSBUaGUgbm9kZSB0byBleGVjdXRlLlxyXG5cdCAqIEByZXR1cm4ge09iamVjdH0gVGhlIGNvZGUgZmxvdy5cclxuXHQgKi9cclxuXHRmbG93Tm9kZSggbm9kZSApIHtcclxuXHJcblx0XHRjb25zdCBvdXRwdXQgPSBub2RlLmdldE5vZGVUeXBlKCB0aGlzICk7XHJcblxyXG5cdFx0Y29uc3QgZmxvd0RhdGEgPSB0aGlzLmZsb3dDaGlsZE5vZGUoIG5vZGUsIG91dHB1dCApO1xyXG5cclxuXHRcdHRoaXMuZmxvd3NEYXRhLnNldCggbm9kZSwgZmxvd0RhdGEgKTtcclxuXHJcblx0XHRyZXR1cm4gZmxvd0RhdGE7XHJcblxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogUmV0dXJucyB0aGUgbmF0aXZlIHNoYWRlciBvcGVyYXRvciBuYW1lIGZvciBhIGdpdmVuIGdlbmVyaWMgbmFtZS5cclxuXHQgKiBJdCBpcyBhIHNpbWlsYXIgdHlwZSBvZiBtZXRob2QgbGlrZSB7QGxpbmsgTm9kZUJ1aWxkZXIjZ2V0TWV0aG9kfS5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7U2hhZGVyTm9kZUludGVybmFsfSBzaGFkZXJOb2RlIC0gVGhlIHNoYWRlciBub2RlIHRvIGJ1aWxkIHRoZSBmdW5jdGlvbiBub2RlIHdpdGguXHJcblx0ICogQHJldHVybiB7RnVuY3Rpb25Ob2RlfSBUaGUgYnVpbGQgZnVuY3Rpb24gbm9kZS5cclxuXHQgKi9cclxuXHRidWlsZEZ1bmN0aW9uTm9kZSggc2hhZGVyTm9kZSApIHtcclxuXHJcblx0XHRjb25zdCBmbiA9IG5ldyBGdW5jdGlvbk5vZGUoKTtcclxuXHJcblx0XHRjb25zdCBwcmV2aW91cyA9IHRoaXMuY3VycmVudEZ1bmN0aW9uTm9kZTtcclxuXHJcblx0XHR0aGlzLmN1cnJlbnRGdW5jdGlvbk5vZGUgPSBmbjtcclxuXHJcblx0XHRmbi5jb2RlID0gdGhpcy5idWlsZEZ1bmN0aW9uQ29kZSggc2hhZGVyTm9kZSApO1xyXG5cclxuXHRcdHRoaXMuY3VycmVudEZ1bmN0aW9uTm9kZSA9IHByZXZpb3VzO1xyXG5cclxuXHRcdHJldHVybiBmbjtcclxuXHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBHZW5lcmF0ZXMgYSBjb2RlIGZsb3cgYmFzZWQgb24gYSBUU0wgZnVuY3Rpb246IEZuKCkuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge1NoYWRlck5vZGVJbnRlcm5hbH0gc2hhZGVyTm9kZSAtIEEgZnVuY3Rpb24gY29kZSB3aWxsIGJlIGdlbmVyYXRlZCBiYXNlZCBvbiB0aGUgaW5wdXQuXHJcblx0ICogQHJldHVybiB7T2JqZWN0fVxyXG5cdCAqL1xyXG5cdGZsb3dTaGFkZXJOb2RlKCBzaGFkZXJOb2RlICkge1xyXG5cclxuXHRcdGNvbnN0IGxheW91dCA9IHNoYWRlck5vZGUubGF5b3V0O1xyXG5cclxuXHRcdGNvbnN0IGlucHV0cyA9IHtcclxuXHRcdFx0WyBTeW1ib2wuaXRlcmF0b3IgXSgpIHtcclxuXHJcblx0XHRcdFx0bGV0IGluZGV4ID0gMDtcclxuXHRcdFx0XHRjb25zdCB2YWx1ZXMgPSBPYmplY3QudmFsdWVzKCB0aGlzICk7XHJcblx0XHRcdFx0cmV0dXJuIHtcclxuXHRcdFx0XHRcdG5leHQ6ICgpID0+ICgge1xyXG5cdFx0XHRcdFx0XHR2YWx1ZTogdmFsdWVzWyBpbmRleCBdLFxyXG5cdFx0XHRcdFx0XHRkb25lOiBpbmRleCArKyA+PSB2YWx1ZXMubGVuZ3RoXHJcblx0XHRcdFx0XHR9IClcclxuXHRcdFx0XHR9O1xyXG5cclxuXHRcdFx0fVxyXG5cdFx0fTtcclxuXHJcblx0XHRmb3IgKCBjb25zdCBpbnB1dCBvZiBsYXlvdXQuaW5wdXRzICkge1xyXG5cclxuXHRcdFx0aW5wdXRzWyBpbnB1dC5uYW1lIF0gPSBuZXcgUGFyYW1ldGVyTm9kZSggaW5wdXQudHlwZSwgaW5wdXQubmFtZSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvL1xyXG5cclxuXHRcdHNoYWRlck5vZGUubGF5b3V0ID0gbnVsbDtcclxuXHJcblx0XHRjb25zdCBjYWxsTm9kZSA9IHNoYWRlck5vZGUuY2FsbCggaW5wdXRzICk7XHJcblx0XHRjb25zdCBmbG93RGF0YSA9IHRoaXMuZmxvd1N0YWdlc05vZGUoIGNhbGxOb2RlLCBsYXlvdXQudHlwZSApO1xyXG5cclxuXHRcdHNoYWRlck5vZGUubGF5b3V0ID0gbGF5b3V0O1xyXG5cclxuXHRcdHJldHVybiBmbG93RGF0YTtcclxuXHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBSdW5zIHRoZSBub2RlIGZsb3cgdGhyb3VnaCBhbGwgdGhlIHN0ZXBzIG9mIGNyZWF0aW9uLCAnc2V0dXAnLCAnYW5hbHl6ZScsICdnZW5lcmF0ZScuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge05vZGV9IG5vZGUgLSBUaGUgbm9kZSB0byBleGVjdXRlLlxyXG5cdCAqIEBwYXJhbSB7U3RyaW5nP30gb3V0cHV0IC0gRXhwZWN0ZWQgb3V0cHV0IHR5cGUuIEZvciBleGFtcGxlICd2ZWMzJy5cclxuXHQgKiBAcmV0dXJuIHtPYmplY3R9XHJcblx0ICovXHJcblx0Zmxvd1N0YWdlc05vZGUoIG5vZGUsIG91dHB1dCA9IG51bGwgKSB7XHJcblxyXG5cdFx0Y29uc3QgcHJldmlvdXNGbG93ID0gdGhpcy5mbG93O1xyXG5cdFx0Y29uc3QgcHJldmlvdXNWYXJzID0gdGhpcy52YXJzO1xyXG5cdFx0Y29uc3QgcHJldmlvdXNDYWNoZSA9IHRoaXMuY2FjaGU7XHJcblx0XHRjb25zdCBwcmV2aW91c0J1aWxkU3RhZ2UgPSB0aGlzLmJ1aWxkU3RhZ2U7XHJcblx0XHRjb25zdCBwcmV2aW91c1N0YWNrID0gdGhpcy5zdGFjaztcclxuXHJcblx0XHRjb25zdCBmbG93ID0ge1xyXG5cdFx0XHRjb2RlOiAnJ1xyXG5cdFx0fTtcclxuXHJcblx0XHR0aGlzLmZsb3cgPSBmbG93O1xyXG5cdFx0dGhpcy52YXJzID0ge307XHJcblx0XHR0aGlzLmNhY2hlID0gbmV3IE5vZGVDYWNoZSgpO1xyXG5cdFx0dGhpcy5zdGFjayA9IHN0YWNrKCk7XHJcblxyXG5cdFx0Zm9yICggY29uc3QgYnVpbGRTdGFnZSBvZiBkZWZhdWx0QnVpbGRTdGFnZXMgKSB7XHJcblxyXG5cdFx0XHR0aGlzLnNldEJ1aWxkU3RhZ2UoIGJ1aWxkU3RhZ2UgKTtcclxuXHJcblx0XHRcdGZsb3cucmVzdWx0ID0gbm9kZS5idWlsZCggdGhpcywgb3V0cHV0ICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGZsb3cudmFycyA9IHRoaXMuZ2V0VmFycyggdGhpcy5zaGFkZXJTdGFnZSApO1xyXG5cclxuXHRcdHRoaXMuZmxvdyA9IHByZXZpb3VzRmxvdztcclxuXHRcdHRoaXMudmFycyA9IHByZXZpb3VzVmFycztcclxuXHRcdHRoaXMuY2FjaGUgPSBwcmV2aW91c0NhY2hlO1xyXG5cdFx0dGhpcy5zdGFjayA9IHByZXZpb3VzU3RhY2s7XHJcblxyXG5cdFx0dGhpcy5zZXRCdWlsZFN0YWdlKCBwcmV2aW91c0J1aWxkU3RhZ2UgKTtcclxuXHJcblx0XHRyZXR1cm4gZmxvdztcclxuXHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBSZXR1cm5zIHRoZSBuYXRpdmUgc2hhZGVyIG9wZXJhdG9yIG5hbWUgZm9yIGEgZ2l2ZW4gZ2VuZXJpYyBuYW1lLlxyXG5cdCAqIEl0IGlzIGEgc2ltaWxhciB0eXBlIG9mIG1ldGhvZCBsaWtlIHtAbGluayBOb2RlQnVpbGRlciNnZXRNZXRob2R9LlxyXG5cdCAqXHJcblx0ICogQGFic3RyYWN0XHJcblx0ICogQHBhcmFtIHtTdHJpbmd9IG9wIC0gVGhlIG9wZXJhdG9yIG5hbWUgdG8gcmVzb2x2ZS5cclxuXHQgKiBAcmV0dXJuIHtTdHJpbmd9IFRoZSByZXNvbHZlZCBvcGVyYXRvciBuYW1lLlxyXG5cdCAqL1xyXG5cdGdldEZ1bmN0aW9uT3BlcmF0b3IoIC8qIG9wICovICkge1xyXG5cclxuXHRcdHJldHVybiBudWxsO1xyXG5cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEdlbmVyYXRlcyBhIGNvZGUgZmxvdyBiYXNlZCBvbiBhIGNoaWxkIE5vZGUuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge05vZGV9IG5vZGUgLSBUaGUgbm9kZSB0byBleGVjdXRlLlxyXG5cdCAqIEBwYXJhbSB7U3RyaW5nP30gb3V0cHV0IC0gRXhwZWN0ZWQgb3V0cHV0IHR5cGUuIEZvciBleGFtcGxlICd2ZWMzJy5cclxuXHQgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBjb2RlIGZsb3cuXHJcblx0ICovXHJcblx0Zmxvd0NoaWxkTm9kZSggbm9kZSwgb3V0cHV0ID0gbnVsbCApIHtcclxuXHJcblx0XHRjb25zdCBwcmV2aW91c0Zsb3cgPSB0aGlzLmZsb3c7XHJcblxyXG5cdFx0Y29uc3QgZmxvdyA9IHtcclxuXHRcdFx0Y29kZTogJydcclxuXHRcdH07XHJcblxyXG5cdFx0dGhpcy5mbG93ID0gZmxvdztcclxuXHJcblx0XHRmbG93LnJlc3VsdCA9IG5vZGUuYnVpbGQoIHRoaXMsIG91dHB1dCApO1xyXG5cclxuXHRcdHRoaXMuZmxvdyA9IHByZXZpb3VzRmxvdztcclxuXHJcblx0XHRyZXR1cm4gZmxvdztcclxuXHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBFeGVjdXRlcyBhIGZsb3cgb2YgY29kZSBpbiBhIGRpZmZlcmVudCBzdGFnZS5cclxuXHQgKlxyXG5cdCAqIFNvbWUgbm9kZXMgbGlrZSBgdmFyeWluZygpYCBoYXZlIHRoZSBhYmlsaXR5IHRvIGNvbXB1dGUgY29kZSBpbiB2ZXJ0ZXgtc3RhZ2UgYW5kXHJcblx0ICogcmV0dXJuIHRoZSB2YWx1ZSBpbiBmcmFnbWVudC1zdGFnZSBldmVuIGlmIGl0IGlzIGJlaW5nIGV4ZWN1dGVkIGluIGFuIGlucHV0IGZyYWdtZW50LlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHsoJ3ZlcnRleCd8J2ZyYWdtZW50J3wnY29tcHV0ZSd8J2FueScpfSBzaGFkZXJTdGFnZSAtIFRoZSBzaGFkZXIgc3RhZ2UuXHJcblx0ICogQHBhcmFtIHtOb2RlfSBub2RlIC0gVGhlIG5vZGUgdG8gZXhlY3V0ZS5cclxuXHQgKiBAcGFyYW0ge1N0cmluZz99IG91dHB1dCAtIEV4cGVjdGVkIG91dHB1dCB0eXBlLiBGb3IgZXhhbXBsZSAndmVjMycuXHJcblx0ICogQHBhcmFtIHtTdHJpbmc/fSBwcm9wZXJ0eU5hbWUgLSBUaGUgcHJvcGVydHkgbmFtZSB0byBhc3NpZ24gdGhlIHJlc3VsdC5cclxuXHQgKiBAcmV0dXJuIHtPYmplY3R9XHJcblx0ICovXHJcblx0Zmxvd05vZGVGcm9tU2hhZGVyU3RhZ2UoIHNoYWRlclN0YWdlLCBub2RlLCBvdXRwdXQgPSBudWxsLCBwcm9wZXJ0eU5hbWUgPSBudWxsICkge1xyXG5cclxuXHRcdGNvbnN0IHByZXZpb3VzU2hhZGVyU3RhZ2UgPSB0aGlzLnNoYWRlclN0YWdlO1xyXG5cclxuXHRcdHRoaXMuc2V0U2hhZGVyU3RhZ2UoIHNoYWRlclN0YWdlICk7XHJcblxyXG5cdFx0Y29uc3QgZmxvd0RhdGEgPSB0aGlzLmZsb3dDaGlsZE5vZGUoIG5vZGUsIG91dHB1dCApO1xyXG5cclxuXHRcdGlmICggcHJvcGVydHlOYW1lICE9PSBudWxsICkge1xyXG5cclxuXHRcdFx0Zmxvd0RhdGEuY29kZSArPSBgJHsgdGhpcy50YWIgKyBwcm9wZXJ0eU5hbWUgfSA9ICR7IGZsb3dEYXRhLnJlc3VsdCB9O1xcbmA7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuZmxvd0NvZGVbIHNoYWRlclN0YWdlIF0gPSB0aGlzLmZsb3dDb2RlWyBzaGFkZXJTdGFnZSBdICsgZmxvd0RhdGEuY29kZTtcclxuXHJcblx0XHR0aGlzLnNldFNoYWRlclN0YWdlKCBwcmV2aW91c1NoYWRlclN0YWdlICk7XHJcblxyXG5cdFx0cmV0dXJuIGZsb3dEYXRhO1xyXG5cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFJldHVybnMgYW4gYXJyYXkgaG9sZGluZyBhbGwgbm9kZSBhdHRyaWJ1dGVzIG9mIHRoaXMgbm9kZSBidWlsZGVyLlxyXG5cdCAqXHJcblx0ICogQHJldHVybiB7QXJyYXk8Tm9kZUF0dHJpYnV0ZT59IFRoZSBub2RlIGF0dHJpYnV0ZXMgb2YgdGhpcyBidWlsZGVyLlxyXG5cdCAqL1xyXG5cdGdldEF0dHJpYnV0ZXNBcnJheSgpIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5hdHRyaWJ1dGVzLmNvbmNhdCggdGhpcy5idWZmZXJBdHRyaWJ1dGVzICk7XHJcblxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogUmV0dXJucyB0aGUgYXR0cmlidXRlIGRlZmluaXRpb25zIGFzIGEgc2hhZGVyIHN0cmluZyBmb3IgdGhlIGdpdmVuIHNoYWRlciBzdGFnZS5cclxuXHQgKlxyXG5cdCAqIEBhYnN0cmFjdFxyXG5cdCAqIEBwYXJhbSB7KCd2ZXJ0ZXgnfCdmcmFnbWVudCd8J2NvbXB1dGUnfCdhbnknKX0gc2hhZGVyU3RhZ2UgLSBUaGUgc2hhZGVyIHN0YWdlLlxyXG5cdCAqIEByZXR1cm4ge1N0cmluZ30gVGhlIGF0dHJpYnV0ZSBjb2RlIHNlY3Rpb24uXHJcblx0ICovXHJcblx0Z2V0QXR0cmlidXRlcyggLypzaGFkZXJTdGFnZSovICkge1xyXG5cclxuXHRcdGNvbnNvbGUud2FybiggJ0Fic3RyYWN0IGZ1bmN0aW9uLicgKTtcclxuXHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBSZXR1cm5zIHRoZSB2YXJ5aW5nIGRlZmluaXRpb25zIGFzIGEgc2hhZGVyIHN0cmluZyBmb3IgdGhlIGdpdmVuIHNoYWRlciBzdGFnZS5cclxuXHQgKlxyXG5cdCAqIEBhYnN0cmFjdFxyXG5cdCAqIEBwYXJhbSB7KCd2ZXJ0ZXgnfCdmcmFnbWVudCd8J2NvbXB1dGUnfCdhbnknKX0gc2hhZGVyU3RhZ2UgLSBUaGUgc2hhZGVyIHN0YWdlLlxyXG5cdCAqIEByZXR1cm4ge1N0cmluZ30gVGhlIHZhcnlpbmcgY29kZSBzZWN0aW9uLlxyXG5cdCAqL1xyXG5cdGdldFZhcnlpbmdzKCAvKnNoYWRlclN0YWdlKi8gKSB7XHJcblxyXG5cdFx0Y29uc29sZS53YXJuKCAnQWJzdHJhY3QgZnVuY3Rpb24uJyApO1xyXG5cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFJldHVybnMgYSBzaW5nbGUgdmFyaWFibGUgZGVmaW5pdGlvbiBhcyBhIHNoYWRlciBzdHJpbmcgZm9yIHRoZSBnaXZlbiB2YXJpYWJsZSB0eXBlIGFuZCBuYW1lLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgLSBUaGUgdmFyaWFibGUncyB0eXBlLlxyXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIC0gVGhlIHZhcmlhYmxlJ3MgbmFtZS5cclxuXHQgKiBAcmV0dXJuIHtTdHJpbmd9IFRoZSBzaGFkZXIgc3RyaW5nLlxyXG5cdCAqL1xyXG5cdGdldFZhciggdHlwZSwgbmFtZSApIHtcclxuXHJcblx0XHRyZXR1cm4gYCR7IHRoaXMuZ2V0VHlwZSggdHlwZSApIH0gJHsgbmFtZSB9YDtcclxuXHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBSZXR1cm5zIHRoZSB2YXJpYWJsZSBkZWZpbml0aW9ucyBhcyBhIHNoYWRlciBzdHJpbmcgZm9yIHRoZSBnaXZlbiBzaGFkZXIgc3RhZ2UuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0geygndmVydGV4J3wnZnJhZ21lbnQnfCdjb21wdXRlJ3wnYW55Jyl9IHNoYWRlclN0YWdlIC0gVGhlIHNoYWRlciBzdGFnZS5cclxuXHQgKiBAcmV0dXJuIHtTdHJpbmd9IFRoZSB2YXJpYWJsZSBjb2RlIHNlY3Rpb24uXHJcblx0ICovXHJcblx0Z2V0VmFycyggc2hhZGVyU3RhZ2UgKSB7XHJcblxyXG5cdFx0bGV0IHNuaXBwZXQgPSAnJztcclxuXHJcblx0XHRjb25zdCB2YXJzID0gdGhpcy52YXJzWyBzaGFkZXJTdGFnZSBdO1xyXG5cclxuXHRcdGlmICggdmFycyAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0Zm9yICggY29uc3QgdmFyaWFibGUgb2YgdmFycyApIHtcclxuXHJcblx0XHRcdFx0c25pcHBldCArPSBgJHsgdGhpcy5nZXRWYXIoIHZhcmlhYmxlLnR5cGUsIHZhcmlhYmxlLm5hbWUgKSB9OyBgO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gc25pcHBldDtcclxuXHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBSZXR1cm5zIHRoZSB1bmlmb3JtIGRlZmluaXRpb25zIGFzIGEgc2hhZGVyIHN0cmluZyBmb3IgdGhlIGdpdmVuIHNoYWRlciBzdGFnZS5cclxuXHQgKlxyXG5cdCAqIEBhYnN0cmFjdFxyXG5cdCAqIEBwYXJhbSB7KCd2ZXJ0ZXgnfCdmcmFnbWVudCd8J2NvbXB1dGUnfCdhbnknKX0gc2hhZGVyU3RhZ2UgLSBUaGUgc2hhZGVyIHN0YWdlLlxyXG5cdCAqIEByZXR1cm4ge1N0cmluZ30gVGhlIHVuaWZvcm0gY29kZSBzZWN0aW9uLlxyXG5cdCAqL1xyXG5cdGdldFVuaWZvcm1zKCAvKnNoYWRlclN0YWdlKi8gKSB7XHJcblxyXG5cdFx0Y29uc29sZS53YXJuKCAnQWJzdHJhY3QgZnVuY3Rpb24uJyApO1xyXG5cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFJldHVybnMgdGhlIG5hdGl2ZSBjb2RlIGRlZmluaXRpb25zIGFzIGEgc2hhZGVyIHN0cmluZyBmb3IgdGhlIGdpdmVuIHNoYWRlciBzdGFnZS5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7KCd2ZXJ0ZXgnfCdmcmFnbWVudCd8J2NvbXB1dGUnfCdhbnknKX0gc2hhZGVyU3RhZ2UgLSBUaGUgc2hhZGVyIHN0YWdlLlxyXG5cdCAqIEByZXR1cm4ge1N0cmluZ30gVGhlIG5hdGl2ZSBjb2RlIHNlY3Rpb24uXHJcblx0ICovXHJcblx0Z2V0Q29kZXMoIHNoYWRlclN0YWdlICkge1xyXG5cclxuXHRcdGNvbnN0IGNvZGVzID0gdGhpcy5jb2Rlc1sgc2hhZGVyU3RhZ2UgXTtcclxuXHJcblx0XHRsZXQgY29kZSA9ICcnO1xyXG5cclxuXHRcdGlmICggY29kZXMgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdGZvciAoIGNvbnN0IG5vZGVDb2RlIG9mIGNvZGVzICkge1xyXG5cclxuXHRcdFx0XHRjb2RlICs9IG5vZGVDb2RlLmNvZGUgKyAnXFxuJztcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGNvZGU7XHJcblxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogUmV0dXJucyB0aGUgaGFzaCBvZiB0aGlzIG5vZGUgYnVpbGRlci5cclxuXHQgKlxyXG5cdCAqIEByZXR1cm4ge1N0cmluZ30gVGhlIGhhc2guXHJcblx0ICovXHJcblx0Z2V0SGFzaCgpIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy52ZXJ0ZXhTaGFkZXIgKyB0aGlzLmZyYWdtZW50U2hhZGVyICsgdGhpcy5jb21wdXRlU2hhZGVyO1xyXG5cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFNldHMgdGhlIGN1cnJlbnQgc2hhZGVyIHN0YWdlLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHsoJ3ZlcnRleCd8J2ZyYWdtZW50J3wnY29tcHV0ZSd8J2FueScpP30gc2hhZGVyU3RhZ2UgLSBUaGUgc2hhZGVyIHN0YWdlIHRvIHNldC5cclxuXHQgKi9cclxuXHRzZXRTaGFkZXJTdGFnZSggc2hhZGVyU3RhZ2UgKSB7XHJcblxyXG5cdFx0dGhpcy5zaGFkZXJTdGFnZSA9IHNoYWRlclN0YWdlO1xyXG5cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFJldHVybnMgdGhlIGN1cnJlbnQgc2hhZGVyIHN0YWdlLlxyXG5cdCAqXHJcblx0ICogQHJldHVybiB7KCd2ZXJ0ZXgnfCdmcmFnbWVudCd8J2NvbXB1dGUnfCdhbnknKT99IFRoZSBjdXJyZW50IHNoYWRlciBzdGFnZS5cclxuXHQgKi9cclxuXHRnZXRTaGFkZXJTdGFnZSgpIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5zaGFkZXJTdGFnZTtcclxuXHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBTZXRzIHRoZSBjdXJyZW50IGJ1aWxkIHN0YWdlLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHsoJ3NldHVwJ3wnYW5hbHl6ZSd8J2dlbmVyYXRlJyk/fSBidWlsZFN0YWdlIC0gVGhlIGJ1aWxkIHN0YWdlIHRvIHNldC5cclxuXHQgKi9cclxuXHRzZXRCdWlsZFN0YWdlKCBidWlsZFN0YWdlICkge1xyXG5cclxuXHRcdHRoaXMuYnVpbGRTdGFnZSA9IGJ1aWxkU3RhZ2U7XHJcblxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogUmV0dXJucyB0aGUgY3VycmVudCBidWlsZCBzdGFnZS5cclxuXHQgKlxyXG5cdCAqIEByZXR1cm4geygnc2V0dXAnfCdhbmFseXplJ3wnZ2VuZXJhdGUnKT99IFRoZSBjdXJyZW50IGJ1aWxkIHN0YWdlLlxyXG5cdCAqL1xyXG5cdGdldEJ1aWxkU3RhZ2UoKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuYnVpbGRTdGFnZTtcclxuXHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBDb250cm9scyB0aGUgY29kZSBidWlsZCBvZiB0aGUgc2hhZGVyIHN0YWdlcy5cclxuXHQgKlxyXG5cdCAqIEBhYnN0cmFjdFxyXG5cdCAqL1xyXG5cdGJ1aWxkQ29kZSgpIHtcclxuXHJcblx0XHRjb25zb2xlLndhcm4oICdBYnN0cmFjdCBmdW5jdGlvbi4nICk7XHJcblxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogQ2VudHJhbCBidWlsZCBtZXRob2Qgd2hpY2ggY29udHJvbHMgdGhlIGJ1aWxkIGZvciB0aGUgZ2l2ZW4gb2JqZWN0LlxyXG5cdCAqXHJcblx0ICogQHJldHVybiB7Tm9kZUJ1aWxkZXJ9IEEgcmVmZXJlbmNlIHRvIHRoaXMgbm9kZSBidWlsZGVyLlxyXG5cdCAqL1xyXG5cdGJ1aWxkKCkge1xyXG5cclxuXHRcdGNvbnN0IHsgb2JqZWN0LCBtYXRlcmlhbCwgcmVuZGVyZXIgfSA9IHRoaXM7XHJcblxyXG5cdFx0aWYgKCBtYXRlcmlhbCAhPT0gbnVsbCApIHtcclxuXHJcblx0XHRcdGxldCBub2RlTWF0ZXJpYWwgPSByZW5kZXJlci5saWJyYXJ5LmZyb21NYXRlcmlhbCggbWF0ZXJpYWwgKTtcclxuXHJcblx0XHRcdGlmICggbm9kZU1hdGVyaWFsID09PSBudWxsICkge1xyXG5cclxuXHRcdFx0XHRjb25zb2xlLmVycm9yKCBgTm9kZU1hdGVyaWFsOiBNYXRlcmlhbCBcIiR7IG1hdGVyaWFsLnR5cGUgfVwiIGlzIG5vdCBjb21wYXRpYmxlLmAgKTtcclxuXHJcblx0XHRcdFx0bm9kZU1hdGVyaWFsID0gbmV3IE5vZGVNYXRlcmlhbCgpO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0bm9kZU1hdGVyaWFsLmJ1aWxkKCB0aGlzICk7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdHRoaXMuYWRkRmxvdyggJ2NvbXB1dGUnLCBvYmplY3QgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gc2V0dXAoKSAtPiBzdGFnZSAxOiBjcmVhdGUgcG9zc2libGUgbmV3IG5vZGVzIGFuZCByZXR1cm5zIGFuIG91dHB1dCByZWZlcmVuY2Ugbm9kZVxyXG5cdFx0Ly8gYW5hbHl6ZSgpICAgLT4gc3RhZ2UgMjogYW5hbHl6ZSBub2RlcyB0byBwb3NzaWJsZSBvcHRpbWl6YXRpb24gYW5kIHZhbGlkYXRpb25cclxuXHRcdC8vIGdlbmVyYXRlKCkgIC0+IHN0YWdlIDM6IGdlbmVyYXRlIHNoYWRlclxyXG5cclxuXHRcdGZvciAoIGNvbnN0IGJ1aWxkU3RhZ2Ugb2YgZGVmYXVsdEJ1aWxkU3RhZ2VzICkge1xyXG5cclxuXHRcdFx0dGhpcy5zZXRCdWlsZFN0YWdlKCBidWlsZFN0YWdlICk7XHJcblxyXG5cdFx0XHRpZiAoIHRoaXMuY29udGV4dC52ZXJ0ZXggJiYgdGhpcy5jb250ZXh0LnZlcnRleC5pc05vZGUgKSB7XHJcblxyXG5cdFx0XHRcdHRoaXMuZmxvd05vZGVGcm9tU2hhZGVyU3RhZ2UoICd2ZXJ0ZXgnLCB0aGlzLmNvbnRleHQudmVydGV4ICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRmb3IgKCBjb25zdCBzaGFkZXJTdGFnZSBvZiBzaGFkZXJTdGFnZXMgKSB7XHJcblxyXG5cdFx0XHRcdHRoaXMuc2V0U2hhZGVyU3RhZ2UoIHNoYWRlclN0YWdlICk7XHJcblxyXG5cdFx0XHRcdGNvbnN0IGZsb3dOb2RlcyA9IHRoaXMuZmxvd05vZGVzWyBzaGFkZXJTdGFnZSBdO1xyXG5cclxuXHRcdFx0XHRmb3IgKCBjb25zdCBub2RlIG9mIGZsb3dOb2RlcyApIHtcclxuXHJcblx0XHRcdFx0XHRpZiAoIGJ1aWxkU3RhZ2UgPT09ICdnZW5lcmF0ZScgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHR0aGlzLmZsb3dOb2RlKCBub2RlICk7XHJcblxyXG5cdFx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHRcdG5vZGUuYnVpbGQoIHRoaXMgKTtcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5zZXRCdWlsZFN0YWdlKCBudWxsICk7XHJcblx0XHR0aGlzLnNldFNoYWRlclN0YWdlKCBudWxsICk7XHJcblxyXG5cdFx0Ly8gc3RhZ2UgNDogYnVpbGQgY29kZSBmb3IgYSBzcGVjaWZpYyBvdXRwdXRcclxuXHJcblx0XHR0aGlzLmJ1aWxkQ29kZSgpO1xyXG5cdFx0dGhpcy5idWlsZFVwZGF0ZU5vZGVzKCk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogUmV0dXJucyBhIHVuaWZvcm0gcmVwcmVzZW50YXRpb24gd2hpY2ggaXMgbGF0ZXIgdXNlZCBmb3IgVUJPIGdlbmVyYXRpb24gYW5kIHJlbmRlcmluZy5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7Tm9kZVVuaWZvcm19IHVuaWZvcm1Ob2RlIC0gVGhlIHVuaWZvcm0gbm9kZS5cclxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSAtIFRoZSByZXF1ZXN0ZWQgdHlwZS5cclxuXHQgKiBAcmV0dXJuIHtVbmlmb3JtfSBUaGUgdW5pZm9ybS5cclxuXHQgKi9cclxuXHRnZXROb2RlVW5pZm9ybSggdW5pZm9ybU5vZGUsIHR5cGUgKSB7XHJcblxyXG5cdFx0aWYgKCB0eXBlID09PSAnZmxvYXQnIHx8IHR5cGUgPT09ICdpbnQnIHx8IHR5cGUgPT09ICd1aW50JyApIHJldHVybiBuZXcgTnVtYmVyTm9kZVVuaWZvcm0oIHVuaWZvcm1Ob2RlICk7XHJcblx0XHRpZiAoIHR5cGUgPT09ICd2ZWMyJyB8fCB0eXBlID09PSAnaXZlYzInIHx8IHR5cGUgPT09ICd1dmVjMicgKSByZXR1cm4gbmV3IFZlY3RvcjJOb2RlVW5pZm9ybSggdW5pZm9ybU5vZGUgKTtcclxuXHRcdGlmICggdHlwZSA9PT0gJ3ZlYzMnIHx8IHR5cGUgPT09ICdpdmVjMycgfHwgdHlwZSA9PT0gJ3V2ZWMzJyApIHJldHVybiBuZXcgVmVjdG9yM05vZGVVbmlmb3JtKCB1bmlmb3JtTm9kZSApO1xyXG5cdFx0aWYgKCB0eXBlID09PSAndmVjNCcgfHwgdHlwZSA9PT0gJ2l2ZWM0JyB8fCB0eXBlID09PSAndXZlYzQnICkgcmV0dXJuIG5ldyBWZWN0b3I0Tm9kZVVuaWZvcm0oIHVuaWZvcm1Ob2RlICk7XHJcblx0XHRpZiAoIHR5cGUgPT09ICdjb2xvcicgKSByZXR1cm4gbmV3IENvbG9yTm9kZVVuaWZvcm0oIHVuaWZvcm1Ob2RlICk7XHJcblx0XHRpZiAoIHR5cGUgPT09ICdtYXQzJyApIHJldHVybiBuZXcgTWF0cml4M05vZGVVbmlmb3JtKCB1bmlmb3JtTm9kZSApO1xyXG5cdFx0aWYgKCB0eXBlID09PSAnbWF0NCcgKSByZXR1cm4gbmV3IE1hdHJpeDROb2RlVW5pZm9ybSggdW5pZm9ybU5vZGUgKTtcclxuXHJcblx0XHR0aHJvdyBuZXcgRXJyb3IoIGBVbmlmb3JtIFwiJHt0eXBlfVwiIG5vdCBkZWNsYXJlZC5gICk7XHJcblxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogRm9ybWF0cyB0aGUgZ2l2ZW4gc2hhZGVyIHNuaXBwZXQgZnJvbSBhIGdpdmVuIHR5cGUgaW50byBhbm90aGVyIG9uZS4gRS5nLlxyXG5cdCAqIHRoaXMgbWV0aG9kIG1pZ2h0IGJlIHVzZWQgdG8gY29udmVydCBhIHNpbXBsZSBmbG9hdCBzdHJpbmcgYFwiMS4wXCJgIGludG8gYVxyXG5cdCAqIGB2ZWMzYCByZXByZXNlbnRhdGlvbjogYFwidmVjMzxmMzI+KCAxLjAgKVwiYC5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBzbmlwcGV0IC0gVGhlIHNoYWRlciBzbmlwcGV0LlxyXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBmcm9tVHlwZSAtIFRoZSBzb3VyY2UgdHlwZS5cclxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdG9UeXBlIC0gVGhlIHRhcmdldCB0eXBlLlxyXG5cdCAqIEByZXR1cm4ge1N0cmluZ30gVGhlIHVwZGF0ZWQgc2hhZGVyIHN0cmluZy5cclxuXHQgKi9cclxuXHRmb3JtYXQoIHNuaXBwZXQsIGZyb21UeXBlLCB0b1R5cGUgKSB7XHJcblxyXG5cdFx0ZnJvbVR5cGUgPSB0aGlzLmdldFZlY3RvclR5cGUoIGZyb21UeXBlICk7XHJcblx0XHR0b1R5cGUgPSB0aGlzLmdldFZlY3RvclR5cGUoIHRvVHlwZSApO1xyXG5cclxuXHRcdGlmICggZnJvbVR5cGUgPT09IHRvVHlwZSB8fCB0b1R5cGUgPT09IG51bGwgfHwgdGhpcy5pc1JlZmVyZW5jZSggdG9UeXBlICkgKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gc25pcHBldDtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Y29uc3QgZnJvbVR5cGVMZW5ndGggPSB0aGlzLmdldFR5cGVMZW5ndGgoIGZyb21UeXBlICk7XHJcblx0XHRjb25zdCB0b1R5cGVMZW5ndGggPSB0aGlzLmdldFR5cGVMZW5ndGgoIHRvVHlwZSApO1xyXG5cclxuXHRcdGlmICggZnJvbVR5cGVMZW5ndGggPT09IDE2ICYmIHRvVHlwZUxlbmd0aCA9PT0gOSApIHtcclxuXHJcblx0XHRcdHJldHVybiBgJHsgdGhpcy5nZXRUeXBlKCB0b1R5cGUgKSB9KCR7IHNuaXBwZXQgfVswXS54eXosICR7IHNuaXBwZXQgfVsxXS54eXosICR7IHNuaXBwZXQgfVsyXS54eXopYDtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBmcm9tVHlwZUxlbmd0aCA9PT0gOSAmJiB0b1R5cGVMZW5ndGggPT09IDQgKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gYCR7IHRoaXMuZ2V0VHlwZSggdG9UeXBlICkgfSgkeyBzbmlwcGV0IH1bMF0ueHksICR7IHNuaXBwZXQgfVsxXS54eSlgO1xyXG5cclxuXHRcdH1cclxuXHJcblxyXG5cdFx0aWYgKCBmcm9tVHlwZUxlbmd0aCA+IDQgKSB7IC8vIGZyb21UeXBlIGlzIG1hdHJpeC1saWtlXHJcblxyXG5cdFx0XHQvLyBAVE9ETzogaWdub3JlIGZvciBub3dcclxuXHJcblx0XHRcdHJldHVybiBzbmlwcGV0O1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIHRvVHlwZUxlbmd0aCA+IDQgfHwgdG9UeXBlTGVuZ3RoID09PSAwICkgeyAvLyB0b1R5cGUgaXMgbWF0cml4LWxpa2Ugb3IgdW5rbm93blxyXG5cclxuXHRcdFx0Ly8gQFRPRE86IGlnbm9yZSBmb3Igbm93XHJcblxyXG5cdFx0XHRyZXR1cm4gc25pcHBldDtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBmcm9tVHlwZUxlbmd0aCA9PT0gdG9UeXBlTGVuZ3RoICkge1xyXG5cclxuXHRcdFx0cmV0dXJuIGAkeyB0aGlzLmdldFR5cGUoIHRvVHlwZSApIH0oICR7IHNuaXBwZXQgfSApYDtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBmcm9tVHlwZUxlbmd0aCA+IHRvVHlwZUxlbmd0aCApIHtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzLmZvcm1hdCggYCR7IHNuaXBwZXQgfS4keyAneHl6Jy5zbGljZSggMCwgdG9UeXBlTGVuZ3RoICkgfWAsIHRoaXMuZ2V0VHlwZUZyb21MZW5ndGgoIHRvVHlwZUxlbmd0aCwgdGhpcy5nZXRDb21wb25lbnRUeXBlKCBmcm9tVHlwZSApICksIHRvVHlwZSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIHRvVHlwZUxlbmd0aCA9PT0gNCAmJiBmcm9tVHlwZUxlbmd0aCA+IDEgKSB7IC8vIHRvVHlwZSBpcyB2ZWM0LWxpa2VcclxuXHJcblx0XHRcdHJldHVybiBgJHsgdGhpcy5nZXRUeXBlKCB0b1R5cGUgKSB9KCAkeyB0aGlzLmZvcm1hdCggc25pcHBldCwgZnJvbVR5cGUsICd2ZWMzJyApIH0sIDEuMCApYDtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBmcm9tVHlwZUxlbmd0aCA9PT0gMiApIHsgLy8gZnJvbVR5cGUgaXMgdmVjMi1saWtlIGFuZCB0b1R5cGUgaXMgdmVjMy1saWtlXHJcblxyXG5cdFx0XHRyZXR1cm4gYCR7IHRoaXMuZ2V0VHlwZSggdG9UeXBlICkgfSggJHsgdGhpcy5mb3JtYXQoIHNuaXBwZXQsIGZyb21UeXBlLCAndmVjMicgKSB9LCAwLjAgKWA7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggZnJvbVR5cGVMZW5ndGggPT09IDEgJiYgdG9UeXBlTGVuZ3RoID4gMSAmJiBmcm9tVHlwZSAhPT0gdGhpcy5nZXRDb21wb25lbnRUeXBlKCB0b1R5cGUgKSApIHsgLy8gZnJvbVR5cGUgaXMgZmxvYXQtbGlrZVxyXG5cclxuXHRcdFx0Ly8gY29udmVydCBhIG51bWJlciB2YWx1ZSB0byB2ZWN0b3IgdHlwZSwgZS5nOlxyXG5cdFx0XHQvLyB2ZWMzKCAxdSApIC0+IHZlYzMoIGZsb2F0KCAxdSApIClcclxuXHJcblx0XHRcdHNuaXBwZXQgPSBgJHsgdGhpcy5nZXRUeXBlKCB0aGlzLmdldENvbXBvbmVudFR5cGUoIHRvVHlwZSApICkgfSggJHsgc25pcHBldCB9IClgO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gYCR7IHRoaXMuZ2V0VHlwZSggdG9UeXBlICkgfSggJHsgc25pcHBldCB9IClgOyAvLyBmcm9tVHlwZSBpcyBmbG9hdC1saWtlXHJcblxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogUmV0dXJucyBhIHNpZ25hdHVyZSB3aXRoIHRoZSBlbmdpbmUncyBjdXJyZW50IHJldmlzaW9uLlxyXG5cdCAqXHJcblx0ICogQHJldHVybiB7U3RyaW5nfSBUaGUgc2lnbmF0dXJlLlxyXG5cdCAqL1xyXG5cdGdldFNpZ25hdHVyZSgpIHtcclxuXHJcblx0XHRyZXR1cm4gYC8vIFRocmVlLmpzIHIkeyBSRVZJU0lPTiB9IC0gTm9kZSBTeXN0ZW1cXG5gO1xyXG5cclxuXHR9XHJcblxyXG5cdC8vIGRlcHJlY2F0ZWRcclxuXHJcblx0Y3JlYXRlTm9kZU1hdGVyaWFsKCB0eXBlID0gJ05vZGVNYXRlcmlhbCcgKSB7IC8vIEBkZXByZWNhdGVkLCByMTY4XHJcblxyXG5cdFx0dGhyb3cgbmV3IEVycm9yKCBgVEhSRUUuTm9kZUJ1aWxkZXI6IGNyZWF0ZU5vZGVNYXRlcmlhbCgpIHdhcyBkZXByZWNhdGVkLiBVc2UgbmV3ICR7IHR5cGUgfSgpIGluc3RlYWQuYCApO1xyXG5cclxuXHR9XHJcblxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBOb2RlQnVpbGRlcjtcclxuIiwiaW1wb3J0IHsgTm9kZVVwZGF0ZVR5cGUgfSBmcm9tICcuL2NvbnN0YW50cy5qcyc7XHJcblxyXG4vKipcclxuICogTWFuYWdlbWVudCBjbGFzcyBmb3IgdXBkYXRpbmcgbm9kZXMuIFRoZSBtb2R1bGUgdHJhY2tzIG1ldHJpY3MgbGlrZVxyXG4gKiB0aGUgZWxhcHNlZCB0aW1lLCBkZWx0YSB0aW1lLCB0aGUgcmVuZGVyIGFuZCBmcmFtZSBJRCB0byBjb3JyZWN0bHlcclxuICogY2FsbCB0aGUgbm9kZSB1cGRhdGUgbWV0aG9kcyB7QGxpbmsgTm9kZSN1cGRhdGVCZWZvcmV9LCB7QGxpbmsgTm9kZSN1cGRhdGV9XHJcbiAqIGFuZCB7QGxpbmsgTm9kZSN1cGRhdGVBZnRlcn0gZGVwZW5kaW5nIG9uIHRoZSBub2RlJ3MgY29uZmlndXJhdGlvbi5cclxuICovXHJcbmNsYXNzIE5vZGVGcmFtZSB7XHJcblxyXG5cdC8qKlxyXG5cdCAqIENvbnN0cnVjdHMgYSBuZXcgbm9kZSBmYW1lLlxyXG5cdCAqL1xyXG5cdGNvbnN0cnVjdG9yKCkge1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogVGhlIGVsYXBzZWQgdGltZSBpbiBzZWNvbmRzLlxyXG5cdFx0ICpcclxuXHRcdCAqIEB0eXBlIHtOdW1iZXJ9XHJcblx0XHQgKiBAZGVmYXVsdCAwXHJcblx0XHQgKi9cclxuXHRcdHRoaXMudGltZSA9IDA7XHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBUaGUgZGVsdGEgdGltZSBpbiBzZWNvbmRzLlxyXG5cdFx0ICpcclxuXHRcdCAqIEB0eXBlIHtOdW1iZXJ9XHJcblx0XHQgKiBAZGVmYXVsdCAwXHJcblx0XHQgKi9cclxuXHRcdHRoaXMuZGVsdGFUaW1lID0gMDtcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIFRoZSBmcmFtZSBJRC5cclxuXHRcdCAqXHJcblx0XHQgKiBAdHlwZSB7TnVtYmVyfVxyXG5cdFx0ICogQGRlZmF1bHQgMFxyXG5cdFx0ICovXHJcblx0XHR0aGlzLmZyYW1lSWQgPSAwO1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogVGhlIHJlbmRlciBJRC5cclxuXHRcdCAqXHJcblx0XHQgKiBAdHlwZSB7TnVtYmVyfVxyXG5cdFx0ICogQGRlZmF1bHQgMFxyXG5cdFx0ICovXHJcblx0XHR0aGlzLnJlbmRlcklkID0gMDtcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIFVzZWQgdG8gY29udHJvbCB0aGUge0BsaW5rIE5vZGUjdXBkYXRlfSBjYWxsLlxyXG5cdFx0ICpcclxuXHRcdCAqIEB0eXBlIHtXZWFrTWFwPE5vZGUsIE9iamVjdD59XHJcblx0XHQgKi9cclxuXHRcdHRoaXMudXBkYXRlTWFwID0gbmV3IFdlYWtNYXAoKTtcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIFVzZWQgdG8gY29udHJvbCB0aGUge0BsaW5rIE5vZGUjdXBkYXRlQmVmb3JlfSBjYWxsLlxyXG5cdFx0ICpcclxuXHRcdCAqIEB0eXBlIHtXZWFrTWFwPE5vZGUsIE9iamVjdD59XHJcblx0XHQgKi9cclxuXHRcdHRoaXMudXBkYXRlQmVmb3JlTWFwID0gbmV3IFdlYWtNYXAoKTtcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIFVzZWQgdG8gY29udHJvbCB0aGUge0BsaW5rIE5vZGUjdXBkYXRlQWZ0ZXJ9IGNhbGwuXHJcblx0XHQgKlxyXG5cdFx0ICogQHR5cGUge1dlYWtNYXA8Tm9kZSwgT2JqZWN0Pn1cclxuXHRcdCAqL1xyXG5cdFx0dGhpcy51cGRhdGVBZnRlck1hcCA9IG5ldyBXZWFrTWFwKCk7XHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBBIHJlZmVyZW5jZSB0byB0aGUgY3VycmVudCByZW5kZXJlci5cclxuXHRcdCAqXHJcblx0XHQgKiBAdHlwZSB7UmVuZGVyZXI/fVxyXG5cdFx0ICogQGRlZmF1bHQgbnVsbFxyXG5cdFx0ICovXHJcblx0XHR0aGlzLnJlbmRlcmVyID0gbnVsbDtcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIEEgcmVmZXJlbmNlIHRvIHRoZSBjdXJyZW50IG1hdGVyaWFsLlxyXG5cdFx0ICpcclxuXHRcdCAqIEB0eXBlIHtNYXRlcmlhbD99XHJcblx0XHQgKiBAZGVmYXVsdCBudWxsXHJcblx0XHQgKi9cclxuXHRcdHRoaXMubWF0ZXJpYWwgPSBudWxsO1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogQSByZWZlcmVuY2UgdG8gdGhlIGN1cnJlbnQgY2FtZXJhLlxyXG5cdFx0ICpcclxuXHRcdCAqIEB0eXBlIHtDYW1lcmE/fVxyXG5cdFx0ICogQGRlZmF1bHQgbnVsbFxyXG5cdFx0ICovXHJcblx0XHR0aGlzLmNhbWVyYSA9IG51bGw7XHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBBIHJlZmVyZW5jZSB0byB0aGUgY3VycmVudCAzRCBvYmplY3QuXHJcblx0XHQgKlxyXG5cdFx0ICogQHR5cGUge09iamVjdDNEP31cclxuXHRcdCAqIEBkZWZhdWx0IG51bGxcclxuXHRcdCAqL1xyXG5cdFx0dGhpcy5vYmplY3QgPSBudWxsO1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogQSByZWZlcmVuY2UgdG8gdGhlIGN1cnJlbnQgc2NlbmUuXHJcblx0XHQgKlxyXG5cdFx0ICogQHR5cGUge1NjZW5lP31cclxuXHRcdCAqIEBkZWZhdWx0IG51bGxcclxuXHRcdCAqL1xyXG5cdFx0dGhpcy5zY2VuZSA9IG51bGw7XHJcblxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogUmV0dXJucyBhIGRpY3Rpb25hcnkgZm9yIGEgZ2l2ZW4gbm9kZSBhbmQgdXBkYXRlIG1hcCB3aGljaFxyXG5cdCAqIGlzIHVzZWQgdG8gY29ycmVjdGx5IGNhbGwgbm9kZSB1cGRhdGUgbWV0aG9kcyBwZXIgZnJhbWUgb3IgcmVuZGVyLlxyXG5cdCAqXHJcblx0ICogQHByaXZhdGVcclxuXHQgKiBAcGFyYW0ge1dlYWtNYXA8Tm9kZSwgT2JqZWN0Pn0gcmVmZXJlbmNlTWFwIC0gVGhlIHJlZmVyZW5jZSB3ZWFrIG1hcC5cclxuXHQgKiBAcGFyYW0ge05vZGV9IG5vZGVSZWYgLSBUaGUgcmVmZXJlbmNlIHRvIHRoZSBjdXJyZW50IG5vZGUuXHJcblx0ICogQHJldHVybiB7T2JqZWN0PFN0cmluZyxXZWFrTWFwPn0gVGhlIGRpY3Rpb25hcnkuXHJcblx0ICovXHJcblx0X2dldE1hcHMoIHJlZmVyZW5jZU1hcCwgbm9kZVJlZiApIHtcclxuXHJcblx0XHRsZXQgbWFwcyA9IHJlZmVyZW5jZU1hcC5nZXQoIG5vZGVSZWYgKTtcclxuXHJcblx0XHRpZiAoIG1hcHMgPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdG1hcHMgPSB7XHJcblx0XHRcdFx0cmVuZGVyTWFwOiBuZXcgV2Vha01hcCgpLFxyXG5cdFx0XHRcdGZyYW1lTWFwOiBuZXcgV2Vha01hcCgpXHJcblx0XHRcdH07XHJcblxyXG5cdFx0XHRyZWZlcmVuY2VNYXAuc2V0KCBub2RlUmVmLCBtYXBzICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBtYXBzO1xyXG5cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFRoaXMgbWV0aG9kIGV4ZWN1dGVzIHRoZSB7QGxpbmsgTm9kZSN1cGRhdGVCZWZvcmV9IGZvciB0aGUgZ2l2ZW4gbm9kZS5cclxuXHQgKiBJdCBtYWtlcyBzdXJlIHtAbGluayBOb2RlI3VwZGF0ZUJlZm9yZVR5cGV9IGlzIGhvbm9yZWQgbWVhbmluZyB0aGUgdXBkYXRlXHJcblx0ICogaXMgb25seSBleGVjdXRlZCBvbmNlIHBlciBmcmFtZSwgcmVuZGVyIG9yIG9iamVjdCBkZXBlbmRpbmcgb24gdGhlIHVwZGF0ZVxyXG5cdCAqIHR5cGUuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge05vZGV9IG5vZGUgLSBUaGUgbm9kZSB0aGF0IHNob3VsZCBiZSB1cGRhdGVkLlxyXG5cdCAqL1xyXG5cdHVwZGF0ZUJlZm9yZU5vZGUoIG5vZGUgKSB7XHJcblxyXG5cdFx0Y29uc3QgdXBkYXRlVHlwZSA9IG5vZGUuZ2V0VXBkYXRlQmVmb3JlVHlwZSgpO1xyXG5cdFx0Y29uc3QgcmVmZXJlbmNlID0gbm9kZS51cGRhdGVSZWZlcmVuY2UoIHRoaXMgKTtcclxuXHJcblx0XHRpZiAoIHVwZGF0ZVR5cGUgPT09IE5vZGVVcGRhdGVUeXBlLkZSQU1FICkge1xyXG5cclxuXHRcdFx0Y29uc3QgeyBmcmFtZU1hcCB9ID0gdGhpcy5fZ2V0TWFwcyggdGhpcy51cGRhdGVCZWZvcmVNYXAsIHJlZmVyZW5jZSApO1xyXG5cclxuXHRcdFx0aWYgKCBmcmFtZU1hcC5nZXQoIHJlZmVyZW5jZSApICE9PSB0aGlzLmZyYW1lSWQgKSB7XHJcblxyXG5cdFx0XHRcdGlmICggbm9kZS51cGRhdGVCZWZvcmUoIHRoaXMgKSAhPT0gZmFsc2UgKSB7XHJcblxyXG5cdFx0XHRcdFx0ZnJhbWVNYXAuc2V0KCByZWZlcmVuY2UsIHRoaXMuZnJhbWVJZCApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fSBlbHNlIGlmICggdXBkYXRlVHlwZSA9PT0gTm9kZVVwZGF0ZVR5cGUuUkVOREVSICkge1xyXG5cclxuXHRcdFx0Y29uc3QgeyByZW5kZXJNYXAgfSA9IHRoaXMuX2dldE1hcHMoIHRoaXMudXBkYXRlQmVmb3JlTWFwLCByZWZlcmVuY2UgKTtcclxuXHJcblx0XHRcdGlmICggcmVuZGVyTWFwLmdldCggcmVmZXJlbmNlICkgIT09IHRoaXMucmVuZGVySWQgKSB7XHJcblxyXG5cdFx0XHRcdGlmICggbm9kZS51cGRhdGVCZWZvcmUoIHRoaXMgKSAhPT0gZmFsc2UgKSB7XHJcblxyXG5cdFx0XHRcdFx0cmVuZGVyTWFwLnNldCggcmVmZXJlbmNlLCB0aGlzLnJlbmRlcklkICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9IGVsc2UgaWYgKCB1cGRhdGVUeXBlID09PSBOb2RlVXBkYXRlVHlwZS5PQkpFQ1QgKSB7XHJcblxyXG5cdFx0XHRub2RlLnVwZGF0ZUJlZm9yZSggdGhpcyApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBUaGlzIG1ldGhvZCBleGVjdXRlcyB0aGUge0BsaW5rIE5vZGUjdXBkYXRlQWZ0ZXJ9IGZvciB0aGUgZ2l2ZW4gbm9kZS5cclxuXHQgKiBJdCBtYWtlcyBzdXJlIHtAbGluayBOb2RlI3VwZGF0ZUFmdGVyVHlwZX0gaXMgaG9ub3JlZCBtZWFuaW5nIHRoZSB1cGRhdGVcclxuXHQgKiBpcyBvbmx5IGV4ZWN1dGVkIG9uY2UgcGVyIGZyYW1lLCByZW5kZXIgb3Igb2JqZWN0IGRlcGVuZGluZyBvbiB0aGUgdXBkYXRlXHJcblx0ICogdHlwZS5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7Tm9kZX0gbm9kZSAtIFRoZSBub2RlIHRoYXQgc2hvdWxkIGJlIHVwZGF0ZWQuXHJcblx0ICovXHJcblx0dXBkYXRlQWZ0ZXJOb2RlKCBub2RlICkge1xyXG5cclxuXHRcdGNvbnN0IHVwZGF0ZVR5cGUgPSBub2RlLmdldFVwZGF0ZUFmdGVyVHlwZSgpO1xyXG5cdFx0Y29uc3QgcmVmZXJlbmNlID0gbm9kZS51cGRhdGVSZWZlcmVuY2UoIHRoaXMgKTtcclxuXHJcblx0XHRpZiAoIHVwZGF0ZVR5cGUgPT09IE5vZGVVcGRhdGVUeXBlLkZSQU1FICkge1xyXG5cclxuXHRcdFx0Y29uc3QgeyBmcmFtZU1hcCB9ID0gdGhpcy5fZ2V0TWFwcyggdGhpcy51cGRhdGVBZnRlck1hcCwgcmVmZXJlbmNlICk7XHJcblxyXG5cdFx0XHRpZiAoIGZyYW1lTWFwLmdldCggcmVmZXJlbmNlICkgIT09IHRoaXMuZnJhbWVJZCApIHtcclxuXHJcblx0XHRcdFx0aWYgKCBub2RlLnVwZGF0ZUFmdGVyKCB0aGlzICkgIT09IGZhbHNlICkge1xyXG5cclxuXHRcdFx0XHRcdGZyYW1lTWFwLnNldCggcmVmZXJlbmNlLCB0aGlzLmZyYW1lSWQgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH0gZWxzZSBpZiAoIHVwZGF0ZVR5cGUgPT09IE5vZGVVcGRhdGVUeXBlLlJFTkRFUiApIHtcclxuXHJcblx0XHRcdGNvbnN0IHsgcmVuZGVyTWFwIH0gPSB0aGlzLl9nZXRNYXBzKCB0aGlzLnVwZGF0ZUFmdGVyTWFwLCByZWZlcmVuY2UgKTtcclxuXHJcblx0XHRcdGlmICggcmVuZGVyTWFwLmdldCggcmVmZXJlbmNlICkgIT09IHRoaXMucmVuZGVySWQgKSB7XHJcblxyXG5cdFx0XHRcdGlmICggbm9kZS51cGRhdGVBZnRlciggdGhpcyApICE9PSBmYWxzZSApIHtcclxuXHJcblx0XHRcdFx0XHRyZW5kZXJNYXAuc2V0KCByZWZlcmVuY2UsIHRoaXMucmVuZGVySWQgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH0gZWxzZSBpZiAoIHVwZGF0ZVR5cGUgPT09IE5vZGVVcGRhdGVUeXBlLk9CSkVDVCApIHtcclxuXHJcblx0XHRcdG5vZGUudXBkYXRlQWZ0ZXIoIHRoaXMgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogVGhpcyBtZXRob2QgZXhlY3V0ZXMgdGhlIHtAbGluayBOb2RlI3VwZGF0ZX0gZm9yIHRoZSBnaXZlbiBub2RlLlxyXG5cdCAqIEl0IG1ha2VzIHN1cmUge0BsaW5rIE5vZGUjdXBkYXRlVHlwZX0gaXMgaG9ub3JlZCBtZWFuaW5nIHRoZSB1cGRhdGVcclxuXHQgKiBpcyBvbmx5IGV4ZWN1dGVkIG9uY2UgcGVyIGZyYW1lLCByZW5kZXIgb3Igb2JqZWN0IGRlcGVuZGluZyBvbiB0aGUgdXBkYXRlXHJcblx0ICogdHlwZS5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7Tm9kZX0gbm9kZSAtIFRoZSBub2RlIHRoYXQgc2hvdWxkIGJlIHVwZGF0ZWQuXHJcblx0ICovXHJcblx0dXBkYXRlTm9kZSggbm9kZSApIHtcclxuXHJcblx0XHRjb25zdCB1cGRhdGVUeXBlID0gbm9kZS5nZXRVcGRhdGVUeXBlKCk7XHJcblx0XHRjb25zdCByZWZlcmVuY2UgPSBub2RlLnVwZGF0ZVJlZmVyZW5jZSggdGhpcyApO1xyXG5cclxuXHRcdGlmICggdXBkYXRlVHlwZSA9PT0gTm9kZVVwZGF0ZVR5cGUuRlJBTUUgKSB7XHJcblxyXG5cdFx0XHRjb25zdCB7IGZyYW1lTWFwIH0gPSB0aGlzLl9nZXRNYXBzKCB0aGlzLnVwZGF0ZU1hcCwgcmVmZXJlbmNlICk7XHJcblxyXG5cdFx0XHRpZiAoIGZyYW1lTWFwLmdldCggcmVmZXJlbmNlICkgIT09IHRoaXMuZnJhbWVJZCApIHtcclxuXHJcblx0XHRcdFx0aWYgKCBub2RlLnVwZGF0ZSggdGhpcyApICE9PSBmYWxzZSApIHtcclxuXHJcblx0XHRcdFx0XHRmcmFtZU1hcC5zZXQoIHJlZmVyZW5jZSwgdGhpcy5mcmFtZUlkICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9IGVsc2UgaWYgKCB1cGRhdGVUeXBlID09PSBOb2RlVXBkYXRlVHlwZS5SRU5ERVIgKSB7XHJcblxyXG5cdFx0XHRjb25zdCB7IHJlbmRlck1hcCB9ID0gdGhpcy5fZ2V0TWFwcyggdGhpcy51cGRhdGVNYXAsIHJlZmVyZW5jZSApO1xyXG5cclxuXHRcdFx0aWYgKCByZW5kZXJNYXAuZ2V0KCByZWZlcmVuY2UgKSAhPT0gdGhpcy5yZW5kZXJJZCApIHtcclxuXHJcblx0XHRcdFx0aWYgKCBub2RlLnVwZGF0ZSggdGhpcyApICE9PSBmYWxzZSApIHtcclxuXHJcblx0XHRcdFx0XHRyZW5kZXJNYXAuc2V0KCByZWZlcmVuY2UsIHRoaXMucmVuZGVySWQgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH0gZWxzZSBpZiAoIHVwZGF0ZVR5cGUgPT09IE5vZGVVcGRhdGVUeXBlLk9CSkVDVCApIHtcclxuXHJcblx0XHRcdG5vZGUudXBkYXRlKCB0aGlzICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFVwZGF0ZXMgdGhlIGludGVybmFsIHN0YXRlIG9mIHRoZSBub2RlIGZyYW1lLiBUaGlzIG1ldGhvZCBpc1xyXG5cdCAqIGNhbGxlZCBieSB0aGUgcmVuZGVyZXIgaW4gaXRzIGludGVybmFsIGFuaW1hdGlvbiBsb29wLlxyXG5cdCAqL1xyXG5cdHVwZGF0ZSgpIHtcclxuXHJcblx0XHR0aGlzLmZyYW1lSWQgKys7XHJcblxyXG5cdFx0aWYgKCB0aGlzLmxhc3RUaW1lID09PSB1bmRlZmluZWQgKSB0aGlzLmxhc3RUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XHJcblxyXG5cdFx0dGhpcy5kZWx0YVRpbWUgPSAoIHBlcmZvcm1hbmNlLm5vdygpIC0gdGhpcy5sYXN0VGltZSApIC8gMTAwMDtcclxuXHJcblx0XHR0aGlzLmxhc3RUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XHJcblxyXG5cdFx0dGhpcy50aW1lICs9IHRoaXMuZGVsdGFUaW1lO1xyXG5cclxuXHR9XHJcblxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBOb2RlRnJhbWU7XHJcbiIsIi8qKlxyXG4gKiBEZXNjcmliZXMgdGhlIGlucHV0IG9mIGEge0BsaW5rIE5vZGVGdW5jdGlvbn0uXHJcbiAqL1xyXG5jbGFzcyBOb2RlRnVuY3Rpb25JbnB1dCB7XHJcblxyXG5cdC8qKlxyXG5cdCAqIENvbnN0cnVjdHMgYSBuZXcgbm9kZSBmdW5jdGlvbiBpbnB1dC5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIC0gVGhlIGlucHV0IHR5cGUuXHJcblx0ICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgLSBUaGUgaW5wdXQgbmFtZS5cclxuXHQgKiBAcGFyYW0ge051bWJlcj99IFtjb3VudD1udWxsXSAtIElmIHRoZSBpbnB1dCBpcyBhbiBBcnJheSwgY291bnQgd2lsbCBiZSB0aGUgbGVuZ3RoLlxyXG5cdCAqIEBwYXJhbSB7KCdpbid8J291dCd8J2lub3V0Jyl9IFtxdWFsaWZpZXI9JyddIC0gVGhlIHBhcmFtZXRlciBxdWFsaWZpZXIgKG9ubHkgcmVsZXZhbnQgZm9yIEdMU0wpLlxyXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gW2lzQ29uc3Q9ZmFsc2VdIC0gV2hldGhlciB0aGUgaW5wdXQgdXNlcyBhIGNvbnN0IHF1YWxpZmllciBvciBub3QgKG9ubHkgcmVsZXZhbnQgZm9yIEdMU0wpLlxyXG5cdCAqL1xyXG5cdGNvbnN0cnVjdG9yKCB0eXBlLCBuYW1lLCBjb3VudCA9IG51bGwsIHF1YWxpZmllciA9ICcnLCBpc0NvbnN0ID0gZmFsc2UgKSB7XHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiAgVGhlIGlucHV0IHR5cGUuXHJcblx0XHQgKlxyXG5cdFx0ICogQHR5cGUge1N0cmluZ31cclxuXHRcdCAqL1xyXG5cdFx0dGhpcy50eXBlID0gdHlwZTtcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIFRoZSBpbnB1dCBuYW1lLlxyXG5cdFx0ICpcclxuXHRcdCAqIEB0eXBlIHtTdHJpbmd9XHJcblx0XHQgKi9cclxuXHRcdHRoaXMubmFtZSA9IG5hbWU7XHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBJZiB0aGUgaW5wdXQgaXMgYW4gQXJyYXksIGNvdW50IHdpbGwgYmUgdGhlIGxlbmd0aC5cclxuXHRcdCAqXHJcblx0XHQgKiBAdHlwZSB7TnVtYmVyP31cclxuXHRcdCAqIEBkZWZhdWx0IG51bGxcclxuXHRcdCAqL1xyXG5cdFx0dGhpcy5jb3VudCA9IGNvdW50O1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICpUaGUgcGFyYW1ldGVyIHF1YWxpZmllciAob25seSByZWxldmFudCBmb3IgR0xTTCkuXHJcblx0XHQgKlxyXG5cdFx0ICogQHR5cGUgeygnaW4nfCdvdXQnfCdpbm91dCcpfVxyXG5cdFx0ICogQGRlZmF1bHQgJydcclxuXHRcdCAqL1xyXG5cdFx0dGhpcy5xdWFsaWZpZXIgPSBxdWFsaWZpZXI7XHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBXaGV0aGVyIHRoZSBpbnB1dCB1c2VzIGEgY29uc3QgcXVhbGlmaWVyIG9yIG5vdCAob25seSByZWxldmFudCBmb3IgR0xTTCkuXHJcblx0XHQgKlxyXG5cdFx0ICogQHR5cGUge0Jvb2xlYW59XHJcblx0XHQgKiBAZGVmYXVsdCBmYWxzZVxyXG5cdFx0ICovXHJcblx0XHR0aGlzLmlzQ29uc3QgPSBpc0NvbnN0O1xyXG5cclxuXHR9XHJcblxyXG59XHJcblxyXG5Ob2RlRnVuY3Rpb25JbnB1dC5pc05vZGVGdW5jdGlvbklucHV0ID0gdHJ1ZTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IE5vZGVGdW5jdGlvbklucHV0O1xyXG4iLCJpbXBvcnQgQW5hbHl0aWNMaWdodE5vZGUgZnJvbSAnLi9BbmFseXRpY0xpZ2h0Tm9kZS5qcyc7XHJcbmltcG9ydCB7IGxpZ2h0VGFyZ2V0RGlyZWN0aW9uIH0gZnJvbSAnLi4vYWNjZXNzb3JzL0xpZ2h0cy5qcyc7XHJcblxyXG4vKipcclxuICogTW9kdWxlIGZvciByZXByZXNlbnRpbmcgZGlyZWN0aW9uYWwgbGlnaHRzIGFzIG5vZGVzLlxyXG4gKlxyXG4gKiBAYXVnbWVudHMgQW5hbHl0aWNMaWdodE5vZGVcclxuICovXHJcbmNsYXNzIERpcmVjdGlvbmFsTGlnaHROb2RlIGV4dGVuZHMgQW5hbHl0aWNMaWdodE5vZGUge1xyXG5cclxuXHRzdGF0aWMgZ2V0IHR5cGUoKSB7XHJcblxyXG5cdFx0cmV0dXJuICdEaXJlY3Rpb25hbExpZ2h0Tm9kZSc7XHJcblxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogQ29uc3RydWN0cyBhIG5ldyBkaXJlY3Rpb25hbCBsaWdodCBub2RlLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtEaXJlY3Rpb25hbExpZ2h0P30gW2xpZ2h0PW51bGxdIC0gVGhlIGRpcmVjdGlvbmFsIGxpZ2h0IHNvdXJjZS5cclxuXHQgKi9cclxuXHRjb25zdHJ1Y3RvciggbGlnaHQgPSBudWxsICkge1xyXG5cclxuXHRcdHN1cGVyKCBsaWdodCApO1xyXG5cclxuXHR9XHJcblxyXG5cdHNldHVwKCBidWlsZGVyICkge1xyXG5cclxuXHRcdHN1cGVyLnNldHVwKCBidWlsZGVyICk7XHJcblxyXG5cdFx0Y29uc3QgbGlnaHRpbmdNb2RlbCA9IGJ1aWxkZXIuY29udGV4dC5saWdodGluZ01vZGVsO1xyXG5cclxuXHRcdGNvbnN0IGxpZ2h0Q29sb3IgPSB0aGlzLmNvbG9yTm9kZTtcclxuXHRcdGNvbnN0IGxpZ2h0RGlyZWN0aW9uID0gbGlnaHRUYXJnZXREaXJlY3Rpb24oIHRoaXMubGlnaHQgKTtcclxuXHRcdGNvbnN0IHJlZmxlY3RlZExpZ2h0ID0gYnVpbGRlci5jb250ZXh0LnJlZmxlY3RlZExpZ2h0O1xyXG5cclxuXHRcdGxpZ2h0aW5nTW9kZWwuZGlyZWN0KCB7XHJcblx0XHRcdGxpZ2h0RGlyZWN0aW9uLFxyXG5cdFx0XHRsaWdodENvbG9yLFxyXG5cdFx0XHRyZWZsZWN0ZWRMaWdodFxyXG5cdFx0fSwgYnVpbGRlci5zdGFjaywgYnVpbGRlciApO1xyXG5cclxuXHR9XHJcblxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBEaXJlY3Rpb25hbExpZ2h0Tm9kZTtcclxuIiwiaW1wb3J0IEFuYWx5dGljTGlnaHROb2RlIGZyb20gJy4vQW5hbHl0aWNMaWdodE5vZGUuanMnO1xyXG5pbXBvcnQgeyB0ZXh0dXJlIH0gZnJvbSAnLi4vYWNjZXNzb3JzL1RleHR1cmVOb2RlLmpzJztcclxuaW1wb3J0IHsgdW5pZm9ybSB9IGZyb20gJy4uL2NvcmUvVW5pZm9ybU5vZGUuanMnO1xyXG5pbXBvcnQgeyBsaWdodFZpZXdQb3NpdGlvbiB9IGZyb20gJy4uL2FjY2Vzc29ycy9MaWdodHMuanMnO1xyXG5pbXBvcnQgeyByZW5kZXJHcm91cCB9IGZyb20gJy4uL2NvcmUvVW5pZm9ybUdyb3VwTm9kZS5qcyc7XHJcblxyXG5pbXBvcnQgeyBNYXRyaXg0IH0gZnJvbSAnLi4vLi4vbWF0aC9NYXRyaXg0LmpzJztcclxuaW1wb3J0IHsgVmVjdG9yMyB9IGZyb20gJy4uLy4uL21hdGgvVmVjdG9yMy5qcyc7XHJcbmltcG9ydCB7IE5vZGVVcGRhdGVUeXBlIH0gZnJvbSAnLi4vY29yZS9jb25zdGFudHMuanMnO1xyXG5cclxuY29uc3QgX21hdHJpeDQxID0gLypAX19QVVJFX18qLyBuZXcgTWF0cml4NCgpO1xyXG5jb25zdCBfbWF0cml4NDIgPSAvKkBfX1BVUkVfXyovIG5ldyBNYXRyaXg0KCk7XHJcblxyXG5sZXQgX2x0Y0xpYiA9IG51bGw7XHJcblxyXG4vKipcclxuICogTW9kdWxlIGZvciByZXByZXNlbnRpbmcgcmVjdCBhcmVhIGxpZ2h0cyBhcyBub2Rlcy5cclxuICpcclxuICogQGF1Z21lbnRzIEFuYWx5dGljTGlnaHROb2RlXHJcbiAqL1xyXG5jbGFzcyBSZWN0QXJlYUxpZ2h0Tm9kZSBleHRlbmRzIEFuYWx5dGljTGlnaHROb2RlIHtcclxuXHJcblx0c3RhdGljIGdldCB0eXBlKCkge1xyXG5cclxuXHRcdHJldHVybiAnUmVjdEFyZWFMaWdodE5vZGUnO1xyXG5cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIENvbnN0cnVjdHMgYSBuZXcgcmVjdCBhcmVhIGxpZ2h0IG5vZGUuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge1JlY3RBcmVhTGlnaHQ/fSBbbGlnaHQ9bnVsbF0gLSBUaGUgcmVjdCBhcmVhIGxpZ2h0IHNvdXJjZS5cclxuXHQgKi9cclxuXHRjb25zdHJ1Y3RvciggbGlnaHQgPSBudWxsICkge1xyXG5cclxuXHRcdHN1cGVyKCBsaWdodCApO1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogVW5pZm9ybSBub2RlIHJlcHJlc2VudGluZyB0aGUgaGFsZiBoZWlnaHQgb2YgdGhlIGFyZSBsaWdodC5cclxuXHRcdCAqXHJcblx0XHQgKiBAdHlwZSB7VW5pZm9ybU5vZGU8dmVjMz59XHJcblx0XHQgKi9cclxuXHRcdHRoaXMuaGFsZkhlaWdodCA9IHVuaWZvcm0oIG5ldyBWZWN0b3IzKCkgKS5zZXRHcm91cCggcmVuZGVyR3JvdXAgKTtcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIFVuaWZvcm0gbm9kZSByZXByZXNlbnRpbmcgdGhlIGhhbGYgd2lkdGggb2YgdGhlIGFyZSBsaWdodC5cclxuXHRcdCAqXHJcblx0XHQgKiBAdHlwZSB7VW5pZm9ybU5vZGU8dmVjMz59XHJcblx0XHQgKi9cclxuXHRcdHRoaXMuaGFsZldpZHRoID0gdW5pZm9ybSggbmV3IFZlY3RvcjMoKSApLnNldEdyb3VwKCByZW5kZXJHcm91cCApO1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogVGhlIGB1cGRhdGVUeXBlYCBpcyBzZXQgdG8gYE5vZGVVcGRhdGVUeXBlLlJFTkRFUmAgc2luY2UgdGhlIGxpZ2h0XHJcblx0XHQgKiByZWxpZXMgb24gYHZpZXdNYXRyaXhgIHdoaWNoIG1pZ2h0IHZhcnkgcGVyIHJlbmRlciBjYWxsLlxyXG5cdFx0ICpcclxuXHRcdCAqIEB0eXBlIHtTdHJpbmd9XHJcblx0XHQgKiBAZGVmYXVsdCAncmVuZGVyJ1xyXG5cdFx0ICovXHJcblx0XHR0aGlzLnVwZGF0ZVR5cGUgPSBOb2RlVXBkYXRlVHlwZS5SRU5ERVI7XHJcblxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogT3ZlcndyaXR0ZW4gdG8gdXBkYXRlZCByZWN0IGFyZWEgbGlnaHQgc3BlY2lmaWMgdW5pZm9ybXMuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge05vZGVGcmFtZX0gZnJhbWUgLSBBIHJlZmVyZW5jZSB0byB0aGUgY3VycmVudCBub2RlIGZyYW1lLlxyXG5cdCAqL1xyXG5cdHVwZGF0ZSggZnJhbWUgKSB7XHJcblxyXG5cdFx0c3VwZXIudXBkYXRlKCBmcmFtZSApO1xyXG5cclxuXHRcdGNvbnN0IHsgbGlnaHQgfSA9IHRoaXM7XHJcblxyXG5cdFx0Y29uc3Qgdmlld01hdHJpeCA9IGZyYW1lLmNhbWVyYS5tYXRyaXhXb3JsZEludmVyc2U7XHJcblxyXG5cdFx0X21hdHJpeDQyLmlkZW50aXR5KCk7XHJcblx0XHRfbWF0cml4NDEuY29weSggbGlnaHQubWF0cml4V29ybGQgKTtcclxuXHRcdF9tYXRyaXg0MS5wcmVtdWx0aXBseSggdmlld01hdHJpeCApO1xyXG5cdFx0X21hdHJpeDQyLmV4dHJhY3RSb3RhdGlvbiggX21hdHJpeDQxICk7XHJcblxyXG5cdFx0dGhpcy5oYWxmV2lkdGgudmFsdWUuc2V0KCBsaWdodC53aWR0aCAqIDAuNSwgMC4wLCAwLjAgKTtcclxuXHRcdHRoaXMuaGFsZkhlaWdodC52YWx1ZS5zZXQoIDAuMCwgbGlnaHQuaGVpZ2h0ICogMC41LCAwLjAgKTtcclxuXHJcblx0XHR0aGlzLmhhbGZXaWR0aC52YWx1ZS5hcHBseU1hdHJpeDQoIF9tYXRyaXg0MiApO1xyXG5cdFx0dGhpcy5oYWxmSGVpZ2h0LnZhbHVlLmFwcGx5TWF0cml4NCggX21hdHJpeDQyICk7XHJcblxyXG5cdH1cclxuXHJcblx0c2V0dXAoIGJ1aWxkZXIgKSB7XHJcblxyXG5cdFx0c3VwZXIuc2V0dXAoIGJ1aWxkZXIgKTtcclxuXHJcblx0XHRsZXQgbHRjXzEsIGx0Y18yO1xyXG5cclxuXHRcdGlmICggYnVpbGRlci5pc0F2YWlsYWJsZSggJ2Zsb2F0MzJGaWx0ZXJhYmxlJyApICkge1xyXG5cclxuXHRcdFx0bHRjXzEgPSB0ZXh0dXJlKCBfbHRjTGliLkxUQ19GTE9BVF8xICk7XHJcblx0XHRcdGx0Y18yID0gdGV4dHVyZSggX2x0Y0xpYi5MVENfRkxPQVRfMiApO1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRsdGNfMSA9IHRleHR1cmUoIF9sdGNMaWIuTFRDX0hBTEZfMSApO1xyXG5cdFx0XHRsdGNfMiA9IHRleHR1cmUoIF9sdGNMaWIuTFRDX0hBTEZfMiApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRjb25zdCB7IGNvbG9yTm9kZSwgbGlnaHQgfSA9IHRoaXM7XHJcblx0XHRjb25zdCBsaWdodGluZ01vZGVsID0gYnVpbGRlci5jb250ZXh0LmxpZ2h0aW5nTW9kZWw7XHJcblxyXG5cdFx0Y29uc3QgbGlnaHRQb3NpdGlvbiA9IGxpZ2h0Vmlld1Bvc2l0aW9uKCBsaWdodCApO1xyXG5cdFx0Y29uc3QgcmVmbGVjdGVkTGlnaHQgPSBidWlsZGVyLmNvbnRleHQucmVmbGVjdGVkTGlnaHQ7XHJcblxyXG5cdFx0bGlnaHRpbmdNb2RlbC5kaXJlY3RSZWN0QXJlYSgge1xyXG5cdFx0XHRsaWdodENvbG9yOiBjb2xvck5vZGUsXHJcblx0XHRcdGxpZ2h0UG9zaXRpb24sXHJcblx0XHRcdGhhbGZXaWR0aDogdGhpcy5oYWxmV2lkdGgsXHJcblx0XHRcdGhhbGZIZWlnaHQ6IHRoaXMuaGFsZkhlaWdodCxcclxuXHRcdFx0cmVmbGVjdGVkTGlnaHQsXHJcblx0XHRcdGx0Y18xLFxyXG5cdFx0XHRsdGNfMlxyXG5cdFx0fSwgYnVpbGRlci5zdGFjaywgYnVpbGRlciApO1xyXG5cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFVzZWQgdG8gY29uZmlndXJlIHRoZSBpbnRlcm5hbCBCUkRGIGFwcHJveGltYXRpb24gdGV4dHVyZSBkYXRhLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtSZWN0QXJlYUxpZ2h0VGV4dHVyZXNMaWJ9IGx0YyAtIFRoZSBCUkRGIGFwcHJveGltYXRpb24gdGV4dHVyZSBkYXRhLlxyXG5cdCAqL1xyXG5cdHN0YXRpYyBzZXRMVEMoIGx0YyApIHtcclxuXHJcblx0XHRfbHRjTGliID0gbHRjO1xyXG5cclxuXHR9XHJcblxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBSZWN0QXJlYUxpZ2h0Tm9kZTtcclxuIiwiaW1wb3J0IEFuYWx5dGljTGlnaHROb2RlIGZyb20gJy4vQW5hbHl0aWNMaWdodE5vZGUuanMnO1xyXG5pbXBvcnQgeyBnZXREaXN0YW5jZUF0dGVudWF0aW9uIH0gZnJvbSAnLi9MaWdodFV0aWxzLmpzJztcclxuaW1wb3J0IHsgdW5pZm9ybSB9IGZyb20gJy4uL2NvcmUvVW5pZm9ybU5vZGUuanMnO1xyXG5pbXBvcnQgeyBzbW9vdGhzdGVwIH0gZnJvbSAnLi4vbWF0aC9NYXRoTm9kZS5qcyc7XHJcbmltcG9ydCB7IHBvc2l0aW9uVmlldyB9IGZyb20gJy4uL2FjY2Vzc29ycy9Qb3NpdGlvbi5qcyc7XHJcbmltcG9ydCB7IHJlbmRlckdyb3VwIH0gZnJvbSAnLi4vY29yZS9Vbmlmb3JtR3JvdXBOb2RlLmpzJztcclxuaW1wb3J0IHsgbGlnaHRWaWV3UG9zaXRpb24sIGxpZ2h0VGFyZ2V0RGlyZWN0aW9uLCBsaWdodFByb2plY3Rpb25VViB9IGZyb20gJy4uL2FjY2Vzc29ycy9MaWdodHMuanMnO1xyXG5pbXBvcnQgeyB0ZXh0dXJlIH0gZnJvbSAnLi4vYWNjZXNzb3JzL1RleHR1cmVOb2RlLmpzJztcclxuXHJcbi8qKlxyXG4gKiBNb2R1bGUgZm9yIHJlcHJlc2VudGluZyBzcG90IGxpZ2h0cyBhcyBub2Rlcy5cclxuICpcclxuICogQGF1Z21lbnRzIEFuYWx5dGljTGlnaHROb2RlXHJcbiAqL1xyXG5jbGFzcyBTcG90TGlnaHROb2RlIGV4dGVuZHMgQW5hbHl0aWNMaWdodE5vZGUge1xyXG5cclxuXHRzdGF0aWMgZ2V0IHR5cGUoKSB7XHJcblxyXG5cdFx0cmV0dXJuICdTcG90TGlnaHROb2RlJztcclxuXHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBDb25zdHJ1Y3RzIGEgbmV3IHNwb3QgbGlnaHQgbm9kZS5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7U3BvdExpZ2h0P30gW2xpZ2h0PW51bGxdIC0gVGhlIHNwb3QgbGlnaHQgc291cmNlLlxyXG5cdCAqL1xyXG5cdGNvbnN0cnVjdG9yKCBsaWdodCA9IG51bGwgKSB7XHJcblxyXG5cdFx0c3VwZXIoIGxpZ2h0ICk7XHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBVbmlmb3JtIG5vZGUgcmVwcmVzZW50aW5nIHRoZSBjb25lIGNvc2ludXMuXHJcblx0XHQgKlxyXG5cdFx0ICogQHR5cGUge1VuaWZvcm1Ob2RlPGZsb2F0Pn1cclxuXHRcdCAqL1xyXG5cdFx0dGhpcy5jb25lQ29zTm9kZSA9IHVuaWZvcm0oIDAgKS5zZXRHcm91cCggcmVuZGVyR3JvdXAgKTtcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIFVuaWZvcm0gbm9kZSByZXByZXNlbnRpbmcgdGhlIHBlbnVtYnJhIGNvc2ludXMuXHJcblx0XHQgKlxyXG5cdFx0ICogQHR5cGUge1VuaWZvcm1Ob2RlPGZsb2F0Pn1cclxuXHRcdCAqL1xyXG5cdFx0dGhpcy5wZW51bWJyYUNvc05vZGUgPSB1bmlmb3JtKCAwICkuc2V0R3JvdXAoIHJlbmRlckdyb3VwICk7XHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBVbmlmb3JtIG5vZGUgcmVwcmVzZW50aW5nIHRoZSBjdXRvZmYgZGlzdGFuY2UuXHJcblx0XHQgKlxyXG5cdFx0ICogQHR5cGUge1VuaWZvcm1Ob2RlPGZsb2F0Pn1cclxuXHRcdCAqL1xyXG5cdFx0dGhpcy5jdXRvZmZEaXN0YW5jZU5vZGUgPSB1bmlmb3JtKCAwICkuc2V0R3JvdXAoIHJlbmRlckdyb3VwICk7XHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBVbmlmb3JtIG5vZGUgcmVwcmVzZW50aW5nIHRoZSBkZWNheSBleHBvbmVudC5cclxuXHRcdCAqXHJcblx0XHQgKiBAdHlwZSB7VW5pZm9ybU5vZGU8ZmxvYXQ+fVxyXG5cdFx0ICovXHJcblx0XHR0aGlzLmRlY2F5RXhwb25lbnROb2RlID0gdW5pZm9ybSggMCApLnNldEdyb3VwKCByZW5kZXJHcm91cCApO1xyXG5cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIE92ZXJ3cml0dGVuIHRvIHVwZGF0ZWQgc3BvdCBsaWdodCBzcGVjaWZpYyB1bmlmb3Jtcy5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7Tm9kZUZyYW1lfSBmcmFtZSAtIEEgcmVmZXJlbmNlIHRvIHRoZSBjdXJyZW50IG5vZGUgZnJhbWUuXHJcblx0ICovXHJcblx0dXBkYXRlKCBmcmFtZSApIHtcclxuXHJcblx0XHRzdXBlci51cGRhdGUoIGZyYW1lICk7XHJcblxyXG5cdFx0Y29uc3QgeyBsaWdodCB9ID0gdGhpcztcclxuXHJcblx0XHR0aGlzLmNvbmVDb3NOb2RlLnZhbHVlID0gTWF0aC5jb3MoIGxpZ2h0LmFuZ2xlICk7XHJcblx0XHR0aGlzLnBlbnVtYnJhQ29zTm9kZS52YWx1ZSA9IE1hdGguY29zKCBsaWdodC5hbmdsZSAqICggMSAtIGxpZ2h0LnBlbnVtYnJhICkgKTtcclxuXHJcblx0XHR0aGlzLmN1dG9mZkRpc3RhbmNlTm9kZS52YWx1ZSA9IGxpZ2h0LmRpc3RhbmNlO1xyXG5cdFx0dGhpcy5kZWNheUV4cG9uZW50Tm9kZS52YWx1ZSA9IGxpZ2h0LmRlY2F5O1xyXG5cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIENvbXB1dGVzIHRoZSBzcG90IGF0dGVudWF0aW9uIGZvciB0aGUgZ2l2ZW4gYW5nbGUuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge05vZGU8ZmxvYXQ+fSBhbmdsZUNvc2luZSAtIFRoZSBhbmdsZSB0byBjb21wdXRlIHRoZSBzcG90IGF0dGVudWF0aW9uIGZvci5cclxuXHQgKiBAcmV0dXJuIHtOb2RlPGZsb2F0Pn0gVGhlIHNwb3QgYXR0ZW51YXRpb24uXHJcblx0ICovXHJcblx0Z2V0U3BvdEF0dGVudWF0aW9uKCBhbmdsZUNvc2luZSApIHtcclxuXHJcblx0XHRjb25zdCB7IGNvbmVDb3NOb2RlLCBwZW51bWJyYUNvc05vZGUgfSA9IHRoaXM7XHJcblxyXG5cdFx0cmV0dXJuIHNtb290aHN0ZXAoIGNvbmVDb3NOb2RlLCBwZW51bWJyYUNvc05vZGUsIGFuZ2xlQ29zaW5lICk7XHJcblxyXG5cdH1cclxuXHJcblx0c2V0dXAoIGJ1aWxkZXIgKSB7XHJcblxyXG5cdFx0c3VwZXIuc2V0dXAoIGJ1aWxkZXIgKTtcclxuXHJcblx0XHRjb25zdCBsaWdodGluZ01vZGVsID0gYnVpbGRlci5jb250ZXh0LmxpZ2h0aW5nTW9kZWw7XHJcblxyXG5cdFx0Y29uc3QgeyBjb2xvck5vZGUsIGN1dG9mZkRpc3RhbmNlTm9kZSwgZGVjYXlFeHBvbmVudE5vZGUsIGxpZ2h0IH0gPSB0aGlzO1xyXG5cclxuXHRcdGNvbnN0IGxWZWN0b3IgPSBsaWdodFZpZXdQb3NpdGlvbiggbGlnaHQgKS5zdWIoIHBvc2l0aW9uVmlldyApOyAvLyBAVE9ETzogQWRkIGl0IGludG8gTGlnaHROb2RlXHJcblxyXG5cdFx0Y29uc3QgbGlnaHREaXJlY3Rpb24gPSBsVmVjdG9yLm5vcm1hbGl6ZSgpO1xyXG5cdFx0Y29uc3QgYW5nbGVDb3MgPSBsaWdodERpcmVjdGlvbi5kb3QoIGxpZ2h0VGFyZ2V0RGlyZWN0aW9uKCBsaWdodCApICk7XHJcblx0XHRjb25zdCBzcG90QXR0ZW51YXRpb24gPSB0aGlzLmdldFNwb3RBdHRlbnVhdGlvbiggYW5nbGVDb3MgKTtcclxuXHJcblx0XHRjb25zdCBsaWdodERpc3RhbmNlID0gbFZlY3Rvci5sZW5ndGgoKTtcclxuXHJcblx0XHRjb25zdCBsaWdodEF0dGVudWF0aW9uID0gZ2V0RGlzdGFuY2VBdHRlbnVhdGlvbigge1xyXG5cdFx0XHRsaWdodERpc3RhbmNlLFxyXG5cdFx0XHRjdXRvZmZEaXN0YW5jZTogY3V0b2ZmRGlzdGFuY2VOb2RlLFxyXG5cdFx0XHRkZWNheUV4cG9uZW50OiBkZWNheUV4cG9uZW50Tm9kZVxyXG5cdFx0fSApO1xyXG5cclxuXHRcdGxldCBsaWdodENvbG9yID0gY29sb3JOb2RlLm11bCggc3BvdEF0dGVudWF0aW9uICkubXVsKCBsaWdodEF0dGVudWF0aW9uICk7XHJcblxyXG5cdFx0aWYgKCBsaWdodC5tYXAgKSB7XHJcblxyXG5cdFx0XHRjb25zdCBzcG90TGlnaHRDb29yZCA9IGxpZ2h0UHJvamVjdGlvblVWKCBsaWdodCApO1xyXG5cdFx0XHRjb25zdCBwcm9qZWN0ZWRUZXh0dXJlID0gdGV4dHVyZSggbGlnaHQubWFwLCBzcG90TGlnaHRDb29yZC54eSApLm9uUmVuZGVyVXBkYXRlKCAoKSA9PiBsaWdodC5tYXAgKTtcclxuXHJcblx0XHRcdGNvbnN0IGluU3BvdExpZ2h0TWFwID0gc3BvdExpZ2h0Q29vcmQubXVsKCAyLiApLnN1YiggMS4gKS5hYnMoKS5sZXNzVGhhbiggMS4gKS5hbGwoKTtcclxuXHJcblx0XHRcdGxpZ2h0Q29sb3IgPSBpblNwb3RMaWdodE1hcC5zZWxlY3QoIGxpZ2h0Q29sb3IubXVsKCBwcm9qZWN0ZWRUZXh0dXJlICksIGxpZ2h0Q29sb3IgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Y29uc3QgcmVmbGVjdGVkTGlnaHQgPSBidWlsZGVyLmNvbnRleHQucmVmbGVjdGVkTGlnaHQ7XHJcblxyXG5cdFx0bGlnaHRpbmdNb2RlbC5kaXJlY3QoIHtcclxuXHRcdFx0bGlnaHREaXJlY3Rpb24sXHJcblx0XHRcdGxpZ2h0Q29sb3IsXHJcblx0XHRcdHJlZmxlY3RlZExpZ2h0XHJcblx0XHR9LCBidWlsZGVyLnN0YWNrLCBidWlsZGVyICk7XHJcblxyXG5cdH1cclxuXHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IFNwb3RMaWdodE5vZGU7XHJcbiIsImltcG9ydCBTcG90TGlnaHROb2RlIGZyb20gJy4vU3BvdExpZ2h0Tm9kZS5qcyc7XHJcbmltcG9ydCB7IHRleHR1cmUgfSBmcm9tICcuLi9hY2Nlc3NvcnMvVGV4dHVyZU5vZGUuanMnO1xyXG5pbXBvcnQgeyB2ZWMyIH0gZnJvbSAnLi4vdHNsL1RTTEJhc2UuanMnO1xyXG5cclxuLyoqXHJcbiAqIEFuIElFUyB2ZXJzaW9uIG9mIHRoZSBkZWZhdWx0IHNwb3QgbGlnaHQgbm9kZS5cclxuICpcclxuICogQGF1Z21lbnRzIFNwb3RMaWdodE5vZGVcclxuICovXHJcbmNsYXNzIElFU1Nwb3RMaWdodE5vZGUgZXh0ZW5kcyBTcG90TGlnaHROb2RlIHtcclxuXHJcblx0c3RhdGljIGdldCB0eXBlKCkge1xyXG5cclxuXHRcdHJldHVybiAnSUVTU3BvdExpZ2h0Tm9kZSc7XHJcblxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogT3ZlcndyaXRlcyB0aGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiB0byBjb21wdXRlIGFuIElFUyBjb25mb3JtIHNwb3QgYXR0ZW51YXRpb24uXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge05vZGU8ZmxvYXQ+fSBhbmdsZUNvc2luZSAtIFRoZSBhbmdsZSB0byBjb21wdXRlIHRoZSBzcG90IGF0dGVudWF0aW9uIGZvci5cclxuXHQgKiBAcmV0dXJuIHtOb2RlPGZsb2F0Pn0gVGhlIHNwb3QgYXR0ZW51YXRpb24uXHJcblx0ICovXHJcblx0Z2V0U3BvdEF0dGVudWF0aW9uKCBhbmdsZUNvc2luZSApIHtcclxuXHJcblx0XHRjb25zdCBpZXNNYXAgPSB0aGlzLmxpZ2h0Lmllc01hcDtcclxuXHJcblx0XHRsZXQgc3BvdEF0dGVudWF0aW9uID0gbnVsbDtcclxuXHJcblx0XHRpZiAoIGllc01hcCAmJiBpZXNNYXAuaXNUZXh0dXJlID09PSB0cnVlICkge1xyXG5cclxuXHRcdFx0Y29uc3QgYW5nbGUgPSBhbmdsZUNvc2luZS5hY29zKCkubXVsKCAxLjAgLyBNYXRoLlBJICk7XHJcblxyXG5cdFx0XHRzcG90QXR0ZW51YXRpb24gPSB0ZXh0dXJlKCBpZXNNYXAsIHZlYzIoIGFuZ2xlLCAwICksIDAgKS5yO1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRzcG90QXR0ZW51YXRpb24gPSBzdXBlci5nZXRTcG90QXR0ZW51YXRpb24oIGFuZ2xlQ29zaW5lICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBzcG90QXR0ZW51YXRpb247XHJcblxyXG5cdH1cclxuXHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IElFU1Nwb3RMaWdodE5vZGU7XHJcbiIsImltcG9ydCBBbmFseXRpY0xpZ2h0Tm9kZSBmcm9tICcuL0FuYWx5dGljTGlnaHROb2RlLmpzJztcclxuXHJcbi8qKlxyXG4gKiBNb2R1bGUgZm9yIHJlcHJlc2VudGluZyBhbWJpZW50IGxpZ2h0cyBhcyBub2Rlcy5cclxuICpcclxuICogQGF1Z21lbnRzIEFuYWx5dGljTGlnaHROb2RlXHJcbiAqL1xyXG5jbGFzcyBBbWJpZW50TGlnaHROb2RlIGV4dGVuZHMgQW5hbHl0aWNMaWdodE5vZGUge1xyXG5cclxuXHRzdGF0aWMgZ2V0IHR5cGUoKSB7XHJcblxyXG5cdFx0cmV0dXJuICdBbWJpZW50TGlnaHROb2RlJztcclxuXHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBDb25zdHJ1Y3RzIGEgbmV3IGFtYmllbnQgbGlnaHQgbm9kZS5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7QW1iaWVudExpZ2h0P30gW2xpZ2h0PW51bGxdIC0gVGhlIGFtYmllbnQgbGlnaHQgc291cmNlLlxyXG5cdCAqL1xyXG5cdGNvbnN0cnVjdG9yKCBsaWdodCA9IG51bGwgKSB7XHJcblxyXG5cdFx0c3VwZXIoIGxpZ2h0ICk7XHJcblxyXG5cdH1cclxuXHJcblx0c2V0dXAoIHsgY29udGV4dCB9ICkge1xyXG5cclxuXHRcdGNvbnRleHQuaXJyYWRpYW5jZS5hZGRBc3NpZ24oIHRoaXMuY29sb3JOb2RlICk7XHJcblxyXG5cdH1cclxuXHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IEFtYmllbnRMaWdodE5vZGU7XHJcbiIsImltcG9ydCBBbmFseXRpY0xpZ2h0Tm9kZSBmcm9tICcuL0FuYWx5dGljTGlnaHROb2RlLmpzJztcclxuaW1wb3J0IHsgdW5pZm9ybSB9IGZyb20gJy4uL2NvcmUvVW5pZm9ybU5vZGUuanMnO1xyXG5pbXBvcnQgeyBtaXggfSBmcm9tICcuLi9tYXRoL01hdGhOb2RlLmpzJztcclxuaW1wb3J0IHsgbm9ybWFsVmlldyB9IGZyb20gJy4uL2FjY2Vzc29ycy9Ob3JtYWwuanMnO1xyXG5pbXBvcnQgeyBsaWdodFBvc2l0aW9uIH0gZnJvbSAnLi4vYWNjZXNzb3JzL0xpZ2h0cy5qcyc7XHJcbmltcG9ydCB7IHJlbmRlckdyb3VwIH0gZnJvbSAnLi4vY29yZS9Vbmlmb3JtR3JvdXBOb2RlLmpzJztcclxuXHJcbmltcG9ydCB7IENvbG9yIH0gZnJvbSAnLi4vLi4vbWF0aC9Db2xvci5qcyc7XHJcblxyXG4vKipcclxuICogTW9kdWxlIGZvciByZXByZXNlbnRpbmcgaGVtaXNwaGVyZSBsaWdodHMgYXMgbm9kZXMuXHJcbiAqXHJcbiAqIEBhdWdtZW50cyBBbmFseXRpY0xpZ2h0Tm9kZVxyXG4gKi9cclxuY2xhc3MgSGVtaXNwaGVyZUxpZ2h0Tm9kZSBleHRlbmRzIEFuYWx5dGljTGlnaHROb2RlIHtcclxuXHJcblx0c3RhdGljIGdldCB0eXBlKCkge1xyXG5cclxuXHRcdHJldHVybiAnSGVtaXNwaGVyZUxpZ2h0Tm9kZSc7XHJcblxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogQ29uc3RydWN0cyBhIG5ldyBoZW1pc3BoZXJlIGxpZ2h0IG5vZGUuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge0hlbWlzcGhlcmVMaWdodD99IFtsaWdodD1udWxsXSAtIFRoZSBoZW1pc3BoZXJlIGxpZ2h0IHNvdXJjZS5cclxuXHQgKi9cclxuXHRjb25zdHJ1Y3RvciggbGlnaHQgPSBudWxsICkge1xyXG5cclxuXHRcdHN1cGVyKCBsaWdodCApO1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogVW5pZm9ybSBub2RlIHJlcHJlc2VudGluZyB0aGUgbGlnaHQncyBwb3NpdGlvbi5cclxuXHRcdCAqXHJcblx0XHQgKiBAdHlwZSB7VW5pZm9ybU5vZGU8dmVjMz59XHJcblx0XHQgKi9cclxuXHRcdHRoaXMubGlnaHRQb3NpdGlvbk5vZGUgPSBsaWdodFBvc2l0aW9uKCBsaWdodCApO1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogQSBub2RlIHJlcHJlc2VudGluZyB0aGUgbGlnaHQncyBkaXJlY3Rpb24uXHJcblx0XHQgKlxyXG5cdFx0ICogQHR5cGUge05vZGU8dmVjMz59XHJcblx0XHQgKi9cclxuXHRcdHRoaXMubGlnaHREaXJlY3Rpb25Ob2RlID0gdGhpcy5saWdodFBvc2l0aW9uTm9kZS5ub3JtYWxpemUoKTtcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIFVuaWZvcm0gbm9kZSByZXByZXNlbnRpbmcgdGhlIGxpZ2h0J3MgZ3JvdW5kIGNvbG9yLlxyXG5cdFx0ICpcclxuXHRcdCAqIEB0eXBlIHtVbmlmb3JtTm9kZTx2ZWMzPn1cclxuXHRcdCAqL1xyXG5cdFx0dGhpcy5ncm91bmRDb2xvck5vZGUgPSB1bmlmb3JtKCBuZXcgQ29sb3IoKSApLnNldEdyb3VwKCByZW5kZXJHcm91cCApO1xyXG5cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIE92ZXJ3cml0dGVuIHRvIHVwZGF0ZWQgaGVtaXNwaGVyZSBsaWdodCBzcGVjaWZpYyB1bmlmb3Jtcy5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7Tm9kZUZyYW1lfSBmcmFtZSAtIEEgcmVmZXJlbmNlIHRvIHRoZSBjdXJyZW50IG5vZGUgZnJhbWUuXHJcblx0ICovXHJcblx0dXBkYXRlKCBmcmFtZSApIHtcclxuXHJcblx0XHRjb25zdCB7IGxpZ2h0IH0gPSB0aGlzO1xyXG5cclxuXHRcdHN1cGVyLnVwZGF0ZSggZnJhbWUgKTtcclxuXHJcblx0XHR0aGlzLmxpZ2h0UG9zaXRpb25Ob2RlLm9iamVjdDNkID0gbGlnaHQ7XHJcblxyXG5cdFx0dGhpcy5ncm91bmRDb2xvck5vZGUudmFsdWUuY29weSggbGlnaHQuZ3JvdW5kQ29sb3IgKS5tdWx0aXBseVNjYWxhciggbGlnaHQuaW50ZW5zaXR5ICk7XHJcblxyXG5cdH1cclxuXHJcblx0c2V0dXAoIGJ1aWxkZXIgKSB7XHJcblxyXG5cdFx0Y29uc3QgeyBjb2xvck5vZGUsIGdyb3VuZENvbG9yTm9kZSwgbGlnaHREaXJlY3Rpb25Ob2RlIH0gPSB0aGlzO1xyXG5cclxuXHRcdGNvbnN0IGRvdE5MID0gbm9ybWFsVmlldy5kb3QoIGxpZ2h0RGlyZWN0aW9uTm9kZSApO1xyXG5cdFx0Y29uc3QgaGVtaURpZmZ1c2VXZWlnaHQgPSBkb3ROTC5tdWwoIDAuNSApLmFkZCggMC41ICk7XHJcblxyXG5cdFx0Y29uc3QgaXJyYWRpYW5jZSA9IG1peCggZ3JvdW5kQ29sb3JOb2RlLCBjb2xvck5vZGUsIGhlbWlEaWZmdXNlV2VpZ2h0ICk7XHJcblxyXG5cdFx0YnVpbGRlci5jb250ZXh0LmlycmFkaWFuY2UuYWRkQXNzaWduKCBpcnJhZGlhbmNlICk7XHJcblxyXG5cdH1cclxuXHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IEhlbWlzcGhlcmVMaWdodE5vZGU7XHJcbiIsImltcG9ydCBBbmFseXRpY0xpZ2h0Tm9kZSBmcm9tICcuL0FuYWx5dGljTGlnaHROb2RlLmpzJztcclxuaW1wb3J0IHsgbm9ybWFsV29ybGQgfSBmcm9tICcuLi9hY2Nlc3NvcnMvTm9ybWFsLmpzJztcclxuaW1wb3J0IHsgdW5pZm9ybUFycmF5IH0gZnJvbSAnLi4vYWNjZXNzb3JzL1VuaWZvcm1BcnJheU5vZGUuanMnO1xyXG5pbXBvcnQgeyBWZWN0b3IzIH0gZnJvbSAnLi4vLi4vbWF0aC9WZWN0b3IzLmpzJztcclxuaW1wb3J0IGdldFNoSXJyYWRpYW5jZUF0IGZyb20gJy4uL2Z1bmN0aW9ucy9tYXRlcmlhbC9nZXRTaElycmFkaWFuY2VBdC5qcyc7XHJcblxyXG4vKipcclxuICogTW9kdWxlIGZvciByZXByZXNlbnRpbmcgbGlnaHQgcHJvYmVzIGFzIG5vZGVzLlxyXG4gKlxyXG4gKiBAYXVnbWVudHMgQW5hbHl0aWNMaWdodE5vZGVcclxuICovXHJcbmNsYXNzIExpZ2h0UHJvYmVOb2RlIGV4dGVuZHMgQW5hbHl0aWNMaWdodE5vZGUge1xyXG5cclxuXHRzdGF0aWMgZ2V0IHR5cGUoKSB7XHJcblxyXG5cdFx0cmV0dXJuICdMaWdodFByb2JlTm9kZSc7XHJcblxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogQ29uc3RydWN0cyBhIG5ldyBsaWdodCBwcm9iZSBub2RlLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtMaWdodFByb2JlP30gW2xpZ2h0PW51bGxdIC0gVGhlIGxpZ2h0IHByb2JlLlxyXG5cdCAqL1xyXG5cdGNvbnN0cnVjdG9yKCBsaWdodCA9IG51bGwgKSB7XHJcblxyXG5cdFx0c3VwZXIoIGxpZ2h0ICk7XHJcblxyXG5cdFx0Y29uc3QgYXJyYXkgPSBbXTtcclxuXHJcblx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCA5OyBpICsrICkgYXJyYXkucHVzaCggbmV3IFZlY3RvcjMoKSApO1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogTGlnaHQgcHJvYmUgcmVwcmVzZW50ZWQgYXMgYSB1bmlmb3JtIG9mIHNwaGVyaWNhbCBoYXJtb25pY3MuXHJcblx0XHQgKlxyXG5cdFx0ICogQHR5cGUge1VuaWZvcm1BcnJheU5vZGV9XHJcblx0XHQgKi9cclxuXHRcdHRoaXMubGlnaHRQcm9iZSA9IHVuaWZvcm1BcnJheSggYXJyYXkgKTtcclxuXHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBPdmVyd3JpdHRlbiB0byB1cGRhdGVkIGxpZ2h0IHByb2JlIHNwZWNpZmljIHVuaWZvcm1zLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtOb2RlRnJhbWV9IGZyYW1lIC0gQSByZWZlcmVuY2UgdG8gdGhlIGN1cnJlbnQgbm9kZSBmcmFtZS5cclxuXHQgKi9cclxuXHR1cGRhdGUoIGZyYW1lICkge1xyXG5cclxuXHRcdGNvbnN0IHsgbGlnaHQgfSA9IHRoaXM7XHJcblxyXG5cdFx0c3VwZXIudXBkYXRlKCBmcmFtZSApO1xyXG5cclxuXHRcdC8vXHJcblxyXG5cdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgOTsgaSArKyApIHtcclxuXHJcblx0XHRcdHRoaXMubGlnaHRQcm9iZS5hcnJheVsgaSBdLmNvcHkoIGxpZ2h0LnNoLmNvZWZmaWNpZW50c1sgaSBdICkubXVsdGlwbHlTY2FsYXIoIGxpZ2h0LmludGVuc2l0eSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHRzZXR1cCggYnVpbGRlciApIHtcclxuXHJcblx0XHRjb25zdCBpcnJhZGlhbmNlID0gZ2V0U2hJcnJhZGlhbmNlQXQoIG5vcm1hbFdvcmxkLCB0aGlzLmxpZ2h0UHJvYmUgKTtcclxuXHJcblx0XHRidWlsZGVyLmNvbnRleHQuaXJyYWRpYW5jZS5hZGRBc3NpZ24oIGlycmFkaWFuY2UgKTtcclxuXHJcblx0fVxyXG5cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgTGlnaHRQcm9iZU5vZGU7XHJcbiIsIi8qKlxyXG4gKiBCYXNlIGNsYXNzIGZvciBub2RlIHBhcnNlcnMuIEEgZGVyaXZlZCBwYXJzZXIgbXVzdCBiZSBpbXBsZW1lbnRlZFxyXG4gKiBmb3IgZWFjaCBzdXBwb3J0ZWQgbmF0aXZlIHNoYWRlciBsYW5ndWFnZS5cclxuICovXHJcbmNsYXNzIE5vZGVQYXJzZXIge1xyXG5cclxuXHQvKipcclxuXHQgKiBUaGUgbWV0aG9kIHBhcnNlcyB0aGUgZ2l2ZW4gbmF0aXZlIGNvZGUgYW4gcmV0dXJucyBhIG5vZGUgZnVuY3Rpb24uXHJcblx0ICpcclxuXHQgKiBAYWJzdHJhY3RcclxuXHQgKiBAcGFyYW0ge1N0cmluZ30gc291cmNlIC0gVGhlIG5hdGl2ZSBzaGFkZXIgY29kZS5cclxuXHQgKiBAcmV0dXJuIHtOb2RlRnVuY3Rpb259IEEgbm9kZSBmdW5jdGlvbi5cclxuXHQgKi9cclxuXHRwYXJzZUZ1bmN0aW9uKCAvKnNvdXJjZSovICkge1xyXG5cclxuXHRcdGNvbnNvbGUud2FybiggJ0Fic3RyYWN0IGZ1bmN0aW9uLicgKTtcclxuXHJcblx0fVxyXG5cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgTm9kZVBhcnNlcjtcclxuIiwiLyoqXHJcbiAqIEJhc2UgY2xhc3MgZm9yIG5vZGUgZnVuY3Rpb25zLiBBIGRlcml2ZWQgbW9kdWxlIG11c3QgYmUgaW1wbGVtZW50ZWRcclxuICogZm9yIGVhY2ggc3VwcG9ydGVkIG5hdGl2ZSBzaGFkZXIgbGFuZ3VhZ2UuIFNpbWlsYXIgdG8gb3RoZXIgYE5vZGUqYCBtb2R1bGVzLFxyXG4gKiB0aGlzIGNsYXNzIGlzIG9ubHkgcmVsZXZhbnQgZHVyaW5nIHRoZSBidWlsZGluZyBwcm9jZXNzIGFuZCBub3QgdXNlZFxyXG4gKiBpbiB1c2VyLWxldmVsIGNvZGUuXHJcbiAqL1xyXG5jbGFzcyBOb2RlRnVuY3Rpb24ge1xyXG5cclxuXHQvKipcclxuXHQgKiBDb25zdHJ1Y3RzIGEgbmV3IG5vZGUgZnVuY3Rpb24uXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSAtIFRoZSBub2RlIHR5cGUuIFRoaXMgdHlwZSBpcyB0aGUgcmV0dXJuIHR5cGUgb2YgdGhlIG5vZGUgZnVuY3Rpb24uXHJcblx0ICogQHBhcmFtIHtBcnJheTxOb2RlRnVuY3Rpb25JbnB1dD59IGlucHV0cyAtIFRoZSBmdW5jdGlvbidzIGlucHV0cy5cclxuXHQgKiBAcGFyYW0ge1N0cmluZ30gW25hbWU9JyddIC0gVGhlIGZ1bmN0aW9uJ3MgbmFtZS5cclxuXHQgKiBAcGFyYW0ge1N0cmluZ30gW3ByZWNpc2lvbj0nJ10gLSBUaGUgcHJlY2lzaW9uIHF1YWxpZmllci5cclxuXHQgKi9cclxuXHRjb25zdHJ1Y3RvciggdHlwZSwgaW5wdXRzLCBuYW1lID0gJycsIHByZWNpc2lvbiA9ICcnICkge1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogVGhlIG5vZGUgdHlwZS4gVGhpcyB0eXBlIGlzIHRoZSByZXR1cm4gdHlwZSBvZiB0aGUgbm9kZSBmdW5jdGlvbi5cclxuXHRcdCAqXHJcblx0XHQgKiBAdHlwZSB7U3RyaW5nfVxyXG5cdFx0ICovXHJcblx0XHR0aGlzLnR5cGUgPSB0eXBlO1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogVGhlIGZ1bmN0aW9uJ3MgaW5wdXRzLlxyXG5cdFx0ICpcclxuXHRcdCAqIEB0eXBlIHtBcnJheTxOb2RlRnVuY3Rpb25JbnB1dD59XHJcblx0XHQgKi9cclxuXHRcdHRoaXMuaW5wdXRzID0gaW5wdXRzO1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogVGhlIG5hbWUgb2YgdGhlIHVuaWZvcm0uXHJcblx0XHQgKlxyXG5cdFx0ICogQHR5cGUge1N0cmluZ31cclxuXHRcdCAqIEBkZWZhdWx0ICcnXHJcblx0XHQgKi9cclxuXHRcdHRoaXMubmFtZSA9IG5hbWU7XHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBUaGUgcHJlY2lzaW9uIHF1YWxpZmllci5cclxuXHRcdCAqXHJcblx0XHQgKiBAdHlwZSB7U3RyaW5nfVxyXG5cdFx0ICogQGRlZmF1bHQgJydcclxuXHRcdCAqL1xyXG5cdFx0dGhpcy5wcmVjaXNpb24gPSBwcmVjaXNpb247XHJcblxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogVGhpcyBtZXRob2QgcmV0dXJucyB0aGUgbmF0aXZlIGNvZGUgb2YgdGhlIG5vZGUgZnVuY3Rpb24uXHJcblx0ICpcclxuXHQgKiBAYWJzdHJhY3RcclxuXHQgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSAtIFRoZSBmdW5jdGlvbidzIG5hbWUuXHJcblx0ICogQHJldHVybiB7U3RyaW5nfSBBIHNoYWRlciBjb2RlLlxyXG5cdCAqL1xyXG5cdGdldENvZGUoIC8qbmFtZSA9IHRoaXMubmFtZSovICkge1xyXG5cclxuXHRcdGNvbnNvbGUud2FybiggJ0Fic3RyYWN0IGZ1bmN0aW9uLicgKTtcclxuXHJcblx0fVxyXG5cclxufVxyXG5cclxuTm9kZUZ1bmN0aW9uLmlzTm9kZUZ1bmN0aW9uID0gdHJ1ZTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IE5vZGVGdW5jdGlvbjtcclxuIiwiaW1wb3J0IE5vZGVGdW5jdGlvbiBmcm9tICcuLi9jb3JlL05vZGVGdW5jdGlvbi5qcyc7XHJcbmltcG9ydCBOb2RlRnVuY3Rpb25JbnB1dCBmcm9tICcuLi9jb3JlL05vZGVGdW5jdGlvbklucHV0LmpzJztcclxuXHJcbmNvbnN0IGRlY2xhcmF0aW9uUmVnZXhwID0gL15cXHMqKGhpZ2hwfG1lZGl1bXB8bG93cCk/XFxzKihbYS16XzAtOV0rKVxccyooW2Etel8wLTldKyk/XFxzKlxcKChbXFxzXFxTXSo/KVxcKS9pO1xyXG5jb25zdCBwcm9wZXJ0aWVzUmVnZXhwID0gL1thLXpfMC05XSsvaWc7XHJcblxyXG5jb25zdCBwcmFnbWFNYWluID0gJyNwcmFnbWEgbWFpbic7XHJcblxyXG5jb25zdCBwYXJzZSA9ICggc291cmNlICkgPT4ge1xyXG5cclxuXHRzb3VyY2UgPSBzb3VyY2UudHJpbSgpO1xyXG5cclxuXHRjb25zdCBwcmFnbWFNYWluSW5kZXggPSBzb3VyY2UuaW5kZXhPZiggcHJhZ21hTWFpbiApO1xyXG5cclxuXHRjb25zdCBtYWluQ29kZSA9IHByYWdtYU1haW5JbmRleCAhPT0gLSAxID8gc291cmNlLnNsaWNlKCBwcmFnbWFNYWluSW5kZXggKyBwcmFnbWFNYWluLmxlbmd0aCApIDogc291cmNlO1xyXG5cclxuXHRjb25zdCBkZWNsYXJhdGlvbiA9IG1haW5Db2RlLm1hdGNoKCBkZWNsYXJhdGlvblJlZ2V4cCApO1xyXG5cclxuXHRpZiAoIGRlY2xhcmF0aW9uICE9PSBudWxsICYmIGRlY2xhcmF0aW9uLmxlbmd0aCA9PT0gNSApIHtcclxuXHJcblx0XHQvLyB0b2tlbml6ZXJcclxuXHJcblx0XHRjb25zdCBpbnB1dHNDb2RlID0gZGVjbGFyYXRpb25bIDQgXTtcclxuXHRcdGNvbnN0IHByb3BzTWF0Y2hlcyA9IFtdO1xyXG5cclxuXHRcdGxldCBuYW1lTWF0Y2ggPSBudWxsO1xyXG5cclxuXHRcdHdoaWxlICggKCBuYW1lTWF0Y2ggPSBwcm9wZXJ0aWVzUmVnZXhwLmV4ZWMoIGlucHV0c0NvZGUgKSApICE9PSBudWxsICkge1xyXG5cclxuXHRcdFx0cHJvcHNNYXRjaGVzLnB1c2goIG5hbWVNYXRjaCApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvLyBwYXJzZXJcclxuXHJcblx0XHRjb25zdCBpbnB1dHMgPSBbXTtcclxuXHJcblx0XHRsZXQgaSA9IDA7XHJcblxyXG5cdFx0d2hpbGUgKCBpIDwgcHJvcHNNYXRjaGVzLmxlbmd0aCApIHtcclxuXHJcblx0XHRcdGNvbnN0IGlzQ29uc3QgPSBwcm9wc01hdGNoZXNbIGkgXVsgMCBdID09PSAnY29uc3QnO1xyXG5cclxuXHRcdFx0aWYgKCBpc0NvbnN0ID09PSB0cnVlICkge1xyXG5cclxuXHRcdFx0XHRpICsrO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0bGV0IHF1YWxpZmllciA9IHByb3BzTWF0Y2hlc1sgaSBdWyAwIF07XHJcblxyXG5cdFx0XHRpZiAoIHF1YWxpZmllciA9PT0gJ2luJyB8fCBxdWFsaWZpZXIgPT09ICdvdXQnIHx8IHF1YWxpZmllciA9PT0gJ2lub3V0JyApIHtcclxuXHJcblx0XHRcdFx0aSArKztcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdHF1YWxpZmllciA9ICcnO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Y29uc3QgdHlwZSA9IHByb3BzTWF0Y2hlc1sgaSArKyBdWyAwIF07XHJcblxyXG5cdFx0XHRsZXQgY291bnQgPSBOdW1iZXIucGFyc2VJbnQoIHByb3BzTWF0Y2hlc1sgaSBdWyAwIF0gKTtcclxuXHJcblx0XHRcdGlmICggTnVtYmVyLmlzTmFOKCBjb3VudCApID09PSBmYWxzZSApIGkgKys7XHJcblx0XHRcdGVsc2UgY291bnQgPSBudWxsO1xyXG5cclxuXHRcdFx0Y29uc3QgbmFtZSA9IHByb3BzTWF0Y2hlc1sgaSArKyBdWyAwIF07XHJcblxyXG5cdFx0XHRpbnB1dHMucHVzaCggbmV3IE5vZGVGdW5jdGlvbklucHV0KCB0eXBlLCBuYW1lLCBjb3VudCwgcXVhbGlmaWVyLCBpc0NvbnN0ICkgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly9cclxuXHJcblx0XHRjb25zdCBibG9ja0NvZGUgPSBtYWluQ29kZS5zdWJzdHJpbmcoIGRlY2xhcmF0aW9uWyAwIF0ubGVuZ3RoICk7XHJcblxyXG5cdFx0Y29uc3QgbmFtZSA9IGRlY2xhcmF0aW9uWyAzIF0gIT09IHVuZGVmaW5lZCA/IGRlY2xhcmF0aW9uWyAzIF0gOiAnJztcclxuXHRcdGNvbnN0IHR5cGUgPSBkZWNsYXJhdGlvblsgMiBdO1xyXG5cclxuXHRcdGNvbnN0IHByZWNpc2lvbiA9IGRlY2xhcmF0aW9uWyAxIF0gIT09IHVuZGVmaW5lZCA/IGRlY2xhcmF0aW9uWyAxIF0gOiAnJztcclxuXHJcblx0XHRjb25zdCBoZWFkZXJDb2RlID0gcHJhZ21hTWFpbkluZGV4ICE9PSAtIDEgPyBzb3VyY2Uuc2xpY2UoIDAsIHByYWdtYU1haW5JbmRleCApIDogJyc7XHJcblxyXG5cdFx0cmV0dXJuIHtcclxuXHRcdFx0dHlwZSxcclxuXHRcdFx0aW5wdXRzLFxyXG5cdFx0XHRuYW1lLFxyXG5cdFx0XHRwcmVjaXNpb24sXHJcblx0XHRcdGlucHV0c0NvZGUsXHJcblx0XHRcdGJsb2NrQ29kZSxcclxuXHRcdFx0aGVhZGVyQ29kZVxyXG5cdFx0fTtcclxuXHJcblx0fSBlbHNlIHtcclxuXHJcblx0XHR0aHJvdyBuZXcgRXJyb3IoICdGdW5jdGlvbk5vZGU6IEZ1bmN0aW9uIGlzIG5vdCBhIEdMU0wgY29kZS4nICk7XHJcblxyXG5cdH1cclxuXHJcbn07XHJcblxyXG4vKipcclxuICogVGhpcyBjbGFzcyByZXByZXNlbnRzIGEgR0xTTCBub2RlIGZ1bmN0aW9uLlxyXG4gKlxyXG4gKiBAYXVnbWVudHMgTm9kZUZ1bmN0aW9uXHJcbiAqL1xyXG5jbGFzcyBHTFNMTm9kZUZ1bmN0aW9uIGV4dGVuZHMgTm9kZUZ1bmN0aW9uIHtcclxuXHJcblx0LyoqXHJcblx0ICogQ29uc3RydWN0cyBhIG5ldyBHTFNMIG5vZGUgZnVuY3Rpb24uXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge1N0cmluZ30gc291cmNlIC0gVGhlIEdMU0wgc291cmNlLlxyXG5cdCAqL1xyXG5cdGNvbnN0cnVjdG9yKCBzb3VyY2UgKSB7XHJcblxyXG5cdFx0Y29uc3QgeyB0eXBlLCBpbnB1dHMsIG5hbWUsIHByZWNpc2lvbiwgaW5wdXRzQ29kZSwgYmxvY2tDb2RlLCBoZWFkZXJDb2RlIH0gPSBwYXJzZSggc291cmNlICk7XHJcblxyXG5cdFx0c3VwZXIoIHR5cGUsIGlucHV0cywgbmFtZSwgcHJlY2lzaW9uICk7XHJcblxyXG5cdFx0dGhpcy5pbnB1dHNDb2RlID0gaW5wdXRzQ29kZTtcclxuXHRcdHRoaXMuYmxvY2tDb2RlID0gYmxvY2tDb2RlO1xyXG5cdFx0dGhpcy5oZWFkZXJDb2RlID0gaGVhZGVyQ29kZTtcclxuXHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBUaGlzIG1ldGhvZCByZXR1cm5zIHRoZSBHTFNMIGNvZGUgb2YgdGhlIG5vZGUgZnVuY3Rpb24uXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge1N0cmluZ30gW25hbWU9dGhpcy5uYW1lXSAtIFRoZSBmdW5jdGlvbidzIG5hbWUuXHJcblx0ICogQHJldHVybiB7U3RyaW5nfSBUaGUgc2hhZGVyIGNvZGUuXHJcblx0ICovXHJcblx0Z2V0Q29kZSggbmFtZSA9IHRoaXMubmFtZSApIHtcclxuXHJcblx0XHRsZXQgY29kZTtcclxuXHJcblx0XHRjb25zdCBibG9ja0NvZGUgPSB0aGlzLmJsb2NrQ29kZTtcclxuXHJcblx0XHRpZiAoIGJsb2NrQ29kZSAhPT0gJycgKSB7XHJcblxyXG5cdFx0XHRjb25zdCB7IHR5cGUsIGlucHV0c0NvZGUsIGhlYWRlckNvZGUsIHByZWNpc2lvbiB9ID0gdGhpcztcclxuXHJcblx0XHRcdGxldCBkZWNsYXJhdGlvbkNvZGUgPSBgJHsgdHlwZSB9ICR7IG5hbWUgfSAoICR7IGlucHV0c0NvZGUudHJpbSgpIH0gKWA7XHJcblxyXG5cdFx0XHRpZiAoIHByZWNpc2lvbiAhPT0gJycgKSB7XHJcblxyXG5cdFx0XHRcdGRlY2xhcmF0aW9uQ29kZSA9IGAkeyBwcmVjaXNpb24gfSAkeyBkZWNsYXJhdGlvbkNvZGUgfWA7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRjb2RlID0gaGVhZGVyQ29kZSArIGRlY2xhcmF0aW9uQ29kZSArIGJsb2NrQ29kZTtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0Ly8gaW50ZXJmYWNlIGZ1bmN0aW9uXHJcblxyXG5cdFx0XHRjb2RlID0gJyc7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBjb2RlO1xyXG5cclxuXHR9XHJcblxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBHTFNMTm9kZUZ1bmN0aW9uO1xyXG4iLCJpbXBvcnQgTm9kZVBhcnNlciBmcm9tICcuLi9jb3JlL05vZGVQYXJzZXIuanMnO1xyXG5pbXBvcnQgR0xTTE5vZGVGdW5jdGlvbiBmcm9tICcuL0dMU0xOb2RlRnVuY3Rpb24uanMnO1xyXG5cclxuLyoqXHJcbiAqIEEgR0xTTCBub2RlIHBhcnNlci5cclxuICpcclxuICogQGF1Z21lbnRzIE5vZGVQYXJzZXJcclxuICovXHJcbmNsYXNzIEdMU0xOb2RlUGFyc2VyIGV4dGVuZHMgTm9kZVBhcnNlciB7XHJcblxyXG5cdC8qKlxyXG5cdCAqIFRoZSBtZXRob2QgcGFyc2VzIHRoZSBnaXZlbiBHTFNMIGNvZGUgYW4gcmV0dXJucyBhIG5vZGUgZnVuY3Rpb24uXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge1N0cmluZ30gc291cmNlIC0gVGhlIEdMU0wgY29kZS5cclxuXHQgKiBAcmV0dXJuIHtHTFNMTm9kZUZ1bmN0aW9ufSBBIG5vZGUgZnVuY3Rpb24uXHJcblx0ICovXHJcblx0cGFyc2VGdW5jdGlvbiggc291cmNlICkge1xyXG5cclxuXHRcdHJldHVybiBuZXcgR0xTTE5vZGVGdW5jdGlvbiggc291cmNlICk7XHJcblxyXG5cdH1cclxuXHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IEdMU0xOb2RlUGFyc2VyO1xyXG4iLCJpbXBvcnQgRGF0YU1hcCBmcm9tICcuLi9EYXRhTWFwLmpzJztcclxuaW1wb3J0IENoYWluTWFwIGZyb20gJy4uL0NoYWluTWFwLmpzJztcclxuaW1wb3J0IE5vZGVCdWlsZGVyU3RhdGUgZnJvbSAnLi9Ob2RlQnVpbGRlclN0YXRlLmpzJztcclxuaW1wb3J0IHsgY3ViZU1hcE5vZGUgfSBmcm9tICcuLi8uLi8uLi9ub2Rlcy91dGlscy9DdWJlTWFwTm9kZS5qcyc7XHJcbmltcG9ydCB7IE5vZGVGcmFtZSB9IGZyb20gJy4uLy4uLy4uL25vZGVzL05vZGVzLmpzJztcclxuaW1wb3J0IHsgb2JqZWN0R3JvdXAsIHJlbmRlckdyb3VwLCBmcmFtZUdyb3VwLCBjdWJlVGV4dHVyZSwgdGV4dHVyZSwgZm9nLCByYW5nZUZvZ0ZhY3RvciwgZGVuc2l0eUZvZ0ZhY3RvciwgcmVmZXJlbmNlLCBwbXJlbVRleHR1cmUsIHNjcmVlblVWIH0gZnJvbSAnLi4vLi4vLi4vbm9kZXMvVFNMLmpzJztcclxuXHJcbmltcG9ydCB7IEN1YmVVVlJlZmxlY3Rpb25NYXBwaW5nLCBFcXVpcmVjdGFuZ3VsYXJSZWZsZWN0aW9uTWFwcGluZywgRXF1aXJlY3Rhbmd1bGFyUmVmcmFjdGlvbk1hcHBpbmcgfSBmcm9tICcuLi8uLi8uLi9jb25zdGFudHMuanMnO1xyXG5pbXBvcnQgeyBoYXNoQXJyYXkgfSBmcm9tICcuLi8uLi8uLi9ub2Rlcy9jb3JlL05vZGVVdGlscy5qcyc7XHJcblxyXG5jb25zdCBvdXRwdXROb2RlTWFwID0gbmV3IFdlYWtNYXAoKTtcclxuXHJcbmNsYXNzIE5vZGVzIGV4dGVuZHMgRGF0YU1hcCB7XHJcblxyXG5cdGNvbnN0cnVjdG9yKCByZW5kZXJlciwgYmFja2VuZCApIHtcclxuXHJcblx0XHRzdXBlcigpO1xyXG5cclxuXHRcdHRoaXMucmVuZGVyZXIgPSByZW5kZXJlcjtcclxuXHRcdHRoaXMuYmFja2VuZCA9IGJhY2tlbmQ7XHJcblx0XHR0aGlzLm5vZGVGcmFtZSA9IG5ldyBOb2RlRnJhbWUoKTtcclxuXHRcdHRoaXMubm9kZUJ1aWxkZXJDYWNoZSA9IG5ldyBNYXAoKTtcclxuXHRcdHRoaXMuY2FsbEhhc2hDYWNoZSA9IG5ldyBDaGFpbk1hcCgpO1xyXG5cdFx0dGhpcy5ncm91cHNEYXRhID0gbmV3IENoYWluTWFwKCk7XHJcblxyXG5cdH1cclxuXHJcblx0dXBkYXRlR3JvdXAoIG5vZGVVbmlmb3Jtc0dyb3VwICkge1xyXG5cclxuXHRcdGNvbnN0IGdyb3VwTm9kZSA9IG5vZGVVbmlmb3Jtc0dyb3VwLmdyb3VwTm9kZTtcclxuXHRcdGNvbnN0IG5hbWUgPSBncm91cE5vZGUubmFtZTtcclxuXHJcblx0XHQvLyBvYmplY3RHcm91cCBpcyBldmVyeSB1cGRhdGVkXHJcblxyXG5cdFx0aWYgKCBuYW1lID09PSBvYmplY3RHcm91cC5uYW1lICkgcmV0dXJuIHRydWU7XHJcblxyXG5cdFx0Ly8gcmVuZGVyR3JvdXAgaXMgdXBkYXRlZCBvbmNlIHBlciByZW5kZXIvY29tcHV0ZSBjYWxsXHJcblxyXG5cdFx0aWYgKCBuYW1lID09PSByZW5kZXJHcm91cC5uYW1lICkge1xyXG5cclxuXHRcdFx0Y29uc3QgdW5pZm9ybXNHcm91cERhdGEgPSB0aGlzLmdldCggbm9kZVVuaWZvcm1zR3JvdXAgKTtcclxuXHRcdFx0Y29uc3QgcmVuZGVySWQgPSB0aGlzLm5vZGVGcmFtZS5yZW5kZXJJZDtcclxuXHJcblx0XHRcdGlmICggdW5pZm9ybXNHcm91cERhdGEucmVuZGVySWQgIT09IHJlbmRlcklkICkge1xyXG5cclxuXHRcdFx0XHR1bmlmb3Jtc0dyb3VwRGF0YS5yZW5kZXJJZCA9IHJlbmRlcklkO1xyXG5cclxuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHJldHVybiBmYWxzZTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gZnJhbWVHcm91cCBpcyB1cGRhdGVkIG9uY2UgcGVyIGZyYW1lXHJcblxyXG5cdFx0aWYgKCBuYW1lID09PSBmcmFtZUdyb3VwLm5hbWUgKSB7XHJcblxyXG5cdFx0XHRjb25zdCB1bmlmb3Jtc0dyb3VwRGF0YSA9IHRoaXMuZ2V0KCBub2RlVW5pZm9ybXNHcm91cCApO1xyXG5cdFx0XHRjb25zdCBmcmFtZUlkID0gdGhpcy5ub2RlRnJhbWUuZnJhbWVJZDtcclxuXHJcblx0XHRcdGlmICggdW5pZm9ybXNHcm91cERhdGEuZnJhbWVJZCAhPT0gZnJhbWVJZCApIHtcclxuXHJcblx0XHRcdFx0dW5pZm9ybXNHcm91cERhdGEuZnJhbWVJZCA9IGZyYW1lSWQ7XHJcblxyXG5cdFx0XHRcdHJldHVybiB0cnVlO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvLyBvdGhlciBncm91cHMgYXJlIHVwZGF0ZWQganVzdCB3aGVuIGdyb3VwTm9kZS5uZWVkc1VwZGF0ZSBpcyB0cnVlXHJcblxyXG5cdFx0Y29uc3QgZ3JvdXBDaGFpbiA9IFsgZ3JvdXBOb2RlLCBub2RlVW5pZm9ybXNHcm91cCBdO1xyXG5cclxuXHRcdGxldCBncm91cERhdGEgPSB0aGlzLmdyb3Vwc0RhdGEuZ2V0KCBncm91cENoYWluICk7XHJcblx0XHRpZiAoIGdyb3VwRGF0YSA9PT0gdW5kZWZpbmVkICkgdGhpcy5ncm91cHNEYXRhLnNldCggZ3JvdXBDaGFpbiwgZ3JvdXBEYXRhID0ge30gKTtcclxuXHJcblx0XHRpZiAoIGdyb3VwRGF0YS52ZXJzaW9uICE9PSBncm91cE5vZGUudmVyc2lvbiApIHtcclxuXHJcblx0XHRcdGdyb3VwRGF0YS52ZXJzaW9uID0gZ3JvdXBOb2RlLnZlcnNpb247XHJcblxyXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGZhbHNlO1xyXG5cclxuXHR9XHJcblxyXG5cdGdldEZvclJlbmRlckNhY2hlS2V5KCByZW5kZXJPYmplY3QgKSB7XHJcblxyXG5cdFx0cmV0dXJuIHJlbmRlck9iamVjdC5pbml0aWFsQ2FjaGVLZXk7XHJcblxyXG5cdH1cclxuXHJcblx0Z2V0Rm9yUmVuZGVyKCByZW5kZXJPYmplY3QgKSB7XHJcblxyXG5cdFx0Y29uc3QgcmVuZGVyT2JqZWN0RGF0YSA9IHRoaXMuZ2V0KCByZW5kZXJPYmplY3QgKTtcclxuXHJcblx0XHRsZXQgbm9kZUJ1aWxkZXJTdGF0ZSA9IHJlbmRlck9iamVjdERhdGEubm9kZUJ1aWxkZXJTdGF0ZTtcclxuXHJcblx0XHRpZiAoIG5vZGVCdWlsZGVyU3RhdGUgPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdGNvbnN0IHsgbm9kZUJ1aWxkZXJDYWNoZSB9ID0gdGhpcztcclxuXHJcblx0XHRcdGNvbnN0IGNhY2hlS2V5ID0gdGhpcy5nZXRGb3JSZW5kZXJDYWNoZUtleSggcmVuZGVyT2JqZWN0ICk7XHJcblxyXG5cdFx0XHRub2RlQnVpbGRlclN0YXRlID0gbm9kZUJ1aWxkZXJDYWNoZS5nZXQoIGNhY2hlS2V5ICk7XHJcblxyXG5cdFx0XHRpZiAoIG5vZGVCdWlsZGVyU3RhdGUgPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0Y29uc3Qgbm9kZUJ1aWxkZXIgPSB0aGlzLmJhY2tlbmQuY3JlYXRlTm9kZUJ1aWxkZXIoIHJlbmRlck9iamVjdC5vYmplY3QsIHRoaXMucmVuZGVyZXIgKTtcclxuXHRcdFx0XHRub2RlQnVpbGRlci5zY2VuZSA9IHJlbmRlck9iamVjdC5zY2VuZTtcclxuXHRcdFx0XHRub2RlQnVpbGRlci5tYXRlcmlhbCA9IHJlbmRlck9iamVjdC5tYXRlcmlhbDtcclxuXHRcdFx0XHRub2RlQnVpbGRlci5jYW1lcmEgPSByZW5kZXJPYmplY3QuY2FtZXJhO1xyXG5cdFx0XHRcdG5vZGVCdWlsZGVyLmNvbnRleHQubWF0ZXJpYWwgPSByZW5kZXJPYmplY3QubWF0ZXJpYWw7XHJcblx0XHRcdFx0bm9kZUJ1aWxkZXIubGlnaHRzTm9kZSA9IHJlbmRlck9iamVjdC5saWdodHNOb2RlO1xyXG5cdFx0XHRcdG5vZGVCdWlsZGVyLmVudmlyb25tZW50Tm9kZSA9IHRoaXMuZ2V0RW52aXJvbm1lbnROb2RlKCByZW5kZXJPYmplY3Quc2NlbmUgKTtcclxuXHRcdFx0XHRub2RlQnVpbGRlci5mb2dOb2RlID0gdGhpcy5nZXRGb2dOb2RlKCByZW5kZXJPYmplY3Quc2NlbmUgKTtcclxuXHRcdFx0XHRub2RlQnVpbGRlci5jbGlwcGluZ0NvbnRleHQgPSByZW5kZXJPYmplY3QuY2xpcHBpbmdDb250ZXh0O1xyXG5cdFx0XHRcdG5vZGVCdWlsZGVyLmJ1aWxkKCk7XHJcblxyXG5cdFx0XHRcdG5vZGVCdWlsZGVyU3RhdGUgPSB0aGlzLl9jcmVhdGVOb2RlQnVpbGRlclN0YXRlKCBub2RlQnVpbGRlciApO1xyXG5cclxuXHRcdFx0XHRub2RlQnVpbGRlckNhY2hlLnNldCggY2FjaGVLZXksIG5vZGVCdWlsZGVyU3RhdGUgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdG5vZGVCdWlsZGVyU3RhdGUudXNlZFRpbWVzICsrO1xyXG5cclxuXHRcdFx0cmVuZGVyT2JqZWN0RGF0YS5ub2RlQnVpbGRlclN0YXRlID0gbm9kZUJ1aWxkZXJTdGF0ZTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIG5vZGVCdWlsZGVyU3RhdGU7XHJcblxyXG5cdH1cclxuXHJcblx0ZGVsZXRlKCBvYmplY3QgKSB7XHJcblxyXG5cdFx0aWYgKCBvYmplY3QuaXNSZW5kZXJPYmplY3QgKSB7XHJcblxyXG5cdFx0XHRjb25zdCBub2RlQnVpbGRlclN0YXRlID0gdGhpcy5nZXQoIG9iamVjdCApLm5vZGVCdWlsZGVyU3RhdGU7XHJcblx0XHRcdG5vZGVCdWlsZGVyU3RhdGUudXNlZFRpbWVzIC0tO1xyXG5cclxuXHRcdFx0aWYgKCBub2RlQnVpbGRlclN0YXRlLnVzZWRUaW1lcyA9PT0gMCApIHtcclxuXHJcblx0XHRcdFx0dGhpcy5ub2RlQnVpbGRlckNhY2hlLmRlbGV0ZSggdGhpcy5nZXRGb3JSZW5kZXJDYWNoZUtleSggb2JqZWN0ICkgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHN1cGVyLmRlbGV0ZSggb2JqZWN0ICk7XHJcblxyXG5cdH1cclxuXHJcblx0Z2V0Rm9yQ29tcHV0ZSggY29tcHV0ZU5vZGUgKSB7XHJcblxyXG5cdFx0Y29uc3QgY29tcHV0ZURhdGEgPSB0aGlzLmdldCggY29tcHV0ZU5vZGUgKTtcclxuXHJcblx0XHRsZXQgbm9kZUJ1aWxkZXJTdGF0ZSA9IGNvbXB1dGVEYXRhLm5vZGVCdWlsZGVyU3RhdGU7XHJcblxyXG5cdFx0aWYgKCBub2RlQnVpbGRlclN0YXRlID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRjb25zdCBub2RlQnVpbGRlciA9IHRoaXMuYmFja2VuZC5jcmVhdGVOb2RlQnVpbGRlciggY29tcHV0ZU5vZGUsIHRoaXMucmVuZGVyZXIgKTtcclxuXHRcdFx0bm9kZUJ1aWxkZXIuYnVpbGQoKTtcclxuXHJcblx0XHRcdG5vZGVCdWlsZGVyU3RhdGUgPSB0aGlzLl9jcmVhdGVOb2RlQnVpbGRlclN0YXRlKCBub2RlQnVpbGRlciApO1xyXG5cclxuXHRcdFx0Y29tcHV0ZURhdGEubm9kZUJ1aWxkZXJTdGF0ZSA9IG5vZGVCdWlsZGVyU3RhdGU7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBub2RlQnVpbGRlclN0YXRlO1xyXG5cclxuXHR9XHJcblxyXG5cdF9jcmVhdGVOb2RlQnVpbGRlclN0YXRlKCBub2RlQnVpbGRlciApIHtcclxuXHJcblx0XHRyZXR1cm4gbmV3IE5vZGVCdWlsZGVyU3RhdGUoXHJcblx0XHRcdG5vZGVCdWlsZGVyLnZlcnRleFNoYWRlcixcclxuXHRcdFx0bm9kZUJ1aWxkZXIuZnJhZ21lbnRTaGFkZXIsXHJcblx0XHRcdG5vZGVCdWlsZGVyLmNvbXB1dGVTaGFkZXIsXHJcblx0XHRcdG5vZGVCdWlsZGVyLmdldEF0dHJpYnV0ZXNBcnJheSgpLFxyXG5cdFx0XHRub2RlQnVpbGRlci5nZXRCaW5kaW5ncygpLFxyXG5cdFx0XHRub2RlQnVpbGRlci51cGRhdGVOb2RlcyxcclxuXHRcdFx0bm9kZUJ1aWxkZXIudXBkYXRlQmVmb3JlTm9kZXMsXHJcblx0XHRcdG5vZGVCdWlsZGVyLnVwZGF0ZUFmdGVyTm9kZXMsXHJcblx0XHRcdG5vZGVCdWlsZGVyLm1vbml0b3IsXHJcblx0XHRcdG5vZGVCdWlsZGVyLnRyYW5zZm9ybXNcclxuXHRcdCk7XHJcblxyXG5cdH1cclxuXHJcblx0Z2V0RW52aXJvbm1lbnROb2RlKCBzY2VuZSApIHtcclxuXHJcblx0XHRyZXR1cm4gc2NlbmUuZW52aXJvbm1lbnROb2RlIHx8IHRoaXMuZ2V0KCBzY2VuZSApLmVudmlyb25tZW50Tm9kZSB8fCBudWxsO1xyXG5cclxuXHR9XHJcblxyXG5cdGdldEJhY2tncm91bmROb2RlKCBzY2VuZSApIHtcclxuXHJcblx0XHRyZXR1cm4gc2NlbmUuYmFja2dyb3VuZE5vZGUgfHwgdGhpcy5nZXQoIHNjZW5lICkuYmFja2dyb3VuZE5vZGUgfHwgbnVsbDtcclxuXHJcblx0fVxyXG5cclxuXHRnZXRGb2dOb2RlKCBzY2VuZSApIHtcclxuXHJcblx0XHRyZXR1cm4gc2NlbmUuZm9nTm9kZSB8fCB0aGlzLmdldCggc2NlbmUgKS5mb2dOb2RlIHx8IG51bGw7XHJcblxyXG5cdH1cclxuXHJcblx0Z2V0Q2FjaGVLZXkoIHNjZW5lLCBsaWdodHNOb2RlICkge1xyXG5cclxuXHRcdGNvbnN0IGNoYWluID0gWyBzY2VuZSwgbGlnaHRzTm9kZSBdO1xyXG5cdFx0Y29uc3QgY2FsbElkID0gdGhpcy5yZW5kZXJlci5pbmZvLmNhbGxzO1xyXG5cclxuXHRcdGxldCBjYWNoZUtleURhdGEgPSB0aGlzLmNhbGxIYXNoQ2FjaGUuZ2V0KCBjaGFpbiApO1xyXG5cclxuXHRcdGlmICggY2FjaGVLZXlEYXRhID09PSB1bmRlZmluZWQgfHwgY2FjaGVLZXlEYXRhLmNhbGxJZCAhPT0gY2FsbElkICkge1xyXG5cclxuXHRcdFx0Y29uc3QgZW52aXJvbm1lbnROb2RlID0gdGhpcy5nZXRFbnZpcm9ubWVudE5vZGUoIHNjZW5lICk7XHJcblx0XHRcdGNvbnN0IGZvZ05vZGUgPSB0aGlzLmdldEZvZ05vZGUoIHNjZW5lICk7XHJcblxyXG5cdFx0XHRjb25zdCB2YWx1ZXMgPSBbXTtcclxuXHJcblx0XHRcdGlmICggbGlnaHRzTm9kZSApIHZhbHVlcy5wdXNoKCBsaWdodHNOb2RlLmdldENhY2hlS2V5KCB0cnVlICkgKTtcclxuXHRcdFx0aWYgKCBlbnZpcm9ubWVudE5vZGUgKSB2YWx1ZXMucHVzaCggZW52aXJvbm1lbnROb2RlLmdldENhY2hlS2V5KCkgKTtcclxuXHRcdFx0aWYgKCBmb2dOb2RlICkgdmFsdWVzLnB1c2goIGZvZ05vZGUuZ2V0Q2FjaGVLZXkoKSApO1xyXG5cclxuXHRcdFx0dmFsdWVzLnB1c2goIHRoaXMucmVuZGVyZXIuc2hhZG93TWFwLmVuYWJsZWQgPyAxIDogMCApO1xyXG5cclxuXHRcdFx0Y2FjaGVLZXlEYXRhID0ge1xyXG5cdFx0XHRcdGNhbGxJZCxcclxuXHRcdFx0XHRjYWNoZUtleTogaGFzaEFycmF5KCB2YWx1ZXMgKVxyXG5cdFx0XHR9O1xyXG5cclxuXHRcdFx0dGhpcy5jYWxsSGFzaENhY2hlLnNldCggY2hhaW4sIGNhY2hlS2V5RGF0YSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gY2FjaGVLZXlEYXRhLmNhY2hlS2V5O1xyXG5cclxuXHR9XHJcblxyXG5cdHVwZGF0ZVNjZW5lKCBzY2VuZSApIHtcclxuXHJcblx0XHR0aGlzLnVwZGF0ZUVudmlyb25tZW50KCBzY2VuZSApO1xyXG5cdFx0dGhpcy51cGRhdGVGb2coIHNjZW5lICk7XHJcblx0XHR0aGlzLnVwZGF0ZUJhY2tncm91bmQoIHNjZW5lICk7XHJcblxyXG5cdH1cclxuXHJcblx0Z2V0IGlzVG9uZU1hcHBpbmdTdGF0ZSgpIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5yZW5kZXJlci5nZXRSZW5kZXJUYXJnZXQoKSA/IGZhbHNlIDogdHJ1ZTtcclxuXHJcblx0fVxyXG5cclxuXHR1cGRhdGVCYWNrZ3JvdW5kKCBzY2VuZSApIHtcclxuXHJcblx0XHRjb25zdCBzY2VuZURhdGEgPSB0aGlzLmdldCggc2NlbmUgKTtcclxuXHRcdGNvbnN0IGJhY2tncm91bmQgPSBzY2VuZS5iYWNrZ3JvdW5kO1xyXG5cclxuXHRcdGlmICggYmFja2dyb3VuZCApIHtcclxuXHJcblx0XHRcdGNvbnN0IGZvcmNlVXBkYXRlID0gKCBzY2VuZS5iYWNrZ3JvdW5kQmx1cnJpbmVzcyA9PT0gMCAmJiBzY2VuZURhdGEuYmFja2dyb3VuZEJsdXJyaW5lc3MgPiAwICkgfHwgKCBzY2VuZS5iYWNrZ3JvdW5kQmx1cnJpbmVzcyA+IDAgJiYgc2NlbmVEYXRhLmJhY2tncm91bmRCbHVycmluZXNzID09PSAwICk7XHJcblxyXG5cdFx0XHRpZiAoIHNjZW5lRGF0YS5iYWNrZ3JvdW5kICE9PSBiYWNrZ3JvdW5kIHx8IGZvcmNlVXBkYXRlICkge1xyXG5cclxuXHRcdFx0XHRsZXQgYmFja2dyb3VuZE5vZGUgPSBudWxsO1xyXG5cclxuXHRcdFx0XHRpZiAoIGJhY2tncm91bmQuaXNDdWJlVGV4dHVyZSA9PT0gdHJ1ZSB8fCAoIGJhY2tncm91bmQubWFwcGluZyA9PT0gRXF1aXJlY3Rhbmd1bGFyUmVmbGVjdGlvbk1hcHBpbmcgfHwgYmFja2dyb3VuZC5tYXBwaW5nID09PSBFcXVpcmVjdGFuZ3VsYXJSZWZyYWN0aW9uTWFwcGluZyB8fCBiYWNrZ3JvdW5kLm1hcHBpbmcgPT09IEN1YmVVVlJlZmxlY3Rpb25NYXBwaW5nICkgKSB7XHJcblxyXG5cdFx0XHRcdFx0aWYgKCBzY2VuZS5iYWNrZ3JvdW5kQmx1cnJpbmVzcyA+IDAgfHwgYmFja2dyb3VuZC5tYXBwaW5nID09PSBDdWJlVVZSZWZsZWN0aW9uTWFwcGluZyApIHtcclxuXHJcblx0XHRcdFx0XHRcdGJhY2tncm91bmROb2RlID0gcG1yZW1UZXh0dXJlKCBiYWNrZ3JvdW5kICk7XHJcblxyXG5cdFx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHRcdGxldCBlbnZNYXA7XHJcblxyXG5cdFx0XHRcdFx0XHRpZiAoIGJhY2tncm91bmQuaXNDdWJlVGV4dHVyZSA9PT0gdHJ1ZSApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0ZW52TWFwID0gY3ViZVRleHR1cmUoIGJhY2tncm91bmQgKTtcclxuXHJcblx0XHRcdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdGVudk1hcCA9IHRleHR1cmUoIGJhY2tncm91bmQgKTtcclxuXHJcblx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRcdGJhY2tncm91bmROb2RlID0gY3ViZU1hcE5vZGUoIGVudk1hcCApO1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0fSBlbHNlIGlmICggYmFja2dyb3VuZC5pc1RleHR1cmUgPT09IHRydWUgKSB7XHJcblxyXG5cdFx0XHRcdFx0YmFja2dyb3VuZE5vZGUgPSB0ZXh0dXJlKCBiYWNrZ3JvdW5kLCBzY3JlZW5VVi5mbGlwWSgpICkuc2V0VXBkYXRlTWF0cml4KCB0cnVlICk7XHJcblxyXG5cdFx0XHRcdH0gZWxzZSBpZiAoIGJhY2tncm91bmQuaXNDb2xvciAhPT0gdHJ1ZSApIHtcclxuXHJcblx0XHRcdFx0XHRjb25zb2xlLmVycm9yKCAnV2ViR1BVTm9kZXM6IFVuc3VwcG9ydGVkIGJhY2tncm91bmQgY29uZmlndXJhdGlvbi4nLCBiYWNrZ3JvdW5kICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0c2NlbmVEYXRhLmJhY2tncm91bmROb2RlID0gYmFja2dyb3VuZE5vZGU7XHJcblx0XHRcdFx0c2NlbmVEYXRhLmJhY2tncm91bmQgPSBiYWNrZ3JvdW5kO1xyXG5cdFx0XHRcdHNjZW5lRGF0YS5iYWNrZ3JvdW5kQmx1cnJpbmVzcyA9IHNjZW5lLmJhY2tncm91bmRCbHVycmluZXNzO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH0gZWxzZSBpZiAoIHNjZW5lRGF0YS5iYWNrZ3JvdW5kTm9kZSApIHtcclxuXHJcblx0XHRcdGRlbGV0ZSBzY2VuZURhdGEuYmFja2dyb3VuZE5vZGU7XHJcblx0XHRcdGRlbGV0ZSBzY2VuZURhdGEuYmFja2dyb3VuZDtcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0dXBkYXRlRm9nKCBzY2VuZSApIHtcclxuXHJcblx0XHRjb25zdCBzY2VuZURhdGEgPSB0aGlzLmdldCggc2NlbmUgKTtcclxuXHRcdGNvbnN0IHNjZW5lRm9nID0gc2NlbmUuZm9nO1xyXG5cclxuXHRcdGlmICggc2NlbmVGb2cgKSB7XHJcblxyXG5cdFx0XHRpZiAoIHNjZW5lRGF0YS5mb2cgIT09IHNjZW5lRm9nICkge1xyXG5cclxuXHRcdFx0XHRsZXQgZm9nTm9kZSA9IG51bGw7XHJcblxyXG5cdFx0XHRcdGlmICggc2NlbmVGb2cuaXNGb2dFeHAyICkge1xyXG5cclxuXHRcdFx0XHRcdGNvbnN0IGNvbG9yID0gcmVmZXJlbmNlKCAnY29sb3InLCAnY29sb3InLCBzY2VuZUZvZyApLnNldEdyb3VwKCByZW5kZXJHcm91cCApO1xyXG5cdFx0XHRcdFx0Y29uc3QgZGVuc2l0eSA9IHJlZmVyZW5jZSggJ2RlbnNpdHknLCAnZmxvYXQnLCBzY2VuZUZvZyApLnNldEdyb3VwKCByZW5kZXJHcm91cCApO1xyXG5cclxuXHRcdFx0XHRcdGZvZ05vZGUgPSBmb2coIGNvbG9yLCBkZW5zaXR5Rm9nRmFjdG9yKCBkZW5zaXR5ICkgKTtcclxuXHJcblx0XHRcdFx0fSBlbHNlIGlmICggc2NlbmVGb2cuaXNGb2cgKSB7XHJcblxyXG5cdFx0XHRcdFx0Y29uc3QgY29sb3IgPSByZWZlcmVuY2UoICdjb2xvcicsICdjb2xvcicsIHNjZW5lRm9nICkuc2V0R3JvdXAoIHJlbmRlckdyb3VwICk7XHJcblx0XHRcdFx0XHRjb25zdCBuZWFyID0gcmVmZXJlbmNlKCAnbmVhcicsICdmbG9hdCcsIHNjZW5lRm9nICkuc2V0R3JvdXAoIHJlbmRlckdyb3VwICk7XHJcblx0XHRcdFx0XHRjb25zdCBmYXIgPSByZWZlcmVuY2UoICdmYXInLCAnZmxvYXQnLCBzY2VuZUZvZyApLnNldEdyb3VwKCByZW5kZXJHcm91cCApO1xyXG5cclxuXHRcdFx0XHRcdGZvZ05vZGUgPSBmb2coIGNvbG9yLCByYW5nZUZvZ0ZhY3RvciggbmVhciwgZmFyICkgKTtcclxuXHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHRjb25zb2xlLmVycm9yKCAnV2ViR1BVTm9kZXM6IFVuc3VwcG9ydGVkIGZvZyBjb25maWd1cmF0aW9uLicsIHNjZW5lRm9nICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0c2NlbmVEYXRhLmZvZ05vZGUgPSBmb2dOb2RlO1xyXG5cdFx0XHRcdHNjZW5lRGF0YS5mb2cgPSBzY2VuZUZvZztcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0ZGVsZXRlIHNjZW5lRGF0YS5mb2dOb2RlO1xyXG5cdFx0XHRkZWxldGUgc2NlbmVEYXRhLmZvZztcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0dXBkYXRlRW52aXJvbm1lbnQoIHNjZW5lICkge1xyXG5cclxuXHRcdGNvbnN0IHNjZW5lRGF0YSA9IHRoaXMuZ2V0KCBzY2VuZSApO1xyXG5cdFx0Y29uc3QgZW52aXJvbm1lbnQgPSBzY2VuZS5lbnZpcm9ubWVudDtcclxuXHJcblx0XHRpZiAoIGVudmlyb25tZW50ICkge1xyXG5cclxuXHRcdFx0aWYgKCBzY2VuZURhdGEuZW52aXJvbm1lbnQgIT09IGVudmlyb25tZW50ICkge1xyXG5cclxuXHRcdFx0XHRsZXQgZW52aXJvbm1lbnROb2RlID0gbnVsbDtcclxuXHJcblx0XHRcdFx0aWYgKCBlbnZpcm9ubWVudC5pc0N1YmVUZXh0dXJlID09PSB0cnVlICkge1xyXG5cclxuXHRcdFx0XHRcdGVudmlyb25tZW50Tm9kZSA9IGN1YmVUZXh0dXJlKCBlbnZpcm9ubWVudCApO1xyXG5cclxuXHRcdFx0XHR9IGVsc2UgaWYgKCBlbnZpcm9ubWVudC5pc1RleHR1cmUgPT09IHRydWUgKSB7XHJcblxyXG5cdFx0XHRcdFx0ZW52aXJvbm1lbnROb2RlID0gdGV4dHVyZSggZW52aXJvbm1lbnQgKTtcclxuXHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHRjb25zb2xlLmVycm9yKCAnTm9kZXM6IFVuc3VwcG9ydGVkIGVudmlyb25tZW50IGNvbmZpZ3VyYXRpb24uJywgZW52aXJvbm1lbnQgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRzY2VuZURhdGEuZW52aXJvbm1lbnROb2RlID0gZW52aXJvbm1lbnROb2RlO1xyXG5cdFx0XHRcdHNjZW5lRGF0YS5lbnZpcm9ubWVudCA9IGVudmlyb25tZW50O1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH0gZWxzZSBpZiAoIHNjZW5lRGF0YS5lbnZpcm9ubWVudE5vZGUgKSB7XHJcblxyXG5cdFx0XHRkZWxldGUgc2NlbmVEYXRhLmVudmlyb25tZW50Tm9kZTtcclxuXHRcdFx0ZGVsZXRlIHNjZW5lRGF0YS5lbnZpcm9ubWVudDtcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0Z2V0Tm9kZUZyYW1lKCByZW5kZXJlciA9IHRoaXMucmVuZGVyZXIsIHNjZW5lID0gbnVsbCwgb2JqZWN0ID0gbnVsbCwgY2FtZXJhID0gbnVsbCwgbWF0ZXJpYWwgPSBudWxsICkge1xyXG5cclxuXHRcdGNvbnN0IG5vZGVGcmFtZSA9IHRoaXMubm9kZUZyYW1lO1xyXG5cdFx0bm9kZUZyYW1lLnJlbmRlcmVyID0gcmVuZGVyZXI7XHJcblx0XHRub2RlRnJhbWUuc2NlbmUgPSBzY2VuZTtcclxuXHRcdG5vZGVGcmFtZS5vYmplY3QgPSBvYmplY3Q7XHJcblx0XHRub2RlRnJhbWUuY2FtZXJhID0gY2FtZXJhO1xyXG5cdFx0bm9kZUZyYW1lLm1hdGVyaWFsID0gbWF0ZXJpYWw7XHJcblxyXG5cdFx0cmV0dXJuIG5vZGVGcmFtZTtcclxuXHJcblx0fVxyXG5cclxuXHRnZXROb2RlRnJhbWVGb3JSZW5kZXIoIHJlbmRlck9iamVjdCApIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5nZXROb2RlRnJhbWUoIHJlbmRlck9iamVjdC5yZW5kZXJlciwgcmVuZGVyT2JqZWN0LnNjZW5lLCByZW5kZXJPYmplY3Qub2JqZWN0LCByZW5kZXJPYmplY3QuY2FtZXJhLCByZW5kZXJPYmplY3QubWF0ZXJpYWwgKTtcclxuXHJcblx0fVxyXG5cclxuXHRnZXRPdXRwdXRDYWNoZUtleSgpIHtcclxuXHJcblx0XHRjb25zdCByZW5kZXJlciA9IHRoaXMucmVuZGVyZXI7XHJcblxyXG5cdFx0cmV0dXJuIHJlbmRlcmVyLnRvbmVNYXBwaW5nICsgJywnICsgcmVuZGVyZXIuY3VycmVudENvbG9yU3BhY2U7XHJcblxyXG5cdH1cclxuXHJcblx0aGFzT3V0cHV0Q2hhbmdlKCBvdXRwdXRUYXJnZXQgKSB7XHJcblxyXG5cdFx0Y29uc3QgY2FjaGVLZXkgPSBvdXRwdXROb2RlTWFwLmdldCggb3V0cHV0VGFyZ2V0ICk7XHJcblxyXG5cdFx0cmV0dXJuIGNhY2hlS2V5ICE9PSB0aGlzLmdldE91dHB1dENhY2hlS2V5KCk7XHJcblxyXG5cdH1cclxuXHJcblx0Z2V0T3V0cHV0Tm9kZSggb3V0cHV0VGV4dHVyZSApIHtcclxuXHJcblx0XHRjb25zdCByZW5kZXJlciA9IHRoaXMucmVuZGVyZXI7XHJcblx0XHRjb25zdCBjYWNoZUtleSA9IHRoaXMuZ2V0T3V0cHV0Q2FjaGVLZXkoKTtcclxuXHJcblx0XHRjb25zdCBvdXRwdXQgPSB0ZXh0dXJlKCBvdXRwdXRUZXh0dXJlLCBzY3JlZW5VViApLnJlbmRlck91dHB1dCggcmVuZGVyZXIudG9uZU1hcHBpbmcsIHJlbmRlcmVyLmN1cnJlbnRDb2xvclNwYWNlICk7XHJcblxyXG5cdFx0b3V0cHV0Tm9kZU1hcC5zZXQoIG91dHB1dFRleHR1cmUsIGNhY2hlS2V5ICk7XHJcblxyXG5cdFx0cmV0dXJuIG91dHB1dDtcclxuXHJcblx0fVxyXG5cclxuXHR1cGRhdGVCZWZvcmUoIHJlbmRlck9iamVjdCApIHtcclxuXHJcblx0XHRjb25zdCBub2RlQnVpbGRlciA9IHJlbmRlck9iamVjdC5nZXROb2RlQnVpbGRlclN0YXRlKCk7XHJcblxyXG5cdFx0Zm9yICggY29uc3Qgbm9kZSBvZiBub2RlQnVpbGRlci51cGRhdGVCZWZvcmVOb2RlcyApIHtcclxuXHJcblx0XHRcdC8vIHVwZGF0ZSBmcmFtZSBzdGF0ZSBmb3IgZWFjaCBub2RlXHJcblxyXG5cdFx0XHR0aGlzLmdldE5vZGVGcmFtZUZvclJlbmRlciggcmVuZGVyT2JqZWN0ICkudXBkYXRlQmVmb3JlTm9kZSggbm9kZSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHR1cGRhdGVBZnRlciggcmVuZGVyT2JqZWN0ICkge1xyXG5cclxuXHRcdGNvbnN0IG5vZGVCdWlsZGVyID0gcmVuZGVyT2JqZWN0LmdldE5vZGVCdWlsZGVyU3RhdGUoKTtcclxuXHJcblx0XHRmb3IgKCBjb25zdCBub2RlIG9mIG5vZGVCdWlsZGVyLnVwZGF0ZUFmdGVyTm9kZXMgKSB7XHJcblxyXG5cdFx0XHQvLyB1cGRhdGUgZnJhbWUgc3RhdGUgZm9yIGVhY2ggbm9kZVxyXG5cclxuXHRcdFx0dGhpcy5nZXROb2RlRnJhbWVGb3JSZW5kZXIoIHJlbmRlck9iamVjdCApLnVwZGF0ZUFmdGVyTm9kZSggbm9kZSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHR1cGRhdGVGb3JDb21wdXRlKCBjb21wdXRlTm9kZSApIHtcclxuXHJcblx0XHRjb25zdCBub2RlRnJhbWUgPSB0aGlzLmdldE5vZGVGcmFtZSgpO1xyXG5cdFx0Y29uc3Qgbm9kZUJ1aWxkZXIgPSB0aGlzLmdldEZvckNvbXB1dGUoIGNvbXB1dGVOb2RlICk7XHJcblxyXG5cdFx0Zm9yICggY29uc3Qgbm9kZSBvZiBub2RlQnVpbGRlci51cGRhdGVOb2RlcyApIHtcclxuXHJcblx0XHRcdG5vZGVGcmFtZS51cGRhdGVOb2RlKCBub2RlICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdHVwZGF0ZUZvclJlbmRlciggcmVuZGVyT2JqZWN0ICkge1xyXG5cclxuXHRcdGNvbnN0IG5vZGVGcmFtZSA9IHRoaXMuZ2V0Tm9kZUZyYW1lRm9yUmVuZGVyKCByZW5kZXJPYmplY3QgKTtcclxuXHRcdGNvbnN0IG5vZGVCdWlsZGVyID0gcmVuZGVyT2JqZWN0LmdldE5vZGVCdWlsZGVyU3RhdGUoKTtcclxuXHJcblx0XHRmb3IgKCBjb25zdCBub2RlIG9mIG5vZGVCdWlsZGVyLnVwZGF0ZU5vZGVzICkge1xyXG5cclxuXHRcdFx0bm9kZUZyYW1lLnVwZGF0ZU5vZGUoIG5vZGUgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0bmVlZHNSZWZyZXNoKCByZW5kZXJPYmplY3QgKSB7XHJcblxyXG5cdFx0Y29uc3Qgbm9kZUZyYW1lID0gdGhpcy5nZXROb2RlRnJhbWVGb3JSZW5kZXIoIHJlbmRlck9iamVjdCApO1xyXG5cdFx0Y29uc3QgbW9uaXRvciA9IHJlbmRlck9iamVjdC5nZXRNb25pdG9yKCk7XHJcblxyXG5cdFx0cmV0dXJuIG1vbml0b3IubmVlZHNSZWZyZXNoKCByZW5kZXJPYmplY3QsIG5vZGVGcmFtZSApO1xyXG5cclxuXHR9XHJcblxyXG5cdGRpc3Bvc2UoKSB7XHJcblxyXG5cdFx0c3VwZXIuZGlzcG9zZSgpO1xyXG5cclxuXHRcdHRoaXMubm9kZUZyYW1lID0gbmV3IE5vZGVGcmFtZSgpO1xyXG5cdFx0dGhpcy5ub2RlQnVpbGRlckNhY2hlID0gbmV3IE1hcCgpO1xyXG5cclxuXHR9XHJcblxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBOb2RlcztcclxuIiwiaW1wb3J0IHsgTWF0cml4MyB9IGZyb20gJy4uLy4uL21hdGgvTWF0cml4My5qcyc7XHJcbmltcG9ydCB7IFBsYW5lIH0gZnJvbSAnLi4vLi4vbWF0aC9QbGFuZS5qcyc7XHJcbmltcG9ydCB7IFZlY3RvcjQgfSBmcm9tICcuLi8uLi9tYXRoL1ZlY3RvcjQuanMnO1xyXG5cclxuY29uc3QgX3BsYW5lID0gLypAX19QVVJFX18qLyBuZXcgUGxhbmUoKTtcclxuXHJcbmNsYXNzIENsaXBwaW5nQ29udGV4dCB7XHJcblxyXG5cdGNvbnN0cnVjdG9yKCBwYXJlbnRDb250ZXh0ID0gbnVsbCApIHtcclxuXHJcblx0XHR0aGlzLnZlcnNpb24gPSAwO1xyXG5cclxuXHRcdHRoaXMuY2xpcEludGVyc2VjdGlvbiA9IG51bGw7XHJcblx0XHR0aGlzLmNhY2hlS2V5ID0gJyc7XHJcblxyXG5cclxuXHRcdGlmICggcGFyZW50Q29udGV4dCA9PT0gbnVsbCApIHtcclxuXHJcblx0XHRcdHRoaXMuaW50ZXJzZWN0aW9uUGxhbmVzID0gW107XHJcblx0XHRcdHRoaXMudW5pb25QbGFuZXMgPSBbXTtcclxuXHJcblx0XHRcdHRoaXMudmlld05vcm1hbE1hdHJpeCA9IG5ldyBNYXRyaXgzKCk7XHJcblx0XHRcdHRoaXMuY2xpcHBpbmdHcm91cENvbnRleHRzID0gbmV3IFdlYWtNYXAoKTtcclxuXHJcblx0XHRcdHRoaXMuc2hhZG93UGFzcyA9IGZhbHNlO1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHR0aGlzLnZpZXdOb3JtYWxNYXRyaXggPSBwYXJlbnRDb250ZXh0LnZpZXdOb3JtYWxNYXRyaXg7XHJcblx0XHRcdHRoaXMuY2xpcHBpbmdHcm91cENvbnRleHRzID0gcGFyZW50Q29udGV4dC5jbGlwcGluZ0dyb3VwQ29udGV4dHM7XHJcblxyXG5cdFx0XHR0aGlzLnNoYWRvd1Bhc3MgPSBwYXJlbnRDb250ZXh0LnNoYWRvd1Bhc3M7XHJcblxyXG5cdFx0XHR0aGlzLnZpZXdNYXRyaXggPSBwYXJlbnRDb250ZXh0LnZpZXdNYXRyaXg7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMucGFyZW50VmVyc2lvbiA9IG51bGw7XHJcblxyXG5cdH1cclxuXHJcblx0cHJvamVjdFBsYW5lcyggc291cmNlLCBkZXN0aW5hdGlvbiwgb2Zmc2V0ICkge1xyXG5cclxuXHRcdGNvbnN0IGwgPSBzb3VyY2UubGVuZ3RoO1xyXG5cclxuXHRcdGZvciAoIGxldCBpID0gMDsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRfcGxhbmUuY29weSggc291cmNlWyBpIF0gKS5hcHBseU1hdHJpeDQoIHRoaXMudmlld01hdHJpeCwgdGhpcy52aWV3Tm9ybWFsTWF0cml4ICk7XHJcblxyXG5cdFx0XHRjb25zdCB2ID0gZGVzdGluYXRpb25bIG9mZnNldCArIGkgXTtcclxuXHRcdFx0Y29uc3Qgbm9ybWFsID0gX3BsYW5lLm5vcm1hbDtcclxuXHJcblx0XHRcdHYueCA9IC0gbm9ybWFsLng7XHJcblx0XHRcdHYueSA9IC0gbm9ybWFsLnk7XHJcblx0XHRcdHYueiA9IC0gbm9ybWFsLno7XHJcblx0XHRcdHYudyA9IF9wbGFuZS5jb25zdGFudDtcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0dXBkYXRlR2xvYmFsKCBzY2VuZSwgY2FtZXJhICkge1xyXG5cclxuXHRcdHRoaXMuc2hhZG93UGFzcyA9ICggc2NlbmUub3ZlcnJpZGVNYXRlcmlhbCAhPT0gbnVsbCAmJiBzY2VuZS5vdmVycmlkZU1hdGVyaWFsLmlzU2hhZG93Tm9kZU1hdGVyaWFsICk7XHJcblx0XHR0aGlzLnZpZXdNYXRyaXggPSBjYW1lcmEubWF0cml4V29ybGRJbnZlcnNlO1xyXG5cclxuXHRcdHRoaXMudmlld05vcm1hbE1hdHJpeC5nZXROb3JtYWxNYXRyaXgoIHRoaXMudmlld01hdHJpeCApO1xyXG5cclxuXHR9XHJcblxyXG5cdHVwZGF0ZSggcGFyZW50Q29udGV4dCwgY2xpcHBpbmdHcm91cCApIHtcclxuXHJcblx0XHRsZXQgdXBkYXRlID0gZmFsc2U7XHJcblxyXG5cdFx0aWYgKCBwYXJlbnRDb250ZXh0LnZlcnNpb24gIT09IHRoaXMucGFyZW50VmVyc2lvbiApIHtcclxuXHJcblx0XHRcdHRoaXMuaW50ZXJzZWN0aW9uUGxhbmVzID0gQXJyYXkuZnJvbSggcGFyZW50Q29udGV4dC5pbnRlcnNlY3Rpb25QbGFuZXMgKTtcclxuXHRcdFx0dGhpcy51bmlvblBsYW5lcyA9IEFycmF5LmZyb20oIHBhcmVudENvbnRleHQudW5pb25QbGFuZXMgKTtcclxuXHRcdFx0dGhpcy5wYXJlbnRWZXJzaW9uID0gcGFyZW50Q29udGV4dC52ZXJzaW9uO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIHRoaXMuY2xpcEludGVyc2VjdGlvbiAhPT0gY2xpcHBpbmdHcm91cC5jbGlwSW50ZXJzZWN0aW9uICkge1xyXG5cclxuXHRcdFx0dGhpcy5jbGlwSW50ZXJzZWN0aW9uID0gY2xpcHBpbmdHcm91cC5jbGlwSW50ZXJzZWN0aW9uO1xyXG5cclxuXHRcdFx0aWYgKCB0aGlzLmNsaXBJbnRlcnNlY3Rpb24gKSB7XHJcblxyXG5cdFx0XHRcdHRoaXMudW5pb25QbGFuZXMubGVuZ3RoID0gcGFyZW50Q29udGV4dC51bmlvblBsYW5lcy5sZW5ndGg7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHR0aGlzLmludGVyc2VjdGlvblBsYW5lcy5sZW5ndGggPSBwYXJlbnRDb250ZXh0LmludGVyc2VjdGlvblBsYW5lcy5sZW5ndGg7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGNvbnN0IHNyY0NsaXBwaW5nUGxhbmVzID0gY2xpcHBpbmdHcm91cC5jbGlwcGluZ1BsYW5lcztcclxuXHRcdGNvbnN0IGwgPSBzcmNDbGlwcGluZ1BsYW5lcy5sZW5ndGg7XHJcblxyXG5cdFx0bGV0IGRzdENsaXBwaW5nUGxhbmVzO1xyXG5cdFx0bGV0IG9mZnNldDtcclxuXHJcblx0XHRpZiAoIHRoaXMuY2xpcEludGVyc2VjdGlvbiApIHtcclxuXHJcblx0XHRcdGRzdENsaXBwaW5nUGxhbmVzID0gdGhpcy5pbnRlcnNlY3Rpb25QbGFuZXM7XHJcblx0XHRcdG9mZnNldCA9IHBhcmVudENvbnRleHQuaW50ZXJzZWN0aW9uUGxhbmVzLmxlbmd0aDtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0ZHN0Q2xpcHBpbmdQbGFuZXMgPSB0aGlzLnVuaW9uUGxhbmVzO1xyXG5cdFx0XHRvZmZzZXQgPSBwYXJlbnRDb250ZXh0LnVuaW9uUGxhbmVzLmxlbmd0aDtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBkc3RDbGlwcGluZ1BsYW5lcy5sZW5ndGggIT09IG9mZnNldCArIGwgKSB7XHJcblxyXG5cdFx0XHRkc3RDbGlwcGluZ1BsYW5lcy5sZW5ndGggPSBvZmZzZXQgKyBsO1xyXG5cclxuXHRcdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgbDsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0ZHN0Q2xpcHBpbmdQbGFuZXNbIG9mZnNldCArIGkgXSA9IG5ldyBWZWN0b3I0KCk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR1cGRhdGUgPSB0cnVlO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLnByb2plY3RQbGFuZXMoIHNyY0NsaXBwaW5nUGxhbmVzLCBkc3RDbGlwcGluZ1BsYW5lcywgb2Zmc2V0ICk7XHJcblxyXG5cdFx0aWYgKCB1cGRhdGUgKSB7XHJcblxyXG5cdFx0XHR0aGlzLnZlcnNpb24gKys7XHJcblx0XHRcdHRoaXMuY2FjaGVLZXkgPSBgJHsgdGhpcy5pbnRlcnNlY3Rpb25QbGFuZXMubGVuZ3RoIH06JHsgdGhpcy51bmlvblBsYW5lcy5sZW5ndGggfWA7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdGdldEdyb3VwQ29udGV4dCggY2xpcHBpbmdHcm91cCApIHtcclxuXHJcblx0XHRpZiAoIHRoaXMuc2hhZG93UGFzcyAmJiAhIGNsaXBwaW5nR3JvdXAuY2xpcFNoYWRvd3MgKSByZXR1cm4gdGhpcztcclxuXHJcblx0XHRsZXQgY29udGV4dCA9IHRoaXMuY2xpcHBpbmdHcm91cENvbnRleHRzLmdldCggY2xpcHBpbmdHcm91cCApO1xyXG5cclxuXHRcdGlmICggY29udGV4dCA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0Y29udGV4dCA9IG5ldyBDbGlwcGluZ0NvbnRleHQoIHRoaXMgKTtcclxuXHRcdFx0dGhpcy5jbGlwcGluZ0dyb3VwQ29udGV4dHMuc2V0KCBjbGlwcGluZ0dyb3VwLCBjb250ZXh0ICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGNvbnRleHQudXBkYXRlKCB0aGlzLCBjbGlwcGluZ0dyb3VwICk7XHJcblxyXG5cdFx0cmV0dXJuIGNvbnRleHQ7XHJcblxyXG5cdH1cclxuXHJcblx0Z2V0IHVuaW9uQ2xpcHBpbmdDb3VudCgpIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy51bmlvblBsYW5lcy5sZW5ndGg7XHJcblxyXG5cdH1cclxuXHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IENsaXBwaW5nQ29udGV4dDtcclxuIiwiY2xhc3MgUmVuZGVyQnVuZGxlIHtcclxuXHJcblx0Y29uc3RydWN0b3IoIHNjZW5lLCBjYW1lcmEgKSB7XHJcblxyXG5cdFx0dGhpcy5zY2VuZSA9IHNjZW5lO1xyXG5cdFx0dGhpcy5jYW1lcmEgPSBjYW1lcmE7XHJcblxyXG5cdH1cclxuXHJcblx0Y2xvbmUoKSB7XHJcblxyXG5cdFx0cmV0dXJuIE9iamVjdC5hc3NpZ24oIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCksIHRoaXMgKTtcclxuXHJcblx0fVxyXG5cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgUmVuZGVyQnVuZGxlO1xyXG4iLCJpbXBvcnQgQ2hhaW5NYXAgZnJvbSAnLi9DaGFpbk1hcC5qcyc7XHJcbmltcG9ydCBSZW5kZXJCdW5kbGUgZnJvbSAnLi9SZW5kZXJCdW5kbGUuanMnO1xyXG5cclxuY2xhc3MgUmVuZGVyQnVuZGxlcyB7XHJcblxyXG5cdGNvbnN0cnVjdG9yKCkge1xyXG5cclxuXHRcdHRoaXMubGlzdHMgPSBuZXcgQ2hhaW5NYXAoKTtcclxuXHJcblx0fVxyXG5cclxuXHRnZXQoIHNjZW5lLCBjYW1lcmEgKSB7XHJcblxyXG5cdFx0Y29uc3QgbGlzdHMgPSB0aGlzLmxpc3RzO1xyXG5cdFx0Y29uc3Qga2V5cyA9IFsgc2NlbmUsIGNhbWVyYSBdO1xyXG5cclxuXHRcdGxldCBsaXN0ID0gbGlzdHMuZ2V0KCBrZXlzICk7XHJcblxyXG5cdFx0aWYgKCBsaXN0ID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRsaXN0ID0gbmV3IFJlbmRlckJ1bmRsZSggc2NlbmUsIGNhbWVyYSApO1xyXG5cdFx0XHRsaXN0cy5zZXQoIGtleXMsIGxpc3QgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGxpc3Q7XHJcblxyXG5cdH1cclxuXHJcblx0ZGlzcG9zZSgpIHtcclxuXHJcblx0XHR0aGlzLmxpc3RzID0gbmV3IENoYWluTWFwKCk7XHJcblxyXG5cdH1cclxuXHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IFJlbmRlckJ1bmRsZXM7XHJcbiIsImNsYXNzIE5vZGVMaWJyYXJ5IHtcclxuXHJcblx0Y29uc3RydWN0b3IoKSB7XHJcblxyXG5cdFx0dGhpcy5saWdodE5vZGVzID0gbmV3IFdlYWtNYXAoKTtcclxuXHRcdHRoaXMubWF0ZXJpYWxOb2RlcyA9IG5ldyBNYXAoKTtcclxuXHRcdHRoaXMudG9uZU1hcHBpbmdOb2RlcyA9IG5ldyBNYXAoKTtcclxuXHJcblx0fVxyXG5cclxuXHRmcm9tTWF0ZXJpYWwoIG1hdGVyaWFsICkge1xyXG5cclxuXHRcdGlmICggbWF0ZXJpYWwuaXNOb2RlTWF0ZXJpYWwgKSByZXR1cm4gbWF0ZXJpYWw7XHJcblxyXG5cdFx0bGV0IG5vZGVNYXRlcmlhbCA9IG51bGw7XHJcblxyXG5cdFx0Y29uc3Qgbm9kZU1hdGVyaWFsQ2xhc3MgPSB0aGlzLmdldE1hdGVyaWFsTm9kZUNsYXNzKCBtYXRlcmlhbC50eXBlICk7XHJcblxyXG5cdFx0aWYgKCBub2RlTWF0ZXJpYWxDbGFzcyAhPT0gbnVsbCApIHtcclxuXHJcblx0XHRcdG5vZGVNYXRlcmlhbCA9IG5ldyBub2RlTWF0ZXJpYWxDbGFzcygpO1xyXG5cclxuXHRcdFx0Zm9yICggY29uc3Qga2V5IGluIG1hdGVyaWFsICkge1xyXG5cclxuXHRcdFx0XHRub2RlTWF0ZXJpYWxbIGtleSBdID0gbWF0ZXJpYWxbIGtleSBdO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gbm9kZU1hdGVyaWFsO1xyXG5cclxuXHR9XHJcblxyXG5cdGFkZFRvbmVNYXBwaW5nKCB0b25lTWFwcGluZ05vZGUsIHRvbmVNYXBwaW5nICkge1xyXG5cclxuXHRcdHRoaXMuYWRkVHlwZSggdG9uZU1hcHBpbmdOb2RlLCB0b25lTWFwcGluZywgdGhpcy50b25lTWFwcGluZ05vZGVzICk7XHJcblxyXG5cdH1cclxuXHJcblx0Z2V0VG9uZU1hcHBpbmdGdW5jdGlvbiggdG9uZU1hcHBpbmcgKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMudG9uZU1hcHBpbmdOb2Rlcy5nZXQoIHRvbmVNYXBwaW5nICkgfHwgbnVsbDtcclxuXHJcblx0fVxyXG5cclxuXHRnZXRNYXRlcmlhbE5vZGVDbGFzcyggbWF0ZXJpYWxUeXBlICkge1xyXG5cclxuXHRcdHJldHVybiB0aGlzLm1hdGVyaWFsTm9kZXMuZ2V0KCBtYXRlcmlhbFR5cGUgKSB8fCBudWxsO1xyXG5cclxuXHR9XHJcblxyXG5cdGFkZE1hdGVyaWFsKCBtYXRlcmlhbE5vZGVDbGFzcywgbWF0ZXJpYWxDbGFzc1R5cGUgKSB7XHJcblxyXG5cdFx0dGhpcy5hZGRUeXBlKCBtYXRlcmlhbE5vZGVDbGFzcywgbWF0ZXJpYWxDbGFzc1R5cGUsIHRoaXMubWF0ZXJpYWxOb2RlcyApO1xyXG5cclxuXHR9XHJcblxyXG5cdGdldExpZ2h0Tm9kZUNsYXNzKCBsaWdodCApIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5saWdodE5vZGVzLmdldCggbGlnaHQgKSB8fCBudWxsO1xyXG5cclxuXHR9XHJcblxyXG5cdGFkZExpZ2h0KCBsaWdodE5vZGVDbGFzcywgbGlnaHRDbGFzcyApIHtcclxuXHJcblx0XHR0aGlzLmFkZENsYXNzKCBsaWdodE5vZGVDbGFzcywgbGlnaHRDbGFzcywgdGhpcy5saWdodE5vZGVzICk7XHJcblxyXG5cdH1cclxuXHJcblx0YWRkVHlwZSggbm9kZUNsYXNzLCB0eXBlLCBsaWJyYXJ5ICkge1xyXG5cclxuXHRcdGlmICggbGlicmFyeS5oYXMoIHR5cGUgKSApIHtcclxuXHJcblx0XHRcdGNvbnNvbGUud2FybiggYFJlZGVmaW5pdGlvbiBvZiBub2RlICR7IHR5cGUgfWAgKTtcclxuXHRcdFx0cmV0dXJuO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIHR5cGVvZiBub2RlQ2xhc3MgIT09ICdmdW5jdGlvbicgKSB0aHJvdyBuZXcgRXJyb3IoIGBOb2RlIGNsYXNzICR7IG5vZGVDbGFzcy5uYW1lIH0gaXMgbm90IGEgY2xhc3MuYCApO1xyXG5cdFx0aWYgKCB0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgKSB0aHJvdyBuZXcgRXJyb3IoIGBCYXNlIGNsYXNzICR7IHR5cGUgfSBpcyBub3QgYSBjbGFzcy5gICk7XHJcblxyXG5cdFx0bGlicmFyeS5zZXQoIHR5cGUsIG5vZGVDbGFzcyApO1xyXG5cclxuXHR9XHJcblxyXG5cdGFkZENsYXNzKCBub2RlQ2xhc3MsIGJhc2VDbGFzcywgbGlicmFyeSApIHtcclxuXHJcblx0XHRpZiAoIGxpYnJhcnkuaGFzKCBiYXNlQ2xhc3MgKSApIHtcclxuXHJcblx0XHRcdGNvbnNvbGUud2FybiggYFJlZGVmaW5pdGlvbiBvZiBub2RlICR7IGJhc2VDbGFzcy5uYW1lIH1gICk7XHJcblx0XHRcdHJldHVybjtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCB0eXBlb2Ygbm9kZUNsYXNzICE9PSAnZnVuY3Rpb24nICkgdGhyb3cgbmV3IEVycm9yKCBgTm9kZSBjbGFzcyAkeyBub2RlQ2xhc3MubmFtZSB9IGlzIG5vdCBhIGNsYXNzLmAgKTtcclxuXHRcdGlmICggdHlwZW9mIGJhc2VDbGFzcyAhPT0gJ2Z1bmN0aW9uJyApIHRocm93IG5ldyBFcnJvciggYEJhc2UgY2xhc3MgJHsgYmFzZUNsYXNzLm5hbWUgfSBpcyBub3QgYSBjbGFzcy5gICk7XHJcblxyXG5cdFx0bGlicmFyeS5zZXQoIGJhc2VDbGFzcywgbm9kZUNsYXNzICk7XHJcblxyXG5cdH1cclxuXHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IE5vZGVMaWJyYXJ5O1xyXG4iLCJpbXBvcnQgeyBMaWdodHNOb2RlIH0gZnJvbSAnLi4vLi4vbm9kZXMvTm9kZXMuanMnO1xyXG5pbXBvcnQgQ2hhaW5NYXAgZnJvbSAnLi9DaGFpbk1hcC5qcyc7XHJcblxyXG5jb25zdCBfZGVmYXVsdExpZ2h0cyA9IC8qQF9fUFVSRV9fKi8gbmV3IExpZ2h0c05vZGUoKTtcclxuXHJcbmNsYXNzIExpZ2h0aW5nIGV4dGVuZHMgQ2hhaW5NYXAge1xyXG5cclxuXHRjb25zdHJ1Y3RvcigpIHtcclxuXHJcblx0XHRzdXBlcigpO1xyXG5cclxuXHR9XHJcblxyXG5cdGNyZWF0ZU5vZGUoIGxpZ2h0cyA9IFtdICkge1xyXG5cclxuXHRcdHJldHVybiBuZXcgTGlnaHRzTm9kZSgpLnNldExpZ2h0cyggbGlnaHRzICk7XHJcblxyXG5cdH1cclxuXHJcblx0Z2V0Tm9kZSggc2NlbmUsIGNhbWVyYSApIHtcclxuXHJcblx0XHQvLyBpZ25vcmUgcG9zdC1wcm9jZXNzaW5nXHJcblxyXG5cdFx0aWYgKCBzY2VuZS5pc1F1YWRNZXNoICkgcmV0dXJuIF9kZWZhdWx0TGlnaHRzO1xyXG5cclxuXHRcdC8vIHRpbGVkIGxpZ2h0aW5nXHJcblxyXG5cdFx0Y29uc3Qga2V5cyA9IFsgc2NlbmUsIGNhbWVyYSBdO1xyXG5cclxuXHRcdGxldCBub2RlID0gdGhpcy5nZXQoIGtleXMgKTtcclxuXHJcblx0XHRpZiAoIG5vZGUgPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdG5vZGUgPSB0aGlzLmNyZWF0ZU5vZGUoKTtcclxuXHRcdFx0dGhpcy5zZXQoIGtleXMsIG5vZGUgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIG5vZGU7XHJcblxyXG5cdH1cclxuXHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IExpZ2h0aW5nO1xyXG4iLCJpbXBvcnQgQW5pbWF0aW9uIGZyb20gJy4vQW5pbWF0aW9uLmpzJztcclxuaW1wb3J0IFJlbmRlck9iamVjdHMgZnJvbSAnLi9SZW5kZXJPYmplY3RzLmpzJztcclxuaW1wb3J0IEF0dHJpYnV0ZXMgZnJvbSAnLi9BdHRyaWJ1dGVzLmpzJztcclxuaW1wb3J0IEdlb21ldHJpZXMgZnJvbSAnLi9HZW9tZXRyaWVzLmpzJztcclxuaW1wb3J0IEluZm8gZnJvbSAnLi9JbmZvLmpzJztcclxuaW1wb3J0IFBpcGVsaW5lcyBmcm9tICcuL1BpcGVsaW5lcy5qcyc7XHJcbmltcG9ydCBCaW5kaW5ncyBmcm9tICcuL0JpbmRpbmdzLmpzJztcclxuaW1wb3J0IFJlbmRlckxpc3RzIGZyb20gJy4vUmVuZGVyTGlzdHMuanMnO1xyXG5pbXBvcnQgUmVuZGVyQ29udGV4dHMgZnJvbSAnLi9SZW5kZXJDb250ZXh0cy5qcyc7XHJcbmltcG9ydCBUZXh0dXJlcyBmcm9tICcuL1RleHR1cmVzLmpzJztcclxuaW1wb3J0IEJhY2tncm91bmQgZnJvbSAnLi9CYWNrZ3JvdW5kLmpzJztcclxuaW1wb3J0IE5vZGVzIGZyb20gJy4vbm9kZXMvTm9kZXMuanMnO1xyXG5pbXBvcnQgQ29sb3I0IGZyb20gJy4vQ29sb3I0LmpzJztcclxuaW1wb3J0IENsaXBwaW5nQ29udGV4dCBmcm9tICcuL0NsaXBwaW5nQ29udGV4dC5qcyc7XHJcbmltcG9ydCBRdWFkTWVzaCBmcm9tICcuL1F1YWRNZXNoLmpzJztcclxuaW1wb3J0IFJlbmRlckJ1bmRsZXMgZnJvbSAnLi9SZW5kZXJCdW5kbGVzLmpzJztcclxuaW1wb3J0IE5vZGVMaWJyYXJ5IGZyb20gJy4vbm9kZXMvTm9kZUxpYnJhcnkuanMnO1xyXG5pbXBvcnQgTGlnaHRpbmcgZnJvbSAnLi9MaWdodGluZy5qcyc7XHJcblxyXG5pbXBvcnQgTm9kZU1hdGVyaWFsIGZyb20gJy4uLy4uL21hdGVyaWFscy9ub2Rlcy9Ob2RlTWF0ZXJpYWwuanMnO1xyXG5cclxuaW1wb3J0IHsgU2NlbmUgfSBmcm9tICcuLi8uLi9zY2VuZXMvU2NlbmUuanMnO1xyXG5pbXBvcnQgeyBGcnVzdHVtIH0gZnJvbSAnLi4vLi4vbWF0aC9GcnVzdHVtLmpzJztcclxuaW1wb3J0IHsgTWF0cml4NCB9IGZyb20gJy4uLy4uL21hdGgvTWF0cml4NC5qcyc7XHJcbmltcG9ydCB7IFZlY3RvcjIgfSBmcm9tICcuLi8uLi9tYXRoL1ZlY3RvcjIuanMnO1xyXG5pbXBvcnQgeyBWZWN0b3I0IH0gZnJvbSAnLi4vLi4vbWF0aC9WZWN0b3I0LmpzJztcclxuaW1wb3J0IHsgUmVuZGVyVGFyZ2V0IH0gZnJvbSAnLi4vLi4vY29yZS9SZW5kZXJUYXJnZXQuanMnO1xyXG5pbXBvcnQgeyBEb3VibGVTaWRlLCBCYWNrU2lkZSwgRnJvbnRTaWRlLCBTUkdCQ29sb3JTcGFjZSwgTm9Ub25lTWFwcGluZywgTGluZWFyRmlsdGVyLCBMaW5lYXJTUkdCQ29sb3JTcGFjZSwgSGFsZkZsb2F0VHlwZSwgUkdCQUZvcm1hdCwgUENGU2hhZG93TWFwIH0gZnJvbSAnLi4vLi4vY29uc3RhbnRzLmpzJztcclxuXHJcbmNvbnN0IF9zY2VuZSA9IC8qQF9fUFVSRV9fKi8gbmV3IFNjZW5lKCk7XHJcbmNvbnN0IF9kcmF3aW5nQnVmZmVyU2l6ZSA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjIoKTtcclxuY29uc3QgX3NjcmVlbiA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjQoKTtcclxuY29uc3QgX2ZydXN0dW0gPSAvKkBfX1BVUkVfXyovIG5ldyBGcnVzdHVtKCk7XHJcbmNvbnN0IF9wcm9qU2NyZWVuTWF0cml4ID0gLypAX19QVVJFX18qLyBuZXcgTWF0cml4NCgpO1xyXG5jb25zdCBfdmVjdG9yNCA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjQoKTtcclxuXHJcbmNsYXNzIFJlbmRlcmVyIHtcclxuXHJcblx0Y29uc3RydWN0b3IoIGJhY2tlbmQsIHBhcmFtZXRlcnMgPSB7fSApIHtcclxuXHJcblx0XHR0aGlzLmlzUmVuZGVyZXIgPSB0cnVlO1xyXG5cclxuXHRcdC8vXHJcblxyXG5cdFx0Y29uc3Qge1xyXG5cdFx0XHRsb2dhcml0aG1pY0RlcHRoQnVmZmVyID0gZmFsc2UsXHJcblx0XHRcdGFscGhhID0gdHJ1ZSxcclxuXHRcdFx0ZGVwdGggPSB0cnVlLFxyXG5cdFx0XHRzdGVuY2lsID0gZmFsc2UsXHJcblx0XHRcdGFudGlhbGlhcyA9IGZhbHNlLFxyXG5cdFx0XHRzYW1wbGVzID0gMCxcclxuXHRcdFx0Z2V0RmFsbGJhY2sgPSBudWxsXHJcblx0XHR9ID0gcGFyYW1ldGVycztcclxuXHJcblx0XHQvLyBwdWJsaWNcclxuXHRcdHRoaXMuZG9tRWxlbWVudCA9IGJhY2tlbmQuZ2V0RG9tRWxlbWVudCgpO1xyXG5cclxuXHRcdHRoaXMuYmFja2VuZCA9IGJhY2tlbmQ7XHJcblxyXG5cdFx0dGhpcy5zYW1wbGVzID0gc2FtcGxlcyB8fCAoIGFudGlhbGlhcyA9PT0gdHJ1ZSApID8gNCA6IDA7XHJcblxyXG5cdFx0dGhpcy5hdXRvQ2xlYXIgPSB0cnVlO1xyXG5cdFx0dGhpcy5hdXRvQ2xlYXJDb2xvciA9IHRydWU7XHJcblx0XHR0aGlzLmF1dG9DbGVhckRlcHRoID0gdHJ1ZTtcclxuXHRcdHRoaXMuYXV0b0NsZWFyU3RlbmNpbCA9IHRydWU7XHJcblxyXG5cdFx0dGhpcy5hbHBoYSA9IGFscGhhO1xyXG5cclxuXHRcdHRoaXMubG9nYXJpdGhtaWNEZXB0aEJ1ZmZlciA9IGxvZ2FyaXRobWljRGVwdGhCdWZmZXI7XHJcblxyXG5cdFx0dGhpcy5vdXRwdXRDb2xvclNwYWNlID0gU1JHQkNvbG9yU3BhY2U7XHJcblxyXG5cdFx0dGhpcy50b25lTWFwcGluZyA9IE5vVG9uZU1hcHBpbmc7XHJcblx0XHR0aGlzLnRvbmVNYXBwaW5nRXhwb3N1cmUgPSAxLjA7XHJcblxyXG5cdFx0dGhpcy5zb3J0T2JqZWN0cyA9IHRydWU7XHJcblxyXG5cdFx0dGhpcy5kZXB0aCA9IGRlcHRoO1xyXG5cdFx0dGhpcy5zdGVuY2lsID0gc3RlbmNpbDtcclxuXHJcblx0XHR0aGlzLmluZm8gPSBuZXcgSW5mbygpO1xyXG5cclxuXHRcdHRoaXMubm9kZXMgPSB7XHJcblx0XHRcdG1vZGVsVmlld01hdHJpeDogbnVsbCxcclxuXHRcdFx0bW9kZWxOb3JtYWxWaWV3TWF0cml4OiBudWxsXHJcblx0XHR9O1xyXG5cclxuXHRcdHRoaXMubGlicmFyeSA9IG5ldyBOb2RlTGlicmFyeSgpO1xyXG5cdFx0dGhpcy5saWdodGluZyA9IG5ldyBMaWdodGluZygpO1xyXG5cclxuXHRcdC8vIGludGVybmFsc1xyXG5cclxuXHRcdHRoaXMuX2dldEZhbGxiYWNrID0gZ2V0RmFsbGJhY2s7XHJcblxyXG5cdFx0dGhpcy5fcGl4ZWxSYXRpbyA9IDE7XHJcblx0XHR0aGlzLl93aWR0aCA9IHRoaXMuZG9tRWxlbWVudC53aWR0aDtcclxuXHRcdHRoaXMuX2hlaWdodCA9IHRoaXMuZG9tRWxlbWVudC5oZWlnaHQ7XHJcblxyXG5cdFx0dGhpcy5fdmlld3BvcnQgPSBuZXcgVmVjdG9yNCggMCwgMCwgdGhpcy5fd2lkdGgsIHRoaXMuX2hlaWdodCApO1xyXG5cdFx0dGhpcy5fc2Npc3NvciA9IG5ldyBWZWN0b3I0KCAwLCAwLCB0aGlzLl93aWR0aCwgdGhpcy5faGVpZ2h0ICk7XHJcblx0XHR0aGlzLl9zY2lzc29yVGVzdCA9IGZhbHNlO1xyXG5cclxuXHRcdHRoaXMuX2F0dHJpYnV0ZXMgPSBudWxsO1xyXG5cdFx0dGhpcy5fZ2VvbWV0cmllcyA9IG51bGw7XHJcblx0XHR0aGlzLl9ub2RlcyA9IG51bGw7XHJcblx0XHR0aGlzLl9hbmltYXRpb24gPSBudWxsO1xyXG5cdFx0dGhpcy5fYmluZGluZ3MgPSBudWxsO1xyXG5cdFx0dGhpcy5fb2JqZWN0cyA9IG51bGw7XHJcblx0XHR0aGlzLl9waXBlbGluZXMgPSBudWxsO1xyXG5cdFx0dGhpcy5fYnVuZGxlcyA9IG51bGw7XHJcblx0XHR0aGlzLl9yZW5kZXJMaXN0cyA9IG51bGw7XHJcblx0XHR0aGlzLl9yZW5kZXJDb250ZXh0cyA9IG51bGw7XHJcblx0XHR0aGlzLl90ZXh0dXJlcyA9IG51bGw7XHJcblx0XHR0aGlzLl9iYWNrZ3JvdW5kID0gbnVsbDtcclxuXHJcblx0XHR0aGlzLl9xdWFkID0gbmV3IFF1YWRNZXNoKCBuZXcgTm9kZU1hdGVyaWFsKCkgKTtcclxuXHRcdHRoaXMuX3F1YWQubWF0ZXJpYWwudHlwZSA9ICdSZW5kZXJlcl9vdXRwdXQnO1xyXG5cclxuXHRcdHRoaXMuX2N1cnJlbnRSZW5kZXJDb250ZXh0ID0gbnVsbDtcclxuXHJcblx0XHR0aGlzLl9vcGFxdWVTb3J0ID0gbnVsbDtcclxuXHRcdHRoaXMuX3RyYW5zcGFyZW50U29ydCA9IG51bGw7XHJcblxyXG5cdFx0dGhpcy5fZnJhbWVCdWZmZXJUYXJnZXQgPSBudWxsO1xyXG5cclxuXHRcdGNvbnN0IGFscGhhQ2xlYXIgPSB0aGlzLmFscGhhID09PSB0cnVlID8gMCA6IDE7XHJcblxyXG5cdFx0dGhpcy5fY2xlYXJDb2xvciA9IG5ldyBDb2xvcjQoIDAsIDAsIDAsIGFscGhhQ2xlYXIgKTtcclxuXHRcdHRoaXMuX2NsZWFyRGVwdGggPSAxO1xyXG5cdFx0dGhpcy5fY2xlYXJTdGVuY2lsID0gMDtcclxuXHJcblx0XHR0aGlzLl9yZW5kZXJUYXJnZXQgPSBudWxsO1xyXG5cdFx0dGhpcy5fYWN0aXZlQ3ViZUZhY2UgPSAwO1xyXG5cdFx0dGhpcy5fYWN0aXZlTWlwbWFwTGV2ZWwgPSAwO1xyXG5cclxuXHRcdHRoaXMuX21ydCA9IG51bGw7XHJcblxyXG5cdFx0dGhpcy5fcmVuZGVyT2JqZWN0RnVuY3Rpb24gPSBudWxsO1xyXG5cdFx0dGhpcy5fY3VycmVudFJlbmRlck9iamVjdEZ1bmN0aW9uID0gbnVsbDtcclxuXHRcdHRoaXMuX2N1cnJlbnRSZW5kZXJCdW5kbGUgPSBudWxsO1xyXG5cclxuXHRcdHRoaXMuX2hhbmRsZU9iamVjdEZ1bmN0aW9uID0gdGhpcy5fcmVuZGVyT2JqZWN0RGlyZWN0O1xyXG5cclxuXHRcdHRoaXMuX2lzRGV2aWNlTG9zdCA9IGZhbHNlO1xyXG5cdFx0dGhpcy5vbkRldmljZUxvc3QgPSB0aGlzLl9vbkRldmljZUxvc3Q7XHJcblxyXG5cdFx0dGhpcy5faW5pdGlhbGl6ZWQgPSBmYWxzZTtcclxuXHRcdHRoaXMuX2luaXRQcm9taXNlID0gbnVsbDtcclxuXHJcblx0XHR0aGlzLl9jb21waWxhdGlvblByb21pc2VzID0gbnVsbDtcclxuXHJcblx0XHR0aGlzLnRyYW5zcGFyZW50ID0gdHJ1ZTtcclxuXHRcdHRoaXMub3BhcXVlID0gdHJ1ZTtcclxuXHJcblx0XHR0aGlzLnNoYWRvd01hcCA9IHtcclxuXHRcdFx0ZW5hYmxlZDogZmFsc2UsXHJcblx0XHRcdHR5cGU6IFBDRlNoYWRvd01hcFxyXG5cdFx0fTtcclxuXHJcblx0XHR0aGlzLnhyID0ge1xyXG5cdFx0XHRlbmFibGVkOiBmYWxzZVxyXG5cdFx0fTtcclxuXHJcblx0XHR0aGlzLmRlYnVnID0ge1xyXG5cdFx0XHRjaGVja1NoYWRlckVycm9yczogdHJ1ZSxcclxuXHRcdFx0b25TaGFkZXJFcnJvcjogbnVsbCxcclxuXHRcdFx0Z2V0U2hhZGVyQXN5bmM6IGFzeW5jICggc2NlbmUsIGNhbWVyYSwgb2JqZWN0ICkgPT4ge1xyXG5cclxuXHRcdFx0XHRhd2FpdCB0aGlzLmNvbXBpbGVBc3luYyggc2NlbmUsIGNhbWVyYSApO1xyXG5cclxuXHRcdFx0XHRjb25zdCByZW5kZXJMaXN0ID0gdGhpcy5fcmVuZGVyTGlzdHMuZ2V0KCBzY2VuZSwgY2FtZXJhICk7XHJcblx0XHRcdFx0Y29uc3QgcmVuZGVyQ29udGV4dCA9IHRoaXMuX3JlbmRlckNvbnRleHRzLmdldCggc2NlbmUsIGNhbWVyYSwgdGhpcy5fcmVuZGVyVGFyZ2V0ICk7XHJcblxyXG5cdFx0XHRcdGNvbnN0IG1hdGVyaWFsID0gc2NlbmUub3ZlcnJpZGVNYXRlcmlhbCB8fCBvYmplY3QubWF0ZXJpYWw7XHJcblxyXG5cdFx0XHRcdGNvbnN0IHJlbmRlck9iamVjdCA9IHRoaXMuX29iamVjdHMuZ2V0KCBvYmplY3QsIG1hdGVyaWFsLCBzY2VuZSwgY2FtZXJhLCByZW5kZXJMaXN0LmxpZ2h0c05vZGUsIHJlbmRlckNvbnRleHQsIHJlbmRlckNvbnRleHQuY2xpcHBpbmdDb250ZXh0ICk7XHJcblxyXG5cdFx0XHRcdGNvbnN0IHsgZnJhZ21lbnRTaGFkZXIsIHZlcnRleFNoYWRlciB9ID0gcmVuZGVyT2JqZWN0LmdldE5vZGVCdWlsZGVyU3RhdGUoKTtcclxuXHJcblx0XHRcdFx0cmV0dXJuIHsgZnJhZ21lbnRTaGFkZXIsIHZlcnRleFNoYWRlciB9O1xyXG5cclxuXHRcdFx0fVxyXG5cdFx0fTtcclxuXHJcblx0fVxyXG5cclxuXHRhc3luYyBpbml0KCkge1xyXG5cclxuXHRcdGlmICggdGhpcy5faW5pdGlhbGl6ZWQgKSB7XHJcblxyXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoICdSZW5kZXJlcjogQmFja2VuZCBoYXMgYWxyZWFkeSBiZWVuIGluaXRpYWxpemVkLicgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCB0aGlzLl9pbml0UHJvbWlzZSAhPT0gbnVsbCApIHtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzLl9pbml0UHJvbWlzZTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5faW5pdFByb21pc2UgPSBuZXcgUHJvbWlzZSggYXN5bmMgKCByZXNvbHZlLCByZWplY3QgKSA9PiB7XHJcblxyXG5cdFx0XHRsZXQgYmFja2VuZCA9IHRoaXMuYmFja2VuZDtcclxuXHJcblx0XHRcdHRyeSB7XHJcblxyXG5cdFx0XHRcdGF3YWl0IGJhY2tlbmQuaW5pdCggdGhpcyApO1xyXG5cclxuXHRcdFx0fSBjYXRjaCAoIGVycm9yICkge1xyXG5cclxuXHRcdFx0XHRpZiAoIHRoaXMuX2dldEZhbGxiYWNrICE9PSBudWxsICkge1xyXG5cclxuXHRcdFx0XHRcdC8vIHRyeSB0aGUgZmFsbGJhY2tcclxuXHJcblx0XHRcdFx0XHR0cnkge1xyXG5cclxuXHRcdFx0XHRcdFx0dGhpcy5iYWNrZW5kID0gYmFja2VuZCA9IHRoaXMuX2dldEZhbGxiYWNrKCBlcnJvciApO1xyXG5cdFx0XHRcdFx0XHRhd2FpdCBiYWNrZW5kLmluaXQoIHRoaXMgKTtcclxuXHJcblx0XHRcdFx0XHR9IGNhdGNoICggZXJyb3IgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRyZWplY3QoIGVycm9yICk7XHJcblx0XHRcdFx0XHRcdHJldHVybjtcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0cmVqZWN0KCBlcnJvciApO1xyXG5cdFx0XHRcdFx0cmV0dXJuO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR0aGlzLl9ub2RlcyA9IG5ldyBOb2RlcyggdGhpcywgYmFja2VuZCApO1xyXG5cdFx0XHR0aGlzLl9hbmltYXRpb24gPSBuZXcgQW5pbWF0aW9uKCB0aGlzLl9ub2RlcywgdGhpcy5pbmZvICk7XHJcblx0XHRcdHRoaXMuX2F0dHJpYnV0ZXMgPSBuZXcgQXR0cmlidXRlcyggYmFja2VuZCApO1xyXG5cdFx0XHR0aGlzLl9iYWNrZ3JvdW5kID0gbmV3IEJhY2tncm91bmQoIHRoaXMsIHRoaXMuX25vZGVzICk7XHJcblx0XHRcdHRoaXMuX2dlb21ldHJpZXMgPSBuZXcgR2VvbWV0cmllcyggdGhpcy5fYXR0cmlidXRlcywgdGhpcy5pbmZvICk7XHJcblx0XHRcdHRoaXMuX3RleHR1cmVzID0gbmV3IFRleHR1cmVzKCB0aGlzLCBiYWNrZW5kLCB0aGlzLmluZm8gKTtcclxuXHRcdFx0dGhpcy5fcGlwZWxpbmVzID0gbmV3IFBpcGVsaW5lcyggYmFja2VuZCwgdGhpcy5fbm9kZXMgKTtcclxuXHRcdFx0dGhpcy5fYmluZGluZ3MgPSBuZXcgQmluZGluZ3MoIGJhY2tlbmQsIHRoaXMuX25vZGVzLCB0aGlzLl90ZXh0dXJlcywgdGhpcy5fYXR0cmlidXRlcywgdGhpcy5fcGlwZWxpbmVzLCB0aGlzLmluZm8gKTtcclxuXHRcdFx0dGhpcy5fb2JqZWN0cyA9IG5ldyBSZW5kZXJPYmplY3RzKCB0aGlzLCB0aGlzLl9ub2RlcywgdGhpcy5fZ2VvbWV0cmllcywgdGhpcy5fcGlwZWxpbmVzLCB0aGlzLl9iaW5kaW5ncywgdGhpcy5pbmZvICk7XHJcblx0XHRcdHRoaXMuX3JlbmRlckxpc3RzID0gbmV3IFJlbmRlckxpc3RzKCB0aGlzLmxpZ2h0aW5nICk7XHJcblx0XHRcdHRoaXMuX2J1bmRsZXMgPSBuZXcgUmVuZGVyQnVuZGxlcygpO1xyXG5cdFx0XHR0aGlzLl9yZW5kZXJDb250ZXh0cyA9IG5ldyBSZW5kZXJDb250ZXh0cygpO1xyXG5cclxuXHRcdFx0Ly9cclxuXHJcblx0XHRcdHRoaXMuX2FuaW1hdGlvbi5zdGFydCgpO1xyXG5cdFx0XHR0aGlzLl9pbml0aWFsaXplZCA9IHRydWU7XHJcblxyXG5cdFx0XHRyZXNvbHZlKCk7XHJcblxyXG5cdFx0fSApO1xyXG5cclxuXHRcdHJldHVybiB0aGlzLl9pbml0UHJvbWlzZTtcclxuXHJcblx0fVxyXG5cclxuXHRnZXQgY29vcmRpbmF0ZVN5c3RlbSgpIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5iYWNrZW5kLmNvb3JkaW5hdGVTeXN0ZW07XHJcblxyXG5cdH1cclxuXHJcblx0YXN5bmMgY29tcGlsZUFzeW5jKCBzY2VuZSwgY2FtZXJhLCB0YXJnZXRTY2VuZSA9IG51bGwgKSB7XHJcblxyXG5cdFx0aWYgKCB0aGlzLl9pc0RldmljZUxvc3QgPT09IHRydWUgKSByZXR1cm47XHJcblxyXG5cdFx0aWYgKCB0aGlzLl9pbml0aWFsaXplZCA9PT0gZmFsc2UgKSBhd2FpdCB0aGlzLmluaXQoKTtcclxuXHJcblx0XHQvLyBwcmVzZXJ2ZSByZW5kZXIgdHJlZVxyXG5cclxuXHRcdGNvbnN0IG5vZGVGcmFtZSA9IHRoaXMuX25vZGVzLm5vZGVGcmFtZTtcclxuXHJcblx0XHRjb25zdCBwcmV2aW91c1JlbmRlcklkID0gbm9kZUZyYW1lLnJlbmRlcklkO1xyXG5cdFx0Y29uc3QgcHJldmlvdXNSZW5kZXJDb250ZXh0ID0gdGhpcy5fY3VycmVudFJlbmRlckNvbnRleHQ7XHJcblx0XHRjb25zdCBwcmV2aW91c1JlbmRlck9iamVjdEZ1bmN0aW9uID0gdGhpcy5fY3VycmVudFJlbmRlck9iamVjdEZ1bmN0aW9uO1xyXG5cdFx0Y29uc3QgcHJldmlvdXNDb21waWxhdGlvblByb21pc2VzID0gdGhpcy5fY29tcGlsYXRpb25Qcm9taXNlcztcclxuXHJcblx0XHQvL1xyXG5cclxuXHRcdGNvbnN0IHNjZW5lUmVmID0gKCBzY2VuZS5pc1NjZW5lID09PSB0cnVlICkgPyBzY2VuZSA6IF9zY2VuZTtcclxuXHJcblx0XHRpZiAoIHRhcmdldFNjZW5lID09PSBudWxsICkgdGFyZ2V0U2NlbmUgPSBzY2VuZTtcclxuXHJcblx0XHRjb25zdCByZW5kZXJUYXJnZXQgPSB0aGlzLl9yZW5kZXJUYXJnZXQ7XHJcblx0XHRjb25zdCByZW5kZXJDb250ZXh0ID0gdGhpcy5fcmVuZGVyQ29udGV4dHMuZ2V0KCB0YXJnZXRTY2VuZSwgY2FtZXJhLCByZW5kZXJUYXJnZXQgKTtcclxuXHRcdGNvbnN0IGFjdGl2ZU1pcG1hcExldmVsID0gdGhpcy5fYWN0aXZlTWlwbWFwTGV2ZWw7XHJcblxyXG5cdFx0Y29uc3QgY29tcGlsYXRpb25Qcm9taXNlcyA9IFtdO1xyXG5cclxuXHRcdHRoaXMuX2N1cnJlbnRSZW5kZXJDb250ZXh0ID0gcmVuZGVyQ29udGV4dDtcclxuXHRcdHRoaXMuX2N1cnJlbnRSZW5kZXJPYmplY3RGdW5jdGlvbiA9IHRoaXMucmVuZGVyT2JqZWN0O1xyXG5cclxuXHRcdHRoaXMuX2hhbmRsZU9iamVjdEZ1bmN0aW9uID0gdGhpcy5fY3JlYXRlT2JqZWN0UGlwZWxpbmU7XHJcblxyXG5cdFx0dGhpcy5fY29tcGlsYXRpb25Qcm9taXNlcyA9IGNvbXBpbGF0aW9uUHJvbWlzZXM7XHJcblxyXG5cdFx0bm9kZUZyYW1lLnJlbmRlcklkICsrO1xyXG5cclxuXHRcdC8vXHJcblxyXG5cdFx0bm9kZUZyYW1lLnVwZGF0ZSgpO1xyXG5cclxuXHRcdC8vXHJcblxyXG5cdFx0cmVuZGVyQ29udGV4dC5kZXB0aCA9IHRoaXMuZGVwdGg7XHJcblx0XHRyZW5kZXJDb250ZXh0LnN0ZW5jaWwgPSB0aGlzLnN0ZW5jaWw7XHJcblxyXG5cdFx0aWYgKCAhIHJlbmRlckNvbnRleHQuY2xpcHBpbmdDb250ZXh0ICkgcmVuZGVyQ29udGV4dC5jbGlwcGluZ0NvbnRleHQgPSBuZXcgQ2xpcHBpbmdDb250ZXh0KCk7XHJcblx0XHRyZW5kZXJDb250ZXh0LmNsaXBwaW5nQ29udGV4dC51cGRhdGVHbG9iYWwoIHNjZW5lUmVmLCBjYW1lcmEgKTtcclxuXHJcblx0XHQvL1xyXG5cclxuXHRcdHNjZW5lUmVmLm9uQmVmb3JlUmVuZGVyKCB0aGlzLCBzY2VuZSwgY2FtZXJhLCByZW5kZXJUYXJnZXQgKTtcclxuXHJcblx0XHQvL1xyXG5cclxuXHRcdGNvbnN0IHJlbmRlckxpc3QgPSB0aGlzLl9yZW5kZXJMaXN0cy5nZXQoIHNjZW5lLCBjYW1lcmEgKTtcclxuXHRcdHJlbmRlckxpc3QuYmVnaW4oKTtcclxuXHJcblx0XHR0aGlzLl9wcm9qZWN0T2JqZWN0KCBzY2VuZSwgY2FtZXJhLCAwLCByZW5kZXJMaXN0LCByZW5kZXJDb250ZXh0LmNsaXBwaW5nQ29udGV4dCApO1xyXG5cclxuXHRcdC8vIGluY2x1ZGUgbGlnaHRzIGZyb20gdGFyZ2V0IHNjZW5lXHJcblx0XHRpZiAoIHRhcmdldFNjZW5lICE9PSBzY2VuZSApIHtcclxuXHJcblx0XHRcdHRhcmdldFNjZW5lLnRyYXZlcnNlVmlzaWJsZSggZnVuY3Rpb24gKCBvYmplY3QgKSB7XHJcblxyXG5cdFx0XHRcdGlmICggb2JqZWN0LmlzTGlnaHQgJiYgb2JqZWN0LmxheWVycy50ZXN0KCBjYW1lcmEubGF5ZXJzICkgKSB7XHJcblxyXG5cdFx0XHRcdFx0cmVuZGVyTGlzdC5wdXNoTGlnaHQoIG9iamVjdCApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9ICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJlbmRlckxpc3QuZmluaXNoKCk7XHJcblxyXG5cdFx0Ly9cclxuXHJcblx0XHRpZiAoIHJlbmRlclRhcmdldCAhPT0gbnVsbCApIHtcclxuXHJcblx0XHRcdHRoaXMuX3RleHR1cmVzLnVwZGF0ZVJlbmRlclRhcmdldCggcmVuZGVyVGFyZ2V0LCBhY3RpdmVNaXBtYXBMZXZlbCApO1xyXG5cclxuXHRcdFx0Y29uc3QgcmVuZGVyVGFyZ2V0RGF0YSA9IHRoaXMuX3RleHR1cmVzLmdldCggcmVuZGVyVGFyZ2V0ICk7XHJcblxyXG5cdFx0XHRyZW5kZXJDb250ZXh0LnRleHR1cmVzID0gcmVuZGVyVGFyZ2V0RGF0YS50ZXh0dXJlcztcclxuXHRcdFx0cmVuZGVyQ29udGV4dC5kZXB0aFRleHR1cmUgPSByZW5kZXJUYXJnZXREYXRhLmRlcHRoVGV4dHVyZTtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0cmVuZGVyQ29udGV4dC50ZXh0dXJlcyA9IG51bGw7XHJcblx0XHRcdHJlbmRlckNvbnRleHQuZGVwdGhUZXh0dXJlID0gbnVsbDtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly9cclxuXHJcblx0XHR0aGlzLl9ub2Rlcy51cGRhdGVTY2VuZSggc2NlbmVSZWYgKTtcclxuXHJcblx0XHQvL1xyXG5cclxuXHRcdHRoaXMuX2JhY2tncm91bmQudXBkYXRlKCBzY2VuZVJlZiwgcmVuZGVyTGlzdCwgcmVuZGVyQ29udGV4dCApO1xyXG5cclxuXHRcdC8vIHByb2Nlc3MgcmVuZGVyIGxpc3RzXHJcblxyXG5cdFx0Y29uc3Qgb3BhcXVlT2JqZWN0cyA9IHJlbmRlckxpc3Qub3BhcXVlO1xyXG5cdFx0Y29uc3QgdHJhbnNwYXJlbnRPYmplY3RzID0gcmVuZGVyTGlzdC50cmFuc3BhcmVudDtcclxuXHRcdGNvbnN0IHRyYW5zcGFyZW50RG91YmxlUGFzc09iamVjdHMgPSByZW5kZXJMaXN0LnRyYW5zcGFyZW50RG91YmxlUGFzcztcclxuXHRcdGNvbnN0IGxpZ2h0c05vZGUgPSByZW5kZXJMaXN0LmxpZ2h0c05vZGU7XHJcblxyXG5cdFx0aWYgKCB0aGlzLm9wYXF1ZSA9PT0gdHJ1ZSAmJiBvcGFxdWVPYmplY3RzLmxlbmd0aCA+IDAgKSB0aGlzLl9yZW5kZXJPYmplY3RzKCBvcGFxdWVPYmplY3RzLCBjYW1lcmEsIHNjZW5lUmVmLCBsaWdodHNOb2RlICk7XHJcblx0XHRpZiAoIHRoaXMudHJhbnNwYXJlbnQgPT09IHRydWUgJiYgdHJhbnNwYXJlbnRPYmplY3RzLmxlbmd0aCA+IDAgKSB0aGlzLl9yZW5kZXJUcmFuc3BhcmVudHMoIHRyYW5zcGFyZW50T2JqZWN0cywgdHJhbnNwYXJlbnREb3VibGVQYXNzT2JqZWN0cywgY2FtZXJhLCBzY2VuZVJlZiwgbGlnaHRzTm9kZSApO1xyXG5cclxuXHRcdC8vIHJlc3RvcmUgcmVuZGVyIHRyZWVcclxuXHJcblx0XHRub2RlRnJhbWUucmVuZGVySWQgPSBwcmV2aW91c1JlbmRlcklkO1xyXG5cclxuXHRcdHRoaXMuX2N1cnJlbnRSZW5kZXJDb250ZXh0ID0gcHJldmlvdXNSZW5kZXJDb250ZXh0O1xyXG5cdFx0dGhpcy5fY3VycmVudFJlbmRlck9iamVjdEZ1bmN0aW9uID0gcHJldmlvdXNSZW5kZXJPYmplY3RGdW5jdGlvbjtcclxuXHRcdHRoaXMuX2NvbXBpbGF0aW9uUHJvbWlzZXMgPSBwcmV2aW91c0NvbXBpbGF0aW9uUHJvbWlzZXM7XHJcblxyXG5cdFx0dGhpcy5faGFuZGxlT2JqZWN0RnVuY3Rpb24gPSB0aGlzLl9yZW5kZXJPYmplY3REaXJlY3Q7XHJcblxyXG5cdFx0Ly8gd2FpdCBmb3IgYWxsIHByb21pc2VzIHNldHVwIGJ5IGJhY2tlbmRzIGF3YWl0aW5nIGNvbXBpbGF0aW9uL2xpbmtpbmcvcGlwZWxpbmUgY3JlYXRpb24gdG8gY29tcGxldGVcclxuXHJcblx0XHRhd2FpdCBQcm9taXNlLmFsbCggY29tcGlsYXRpb25Qcm9taXNlcyApO1xyXG5cclxuXHR9XHJcblxyXG5cdGFzeW5jIHJlbmRlckFzeW5jKCBzY2VuZSwgY2FtZXJhICkge1xyXG5cclxuXHRcdGlmICggdGhpcy5faW5pdGlhbGl6ZWQgPT09IGZhbHNlICkgYXdhaXQgdGhpcy5pbml0KCk7XHJcblxyXG5cdFx0Y29uc3QgcmVuZGVyQ29udGV4dCA9IHRoaXMuX3JlbmRlclNjZW5lKCBzY2VuZSwgY2FtZXJhICk7XHJcblxyXG5cdFx0YXdhaXQgdGhpcy5iYWNrZW5kLnJlc29sdmVUaW1lc3RhbXBBc3luYyggcmVuZGVyQ29udGV4dCwgJ3JlbmRlcicgKTtcclxuXHJcblx0fVxyXG5cclxuXHRhc3luYyB3YWl0Rm9yR1BVKCkge1xyXG5cclxuXHRcdGF3YWl0IHRoaXMuYmFja2VuZC53YWl0Rm9yR1BVKCk7XHJcblxyXG5cdH1cclxuXHJcblx0c2V0TVJUKCBtcnQgKSB7XHJcblxyXG5cdFx0dGhpcy5fbXJ0ID0gbXJ0O1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9XHJcblxyXG5cdGdldE1SVCgpIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5fbXJ0O1xyXG5cclxuXHR9XHJcblxyXG5cdF9vbkRldmljZUxvc3QoIGluZm8gKSB7XHJcblxyXG5cdFx0bGV0IGVycm9yTWVzc2FnZSA9IGBUSFJFRS5XZWJHUFVSZW5kZXJlcjogJHtpbmZvLmFwaX0gRGV2aWNlIExvc3Q6XFxuXFxuTWVzc2FnZTogJHtpbmZvLm1lc3NhZ2V9YDtcclxuXHJcblx0XHRpZiAoIGluZm8ucmVhc29uICkge1xyXG5cclxuXHRcdFx0ZXJyb3JNZXNzYWdlICs9IGBcXG5SZWFzb246ICR7aW5mby5yZWFzb259YDtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Y29uc29sZS5lcnJvciggZXJyb3JNZXNzYWdlICk7XHJcblxyXG5cdFx0dGhpcy5faXNEZXZpY2VMb3N0ID0gdHJ1ZTtcclxuXHJcblx0fVxyXG5cclxuXHJcblx0X3JlbmRlckJ1bmRsZSggYnVuZGxlLCBzY2VuZVJlZiwgbGlnaHRzTm9kZSApIHtcclxuXHJcblx0XHRjb25zdCB7IGJ1bmRsZUdyb3VwLCBjYW1lcmEsIHJlbmRlckxpc3QgfSA9IGJ1bmRsZTtcclxuXHJcblx0XHRjb25zdCByZW5kZXJDb250ZXh0ID0gdGhpcy5fY3VycmVudFJlbmRlckNvbnRleHQ7XHJcblxyXG5cdFx0Ly9cclxuXHJcblx0XHRjb25zdCByZW5kZXJCdW5kbGUgPSB0aGlzLl9idW5kbGVzLmdldCggYnVuZGxlR3JvdXAsIGNhbWVyYSApO1xyXG5cdFx0Y29uc3QgcmVuZGVyQnVuZGxlRGF0YSA9IHRoaXMuYmFja2VuZC5nZXQoIHJlbmRlckJ1bmRsZSApO1xyXG5cclxuXHRcdGlmICggcmVuZGVyQnVuZGxlRGF0YS5yZW5kZXJDb250ZXh0cyA9PT0gdW5kZWZpbmVkICkgcmVuZGVyQnVuZGxlRGF0YS5yZW5kZXJDb250ZXh0cyA9IG5ldyBTZXQoKTtcclxuXHJcblx0XHQvL1xyXG5cclxuXHRcdGNvbnN0IG5lZWRzVXBkYXRlID0gYnVuZGxlR3JvdXAudmVyc2lvbiAhPT0gcmVuZGVyQnVuZGxlRGF0YS52ZXJzaW9uO1xyXG5cdFx0Y29uc3QgcmVuZGVyQnVuZGxlTmVlZHNVcGRhdGUgPSByZW5kZXJCdW5kbGVEYXRhLnJlbmRlckNvbnRleHRzLmhhcyggcmVuZGVyQ29udGV4dCApID09PSBmYWxzZSB8fCBuZWVkc1VwZGF0ZTtcclxuXHJcblx0XHRyZW5kZXJCdW5kbGVEYXRhLnJlbmRlckNvbnRleHRzLmFkZCggcmVuZGVyQ29udGV4dCApO1xyXG5cclxuXHRcdGlmICggcmVuZGVyQnVuZGxlTmVlZHNVcGRhdGUgKSB7XHJcblxyXG5cdFx0XHR0aGlzLmJhY2tlbmQuYmVnaW5CdW5kbGUoIHJlbmRlckNvbnRleHQgKTtcclxuXHJcblx0XHRcdGlmICggcmVuZGVyQnVuZGxlRGF0YS5yZW5kZXJPYmplY3RzID09PSB1bmRlZmluZWQgfHwgbmVlZHNVcGRhdGUgKSB7XHJcblxyXG5cdFx0XHRcdHJlbmRlckJ1bmRsZURhdGEucmVuZGVyT2JqZWN0cyA9IFtdO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dGhpcy5fY3VycmVudFJlbmRlckJ1bmRsZSA9IHJlbmRlckJ1bmRsZTtcclxuXHJcblx0XHRcdGNvbnN0IG9wYXF1ZU9iamVjdHMgPSByZW5kZXJMaXN0Lm9wYXF1ZTtcclxuXHJcblx0XHRcdGlmICggdGhpcy5vcGFxdWUgPT09IHRydWUgJiYgb3BhcXVlT2JqZWN0cy5sZW5ndGggPiAwICkgdGhpcy5fcmVuZGVyT2JqZWN0cyggb3BhcXVlT2JqZWN0cywgY2FtZXJhLCBzY2VuZVJlZiwgbGlnaHRzTm9kZSApO1xyXG5cclxuXHRcdFx0dGhpcy5fY3VycmVudFJlbmRlckJ1bmRsZSA9IG51bGw7XHJcblxyXG5cdFx0XHQvL1xyXG5cclxuXHRcdFx0dGhpcy5iYWNrZW5kLmZpbmlzaEJ1bmRsZSggcmVuZGVyQ29udGV4dCwgcmVuZGVyQnVuZGxlICk7XHJcblxyXG5cdFx0XHRyZW5kZXJCdW5kbGVEYXRhLnZlcnNpb24gPSBidW5kbGVHcm91cC52ZXJzaW9uO1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRjb25zdCB7IHJlbmRlck9iamVjdHMgfSA9IHJlbmRlckJ1bmRsZURhdGE7XHJcblxyXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSByZW5kZXJPYmplY3RzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdGNvbnN0IHJlbmRlck9iamVjdCA9IHJlbmRlck9iamVjdHNbIGkgXTtcclxuXHJcblx0XHRcdFx0aWYgKCB0aGlzLl9ub2Rlcy5uZWVkc1JlZnJlc2goIHJlbmRlck9iamVjdCApICkge1xyXG5cclxuXHRcdFx0XHRcdHRoaXMuX25vZGVzLnVwZGF0ZUJlZm9yZSggcmVuZGVyT2JqZWN0ICk7XHJcblxyXG5cdFx0XHRcdFx0dGhpcy5fbm9kZXMudXBkYXRlRm9yUmVuZGVyKCByZW5kZXJPYmplY3QgKTtcclxuXHRcdFx0XHRcdHRoaXMuX2JpbmRpbmdzLnVwZGF0ZUZvclJlbmRlciggcmVuZGVyT2JqZWN0ICk7XHJcblxyXG5cdFx0XHRcdFx0dGhpcy5fbm9kZXMudXBkYXRlQWZ0ZXIoIHJlbmRlck9iamVjdCApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuYmFja2VuZC5hZGRCdW5kbGUoIHJlbmRlckNvbnRleHQsIHJlbmRlckJ1bmRsZSApO1xyXG5cclxuXHR9XHJcblxyXG5cdHJlbmRlciggc2NlbmUsIGNhbWVyYSApIHtcclxuXHJcblx0XHRpZiAoIHRoaXMuX2luaXRpYWxpemVkID09PSBmYWxzZSApIHtcclxuXHJcblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLlJlbmRlcmVyOiAucmVuZGVyKCkgY2FsbGVkIGJlZm9yZSB0aGUgYmFja2VuZCBpcyBpbml0aWFsaXplZC4gVHJ5IHVzaW5nIC5yZW5kZXJBc3luYygpIGluc3RlYWQuJyApO1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXMucmVuZGVyQXN5bmMoIHNjZW5lLCBjYW1lcmEgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fcmVuZGVyU2NlbmUoIHNjZW5lLCBjYW1lcmEgKTtcclxuXHJcblx0fVxyXG5cclxuXHRfZ2V0RnJhbWVCdWZmZXJUYXJnZXQoKSB7XHJcblxyXG5cdFx0Y29uc3QgeyBjdXJyZW50VG9uZU1hcHBpbmcsIGN1cnJlbnRDb2xvclNwYWNlIH0gPSB0aGlzO1xyXG5cclxuXHRcdGNvbnN0IHVzZVRvbmVNYXBwaW5nID0gY3VycmVudFRvbmVNYXBwaW5nICE9PSBOb1RvbmVNYXBwaW5nO1xyXG5cdFx0Y29uc3QgdXNlQ29sb3JTcGFjZSA9IGN1cnJlbnRDb2xvclNwYWNlICE9PSBMaW5lYXJTUkdCQ29sb3JTcGFjZTtcclxuXHJcblx0XHRpZiAoIHVzZVRvbmVNYXBwaW5nID09PSBmYWxzZSAmJiB1c2VDb2xvclNwYWNlID09PSBmYWxzZSApIHJldHVybiBudWxsO1xyXG5cclxuXHRcdGNvbnN0IHsgd2lkdGgsIGhlaWdodCB9ID0gdGhpcy5nZXREcmF3aW5nQnVmZmVyU2l6ZSggX2RyYXdpbmdCdWZmZXJTaXplICk7XHJcblx0XHRjb25zdCB7IGRlcHRoLCBzdGVuY2lsIH0gPSB0aGlzO1xyXG5cclxuXHRcdGxldCBmcmFtZUJ1ZmZlclRhcmdldCA9IHRoaXMuX2ZyYW1lQnVmZmVyVGFyZ2V0O1xyXG5cclxuXHRcdGlmICggZnJhbWVCdWZmZXJUYXJnZXQgPT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHRmcmFtZUJ1ZmZlclRhcmdldCA9IG5ldyBSZW5kZXJUYXJnZXQoIHdpZHRoLCBoZWlnaHQsIHtcclxuXHRcdFx0XHRkZXB0aEJ1ZmZlcjogZGVwdGgsXHJcblx0XHRcdFx0c3RlbmNpbEJ1ZmZlcjogc3RlbmNpbCxcclxuXHRcdFx0XHR0eXBlOiBIYWxmRmxvYXRUeXBlLCAvLyBGbG9hdFR5cGVcclxuXHRcdFx0XHRmb3JtYXQ6IFJHQkFGb3JtYXQsXHJcblx0XHRcdFx0Y29sb3JTcGFjZTogTGluZWFyU1JHQkNvbG9yU3BhY2UsXHJcblx0XHRcdFx0Z2VuZXJhdGVNaXBtYXBzOiBmYWxzZSxcclxuXHRcdFx0XHRtaW5GaWx0ZXI6IExpbmVhckZpbHRlcixcclxuXHRcdFx0XHRtYWdGaWx0ZXI6IExpbmVhckZpbHRlcixcclxuXHRcdFx0XHRzYW1wbGVzOiB0aGlzLnNhbXBsZXNcclxuXHRcdFx0fSApO1xyXG5cclxuXHRcdFx0ZnJhbWVCdWZmZXJUYXJnZXQuaXNQb3N0UHJvY2Vzc2luZ1JlbmRlclRhcmdldCA9IHRydWU7XHJcblxyXG5cdFx0XHR0aGlzLl9mcmFtZUJ1ZmZlclRhcmdldCA9IGZyYW1lQnVmZmVyVGFyZ2V0O1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRmcmFtZUJ1ZmZlclRhcmdldC5kZXB0aEJ1ZmZlciA9IGRlcHRoO1xyXG5cdFx0ZnJhbWVCdWZmZXJUYXJnZXQuc3RlbmNpbEJ1ZmZlciA9IHN0ZW5jaWw7XHJcblx0XHRmcmFtZUJ1ZmZlclRhcmdldC5zZXRTaXplKCB3aWR0aCwgaGVpZ2h0ICk7XHJcblx0XHRmcmFtZUJ1ZmZlclRhcmdldC52aWV3cG9ydC5jb3B5KCB0aGlzLl92aWV3cG9ydCApO1xyXG5cdFx0ZnJhbWVCdWZmZXJUYXJnZXQuc2Npc3Nvci5jb3B5KCB0aGlzLl9zY2lzc29yICk7XHJcblx0XHRmcmFtZUJ1ZmZlclRhcmdldC52aWV3cG9ydC5tdWx0aXBseVNjYWxhciggdGhpcy5fcGl4ZWxSYXRpbyApO1xyXG5cdFx0ZnJhbWVCdWZmZXJUYXJnZXQuc2Npc3Nvci5tdWx0aXBseVNjYWxhciggdGhpcy5fcGl4ZWxSYXRpbyApO1xyXG5cdFx0ZnJhbWVCdWZmZXJUYXJnZXQuc2Npc3NvclRlc3QgPSB0aGlzLl9zY2lzc29yVGVzdDtcclxuXHJcblx0XHRyZXR1cm4gZnJhbWVCdWZmZXJUYXJnZXQ7XHJcblxyXG5cdH1cclxuXHJcblx0X3JlbmRlclNjZW5lKCBzY2VuZSwgY2FtZXJhLCB1c2VGcmFtZUJ1ZmZlclRhcmdldCA9IHRydWUgKSB7XHJcblxyXG5cdFx0aWYgKCB0aGlzLl9pc0RldmljZUxvc3QgPT09IHRydWUgKSByZXR1cm47XHJcblxyXG5cdFx0Y29uc3QgZnJhbWVCdWZmZXJUYXJnZXQgPSB1c2VGcmFtZUJ1ZmZlclRhcmdldCA/IHRoaXMuX2dldEZyYW1lQnVmZmVyVGFyZ2V0KCkgOiBudWxsO1xyXG5cclxuXHRcdC8vIHByZXNlcnZlIHJlbmRlciB0cmVlXHJcblxyXG5cdFx0Y29uc3Qgbm9kZUZyYW1lID0gdGhpcy5fbm9kZXMubm9kZUZyYW1lO1xyXG5cclxuXHRcdGNvbnN0IHByZXZpb3VzUmVuZGVySWQgPSBub2RlRnJhbWUucmVuZGVySWQ7XHJcblx0XHRjb25zdCBwcmV2aW91c1JlbmRlckNvbnRleHQgPSB0aGlzLl9jdXJyZW50UmVuZGVyQ29udGV4dDtcclxuXHRcdGNvbnN0IHByZXZpb3VzUmVuZGVyT2JqZWN0RnVuY3Rpb24gPSB0aGlzLl9jdXJyZW50UmVuZGVyT2JqZWN0RnVuY3Rpb247XHJcblxyXG5cdFx0Ly9cclxuXHJcblx0XHRjb25zdCBzY2VuZVJlZiA9ICggc2NlbmUuaXNTY2VuZSA9PT0gdHJ1ZSApID8gc2NlbmUgOiBfc2NlbmU7XHJcblxyXG5cdFx0Y29uc3Qgb3V0cHV0UmVuZGVyVGFyZ2V0ID0gdGhpcy5fcmVuZGVyVGFyZ2V0O1xyXG5cclxuXHRcdGNvbnN0IGFjdGl2ZUN1YmVGYWNlID0gdGhpcy5fYWN0aXZlQ3ViZUZhY2U7XHJcblx0XHRjb25zdCBhY3RpdmVNaXBtYXBMZXZlbCA9IHRoaXMuX2FjdGl2ZU1pcG1hcExldmVsO1xyXG5cclxuXHRcdC8vXHJcblxyXG5cdFx0bGV0IHJlbmRlclRhcmdldDtcclxuXHJcblx0XHRpZiAoIGZyYW1lQnVmZmVyVGFyZ2V0ICE9PSBudWxsICkge1xyXG5cclxuXHRcdFx0cmVuZGVyVGFyZ2V0ID0gZnJhbWVCdWZmZXJUYXJnZXQ7XHJcblxyXG5cdFx0XHR0aGlzLnNldFJlbmRlclRhcmdldCggcmVuZGVyVGFyZ2V0ICk7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdHJlbmRlclRhcmdldCA9IG91dHB1dFJlbmRlclRhcmdldDtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly9cclxuXHJcblx0XHRjb25zdCByZW5kZXJDb250ZXh0ID0gdGhpcy5fcmVuZGVyQ29udGV4dHMuZ2V0KCBzY2VuZSwgY2FtZXJhLCByZW5kZXJUYXJnZXQgKTtcclxuXHJcblx0XHR0aGlzLl9jdXJyZW50UmVuZGVyQ29udGV4dCA9IHJlbmRlckNvbnRleHQ7XHJcblx0XHR0aGlzLl9jdXJyZW50UmVuZGVyT2JqZWN0RnVuY3Rpb24gPSB0aGlzLl9yZW5kZXJPYmplY3RGdW5jdGlvbiB8fCB0aGlzLnJlbmRlck9iamVjdDtcclxuXHJcblx0XHQvL1xyXG5cclxuXHRcdHRoaXMuaW5mby5jYWxscyArKztcclxuXHRcdHRoaXMuaW5mby5yZW5kZXIuY2FsbHMgKys7XHJcblx0XHR0aGlzLmluZm8ucmVuZGVyLmZyYW1lQ2FsbHMgKys7XHJcblxyXG5cdFx0bm9kZUZyYW1lLnJlbmRlcklkID0gdGhpcy5pbmZvLmNhbGxzO1xyXG5cclxuXHRcdC8vXHJcblxyXG5cdFx0Y29uc3QgY29vcmRpbmF0ZVN5c3RlbSA9IHRoaXMuY29vcmRpbmF0ZVN5c3RlbTtcclxuXHJcblx0XHRpZiAoIGNhbWVyYS5jb29yZGluYXRlU3lzdGVtICE9PSBjb29yZGluYXRlU3lzdGVtICkge1xyXG5cclxuXHRcdFx0Y2FtZXJhLmNvb3JkaW5hdGVTeXN0ZW0gPSBjb29yZGluYXRlU3lzdGVtO1xyXG5cclxuXHRcdFx0Y2FtZXJhLnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly9cclxuXHJcblx0XHRpZiAoIHNjZW5lLm1hdHJpeFdvcmxkQXV0b1VwZGF0ZSA9PT0gdHJ1ZSApIHNjZW5lLnVwZGF0ZU1hdHJpeFdvcmxkKCk7XHJcblxyXG5cdFx0aWYgKCBjYW1lcmEucGFyZW50ID09PSBudWxsICYmIGNhbWVyYS5tYXRyaXhXb3JsZEF1dG9VcGRhdGUgPT09IHRydWUgKSBjYW1lcmEudXBkYXRlTWF0cml4V29ybGQoKTtcclxuXHJcblx0XHQvL1xyXG5cclxuXHRcdGxldCB2aWV3cG9ydCA9IHRoaXMuX3ZpZXdwb3J0O1xyXG5cdFx0bGV0IHNjaXNzb3IgPSB0aGlzLl9zY2lzc29yO1xyXG5cdFx0bGV0IHBpeGVsUmF0aW8gPSB0aGlzLl9waXhlbFJhdGlvO1xyXG5cclxuXHRcdGlmICggcmVuZGVyVGFyZ2V0ICE9PSBudWxsICkge1xyXG5cclxuXHRcdFx0dmlld3BvcnQgPSByZW5kZXJUYXJnZXQudmlld3BvcnQ7XHJcblx0XHRcdHNjaXNzb3IgPSByZW5kZXJUYXJnZXQuc2Npc3NvcjtcclxuXHRcdFx0cGl4ZWxSYXRpbyA9IDE7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuZ2V0RHJhd2luZ0J1ZmZlclNpemUoIF9kcmF3aW5nQnVmZmVyU2l6ZSApO1xyXG5cclxuXHRcdF9zY3JlZW4uc2V0KCAwLCAwLCBfZHJhd2luZ0J1ZmZlclNpemUud2lkdGgsIF9kcmF3aW5nQnVmZmVyU2l6ZS5oZWlnaHQgKTtcclxuXHJcblx0XHRjb25zdCBtaW5EZXB0aCA9ICggdmlld3BvcnQubWluRGVwdGggPT09IHVuZGVmaW5lZCApID8gMCA6IHZpZXdwb3J0Lm1pbkRlcHRoO1xyXG5cdFx0Y29uc3QgbWF4RGVwdGggPSAoIHZpZXdwb3J0Lm1heERlcHRoID09PSB1bmRlZmluZWQgKSA/IDEgOiB2aWV3cG9ydC5tYXhEZXB0aDtcclxuXHJcblx0XHRyZW5kZXJDb250ZXh0LnZpZXdwb3J0VmFsdWUuY29weSggdmlld3BvcnQgKS5tdWx0aXBseVNjYWxhciggcGl4ZWxSYXRpbyApLmZsb29yKCk7XHJcblx0XHRyZW5kZXJDb250ZXh0LnZpZXdwb3J0VmFsdWUud2lkdGggPj49IGFjdGl2ZU1pcG1hcExldmVsO1xyXG5cdFx0cmVuZGVyQ29udGV4dC52aWV3cG9ydFZhbHVlLmhlaWdodCA+Pj0gYWN0aXZlTWlwbWFwTGV2ZWw7XHJcblx0XHRyZW5kZXJDb250ZXh0LnZpZXdwb3J0VmFsdWUubWluRGVwdGggPSBtaW5EZXB0aDtcclxuXHRcdHJlbmRlckNvbnRleHQudmlld3BvcnRWYWx1ZS5tYXhEZXB0aCA9IG1heERlcHRoO1xyXG5cdFx0cmVuZGVyQ29udGV4dC52aWV3cG9ydCA9IHJlbmRlckNvbnRleHQudmlld3BvcnRWYWx1ZS5lcXVhbHMoIF9zY3JlZW4gKSA9PT0gZmFsc2U7XHJcblxyXG5cdFx0cmVuZGVyQ29udGV4dC5zY2lzc29yVmFsdWUuY29weSggc2Npc3NvciApLm11bHRpcGx5U2NhbGFyKCBwaXhlbFJhdGlvICkuZmxvb3IoKTtcclxuXHRcdHJlbmRlckNvbnRleHQuc2Npc3NvciA9IHRoaXMuX3NjaXNzb3JUZXN0ICYmIHJlbmRlckNvbnRleHQuc2Npc3NvclZhbHVlLmVxdWFscyggX3NjcmVlbiApID09PSBmYWxzZTtcclxuXHRcdHJlbmRlckNvbnRleHQuc2Npc3NvclZhbHVlLndpZHRoID4+PSBhY3RpdmVNaXBtYXBMZXZlbDtcclxuXHRcdHJlbmRlckNvbnRleHQuc2Npc3NvclZhbHVlLmhlaWdodCA+Pj0gYWN0aXZlTWlwbWFwTGV2ZWw7XHJcblxyXG5cdFx0aWYgKCAhIHJlbmRlckNvbnRleHQuY2xpcHBpbmdDb250ZXh0ICkgcmVuZGVyQ29udGV4dC5jbGlwcGluZ0NvbnRleHQgPSBuZXcgQ2xpcHBpbmdDb250ZXh0KCk7XHJcblx0XHRyZW5kZXJDb250ZXh0LmNsaXBwaW5nQ29udGV4dC51cGRhdGVHbG9iYWwoIHNjZW5lUmVmLCBjYW1lcmEgKTtcclxuXHJcblx0XHQvL1xyXG5cclxuXHRcdHNjZW5lUmVmLm9uQmVmb3JlUmVuZGVyKCB0aGlzLCBzY2VuZSwgY2FtZXJhLCByZW5kZXJUYXJnZXQgKTtcclxuXHJcblx0XHQvL1xyXG5cclxuXHRcdF9wcm9qU2NyZWVuTWF0cml4Lm11bHRpcGx5TWF0cmljZXMoIGNhbWVyYS5wcm9qZWN0aW9uTWF0cml4LCBjYW1lcmEubWF0cml4V29ybGRJbnZlcnNlICk7XHJcblx0XHRfZnJ1c3R1bS5zZXRGcm9tUHJvamVjdGlvbk1hdHJpeCggX3Byb2pTY3JlZW5NYXRyaXgsIGNvb3JkaW5hdGVTeXN0ZW0gKTtcclxuXHJcblx0XHRjb25zdCByZW5kZXJMaXN0ID0gdGhpcy5fcmVuZGVyTGlzdHMuZ2V0KCBzY2VuZSwgY2FtZXJhICk7XHJcblx0XHRyZW5kZXJMaXN0LmJlZ2luKCk7XHJcblxyXG5cdFx0dGhpcy5fcHJvamVjdE9iamVjdCggc2NlbmUsIGNhbWVyYSwgMCwgcmVuZGVyTGlzdCwgcmVuZGVyQ29udGV4dC5jbGlwcGluZ0NvbnRleHQgKTtcclxuXHJcblx0XHRyZW5kZXJMaXN0LmZpbmlzaCgpO1xyXG5cclxuXHRcdGlmICggdGhpcy5zb3J0T2JqZWN0cyA9PT0gdHJ1ZSApIHtcclxuXHJcblx0XHRcdHJlbmRlckxpc3Quc29ydCggdGhpcy5fb3BhcXVlU29ydCwgdGhpcy5fdHJhbnNwYXJlbnRTb3J0ICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vXHJcblxyXG5cdFx0aWYgKCByZW5kZXJUYXJnZXQgIT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHR0aGlzLl90ZXh0dXJlcy51cGRhdGVSZW5kZXJUYXJnZXQoIHJlbmRlclRhcmdldCwgYWN0aXZlTWlwbWFwTGV2ZWwgKTtcclxuXHJcblx0XHRcdGNvbnN0IHJlbmRlclRhcmdldERhdGEgPSB0aGlzLl90ZXh0dXJlcy5nZXQoIHJlbmRlclRhcmdldCApO1xyXG5cclxuXHRcdFx0cmVuZGVyQ29udGV4dC50ZXh0dXJlcyA9IHJlbmRlclRhcmdldERhdGEudGV4dHVyZXM7XHJcblx0XHRcdHJlbmRlckNvbnRleHQuZGVwdGhUZXh0dXJlID0gcmVuZGVyVGFyZ2V0RGF0YS5kZXB0aFRleHR1cmU7XHJcblx0XHRcdHJlbmRlckNvbnRleHQud2lkdGggPSByZW5kZXJUYXJnZXREYXRhLndpZHRoO1xyXG5cdFx0XHRyZW5kZXJDb250ZXh0LmhlaWdodCA9IHJlbmRlclRhcmdldERhdGEuaGVpZ2h0O1xyXG5cdFx0XHRyZW5kZXJDb250ZXh0LnJlbmRlclRhcmdldCA9IHJlbmRlclRhcmdldDtcclxuXHRcdFx0cmVuZGVyQ29udGV4dC5kZXB0aCA9IHJlbmRlclRhcmdldC5kZXB0aEJ1ZmZlcjtcclxuXHRcdFx0cmVuZGVyQ29udGV4dC5zdGVuY2lsID0gcmVuZGVyVGFyZ2V0LnN0ZW5jaWxCdWZmZXI7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdHJlbmRlckNvbnRleHQudGV4dHVyZXMgPSBudWxsO1xyXG5cdFx0XHRyZW5kZXJDb250ZXh0LmRlcHRoVGV4dHVyZSA9IG51bGw7XHJcblx0XHRcdHJlbmRlckNvbnRleHQud2lkdGggPSB0aGlzLmRvbUVsZW1lbnQud2lkdGg7XHJcblx0XHRcdHJlbmRlckNvbnRleHQuaGVpZ2h0ID0gdGhpcy5kb21FbGVtZW50LmhlaWdodDtcclxuXHRcdFx0cmVuZGVyQ29udGV4dC5kZXB0aCA9IHRoaXMuZGVwdGg7XHJcblx0XHRcdHJlbmRlckNvbnRleHQuc3RlbmNpbCA9IHRoaXMuc3RlbmNpbDtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmVuZGVyQ29udGV4dC53aWR0aCA+Pj0gYWN0aXZlTWlwbWFwTGV2ZWw7XHJcblx0XHRyZW5kZXJDb250ZXh0LmhlaWdodCA+Pj0gYWN0aXZlTWlwbWFwTGV2ZWw7XHJcblx0XHRyZW5kZXJDb250ZXh0LmFjdGl2ZUN1YmVGYWNlID0gYWN0aXZlQ3ViZUZhY2U7XHJcblx0XHRyZW5kZXJDb250ZXh0LmFjdGl2ZU1pcG1hcExldmVsID0gYWN0aXZlTWlwbWFwTGV2ZWw7XHJcblx0XHRyZW5kZXJDb250ZXh0Lm9jY2x1c2lvblF1ZXJ5Q291bnQgPSByZW5kZXJMaXN0Lm9jY2x1c2lvblF1ZXJ5Q291bnQ7XHJcblxyXG5cdFx0Ly9cclxuXHJcblx0XHR0aGlzLl9ub2Rlcy51cGRhdGVTY2VuZSggc2NlbmVSZWYgKTtcclxuXHJcblx0XHQvL1xyXG5cclxuXHRcdHRoaXMuX2JhY2tncm91bmQudXBkYXRlKCBzY2VuZVJlZiwgcmVuZGVyTGlzdCwgcmVuZGVyQ29udGV4dCApO1xyXG5cclxuXHRcdC8vXHJcblxyXG5cdFx0dGhpcy5iYWNrZW5kLmJlZ2luUmVuZGVyKCByZW5kZXJDb250ZXh0ICk7XHJcblxyXG5cdFx0Ly8gcHJvY2VzcyByZW5kZXIgbGlzdHNcclxuXHJcblx0XHRjb25zdCB7XHJcblx0XHRcdGJ1bmRsZXMsXHJcblx0XHRcdGxpZ2h0c05vZGUsXHJcblx0XHRcdHRyYW5zcGFyZW50RG91YmxlUGFzczogdHJhbnNwYXJlbnREb3VibGVQYXNzT2JqZWN0cyxcclxuXHRcdFx0dHJhbnNwYXJlbnQ6IHRyYW5zcGFyZW50T2JqZWN0cyxcclxuXHRcdFx0b3BhcXVlOiBvcGFxdWVPYmplY3RzXHJcblx0XHR9ID0gcmVuZGVyTGlzdDtcclxuXHJcblx0XHRpZiAoIGJ1bmRsZXMubGVuZ3RoID4gMCApIHRoaXMuX3JlbmRlckJ1bmRsZXMoIGJ1bmRsZXMsIHNjZW5lUmVmLCBsaWdodHNOb2RlICk7XHJcblx0XHRpZiAoIHRoaXMub3BhcXVlID09PSB0cnVlICYmIG9wYXF1ZU9iamVjdHMubGVuZ3RoID4gMCApIHRoaXMuX3JlbmRlck9iamVjdHMoIG9wYXF1ZU9iamVjdHMsIGNhbWVyYSwgc2NlbmVSZWYsIGxpZ2h0c05vZGUgKTtcclxuXHRcdGlmICggdGhpcy50cmFuc3BhcmVudCA9PT0gdHJ1ZSAmJiB0cmFuc3BhcmVudE9iamVjdHMubGVuZ3RoID4gMCApIHRoaXMuX3JlbmRlclRyYW5zcGFyZW50cyggdHJhbnNwYXJlbnRPYmplY3RzLCB0cmFuc3BhcmVudERvdWJsZVBhc3NPYmplY3RzLCBjYW1lcmEsIHNjZW5lUmVmLCBsaWdodHNOb2RlICk7XHJcblxyXG5cdFx0Ly8gZmluaXNoIHJlbmRlciBwYXNzXHJcblxyXG5cdFx0dGhpcy5iYWNrZW5kLmZpbmlzaFJlbmRlciggcmVuZGVyQ29udGV4dCApO1xyXG5cclxuXHRcdC8vIHJlc3RvcmUgcmVuZGVyIHRyZWVcclxuXHJcblx0XHRub2RlRnJhbWUucmVuZGVySWQgPSBwcmV2aW91c1JlbmRlcklkO1xyXG5cclxuXHRcdHRoaXMuX2N1cnJlbnRSZW5kZXJDb250ZXh0ID0gcHJldmlvdXNSZW5kZXJDb250ZXh0O1xyXG5cdFx0dGhpcy5fY3VycmVudFJlbmRlck9iamVjdEZ1bmN0aW9uID0gcHJldmlvdXNSZW5kZXJPYmplY3RGdW5jdGlvbjtcclxuXHJcblx0XHQvL1xyXG5cclxuXHRcdGlmICggZnJhbWVCdWZmZXJUYXJnZXQgIT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHR0aGlzLnNldFJlbmRlclRhcmdldCggb3V0cHV0UmVuZGVyVGFyZ2V0LCBhY3RpdmVDdWJlRmFjZSwgYWN0aXZlTWlwbWFwTGV2ZWwgKTtcclxuXHJcblx0XHRcdGNvbnN0IHF1YWQgPSB0aGlzLl9xdWFkO1xyXG5cclxuXHRcdFx0aWYgKCB0aGlzLl9ub2Rlcy5oYXNPdXRwdXRDaGFuZ2UoIHJlbmRlclRhcmdldC50ZXh0dXJlICkgKSB7XHJcblxyXG5cdFx0XHRcdHF1YWQubWF0ZXJpYWwuZnJhZ21lbnROb2RlID0gdGhpcy5fbm9kZXMuZ2V0T3V0cHV0Tm9kZSggcmVuZGVyVGFyZ2V0LnRleHR1cmUgKTtcclxuXHRcdFx0XHRxdWFkLm1hdGVyaWFsLm5lZWRzVXBkYXRlID0gdHJ1ZTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHRoaXMuX3JlbmRlclNjZW5lKCBxdWFkLCBxdWFkLmNhbWVyYSwgZmFsc2UgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly9cclxuXHJcblx0XHRzY2VuZVJlZi5vbkFmdGVyUmVuZGVyKCB0aGlzLCBzY2VuZSwgY2FtZXJhLCByZW5kZXJUYXJnZXQgKTtcclxuXHJcblx0XHQvL1xyXG5cclxuXHRcdHJldHVybiByZW5kZXJDb250ZXh0O1xyXG5cclxuXHR9XHJcblxyXG5cdGdldE1heEFuaXNvdHJvcHkoKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuYmFja2VuZC5nZXRNYXhBbmlzb3Ryb3B5KCk7XHJcblxyXG5cdH1cclxuXHJcblx0Z2V0QWN0aXZlQ3ViZUZhY2UoKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuX2FjdGl2ZUN1YmVGYWNlO1xyXG5cclxuXHR9XHJcblxyXG5cdGdldEFjdGl2ZU1pcG1hcExldmVsKCkge1xyXG5cclxuXHRcdHJldHVybiB0aGlzLl9hY3RpdmVNaXBtYXBMZXZlbDtcclxuXHJcblx0fVxyXG5cclxuXHRhc3luYyBzZXRBbmltYXRpb25Mb29wKCBjYWxsYmFjayApIHtcclxuXHJcblx0XHRpZiAoIHRoaXMuX2luaXRpYWxpemVkID09PSBmYWxzZSApIGF3YWl0IHRoaXMuaW5pdCgpO1xyXG5cclxuXHRcdHRoaXMuX2FuaW1hdGlvbi5zZXRBbmltYXRpb25Mb29wKCBjYWxsYmFjayApO1xyXG5cclxuXHR9XHJcblxyXG5cdGFzeW5jIGdldEFycmF5QnVmZmVyQXN5bmMoIGF0dHJpYnV0ZSApIHtcclxuXHJcblx0XHRyZXR1cm4gYXdhaXQgdGhpcy5iYWNrZW5kLmdldEFycmF5QnVmZmVyQXN5bmMoIGF0dHJpYnV0ZSApO1xyXG5cclxuXHR9XHJcblxyXG5cdGdldENvbnRleHQoKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuYmFja2VuZC5nZXRDb250ZXh0KCk7XHJcblxyXG5cdH1cclxuXHJcblx0Z2V0UGl4ZWxSYXRpbygpIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5fcGl4ZWxSYXRpbztcclxuXHJcblx0fVxyXG5cclxuXHRnZXREcmF3aW5nQnVmZmVyU2l6ZSggdGFyZ2V0ICkge1xyXG5cclxuXHRcdHJldHVybiB0YXJnZXQuc2V0KCB0aGlzLl93aWR0aCAqIHRoaXMuX3BpeGVsUmF0aW8sIHRoaXMuX2hlaWdodCAqIHRoaXMuX3BpeGVsUmF0aW8gKS5mbG9vcigpO1xyXG5cclxuXHR9XHJcblxyXG5cdGdldFNpemUoIHRhcmdldCApIHtcclxuXHJcblx0XHRyZXR1cm4gdGFyZ2V0LnNldCggdGhpcy5fd2lkdGgsIHRoaXMuX2hlaWdodCApO1xyXG5cclxuXHR9XHJcblxyXG5cdHNldFBpeGVsUmF0aW8oIHZhbHVlID0gMSApIHtcclxuXHJcblx0XHRpZiAoIHRoaXMuX3BpeGVsUmF0aW8gPT09IHZhbHVlICkgcmV0dXJuO1xyXG5cclxuXHRcdHRoaXMuX3BpeGVsUmF0aW8gPSB2YWx1ZTtcclxuXHJcblx0XHR0aGlzLnNldFNpemUoIHRoaXMuX3dpZHRoLCB0aGlzLl9oZWlnaHQsIGZhbHNlICk7XHJcblxyXG5cdH1cclxuXHJcblx0c2V0RHJhd2luZ0J1ZmZlclNpemUoIHdpZHRoLCBoZWlnaHQsIHBpeGVsUmF0aW8gKSB7XHJcblxyXG5cdFx0dGhpcy5fd2lkdGggPSB3aWR0aDtcclxuXHRcdHRoaXMuX2hlaWdodCA9IGhlaWdodDtcclxuXHJcblx0XHR0aGlzLl9waXhlbFJhdGlvID0gcGl4ZWxSYXRpbztcclxuXHJcblx0XHR0aGlzLmRvbUVsZW1lbnQud2lkdGggPSBNYXRoLmZsb29yKCB3aWR0aCAqIHBpeGVsUmF0aW8gKTtcclxuXHRcdHRoaXMuZG9tRWxlbWVudC5oZWlnaHQgPSBNYXRoLmZsb29yKCBoZWlnaHQgKiBwaXhlbFJhdGlvICk7XHJcblxyXG5cdFx0dGhpcy5zZXRWaWV3cG9ydCggMCwgMCwgd2lkdGgsIGhlaWdodCApO1xyXG5cclxuXHRcdGlmICggdGhpcy5faW5pdGlhbGl6ZWQgKSB0aGlzLmJhY2tlbmQudXBkYXRlU2l6ZSgpO1xyXG5cclxuXHR9XHJcblxyXG5cdHNldFNpemUoIHdpZHRoLCBoZWlnaHQsIHVwZGF0ZVN0eWxlID0gdHJ1ZSApIHtcclxuXHJcblx0XHR0aGlzLl93aWR0aCA9IHdpZHRoO1xyXG5cdFx0dGhpcy5faGVpZ2h0ID0gaGVpZ2h0O1xyXG5cclxuXHRcdHRoaXMuZG9tRWxlbWVudC53aWR0aCA9IE1hdGguZmxvb3IoIHdpZHRoICogdGhpcy5fcGl4ZWxSYXRpbyApO1xyXG5cdFx0dGhpcy5kb21FbGVtZW50LmhlaWdodCA9IE1hdGguZmxvb3IoIGhlaWdodCAqIHRoaXMuX3BpeGVsUmF0aW8gKTtcclxuXHJcblx0XHRpZiAoIHVwZGF0ZVN0eWxlID09PSB0cnVlICkge1xyXG5cclxuXHRcdFx0dGhpcy5kb21FbGVtZW50LnN0eWxlLndpZHRoID0gd2lkdGggKyAncHgnO1xyXG5cdFx0XHR0aGlzLmRvbUVsZW1lbnQuc3R5bGUuaGVpZ2h0ID0gaGVpZ2h0ICsgJ3B4JztcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5zZXRWaWV3cG9ydCggMCwgMCwgd2lkdGgsIGhlaWdodCApO1xyXG5cclxuXHRcdGlmICggdGhpcy5faW5pdGlhbGl6ZWQgKSB0aGlzLmJhY2tlbmQudXBkYXRlU2l6ZSgpO1xyXG5cclxuXHR9XHJcblxyXG5cdHNldE9wYXF1ZVNvcnQoIG1ldGhvZCApIHtcclxuXHJcblx0XHR0aGlzLl9vcGFxdWVTb3J0ID0gbWV0aG9kO1xyXG5cclxuXHR9XHJcblxyXG5cdHNldFRyYW5zcGFyZW50U29ydCggbWV0aG9kICkge1xyXG5cclxuXHRcdHRoaXMuX3RyYW5zcGFyZW50U29ydCA9IG1ldGhvZDtcclxuXHJcblx0fVxyXG5cclxuXHRnZXRTY2lzc29yKCB0YXJnZXQgKSB7XHJcblxyXG5cdFx0Y29uc3Qgc2Npc3NvciA9IHRoaXMuX3NjaXNzb3I7XHJcblxyXG5cdFx0dGFyZ2V0LnggPSBzY2lzc29yLng7XHJcblx0XHR0YXJnZXQueSA9IHNjaXNzb3IueTtcclxuXHRcdHRhcmdldC53aWR0aCA9IHNjaXNzb3Iud2lkdGg7XHJcblx0XHR0YXJnZXQuaGVpZ2h0ID0gc2Npc3Nvci5oZWlnaHQ7XHJcblxyXG5cdFx0cmV0dXJuIHRhcmdldDtcclxuXHJcblx0fVxyXG5cclxuXHRzZXRTY2lzc29yKCB4LCB5LCB3aWR0aCwgaGVpZ2h0ICkge1xyXG5cclxuXHRcdGNvbnN0IHNjaXNzb3IgPSB0aGlzLl9zY2lzc29yO1xyXG5cclxuXHRcdGlmICggeC5pc1ZlY3RvcjQgKSB7XHJcblxyXG5cdFx0XHRzY2lzc29yLmNvcHkoIHggKTtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0c2Npc3Nvci5zZXQoIHgsIHksIHdpZHRoLCBoZWlnaHQgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0Z2V0U2Npc3NvclRlc3QoKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuX3NjaXNzb3JUZXN0O1xyXG5cclxuXHR9XHJcblxyXG5cdHNldFNjaXNzb3JUZXN0KCBib29sZWFuICkge1xyXG5cclxuXHRcdHRoaXMuX3NjaXNzb3JUZXN0ID0gYm9vbGVhbjtcclxuXHJcblx0XHR0aGlzLmJhY2tlbmQuc2V0U2Npc3NvclRlc3QoIGJvb2xlYW4gKTtcclxuXHJcblx0fVxyXG5cclxuXHRnZXRWaWV3cG9ydCggdGFyZ2V0ICkge1xyXG5cclxuXHRcdHJldHVybiB0YXJnZXQuY29weSggdGhpcy5fdmlld3BvcnQgKTtcclxuXHJcblx0fVxyXG5cclxuXHRzZXRWaWV3cG9ydCggeCwgeSwgd2lkdGgsIGhlaWdodCwgbWluRGVwdGggPSAwLCBtYXhEZXB0aCA9IDEgKSB7XHJcblxyXG5cdFx0Y29uc3Qgdmlld3BvcnQgPSB0aGlzLl92aWV3cG9ydDtcclxuXHJcblx0XHRpZiAoIHguaXNWZWN0b3I0ICkge1xyXG5cclxuXHRcdFx0dmlld3BvcnQuY29weSggeCApO1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHR2aWV3cG9ydC5zZXQoIHgsIHksIHdpZHRoLCBoZWlnaHQgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dmlld3BvcnQubWluRGVwdGggPSBtaW5EZXB0aDtcclxuXHRcdHZpZXdwb3J0Lm1heERlcHRoID0gbWF4RGVwdGg7XHJcblxyXG5cdH1cclxuXHJcblx0Z2V0Q2xlYXJDb2xvciggdGFyZ2V0ICkge1xyXG5cclxuXHRcdHJldHVybiB0YXJnZXQuY29weSggdGhpcy5fY2xlYXJDb2xvciApO1xyXG5cclxuXHR9XHJcblxyXG5cdHNldENsZWFyQ29sb3IoIGNvbG9yLCBhbHBoYSA9IDEgKSB7XHJcblxyXG5cdFx0dGhpcy5fY2xlYXJDb2xvci5zZXQoIGNvbG9yICk7XHJcblx0XHR0aGlzLl9jbGVhckNvbG9yLmEgPSBhbHBoYTtcclxuXHJcblx0fVxyXG5cclxuXHRnZXRDbGVhckFscGhhKCkge1xyXG5cclxuXHRcdHJldHVybiB0aGlzLl9jbGVhckNvbG9yLmE7XHJcblxyXG5cdH1cclxuXHJcblx0c2V0Q2xlYXJBbHBoYSggYWxwaGEgKSB7XHJcblxyXG5cdFx0dGhpcy5fY2xlYXJDb2xvci5hID0gYWxwaGE7XHJcblxyXG5cdH1cclxuXHJcblx0Z2V0Q2xlYXJEZXB0aCgpIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5fY2xlYXJEZXB0aDtcclxuXHJcblx0fVxyXG5cclxuXHRzZXRDbGVhckRlcHRoKCBkZXB0aCApIHtcclxuXHJcblx0XHR0aGlzLl9jbGVhckRlcHRoID0gZGVwdGg7XHJcblxyXG5cdH1cclxuXHJcblx0Z2V0Q2xlYXJTdGVuY2lsKCkge1xyXG5cclxuXHRcdHJldHVybiB0aGlzLl9jbGVhclN0ZW5jaWw7XHJcblxyXG5cdH1cclxuXHJcblx0c2V0Q2xlYXJTdGVuY2lsKCBzdGVuY2lsICkge1xyXG5cclxuXHRcdHRoaXMuX2NsZWFyU3RlbmNpbCA9IHN0ZW5jaWw7XHJcblxyXG5cdH1cclxuXHJcblx0aXNPY2NsdWRlZCggb2JqZWN0ICkge1xyXG5cclxuXHRcdGNvbnN0IHJlbmRlckNvbnRleHQgPSB0aGlzLl9jdXJyZW50UmVuZGVyQ29udGV4dDtcclxuXHJcblx0XHRyZXR1cm4gcmVuZGVyQ29udGV4dCAmJiB0aGlzLmJhY2tlbmQuaXNPY2NsdWRlZCggcmVuZGVyQ29udGV4dCwgb2JqZWN0ICk7XHJcblxyXG5cdH1cclxuXHJcblx0Y2xlYXIoIGNvbG9yID0gdHJ1ZSwgZGVwdGggPSB0cnVlLCBzdGVuY2lsID0gdHJ1ZSApIHtcclxuXHJcblx0XHRpZiAoIHRoaXMuX2luaXRpYWxpemVkID09PSBmYWxzZSApIHtcclxuXHJcblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLlJlbmRlcmVyOiAuY2xlYXIoKSBjYWxsZWQgYmVmb3JlIHRoZSBiYWNrZW5kIGlzIGluaXRpYWxpemVkLiBUcnkgdXNpbmcgLmNsZWFyQXN5bmMoKSBpbnN0ZWFkLicgKTtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzLmNsZWFyQXN5bmMoIGNvbG9yLCBkZXB0aCwgc3RlbmNpbCApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRjb25zdCByZW5kZXJUYXJnZXQgPSB0aGlzLl9yZW5kZXJUYXJnZXQgfHwgdGhpcy5fZ2V0RnJhbWVCdWZmZXJUYXJnZXQoKTtcclxuXHJcblx0XHRsZXQgcmVuZGVyVGFyZ2V0RGF0YSA9IG51bGw7XHJcblxyXG5cdFx0aWYgKCByZW5kZXJUYXJnZXQgIT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHR0aGlzLl90ZXh0dXJlcy51cGRhdGVSZW5kZXJUYXJnZXQoIHJlbmRlclRhcmdldCApO1xyXG5cclxuXHRcdFx0cmVuZGVyVGFyZ2V0RGF0YSA9IHRoaXMuX3RleHR1cmVzLmdldCggcmVuZGVyVGFyZ2V0ICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuYmFja2VuZC5jbGVhciggY29sb3IsIGRlcHRoLCBzdGVuY2lsLCByZW5kZXJUYXJnZXREYXRhICk7XHJcblxyXG5cdFx0aWYgKCByZW5kZXJUYXJnZXQgIT09IG51bGwgJiYgdGhpcy5fcmVuZGVyVGFyZ2V0ID09PSBudWxsICkge1xyXG5cclxuXHRcdFx0Ly8gSWYgYSBjb2xvciBzcGFjZSB0cmFuc2Zvcm0gb3IgdG9uZSBtYXBwaW5nIGlzIHJlcXVpcmVkLFxyXG5cdFx0XHQvLyB0aGUgY2xlYXIgb3BlcmF0aW9uIGNsZWFycyB0aGUgaW50ZXJtZWRpYXRlIHJlbmRlclRhcmdldCB0ZXh0dXJlLCBidXQgZG9lcyBub3QgdXBkYXRlIHRoZSBzY3JlZW4gY2FudmFzLlxyXG5cclxuXHRcdFx0Y29uc3QgcXVhZCA9IHRoaXMuX3F1YWQ7XHJcblxyXG5cdFx0XHRpZiAoIHRoaXMuX25vZGVzLmhhc091dHB1dENoYW5nZSggcmVuZGVyVGFyZ2V0LnRleHR1cmUgKSApIHtcclxuXHJcblx0XHRcdFx0cXVhZC5tYXRlcmlhbC5mcmFnbWVudE5vZGUgPSB0aGlzLl9ub2Rlcy5nZXRPdXRwdXROb2RlKCByZW5kZXJUYXJnZXQudGV4dHVyZSApO1xyXG5cdFx0XHRcdHF1YWQubWF0ZXJpYWwubmVlZHNVcGRhdGUgPSB0cnVlO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dGhpcy5fcmVuZGVyU2NlbmUoIHF1YWQsIHF1YWQuY2FtZXJhLCBmYWxzZSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHRjbGVhckNvbG9yKCkge1xyXG5cclxuXHRcdHJldHVybiB0aGlzLmNsZWFyKCB0cnVlLCBmYWxzZSwgZmFsc2UgKTtcclxuXHJcblx0fVxyXG5cclxuXHRjbGVhckRlcHRoKCkge1xyXG5cclxuXHRcdHJldHVybiB0aGlzLmNsZWFyKCBmYWxzZSwgdHJ1ZSwgZmFsc2UgKTtcclxuXHJcblx0fVxyXG5cclxuXHRjbGVhclN0ZW5jaWwoKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuY2xlYXIoIGZhbHNlLCBmYWxzZSwgdHJ1ZSApO1xyXG5cclxuXHR9XHJcblxyXG5cdGFzeW5jIGNsZWFyQXN5bmMoIGNvbG9yID0gdHJ1ZSwgZGVwdGggPSB0cnVlLCBzdGVuY2lsID0gdHJ1ZSApIHtcclxuXHJcblx0XHRpZiAoIHRoaXMuX2luaXRpYWxpemVkID09PSBmYWxzZSApIGF3YWl0IHRoaXMuaW5pdCgpO1xyXG5cclxuXHRcdHRoaXMuY2xlYXIoIGNvbG9yLCBkZXB0aCwgc3RlbmNpbCApO1xyXG5cclxuXHR9XHJcblxyXG5cdGNsZWFyQ29sb3JBc3luYygpIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5jbGVhckFzeW5jKCB0cnVlLCBmYWxzZSwgZmFsc2UgKTtcclxuXHJcblx0fVxyXG5cclxuXHRjbGVhckRlcHRoQXN5bmMoKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuY2xlYXJBc3luYyggZmFsc2UsIHRydWUsIGZhbHNlICk7XHJcblxyXG5cdH1cclxuXHJcblx0Y2xlYXJTdGVuY2lsQXN5bmMoKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuY2xlYXJBc3luYyggZmFsc2UsIGZhbHNlLCB0cnVlICk7XHJcblxyXG5cdH1cclxuXHJcblx0Z2V0IGN1cnJlbnRUb25lTWFwcGluZygpIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5fcmVuZGVyVGFyZ2V0ICE9PSBudWxsID8gTm9Ub25lTWFwcGluZyA6IHRoaXMudG9uZU1hcHBpbmc7XHJcblxyXG5cdH1cclxuXHJcblx0Z2V0IGN1cnJlbnRDb2xvclNwYWNlKCkge1xyXG5cclxuXHRcdHJldHVybiB0aGlzLl9yZW5kZXJUYXJnZXQgIT09IG51bGwgPyBMaW5lYXJTUkdCQ29sb3JTcGFjZSA6IHRoaXMub3V0cHV0Q29sb3JTcGFjZTtcclxuXHJcblx0fVxyXG5cclxuXHRkaXNwb3NlKCkge1xyXG5cclxuXHRcdHRoaXMuaW5mby5kaXNwb3NlKCk7XHJcblx0XHR0aGlzLmJhY2tlbmQuZGlzcG9zZSgpO1xyXG5cclxuXHRcdHRoaXMuX2FuaW1hdGlvbi5kaXNwb3NlKCk7XHJcblx0XHR0aGlzLl9vYmplY3RzLmRpc3Bvc2UoKTtcclxuXHRcdHRoaXMuX3BpcGVsaW5lcy5kaXNwb3NlKCk7XHJcblx0XHR0aGlzLl9ub2Rlcy5kaXNwb3NlKCk7XHJcblx0XHR0aGlzLl9iaW5kaW5ncy5kaXNwb3NlKCk7XHJcblx0XHR0aGlzLl9yZW5kZXJMaXN0cy5kaXNwb3NlKCk7XHJcblx0XHR0aGlzLl9yZW5kZXJDb250ZXh0cy5kaXNwb3NlKCk7XHJcblx0XHR0aGlzLl90ZXh0dXJlcy5kaXNwb3NlKCk7XHJcblxyXG5cdFx0dGhpcy5zZXRSZW5kZXJUYXJnZXQoIG51bGwgKTtcclxuXHRcdHRoaXMuc2V0QW5pbWF0aW9uTG9vcCggbnVsbCApO1xyXG5cclxuXHR9XHJcblxyXG5cdHNldFJlbmRlclRhcmdldCggcmVuZGVyVGFyZ2V0LCBhY3RpdmVDdWJlRmFjZSA9IDAsIGFjdGl2ZU1pcG1hcExldmVsID0gMCApIHtcclxuXHJcblx0XHR0aGlzLl9yZW5kZXJUYXJnZXQgPSByZW5kZXJUYXJnZXQ7XHJcblx0XHR0aGlzLl9hY3RpdmVDdWJlRmFjZSA9IGFjdGl2ZUN1YmVGYWNlO1xyXG5cdFx0dGhpcy5fYWN0aXZlTWlwbWFwTGV2ZWwgPSBhY3RpdmVNaXBtYXBMZXZlbDtcclxuXHJcblx0fVxyXG5cclxuXHRnZXRSZW5kZXJUYXJnZXQoKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuX3JlbmRlclRhcmdldDtcclxuXHJcblx0fVxyXG5cclxuXHRzZXRSZW5kZXJPYmplY3RGdW5jdGlvbiggcmVuZGVyT2JqZWN0RnVuY3Rpb24gKSB7XHJcblxyXG5cdFx0dGhpcy5fcmVuZGVyT2JqZWN0RnVuY3Rpb24gPSByZW5kZXJPYmplY3RGdW5jdGlvbjtcclxuXHJcblx0fVxyXG5cclxuXHRnZXRSZW5kZXJPYmplY3RGdW5jdGlvbigpIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5fcmVuZGVyT2JqZWN0RnVuY3Rpb247XHJcblxyXG5cdH1cclxuXHJcblx0Y29tcHV0ZSggY29tcHV0ZU5vZGVzICkge1xyXG5cclxuXHRcdGlmICggdGhpcy5pc0RldmljZUxvc3QgPT09IHRydWUgKSByZXR1cm47XHJcblxyXG5cdFx0aWYgKCB0aGlzLl9pbml0aWFsaXplZCA9PT0gZmFsc2UgKSB7XHJcblxyXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5SZW5kZXJlcjogLmNvbXB1dGUoKSBjYWxsZWQgYmVmb3JlIHRoZSBiYWNrZW5kIGlzIGluaXRpYWxpemVkLiBUcnkgdXNpbmcgLmNvbXB1dGVBc3luYygpIGluc3RlYWQuJyApO1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXMuY29tcHV0ZUFzeW5jKCBjb21wdXRlTm9kZXMgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly9cclxuXHJcblx0XHRjb25zdCBub2RlRnJhbWUgPSB0aGlzLl9ub2Rlcy5ub2RlRnJhbWU7XHJcblxyXG5cdFx0Y29uc3QgcHJldmlvdXNSZW5kZXJJZCA9IG5vZGVGcmFtZS5yZW5kZXJJZDtcclxuXHJcblx0XHQvL1xyXG5cclxuXHRcdHRoaXMuaW5mby5jYWxscyArKztcclxuXHRcdHRoaXMuaW5mby5jb21wdXRlLmNhbGxzICsrO1xyXG5cdFx0dGhpcy5pbmZvLmNvbXB1dGUuZnJhbWVDYWxscyArKztcclxuXHJcblx0XHRub2RlRnJhbWUucmVuZGVySWQgPSB0aGlzLmluZm8uY2FsbHM7XHJcblxyXG5cdFx0Ly9cclxuXHJcblx0XHRjb25zdCBiYWNrZW5kID0gdGhpcy5iYWNrZW5kO1xyXG5cdFx0Y29uc3QgcGlwZWxpbmVzID0gdGhpcy5fcGlwZWxpbmVzO1xyXG5cdFx0Y29uc3QgYmluZGluZ3MgPSB0aGlzLl9iaW5kaW5ncztcclxuXHRcdGNvbnN0IG5vZGVzID0gdGhpcy5fbm9kZXM7XHJcblxyXG5cdFx0Y29uc3QgY29tcHV0ZUxpc3QgPSBBcnJheS5pc0FycmF5KCBjb21wdXRlTm9kZXMgKSA/IGNvbXB1dGVOb2RlcyA6IFsgY29tcHV0ZU5vZGVzIF07XHJcblxyXG5cdFx0aWYgKCBjb21wdXRlTGlzdFsgMCBdID09PSB1bmRlZmluZWQgfHwgY29tcHV0ZUxpc3RbIDAgXS5pc0NvbXB1dGVOb2RlICE9PSB0cnVlICkge1xyXG5cclxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCAnVEhSRUUuUmVuZGVyZXI6IC5jb21wdXRlKCkgZXhwZWN0cyBhIENvbXB1dGVOb2RlLicgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0YmFja2VuZC5iZWdpbkNvbXB1dGUoIGNvbXB1dGVOb2RlcyApO1xyXG5cclxuXHRcdGZvciAoIGNvbnN0IGNvbXB1dGVOb2RlIG9mIGNvbXB1dGVMaXN0ICkge1xyXG5cclxuXHRcdFx0Ly8gb25Jbml0XHJcblxyXG5cdFx0XHRpZiAoIHBpcGVsaW5lcy5oYXMoIGNvbXB1dGVOb2RlICkgPT09IGZhbHNlICkge1xyXG5cclxuXHRcdFx0XHRjb25zdCBkaXNwb3NlID0gKCkgPT4ge1xyXG5cclxuXHRcdFx0XHRcdGNvbXB1dGVOb2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoICdkaXNwb3NlJywgZGlzcG9zZSApO1xyXG5cclxuXHRcdFx0XHRcdHBpcGVsaW5lcy5kZWxldGUoIGNvbXB1dGVOb2RlICk7XHJcblx0XHRcdFx0XHRiaW5kaW5ncy5kZWxldGUoIGNvbXB1dGVOb2RlICk7XHJcblx0XHRcdFx0XHRub2Rlcy5kZWxldGUoIGNvbXB1dGVOb2RlICk7XHJcblxyXG5cdFx0XHRcdH07XHJcblxyXG5cdFx0XHRcdGNvbXB1dGVOb2RlLmFkZEV2ZW50TGlzdGVuZXIoICdkaXNwb3NlJywgZGlzcG9zZSApO1xyXG5cclxuXHRcdFx0XHQvL1xyXG5cclxuXHRcdFx0XHRjb25zdCBvbkluaXRGbiA9IGNvbXB1dGVOb2RlLm9uSW5pdEZ1bmN0aW9uO1xyXG5cclxuXHRcdFx0XHRpZiAoIG9uSW5pdEZuICE9PSBudWxsICkge1xyXG5cclxuXHRcdFx0XHRcdG9uSW5pdEZuLmNhbGwoIGNvbXB1dGVOb2RlLCB7IHJlbmRlcmVyOiB0aGlzIH0gKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0bm9kZXMudXBkYXRlRm9yQ29tcHV0ZSggY29tcHV0ZU5vZGUgKTtcclxuXHRcdFx0YmluZGluZ3MudXBkYXRlRm9yQ29tcHV0ZSggY29tcHV0ZU5vZGUgKTtcclxuXHJcblx0XHRcdGNvbnN0IGNvbXB1dGVCaW5kaW5ncyA9IGJpbmRpbmdzLmdldEZvckNvbXB1dGUoIGNvbXB1dGVOb2RlICk7XHJcblx0XHRcdGNvbnN0IGNvbXB1dGVQaXBlbGluZSA9IHBpcGVsaW5lcy5nZXRGb3JDb21wdXRlKCBjb21wdXRlTm9kZSwgY29tcHV0ZUJpbmRpbmdzICk7XHJcblxyXG5cdFx0XHRiYWNrZW5kLmNvbXB1dGUoIGNvbXB1dGVOb2RlcywgY29tcHV0ZU5vZGUsIGNvbXB1dGVCaW5kaW5ncywgY29tcHV0ZVBpcGVsaW5lICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGJhY2tlbmQuZmluaXNoQ29tcHV0ZSggY29tcHV0ZU5vZGVzICk7XHJcblxyXG5cdFx0Ly9cclxuXHJcblx0XHRub2RlRnJhbWUucmVuZGVySWQgPSBwcmV2aW91c1JlbmRlcklkO1xyXG5cclxuXHR9XHJcblxyXG5cdGFzeW5jIGNvbXB1dGVBc3luYyggY29tcHV0ZU5vZGVzICkge1xyXG5cclxuXHRcdGlmICggdGhpcy5faW5pdGlhbGl6ZWQgPT09IGZhbHNlICkgYXdhaXQgdGhpcy5pbml0KCk7XHJcblxyXG5cdFx0dGhpcy5jb21wdXRlKCBjb21wdXRlTm9kZXMgKTtcclxuXHJcblx0XHRhd2FpdCB0aGlzLmJhY2tlbmQucmVzb2x2ZVRpbWVzdGFtcEFzeW5jKCBjb21wdXRlTm9kZXMsICdjb21wdXRlJyApO1xyXG5cclxuXHR9XHJcblxyXG5cdGFzeW5jIGhhc0ZlYXR1cmVBc3luYyggbmFtZSApIHtcclxuXHJcblx0XHRpZiAoIHRoaXMuX2luaXRpYWxpemVkID09PSBmYWxzZSApIGF3YWl0IHRoaXMuaW5pdCgpO1xyXG5cclxuXHRcdHJldHVybiB0aGlzLmJhY2tlbmQuaGFzRmVhdHVyZSggbmFtZSApO1xyXG5cclxuXHR9XHJcblxyXG5cdGhhc0ZlYXR1cmUoIG5hbWUgKSB7XHJcblxyXG5cdFx0aWYgKCB0aGlzLl9pbml0aWFsaXplZCA9PT0gZmFsc2UgKSB7XHJcblxyXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5SZW5kZXJlcjogLmhhc0ZlYXR1cmUoKSBjYWxsZWQgYmVmb3JlIHRoZSBiYWNrZW5kIGlzIGluaXRpYWxpemVkLiBUcnkgdXNpbmcgLmhhc0ZlYXR1cmVBc3luYygpIGluc3RlYWQuJyApO1xyXG5cclxuXHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcy5iYWNrZW5kLmhhc0ZlYXR1cmUoIG5hbWUgKTtcclxuXHJcblx0fVxyXG5cclxuXHRoYXNJbml0aWFsaXplZCgpIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5faW5pdGlhbGl6ZWQ7XHJcblxyXG5cdH1cclxuXHJcblx0YXN5bmMgaW5pdFRleHR1cmVBc3luYyggdGV4dHVyZSApIHtcclxuXHJcblx0XHRpZiAoIHRoaXMuX2luaXRpYWxpemVkID09PSBmYWxzZSApIGF3YWl0IHRoaXMuaW5pdCgpO1xyXG5cclxuXHRcdHRoaXMuX3RleHR1cmVzLnVwZGF0ZVRleHR1cmUoIHRleHR1cmUgKTtcclxuXHJcblx0fVxyXG5cclxuXHRpbml0VGV4dHVyZSggdGV4dHVyZSApIHtcclxuXHJcblx0XHRpZiAoIHRoaXMuX2luaXRpYWxpemVkID09PSBmYWxzZSApIHtcclxuXHJcblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLlJlbmRlcmVyOiAuaW5pdFRleHR1cmUoKSBjYWxsZWQgYmVmb3JlIHRoZSBiYWNrZW5kIGlzIGluaXRpYWxpemVkLiBUcnkgdXNpbmcgLmluaXRUZXh0dXJlQXN5bmMoKSBpbnN0ZWFkLicgKTtcclxuXHJcblx0XHRcdHJldHVybiBmYWxzZTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fdGV4dHVyZXMudXBkYXRlVGV4dHVyZSggdGV4dHVyZSApO1xyXG5cclxuXHR9XHJcblxyXG5cdGNvcHlGcmFtZWJ1ZmZlclRvVGV4dHVyZSggZnJhbWVidWZmZXJUZXh0dXJlLCByZWN0YW5nbGUgPSBudWxsICkge1xyXG5cclxuXHRcdGlmICggcmVjdGFuZ2xlICE9PSBudWxsICkge1xyXG5cclxuXHRcdFx0aWYgKCByZWN0YW5nbGUuaXNWZWN0b3IyICkge1xyXG5cclxuXHRcdFx0XHRyZWN0YW5nbGUgPSBfdmVjdG9yNC5zZXQoIHJlY3RhbmdsZS54LCByZWN0YW5nbGUueSwgZnJhbWVidWZmZXJUZXh0dXJlLmltYWdlLndpZHRoLCBmcmFtZWJ1ZmZlclRleHR1cmUuaW1hZ2UuaGVpZ2h0ICkuZmxvb3IoKTtcclxuXHJcblx0XHRcdH0gZWxzZSBpZiAoIHJlY3RhbmdsZS5pc1ZlY3RvcjQgKSB7XHJcblxyXG5cdFx0XHRcdHJlY3RhbmdsZSA9IF92ZWN0b3I0LmNvcHkoIHJlY3RhbmdsZSApLmZsb29yKCk7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuUmVuZGVyZXIuY29weUZyYW1lYnVmZmVyVG9UZXh0dXJlOiBJbnZhbGlkIHJlY3RhbmdsZS4nICk7XHJcblxyXG5cdFx0XHRcdHJldHVybjtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0cmVjdGFuZ2xlID0gX3ZlY3RvcjQuc2V0KCAwLCAwLCBmcmFtZWJ1ZmZlclRleHR1cmUuaW1hZ2Uud2lkdGgsIGZyYW1lYnVmZmVyVGV4dHVyZS5pbWFnZS5oZWlnaHQgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly9cclxuXHJcblx0XHRsZXQgcmVuZGVyQ29udGV4dCA9IHRoaXMuX2N1cnJlbnRSZW5kZXJDb250ZXh0O1xyXG5cdFx0bGV0IHJlbmRlclRhcmdldDtcclxuXHJcblx0XHRpZiAoIHJlbmRlckNvbnRleHQgIT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHRyZW5kZXJUYXJnZXQgPSByZW5kZXJDb250ZXh0LnJlbmRlclRhcmdldDtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0cmVuZGVyVGFyZ2V0ID0gdGhpcy5fcmVuZGVyVGFyZ2V0IHx8IHRoaXMuX2dldEZyYW1lQnVmZmVyVGFyZ2V0KCk7XHJcblxyXG5cdFx0XHRpZiAoIHJlbmRlclRhcmdldCAhPT0gbnVsbCApIHtcclxuXHJcblx0XHRcdFx0dGhpcy5fdGV4dHVyZXMudXBkYXRlUmVuZGVyVGFyZ2V0KCByZW5kZXJUYXJnZXQgKTtcclxuXHJcblx0XHRcdFx0cmVuZGVyQ29udGV4dCA9IHRoaXMuX3RleHR1cmVzLmdldCggcmVuZGVyVGFyZ2V0ICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vXHJcblxyXG5cdFx0dGhpcy5fdGV4dHVyZXMudXBkYXRlVGV4dHVyZSggZnJhbWVidWZmZXJUZXh0dXJlLCB7IHJlbmRlclRhcmdldCB9ICk7XHJcblxyXG5cdFx0dGhpcy5iYWNrZW5kLmNvcHlGcmFtZWJ1ZmZlclRvVGV4dHVyZSggZnJhbWVidWZmZXJUZXh0dXJlLCByZW5kZXJDb250ZXh0LCByZWN0YW5nbGUgKTtcclxuXHJcblx0fVxyXG5cclxuXHRjb3B5VGV4dHVyZVRvVGV4dHVyZSggc3JjVGV4dHVyZSwgZHN0VGV4dHVyZSwgc3JjUmVnaW9uID0gbnVsbCwgZHN0UG9zaXRpb24gPSBudWxsLCBsZXZlbCA9IDAgKSB7XHJcblxyXG5cdFx0dGhpcy5fdGV4dHVyZXMudXBkYXRlVGV4dHVyZSggc3JjVGV4dHVyZSApO1xyXG5cdFx0dGhpcy5fdGV4dHVyZXMudXBkYXRlVGV4dHVyZSggZHN0VGV4dHVyZSApO1xyXG5cclxuXHRcdHRoaXMuYmFja2VuZC5jb3B5VGV4dHVyZVRvVGV4dHVyZSggc3JjVGV4dHVyZSwgZHN0VGV4dHVyZSwgc3JjUmVnaW9uLCBkc3RQb3NpdGlvbiwgbGV2ZWwgKTtcclxuXHJcblx0fVxyXG5cclxuXHRyZWFkUmVuZGVyVGFyZ2V0UGl4ZWxzQXN5bmMoIHJlbmRlclRhcmdldCwgeCwgeSwgd2lkdGgsIGhlaWdodCwgaW5kZXggPSAwLCBmYWNlSW5kZXggPSAwICkge1xyXG5cclxuXHRcdHJldHVybiB0aGlzLmJhY2tlbmQuY29weVRleHR1cmVUb0J1ZmZlciggcmVuZGVyVGFyZ2V0LnRleHR1cmVzWyBpbmRleCBdLCB4LCB5LCB3aWR0aCwgaGVpZ2h0LCBmYWNlSW5kZXggKTtcclxuXHJcblx0fVxyXG5cclxuXHRfcHJvamVjdE9iamVjdCggb2JqZWN0LCBjYW1lcmEsIGdyb3VwT3JkZXIsIHJlbmRlckxpc3QsIGNsaXBwaW5nQ29udGV4dCApIHtcclxuXHJcblx0XHRpZiAoIG9iamVjdC52aXNpYmxlID09PSBmYWxzZSApIHJldHVybjtcclxuXHJcblx0XHRjb25zdCB2aXNpYmxlID0gb2JqZWN0LmxheWVycy50ZXN0KCBjYW1lcmEubGF5ZXJzICk7XHJcblxyXG5cdFx0aWYgKCB2aXNpYmxlICkge1xyXG5cclxuXHRcdFx0aWYgKCBvYmplY3QuaXNHcm91cCApIHtcclxuXHJcblx0XHRcdFx0Z3JvdXBPcmRlciA9IG9iamVjdC5yZW5kZXJPcmRlcjtcclxuXHJcblx0XHRcdFx0aWYgKCBvYmplY3QuaXNDbGlwcGluZ0dyb3VwICYmIG9iamVjdC5lbmFibGVkICkgY2xpcHBpbmdDb250ZXh0ID0gY2xpcHBpbmdDb250ZXh0LmdldEdyb3VwQ29udGV4dCggb2JqZWN0ICk7XHJcblxyXG5cdFx0XHR9IGVsc2UgaWYgKCBvYmplY3QuaXNMT0QgKSB7XHJcblxyXG5cdFx0XHRcdGlmICggb2JqZWN0LmF1dG9VcGRhdGUgPT09IHRydWUgKSBvYmplY3QudXBkYXRlKCBjYW1lcmEgKTtcclxuXHJcblx0XHRcdH0gZWxzZSBpZiAoIG9iamVjdC5pc0xpZ2h0ICkge1xyXG5cclxuXHRcdFx0XHRyZW5kZXJMaXN0LnB1c2hMaWdodCggb2JqZWN0ICk7XHJcblxyXG5cdFx0XHR9IGVsc2UgaWYgKCBvYmplY3QuaXNTcHJpdGUgKSB7XHJcblxyXG5cdFx0XHRcdGlmICggISBvYmplY3QuZnJ1c3R1bUN1bGxlZCB8fCBfZnJ1c3R1bS5pbnRlcnNlY3RzU3ByaXRlKCBvYmplY3QgKSApIHtcclxuXHJcblx0XHRcdFx0XHRpZiAoIHRoaXMuc29ydE9iamVjdHMgPT09IHRydWUgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRfdmVjdG9yNC5zZXRGcm9tTWF0cml4UG9zaXRpb24oIG9iamVjdC5tYXRyaXhXb3JsZCApLmFwcGx5TWF0cml4NCggX3Byb2pTY3JlZW5NYXRyaXggKTtcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0Y29uc3QgeyBnZW9tZXRyeSwgbWF0ZXJpYWwgfSA9IG9iamVjdDtcclxuXHJcblx0XHRcdFx0XHRpZiAoIG1hdGVyaWFsLnZpc2libGUgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRyZW5kZXJMaXN0LnB1c2goIG9iamVjdCwgZ2VvbWV0cnksIG1hdGVyaWFsLCBncm91cE9yZGVyLCBfdmVjdG9yNC56LCBudWxsLCBjbGlwcGluZ0NvbnRleHQgKTtcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH0gZWxzZSBpZiAoIG9iamVjdC5pc0xpbmVMb29wICkge1xyXG5cclxuXHRcdFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuUmVuZGVyZXI6IE9iamVjdHMgb2YgdHlwZSBUSFJFRS5MaW5lTG9vcCBhcmUgbm90IHN1cHBvcnRlZC4gUGxlYXNlIHVzZSBUSFJFRS5MaW5lIG9yIFRIUkVFLkxpbmVTZWdtZW50cy4nICk7XHJcblxyXG5cdFx0XHR9IGVsc2UgaWYgKCBvYmplY3QuaXNNZXNoIHx8IG9iamVjdC5pc0xpbmUgfHwgb2JqZWN0LmlzUG9pbnRzICkge1xyXG5cclxuXHRcdFx0XHRpZiAoICEgb2JqZWN0LmZydXN0dW1DdWxsZWQgfHwgX2ZydXN0dW0uaW50ZXJzZWN0c09iamVjdCggb2JqZWN0ICkgKSB7XHJcblxyXG5cdFx0XHRcdFx0Y29uc3QgeyBnZW9tZXRyeSwgbWF0ZXJpYWwgfSA9IG9iamVjdDtcclxuXHJcblx0XHRcdFx0XHRpZiAoIHRoaXMuc29ydE9iamVjdHMgPT09IHRydWUgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRpZiAoIGdlb21ldHJ5LmJvdW5kaW5nU3BoZXJlID09PSBudWxsICkgZ2VvbWV0cnkuY29tcHV0ZUJvdW5kaW5nU3BoZXJlKCk7XHJcblxyXG5cdFx0XHRcdFx0XHRfdmVjdG9yNFxyXG5cdFx0XHRcdFx0XHRcdC5jb3B5KCBnZW9tZXRyeS5ib3VuZGluZ1NwaGVyZS5jZW50ZXIgKVxyXG5cdFx0XHRcdFx0XHRcdC5hcHBseU1hdHJpeDQoIG9iamVjdC5tYXRyaXhXb3JsZCApXHJcblx0XHRcdFx0XHRcdFx0LmFwcGx5TWF0cml4NCggX3Byb2pTY3JlZW5NYXRyaXggKTtcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0aWYgKCBBcnJheS5pc0FycmF5KCBtYXRlcmlhbCApICkge1xyXG5cclxuXHRcdFx0XHRcdFx0Y29uc3QgZ3JvdXBzID0gZ2VvbWV0cnkuZ3JvdXBzO1xyXG5cclxuXHRcdFx0XHRcdFx0Zm9yICggbGV0IGkgPSAwLCBsID0gZ3JvdXBzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdGNvbnN0IGdyb3VwID0gZ3JvdXBzWyBpIF07XHJcblx0XHRcdFx0XHRcdFx0Y29uc3QgZ3JvdXBNYXRlcmlhbCA9IG1hdGVyaWFsWyBncm91cC5tYXRlcmlhbEluZGV4IF07XHJcblxyXG5cdFx0XHRcdFx0XHRcdGlmICggZ3JvdXBNYXRlcmlhbCAmJiBncm91cE1hdGVyaWFsLnZpc2libGUgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0cmVuZGVyTGlzdC5wdXNoKCBvYmplY3QsIGdlb21ldHJ5LCBncm91cE1hdGVyaWFsLCBncm91cE9yZGVyLCBfdmVjdG9yNC56LCBncm91cCwgY2xpcHBpbmdDb250ZXh0ICk7XHJcblxyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHR9IGVsc2UgaWYgKCBtYXRlcmlhbC52aXNpYmxlICkge1xyXG5cclxuXHRcdFx0XHRcdFx0cmVuZGVyTGlzdC5wdXNoKCBvYmplY3QsIGdlb21ldHJ5LCBtYXRlcmlhbCwgZ3JvdXBPcmRlciwgX3ZlY3RvcjQueiwgbnVsbCwgY2xpcHBpbmdDb250ZXh0ICk7XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggb2JqZWN0LmlzQnVuZGxlR3JvdXAgPT09IHRydWUgJiYgdGhpcy5iYWNrZW5kLmJlZ2luQnVuZGxlICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRjb25zdCBiYXNlUmVuZGVyTGlzdCA9IHJlbmRlckxpc3Q7XHJcblxyXG5cdFx0XHQvLyByZXBsYWNlIHJlbmRlciBsaXN0XHJcblx0XHRcdHJlbmRlckxpc3QgPSB0aGlzLl9yZW5kZXJMaXN0cy5nZXQoIG9iamVjdCwgY2FtZXJhICk7XHJcblxyXG5cdFx0XHRyZW5kZXJMaXN0LmJlZ2luKCk7XHJcblxyXG5cdFx0XHRiYXNlUmVuZGVyTGlzdC5wdXNoQnVuZGxlKCB7XHJcblx0XHRcdFx0YnVuZGxlR3JvdXA6IG9iamVjdCxcclxuXHRcdFx0XHRjYW1lcmEsXHJcblx0XHRcdFx0cmVuZGVyTGlzdCxcclxuXHRcdFx0fSApO1xyXG5cclxuXHRcdFx0cmVuZGVyTGlzdC5maW5pc2goKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Y29uc3QgY2hpbGRyZW4gPSBvYmplY3QuY2hpbGRyZW47XHJcblxyXG5cdFx0Zm9yICggbGV0IGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcclxuXHJcblx0XHRcdHRoaXMuX3Byb2plY3RPYmplY3QoIGNoaWxkcmVuWyBpIF0sIGNhbWVyYSwgZ3JvdXBPcmRlciwgcmVuZGVyTGlzdCwgY2xpcHBpbmdDb250ZXh0ICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdF9yZW5kZXJCdW5kbGVzKCBidW5kbGVzLCBzY2VuZVJlZiwgbGlnaHRzTm9kZSApIHtcclxuXHJcblx0XHRmb3IgKCBjb25zdCBidW5kbGUgb2YgYnVuZGxlcyApIHtcclxuXHJcblx0XHRcdHRoaXMuX3JlbmRlckJ1bmRsZSggYnVuZGxlLCBzY2VuZVJlZiwgbGlnaHRzTm9kZSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHRfcmVuZGVyVHJhbnNwYXJlbnRzKCByZW5kZXJMaXN0LCBkb3VibGVQYXNzTGlzdCwgY2FtZXJhLCBzY2VuZSwgbGlnaHRzTm9kZSApIHtcclxuXHJcblx0XHRpZiAoIGRvdWJsZVBhc3NMaXN0Lmxlbmd0aCA+IDAgKSB7XHJcblxyXG5cdFx0XHQvLyByZW5kZXIgYmFjayBzaWRlXHJcblxyXG5cdFx0XHRmb3IgKCBjb25zdCB7IG1hdGVyaWFsIH0gb2YgZG91YmxlUGFzc0xpc3QgKSB7XHJcblxyXG5cdFx0XHRcdG1hdGVyaWFsLnNpZGUgPSBCYWNrU2lkZTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHRoaXMuX3JlbmRlck9iamVjdHMoIGRvdWJsZVBhc3NMaXN0LCBjYW1lcmEsIHNjZW5lLCBsaWdodHNOb2RlLCAnYmFja1NpZGUnICk7XHJcblxyXG5cdFx0XHQvLyByZW5kZXIgZnJvbnQgc2lkZVxyXG5cclxuXHRcdFx0Zm9yICggY29uc3QgeyBtYXRlcmlhbCB9IG9mIGRvdWJsZVBhc3NMaXN0ICkge1xyXG5cclxuXHRcdFx0XHRtYXRlcmlhbC5zaWRlID0gRnJvbnRTaWRlO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dGhpcy5fcmVuZGVyT2JqZWN0cyggcmVuZGVyTGlzdCwgY2FtZXJhLCBzY2VuZSwgbGlnaHRzTm9kZSApO1xyXG5cclxuXHRcdFx0Ly8gcmVzdG9yZVxyXG5cclxuXHRcdFx0Zm9yICggY29uc3QgeyBtYXRlcmlhbCB9IG9mIGRvdWJsZVBhc3NMaXN0ICkge1xyXG5cclxuXHRcdFx0XHRtYXRlcmlhbC5zaWRlID0gRG91YmxlU2lkZTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0dGhpcy5fcmVuZGVyT2JqZWN0cyggcmVuZGVyTGlzdCwgY2FtZXJhLCBzY2VuZSwgbGlnaHRzTm9kZSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHRfcmVuZGVyT2JqZWN0cyggcmVuZGVyTGlzdCwgY2FtZXJhLCBzY2VuZSwgbGlnaHRzTm9kZSwgcGFzc0lkID0gbnVsbCApIHtcclxuXHJcblx0XHQvLyBwcm9jZXNzIHJlbmRlcmFibGUgb2JqZWN0c1xyXG5cclxuXHRcdGZvciAoIGxldCBpID0gMCwgaWwgPSByZW5kZXJMaXN0Lmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xyXG5cclxuXHRcdFx0Y29uc3QgcmVuZGVySXRlbSA9IHJlbmRlckxpc3RbIGkgXTtcclxuXHJcblx0XHRcdC8vIEBUT0RPOiBBZGQgc3VwcG9ydCBmb3IgbXVsdGlwbGUgbWF0ZXJpYWxzIHBlciBvYmplY3QuIFRoaXMgd2lsbCByZXF1aXJlIHRvIGV4dHJhY3RcclxuXHRcdFx0Ly8gdGhlIG1hdGVyaWFsIGZyb20gdGhlIHJlbmRlckl0ZW0gb2JqZWN0IGFuZCBwYXNzIGl0IHdpdGggaXRzIGdyb3VwIGRhdGEgdG8gcmVuZGVyT2JqZWN0KCkuXHJcblxyXG5cdFx0XHRjb25zdCB7IG9iamVjdCwgZ2VvbWV0cnksIG1hdGVyaWFsLCBncm91cCwgY2xpcHBpbmdDb250ZXh0IH0gPSByZW5kZXJJdGVtO1xyXG5cclxuXHRcdFx0aWYgKCBjYW1lcmEuaXNBcnJheUNhbWVyYSApIHtcclxuXHJcblx0XHRcdFx0Y29uc3QgY2FtZXJhcyA9IGNhbWVyYS5jYW1lcmFzO1xyXG5cclxuXHRcdFx0XHRmb3IgKCBsZXQgaiA9IDAsIGpsID0gY2FtZXJhcy5sZW5ndGg7IGogPCBqbDsgaiArKyApIHtcclxuXHJcblx0XHRcdFx0XHRjb25zdCBjYW1lcmEyID0gY2FtZXJhc1sgaiBdO1xyXG5cclxuXHRcdFx0XHRcdGlmICggb2JqZWN0LmxheWVycy50ZXN0KCBjYW1lcmEyLmxheWVycyApICkge1xyXG5cclxuXHRcdFx0XHRcdFx0Y29uc3QgdnAgPSBjYW1lcmEyLnZpZXdwb3J0O1xyXG5cdFx0XHRcdFx0XHRjb25zdCBtaW5EZXB0aCA9ICggdnAubWluRGVwdGggPT09IHVuZGVmaW5lZCApID8gMCA6IHZwLm1pbkRlcHRoO1xyXG5cdFx0XHRcdFx0XHRjb25zdCBtYXhEZXB0aCA9ICggdnAubWF4RGVwdGggPT09IHVuZGVmaW5lZCApID8gMSA6IHZwLm1heERlcHRoO1xyXG5cclxuXHRcdFx0XHRcdFx0Y29uc3Qgdmlld3BvcnRWYWx1ZSA9IHRoaXMuX2N1cnJlbnRSZW5kZXJDb250ZXh0LnZpZXdwb3J0VmFsdWU7XHJcblx0XHRcdFx0XHRcdHZpZXdwb3J0VmFsdWUuY29weSggdnAgKS5tdWx0aXBseVNjYWxhciggdGhpcy5fcGl4ZWxSYXRpbyApLmZsb29yKCk7XHJcblx0XHRcdFx0XHRcdHZpZXdwb3J0VmFsdWUubWluRGVwdGggPSBtaW5EZXB0aDtcclxuXHRcdFx0XHRcdFx0dmlld3BvcnRWYWx1ZS5tYXhEZXB0aCA9IG1heERlcHRoO1xyXG5cclxuXHRcdFx0XHRcdFx0dGhpcy5iYWNrZW5kLnVwZGF0ZVZpZXdwb3J0KCB0aGlzLl9jdXJyZW50UmVuZGVyQ29udGV4dCApO1xyXG5cclxuXHRcdFx0XHRcdFx0dGhpcy5fY3VycmVudFJlbmRlck9iamVjdEZ1bmN0aW9uKCBvYmplY3QsIHNjZW5lLCBjYW1lcmEyLCBnZW9tZXRyeSwgbWF0ZXJpYWwsIGdyb3VwLCBsaWdodHNOb2RlLCBjbGlwcGluZ0NvbnRleHQsIHBhc3NJZCApO1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0dGhpcy5fY3VycmVudFJlbmRlck9iamVjdEZ1bmN0aW9uKCBvYmplY3QsIHNjZW5lLCBjYW1lcmEsIGdlb21ldHJ5LCBtYXRlcmlhbCwgZ3JvdXAsIGxpZ2h0c05vZGUsIGNsaXBwaW5nQ29udGV4dCwgcGFzc0lkICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdHJlbmRlck9iamVjdCggb2JqZWN0LCBzY2VuZSwgY2FtZXJhLCBnZW9tZXRyeSwgbWF0ZXJpYWwsIGdyb3VwLCBsaWdodHNOb2RlLCBjbGlwcGluZ0NvbnRleHQgPSBudWxsLCBwYXNzSWQgPSBudWxsICkge1xyXG5cclxuXHRcdGxldCBvdmVycmlkZVBvc2l0aW9uTm9kZTtcclxuXHRcdGxldCBvdmVycmlkZUNvbG9yTm9kZTtcclxuXHRcdGxldCBvdmVycmlkZURlcHRoTm9kZTtcclxuXHJcblx0XHQvL1xyXG5cclxuXHRcdG9iamVjdC5vbkJlZm9yZVJlbmRlciggdGhpcywgc2NlbmUsIGNhbWVyYSwgZ2VvbWV0cnksIG1hdGVyaWFsLCBncm91cCApO1xyXG5cclxuXHRcdC8vXHJcblxyXG5cdFx0aWYgKCBzY2VuZS5vdmVycmlkZU1hdGVyaWFsICE9PSBudWxsICkge1xyXG5cclxuXHRcdFx0Y29uc3Qgb3ZlcnJpZGVNYXRlcmlhbCA9IHNjZW5lLm92ZXJyaWRlTWF0ZXJpYWw7XHJcblxyXG5cdFx0XHRpZiAoIG1hdGVyaWFsLnBvc2l0aW9uTm9kZSAmJiBtYXRlcmlhbC5wb3NpdGlvbk5vZGUuaXNOb2RlICkge1xyXG5cclxuXHRcdFx0XHRvdmVycmlkZVBvc2l0aW9uTm9kZSA9IG92ZXJyaWRlTWF0ZXJpYWwucG9zaXRpb25Ob2RlO1xyXG5cdFx0XHRcdG92ZXJyaWRlTWF0ZXJpYWwucG9zaXRpb25Ob2RlID0gbWF0ZXJpYWwucG9zaXRpb25Ob2RlO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0b3ZlcnJpZGVNYXRlcmlhbC5hbHBoYVRlc3QgPSBtYXRlcmlhbC5hbHBoYVRlc3Q7XHJcblx0XHRcdG92ZXJyaWRlTWF0ZXJpYWwuYWxwaGFNYXAgPSBtYXRlcmlhbC5hbHBoYU1hcDtcclxuXHRcdFx0b3ZlcnJpZGVNYXRlcmlhbC50cmFuc3BhcmVudCA9IG1hdGVyaWFsLnRyYW5zcGFyZW50IHx8IG1hdGVyaWFsLnRyYW5zbWlzc2lvbiA+IDA7XHJcblxyXG5cdFx0XHRpZiAoIG92ZXJyaWRlTWF0ZXJpYWwuaXNTaGFkb3dOb2RlTWF0ZXJpYWwgKSB7XHJcblxyXG5cdFx0XHRcdG92ZXJyaWRlTWF0ZXJpYWwuc2lkZSA9IG1hdGVyaWFsLnNoYWRvd1NpZGUgPT09IG51bGwgPyBtYXRlcmlhbC5zaWRlIDogbWF0ZXJpYWwuc2hhZG93U2lkZTtcclxuXHJcblx0XHRcdFx0aWYgKCBtYXRlcmlhbC5kZXB0aE5vZGUgJiYgbWF0ZXJpYWwuZGVwdGhOb2RlLmlzTm9kZSApIHtcclxuXHJcblx0XHRcdFx0XHRvdmVycmlkZURlcHRoTm9kZSA9IG92ZXJyaWRlTWF0ZXJpYWwuZGVwdGhOb2RlO1xyXG5cdFx0XHRcdFx0b3ZlcnJpZGVNYXRlcmlhbC5kZXB0aE5vZGUgPSBtYXRlcmlhbC5kZXB0aE5vZGU7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0aWYgKCBtYXRlcmlhbC5jYXN0U2hhZG93Tm9kZSAmJiBtYXRlcmlhbC5jYXN0U2hhZG93Tm9kZS5pc05vZGUgKSB7XHJcblxyXG5cdFx0XHRcdFx0b3ZlcnJpZGVDb2xvck5vZGUgPSBvdmVycmlkZU1hdGVyaWFsLmNvbG9yTm9kZTtcclxuXHRcdFx0XHRcdG92ZXJyaWRlTWF0ZXJpYWwuY29sb3JOb2RlID0gbWF0ZXJpYWwuY2FzdFNoYWRvd05vZGU7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdG1hdGVyaWFsID0gb3ZlcnJpZGVNYXRlcmlhbDtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly9cclxuXHJcblx0XHRpZiAoIG1hdGVyaWFsLnRyYW5zcGFyZW50ID09PSB0cnVlICYmIG1hdGVyaWFsLnNpZGUgPT09IERvdWJsZVNpZGUgJiYgbWF0ZXJpYWwuZm9yY2VTaW5nbGVQYXNzID09PSBmYWxzZSApIHtcclxuXHJcblx0XHRcdG1hdGVyaWFsLnNpZGUgPSBCYWNrU2lkZTtcclxuXHRcdFx0dGhpcy5faGFuZGxlT2JqZWN0RnVuY3Rpb24oIG9iamVjdCwgbWF0ZXJpYWwsIHNjZW5lLCBjYW1lcmEsIGxpZ2h0c05vZGUsIGdyb3VwLCBjbGlwcGluZ0NvbnRleHQsICdiYWNrU2lkZScgKTsgLy8gY3JlYXRlIGJhY2tTaWRlIHBhc3MgaWRcclxuXHJcblx0XHRcdG1hdGVyaWFsLnNpZGUgPSBGcm9udFNpZGU7XHJcblx0XHRcdHRoaXMuX2hhbmRsZU9iamVjdEZ1bmN0aW9uKCBvYmplY3QsIG1hdGVyaWFsLCBzY2VuZSwgY2FtZXJhLCBsaWdodHNOb2RlLCBncm91cCwgY2xpcHBpbmdDb250ZXh0LCBwYXNzSWQgKTsgLy8gdXNlIGRlZmF1bHQgcGFzcyBpZFxyXG5cclxuXHRcdFx0bWF0ZXJpYWwuc2lkZSA9IERvdWJsZVNpZGU7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdHRoaXMuX2hhbmRsZU9iamVjdEZ1bmN0aW9uKCBvYmplY3QsIG1hdGVyaWFsLCBzY2VuZSwgY2FtZXJhLCBsaWdodHNOb2RlLCBncm91cCwgY2xpcHBpbmdDb250ZXh0LCBwYXNzSWQgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly9cclxuXHJcblx0XHRpZiAoIG92ZXJyaWRlUG9zaXRpb25Ob2RlICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRzY2VuZS5vdmVycmlkZU1hdGVyaWFsLnBvc2l0aW9uTm9kZSA9IG92ZXJyaWRlUG9zaXRpb25Ob2RlO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIG92ZXJyaWRlRGVwdGhOb2RlICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRzY2VuZS5vdmVycmlkZU1hdGVyaWFsLmRlcHRoTm9kZSA9IG92ZXJyaWRlRGVwdGhOb2RlO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIG92ZXJyaWRlQ29sb3JOb2RlICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRzY2VuZS5vdmVycmlkZU1hdGVyaWFsLmNvbG9yTm9kZSA9IG92ZXJyaWRlQ29sb3JOb2RlO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvL1xyXG5cclxuXHRcdG9iamVjdC5vbkFmdGVyUmVuZGVyKCB0aGlzLCBzY2VuZSwgY2FtZXJhLCBnZW9tZXRyeSwgbWF0ZXJpYWwsIGdyb3VwICk7XHJcblxyXG5cdH1cclxuXHJcblx0X3JlbmRlck9iamVjdERpcmVjdCggb2JqZWN0LCBtYXRlcmlhbCwgc2NlbmUsIGNhbWVyYSwgbGlnaHRzTm9kZSwgZ3JvdXAsIGNsaXBwaW5nQ29udGV4dCwgcGFzc0lkICkge1xyXG5cclxuXHRcdGNvbnN0IHJlbmRlck9iamVjdCA9IHRoaXMuX29iamVjdHMuZ2V0KCBvYmplY3QsIG1hdGVyaWFsLCBzY2VuZSwgY2FtZXJhLCBsaWdodHNOb2RlLCB0aGlzLl9jdXJyZW50UmVuZGVyQ29udGV4dCwgY2xpcHBpbmdDb250ZXh0LCBwYXNzSWQgKTtcclxuXHRcdHJlbmRlck9iamVjdC5kcmF3UmFuZ2UgPSBvYmplY3QuZ2VvbWV0cnkuZHJhd1JhbmdlO1xyXG5cdFx0cmVuZGVyT2JqZWN0Lmdyb3VwID0gZ3JvdXA7XHJcblxyXG5cdFx0Ly9cclxuXHJcblx0XHRjb25zdCBuZWVkc1JlZnJlc2ggPSB0aGlzLl9ub2Rlcy5uZWVkc1JlZnJlc2goIHJlbmRlck9iamVjdCApO1xyXG5cclxuXHRcdGlmICggbmVlZHNSZWZyZXNoICkge1xyXG5cclxuXHRcdFx0dGhpcy5fbm9kZXMudXBkYXRlQmVmb3JlKCByZW5kZXJPYmplY3QgKTtcclxuXHJcblx0XHRcdHRoaXMuX2dlb21ldHJpZXMudXBkYXRlRm9yUmVuZGVyKCByZW5kZXJPYmplY3QgKTtcclxuXHJcblx0XHRcdHRoaXMuX25vZGVzLnVwZGF0ZUZvclJlbmRlciggcmVuZGVyT2JqZWN0ICk7XHJcblx0XHRcdHRoaXMuX2JpbmRpbmdzLnVwZGF0ZUZvclJlbmRlciggcmVuZGVyT2JqZWN0ICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX3BpcGVsaW5lcy51cGRhdGVGb3JSZW5kZXIoIHJlbmRlck9iamVjdCApO1xyXG5cclxuXHRcdC8vXHJcblxyXG5cdFx0aWYgKCB0aGlzLl9jdXJyZW50UmVuZGVyQnVuZGxlICE9PSBudWxsICkge1xyXG5cclxuXHRcdFx0Y29uc3QgcmVuZGVyQnVuZGxlRGF0YSA9IHRoaXMuYmFja2VuZC5nZXQoIHRoaXMuX2N1cnJlbnRSZW5kZXJCdW5kbGUgKTtcclxuXHJcblx0XHRcdHJlbmRlckJ1bmRsZURhdGEucmVuZGVyT2JqZWN0cy5wdXNoKCByZW5kZXJPYmplY3QgKTtcclxuXHJcblx0XHRcdHJlbmRlck9iamVjdC5idW5kbGUgPSB0aGlzLl9jdXJyZW50UmVuZGVyQnVuZGxlLnNjZW5lO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLmJhY2tlbmQuZHJhdyggcmVuZGVyT2JqZWN0LCB0aGlzLmluZm8gKTtcclxuXHJcblx0XHRpZiAoIG5lZWRzUmVmcmVzaCApIHRoaXMuX25vZGVzLnVwZGF0ZUFmdGVyKCByZW5kZXJPYmplY3QgKTtcclxuXHJcblx0fVxyXG5cclxuXHRfY3JlYXRlT2JqZWN0UGlwZWxpbmUoIG9iamVjdCwgbWF0ZXJpYWwsIHNjZW5lLCBjYW1lcmEsIGxpZ2h0c05vZGUsIGdyb3VwLCBjbGlwcGluZ0NvbnRleHQsIHBhc3NJZCApIHtcclxuXHJcblx0XHRjb25zdCByZW5kZXJPYmplY3QgPSB0aGlzLl9vYmplY3RzLmdldCggb2JqZWN0LCBtYXRlcmlhbCwgc2NlbmUsIGNhbWVyYSwgbGlnaHRzTm9kZSwgdGhpcy5fY3VycmVudFJlbmRlckNvbnRleHQsIGNsaXBwaW5nQ29udGV4dCwgcGFzc0lkICk7XHJcblx0XHRyZW5kZXJPYmplY3QuZHJhd1JhbmdlID0gb2JqZWN0Lmdlb21ldHJ5LmRyYXdSYW5nZTtcclxuXHRcdHJlbmRlck9iamVjdC5ncm91cCA9IGdyb3VwO1xyXG5cclxuXHRcdC8vXHJcblxyXG5cdFx0dGhpcy5fbm9kZXMudXBkYXRlQmVmb3JlKCByZW5kZXJPYmplY3QgKTtcclxuXHJcblx0XHR0aGlzLl9nZW9tZXRyaWVzLnVwZGF0ZUZvclJlbmRlciggcmVuZGVyT2JqZWN0ICk7XHJcblxyXG5cdFx0dGhpcy5fbm9kZXMudXBkYXRlRm9yUmVuZGVyKCByZW5kZXJPYmplY3QgKTtcclxuXHRcdHRoaXMuX2JpbmRpbmdzLnVwZGF0ZUZvclJlbmRlciggcmVuZGVyT2JqZWN0ICk7XHJcblxyXG5cdFx0dGhpcy5fcGlwZWxpbmVzLmdldEZvclJlbmRlciggcmVuZGVyT2JqZWN0LCB0aGlzLl9jb21waWxhdGlvblByb21pc2VzICk7XHJcblxyXG5cdFx0dGhpcy5fbm9kZXMudXBkYXRlQWZ0ZXIoIHJlbmRlck9iamVjdCApO1xyXG5cclxuXHR9XHJcblxyXG5cdGdldCBjb21waWxlKCkge1xyXG5cclxuXHRcdHJldHVybiB0aGlzLmNvbXBpbGVBc3luYztcclxuXHJcblx0fVxyXG5cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgUmVuZGVyZXI7XHJcbiIsImNsYXNzIEJpbmRpbmcge1xyXG5cclxuXHRjb25zdHJ1Y3RvciggbmFtZSA9ICcnICkge1xyXG5cclxuXHRcdHRoaXMubmFtZSA9IG5hbWU7XHJcblxyXG5cdFx0dGhpcy52aXNpYmlsaXR5ID0gMDtcclxuXHJcblx0fVxyXG5cclxuXHRzZXRWaXNpYmlsaXR5KCB2aXNpYmlsaXR5ICkge1xyXG5cclxuXHRcdHRoaXMudmlzaWJpbGl0eSB8PSB2aXNpYmlsaXR5O1xyXG5cclxuXHR9XHJcblxyXG5cdGNsb25lKCkge1xyXG5cclxuXHRcdHJldHVybiBPYmplY3QuYXNzaWduKCBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLCB0aGlzICk7XHJcblxyXG5cdH1cclxuXHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IEJpbmRpbmc7XHJcbiIsImltcG9ydCB7IEdQVV9DSFVOS19CWVRFUyB9IGZyb20gJy4vQ29uc3RhbnRzLmpzJztcclxuXHJcbmZ1bmN0aW9uIGdldEZsb2F0TGVuZ3RoKCBmbG9hdExlbmd0aCApIHtcclxuXHJcblx0Ly8gZW5zdXJlIGNodW5rIHNpemUgYWxpZ25tZW50IChTVEQxNDAgbGF5b3V0KVxyXG5cclxuXHRyZXR1cm4gZmxvYXRMZW5ndGggKyAoICggR1BVX0NIVU5LX0JZVEVTIC0gKCBmbG9hdExlbmd0aCAlIEdQVV9DSFVOS19CWVRFUyApICkgJSBHUFVfQ0hVTktfQllURVMgKTtcclxuXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdldFZlY3Rvckxlbmd0aCggY291bnQsIHZlY3Rvckxlbmd0aCA9IDQgKSB7XHJcblxyXG5cdGNvbnN0IHN0cmlkZUxlbmd0aCA9IGdldFN0cmlkZUxlbmd0aCggdmVjdG9yTGVuZ3RoICk7XHJcblxyXG5cdGNvbnN0IGZsb2F0TGVuZ3RoID0gc3RyaWRlTGVuZ3RoICogY291bnQ7XHJcblxyXG5cdHJldHVybiBnZXRGbG9hdExlbmd0aCggZmxvYXRMZW5ndGggKTtcclxuXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdldFN0cmlkZUxlbmd0aCggdmVjdG9yTGVuZ3RoICkge1xyXG5cclxuXHRjb25zdCBzdHJpZGVMZW5ndGggPSA0O1xyXG5cclxuXHRyZXR1cm4gdmVjdG9yTGVuZ3RoICsgKCAoIHN0cmlkZUxlbmd0aCAtICggdmVjdG9yTGVuZ3RoICUgc3RyaWRlTGVuZ3RoICkgKSAlIHN0cmlkZUxlbmd0aCApO1xyXG5cclxufVxyXG5cclxuZXhwb3J0IHtcclxuXHRnZXRGbG9hdExlbmd0aCxcclxuXHRnZXRWZWN0b3JMZW5ndGgsXHJcblx0Z2V0U3RyaWRlTGVuZ3RoXHJcbn07XHJcbiIsImltcG9ydCBCaW5kaW5nIGZyb20gJy4vQmluZGluZy5qcyc7XHJcbmltcG9ydCB7IGdldEZsb2F0TGVuZ3RoIH0gZnJvbSAnLi9CdWZmZXJVdGlscy5qcyc7XHJcblxyXG5jbGFzcyBCdWZmZXIgZXh0ZW5kcyBCaW5kaW5nIHtcclxuXHJcblx0Y29uc3RydWN0b3IoIG5hbWUsIGJ1ZmZlciA9IG51bGwgKSB7XHJcblxyXG5cdFx0c3VwZXIoIG5hbWUgKTtcclxuXHJcblx0XHR0aGlzLmlzQnVmZmVyID0gdHJ1ZTtcclxuXHJcblx0XHR0aGlzLmJ5dGVzUGVyRWxlbWVudCA9IEZsb2F0MzJBcnJheS5CWVRFU19QRVJfRUxFTUVOVDtcclxuXHJcblx0XHR0aGlzLl9idWZmZXIgPSBidWZmZXI7XHJcblxyXG5cdH1cclxuXHJcblx0Z2V0IGJ5dGVMZW5ndGgoKSB7XHJcblxyXG5cdFx0cmV0dXJuIGdldEZsb2F0TGVuZ3RoKCB0aGlzLl9idWZmZXIuYnl0ZUxlbmd0aCApO1xyXG5cclxuXHR9XHJcblxyXG5cdGdldCBidWZmZXIoKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuX2J1ZmZlcjtcclxuXHJcblx0fVxyXG5cclxuXHR1cGRhdGUoKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRydWU7XHJcblxyXG5cdH1cclxuXHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IEJ1ZmZlcjtcclxuIiwiaW1wb3J0IEJ1ZmZlciBmcm9tICcuL0J1ZmZlci5qcyc7XHJcblxyXG5jbGFzcyBVbmlmb3JtQnVmZmVyIGV4dGVuZHMgQnVmZmVyIHtcclxuXHJcblx0Y29uc3RydWN0b3IoIG5hbWUsIGJ1ZmZlciA9IG51bGwgKSB7XHJcblxyXG5cdFx0c3VwZXIoIG5hbWUsIGJ1ZmZlciApO1xyXG5cclxuXHRcdHRoaXMuaXNVbmlmb3JtQnVmZmVyID0gdHJ1ZTtcclxuXHJcblx0fVxyXG5cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgVW5pZm9ybUJ1ZmZlcjtcclxuIiwiaW1wb3J0IFVuaWZvcm1CdWZmZXIgZnJvbSAnLi4vVW5pZm9ybUJ1ZmZlci5qcyc7XHJcblxyXG5sZXQgX2lkID0gMDtcclxuXHJcbmNsYXNzIE5vZGVVbmlmb3JtQnVmZmVyIGV4dGVuZHMgVW5pZm9ybUJ1ZmZlciB7XHJcblxyXG5cdGNvbnN0cnVjdG9yKCBub2RlVW5pZm9ybSwgZ3JvdXBOb2RlICkge1xyXG5cclxuXHRcdHN1cGVyKCAnVW5pZm9ybUJ1ZmZlcl8nICsgX2lkICsrLCBub2RlVW5pZm9ybSA/IG5vZGVVbmlmb3JtLnZhbHVlIDogbnVsbCApO1xyXG5cclxuXHRcdHRoaXMubm9kZVVuaWZvcm0gPSBub2RlVW5pZm9ybTtcclxuXHRcdHRoaXMuZ3JvdXBOb2RlID0gZ3JvdXBOb2RlO1xyXG5cclxuXHR9XHJcblxyXG5cdGdldCBidWZmZXIoKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMubm9kZVVuaWZvcm0udmFsdWU7XHJcblxyXG5cdH1cclxuXHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IE5vZGVVbmlmb3JtQnVmZmVyO1xyXG4iLCJpbXBvcnQgVW5pZm9ybUJ1ZmZlciBmcm9tICcuL1VuaWZvcm1CdWZmZXIuanMnO1xyXG5pbXBvcnQgeyBHUFVfQ0hVTktfQllURVMgfSBmcm9tICcuL0NvbnN0YW50cy5qcyc7XHJcblxyXG5jbGFzcyBVbmlmb3Jtc0dyb3VwIGV4dGVuZHMgVW5pZm9ybUJ1ZmZlciB7XHJcblxyXG5cdGNvbnN0cnVjdG9yKCBuYW1lICkge1xyXG5cclxuXHRcdHN1cGVyKCBuYW1lICk7XHJcblxyXG5cdFx0dGhpcy5pc1VuaWZvcm1zR3JvdXAgPSB0cnVlO1xyXG5cclxuXHRcdHRoaXMuX3ZhbHVlcyA9IG51bGw7XHJcblxyXG5cdFx0Ly8gdGhlIG9yZGVyIG9mIHVuaWZvcm1zIGluIHRoaXMgYXJyYXkgbXVzdCBtYXRjaCB0aGUgb3JkZXIgb2YgdW5pZm9ybXMgaW4gdGhlIHNoYWRlclxyXG5cclxuXHRcdHRoaXMudW5pZm9ybXMgPSBbXTtcclxuXHJcblx0fVxyXG5cclxuXHRhZGRVbmlmb3JtKCB1bmlmb3JtICkge1xyXG5cclxuXHRcdHRoaXMudW5pZm9ybXMucHVzaCggdW5pZm9ybSApO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9XHJcblxyXG5cdHJlbW92ZVVuaWZvcm0oIHVuaWZvcm0gKSB7XHJcblxyXG5cdFx0Y29uc3QgaW5kZXggPSB0aGlzLnVuaWZvcm1zLmluZGV4T2YoIHVuaWZvcm0gKTtcclxuXHJcblx0XHRpZiAoIGluZGV4ICE9PSAtIDEgKSB7XHJcblxyXG5cdFx0XHR0aGlzLnVuaWZvcm1zLnNwbGljZSggaW5kZXgsIDEgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHJcblx0Z2V0IHZhbHVlcygpIHtcclxuXHJcblx0XHRpZiAoIHRoaXMuX3ZhbHVlcyA9PT0gbnVsbCApIHtcclxuXHJcblx0XHRcdHRoaXMuX3ZhbHVlcyA9IEFycmF5LmZyb20oIHRoaXMuYnVmZmVyICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzLl92YWx1ZXM7XHJcblxyXG5cdH1cclxuXHJcblx0Z2V0IGJ1ZmZlcigpIHtcclxuXHJcblx0XHRsZXQgYnVmZmVyID0gdGhpcy5fYnVmZmVyO1xyXG5cclxuXHRcdGlmICggYnVmZmVyID09PSBudWxsICkge1xyXG5cclxuXHRcdFx0Y29uc3QgYnl0ZUxlbmd0aCA9IHRoaXMuYnl0ZUxlbmd0aDtcclxuXHJcblx0XHRcdGJ1ZmZlciA9IG5ldyBGbG9hdDMyQXJyYXkoIG5ldyBBcnJheUJ1ZmZlciggYnl0ZUxlbmd0aCApICk7XHJcblxyXG5cdFx0XHR0aGlzLl9idWZmZXIgPSBidWZmZXI7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBidWZmZXI7XHJcblxyXG5cdH1cclxuXHJcblx0Z2V0IGJ5dGVMZW5ndGgoKSB7XHJcblxyXG5cdFx0bGV0IG9mZnNldCA9IDA7IC8vIGdsb2JhbCBidWZmZXIgb2Zmc2V0IGluIGJ5dGVzXHJcblxyXG5cdFx0Zm9yICggbGV0IGkgPSAwLCBsID0gdGhpcy51bmlmb3Jtcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xyXG5cclxuXHRcdFx0Y29uc3QgdW5pZm9ybSA9IHRoaXMudW5pZm9ybXNbIGkgXTtcclxuXHJcblx0XHRcdGNvbnN0IHsgYm91bmRhcnksIGl0ZW1TaXplIH0gPSB1bmlmb3JtO1xyXG5cclxuXHRcdFx0Ly8gb2Zmc2V0IHdpdGhpbiBhIHNpbmdsZSBjaHVuayBpbiBieXRlc1xyXG5cclxuXHRcdFx0Y29uc3QgY2h1bmtPZmZzZXQgPSBvZmZzZXQgJSBHUFVfQ0hVTktfQllURVM7XHJcblx0XHRcdGNvbnN0IHJlbWFpbmluZ1NpemVJbkNodW5rID0gR1BVX0NIVU5LX0JZVEVTIC0gY2h1bmtPZmZzZXQ7XHJcblxyXG5cdFx0XHQvLyBjb25mb3JtYW5jZSB0ZXN0c1xyXG5cclxuXHRcdFx0aWYgKCBjaHVua09mZnNldCAhPT0gMCAmJiAoIHJlbWFpbmluZ1NpemVJbkNodW5rIC0gYm91bmRhcnkgKSA8IDAgKSB7XHJcblxyXG5cdFx0XHRcdC8vIGNoZWNrIGZvciBjaHVuayBvdmVyZmxvd1xyXG5cclxuXHRcdFx0XHRvZmZzZXQgKz0gKCBHUFVfQ0hVTktfQllURVMgLSBjaHVua09mZnNldCApO1xyXG5cclxuXHRcdFx0fSBlbHNlIGlmICggY2h1bmtPZmZzZXQgJSBib3VuZGFyeSAhPT0gMCApIHtcclxuXHJcblx0XHRcdFx0Ly8gY2hlY2sgZm9yIGNvcnJlY3QgYWxpZ25tZW50XHJcblxyXG5cdFx0XHRcdG9mZnNldCArPSAoIGNodW5rT2Zmc2V0ICUgYm91bmRhcnkgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHVuaWZvcm0ub2Zmc2V0ID0gKCBvZmZzZXQgLyB0aGlzLmJ5dGVzUGVyRWxlbWVudCApO1xyXG5cclxuXHRcdFx0b2Zmc2V0ICs9ICggaXRlbVNpemUgKiB0aGlzLmJ5dGVzUGVyRWxlbWVudCApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gTWF0aC5jZWlsKCBvZmZzZXQgLyBHUFVfQ0hVTktfQllURVMgKSAqIEdQVV9DSFVOS19CWVRFUztcclxuXHJcblx0fVxyXG5cclxuXHR1cGRhdGUoKSB7XHJcblxyXG5cdFx0bGV0IHVwZGF0ZWQgPSBmYWxzZTtcclxuXHJcblx0XHRmb3IgKCBjb25zdCB1bmlmb3JtIG9mIHRoaXMudW5pZm9ybXMgKSB7XHJcblxyXG5cdFx0XHRpZiAoIHRoaXMudXBkYXRlQnlUeXBlKCB1bmlmb3JtICkgPT09IHRydWUgKSB7XHJcblxyXG5cdFx0XHRcdHVwZGF0ZWQgPSB0cnVlO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdXBkYXRlZDtcclxuXHJcblx0fVxyXG5cclxuXHR1cGRhdGVCeVR5cGUoIHVuaWZvcm0gKSB7XHJcblxyXG5cdFx0aWYgKCB1bmlmb3JtLmlzTnVtYmVyVW5pZm9ybSApIHJldHVybiB0aGlzLnVwZGF0ZU51bWJlciggdW5pZm9ybSApO1xyXG5cdFx0aWYgKCB1bmlmb3JtLmlzVmVjdG9yMlVuaWZvcm0gKSByZXR1cm4gdGhpcy51cGRhdGVWZWN0b3IyKCB1bmlmb3JtICk7XHJcblx0XHRpZiAoIHVuaWZvcm0uaXNWZWN0b3IzVW5pZm9ybSApIHJldHVybiB0aGlzLnVwZGF0ZVZlY3RvcjMoIHVuaWZvcm0gKTtcclxuXHRcdGlmICggdW5pZm9ybS5pc1ZlY3RvcjRVbmlmb3JtICkgcmV0dXJuIHRoaXMudXBkYXRlVmVjdG9yNCggdW5pZm9ybSApO1xyXG5cdFx0aWYgKCB1bmlmb3JtLmlzQ29sb3JVbmlmb3JtICkgcmV0dXJuIHRoaXMudXBkYXRlQ29sb3IoIHVuaWZvcm0gKTtcclxuXHRcdGlmICggdW5pZm9ybS5pc01hdHJpeDNVbmlmb3JtICkgcmV0dXJuIHRoaXMudXBkYXRlTWF0cml4MyggdW5pZm9ybSApO1xyXG5cdFx0aWYgKCB1bmlmb3JtLmlzTWF0cml4NFVuaWZvcm0gKSByZXR1cm4gdGhpcy51cGRhdGVNYXRyaXg0KCB1bmlmb3JtICk7XHJcblxyXG5cdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLldlYkdQVVVuaWZvcm1zR3JvdXA6IFVuc3VwcG9ydGVkIHVuaWZvcm0gdHlwZS4nLCB1bmlmb3JtICk7XHJcblxyXG5cdH1cclxuXHJcblx0dXBkYXRlTnVtYmVyKCB1bmlmb3JtICkge1xyXG5cclxuXHRcdGxldCB1cGRhdGVkID0gZmFsc2U7XHJcblxyXG5cdFx0Y29uc3QgYSA9IHRoaXMudmFsdWVzO1xyXG5cdFx0Y29uc3QgdiA9IHVuaWZvcm0uZ2V0VmFsdWUoKTtcclxuXHRcdGNvbnN0IG9mZnNldCA9IHVuaWZvcm0ub2Zmc2V0O1xyXG5cdFx0Y29uc3QgdHlwZSA9IHVuaWZvcm0uZ2V0VHlwZSgpO1xyXG5cclxuXHRcdGlmICggYVsgb2Zmc2V0IF0gIT09IHYgKSB7XHJcblxyXG5cdFx0XHRjb25zdCBiID0gdGhpcy5fZ2V0QnVmZmVyRm9yVHlwZSggdHlwZSApO1xyXG5cclxuXHRcdFx0Ylsgb2Zmc2V0IF0gPSBhWyBvZmZzZXQgXSA9IHY7XHJcblx0XHRcdHVwZGF0ZWQgPSB0cnVlO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdXBkYXRlZDtcclxuXHJcblx0fVxyXG5cclxuXHR1cGRhdGVWZWN0b3IyKCB1bmlmb3JtICkge1xyXG5cclxuXHRcdGxldCB1cGRhdGVkID0gZmFsc2U7XHJcblxyXG5cdFx0Y29uc3QgYSA9IHRoaXMudmFsdWVzO1xyXG5cdFx0Y29uc3QgdiA9IHVuaWZvcm0uZ2V0VmFsdWUoKTtcclxuXHRcdGNvbnN0IG9mZnNldCA9IHVuaWZvcm0ub2Zmc2V0O1xyXG5cdFx0Y29uc3QgdHlwZSA9IHVuaWZvcm0uZ2V0VHlwZSgpO1xyXG5cclxuXHRcdGlmICggYVsgb2Zmc2V0ICsgMCBdICE9PSB2LnggfHwgYVsgb2Zmc2V0ICsgMSBdICE9PSB2LnkgKSB7XHJcblxyXG5cdFx0XHRjb25zdCBiID0gdGhpcy5fZ2V0QnVmZmVyRm9yVHlwZSggdHlwZSApO1xyXG5cclxuXHRcdFx0Ylsgb2Zmc2V0ICsgMCBdID0gYVsgb2Zmc2V0ICsgMCBdID0gdi54O1xyXG5cdFx0XHRiWyBvZmZzZXQgKyAxIF0gPSBhWyBvZmZzZXQgKyAxIF0gPSB2Lnk7XHJcblxyXG5cdFx0XHR1cGRhdGVkID0gdHJ1ZTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHVwZGF0ZWQ7XHJcblxyXG5cdH1cclxuXHJcblx0dXBkYXRlVmVjdG9yMyggdW5pZm9ybSApIHtcclxuXHJcblx0XHRsZXQgdXBkYXRlZCA9IGZhbHNlO1xyXG5cclxuXHRcdGNvbnN0IGEgPSB0aGlzLnZhbHVlcztcclxuXHRcdGNvbnN0IHYgPSB1bmlmb3JtLmdldFZhbHVlKCk7XHJcblx0XHRjb25zdCBvZmZzZXQgPSB1bmlmb3JtLm9mZnNldDtcclxuXHRcdGNvbnN0IHR5cGUgPSB1bmlmb3JtLmdldFR5cGUoKTtcclxuXHJcblx0XHRpZiAoIGFbIG9mZnNldCArIDAgXSAhPT0gdi54IHx8IGFbIG9mZnNldCArIDEgXSAhPT0gdi55IHx8IGFbIG9mZnNldCArIDIgXSAhPT0gdi56ICkge1xyXG5cclxuXHRcdFx0Y29uc3QgYiA9IHRoaXMuX2dldEJ1ZmZlckZvclR5cGUoIHR5cGUgKTtcclxuXHJcblx0XHRcdGJbIG9mZnNldCArIDAgXSA9IGFbIG9mZnNldCArIDAgXSA9IHYueDtcclxuXHRcdFx0Ylsgb2Zmc2V0ICsgMSBdID0gYVsgb2Zmc2V0ICsgMSBdID0gdi55O1xyXG5cdFx0XHRiWyBvZmZzZXQgKyAyIF0gPSBhWyBvZmZzZXQgKyAyIF0gPSB2Lno7XHJcblxyXG5cdFx0XHR1cGRhdGVkID0gdHJ1ZTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHVwZGF0ZWQ7XHJcblxyXG5cdH1cclxuXHJcblx0dXBkYXRlVmVjdG9yNCggdW5pZm9ybSApIHtcclxuXHJcblx0XHRsZXQgdXBkYXRlZCA9IGZhbHNlO1xyXG5cclxuXHRcdGNvbnN0IGEgPSB0aGlzLnZhbHVlcztcclxuXHRcdGNvbnN0IHYgPSB1bmlmb3JtLmdldFZhbHVlKCk7XHJcblx0XHRjb25zdCBvZmZzZXQgPSB1bmlmb3JtLm9mZnNldDtcclxuXHRcdGNvbnN0IHR5cGUgPSB1bmlmb3JtLmdldFR5cGUoKTtcclxuXHJcblx0XHRpZiAoIGFbIG9mZnNldCArIDAgXSAhPT0gdi54IHx8IGFbIG9mZnNldCArIDEgXSAhPT0gdi55IHx8IGFbIG9mZnNldCArIDIgXSAhPT0gdi56IHx8IGFbIG9mZnNldCArIDQgXSAhPT0gdi53ICkge1xyXG5cclxuXHRcdFx0Y29uc3QgYiA9IHRoaXMuX2dldEJ1ZmZlckZvclR5cGUoIHR5cGUgKTtcclxuXHJcblx0XHRcdGJbIG9mZnNldCArIDAgXSA9IGFbIG9mZnNldCArIDAgXSA9IHYueDtcclxuXHRcdFx0Ylsgb2Zmc2V0ICsgMSBdID0gYVsgb2Zmc2V0ICsgMSBdID0gdi55O1xyXG5cdFx0XHRiWyBvZmZzZXQgKyAyIF0gPSBhWyBvZmZzZXQgKyAyIF0gPSB2Lno7XHJcblx0XHRcdGJbIG9mZnNldCArIDMgXSA9IGFbIG9mZnNldCArIDMgXSA9IHYudztcclxuXHJcblx0XHRcdHVwZGF0ZWQgPSB0cnVlO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdXBkYXRlZDtcclxuXHJcblx0fVxyXG5cclxuXHR1cGRhdGVDb2xvciggdW5pZm9ybSApIHtcclxuXHJcblx0XHRsZXQgdXBkYXRlZCA9IGZhbHNlO1xyXG5cclxuXHRcdGNvbnN0IGEgPSB0aGlzLnZhbHVlcztcclxuXHRcdGNvbnN0IGMgPSB1bmlmb3JtLmdldFZhbHVlKCk7XHJcblx0XHRjb25zdCBvZmZzZXQgPSB1bmlmb3JtLm9mZnNldDtcclxuXHJcblx0XHRpZiAoIGFbIG9mZnNldCArIDAgXSAhPT0gYy5yIHx8IGFbIG9mZnNldCArIDEgXSAhPT0gYy5nIHx8IGFbIG9mZnNldCArIDIgXSAhPT0gYy5iICkge1xyXG5cclxuXHRcdFx0Y29uc3QgYiA9IHRoaXMuYnVmZmVyO1xyXG5cclxuXHRcdFx0Ylsgb2Zmc2V0ICsgMCBdID0gYVsgb2Zmc2V0ICsgMCBdID0gYy5yO1xyXG5cdFx0XHRiWyBvZmZzZXQgKyAxIF0gPSBhWyBvZmZzZXQgKyAxIF0gPSBjLmc7XHJcblx0XHRcdGJbIG9mZnNldCArIDIgXSA9IGFbIG9mZnNldCArIDIgXSA9IGMuYjtcclxuXHJcblx0XHRcdHVwZGF0ZWQgPSB0cnVlO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdXBkYXRlZDtcclxuXHJcblx0fVxyXG5cclxuXHR1cGRhdGVNYXRyaXgzKCB1bmlmb3JtICkge1xyXG5cclxuXHRcdGxldCB1cGRhdGVkID0gZmFsc2U7XHJcblxyXG5cdFx0Y29uc3QgYSA9IHRoaXMudmFsdWVzO1xyXG5cdFx0Y29uc3QgZSA9IHVuaWZvcm0uZ2V0VmFsdWUoKS5lbGVtZW50cztcclxuXHRcdGNvbnN0IG9mZnNldCA9IHVuaWZvcm0ub2Zmc2V0O1xyXG5cclxuXHRcdGlmICggYVsgb2Zmc2V0ICsgMCBdICE9PSBlWyAwIF0gfHwgYVsgb2Zmc2V0ICsgMSBdICE9PSBlWyAxIF0gfHwgYVsgb2Zmc2V0ICsgMiBdICE9PSBlWyAyIF0gfHxcclxuXHRcdFx0YVsgb2Zmc2V0ICsgNCBdICE9PSBlWyAzIF0gfHwgYVsgb2Zmc2V0ICsgNSBdICE9PSBlWyA0IF0gfHwgYVsgb2Zmc2V0ICsgNiBdICE9PSBlWyA1IF0gfHxcclxuXHRcdFx0YVsgb2Zmc2V0ICsgOCBdICE9PSBlWyA2IF0gfHwgYVsgb2Zmc2V0ICsgOSBdICE9PSBlWyA3IF0gfHwgYVsgb2Zmc2V0ICsgMTAgXSAhPT0gZVsgOCBdICkge1xyXG5cclxuXHRcdFx0Y29uc3QgYiA9IHRoaXMuYnVmZmVyO1xyXG5cclxuXHRcdFx0Ylsgb2Zmc2V0ICsgMCBdID0gYVsgb2Zmc2V0ICsgMCBdID0gZVsgMCBdO1xyXG5cdFx0XHRiWyBvZmZzZXQgKyAxIF0gPSBhWyBvZmZzZXQgKyAxIF0gPSBlWyAxIF07XHJcblx0XHRcdGJbIG9mZnNldCArIDIgXSA9IGFbIG9mZnNldCArIDIgXSA9IGVbIDIgXTtcclxuXHRcdFx0Ylsgb2Zmc2V0ICsgNCBdID0gYVsgb2Zmc2V0ICsgNCBdID0gZVsgMyBdO1xyXG5cdFx0XHRiWyBvZmZzZXQgKyA1IF0gPSBhWyBvZmZzZXQgKyA1IF0gPSBlWyA0IF07XHJcblx0XHRcdGJbIG9mZnNldCArIDYgXSA9IGFbIG9mZnNldCArIDYgXSA9IGVbIDUgXTtcclxuXHRcdFx0Ylsgb2Zmc2V0ICsgOCBdID0gYVsgb2Zmc2V0ICsgOCBdID0gZVsgNiBdO1xyXG5cdFx0XHRiWyBvZmZzZXQgKyA5IF0gPSBhWyBvZmZzZXQgKyA5IF0gPSBlWyA3IF07XHJcblx0XHRcdGJbIG9mZnNldCArIDEwIF0gPSBhWyBvZmZzZXQgKyAxMCBdID0gZVsgOCBdO1xyXG5cclxuXHRcdFx0dXBkYXRlZCA9IHRydWU7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB1cGRhdGVkO1xyXG5cclxuXHR9XHJcblxyXG5cdHVwZGF0ZU1hdHJpeDQoIHVuaWZvcm0gKSB7XHJcblxyXG5cdFx0bGV0IHVwZGF0ZWQgPSBmYWxzZTtcclxuXHJcblx0XHRjb25zdCBhID0gdGhpcy52YWx1ZXM7XHJcblx0XHRjb25zdCBlID0gdW5pZm9ybS5nZXRWYWx1ZSgpLmVsZW1lbnRzO1xyXG5cdFx0Y29uc3Qgb2Zmc2V0ID0gdW5pZm9ybS5vZmZzZXQ7XHJcblxyXG5cdFx0aWYgKCBhcnJheXNFcXVhbCggYSwgZSwgb2Zmc2V0ICkgPT09IGZhbHNlICkge1xyXG5cclxuXHRcdFx0Y29uc3QgYiA9IHRoaXMuYnVmZmVyO1xyXG5cdFx0XHRiLnNldCggZSwgb2Zmc2V0ICk7XHJcblx0XHRcdHNldEFycmF5KCBhLCBlLCBvZmZzZXQgKTtcclxuXHRcdFx0dXBkYXRlZCA9IHRydWU7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB1cGRhdGVkO1xyXG5cclxuXHR9XHJcblxyXG5cdF9nZXRCdWZmZXJGb3JUeXBlKCB0eXBlICkge1xyXG5cclxuXHRcdGlmICggdHlwZSA9PT0gJ2ludCcgfHwgdHlwZSA9PT0gJ2l2ZWMyJyB8fCB0eXBlID09PSAnaXZlYzMnIHx8IHR5cGUgPT09ICdpdmVjNCcgKSByZXR1cm4gbmV3IEludDMyQXJyYXkoIHRoaXMuYnVmZmVyLmJ1ZmZlciApO1xyXG5cdFx0aWYgKCB0eXBlID09PSAndWludCcgfHwgdHlwZSA9PT0gJ3V2ZWMyJyB8fCB0eXBlID09PSAndXZlYzMnIHx8IHR5cGUgPT09ICd1dmVjNCcgKSByZXR1cm4gbmV3IFVpbnQzMkFycmF5KCB0aGlzLmJ1ZmZlci5idWZmZXIgKTtcclxuXHRcdHJldHVybiB0aGlzLmJ1ZmZlcjtcclxuXHJcblx0fVxyXG5cclxufVxyXG5cclxuZnVuY3Rpb24gc2V0QXJyYXkoIGEsIGIsIG9mZnNldCApIHtcclxuXHJcblx0Zm9yICggbGV0IGkgPSAwLCBsID0gYi5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xyXG5cclxuXHRcdGFbIG9mZnNldCArIGkgXSA9IGJbIGkgXTtcclxuXHJcblx0fVxyXG5cclxufVxyXG5cclxuZnVuY3Rpb24gYXJyYXlzRXF1YWwoIGEsIGIsIG9mZnNldCApIHtcclxuXHJcblx0Zm9yICggbGV0IGkgPSAwLCBsID0gYi5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xyXG5cclxuXHRcdGlmICggYVsgb2Zmc2V0ICsgaSBdICE9PSBiWyBpIF0gKSByZXR1cm4gZmFsc2U7XHJcblxyXG5cdH1cclxuXHJcblx0cmV0dXJuIHRydWU7XHJcblxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBVbmlmb3Jtc0dyb3VwO1xyXG4iLCJpbXBvcnQgVW5pZm9ybXNHcm91cCBmcm9tICcuLi9Vbmlmb3Jtc0dyb3VwLmpzJztcclxuXHJcbmxldCBfaWQgPSAwO1xyXG5cclxuY2xhc3MgTm9kZVVuaWZvcm1zR3JvdXAgZXh0ZW5kcyBVbmlmb3Jtc0dyb3VwIHtcclxuXHJcblx0Y29uc3RydWN0b3IoIG5hbWUsIGdyb3VwTm9kZSApIHtcclxuXHJcblx0XHRzdXBlciggbmFtZSApO1xyXG5cclxuXHRcdHRoaXMuaWQgPSBfaWQgKys7XHJcblx0XHR0aGlzLmdyb3VwTm9kZSA9IGdyb3VwTm9kZTtcclxuXHJcblx0XHR0aGlzLmlzTm9kZVVuaWZvcm1zR3JvdXAgPSB0cnVlO1xyXG5cclxuXHR9XHJcblxyXG5cdGdldE5vZGVzKCkge1xyXG5cclxuXHRcdGNvbnN0IG5vZGVzID0gW107XHJcblxyXG5cdFx0Zm9yICggY29uc3QgdW5pZm9ybSBvZiB0aGlzLnVuaWZvcm1zICkge1xyXG5cclxuXHRcdFx0Y29uc3Qgbm9kZSA9IHVuaWZvcm0ubm9kZVVuaWZvcm0ubm9kZTtcclxuXHJcblx0XHRcdGlmICggISBub2RlICkgdGhyb3cgbmV3IEVycm9yKCAnTm9kZVVuaWZvcm1zR3JvdXA6IFVuaWZvcm0gaGFzIG5vIG5vZGUuJyApO1xyXG5cclxuXHRcdFx0bm9kZXMucHVzaCggbm9kZSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gbm9kZXM7XHJcblxyXG5cdH1cclxuXHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IE5vZGVVbmlmb3Jtc0dyb3VwO1xyXG4iLCJpbXBvcnQgQmluZGluZyBmcm9tICcuL0JpbmRpbmcuanMnO1xyXG5cclxubGV0IF9pZCA9IDA7XHJcblxyXG5jbGFzcyBTYW1wbGVkVGV4dHVyZSBleHRlbmRzIEJpbmRpbmcge1xyXG5cclxuXHRjb25zdHJ1Y3RvciggbmFtZSwgdGV4dHVyZSApIHtcclxuXHJcblx0XHRzdXBlciggbmFtZSApO1xyXG5cclxuXHRcdHRoaXMuaWQgPSBfaWQgKys7XHJcblxyXG5cdFx0dGhpcy50ZXh0dXJlID0gdGV4dHVyZTtcclxuXHRcdHRoaXMudmVyc2lvbiA9IHRleHR1cmUgPyB0ZXh0dXJlLnZlcnNpb24gOiAwO1xyXG5cdFx0dGhpcy5zdG9yZSA9IGZhbHNlO1xyXG5cdFx0dGhpcy5nZW5lcmF0aW9uID0gbnVsbDtcclxuXHJcblx0XHR0aGlzLmlzU2FtcGxlZFRleHR1cmUgPSB0cnVlO1xyXG5cclxuXHR9XHJcblxyXG5cdG5lZWRzQmluZGluZ3NVcGRhdGUoIGdlbmVyYXRpb24gKSB7XHJcblxyXG5cdFx0Y29uc3QgeyB0ZXh0dXJlIH0gPSB0aGlzO1xyXG5cclxuXHRcdGlmICggZ2VuZXJhdGlvbiAhPT0gdGhpcy5nZW5lcmF0aW9uICkge1xyXG5cclxuXHRcdFx0dGhpcy5nZW5lcmF0aW9uID0gZ2VuZXJhdGlvbjtcclxuXHJcblx0XHRcdHJldHVybiB0cnVlO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGV4dHVyZS5pc1ZpZGVvVGV4dHVyZTtcclxuXHJcblx0fVxyXG5cclxuXHR1cGRhdGUoKSB7XHJcblxyXG5cdFx0Y29uc3QgeyB0ZXh0dXJlLCB2ZXJzaW9uIH0gPSB0aGlzO1xyXG5cclxuXHRcdGlmICggdmVyc2lvbiAhPT0gdGV4dHVyZS52ZXJzaW9uICkge1xyXG5cclxuXHRcdFx0dGhpcy52ZXJzaW9uID0gdGV4dHVyZS52ZXJzaW9uO1xyXG5cclxuXHRcdFx0cmV0dXJuIHRydWU7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBmYWxzZTtcclxuXHJcblx0fVxyXG5cclxufVxyXG5cclxuY2xhc3MgU2FtcGxlZEFycmF5VGV4dHVyZSBleHRlbmRzIFNhbXBsZWRUZXh0dXJlIHtcclxuXHJcblx0Y29uc3RydWN0b3IoIG5hbWUsIHRleHR1cmUgKSB7XHJcblxyXG5cdFx0c3VwZXIoIG5hbWUsIHRleHR1cmUgKTtcclxuXHJcblx0XHR0aGlzLmlzU2FtcGxlZEFycmF5VGV4dHVyZSA9IHRydWU7XHJcblxyXG5cdH1cclxuXHJcbn1cclxuXHJcbmNsYXNzIFNhbXBsZWQzRFRleHR1cmUgZXh0ZW5kcyBTYW1wbGVkVGV4dHVyZSB7XHJcblxyXG5cdGNvbnN0cnVjdG9yKCBuYW1lLCB0ZXh0dXJlICkge1xyXG5cclxuXHRcdHN1cGVyKCBuYW1lLCB0ZXh0dXJlICk7XHJcblxyXG5cdFx0dGhpcy5pc1NhbXBsZWQzRFRleHR1cmUgPSB0cnVlO1xyXG5cclxuXHR9XHJcblxyXG59XHJcblxyXG5jbGFzcyBTYW1wbGVkQ3ViZVRleHR1cmUgZXh0ZW5kcyBTYW1wbGVkVGV4dHVyZSB7XHJcblxyXG5cdGNvbnN0cnVjdG9yKCBuYW1lLCB0ZXh0dXJlICkge1xyXG5cclxuXHRcdHN1cGVyKCBuYW1lLCB0ZXh0dXJlICk7XHJcblxyXG5cdFx0dGhpcy5pc1NhbXBsZWRDdWJlVGV4dHVyZSA9IHRydWU7XHJcblxyXG5cdH1cclxuXHJcbn1cclxuXHJcbmV4cG9ydCB7IFNhbXBsZWRUZXh0dXJlLCBTYW1wbGVkQXJyYXlUZXh0dXJlLCBTYW1wbGVkM0RUZXh0dXJlLCBTYW1wbGVkQ3ViZVRleHR1cmUgfTtcclxuIiwiaW1wb3J0IHsgU2FtcGxlZFRleHR1cmUgfSBmcm9tICcuLi9TYW1wbGVkVGV4dHVyZS5qcyc7XHJcblxyXG5jbGFzcyBOb2RlU2FtcGxlZFRleHR1cmUgZXh0ZW5kcyBTYW1wbGVkVGV4dHVyZSB7XHJcblxyXG5cdGNvbnN0cnVjdG9yKCBuYW1lLCB0ZXh0dXJlTm9kZSwgZ3JvdXBOb2RlLCBhY2Nlc3MgPSBudWxsICkge1xyXG5cclxuXHRcdHN1cGVyKCBuYW1lLCB0ZXh0dXJlTm9kZSA/IHRleHR1cmVOb2RlLnZhbHVlIDogbnVsbCApO1xyXG5cclxuXHRcdHRoaXMudGV4dHVyZU5vZGUgPSB0ZXh0dXJlTm9kZTtcclxuXHRcdHRoaXMuZ3JvdXBOb2RlID0gZ3JvdXBOb2RlO1xyXG5cclxuXHRcdHRoaXMuYWNjZXNzID0gYWNjZXNzO1xyXG5cclxuXHR9XHJcblxyXG5cdG5lZWRzQmluZGluZ3NVcGRhdGUoIGdlbmVyYXRpb24gKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMudGV4dHVyZU5vZGUudmFsdWUgIT09IHRoaXMudGV4dHVyZSB8fCBzdXBlci5uZWVkc0JpbmRpbmdzVXBkYXRlKCBnZW5lcmF0aW9uICk7XHJcblxyXG5cdH1cclxuXHJcblx0dXBkYXRlKCkge1xyXG5cclxuXHRcdGNvbnN0IHsgdGV4dHVyZU5vZGUgfSA9IHRoaXM7XHJcblxyXG5cdFx0aWYgKCB0aGlzLnRleHR1cmUgIT09IHRleHR1cmVOb2RlLnZhbHVlICkge1xyXG5cclxuXHRcdFx0dGhpcy50ZXh0dXJlID0gdGV4dHVyZU5vZGUudmFsdWU7XHJcblxyXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHN1cGVyLnVwZGF0ZSgpO1xyXG5cclxuXHR9XHJcblxyXG59XHJcblxyXG5jbGFzcyBOb2RlU2FtcGxlZEN1YmVUZXh0dXJlIGV4dGVuZHMgTm9kZVNhbXBsZWRUZXh0dXJlIHtcclxuXHJcblx0Y29uc3RydWN0b3IoIG5hbWUsIHRleHR1cmVOb2RlLCBncm91cE5vZGUsIGFjY2VzcyApIHtcclxuXHJcblx0XHRzdXBlciggbmFtZSwgdGV4dHVyZU5vZGUsIGdyb3VwTm9kZSwgYWNjZXNzICk7XHJcblxyXG5cdFx0dGhpcy5pc1NhbXBsZWRDdWJlVGV4dHVyZSA9IHRydWU7XHJcblxyXG5cdH1cclxuXHJcbn1cclxuXHJcbmNsYXNzIE5vZGVTYW1wbGVkVGV4dHVyZTNEIGV4dGVuZHMgTm9kZVNhbXBsZWRUZXh0dXJlIHtcclxuXHJcblx0Y29uc3RydWN0b3IoIG5hbWUsIHRleHR1cmVOb2RlLCBncm91cE5vZGUsIGFjY2VzcyApIHtcclxuXHJcblx0XHRzdXBlciggbmFtZSwgdGV4dHVyZU5vZGUsIGdyb3VwTm9kZSwgYWNjZXNzICk7XHJcblxyXG5cdFx0dGhpcy5pc1NhbXBsZWRUZXh0dXJlM0QgPSB0cnVlO1xyXG5cclxuXHR9XHJcblxyXG59XHJcblxyXG5leHBvcnQgeyBOb2RlU2FtcGxlZFRleHR1cmUsIE5vZGVTYW1wbGVkQ3ViZVRleHR1cmUsIE5vZGVTYW1wbGVkVGV4dHVyZTNEIH07XHJcbiIsImltcG9ydCB7IEdMU0xOb2RlUGFyc2VyLCBOb2RlQnVpbGRlciwgVGV4dHVyZU5vZGUsIHZlY3RvckNvbXBvbmVudHMgfSBmcm9tICcuLi8uLi8uLi9ub2Rlcy9Ob2Rlcy5qcyc7XHJcblxyXG5pbXBvcnQgTm9kZVVuaWZvcm1CdWZmZXIgZnJvbSAnLi4vLi4vY29tbW9uL25vZGVzL05vZGVVbmlmb3JtQnVmZmVyLmpzJztcclxuaW1wb3J0IE5vZGVVbmlmb3Jtc0dyb3VwIGZyb20gJy4uLy4uL2NvbW1vbi9ub2Rlcy9Ob2RlVW5pZm9ybXNHcm91cC5qcyc7XHJcblxyXG5pbXBvcnQgeyBOb2RlU2FtcGxlZFRleHR1cmUsIE5vZGVTYW1wbGVkQ3ViZVRleHR1cmUsIE5vZGVTYW1wbGVkVGV4dHVyZTNEIH0gZnJvbSAnLi4vLi4vY29tbW9uL25vZGVzL05vZGVTYW1wbGVkVGV4dHVyZS5qcyc7XHJcblxyXG5pbXBvcnQgeyBOb0NvbG9yU3BhY2UsIEJ5dGVUeXBlLCBTaG9ydFR5cGUsIFJHQkFJbnRlZ2VyRm9ybWF0LCBSR0JJbnRlZ2VyRm9ybWF0LCBSZWRJbnRlZ2VyRm9ybWF0LCBSR0ludGVnZXJGb3JtYXQsIFVuc2lnbmVkQnl0ZVR5cGUsIFVuc2lnbmVkSW50VHlwZSwgVW5zaWduZWRTaG9ydFR5cGUsIFJlZEZvcm1hdCwgUkdGb3JtYXQsIEludFR5cGUsIFJHQkZvcm1hdCwgUkdCQUZvcm1hdCwgRmxvYXRUeXBlIH0gZnJvbSAnLi4vLi4vLi4vY29uc3RhbnRzLmpzJztcclxuaW1wb3J0IHsgRGF0YVRleHR1cmUgfSBmcm9tICcuLi8uLi8uLi90ZXh0dXJlcy9EYXRhVGV4dHVyZS5qcyc7XHJcblxyXG5jb25zdCBnbHNsTWV0aG9kcyA9IHtcclxuXHRhdGFuMjogJ2F0YW4nLFxyXG5cdHRleHR1cmVEaW1lbnNpb25zOiAndGV4dHVyZVNpemUnLFxyXG5cdGVxdWFsczogJ2VxdWFsJ1xyXG59O1xyXG5cclxuY29uc3QgcHJlY2lzaW9uTGliID0ge1xyXG5cdGxvdzogJ2xvd3AnLFxyXG5cdG1lZGl1bTogJ21lZGl1bXAnLFxyXG5cdGhpZ2g6ICdoaWdocCdcclxufTtcclxuXHJcbmNvbnN0IHN1cHBvcnRzID0ge1xyXG5cdHN3aXp6bGVBc3NpZ246IHRydWUsXHJcblx0c3RvcmFnZUJ1ZmZlcjogZmFsc2VcclxufTtcclxuXHJcbmNvbnN0IGRlZmF1bHRQcmVjaXNpb25zID0gYFxyXG5wcmVjaXNpb24gaGlnaHAgZmxvYXQ7XHJcbnByZWNpc2lvbiBoaWdocCBpbnQ7XHJcbnByZWNpc2lvbiBoaWdocCBzYW1wbGVyMkQ7XHJcbnByZWNpc2lvbiBoaWdocCBzYW1wbGVyM0Q7XHJcbnByZWNpc2lvbiBoaWdocCBzYW1wbGVyQ3ViZTtcclxucHJlY2lzaW9uIGhpZ2hwIHNhbXBsZXIyREFycmF5O1xyXG5cclxucHJlY2lzaW9uIGhpZ2hwIHVzYW1wbGVyMkQ7XHJcbnByZWNpc2lvbiBoaWdocCB1c2FtcGxlcjNEO1xyXG5wcmVjaXNpb24gaGlnaHAgdXNhbXBsZXJDdWJlO1xyXG5wcmVjaXNpb24gaGlnaHAgdXNhbXBsZXIyREFycmF5O1xyXG5cclxucHJlY2lzaW9uIGhpZ2hwIGlzYW1wbGVyMkQ7XHJcbnByZWNpc2lvbiBoaWdocCBpc2FtcGxlcjNEO1xyXG5wcmVjaXNpb24gaGlnaHAgaXNhbXBsZXJDdWJlO1xyXG5wcmVjaXNpb24gaGlnaHAgaXNhbXBsZXIyREFycmF5O1xyXG5cclxucHJlY2lzaW9uIGxvd3Agc2FtcGxlcjJEU2hhZG93O1xyXG5gO1xyXG5cclxuY2xhc3MgR0xTTE5vZGVCdWlsZGVyIGV4dGVuZHMgTm9kZUJ1aWxkZXIge1xyXG5cclxuXHRjb25zdHJ1Y3Rvciggb2JqZWN0LCByZW5kZXJlciApIHtcclxuXHJcblx0XHRzdXBlciggb2JqZWN0LCByZW5kZXJlciwgbmV3IEdMU0xOb2RlUGFyc2VyKCkgKTtcclxuXHJcblx0XHR0aGlzLnVuaWZvcm1Hcm91cHMgPSB7fTtcclxuXHRcdHRoaXMudHJhbnNmb3JtcyA9IFtdO1xyXG5cdFx0dGhpcy5leHRlbnNpb25zID0ge307XHJcblx0XHR0aGlzLmJ1aWx0aW5zID0geyB2ZXJ0ZXg6IFtdLCBmcmFnbWVudDogW10sIGNvbXB1dGU6IFtdIH07XHJcblxyXG5cdFx0dGhpcy51c2VDb21wYXJpc29uTWV0aG9kID0gdHJ1ZTtcclxuXHJcblx0fVxyXG5cclxuXHRuZWVkc1RvV29ya2luZ0NvbG9yU3BhY2UoIHRleHR1cmUgKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRleHR1cmUuaXNWaWRlb1RleHR1cmUgPT09IHRydWUgJiYgdGV4dHVyZS5jb2xvclNwYWNlICE9PSBOb0NvbG9yU3BhY2U7XHJcblxyXG5cdH1cclxuXHJcblx0Z2V0TWV0aG9kKCBtZXRob2QgKSB7XHJcblxyXG5cdFx0cmV0dXJuIGdsc2xNZXRob2RzWyBtZXRob2QgXSB8fCBtZXRob2Q7XHJcblxyXG5cdH1cclxuXHJcblx0Z2V0T3V0cHV0U3RydWN0TmFtZSgpIHtcclxuXHJcblx0XHRyZXR1cm4gJyc7XHJcblxyXG5cdH1cclxuXHJcblx0YnVpbGRGdW5jdGlvbkNvZGUoIHNoYWRlck5vZGUgKSB7XHJcblxyXG5cdFx0Y29uc3QgbGF5b3V0ID0gc2hhZGVyTm9kZS5sYXlvdXQ7XHJcblx0XHRjb25zdCBmbG93RGF0YSA9IHRoaXMuZmxvd1NoYWRlck5vZGUoIHNoYWRlck5vZGUgKTtcclxuXHJcblx0XHRjb25zdCBwYXJhbWV0ZXJzID0gW107XHJcblxyXG5cdFx0Zm9yICggY29uc3QgaW5wdXQgb2YgbGF5b3V0LmlucHV0cyApIHtcclxuXHJcblx0XHRcdHBhcmFtZXRlcnMucHVzaCggdGhpcy5nZXRUeXBlKCBpbnB1dC50eXBlICkgKyAnICcgKyBpbnB1dC5uYW1lICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vXHJcblxyXG5cdFx0Y29uc3QgY29kZSA9IGAkeyB0aGlzLmdldFR5cGUoIGxheW91dC50eXBlICkgfSAkeyBsYXlvdXQubmFtZSB9KCAkeyBwYXJhbWV0ZXJzLmpvaW4oICcsICcgKSB9ICkge1xyXG5cclxuXHQkeyBmbG93RGF0YS52YXJzIH1cclxuXHJcbiR7IGZsb3dEYXRhLmNvZGUgfVxyXG5cdHJldHVybiAkeyBmbG93RGF0YS5yZXN1bHQgfTtcclxuXHJcbn1gO1xyXG5cclxuXHRcdC8vXHJcblxyXG5cdFx0cmV0dXJuIGNvZGU7XHJcblxyXG5cdH1cclxuXHJcblx0c2V0dXBQQk8oIHN0b3JhZ2VCdWZmZXJOb2RlICkge1xyXG5cclxuXHRcdGNvbnN0IGF0dHJpYnV0ZSA9IHN0b3JhZ2VCdWZmZXJOb2RlLnZhbHVlO1xyXG5cclxuXHRcdGlmICggYXR0cmlidXRlLnBibyA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0Y29uc3Qgb3JpZ2luYWxBcnJheSA9IGF0dHJpYnV0ZS5hcnJheTtcclxuXHRcdFx0Y29uc3QgbnVtRWxlbWVudHMgPSBhdHRyaWJ1dGUuY291bnQgKiBhdHRyaWJ1dGUuaXRlbVNpemU7XHJcblxyXG5cdFx0XHRjb25zdCB7IGl0ZW1TaXplIH0gPSBhdHRyaWJ1dGU7XHJcblxyXG5cdFx0XHRjb25zdCBpc0ludGVnZXIgPSBhdHRyaWJ1dGUuYXJyYXkuY29uc3RydWN0b3IubmFtZS50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKCAnaW50JyApO1xyXG5cclxuXHRcdFx0bGV0IGZvcm1hdCA9IGlzSW50ZWdlciA/IFJlZEludGVnZXJGb3JtYXQgOiBSZWRGb3JtYXQ7XHJcblxyXG5cdFx0XHRpZiAoIGl0ZW1TaXplID09PSAyICkge1xyXG5cclxuXHRcdFx0XHRmb3JtYXQgPSBpc0ludGVnZXIgPyBSR0ludGVnZXJGb3JtYXQgOiBSR0Zvcm1hdDtcclxuXHJcblx0XHRcdH0gZWxzZSBpZiAoIGl0ZW1TaXplID09PSAzICkge1xyXG5cclxuXHRcdFx0XHRmb3JtYXQgPSBpc0ludGVnZXIgPyBSR0JJbnRlZ2VyRm9ybWF0IDogUkdCRm9ybWF0O1xyXG5cclxuXHRcdFx0fSBlbHNlIGlmICggaXRlbVNpemUgPT09IDQgKSB7XHJcblxyXG5cdFx0XHRcdGZvcm1hdCA9IGlzSW50ZWdlciA/IFJHQkFJbnRlZ2VyRm9ybWF0IDogUkdCQUZvcm1hdDtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGNvbnN0IHR5cGVNYXAgPSB7XHJcblx0XHRcdFx0RmxvYXQzMkFycmF5OiBGbG9hdFR5cGUsXHJcblx0XHRcdFx0VWludDhBcnJheTogVW5zaWduZWRCeXRlVHlwZSxcclxuXHRcdFx0XHRVaW50MTZBcnJheTogVW5zaWduZWRTaG9ydFR5cGUsXHJcblx0XHRcdFx0VWludDMyQXJyYXk6IFVuc2lnbmVkSW50VHlwZSxcclxuXHRcdFx0XHRJbnQ4QXJyYXk6IEJ5dGVUeXBlLFxyXG5cdFx0XHRcdEludDE2QXJyYXk6IFNob3J0VHlwZSxcclxuXHRcdFx0XHRJbnQzMkFycmF5OiBJbnRUeXBlLFxyXG5cdFx0XHRcdFVpbnQ4Q2xhbXBlZEFycmF5OiBVbnNpZ25lZEJ5dGVUeXBlLFxyXG5cdFx0XHR9O1xyXG5cclxuXHRcdFx0Y29uc3Qgd2lkdGggPSBNYXRoLnBvdyggMiwgTWF0aC5jZWlsKCBNYXRoLmxvZzIoIE1hdGguc3FydCggbnVtRWxlbWVudHMgLyBpdGVtU2l6ZSApICkgKSApO1xyXG5cdFx0XHRsZXQgaGVpZ2h0ID0gTWF0aC5jZWlsKCAoIG51bUVsZW1lbnRzIC8gaXRlbVNpemUgKSAvIHdpZHRoICk7XHJcblx0XHRcdGlmICggd2lkdGggKiBoZWlnaHQgKiBpdGVtU2l6ZSA8IG51bUVsZW1lbnRzICkgaGVpZ2h0ICsrOyAvLyBFbnN1cmUgZW5vdWdoIHNwYWNlXHJcblxyXG5cdFx0XHRjb25zdCBuZXdTaXplID0gd2lkdGggKiBoZWlnaHQgKiBpdGVtU2l6ZTtcclxuXHJcblx0XHRcdGNvbnN0IG5ld0FycmF5ID0gbmV3IG9yaWdpbmFsQXJyYXkuY29uc3RydWN0b3IoIG5ld1NpemUgKTtcclxuXHJcblx0XHRcdG5ld0FycmF5LnNldCggb3JpZ2luYWxBcnJheSwgMCApO1xyXG5cclxuXHRcdFx0YXR0cmlidXRlLmFycmF5ID0gbmV3QXJyYXk7XHJcblxyXG5cdFx0XHRjb25zdCBwYm9UZXh0dXJlID0gbmV3IERhdGFUZXh0dXJlKCBhdHRyaWJ1dGUuYXJyYXksIHdpZHRoLCBoZWlnaHQsIGZvcm1hdCwgdHlwZU1hcFsgYXR0cmlidXRlLmFycmF5LmNvbnN0cnVjdG9yLm5hbWUgXSB8fCBGbG9hdFR5cGUgKTtcclxuXHRcdFx0cGJvVGV4dHVyZS5uZWVkc1VwZGF0ZSA9IHRydWU7XHJcblx0XHRcdHBib1RleHR1cmUuaXNQQk9UZXh0dXJlID0gdHJ1ZTtcclxuXHJcblx0XHRcdGNvbnN0IHBibyA9IG5ldyBUZXh0dXJlTm9kZSggcGJvVGV4dHVyZSwgbnVsbCwgbnVsbCApO1xyXG5cdFx0XHRwYm8uc2V0UHJlY2lzaW9uKCAnaGlnaCcgKTtcclxuXHJcblx0XHRcdGF0dHJpYnV0ZS5wYm9Ob2RlID0gcGJvO1xyXG5cdFx0XHRhdHRyaWJ1dGUucGJvID0gcGJvLnZhbHVlO1xyXG5cclxuXHRcdFx0dGhpcy5nZXRVbmlmb3JtRnJvbU5vZGUoIGF0dHJpYnV0ZS5wYm9Ob2RlLCAndGV4dHVyZScsIHRoaXMuc2hhZGVyU3RhZ2UsIHRoaXMuY29udGV4dC5sYWJlbCApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHRnZXRQcm9wZXJ0eU5hbWUoIG5vZGUsIHNoYWRlclN0YWdlID0gdGhpcy5zaGFkZXJTdGFnZSApIHtcclxuXHJcblx0XHRpZiAoIG5vZGUuaXNOb2RlVW5pZm9ybSAmJiBub2RlLm5vZGUuaXNUZXh0dXJlTm9kZSAhPT0gdHJ1ZSAmJiBub2RlLm5vZGUuaXNCdWZmZXJOb2RlICE9PSB0cnVlICkge1xyXG5cclxuXHRcdFx0cmV0dXJuIHNoYWRlclN0YWdlLmNoYXJBdCggMCApICsgJ18nICsgbm9kZS5uYW1lO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gc3VwZXIuZ2V0UHJvcGVydHlOYW1lKCBub2RlLCBzaGFkZXJTdGFnZSApO1xyXG5cclxuXHR9XHJcblxyXG5cdGdlbmVyYXRlUEJPKCBzdG9yYWdlQXJyYXlFbGVtZW50Tm9kZSApIHtcclxuXHJcblx0XHRjb25zdCB7IG5vZGUsIGluZGV4Tm9kZSB9ID0gc3RvcmFnZUFycmF5RWxlbWVudE5vZGU7XHJcblx0XHRjb25zdCBhdHRyaWJ1dGUgPSBub2RlLnZhbHVlO1xyXG5cclxuXHRcdGlmICggdGhpcy5yZW5kZXJlci5iYWNrZW5kLmhhcyggYXR0cmlidXRlICkgKSB7XHJcblxyXG5cdFx0XHRjb25zdCBhdHRyaWJ1dGVEYXRhID0gdGhpcy5yZW5kZXJlci5iYWNrZW5kLmdldCggYXR0cmlidXRlICk7XHJcblx0XHRcdGF0dHJpYnV0ZURhdGEucGJvID0gYXR0cmlidXRlLnBibztcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Y29uc3Qgbm9kZVVuaWZvcm0gPSB0aGlzLmdldFVuaWZvcm1Gcm9tTm9kZSggYXR0cmlidXRlLnBib05vZGUsICd0ZXh0dXJlJywgdGhpcy5zaGFkZXJTdGFnZSwgdGhpcy5jb250ZXh0LmxhYmVsICk7XHJcblx0XHRjb25zdCB0ZXh0dXJlTmFtZSA9IHRoaXMuZ2V0UHJvcGVydHlOYW1lKCBub2RlVW5pZm9ybSApO1xyXG5cclxuXHRcdHRoaXMuaW5jcmVhc2VVc2FnZSggaW5kZXhOb2RlICk7IC8vIGZvcmNlIGNhY2hlIGdlbmVyYXRlIHRvIGJlIHVzZWQgYXMgaW5kZXggaW4geCx5XHJcblx0XHRjb25zdCBpbmRleFNuaXBwZXQgPSBpbmRleE5vZGUuYnVpbGQoIHRoaXMsICd1aW50JyApO1xyXG5cclxuXHRcdGNvbnN0IGVsZW1lbnROb2RlRGF0YSA9IHRoaXMuZ2V0RGF0YUZyb21Ob2RlKCBzdG9yYWdlQXJyYXlFbGVtZW50Tm9kZSApO1xyXG5cclxuXHRcdGxldCBwcm9wZXJ0eU5hbWUgPSBlbGVtZW50Tm9kZURhdGEucHJvcGVydHlOYW1lO1xyXG5cclxuXHRcdGlmICggcHJvcGVydHlOYW1lID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHQvLyBwcm9wZXJ0eSBlbGVtZW50XHJcblxyXG5cdFx0XHRjb25zdCBub2RlVmFyID0gdGhpcy5nZXRWYXJGcm9tTm9kZSggc3RvcmFnZUFycmF5RWxlbWVudE5vZGUgKTtcclxuXHJcblx0XHRcdHByb3BlcnR5TmFtZSA9IHRoaXMuZ2V0UHJvcGVydHlOYW1lKCBub2RlVmFyICk7XHJcblxyXG5cdFx0XHQvLyBwcm9wZXJ0eSBzaXplXHJcblxyXG5cdFx0XHRjb25zdCBidWZmZXJOb2RlRGF0YSA9IHRoaXMuZ2V0RGF0YUZyb21Ob2RlKCBub2RlICk7XHJcblxyXG5cdFx0XHRsZXQgcHJvcGVydHlTaXplTmFtZSA9IGJ1ZmZlck5vZGVEYXRhLnByb3BlcnR5U2l6ZU5hbWU7XHJcblxyXG5cdFx0XHRpZiAoIHByb3BlcnR5U2l6ZU5hbWUgPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0cHJvcGVydHlTaXplTmFtZSA9IHByb3BlcnR5TmFtZSArICdTaXplJztcclxuXHJcblx0XHRcdFx0dGhpcy5nZXRWYXJGcm9tTm9kZSggbm9kZSwgcHJvcGVydHlTaXplTmFtZSwgJ3VpbnQnICk7XHJcblxyXG5cdFx0XHRcdHRoaXMuYWRkTGluZUZsb3dDb2RlKCBgJHsgcHJvcGVydHlTaXplTmFtZSB9ID0gdWludCggdGV4dHVyZVNpemUoICR7IHRleHR1cmVOYW1lIH0sIDAgKS54IClgLCBzdG9yYWdlQXJyYXlFbGVtZW50Tm9kZSApO1xyXG5cclxuXHRcdFx0XHRidWZmZXJOb2RlRGF0YS5wcm9wZXJ0eVNpemVOYW1lID0gcHJvcGVydHlTaXplTmFtZTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vXHJcblxyXG5cdFx0XHRjb25zdCB7IGl0ZW1TaXplIH0gPSBhdHRyaWJ1dGU7XHJcblxyXG5cdFx0XHRjb25zdCBjaGFubmVsID0gJy4nICsgdmVjdG9yQ29tcG9uZW50cy5qb2luKCAnJyApLnNsaWNlKCAwLCBpdGVtU2l6ZSApO1xyXG5cdFx0XHRjb25zdCB1dlNuaXBwZXQgPSBgaXZlYzIoJHtpbmRleFNuaXBwZXR9ICUgJHsgcHJvcGVydHlTaXplTmFtZSB9LCAke2luZGV4U25pcHBldH0gLyAkeyBwcm9wZXJ0eVNpemVOYW1lIH0pYDtcclxuXHJcblx0XHRcdGNvbnN0IHNuaXBwZXQgPSB0aGlzLmdlbmVyYXRlVGV4dHVyZUxvYWQoIG51bGwsIHRleHR1cmVOYW1lLCB1dlNuaXBwZXQsIG51bGwsICcwJyApO1xyXG5cclxuXHRcdFx0Ly9cclxuXHJcblxyXG5cdFx0XHRsZXQgcHJlZml4ID0gJ3ZlYzQnO1xyXG5cclxuXHRcdFx0aWYgKCBhdHRyaWJ1dGUucGJvLnR5cGUgPT09IFVuc2lnbmVkSW50VHlwZSApIHtcclxuXHJcblx0XHRcdFx0cHJlZml4ID0gJ3V2ZWM0JztcclxuXHJcblx0XHRcdH0gZWxzZSBpZiAoIGF0dHJpYnV0ZS5wYm8udHlwZSA9PT0gSW50VHlwZSApIHtcclxuXHJcblx0XHRcdFx0cHJlZml4ID0gJ2l2ZWM0JztcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHRoaXMuYWRkTGluZUZsb3dDb2RlKCBgJHsgcHJvcGVydHlOYW1lIH0gPSAke3ByZWZpeH0oJHsgc25pcHBldCB9KSR7Y2hhbm5lbH1gLCBzdG9yYWdlQXJyYXlFbGVtZW50Tm9kZSApO1xyXG5cclxuXHRcdFx0ZWxlbWVudE5vZGVEYXRhLnByb3BlcnR5TmFtZSA9IHByb3BlcnR5TmFtZTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHByb3BlcnR5TmFtZTtcclxuXHJcblx0fVxyXG5cclxuXHRnZW5lcmF0ZVRleHR1cmVMb2FkKCB0ZXh0dXJlLCB0ZXh0dXJlUHJvcGVydHksIHV2SW5kZXhTbmlwcGV0LCBkZXB0aFNuaXBwZXQsIGxldmVsU25pcHBldCA9ICcwJyApIHtcclxuXHJcblx0XHRpZiAoIGRlcHRoU25pcHBldCApIHtcclxuXHJcblx0XHRcdHJldHVybiBgdGV4ZWxGZXRjaCggJHsgdGV4dHVyZVByb3BlcnR5IH0sIGl2ZWMzKCAkeyB1dkluZGV4U25pcHBldCB9LCAkeyBkZXB0aFNuaXBwZXQgfSApLCAkeyBsZXZlbFNuaXBwZXQgfSApYDtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0cmV0dXJuIGB0ZXhlbEZldGNoKCAkeyB0ZXh0dXJlUHJvcGVydHkgfSwgJHsgdXZJbmRleFNuaXBwZXQgfSwgJHsgbGV2ZWxTbmlwcGV0IH0gKWA7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdGdlbmVyYXRlVGV4dHVyZSggdGV4dHVyZSwgdGV4dHVyZVByb3BlcnR5LCB1dlNuaXBwZXQsIGRlcHRoU25pcHBldCApIHtcclxuXHJcblx0XHRpZiAoIHRleHR1cmUuaXNEZXB0aFRleHR1cmUgKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gYHRleHR1cmUoICR7IHRleHR1cmVQcm9wZXJ0eSB9LCAkeyB1dlNuaXBwZXQgfSApLnhgO1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRpZiAoIGRlcHRoU25pcHBldCApIHV2U25pcHBldCA9IGB2ZWMzKCAkeyB1dlNuaXBwZXQgfSwgJHsgZGVwdGhTbmlwcGV0IH0gKWA7XHJcblxyXG5cdFx0XHRyZXR1cm4gYHRleHR1cmUoICR7IHRleHR1cmVQcm9wZXJ0eSB9LCAkeyB1dlNuaXBwZXQgfSApYDtcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0Z2VuZXJhdGVUZXh0dXJlTGV2ZWwoIHRleHR1cmUsIHRleHR1cmVQcm9wZXJ0eSwgdXZTbmlwcGV0LCBsZXZlbFNuaXBwZXQgKSB7XHJcblxyXG5cdFx0cmV0dXJuIGB0ZXh0dXJlTG9kKCAkeyB0ZXh0dXJlUHJvcGVydHkgfSwgJHsgdXZTbmlwcGV0IH0sICR7IGxldmVsU25pcHBldCB9IClgO1xyXG5cclxuXHR9XHJcblxyXG5cdGdlbmVyYXRlVGV4dHVyZUJpYXMoIHRleHR1cmUsIHRleHR1cmVQcm9wZXJ0eSwgdXZTbmlwcGV0LCBiaWFzU25pcHBldCApIHtcclxuXHJcblx0XHRyZXR1cm4gYHRleHR1cmUoICR7IHRleHR1cmVQcm9wZXJ0eSB9LCAkeyB1dlNuaXBwZXQgfSwgJHsgYmlhc1NuaXBwZXQgfSApYDtcclxuXHJcblx0fVxyXG5cclxuXHRnZW5lcmF0ZVRleHR1cmVHcmFkKCB0ZXh0dXJlLCB0ZXh0dXJlUHJvcGVydHksIHV2U25pcHBldCwgZ3JhZFNuaXBwZXQgKSB7XHJcblxyXG5cdFx0cmV0dXJuIGB0ZXh0dXJlR3JhZCggJHsgdGV4dHVyZVByb3BlcnR5IH0sICR7IHV2U25pcHBldCB9LCAkeyBncmFkU25pcHBldFsgMCBdIH0sICR7IGdyYWRTbmlwcGV0WyAxIF0gfSApYDtcclxuXHJcblx0fVxyXG5cclxuXHRnZW5lcmF0ZVRleHR1cmVDb21wYXJlKCB0ZXh0dXJlLCB0ZXh0dXJlUHJvcGVydHksIHV2U25pcHBldCwgY29tcGFyZVNuaXBwZXQsIGRlcHRoU25pcHBldCwgc2hhZGVyU3RhZ2UgPSB0aGlzLnNoYWRlclN0YWdlICkge1xyXG5cclxuXHRcdGlmICggc2hhZGVyU3RhZ2UgPT09ICdmcmFnbWVudCcgKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gYHRleHR1cmUoICR7IHRleHR1cmVQcm9wZXJ0eSB9LCB2ZWMzKCAkeyB1dlNuaXBwZXQgfSwgJHsgY29tcGFyZVNuaXBwZXQgfSApIClgO1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRjb25zb2xlLmVycm9yKCBgV2ViR1BVUmVuZGVyZXI6IFRIUkVFLkRlcHRoVGV4dHVyZS5jb21wYXJlRnVuY3Rpb24oKSBkb2VzIG5vdCBzdXBwb3J0ICR7IHNoYWRlclN0YWdlIH0gc2hhZGVyLmAgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0Z2V0VmFycyggc2hhZGVyU3RhZ2UgKSB7XHJcblxyXG5cdFx0Y29uc3Qgc25pcHBldHMgPSBbXTtcclxuXHJcblx0XHRjb25zdCB2YXJzID0gdGhpcy52YXJzWyBzaGFkZXJTdGFnZSBdO1xyXG5cclxuXHRcdGlmICggdmFycyAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0Zm9yICggY29uc3QgdmFyaWFibGUgb2YgdmFycyApIHtcclxuXHJcblx0XHRcdFx0c25pcHBldHMucHVzaCggYCR7IHRoaXMuZ2V0VmFyKCB2YXJpYWJsZS50eXBlLCB2YXJpYWJsZS5uYW1lICkgfTtgICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBzbmlwcGV0cy5qb2luKCAnXFxuXFx0JyApO1xyXG5cclxuXHR9XHJcblxyXG5cdGdldFVuaWZvcm1zKCBzaGFkZXJTdGFnZSApIHtcclxuXHJcblx0XHRjb25zdCB1bmlmb3JtcyA9IHRoaXMudW5pZm9ybXNbIHNoYWRlclN0YWdlIF07XHJcblxyXG5cdFx0Y29uc3QgYmluZGluZ1NuaXBwZXRzID0gW107XHJcblx0XHRjb25zdCB1bmlmb3JtR3JvdXBzID0ge307XHJcblxyXG5cdFx0Zm9yICggY29uc3QgdW5pZm9ybSBvZiB1bmlmb3JtcyApIHtcclxuXHJcblx0XHRcdGxldCBzbmlwcGV0ID0gbnVsbDtcclxuXHRcdFx0bGV0IGdyb3VwID0gZmFsc2U7XHJcblxyXG5cdFx0XHRpZiAoIHVuaWZvcm0udHlwZSA9PT0gJ3RleHR1cmUnICkge1xyXG5cclxuXHRcdFx0XHRjb25zdCB0ZXh0dXJlID0gdW5pZm9ybS5ub2RlLnZhbHVlO1xyXG5cclxuXHRcdFx0XHRsZXQgdHlwZVByZWZpeCA9ICcnO1xyXG5cclxuXHRcdFx0XHRpZiAoIHRleHR1cmUuaXNEYXRhVGV4dHVyZSA9PT0gdHJ1ZSApIHtcclxuXHJcblxyXG5cdFx0XHRcdFx0aWYgKCB0ZXh0dXJlLnR5cGUgPT09IFVuc2lnbmVkSW50VHlwZSApIHtcclxuXHJcblx0XHRcdFx0XHRcdHR5cGVQcmVmaXggPSAndSc7XHJcblxyXG5cdFx0XHRcdFx0fSBlbHNlIGlmICggdGV4dHVyZS50eXBlID09PSBJbnRUeXBlICkge1xyXG5cclxuXHRcdFx0XHRcdFx0dHlwZVByZWZpeCA9ICdpJztcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0aWYgKCB0ZXh0dXJlLmNvbXBhcmVGdW5jdGlvbiApIHtcclxuXHJcblx0XHRcdFx0XHRzbmlwcGV0ID0gYHNhbXBsZXIyRFNoYWRvdyAkeyB1bmlmb3JtLm5hbWUgfTtgO1xyXG5cclxuXHRcdFx0XHR9IGVsc2UgaWYgKCB0ZXh0dXJlLmlzRGF0YUFycmF5VGV4dHVyZSA9PT0gdHJ1ZSB8fCB0ZXh0dXJlLmlzQ29tcHJlc3NlZEFycmF5VGV4dHVyZSA9PT0gdHJ1ZSApIHtcclxuXHJcblx0XHRcdFx0XHRzbmlwcGV0ID0gYCR7dHlwZVByZWZpeH1zYW1wbGVyMkRBcnJheSAkeyB1bmlmb3JtLm5hbWUgfTtgO1xyXG5cclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdHNuaXBwZXQgPSBgJHt0eXBlUHJlZml4fXNhbXBsZXIyRCAkeyB1bmlmb3JtLm5hbWUgfTtgO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9IGVsc2UgaWYgKCB1bmlmb3JtLnR5cGUgPT09ICdjdWJlVGV4dHVyZScgKSB7XHJcblxyXG5cdFx0XHRcdHNuaXBwZXQgPSBgc2FtcGxlckN1YmUgJHsgdW5pZm9ybS5uYW1lIH07YDtcclxuXHJcblx0XHRcdH0gZWxzZSBpZiAoIHVuaWZvcm0udHlwZSA9PT0gJ3RleHR1cmUzRCcgKSB7XHJcblxyXG5cdFx0XHRcdHNuaXBwZXQgPSBgc2FtcGxlcjNEICR7IHVuaWZvcm0ubmFtZSB9O2A7XHJcblxyXG5cdFx0XHR9IGVsc2UgaWYgKCB1bmlmb3JtLnR5cGUgPT09ICdidWZmZXInICkge1xyXG5cclxuXHRcdFx0XHRjb25zdCBidWZmZXJOb2RlID0gdW5pZm9ybS5ub2RlO1xyXG5cdFx0XHRcdGNvbnN0IGJ1ZmZlclR5cGUgPSB0aGlzLmdldFR5cGUoIGJ1ZmZlck5vZGUuYnVmZmVyVHlwZSApO1xyXG5cdFx0XHRcdGNvbnN0IGJ1ZmZlckNvdW50ID0gYnVmZmVyTm9kZS5idWZmZXJDb3VudDtcclxuXHJcblx0XHRcdFx0Y29uc3QgYnVmZmVyQ291bnRTbmlwcGV0ID0gYnVmZmVyQ291bnQgPiAwID8gYnVmZmVyQ291bnQgOiAnJztcclxuXHRcdFx0XHRzbmlwcGV0ID0gYCR7YnVmZmVyTm9kZS5uYW1lfSB7XFxuXFx0JHsgYnVmZmVyVHlwZSB9ICR7IHVuaWZvcm0ubmFtZSB9WyR7IGJ1ZmZlckNvdW50U25pcHBldCB9XTtcXG59O1xcbmA7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRjb25zdCB2ZWN0b3JUeXBlID0gdGhpcy5nZXRWZWN0b3JUeXBlKCB1bmlmb3JtLnR5cGUgKTtcclxuXHJcblx0XHRcdFx0c25pcHBldCA9IGAkeyB2ZWN0b3JUeXBlIH0gJHsgdGhpcy5nZXRQcm9wZXJ0eU5hbWUoIHVuaWZvcm0sIHNoYWRlclN0YWdlICkgfTtgO1xyXG5cclxuXHRcdFx0XHRncm91cCA9IHRydWU7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRjb25zdCBwcmVjaXNpb24gPSB1bmlmb3JtLm5vZGUucHJlY2lzaW9uO1xyXG5cclxuXHRcdFx0aWYgKCBwcmVjaXNpb24gIT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHRcdHNuaXBwZXQgPSBwcmVjaXNpb25MaWJbIHByZWNpc2lvbiBdICsgJyAnICsgc25pcHBldDtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICggZ3JvdXAgKSB7XHJcblxyXG5cdFx0XHRcdHNuaXBwZXQgPSAnXFx0JyArIHNuaXBwZXQ7XHJcblxyXG5cdFx0XHRcdGNvbnN0IGdyb3VwTmFtZSA9IHVuaWZvcm0uZ3JvdXBOb2RlLm5hbWU7XHJcblx0XHRcdFx0Y29uc3QgZ3JvdXBTbmlwcGV0cyA9IHVuaWZvcm1Hcm91cHNbIGdyb3VwTmFtZSBdIHx8ICggdW5pZm9ybUdyb3Vwc1sgZ3JvdXBOYW1lIF0gPSBbXSApO1xyXG5cclxuXHRcdFx0XHRncm91cFNuaXBwZXRzLnB1c2goIHNuaXBwZXQgKTtcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdHNuaXBwZXQgPSAndW5pZm9ybSAnICsgc25pcHBldDtcclxuXHJcblx0XHRcdFx0YmluZGluZ1NuaXBwZXRzLnB1c2goIHNuaXBwZXQgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0bGV0IG91dHB1dCA9ICcnO1xyXG5cclxuXHRcdGZvciAoIGNvbnN0IG5hbWUgaW4gdW5pZm9ybUdyb3VwcyApIHtcclxuXHJcblx0XHRcdGNvbnN0IGdyb3VwU25pcHBldHMgPSB1bmlmb3JtR3JvdXBzWyBuYW1lIF07XHJcblxyXG5cdFx0XHRvdXRwdXQgKz0gdGhpcy5fZ2V0R0xTTFVuaWZvcm1TdHJ1Y3QoIHNoYWRlclN0YWdlICsgJ18nICsgbmFtZSwgZ3JvdXBTbmlwcGV0cy5qb2luKCAnXFxuJyApICkgKyAnXFxuJztcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0b3V0cHV0ICs9IGJpbmRpbmdTbmlwcGV0cy5qb2luKCAnXFxuJyApO1xyXG5cclxuXHRcdHJldHVybiBvdXRwdXQ7XHJcblxyXG5cdH1cclxuXHJcblx0Z2V0VHlwZUZyb21BdHRyaWJ1dGUoIGF0dHJpYnV0ZSApIHtcclxuXHJcblx0XHRsZXQgbm9kZVR5cGUgPSBzdXBlci5nZXRUeXBlRnJvbUF0dHJpYnV0ZSggYXR0cmlidXRlICk7XHJcblxyXG5cdFx0aWYgKCAvXltpdV0vLnRlc3QoIG5vZGVUeXBlICkgJiYgYXR0cmlidXRlLmdwdVR5cGUgIT09IEludFR5cGUgKSB7XHJcblxyXG5cdFx0XHRsZXQgZGF0YUF0dHJpYnV0ZSA9IGF0dHJpYnV0ZTtcclxuXHJcblx0XHRcdGlmICggYXR0cmlidXRlLmlzSW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGUgKSBkYXRhQXR0cmlidXRlID0gYXR0cmlidXRlLmRhdGE7XHJcblxyXG5cdFx0XHRjb25zdCBhcnJheSA9IGRhdGFBdHRyaWJ1dGUuYXJyYXk7XHJcblxyXG5cdFx0XHRpZiAoICggYXJyYXkgaW5zdGFuY2VvZiBVaW50MzJBcnJheSB8fCBhcnJheSBpbnN0YW5jZW9mIEludDMyQXJyYXkgKSA9PT0gZmFsc2UgKSB7XHJcblxyXG5cdFx0XHRcdG5vZGVUeXBlID0gbm9kZVR5cGUuc2xpY2UoIDEgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIG5vZGVUeXBlO1xyXG5cclxuXHR9XHJcblxyXG5cdGdldEF0dHJpYnV0ZXMoIHNoYWRlclN0YWdlICkge1xyXG5cclxuXHRcdGxldCBzbmlwcGV0ID0gJyc7XHJcblxyXG5cdFx0aWYgKCBzaGFkZXJTdGFnZSA9PT0gJ3ZlcnRleCcgfHwgc2hhZGVyU3RhZ2UgPT09ICdjb21wdXRlJyApIHtcclxuXHJcblx0XHRcdGNvbnN0IGF0dHJpYnV0ZXMgPSB0aGlzLmdldEF0dHJpYnV0ZXNBcnJheSgpO1xyXG5cclxuXHRcdFx0bGV0IGxvY2F0aW9uID0gMDtcclxuXHJcblx0XHRcdGZvciAoIGNvbnN0IGF0dHJpYnV0ZSBvZiBhdHRyaWJ1dGVzICkge1xyXG5cclxuXHRcdFx0XHRzbmlwcGV0ICs9IGBsYXlvdXQoIGxvY2F0aW9uID0gJHsgbG9jYXRpb24gKysgfSApIGluICR7IGF0dHJpYnV0ZS50eXBlIH0gJHsgYXR0cmlidXRlLm5hbWUgfTtcXG5gO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gc25pcHBldDtcclxuXHJcblx0fVxyXG5cclxuXHRnZXRTdHJ1Y3RNZW1iZXJzKCBzdHJ1Y3QgKSB7XHJcblxyXG5cdFx0Y29uc3Qgc25pcHBldHMgPSBbXTtcclxuXHRcdGNvbnN0IG1lbWJlcnMgPSBzdHJ1Y3QuZ2V0TWVtYmVyVHlwZXMoKTtcclxuXHJcblx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCBtZW1iZXJzLmxlbmd0aDsgaSArKyApIHtcclxuXHJcblx0XHRcdGNvbnN0IG1lbWJlciA9IG1lbWJlcnNbIGkgXTtcclxuXHRcdFx0c25pcHBldHMucHVzaCggYGxheW91dCggbG9jYXRpb24gPSAke2l9ICkgb3V0ICR7IG1lbWJlcn0gbSR7aX07YCApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gc25pcHBldHMuam9pbiggJ1xcbicgKTtcclxuXHJcblx0fVxyXG5cclxuXHRnZXRTdHJ1Y3RzKCBzaGFkZXJTdGFnZSApIHtcclxuXHJcblx0XHRjb25zdCBzbmlwcGV0cyA9IFtdO1xyXG5cdFx0Y29uc3Qgc3RydWN0cyA9IHRoaXMuc3RydWN0c1sgc2hhZGVyU3RhZ2UgXTtcclxuXHJcblx0XHRpZiAoIHN0cnVjdHMubGVuZ3RoID09PSAwICkge1xyXG5cclxuXHRcdFx0cmV0dXJuICdsYXlvdXQoIGxvY2F0aW9uID0gMCApIG91dCB2ZWM0IGZyYWdDb2xvcjtcXG4nO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRmb3IgKCBsZXQgaW5kZXggPSAwLCBsZW5ndGggPSBzdHJ1Y3RzLmxlbmd0aDsgaW5kZXggPCBsZW5ndGg7IGluZGV4ICsrICkge1xyXG5cclxuXHRcdFx0Y29uc3Qgc3RydWN0ID0gc3RydWN0c1sgaW5kZXggXTtcclxuXHJcblx0XHRcdGxldCBzbmlwcGV0ID0gJ1xcbic7XHJcblx0XHRcdHNuaXBwZXQgKz0gdGhpcy5nZXRTdHJ1Y3RNZW1iZXJzKCBzdHJ1Y3QgKTtcclxuXHRcdFx0c25pcHBldCArPSAnXFxuJztcclxuXHJcblx0XHRcdHNuaXBwZXRzLnB1c2goIHNuaXBwZXQgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHNuaXBwZXRzLmpvaW4oICdcXG5cXG4nICk7XHJcblxyXG5cdH1cclxuXHJcblx0Z2V0VmFyeWluZ3MoIHNoYWRlclN0YWdlICkge1xyXG5cclxuXHRcdGxldCBzbmlwcGV0ID0gJyc7XHJcblxyXG5cdFx0Y29uc3QgdmFyeWluZ3MgPSB0aGlzLnZhcnlpbmdzO1xyXG5cclxuXHRcdGlmICggc2hhZGVyU3RhZ2UgPT09ICd2ZXJ0ZXgnIHx8IHNoYWRlclN0YWdlID09PSAnY29tcHV0ZScgKSB7XHJcblxyXG5cdFx0XHRmb3IgKCBjb25zdCB2YXJ5aW5nIG9mIHZhcnlpbmdzICkge1xyXG5cclxuXHRcdFx0XHRpZiAoIHNoYWRlclN0YWdlID09PSAnY29tcHV0ZScgKSB2YXJ5aW5nLm5lZWRzSW50ZXJwb2xhdGlvbiA9IHRydWU7XHJcblx0XHRcdFx0Y29uc3QgdHlwZSA9IHRoaXMuZ2V0VHlwZSggdmFyeWluZy50eXBlICk7XHJcblx0XHRcdFx0Y29uc3QgZmxhdCA9IHR5cGUuaW5jbHVkZXMoICdpbnQnICkgfHwgdHlwZS5pbmNsdWRlcyggJ3V2JyApIHx8IHR5cGUuaW5jbHVkZXMoICdpdicgKSA/ICdmbGF0ICcgOiAnJztcclxuXHJcblx0XHRcdFx0c25pcHBldCArPSBgJHtmbGF0fSR7dmFyeWluZy5uZWVkc0ludGVycG9sYXRpb24gPyAnb3V0JyA6ICcvKm91dCovJ30gJHt0eXBlfSAke3ZhcnlpbmcubmFtZX07XFxuYDtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9IGVsc2UgaWYgKCBzaGFkZXJTdGFnZSA9PT0gJ2ZyYWdtZW50JyApIHtcclxuXHJcblx0XHRcdGZvciAoIGNvbnN0IHZhcnlpbmcgb2YgdmFyeWluZ3MgKSB7XHJcblxyXG5cdFx0XHRcdGlmICggdmFyeWluZy5uZWVkc0ludGVycG9sYXRpb24gKSB7XHJcblxyXG5cdFx0XHRcdFx0Y29uc3QgdHlwZSA9IHRoaXMuZ2V0VHlwZSggdmFyeWluZy50eXBlICk7XHJcblx0XHRcdFx0XHRjb25zdCBmbGF0ID0gdHlwZS5pbmNsdWRlcyggJ2ludCcgKSB8fCB0eXBlLmluY2x1ZGVzKCAndXYnICkgfHwgdHlwZS5pbmNsdWRlcyggJ2l2JyApID8gJ2ZsYXQgJyA6ICcnO1xyXG5cclxuXHRcdFx0XHRcdHNuaXBwZXQgKz0gYCR7ZmxhdH1pbiAke3R5cGV9ICR7dmFyeWluZy5uYW1lfTtcXG5gO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGZvciAoIGNvbnN0IGJ1aWx0aW4gb2YgdGhpcy5idWlsdGluc1sgc2hhZGVyU3RhZ2UgXSApIHtcclxuXHJcblx0XHRcdHNuaXBwZXQgKz0gYCR7YnVpbHRpbn07XFxuYDtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHNuaXBwZXQ7XHJcblxyXG5cdH1cclxuXHJcblx0Z2V0VmVydGV4SW5kZXgoKSB7XHJcblxyXG5cdFx0cmV0dXJuICd1aW50KCBnbF9WZXJ0ZXhJRCApJztcclxuXHJcblx0fVxyXG5cclxuXHRnZXRJbnN0YW5jZUluZGV4KCkge1xyXG5cclxuXHRcdHJldHVybiAndWludCggZ2xfSW5zdGFuY2VJRCApJztcclxuXHJcblx0fVxyXG5cclxuXHRnZXRJbnZvY2F0aW9uTG9jYWxJbmRleCgpIHtcclxuXHJcblx0XHRjb25zdCB3b3JrZ3JvdXBTaXplID0gdGhpcy5vYmplY3Qud29ya2dyb3VwU2l6ZTtcclxuXHJcblx0XHRjb25zdCBzaXplID0gd29ya2dyb3VwU2l6ZS5yZWR1Y2UoICggYWNjLCBjdXJyICkgPT4gYWNjICogY3VyciwgMSApO1xyXG5cclxuXHRcdHJldHVybiBgdWludCggZ2xfSW5zdGFuY2VJRCApICUgJHtzaXplfXVgO1xyXG5cclxuXHR9XHJcblxyXG5cdGdldERyYXdJbmRleCgpIHtcclxuXHJcblx0XHRjb25zdCBleHRlbnNpb25zID0gdGhpcy5yZW5kZXJlci5iYWNrZW5kLmV4dGVuc2lvbnM7XHJcblxyXG5cdFx0aWYgKCBleHRlbnNpb25zLmhhcyggJ1dFQkdMX211bHRpX2RyYXcnICkgKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gJ3VpbnQoIGdsX0RyYXdJRCApJztcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIG51bGw7XHJcblxyXG5cdH1cclxuXHJcblx0Z2V0RnJvbnRGYWNpbmcoKSB7XHJcblxyXG5cdFx0cmV0dXJuICdnbF9Gcm9udEZhY2luZyc7XHJcblxyXG5cdH1cclxuXHJcblx0Z2V0RnJhZ0Nvb3JkKCkge1xyXG5cclxuXHRcdHJldHVybiAnZ2xfRnJhZ0Nvb3JkLnh5JztcclxuXHJcblx0fVxyXG5cclxuXHRnZXRGcmFnRGVwdGgoKSB7XHJcblxyXG5cdFx0cmV0dXJuICdnbF9GcmFnRGVwdGgnO1xyXG5cclxuXHR9XHJcblxyXG5cdGVuYWJsZUV4dGVuc2lvbiggbmFtZSwgYmVoYXZpb3IsIHNoYWRlclN0YWdlID0gdGhpcy5zaGFkZXJTdGFnZSApIHtcclxuXHJcblx0XHRjb25zdCBtYXAgPSB0aGlzLmV4dGVuc2lvbnNbIHNoYWRlclN0YWdlIF0gfHwgKCB0aGlzLmV4dGVuc2lvbnNbIHNoYWRlclN0YWdlIF0gPSBuZXcgTWFwKCkgKTtcclxuXHJcblx0XHRpZiAoIG1hcC5oYXMoIG5hbWUgKSA9PT0gZmFsc2UgKSB7XHJcblxyXG5cdFx0XHRtYXAuc2V0KCBuYW1lLCB7XHJcblx0XHRcdFx0bmFtZSxcclxuXHRcdFx0XHRiZWhhdmlvclxyXG5cdFx0XHR9ICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdGdldEV4dGVuc2lvbnMoIHNoYWRlclN0YWdlICkge1xyXG5cclxuXHRcdGNvbnN0IHNuaXBwZXRzID0gW107XHJcblxyXG5cdFx0aWYgKCBzaGFkZXJTdGFnZSA9PT0gJ3ZlcnRleCcgKSB7XHJcblxyXG5cdFx0XHRjb25zdCBleHQgPSB0aGlzLnJlbmRlcmVyLmJhY2tlbmQuZXh0ZW5zaW9ucztcclxuXHRcdFx0Y29uc3QgaXNCYXRjaGVkTWVzaCA9IHRoaXMub2JqZWN0LmlzQmF0Y2hlZE1lc2g7XHJcblxyXG5cdFx0XHRpZiAoIGlzQmF0Y2hlZE1lc2ggJiYgZXh0LmhhcyggJ1dFQkdMX211bHRpX2RyYXcnICkgKSB7XHJcblxyXG5cdFx0XHRcdHRoaXMuZW5hYmxlRXh0ZW5zaW9uKCAnR0xfQU5HTEVfbXVsdGlfZHJhdycsICdyZXF1aXJlJywgc2hhZGVyU3RhZ2UgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Y29uc3QgZXh0ZW5zaW9ucyA9IHRoaXMuZXh0ZW5zaW9uc1sgc2hhZGVyU3RhZ2UgXTtcclxuXHJcblx0XHRpZiAoIGV4dGVuc2lvbnMgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdGZvciAoIGNvbnN0IHsgbmFtZSwgYmVoYXZpb3IgfSBvZiBleHRlbnNpb25zLnZhbHVlcygpICkge1xyXG5cclxuXHRcdFx0XHRzbmlwcGV0cy5wdXNoKCBgI2V4dGVuc2lvbiAke25hbWV9IDogJHtiZWhhdmlvcn1gICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBzbmlwcGV0cy5qb2luKCAnXFxuJyApO1xyXG5cclxuXHR9XHJcblxyXG5cdGdldENsaXBEaXN0YW5jZSgpIHtcclxuXHJcblx0XHRyZXR1cm4gJ2dsX0NsaXBEaXN0YW5jZSc7XHJcblxyXG5cdH1cclxuXHJcblx0aXNBdmFpbGFibGUoIG5hbWUgKSB7XHJcblxyXG5cdFx0bGV0IHJlc3VsdCA9IHN1cHBvcnRzWyBuYW1lIF07XHJcblxyXG5cdFx0aWYgKCByZXN1bHQgPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdGxldCBleHRlbnNpb25OYW1lO1xyXG5cclxuXHRcdFx0cmVzdWx0ID0gZmFsc2U7XHJcblxyXG5cdFx0XHRzd2l0Y2ggKCBuYW1lICkge1xyXG5cclxuXHRcdFx0XHRjYXNlICdmbG9hdDMyRmlsdGVyYWJsZSc6XHJcblx0XHRcdFx0XHRleHRlbnNpb25OYW1lID0gJ09FU190ZXh0dXJlX2Zsb2F0X2xpbmVhcic7XHJcblx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0Y2FzZSAnY2xpcERpc3RhbmNlJzpcclxuXHRcdFx0XHRcdGV4dGVuc2lvbk5hbWUgPSAnV0VCR0xfY2xpcF9jdWxsX2Rpc3RhbmNlJztcclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKCBleHRlbnNpb25OYW1lICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdGNvbnN0IGV4dGVuc2lvbnMgPSB0aGlzLnJlbmRlcmVyLmJhY2tlbmQuZXh0ZW5zaW9ucztcclxuXHJcblx0XHRcdFx0aWYgKCBleHRlbnNpb25zLmhhcyggZXh0ZW5zaW9uTmFtZSApICkge1xyXG5cclxuXHRcdFx0XHRcdGV4dGVuc2lvbnMuZ2V0KCBleHRlbnNpb25OYW1lICk7XHJcblx0XHRcdFx0XHRyZXN1bHQgPSB0cnVlO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRzdXBwb3J0c1sgbmFtZSBdID0gcmVzdWx0O1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gcmVzdWx0O1xyXG5cclxuXHR9XHJcblxyXG5cdGlzRmxpcFkoKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRydWU7XHJcblxyXG5cdH1cclxuXHJcblx0ZW5hYmxlSGFyZHdhcmVDbGlwcGluZyggcGxhbmVDb3VudCApIHtcclxuXHJcblx0XHR0aGlzLmVuYWJsZUV4dGVuc2lvbiggJ0dMX0FOR0xFX2NsaXBfY3VsbF9kaXN0YW5jZScsICdyZXF1aXJlJyApO1xyXG5cclxuXHRcdHRoaXMuYnVpbHRpbnNbICd2ZXJ0ZXgnIF0ucHVzaCggYG91dCBmbG9hdCBnbF9DbGlwRGlzdGFuY2VbICR7IHBsYW5lQ291bnQgfSBdYCApO1xyXG5cclxuXHR9XHJcblxyXG5cdHJlZ2lzdGVyVHJhbnNmb3JtKCB2YXJ5aW5nTmFtZSwgYXR0cmlidXRlTm9kZSApIHtcclxuXHJcblx0XHR0aGlzLnRyYW5zZm9ybXMucHVzaCggeyB2YXJ5aW5nTmFtZSwgYXR0cmlidXRlTm9kZSB9ICk7XHJcblxyXG5cdH1cclxuXHJcblx0Z2V0VHJhbnNmb3JtcyggLyogc2hhZGVyU3RhZ2UgICovICkge1xyXG5cclxuXHRcdGNvbnN0IHRyYW5zZm9ybXMgPSB0aGlzLnRyYW5zZm9ybXM7XHJcblxyXG5cdFx0bGV0IHNuaXBwZXQgPSAnJztcclxuXHJcblx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCB0cmFuc2Zvcm1zLmxlbmd0aDsgaSArKyApIHtcclxuXHJcblx0XHRcdGNvbnN0IHRyYW5zZm9ybSA9IHRyYW5zZm9ybXNbIGkgXTtcclxuXHJcblx0XHRcdGNvbnN0IGF0dHJpYnV0ZU5hbWUgPSB0aGlzLmdldFByb3BlcnR5TmFtZSggdHJhbnNmb3JtLmF0dHJpYnV0ZU5vZGUgKTtcclxuXHJcblx0XHRcdHNuaXBwZXQgKz0gYCR7IHRyYW5zZm9ybS52YXJ5aW5nTmFtZSB9ID0gJHsgYXR0cmlidXRlTmFtZSB9O1xcblxcdGA7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBzbmlwcGV0O1xyXG5cclxuXHR9XHJcblxyXG5cdF9nZXRHTFNMVW5pZm9ybVN0cnVjdCggbmFtZSwgdmFycyApIHtcclxuXHJcblx0XHRyZXR1cm4gYFxyXG5sYXlvdXQoIHN0ZDE0MCApIHVuaWZvcm0gJHtuYW1lfSB7XHJcbiR7dmFyc31cclxufTtgO1xyXG5cclxuXHR9XHJcblxyXG5cdF9nZXRHTFNMVmVydGV4Q29kZSggc2hhZGVyRGF0YSApIHtcclxuXHJcblx0XHRyZXR1cm4gYCN2ZXJzaW9uIDMwMCBlc1xyXG5cclxuJHsgdGhpcy5nZXRTaWduYXR1cmUoKSB9XHJcblxyXG4vLyBleHRlbnNpb25zIFxyXG4ke3NoYWRlckRhdGEuZXh0ZW5zaW9uc31cclxuXHJcbi8vIHByZWNpc2lvblxyXG4keyBkZWZhdWx0UHJlY2lzaW9ucyB9XHJcblxyXG4vLyB1bmlmb3Jtc1xyXG4ke3NoYWRlckRhdGEudW5pZm9ybXN9XHJcblxyXG4vLyB2YXJ5aW5nc1xyXG4ke3NoYWRlckRhdGEudmFyeWluZ3N9XHJcblxyXG4vLyBhdHRyaWJ1dGVzXHJcbiR7c2hhZGVyRGF0YS5hdHRyaWJ1dGVzfVxyXG5cclxuLy8gY29kZXNcclxuJHtzaGFkZXJEYXRhLmNvZGVzfVxyXG5cclxudm9pZCBtYWluKCkge1xyXG5cclxuXHQvLyB2YXJzXHJcblx0JHtzaGFkZXJEYXRhLnZhcnN9XHJcblxyXG5cdC8vIHRyYW5zZm9ybXNcclxuXHQke3NoYWRlckRhdGEudHJhbnNmb3Jtc31cclxuXHJcblx0Ly8gZmxvd1xyXG5cdCR7c2hhZGVyRGF0YS5mbG93fVxyXG5cclxuXHRnbF9Qb2ludFNpemUgPSAxLjA7XHJcblxyXG59XHJcbmA7XHJcblxyXG5cdH1cclxuXHJcblx0X2dldEdMU0xGcmFnbWVudENvZGUoIHNoYWRlckRhdGEgKSB7XHJcblxyXG5cdFx0cmV0dXJuIGAjdmVyc2lvbiAzMDAgZXNcclxuXHJcbiR7IHRoaXMuZ2V0U2lnbmF0dXJlKCkgfVxyXG5cclxuLy8gcHJlY2lzaW9uXHJcbiR7IGRlZmF1bHRQcmVjaXNpb25zIH1cclxuXHJcbi8vIHVuaWZvcm1zXHJcbiR7c2hhZGVyRGF0YS51bmlmb3Jtc31cclxuXHJcbi8vIHZhcnlpbmdzXHJcbiR7c2hhZGVyRGF0YS52YXJ5aW5nc31cclxuXHJcbi8vIGNvZGVzXHJcbiR7c2hhZGVyRGF0YS5jb2Rlc31cclxuXHJcbiR7c2hhZGVyRGF0YS5zdHJ1Y3RzfVxyXG5cclxudm9pZCBtYWluKCkge1xyXG5cclxuXHQvLyB2YXJzXHJcblx0JHtzaGFkZXJEYXRhLnZhcnN9XHJcblxyXG5cdC8vIGZsb3dcclxuXHQke3NoYWRlckRhdGEuZmxvd31cclxuXHJcbn1cclxuYDtcclxuXHJcblx0fVxyXG5cclxuXHRidWlsZENvZGUoKSB7XHJcblxyXG5cdFx0Y29uc3Qgc2hhZGVyc0RhdGEgPSB0aGlzLm1hdGVyaWFsICE9PSBudWxsID8geyBmcmFnbWVudDoge30sIHZlcnRleDoge30gfSA6IHsgY29tcHV0ZToge30gfTtcclxuXHJcblx0XHR0aGlzLnNvcnRCaW5kaW5nR3JvdXBzKCk7XHJcblxyXG5cdFx0Zm9yICggY29uc3Qgc2hhZGVyU3RhZ2UgaW4gc2hhZGVyc0RhdGEgKSB7XHJcblxyXG5cdFx0XHRsZXQgZmxvdyA9ICcvLyBjb2RlXFxuXFxuJztcclxuXHRcdFx0ZmxvdyArPSB0aGlzLmZsb3dDb2RlWyBzaGFkZXJTdGFnZSBdO1xyXG5cclxuXHRcdFx0Y29uc3QgZmxvd05vZGVzID0gdGhpcy5mbG93Tm9kZXNbIHNoYWRlclN0YWdlIF07XHJcblx0XHRcdGNvbnN0IG1haW5Ob2RlID0gZmxvd05vZGVzWyBmbG93Tm9kZXMubGVuZ3RoIC0gMSBdO1xyXG5cclxuXHRcdFx0Zm9yICggY29uc3Qgbm9kZSBvZiBmbG93Tm9kZXMgKSB7XHJcblxyXG5cdFx0XHRcdGNvbnN0IGZsb3dTbG90RGF0YSA9IHRoaXMuZ2V0Rmxvd0RhdGEoIG5vZGUvKiwgc2hhZGVyU3RhZ2UqLyApO1xyXG5cdFx0XHRcdGNvbnN0IHNsb3ROYW1lID0gbm9kZS5uYW1lO1xyXG5cclxuXHRcdFx0XHRpZiAoIHNsb3ROYW1lICkge1xyXG5cclxuXHRcdFx0XHRcdGlmICggZmxvdy5sZW5ndGggPiAwICkgZmxvdyArPSAnXFxuJztcclxuXHJcblx0XHRcdFx0XHRmbG93ICs9IGBcXHQvLyBmbG93IC0+ICR7IHNsb3ROYW1lIH1cXG5cXHRgO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGZsb3cgKz0gYCR7IGZsb3dTbG90RGF0YS5jb2RlIH1cXG5cXHRgO1xyXG5cclxuXHRcdFx0XHRpZiAoIG5vZGUgPT09IG1haW5Ob2RlICYmIHNoYWRlclN0YWdlICE9PSAnY29tcHV0ZScgKSB7XHJcblxyXG5cdFx0XHRcdFx0ZmxvdyArPSAnLy8gcmVzdWx0XFxuXFx0JztcclxuXHJcblx0XHRcdFx0XHRpZiAoIHNoYWRlclN0YWdlID09PSAndmVydGV4JyApIHtcclxuXHJcblx0XHRcdFx0XHRcdGZsb3cgKz0gJ2dsX1Bvc2l0aW9uID0gJztcclxuXHRcdFx0XHRcdFx0ZmxvdyArPSBgJHsgZmxvd1Nsb3REYXRhLnJlc3VsdCB9O2A7XHJcblxyXG5cdFx0XHRcdFx0fSBlbHNlIGlmICggc2hhZGVyU3RhZ2UgPT09ICdmcmFnbWVudCcgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRpZiAoICEgbm9kZS5vdXRwdXROb2RlLmlzT3V0cHV0U3RydWN0Tm9kZSApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0ZmxvdyArPSAnZnJhZ0NvbG9yID0gJztcclxuXHRcdFx0XHRcdFx0XHRmbG93ICs9IGAkeyBmbG93U2xvdERhdGEucmVzdWx0IH07YDtcclxuXHJcblx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGNvbnN0IHN0YWdlRGF0YSA9IHNoYWRlcnNEYXRhWyBzaGFkZXJTdGFnZSBdO1xyXG5cclxuXHRcdFx0c3RhZ2VEYXRhLmV4dGVuc2lvbnMgPSB0aGlzLmdldEV4dGVuc2lvbnMoIHNoYWRlclN0YWdlICk7XHJcblx0XHRcdHN0YWdlRGF0YS51bmlmb3JtcyA9IHRoaXMuZ2V0VW5pZm9ybXMoIHNoYWRlclN0YWdlICk7XHJcblx0XHRcdHN0YWdlRGF0YS5hdHRyaWJ1dGVzID0gdGhpcy5nZXRBdHRyaWJ1dGVzKCBzaGFkZXJTdGFnZSApO1xyXG5cdFx0XHRzdGFnZURhdGEudmFyeWluZ3MgPSB0aGlzLmdldFZhcnlpbmdzKCBzaGFkZXJTdGFnZSApO1xyXG5cdFx0XHRzdGFnZURhdGEudmFycyA9IHRoaXMuZ2V0VmFycyggc2hhZGVyU3RhZ2UgKTtcclxuXHRcdFx0c3RhZ2VEYXRhLnN0cnVjdHMgPSB0aGlzLmdldFN0cnVjdHMoIHNoYWRlclN0YWdlICk7XHJcblx0XHRcdHN0YWdlRGF0YS5jb2RlcyA9IHRoaXMuZ2V0Q29kZXMoIHNoYWRlclN0YWdlICk7XHJcblx0XHRcdHN0YWdlRGF0YS50cmFuc2Zvcm1zID0gdGhpcy5nZXRUcmFuc2Zvcm1zKCBzaGFkZXJTdGFnZSApO1xyXG5cdFx0XHRzdGFnZURhdGEuZmxvdyA9IGZsb3c7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggdGhpcy5tYXRlcmlhbCAhPT0gbnVsbCApIHtcclxuXHJcblx0XHRcdHRoaXMudmVydGV4U2hhZGVyID0gdGhpcy5fZ2V0R0xTTFZlcnRleENvZGUoIHNoYWRlcnNEYXRhLnZlcnRleCApO1xyXG5cdFx0XHR0aGlzLmZyYWdtZW50U2hhZGVyID0gdGhpcy5fZ2V0R0xTTEZyYWdtZW50Q29kZSggc2hhZGVyc0RhdGEuZnJhZ21lbnQgKTtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0dGhpcy5jb21wdXRlU2hhZGVyID0gdGhpcy5fZ2V0R0xTTFZlcnRleENvZGUoIHNoYWRlcnNEYXRhLmNvbXB1dGUgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0Z2V0VW5pZm9ybUZyb21Ob2RlKCBub2RlLCB0eXBlLCBzaGFkZXJTdGFnZSwgbmFtZSA9IG51bGwgKSB7XHJcblxyXG5cdFx0Y29uc3QgdW5pZm9ybU5vZGUgPSBzdXBlci5nZXRVbmlmb3JtRnJvbU5vZGUoIG5vZGUsIHR5cGUsIHNoYWRlclN0YWdlLCBuYW1lICk7XHJcblx0XHRjb25zdCBub2RlRGF0YSA9IHRoaXMuZ2V0RGF0YUZyb21Ob2RlKCBub2RlLCBzaGFkZXJTdGFnZSwgdGhpcy5nbG9iYWxDYWNoZSApO1xyXG5cclxuXHRcdGxldCB1bmlmb3JtR1BVID0gbm9kZURhdGEudW5pZm9ybUdQVTtcclxuXHJcblx0XHRpZiAoIHVuaWZvcm1HUFUgPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdGNvbnN0IGdyb3VwID0gbm9kZS5ncm91cE5vZGU7XHJcblx0XHRcdGNvbnN0IGdyb3VwTmFtZSA9IGdyb3VwLm5hbWU7XHJcblxyXG5cdFx0XHRjb25zdCBiaW5kaW5ncyA9IHRoaXMuZ2V0QmluZEdyb3VwQXJyYXkoIGdyb3VwTmFtZSwgc2hhZGVyU3RhZ2UgKTtcclxuXHJcblx0XHRcdGlmICggdHlwZSA9PT0gJ3RleHR1cmUnICkge1xyXG5cclxuXHRcdFx0XHR1bmlmb3JtR1BVID0gbmV3IE5vZGVTYW1wbGVkVGV4dHVyZSggdW5pZm9ybU5vZGUubmFtZSwgdW5pZm9ybU5vZGUubm9kZSwgZ3JvdXAgKTtcclxuXHRcdFx0XHRiaW5kaW5ncy5wdXNoKCB1bmlmb3JtR1BVICk7XHJcblxyXG5cdFx0XHR9IGVsc2UgaWYgKCB0eXBlID09PSAnY3ViZVRleHR1cmUnICkge1xyXG5cclxuXHRcdFx0XHR1bmlmb3JtR1BVID0gbmV3IE5vZGVTYW1wbGVkQ3ViZVRleHR1cmUoIHVuaWZvcm1Ob2RlLm5hbWUsIHVuaWZvcm1Ob2RlLm5vZGUsIGdyb3VwICk7XHJcblx0XHRcdFx0YmluZGluZ3MucHVzaCggdW5pZm9ybUdQVSApO1xyXG5cclxuXHRcdFx0fSBlbHNlIGlmICggdHlwZSA9PT0gJ3RleHR1cmUzRCcgKSB7XHJcblxyXG5cdFx0XHRcdHVuaWZvcm1HUFUgPSBuZXcgTm9kZVNhbXBsZWRUZXh0dXJlM0QoIHVuaWZvcm1Ob2RlLm5hbWUsIHVuaWZvcm1Ob2RlLm5vZGUsIGdyb3VwICk7XHJcblx0XHRcdFx0YmluZGluZ3MucHVzaCggdW5pZm9ybUdQVSApO1xyXG5cclxuXHRcdFx0fSBlbHNlIGlmICggdHlwZSA9PT0gJ2J1ZmZlcicgKSB7XHJcblxyXG5cdFx0XHRcdG5vZGUubmFtZSA9IGBOb2RlQnVmZmVyXyR7IG5vZGUuaWQgfWA7XHJcblx0XHRcdFx0dW5pZm9ybU5vZGUubmFtZSA9IGBidWZmZXIkeyBub2RlLmlkIH1gO1xyXG5cclxuXHRcdFx0XHRjb25zdCBidWZmZXIgPSBuZXcgTm9kZVVuaWZvcm1CdWZmZXIoIG5vZGUsIGdyb3VwICk7XHJcblx0XHRcdFx0YnVmZmVyLm5hbWUgPSBub2RlLm5hbWU7XHJcblxyXG5cdFx0XHRcdGJpbmRpbmdzLnB1c2goIGJ1ZmZlciApO1xyXG5cclxuXHRcdFx0XHR1bmlmb3JtR1BVID0gYnVmZmVyO1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0Y29uc3QgdW5pZm9ybXNTdGFnZSA9IHRoaXMudW5pZm9ybUdyb3Vwc1sgc2hhZGVyU3RhZ2UgXSB8fCAoIHRoaXMudW5pZm9ybUdyb3Vwc1sgc2hhZGVyU3RhZ2UgXSA9IHt9ICk7XHJcblxyXG5cdFx0XHRcdGxldCB1bmlmb3Jtc0dyb3VwID0gdW5pZm9ybXNTdGFnZVsgZ3JvdXBOYW1lIF07XHJcblxyXG5cdFx0XHRcdGlmICggdW5pZm9ybXNHcm91cCA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRcdHVuaWZvcm1zR3JvdXAgPSBuZXcgTm9kZVVuaWZvcm1zR3JvdXAoIHNoYWRlclN0YWdlICsgJ18nICsgZ3JvdXBOYW1lLCBncm91cCApO1xyXG5cdFx0XHRcdFx0Ly91bmlmb3Jtc0dyb3VwLnNldFZpc2liaWxpdHkoIGdwdVNoYWRlclN0YWdlTGliWyBzaGFkZXJTdGFnZSBdICk7XHJcblxyXG5cdFx0XHRcdFx0dW5pZm9ybXNTdGFnZVsgZ3JvdXBOYW1lIF0gPSB1bmlmb3Jtc0dyb3VwO1xyXG5cclxuXHRcdFx0XHRcdGJpbmRpbmdzLnB1c2goIHVuaWZvcm1zR3JvdXAgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR1bmlmb3JtR1BVID0gdGhpcy5nZXROb2RlVW5pZm9ybSggdW5pZm9ybU5vZGUsIHR5cGUgKTtcclxuXHJcblx0XHRcdFx0dW5pZm9ybXNHcm91cC5hZGRVbmlmb3JtKCB1bmlmb3JtR1BVICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRub2RlRGF0YS51bmlmb3JtR1BVID0gdW5pZm9ybUdQVTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHVuaWZvcm1Ob2RlO1xyXG5cclxuXHR9XHJcblxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBHTFNMTm9kZUJ1aWxkZXI7XHJcbiIsImxldCB2ZWN0b3IyID0gbnVsbDtcclxubGV0IHZlY3RvcjQgPSBudWxsO1xyXG5sZXQgY29sb3I0ID0gbnVsbDtcclxuXHJcbmltcG9ydCBDb2xvcjQgZnJvbSAnLi9Db2xvcjQuanMnO1xyXG5pbXBvcnQgeyBWZWN0b3IyIH0gZnJvbSAnLi4vLi4vbWF0aC9WZWN0b3IyLmpzJztcclxuaW1wb3J0IHsgVmVjdG9yNCB9IGZyb20gJy4uLy4uL21hdGgvVmVjdG9yNC5qcyc7XHJcbmltcG9ydCB7IGNyZWF0ZUNhbnZhc0VsZW1lbnQgfSBmcm9tICcuLi8uLi91dGlscy5qcyc7XHJcbmltcG9ydCB7IFJFVklTSU9OIH0gZnJvbSAnLi4vLi4vY29uc3RhbnRzLmpzJztcclxuXHJcbmNsYXNzIEJhY2tlbmQge1xyXG5cclxuXHRjb25zdHJ1Y3RvciggcGFyYW1ldGVycyA9IHt9ICkge1xyXG5cclxuXHRcdHRoaXMucGFyYW1ldGVycyA9IE9iamVjdC5hc3NpZ24oIHt9LCBwYXJhbWV0ZXJzICk7XHJcblx0XHR0aGlzLmRhdGEgPSBuZXcgV2Vha01hcCgpO1xyXG5cdFx0dGhpcy5yZW5kZXJlciA9IG51bGw7XHJcblx0XHR0aGlzLmRvbUVsZW1lbnQgPSBudWxsO1xyXG5cclxuXHR9XHJcblxyXG5cdGFzeW5jIGluaXQoIHJlbmRlcmVyICkge1xyXG5cclxuXHRcdHRoaXMucmVuZGVyZXIgPSByZW5kZXJlcjtcclxuXHJcblx0fVxyXG5cclxuXHQvLyByZW5kZXIgY29udGV4dFxyXG5cclxuXHRiZWdpbiggLypyZW5kZXJDb250ZXh0Ki8gKSB7IH1cclxuXHJcblx0ZmluaXNoKCAvKnJlbmRlckNvbnRleHQqLyApIHsgfVxyXG5cclxuXHQvLyByZW5kZXIgb2JqZWN0XHJcblxyXG5cdGRyYXcoIC8qcmVuZGVyT2JqZWN0LCBpbmZvKi8gKSB7IH1cclxuXHJcblx0Ly8gcHJvZ3JhbVxyXG5cclxuXHRjcmVhdGVQcm9ncmFtKCAvKnByb2dyYW0qLyApIHsgfVxyXG5cclxuXHRkZXN0cm95UHJvZ3JhbSggLypwcm9ncmFtKi8gKSB7IH1cclxuXHJcblx0Ly8gYmluZGluZ3NcclxuXHJcblx0Y3JlYXRlQmluZGluZ3MoIC8qYmluZ0dyb3VwLCBiaW5kaW5ncyovICkgeyB9XHJcblxyXG5cdHVwZGF0ZUJpbmRpbmdzKCAvKmJpbmdHcm91cCwgYmluZGluZ3MqLyApIHsgfVxyXG5cclxuXHQvLyBwaXBlbGluZVxyXG5cclxuXHRjcmVhdGVSZW5kZXJQaXBlbGluZSggLypyZW5kZXJPYmplY3QqLyApIHsgfVxyXG5cclxuXHRjcmVhdGVDb21wdXRlUGlwZWxpbmUoIC8qY29tcHV0ZU5vZGUsIHBpcGVsaW5lKi8gKSB7IH1cclxuXHJcblx0ZGVzdHJveVBpcGVsaW5lKCAvKnBpcGVsaW5lKi8gKSB7IH1cclxuXHJcblx0Ly8gY2FjaGUga2V5XHJcblxyXG5cdG5lZWRzUmVuZGVyVXBkYXRlKCAvKnJlbmRlck9iamVjdCovICkgeyB9IC8vIHJldHVybiBCb29sZWFuICggZmFzdCB0ZXN0IClcclxuXHJcblx0Z2V0UmVuZGVyQ2FjaGVLZXkoIC8qcmVuZGVyT2JqZWN0Ki8gKSB7IH0gLy8gcmV0dXJuIFN0cmluZ1xyXG5cclxuXHQvLyBub2RlIGJ1aWxkZXJcclxuXHJcblx0Y3JlYXRlTm9kZUJ1aWxkZXIoIC8qcmVuZGVyT2JqZWN0Ki8gKSB7IH0gLy8gcmV0dXJuIE5vZGVCdWlsZGVyIChBREQgSVQpXHJcblxyXG5cdC8vIHRleHR1cmVzXHJcblxyXG5cdGNyZWF0ZVNhbXBsZXIoIC8qdGV4dHVyZSovICkgeyB9XHJcblxyXG5cdGNyZWF0ZURlZmF1bHRUZXh0dXJlKCAvKnRleHR1cmUqLyApIHsgfVxyXG5cclxuXHRjcmVhdGVUZXh0dXJlKCAvKnRleHR1cmUqLyApIHsgfVxyXG5cclxuXHRjb3B5VGV4dHVyZVRvQnVmZmVyKCAvKnRleHR1cmUsIHgsIHksIHdpZHRoLCBoZWlnaHQqLyApIHt9XHJcblxyXG5cdC8vIGF0dHJpYnV0ZXNcclxuXHJcblx0Y3JlYXRlQXR0cmlidXRlKCAvKmF0dHJpYnV0ZSovICkgeyB9XHJcblxyXG5cdGNyZWF0ZUluZGV4QXR0cmlidXRlKCAvKmF0dHJpYnV0ZSovICkgeyB9XHJcblxyXG5cdHVwZGF0ZUF0dHJpYnV0ZSggLyphdHRyaWJ1dGUqLyApIHsgfVxyXG5cclxuXHRkZXN0cm95QXR0cmlidXRlKCAvKmF0dHJpYnV0ZSovICkgeyB9XHJcblxyXG5cdC8vIGNhbnZhc1xyXG5cclxuXHRnZXRDb250ZXh0KCkgeyB9XHJcblxyXG5cdHVwZGF0ZVNpemUoKSB7IH1cclxuXHJcblx0Ly8gdXRpbHNcclxuXHJcblx0cmVzb2x2ZVRpbWVzdGFtcEFzeW5jKCAvKnJlbmRlckNvbnRleHQsIHR5cGUqLyApIHsgfVxyXG5cclxuXHRoYXNGZWF0dXJlQXN5bmMoIC8qbmFtZSovICkgeyB9IC8vIHJldHVybiBCb29sZWFuXHJcblxyXG5cdGhhc0ZlYXR1cmUoIC8qbmFtZSovICkgeyB9IC8vIHJldHVybiBCb29sZWFuXHJcblxyXG5cdGdldEluc3RhbmNlQ291bnQoIHJlbmRlck9iamVjdCApIHtcclxuXHJcblx0XHRjb25zdCB7IG9iamVjdCwgZ2VvbWV0cnkgfSA9IHJlbmRlck9iamVjdDtcclxuXHJcblx0XHRyZXR1cm4gZ2VvbWV0cnkuaXNJbnN0YW5jZWRCdWZmZXJHZW9tZXRyeSA/IGdlb21ldHJ5Lmluc3RhbmNlQ291bnQgOiAoIG9iamVjdC5jb3VudCA+IDEgPyBvYmplY3QuY291bnQgOiAxICk7XHJcblxyXG5cdH1cclxuXHJcblx0Z2V0RHJhd2luZ0J1ZmZlclNpemUoKSB7XHJcblxyXG5cdFx0dmVjdG9yMiA9IHZlY3RvcjIgfHwgbmV3IFZlY3RvcjIoKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5yZW5kZXJlci5nZXREcmF3aW5nQnVmZmVyU2l6ZSggdmVjdG9yMiApO1xyXG5cclxuXHR9XHJcblxyXG5cdGdldFNjaXNzb3IoKSB7XHJcblxyXG5cdFx0dmVjdG9yNCA9IHZlY3RvcjQgfHwgbmV3IFZlY3RvcjQoKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5yZW5kZXJlci5nZXRTY2lzc29yKCB2ZWN0b3I0ICk7XHJcblxyXG5cdH1cclxuXHJcblx0c2V0U2Npc3NvclRlc3QoIC8qYm9vbGVhbiovICkgeyB9XHJcblxyXG5cdGdldENsZWFyQ29sb3IoKSB7XHJcblxyXG5cdFx0Y29uc3QgcmVuZGVyZXIgPSB0aGlzLnJlbmRlcmVyO1xyXG5cclxuXHRcdGNvbG9yNCA9IGNvbG9yNCB8fCBuZXcgQ29sb3I0KCk7XHJcblxyXG5cdFx0cmVuZGVyZXIuZ2V0Q2xlYXJDb2xvciggY29sb3I0ICk7XHJcblxyXG5cdFx0Y29sb3I0LmdldFJHQiggY29sb3I0LCB0aGlzLnJlbmRlcmVyLmN1cnJlbnRDb2xvclNwYWNlICk7XHJcblxyXG5cdFx0cmV0dXJuIGNvbG9yNDtcclxuXHJcblx0fVxyXG5cclxuXHRnZXREb21FbGVtZW50KCkge1xyXG5cclxuXHRcdGxldCBkb21FbGVtZW50ID0gdGhpcy5kb21FbGVtZW50O1xyXG5cclxuXHRcdGlmICggZG9tRWxlbWVudCA9PT0gbnVsbCApIHtcclxuXHJcblx0XHRcdGRvbUVsZW1lbnQgPSAoIHRoaXMucGFyYW1ldGVycy5jYW52YXMgIT09IHVuZGVmaW5lZCApID8gdGhpcy5wYXJhbWV0ZXJzLmNhbnZhcyA6IGNyZWF0ZUNhbnZhc0VsZW1lbnQoKTtcclxuXHJcblx0XHRcdC8vIE9mZnNjcmVlbkNhbnZhcyBkb2VzIG5vdCBoYXZlIHNldEF0dHJpYnV0ZSwgc2VlICMyMjgxMVxyXG5cdFx0XHRpZiAoICdzZXRBdHRyaWJ1dGUnIGluIGRvbUVsZW1lbnQgKSBkb21FbGVtZW50LnNldEF0dHJpYnV0ZSggJ2RhdGEtZW5naW5lJywgYHRocmVlLmpzIHIke1JFVklTSU9OfSB3ZWJncHVgICk7XHJcblxyXG5cdFx0XHR0aGlzLmRvbUVsZW1lbnQgPSBkb21FbGVtZW50O1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gZG9tRWxlbWVudDtcclxuXHJcblx0fVxyXG5cclxuXHQvLyByZXNvdXJjZSBwcm9wZXJ0aWVzXHJcblxyXG5cdHNldCggb2JqZWN0LCB2YWx1ZSApIHtcclxuXHJcblx0XHR0aGlzLmRhdGEuc2V0KCBvYmplY3QsIHZhbHVlICk7XHJcblxyXG5cdH1cclxuXHJcblx0Z2V0KCBvYmplY3QgKSB7XHJcblxyXG5cdFx0bGV0IG1hcCA9IHRoaXMuZGF0YS5nZXQoIG9iamVjdCApO1xyXG5cclxuXHRcdGlmICggbWFwID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRtYXAgPSB7fTtcclxuXHRcdFx0dGhpcy5kYXRhLnNldCggb2JqZWN0LCBtYXAgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIG1hcDtcclxuXHJcblx0fVxyXG5cclxuXHRoYXMoIG9iamVjdCApIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5kYXRhLmhhcyggb2JqZWN0ICk7XHJcblxyXG5cdH1cclxuXHJcblx0ZGVsZXRlKCBvYmplY3QgKSB7XHJcblxyXG5cdFx0dGhpcy5kYXRhLmRlbGV0ZSggb2JqZWN0ICk7XHJcblxyXG5cdH1cclxuXHJcblx0ZGlzcG9zZSgpIHsgfVxyXG5cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgQmFja2VuZDtcclxuIiwiaW1wb3J0IHsgSW50VHlwZSB9IGZyb20gJy4uLy4uLy4uL2NvbnN0YW50cy5qcyc7XHJcblxyXG5sZXQgX2lkID0gMDtcclxuXHJcbmNsYXNzIER1YWxBdHRyaWJ1dGVEYXRhIHtcclxuXHJcblx0Y29uc3RydWN0b3IoIGF0dHJpYnV0ZURhdGEsIGR1YWxCdWZmZXIgKSB7XHJcblxyXG5cdFx0dGhpcy5idWZmZXJzID0gWyBhdHRyaWJ1dGVEYXRhLmJ1ZmZlckdQVSwgZHVhbEJ1ZmZlciBdO1xyXG5cdFx0dGhpcy50eXBlID0gYXR0cmlidXRlRGF0YS50eXBlO1xyXG5cdFx0dGhpcy5idWZmZXJUeXBlID0gYXR0cmlidXRlRGF0YS5idWZmZXJUeXBlO1xyXG5cdFx0dGhpcy5wYm8gPSBhdHRyaWJ1dGVEYXRhLnBibztcclxuXHRcdHRoaXMuYnl0ZUxlbmd0aCA9IGF0dHJpYnV0ZURhdGEuYnl0ZUxlbmd0aDtcclxuXHRcdHRoaXMuYnl0ZXNQZXJFbGVtZW50ID0gYXR0cmlidXRlRGF0YS5CWVRFU19QRVJfRUxFTUVOVDtcclxuXHRcdHRoaXMudmVyc2lvbiA9IGF0dHJpYnV0ZURhdGEudmVyc2lvbjtcclxuXHRcdHRoaXMuaXNJbnRlZ2VyID0gYXR0cmlidXRlRGF0YS5pc0ludGVnZXI7XHJcblx0XHR0aGlzLmFjdGl2ZUJ1ZmZlckluZGV4ID0gMDtcclxuXHRcdHRoaXMuYmFzZUlkID0gYXR0cmlidXRlRGF0YS5pZDtcclxuXHJcblx0fVxyXG5cclxuXHJcblx0Z2V0IGlkKCkge1xyXG5cclxuXHRcdHJldHVybiBgJHsgdGhpcy5iYXNlSWQgfXwkeyB0aGlzLmFjdGl2ZUJ1ZmZlckluZGV4IH1gO1xyXG5cclxuXHR9XHJcblxyXG5cdGdldCBidWZmZXJHUFUoKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuYnVmZmVyc1sgdGhpcy5hY3RpdmVCdWZmZXJJbmRleCBdO1xyXG5cclxuXHR9XHJcblxyXG5cdGdldCB0cmFuc2Zvcm1CdWZmZXIoKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuYnVmZmVyc1sgdGhpcy5hY3RpdmVCdWZmZXJJbmRleCBeIDEgXTtcclxuXHJcblx0fVxyXG5cclxuXHRzd2l0Y2hCdWZmZXJzKCkge1xyXG5cclxuXHRcdHRoaXMuYWN0aXZlQnVmZmVySW5kZXggXj0gMTtcclxuXHJcblx0fVxyXG5cclxufVxyXG5cclxuY2xhc3MgV2ViR0xBdHRyaWJ1dGVVdGlscyB7XHJcblxyXG5cdGNvbnN0cnVjdG9yKCBiYWNrZW5kICkge1xyXG5cclxuXHRcdHRoaXMuYmFja2VuZCA9IGJhY2tlbmQ7XHJcblxyXG5cdH1cclxuXHJcblx0Y3JlYXRlQXR0cmlidXRlKCBhdHRyaWJ1dGUsIGJ1ZmZlclR5cGUgKSB7XHJcblxyXG5cdFx0Y29uc3QgYmFja2VuZCA9IHRoaXMuYmFja2VuZDtcclxuXHRcdGNvbnN0IHsgZ2wgfSA9IGJhY2tlbmQ7XHJcblxyXG5cdFx0Y29uc3QgYXJyYXkgPSBhdHRyaWJ1dGUuYXJyYXk7XHJcblx0XHRjb25zdCB1c2FnZSA9IGF0dHJpYnV0ZS51c2FnZSB8fCBnbC5TVEFUSUNfRFJBVztcclxuXHJcblx0XHRjb25zdCBidWZmZXJBdHRyaWJ1dGUgPSBhdHRyaWJ1dGUuaXNJbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZSA/IGF0dHJpYnV0ZS5kYXRhIDogYXR0cmlidXRlO1xyXG5cdFx0Y29uc3QgYnVmZmVyRGF0YSA9IGJhY2tlbmQuZ2V0KCBidWZmZXJBdHRyaWJ1dGUgKTtcclxuXHJcblx0XHRsZXQgYnVmZmVyR1BVID0gYnVmZmVyRGF0YS5idWZmZXJHUFU7XHJcblxyXG5cdFx0aWYgKCBidWZmZXJHUFUgPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdGJ1ZmZlckdQVSA9IHRoaXMuX2NyZWF0ZUJ1ZmZlciggZ2wsIGJ1ZmZlclR5cGUsIGFycmF5LCB1c2FnZSApO1xyXG5cclxuXHRcdFx0YnVmZmVyRGF0YS5idWZmZXJHUFUgPSBidWZmZXJHUFU7XHJcblx0XHRcdGJ1ZmZlckRhdGEuYnVmZmVyVHlwZSA9IGJ1ZmZlclR5cGU7XHJcblx0XHRcdGJ1ZmZlckRhdGEudmVyc2lvbiA9IGJ1ZmZlckF0dHJpYnV0ZS52ZXJzaW9uO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvL2F0dHJpYnV0ZS5vblVwbG9hZENhbGxiYWNrKCk7XHJcblxyXG5cdFx0bGV0IHR5cGU7XHJcblxyXG5cdFx0aWYgKCBhcnJheSBpbnN0YW5jZW9mIEZsb2F0MzJBcnJheSApIHtcclxuXHJcblx0XHRcdHR5cGUgPSBnbC5GTE9BVDtcclxuXHJcblx0XHR9IGVsc2UgaWYgKCBhcnJheSBpbnN0YW5jZW9mIFVpbnQxNkFycmF5ICkge1xyXG5cclxuXHRcdFx0aWYgKCBhdHRyaWJ1dGUuaXNGbG9hdDE2QnVmZmVyQXR0cmlidXRlICkge1xyXG5cclxuXHRcdFx0XHR0eXBlID0gZ2wuSEFMRl9GTE9BVDtcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdHR5cGUgPSBnbC5VTlNJR05FRF9TSE9SVDtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9IGVsc2UgaWYgKCBhcnJheSBpbnN0YW5jZW9mIEludDE2QXJyYXkgKSB7XHJcblxyXG5cdFx0XHR0eXBlID0gZ2wuU0hPUlQ7XHJcblxyXG5cdFx0fSBlbHNlIGlmICggYXJyYXkgaW5zdGFuY2VvZiBVaW50MzJBcnJheSApIHtcclxuXHJcblx0XHRcdHR5cGUgPSBnbC5VTlNJR05FRF9JTlQ7XHJcblxyXG5cdFx0fSBlbHNlIGlmICggYXJyYXkgaW5zdGFuY2VvZiBJbnQzMkFycmF5ICkge1xyXG5cclxuXHRcdFx0dHlwZSA9IGdsLklOVDtcclxuXHJcblx0XHR9IGVsc2UgaWYgKCBhcnJheSBpbnN0YW5jZW9mIEludDhBcnJheSApIHtcclxuXHJcblx0XHRcdHR5cGUgPSBnbC5CWVRFO1xyXG5cclxuXHRcdH0gZWxzZSBpZiAoIGFycmF5IGluc3RhbmNlb2YgVWludDhBcnJheSApIHtcclxuXHJcblx0XHRcdHR5cGUgPSBnbC5VTlNJR05FRF9CWVRFO1xyXG5cclxuXHRcdH0gZWxzZSBpZiAoIGFycmF5IGluc3RhbmNlb2YgVWludDhDbGFtcGVkQXJyYXkgKSB7XHJcblxyXG5cdFx0XHR0eXBlID0gZ2wuVU5TSUdORURfQllURTtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCAnVEhSRUUuV2ViR0xCYWNrZW5kOiBVbnN1cHBvcnRlZCBidWZmZXIgZGF0YSBmb3JtYXQ6ICcgKyBhcnJheSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRsZXQgYXR0cmlidXRlRGF0YSA9IHtcclxuXHRcdFx0YnVmZmVyR1BVLFxyXG5cdFx0XHRidWZmZXJUeXBlLFxyXG5cdFx0XHR0eXBlLFxyXG5cdFx0XHRieXRlTGVuZ3RoOiBhcnJheS5ieXRlTGVuZ3RoLFxyXG5cdFx0XHRieXRlc1BlckVsZW1lbnQ6IGFycmF5LkJZVEVTX1BFUl9FTEVNRU5ULFxyXG5cdFx0XHR2ZXJzaW9uOiBhdHRyaWJ1dGUudmVyc2lvbixcclxuXHRcdFx0cGJvOiBhdHRyaWJ1dGUucGJvLFxyXG5cdFx0XHRpc0ludGVnZXI6IHR5cGUgPT09IGdsLklOVCB8fCB0eXBlID09PSBnbC5VTlNJR05FRF9JTlQgfHwgYXR0cmlidXRlLmdwdVR5cGUgPT09IEludFR5cGUsXHJcblx0XHRcdGlkOiBfaWQgKytcclxuXHRcdH07XHJcblxyXG5cdFx0aWYgKCBhdHRyaWJ1dGUuaXNTdG9yYWdlQnVmZmVyQXR0cmlidXRlIHx8IGF0dHJpYnV0ZS5pc1N0b3JhZ2VJbnN0YW5jZWRCdWZmZXJBdHRyaWJ1dGUgKSB7XHJcblxyXG5cdFx0XHQvLyBjcmVhdGUgYnVmZmVyIGZvciB0cmFuZm9ybSBmZWVkYmFjayB1c2VcclxuXHRcdFx0Y29uc3QgYnVmZmVyR1BVRHVhbCA9IHRoaXMuX2NyZWF0ZUJ1ZmZlciggZ2wsIGJ1ZmZlclR5cGUsIGFycmF5LCB1c2FnZSApO1xyXG5cdFx0XHRhdHRyaWJ1dGVEYXRhID0gbmV3IER1YWxBdHRyaWJ1dGVEYXRhKCBhdHRyaWJ1dGVEYXRhLCBidWZmZXJHUFVEdWFsICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGJhY2tlbmQuc2V0KCBhdHRyaWJ1dGUsIGF0dHJpYnV0ZURhdGEgKTtcclxuXHJcblx0fVxyXG5cclxuXHR1cGRhdGVBdHRyaWJ1dGUoIGF0dHJpYnV0ZSApIHtcclxuXHJcblx0XHRjb25zdCBiYWNrZW5kID0gdGhpcy5iYWNrZW5kO1xyXG5cdFx0Y29uc3QgeyBnbCB9ID0gYmFja2VuZDtcclxuXHJcblx0XHRjb25zdCBhcnJheSA9IGF0dHJpYnV0ZS5hcnJheTtcclxuXHRcdGNvbnN0IGJ1ZmZlckF0dHJpYnV0ZSA9IGF0dHJpYnV0ZS5pc0ludGVybGVhdmVkQnVmZmVyQXR0cmlidXRlID8gYXR0cmlidXRlLmRhdGEgOiBhdHRyaWJ1dGU7XHJcblx0XHRjb25zdCBidWZmZXJEYXRhID0gYmFja2VuZC5nZXQoIGJ1ZmZlckF0dHJpYnV0ZSApO1xyXG5cdFx0Y29uc3QgYnVmZmVyVHlwZSA9IGJ1ZmZlckRhdGEuYnVmZmVyVHlwZTtcclxuXHRcdGNvbnN0IHVwZGF0ZVJhbmdlcyA9IGF0dHJpYnV0ZS5pc0ludGVybGVhdmVkQnVmZmVyQXR0cmlidXRlID8gYXR0cmlidXRlLmRhdGEudXBkYXRlUmFuZ2VzIDogYXR0cmlidXRlLnVwZGF0ZVJhbmdlcztcclxuXHJcblx0XHRnbC5iaW5kQnVmZmVyKCBidWZmZXJUeXBlLCBidWZmZXJEYXRhLmJ1ZmZlckdQVSApO1xyXG5cclxuXHRcdGlmICggdXBkYXRlUmFuZ2VzLmxlbmd0aCA9PT0gMCApIHtcclxuXHJcblx0XHRcdC8vIE5vdCB1c2luZyB1cGRhdGUgcmFuZ2VzXHJcblxyXG5cdFx0XHRnbC5idWZmZXJTdWJEYXRhKCBidWZmZXJUeXBlLCAwLCBhcnJheSApO1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSB1cGRhdGVSYW5nZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0Y29uc3QgcmFuZ2UgPSB1cGRhdGVSYW5nZXNbIGkgXTtcclxuXHRcdFx0XHRnbC5idWZmZXJTdWJEYXRhKCBidWZmZXJUeXBlLCByYW5nZS5zdGFydCAqIGFycmF5LkJZVEVTX1BFUl9FTEVNRU5ULFxyXG5cdFx0XHRcdFx0YXJyYXksIHJhbmdlLnN0YXJ0LCByYW5nZS5jb3VudCApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0YnVmZmVyQXR0cmlidXRlLmNsZWFyVXBkYXRlUmFuZ2VzKCk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGdsLmJpbmRCdWZmZXIoIGJ1ZmZlclR5cGUsIG51bGwgKTtcclxuXHJcblx0XHRidWZmZXJEYXRhLnZlcnNpb24gPSBidWZmZXJBdHRyaWJ1dGUudmVyc2lvbjtcclxuXHJcblx0fVxyXG5cclxuXHRkZXN0cm95QXR0cmlidXRlKCBhdHRyaWJ1dGUgKSB7XHJcblxyXG5cdFx0Y29uc3QgYmFja2VuZCA9IHRoaXMuYmFja2VuZDtcclxuXHRcdGNvbnN0IHsgZ2wgfSA9IGJhY2tlbmQ7XHJcblxyXG5cdFx0aWYgKCBhdHRyaWJ1dGUuaXNJbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZSApIHtcclxuXHJcblx0XHRcdGJhY2tlbmQuZGVsZXRlKCBhdHRyaWJ1dGUuZGF0YSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRjb25zdCBhdHRyaWJ1dGVEYXRhID0gYmFja2VuZC5nZXQoIGF0dHJpYnV0ZSApO1xyXG5cclxuXHRcdGdsLmRlbGV0ZUJ1ZmZlciggYXR0cmlidXRlRGF0YS5idWZmZXJHUFUgKTtcclxuXHJcblx0XHRiYWNrZW5kLmRlbGV0ZSggYXR0cmlidXRlICk7XHJcblxyXG5cdH1cclxuXHJcblx0YXN5bmMgZ2V0QXJyYXlCdWZmZXJBc3luYyggYXR0cmlidXRlICkge1xyXG5cclxuXHRcdGNvbnN0IGJhY2tlbmQgPSB0aGlzLmJhY2tlbmQ7XHJcblx0XHRjb25zdCB7IGdsIH0gPSBiYWNrZW5kO1xyXG5cclxuXHRcdGNvbnN0IGJ1ZmZlckF0dHJpYnV0ZSA9IGF0dHJpYnV0ZS5pc0ludGVybGVhdmVkQnVmZmVyQXR0cmlidXRlID8gYXR0cmlidXRlLmRhdGEgOiBhdHRyaWJ1dGU7XHJcblx0XHRjb25zdCB7IGJ1ZmZlckdQVSB9ID0gYmFja2VuZC5nZXQoIGJ1ZmZlckF0dHJpYnV0ZSApO1xyXG5cclxuXHRcdGNvbnN0IGFycmF5ID0gYXR0cmlidXRlLmFycmF5O1xyXG5cdFx0Y29uc3QgYnl0ZUxlbmd0aCA9IGFycmF5LmJ5dGVMZW5ndGg7XHJcblxyXG5cdFx0Z2wuYmluZEJ1ZmZlciggZ2wuQ09QWV9SRUFEX0JVRkZFUiwgYnVmZmVyR1BVICk7XHJcblxyXG5cdFx0Y29uc3Qgd3JpdGVCdWZmZXIgPSBnbC5jcmVhdGVCdWZmZXIoKTtcclxuXHJcblx0XHRnbC5iaW5kQnVmZmVyKCBnbC5DT1BZX1dSSVRFX0JVRkZFUiwgd3JpdGVCdWZmZXIgKTtcclxuXHRcdGdsLmJ1ZmZlckRhdGEoIGdsLkNPUFlfV1JJVEVfQlVGRkVSLCBieXRlTGVuZ3RoLCBnbC5TVFJFQU1fUkVBRCApO1xyXG5cclxuXHRcdGdsLmNvcHlCdWZmZXJTdWJEYXRhKCBnbC5DT1BZX1JFQURfQlVGRkVSLCBnbC5DT1BZX1dSSVRFX0JVRkZFUiwgMCwgMCwgYnl0ZUxlbmd0aCApO1xyXG5cclxuXHRcdGF3YWl0IGJhY2tlbmQudXRpbHMuX2NsaWVudFdhaXRBc3luYygpO1xyXG5cclxuXHRcdGNvbnN0IGRzdEJ1ZmZlciA9IG5ldyBhdHRyaWJ1dGUuYXJyYXkuY29uc3RydWN0b3IoIGFycmF5Lmxlbmd0aCApO1xyXG5cclxuXHRcdC8vIEVuc3VyZSB0aGUgYnVmZmVyIGlzIGJvdW5kIGJlZm9yZSByZWFkaW5nXHJcblx0XHRnbC5iaW5kQnVmZmVyKCBnbC5DT1BZX1dSSVRFX0JVRkZFUiwgd3JpdGVCdWZmZXIgKTtcclxuXHJcblx0XHRnbC5nZXRCdWZmZXJTdWJEYXRhKCBnbC5DT1BZX1dSSVRFX0JVRkZFUiwgMCwgZHN0QnVmZmVyICk7XHJcblxyXG5cdFx0Z2wuZGVsZXRlQnVmZmVyKCB3cml0ZUJ1ZmZlciApO1xyXG5cclxuXHRcdGdsLmJpbmRCdWZmZXIoIGdsLkNPUFlfUkVBRF9CVUZGRVIsIG51bGwgKTtcclxuXHRcdGdsLmJpbmRCdWZmZXIoIGdsLkNPUFlfV1JJVEVfQlVGRkVSLCBudWxsICk7XHJcblxyXG5cdFx0cmV0dXJuIGRzdEJ1ZmZlci5idWZmZXI7XHJcblxyXG5cdH1cclxuXHJcblx0X2NyZWF0ZUJ1ZmZlciggZ2wsIGJ1ZmZlclR5cGUsIGFycmF5LCB1c2FnZSApIHtcclxuXHJcblx0XHRjb25zdCBidWZmZXJHUFUgPSBnbC5jcmVhdGVCdWZmZXIoKTtcclxuXHJcblx0XHRnbC5iaW5kQnVmZmVyKCBidWZmZXJUeXBlLCBidWZmZXJHUFUgKTtcclxuXHRcdGdsLmJ1ZmZlckRhdGEoIGJ1ZmZlclR5cGUsIGFycmF5LCB1c2FnZSApO1xyXG5cdFx0Z2wuYmluZEJ1ZmZlciggYnVmZmVyVHlwZSwgbnVsbCApO1xyXG5cclxuXHRcdHJldHVybiBidWZmZXJHUFU7XHJcblxyXG5cdH1cclxuXHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IFdlYkdMQXR0cmlidXRlVXRpbHM7XHJcbiIsImltcG9ydCB7XHJcblx0Q3VsbEZhY2VOb25lLCBDdWxsRmFjZUJhY2ssIEN1bGxGYWNlRnJvbnQsIERvdWJsZVNpZGUsIEJhY2tTaWRlLFxyXG5cdE5vcm1hbEJsZW5kaW5nLCBOb0JsZW5kaW5nLCBDdXN0b21CbGVuZGluZywgQWRkRXF1YXRpb24sXHJcblx0QWRkaXRpdmVCbGVuZGluZywgU3VidHJhY3RpdmVCbGVuZGluZywgTXVsdGlwbHlCbGVuZGluZywgU3VidHJhY3RFcXVhdGlvbiwgUmV2ZXJzZVN1YnRyYWN0RXF1YXRpb24sXHJcblx0WmVyb0ZhY3RvciwgT25lRmFjdG9yLCBTcmNDb2xvckZhY3RvciwgU3JjQWxwaGFGYWN0b3IsIFNyY0FscGhhU2F0dXJhdGVGYWN0b3IsIERzdENvbG9yRmFjdG9yLCBEc3RBbHBoYUZhY3RvcixcclxuXHRPbmVNaW51c1NyY0NvbG9yRmFjdG9yLCBPbmVNaW51c1NyY0FscGhhRmFjdG9yLCBPbmVNaW51c0RzdENvbG9yRmFjdG9yLCBPbmVNaW51c0RzdEFscGhhRmFjdG9yLFxyXG5cdE5ldmVyRGVwdGgsIEFsd2F5c0RlcHRoLCBMZXNzRGVwdGgsIExlc3NFcXVhbERlcHRoLCBFcXVhbERlcHRoLCBHcmVhdGVyRXF1YWxEZXB0aCwgR3JlYXRlckRlcHRoLCBOb3RFcXVhbERlcHRoXHJcbn0gZnJvbSAnLi4vLi4vLi4vY29uc3RhbnRzLmpzJztcclxuXHJcbmxldCBpbml0aWFsaXplZCA9IGZhbHNlLCBlcXVhdGlvblRvR0wsIGZhY3RvclRvR0w7XHJcblxyXG5jbGFzcyBXZWJHTFN0YXRlIHtcclxuXHJcblx0Y29uc3RydWN0b3IoIGJhY2tlbmQgKSB7XHJcblxyXG5cdFx0dGhpcy5iYWNrZW5kID0gYmFja2VuZDtcclxuXHJcblx0XHR0aGlzLmdsID0gdGhpcy5iYWNrZW5kLmdsO1xyXG5cclxuXHRcdHRoaXMuZW5hYmxlZCA9IHt9O1xyXG5cdFx0dGhpcy5jdXJyZW50RmxpcFNpZGVkID0gbnVsbDtcclxuXHRcdHRoaXMuY3VycmVudEN1bGxGYWNlID0gbnVsbDtcclxuXHRcdHRoaXMuY3VycmVudFByb2dyYW0gPSBudWxsO1xyXG5cdFx0dGhpcy5jdXJyZW50QmxlbmRpbmdFbmFibGVkID0gZmFsc2U7XHJcblx0XHR0aGlzLmN1cnJlbnRCbGVuZGluZyA9IG51bGw7XHJcblx0XHR0aGlzLmN1cnJlbnRCbGVuZFNyYyA9IG51bGw7XHJcblx0XHR0aGlzLmN1cnJlbnRCbGVuZERzdCA9IG51bGw7XHJcblx0XHR0aGlzLmN1cnJlbnRCbGVuZFNyY0FscGhhID0gbnVsbDtcclxuXHRcdHRoaXMuY3VycmVudEJsZW5kRHN0QWxwaGEgPSBudWxsO1xyXG5cdFx0dGhpcy5jdXJyZW50UHJlbXVsdGlwbGVkQWxwaGEgPSBudWxsO1xyXG5cdFx0dGhpcy5jdXJyZW50UG9seWdvbk9mZnNldEZhY3RvciA9IG51bGw7XHJcblx0XHR0aGlzLmN1cnJlbnRQb2x5Z29uT2Zmc2V0VW5pdHMgPSBudWxsO1xyXG5cdFx0dGhpcy5jdXJyZW50Q29sb3JNYXNrID0gbnVsbDtcclxuXHRcdHRoaXMuY3VycmVudERlcHRoRnVuYyA9IG51bGw7XHJcblx0XHR0aGlzLmN1cnJlbnREZXB0aE1hc2sgPSBudWxsO1xyXG5cdFx0dGhpcy5jdXJyZW50U3RlbmNpbEZ1bmMgPSBudWxsO1xyXG5cdFx0dGhpcy5jdXJyZW50U3RlbmNpbFJlZiA9IG51bGw7XHJcblx0XHR0aGlzLmN1cnJlbnRTdGVuY2lsRnVuY01hc2sgPSBudWxsO1xyXG5cdFx0dGhpcy5jdXJyZW50U3RlbmNpbEZhaWwgPSBudWxsO1xyXG5cdFx0dGhpcy5jdXJyZW50U3RlbmNpbFpGYWlsID0gbnVsbDtcclxuXHRcdHRoaXMuY3VycmVudFN0ZW5jaWxaUGFzcyA9IG51bGw7XHJcblx0XHR0aGlzLmN1cnJlbnRTdGVuY2lsTWFzayA9IG51bGw7XHJcblx0XHR0aGlzLmN1cnJlbnRMaW5lV2lkdGggPSBudWxsO1xyXG5cdFx0dGhpcy5jdXJyZW50Q2xpcHBpbmdQbGFuZXMgPSAwO1xyXG5cclxuXHRcdHRoaXMuY3VycmVudEJvdW5kRnJhbWVidWZmZXJzID0ge307XHJcblx0XHR0aGlzLmN1cnJlbnREcmF3YnVmZmVycyA9IG5ldyBXZWFrTWFwKCk7XHJcblxyXG5cdFx0dGhpcy5tYXhUZXh0dXJlcyA9IHRoaXMuZ2wuZ2V0UGFyYW1ldGVyKCB0aGlzLmdsLk1BWF9URVhUVVJFX0lNQUdFX1VOSVRTICk7XHJcblx0XHR0aGlzLmN1cnJlbnRUZXh0dXJlU2xvdCA9IG51bGw7XHJcblx0XHR0aGlzLmN1cnJlbnRCb3VuZFRleHR1cmVzID0ge307XHJcblx0XHR0aGlzLmN1cnJlbnRCb3VuZEJ1ZmZlckJhc2VzID0ge307XHJcblxyXG5cdFx0aWYgKCBpbml0aWFsaXplZCA9PT0gZmFsc2UgKSB7XHJcblxyXG5cdFx0XHR0aGlzLl9pbml0KCB0aGlzLmdsICk7XHJcblxyXG5cdFx0XHRpbml0aWFsaXplZCA9IHRydWU7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdF9pbml0KCBnbCApIHtcclxuXHJcblx0XHQvLyBTdG9yZSBvbmx5IFdlYkdMIGNvbnN0YW50cyBoZXJlLlxyXG5cclxuXHRcdGVxdWF0aW9uVG9HTCA9IHtcclxuXHRcdFx0WyBBZGRFcXVhdGlvbiBdOiBnbC5GVU5DX0FERCxcclxuXHRcdFx0WyBTdWJ0cmFjdEVxdWF0aW9uIF06IGdsLkZVTkNfU1VCVFJBQ1QsXHJcblx0XHRcdFsgUmV2ZXJzZVN1YnRyYWN0RXF1YXRpb24gXTogZ2wuRlVOQ19SRVZFUlNFX1NVQlRSQUNUXHJcblx0XHR9O1xyXG5cclxuXHRcdGZhY3RvclRvR0wgPSB7XHJcblx0XHRcdFsgWmVyb0ZhY3RvciBdOiBnbC5aRVJPLFxyXG5cdFx0XHRbIE9uZUZhY3RvciBdOiBnbC5PTkUsXHJcblx0XHRcdFsgU3JjQ29sb3JGYWN0b3IgXTogZ2wuU1JDX0NPTE9SLFxyXG5cdFx0XHRbIFNyY0FscGhhRmFjdG9yIF06IGdsLlNSQ19BTFBIQSxcclxuXHRcdFx0WyBTcmNBbHBoYVNhdHVyYXRlRmFjdG9yIF06IGdsLlNSQ19BTFBIQV9TQVRVUkFURSxcclxuXHRcdFx0WyBEc3RDb2xvckZhY3RvciBdOiBnbC5EU1RfQ09MT1IsXHJcblx0XHRcdFsgRHN0QWxwaGFGYWN0b3IgXTogZ2wuRFNUX0FMUEhBLFxyXG5cdFx0XHRbIE9uZU1pbnVzU3JjQ29sb3JGYWN0b3IgXTogZ2wuT05FX01JTlVTX1NSQ19DT0xPUixcclxuXHRcdFx0WyBPbmVNaW51c1NyY0FscGhhRmFjdG9yIF06IGdsLk9ORV9NSU5VU19TUkNfQUxQSEEsXHJcblx0XHRcdFsgT25lTWludXNEc3RDb2xvckZhY3RvciBdOiBnbC5PTkVfTUlOVVNfRFNUX0NPTE9SLFxyXG5cdFx0XHRbIE9uZU1pbnVzRHN0QWxwaGFGYWN0b3IgXTogZ2wuT05FX01JTlVTX0RTVF9BTFBIQVxyXG5cdFx0fTtcclxuXHJcblx0fVxyXG5cclxuXHRlbmFibGUoIGlkICkge1xyXG5cclxuXHRcdGNvbnN0IHsgZW5hYmxlZCB9ID0gdGhpcztcclxuXHJcblx0XHRpZiAoIGVuYWJsZWRbIGlkIF0gIT09IHRydWUgKSB7XHJcblxyXG5cdFx0XHR0aGlzLmdsLmVuYWJsZSggaWQgKTtcclxuXHRcdFx0ZW5hYmxlZFsgaWQgXSA9IHRydWU7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdGRpc2FibGUoIGlkICkge1xyXG5cclxuXHRcdGNvbnN0IHsgZW5hYmxlZCB9ID0gdGhpcztcclxuXHJcblx0XHRpZiAoIGVuYWJsZWRbIGlkIF0gIT09IGZhbHNlICkge1xyXG5cclxuXHRcdFx0dGhpcy5nbC5kaXNhYmxlKCBpZCApO1xyXG5cdFx0XHRlbmFibGVkWyBpZCBdID0gZmFsc2U7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdHNldEZsaXBTaWRlZCggZmxpcFNpZGVkICkge1xyXG5cclxuXHRcdGlmICggdGhpcy5jdXJyZW50RmxpcFNpZGVkICE9PSBmbGlwU2lkZWQgKSB7XHJcblxyXG5cdFx0XHRjb25zdCB7IGdsIH0gPSB0aGlzO1xyXG5cclxuXHRcdFx0aWYgKCBmbGlwU2lkZWQgKSB7XHJcblxyXG5cdFx0XHRcdGdsLmZyb250RmFjZSggZ2wuQ1cgKTtcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdGdsLmZyb250RmFjZSggZ2wuQ0NXICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR0aGlzLmN1cnJlbnRGbGlwU2lkZWQgPSBmbGlwU2lkZWQ7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdHNldEN1bGxGYWNlKCBjdWxsRmFjZSApIHtcclxuXHJcblx0XHRjb25zdCB7IGdsIH0gPSB0aGlzO1xyXG5cclxuXHRcdGlmICggY3VsbEZhY2UgIT09IEN1bGxGYWNlTm9uZSApIHtcclxuXHJcblx0XHRcdHRoaXMuZW5hYmxlKCBnbC5DVUxMX0ZBQ0UgKTtcclxuXHJcblx0XHRcdGlmICggY3VsbEZhY2UgIT09IHRoaXMuY3VycmVudEN1bGxGYWNlICkge1xyXG5cclxuXHRcdFx0XHRpZiAoIGN1bGxGYWNlID09PSBDdWxsRmFjZUJhY2sgKSB7XHJcblxyXG5cdFx0XHRcdFx0Z2wuY3VsbEZhY2UoIGdsLkJBQ0sgKTtcclxuXHJcblx0XHRcdFx0fSBlbHNlIGlmICggY3VsbEZhY2UgPT09IEN1bGxGYWNlRnJvbnQgKSB7XHJcblxyXG5cdFx0XHRcdFx0Z2wuY3VsbEZhY2UoIGdsLkZST05UICk7XHJcblxyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0Z2wuY3VsbEZhY2UoIGdsLkZST05UX0FORF9CQUNLICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0dGhpcy5kaXNhYmxlKCBnbC5DVUxMX0ZBQ0UgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5jdXJyZW50Q3VsbEZhY2UgPSBjdWxsRmFjZTtcclxuXHJcblx0fVxyXG5cclxuXHRzZXRMaW5lV2lkdGgoIHdpZHRoICkge1xyXG5cclxuXHRcdGNvbnN0IHsgY3VycmVudExpbmVXaWR0aCwgZ2wgfSA9IHRoaXM7XHJcblxyXG5cdFx0aWYgKCB3aWR0aCAhPT0gY3VycmVudExpbmVXaWR0aCApIHtcclxuXHJcblx0XHRcdGdsLmxpbmVXaWR0aCggd2lkdGggKTtcclxuXHJcblx0XHRcdHRoaXMuY3VycmVudExpbmVXaWR0aCA9IHdpZHRoO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHJcblx0c2V0QmxlbmRpbmcoIGJsZW5kaW5nLCBibGVuZEVxdWF0aW9uLCBibGVuZFNyYywgYmxlbmREc3QsIGJsZW5kRXF1YXRpb25BbHBoYSwgYmxlbmRTcmNBbHBoYSwgYmxlbmREc3RBbHBoYSwgcHJlbXVsdGlwbGllZEFscGhhICkge1xyXG5cclxuXHRcdGNvbnN0IHsgZ2wgfSA9IHRoaXM7XHJcblxyXG5cdFx0aWYgKCBibGVuZGluZyA9PT0gTm9CbGVuZGluZyApIHtcclxuXHJcblx0XHRcdGlmICggdGhpcy5jdXJyZW50QmxlbmRpbmdFbmFibGVkID09PSB0cnVlICkge1xyXG5cclxuXHRcdFx0XHR0aGlzLmRpc2FibGUoIGdsLkJMRU5EICk7XHJcblx0XHRcdFx0dGhpcy5jdXJyZW50QmxlbmRpbmdFbmFibGVkID0gZmFsc2U7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRyZXR1cm47XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggdGhpcy5jdXJyZW50QmxlbmRpbmdFbmFibGVkID09PSBmYWxzZSApIHtcclxuXHJcblx0XHRcdHRoaXMuZW5hYmxlKCBnbC5CTEVORCApO1xyXG5cdFx0XHR0aGlzLmN1cnJlbnRCbGVuZGluZ0VuYWJsZWQgPSB0cnVlO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIGJsZW5kaW5nICE9PSBDdXN0b21CbGVuZGluZyApIHtcclxuXHJcblx0XHRcdGlmICggYmxlbmRpbmcgIT09IHRoaXMuY3VycmVudEJsZW5kaW5nIHx8IHByZW11bHRpcGxpZWRBbHBoYSAhPT0gdGhpcy5jdXJyZW50UHJlbXVsdGlwbGVkQWxwaGEgKSB7XHJcblxyXG5cdFx0XHRcdGlmICggdGhpcy5jdXJyZW50QmxlbmRFcXVhdGlvbiAhPT0gQWRkRXF1YXRpb24gfHwgdGhpcy5jdXJyZW50QmxlbmRFcXVhdGlvbkFscGhhICE9PSBBZGRFcXVhdGlvbiApIHtcclxuXHJcblx0XHRcdFx0XHRnbC5ibGVuZEVxdWF0aW9uKCBnbC5GVU5DX0FERCApO1xyXG5cclxuXHRcdFx0XHRcdHRoaXMuY3VycmVudEJsZW5kRXF1YXRpb24gPSBBZGRFcXVhdGlvbjtcclxuXHRcdFx0XHRcdHRoaXMuY3VycmVudEJsZW5kRXF1YXRpb25BbHBoYSA9IEFkZEVxdWF0aW9uO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGlmICggcHJlbXVsdGlwbGllZEFscGhhICkge1xyXG5cclxuXHRcdFx0XHRcdHN3aXRjaCAoIGJsZW5kaW5nICkge1xyXG5cclxuXHRcdFx0XHRcdFx0Y2FzZSBOb3JtYWxCbGVuZGluZzpcclxuXHRcdFx0XHRcdFx0XHRnbC5ibGVuZEZ1bmNTZXBhcmF0ZSggZ2wuT05FLCBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBLCBnbC5PTkUsIGdsLk9ORV9NSU5VU19TUkNfQUxQSEEgKTtcclxuXHRcdFx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0XHRcdGNhc2UgQWRkaXRpdmVCbGVuZGluZzpcclxuXHRcdFx0XHRcdFx0XHRnbC5ibGVuZEZ1bmMoIGdsLk9ORSwgZ2wuT05FICk7XHJcblx0XHRcdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdFx0XHRjYXNlIFN1YnRyYWN0aXZlQmxlbmRpbmc6XHJcblx0XHRcdFx0XHRcdFx0Z2wuYmxlbmRGdW5jU2VwYXJhdGUoIGdsLlpFUk8sIGdsLk9ORV9NSU5VU19TUkNfQ09MT1IsIGdsLlpFUk8sIGdsLk9ORSApO1xyXG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRcdFx0Y2FzZSBNdWx0aXBseUJsZW5kaW5nOlxyXG5cdFx0XHRcdFx0XHRcdGdsLmJsZW5kRnVuY1NlcGFyYXRlKCBnbC5aRVJPLCBnbC5TUkNfQ09MT1IsIGdsLlpFUk8sIGdsLlNSQ19BTFBIQSApO1xyXG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRcdFx0ZGVmYXVsdDpcclxuXHRcdFx0XHRcdFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuV2ViR0xTdGF0ZTogSW52YWxpZCBibGVuZGluZzogJywgYmxlbmRpbmcgKTtcclxuXHRcdFx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0c3dpdGNoICggYmxlbmRpbmcgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRjYXNlIE5vcm1hbEJsZW5kaW5nOlxyXG5cdFx0XHRcdFx0XHRcdGdsLmJsZW5kRnVuY1NlcGFyYXRlKCBnbC5TUkNfQUxQSEEsIGdsLk9ORV9NSU5VU19TUkNfQUxQSEEsIGdsLk9ORSwgZ2wuT05FX01JTlVTX1NSQ19BTFBIQSApO1xyXG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRcdFx0Y2FzZSBBZGRpdGl2ZUJsZW5kaW5nOlxyXG5cdFx0XHRcdFx0XHRcdGdsLmJsZW5kRnVuYyggZ2wuU1JDX0FMUEhBLCBnbC5PTkUgKTtcclxuXHRcdFx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0XHRcdGNhc2UgU3VidHJhY3RpdmVCbGVuZGluZzpcclxuXHRcdFx0XHRcdFx0XHRnbC5ibGVuZEZ1bmNTZXBhcmF0ZSggZ2wuWkVSTywgZ2wuT05FX01JTlVTX1NSQ19DT0xPUiwgZ2wuWkVSTywgZ2wuT05FICk7XHJcblx0XHRcdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdFx0XHRjYXNlIE11bHRpcGx5QmxlbmRpbmc6XHJcblx0XHRcdFx0XHRcdFx0Z2wuYmxlbmRGdW5jKCBnbC5aRVJPLCBnbC5TUkNfQ09MT1IgKTtcclxuXHRcdFx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0XHRcdGRlZmF1bHQ6XHJcblx0XHRcdFx0XHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLldlYkdMU3RhdGU6IEludmFsaWQgYmxlbmRpbmc6ICcsIGJsZW5kaW5nICk7XHJcblx0XHRcdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHRoaXMuY3VycmVudEJsZW5kU3JjID0gbnVsbDtcclxuXHRcdFx0XHR0aGlzLmN1cnJlbnRCbGVuZERzdCA9IG51bGw7XHJcblx0XHRcdFx0dGhpcy5jdXJyZW50QmxlbmRTcmNBbHBoYSA9IG51bGw7XHJcblx0XHRcdFx0dGhpcy5jdXJyZW50QmxlbmREc3RBbHBoYSA9IG51bGw7XHJcblxyXG5cdFx0XHRcdHRoaXMuY3VycmVudEJsZW5kaW5nID0gYmxlbmRpbmc7XHJcblx0XHRcdFx0dGhpcy5jdXJyZW50UHJlbXVsdGlwbGVkQWxwaGEgPSBwcmVtdWx0aXBsaWVkQWxwaGE7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRyZXR1cm47XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIGN1c3RvbSBibGVuZGluZ1xyXG5cclxuXHRcdGJsZW5kRXF1YXRpb25BbHBoYSA9IGJsZW5kRXF1YXRpb25BbHBoYSB8fCBibGVuZEVxdWF0aW9uO1xyXG5cdFx0YmxlbmRTcmNBbHBoYSA9IGJsZW5kU3JjQWxwaGEgfHwgYmxlbmRTcmM7XHJcblx0XHRibGVuZERzdEFscGhhID0gYmxlbmREc3RBbHBoYSB8fCBibGVuZERzdDtcclxuXHJcblx0XHRpZiAoIGJsZW5kRXF1YXRpb24gIT09IHRoaXMuY3VycmVudEJsZW5kRXF1YXRpb24gfHwgYmxlbmRFcXVhdGlvbkFscGhhICE9PSB0aGlzLmN1cnJlbnRCbGVuZEVxdWF0aW9uQWxwaGEgKSB7XHJcblxyXG5cdFx0XHRnbC5ibGVuZEVxdWF0aW9uU2VwYXJhdGUoIGVxdWF0aW9uVG9HTFsgYmxlbmRFcXVhdGlvbiBdLCBlcXVhdGlvblRvR0xbIGJsZW5kRXF1YXRpb25BbHBoYSBdICk7XHJcblxyXG5cdFx0XHR0aGlzLmN1cnJlbnRCbGVuZEVxdWF0aW9uID0gYmxlbmRFcXVhdGlvbjtcclxuXHRcdFx0dGhpcy5jdXJyZW50QmxlbmRFcXVhdGlvbkFscGhhID0gYmxlbmRFcXVhdGlvbkFscGhhO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIGJsZW5kU3JjICE9PSB0aGlzLmN1cnJlbnRCbGVuZFNyYyB8fCBibGVuZERzdCAhPT0gdGhpcy5jdXJyZW50QmxlbmREc3QgfHwgYmxlbmRTcmNBbHBoYSAhPT0gdGhpcy5jdXJyZW50QmxlbmRTcmNBbHBoYSB8fCBibGVuZERzdEFscGhhICE9PSB0aGlzLmN1cnJlbnRCbGVuZERzdEFscGhhICkge1xyXG5cclxuXHRcdFx0Z2wuYmxlbmRGdW5jU2VwYXJhdGUoIGZhY3RvclRvR0xbIGJsZW5kU3JjIF0sIGZhY3RvclRvR0xbIGJsZW5kRHN0IF0sIGZhY3RvclRvR0xbIGJsZW5kU3JjQWxwaGEgXSwgZmFjdG9yVG9HTFsgYmxlbmREc3RBbHBoYSBdICk7XHJcblxyXG5cdFx0XHR0aGlzLmN1cnJlbnRCbGVuZFNyYyA9IGJsZW5kU3JjO1xyXG5cdFx0XHR0aGlzLmN1cnJlbnRCbGVuZERzdCA9IGJsZW5kRHN0O1xyXG5cdFx0XHR0aGlzLmN1cnJlbnRCbGVuZFNyY0FscGhhID0gYmxlbmRTcmNBbHBoYTtcclxuXHRcdFx0dGhpcy5jdXJyZW50QmxlbmREc3RBbHBoYSA9IGJsZW5kRHN0QWxwaGE7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuY3VycmVudEJsZW5kaW5nID0gYmxlbmRpbmc7XHJcblx0XHR0aGlzLmN1cnJlbnRQcmVtdWx0aXBsZWRBbHBoYSA9IGZhbHNlO1xyXG5cclxuXHR9XHJcblxyXG5cdHNldENvbG9yTWFzayggY29sb3JNYXNrICkge1xyXG5cclxuXHRcdGlmICggdGhpcy5jdXJyZW50Q29sb3JNYXNrICE9PSBjb2xvck1hc2sgKSB7XHJcblxyXG5cdFx0XHR0aGlzLmdsLmNvbG9yTWFzayggY29sb3JNYXNrLCBjb2xvck1hc2ssIGNvbG9yTWFzaywgY29sb3JNYXNrICk7XHJcblx0XHRcdHRoaXMuY3VycmVudENvbG9yTWFzayA9IGNvbG9yTWFzaztcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0c2V0RGVwdGhUZXN0KCBkZXB0aFRlc3QgKSB7XHJcblxyXG5cdFx0Y29uc3QgeyBnbCB9ID0gdGhpcztcclxuXHJcblx0XHRpZiAoIGRlcHRoVGVzdCApIHtcclxuXHJcblx0XHRcdHRoaXMuZW5hYmxlKCBnbC5ERVBUSF9URVNUICk7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdHRoaXMuZGlzYWJsZSggZ2wuREVQVEhfVEVTVCApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHRzZXREZXB0aE1hc2soIGRlcHRoTWFzayApIHtcclxuXHJcblx0XHRpZiAoIHRoaXMuY3VycmVudERlcHRoTWFzayAhPT0gZGVwdGhNYXNrICkge1xyXG5cclxuXHRcdFx0dGhpcy5nbC5kZXB0aE1hc2soIGRlcHRoTWFzayApO1xyXG5cdFx0XHR0aGlzLmN1cnJlbnREZXB0aE1hc2sgPSBkZXB0aE1hc2s7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdHNldERlcHRoRnVuYyggZGVwdGhGdW5jICkge1xyXG5cclxuXHRcdGlmICggdGhpcy5jdXJyZW50RGVwdGhGdW5jICE9PSBkZXB0aEZ1bmMgKSB7XHJcblxyXG5cdFx0XHRjb25zdCB7IGdsIH0gPSB0aGlzO1xyXG5cclxuXHRcdFx0c3dpdGNoICggZGVwdGhGdW5jICkge1xyXG5cclxuXHRcdFx0XHRjYXNlIE5ldmVyRGVwdGg6XHJcblxyXG5cdFx0XHRcdFx0Z2wuZGVwdGhGdW5jKCBnbC5ORVZFUiApO1xyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdGNhc2UgQWx3YXlzRGVwdGg6XHJcblxyXG5cdFx0XHRcdFx0Z2wuZGVwdGhGdW5jKCBnbC5BTFdBWVMgKTtcclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRjYXNlIExlc3NEZXB0aDpcclxuXHJcblx0XHRcdFx0XHRnbC5kZXB0aEZ1bmMoIGdsLkxFU1MgKTtcclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRjYXNlIExlc3NFcXVhbERlcHRoOlxyXG5cclxuXHRcdFx0XHRcdGdsLmRlcHRoRnVuYyggZ2wuTEVRVUFMICk7XHJcblx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0Y2FzZSBFcXVhbERlcHRoOlxyXG5cclxuXHRcdFx0XHRcdGdsLmRlcHRoRnVuYyggZ2wuRVFVQUwgKTtcclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRjYXNlIEdyZWF0ZXJFcXVhbERlcHRoOlxyXG5cclxuXHRcdFx0XHRcdGdsLmRlcHRoRnVuYyggZ2wuR0VRVUFMICk7XHJcblx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0Y2FzZSBHcmVhdGVyRGVwdGg6XHJcblxyXG5cdFx0XHRcdFx0Z2wuZGVwdGhGdW5jKCBnbC5HUkVBVEVSICk7XHJcblx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0Y2FzZSBOb3RFcXVhbERlcHRoOlxyXG5cclxuXHRcdFx0XHRcdGdsLmRlcHRoRnVuYyggZ2wuTk9URVFVQUwgKTtcclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRkZWZhdWx0OlxyXG5cclxuXHRcdFx0XHRcdGdsLmRlcHRoRnVuYyggZ2wuTEVRVUFMICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR0aGlzLmN1cnJlbnREZXB0aEZ1bmMgPSBkZXB0aEZ1bmM7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdHNldFN0ZW5jaWxUZXN0KCBzdGVuY2lsVGVzdCApIHtcclxuXHJcblx0XHRjb25zdCB7IGdsIH0gPSB0aGlzO1xyXG5cclxuXHRcdGlmICggc3RlbmNpbFRlc3QgKSB7XHJcblxyXG5cdFx0XHR0aGlzLmVuYWJsZSggZ2wuU1RFTkNJTF9URVNUICk7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdHRoaXMuZGlzYWJsZSggZ2wuU1RFTkNJTF9URVNUICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdHNldFN0ZW5jaWxNYXNrKCBzdGVuY2lsTWFzayApIHtcclxuXHJcblx0XHRpZiAoIHRoaXMuY3VycmVudFN0ZW5jaWxNYXNrICE9PSBzdGVuY2lsTWFzayApIHtcclxuXHJcblx0XHRcdHRoaXMuZ2wuc3RlbmNpbE1hc2soIHN0ZW5jaWxNYXNrICk7XHJcblx0XHRcdHRoaXMuY3VycmVudFN0ZW5jaWxNYXNrID0gc3RlbmNpbE1hc2s7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdHNldFN0ZW5jaWxGdW5jKCBzdGVuY2lsRnVuYywgc3RlbmNpbFJlZiwgc3RlbmNpbE1hc2sgKSB7XHJcblxyXG5cdFx0aWYgKCB0aGlzLmN1cnJlbnRTdGVuY2lsRnVuYyAhPT0gc3RlbmNpbEZ1bmMgfHxcclxuXHRcdFx0IHRoaXMuY3VycmVudFN0ZW5jaWxSZWYgIT09IHN0ZW5jaWxSZWYgfHxcclxuXHRcdFx0IHRoaXMuY3VycmVudFN0ZW5jaWxGdW5jTWFzayAhPT0gc3RlbmNpbE1hc2sgKSB7XHJcblxyXG5cdFx0XHR0aGlzLmdsLnN0ZW5jaWxGdW5jKCBzdGVuY2lsRnVuYywgc3RlbmNpbFJlZiwgc3RlbmNpbE1hc2sgKTtcclxuXHJcblx0XHRcdHRoaXMuY3VycmVudFN0ZW5jaWxGdW5jID0gc3RlbmNpbEZ1bmM7XHJcblx0XHRcdHRoaXMuY3VycmVudFN0ZW5jaWxSZWYgPSBzdGVuY2lsUmVmO1xyXG5cdFx0XHR0aGlzLmN1cnJlbnRTdGVuY2lsRnVuY01hc2sgPSBzdGVuY2lsTWFzaztcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0c2V0U3RlbmNpbE9wKCBzdGVuY2lsRmFpbCwgc3RlbmNpbFpGYWlsLCBzdGVuY2lsWlBhc3MgKSB7XHJcblxyXG5cdFx0aWYgKCB0aGlzLmN1cnJlbnRTdGVuY2lsRmFpbCAhPT0gc3RlbmNpbEZhaWwgfHxcclxuXHRcdFx0IHRoaXMuY3VycmVudFN0ZW5jaWxaRmFpbCAhPT0gc3RlbmNpbFpGYWlsIHx8XHJcblx0XHRcdCB0aGlzLmN1cnJlbnRTdGVuY2lsWlBhc3MgIT09IHN0ZW5jaWxaUGFzcyApIHtcclxuXHJcblx0XHRcdHRoaXMuZ2wuc3RlbmNpbE9wKCBzdGVuY2lsRmFpbCwgc3RlbmNpbFpGYWlsLCBzdGVuY2lsWlBhc3MgKTtcclxuXHJcblx0XHRcdHRoaXMuY3VycmVudFN0ZW5jaWxGYWlsID0gc3RlbmNpbEZhaWw7XHJcblx0XHRcdHRoaXMuY3VycmVudFN0ZW5jaWxaRmFpbCA9IHN0ZW5jaWxaRmFpbDtcclxuXHRcdFx0dGhpcy5jdXJyZW50U3RlbmNpbFpQYXNzID0gc3RlbmNpbFpQYXNzO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHRzZXRNYXRlcmlhbCggbWF0ZXJpYWwsIGZyb250RmFjZUNXLCBoYXJkd2FyZUNsaXBwaW5nUGxhbmVzICkge1xyXG5cclxuXHRcdGNvbnN0IHsgZ2wgfSA9IHRoaXM7XHJcblxyXG5cdFx0bWF0ZXJpYWwuc2lkZSA9PT0gRG91YmxlU2lkZVxyXG5cdFx0XHQ/IHRoaXMuZGlzYWJsZSggZ2wuQ1VMTF9GQUNFIClcclxuXHRcdFx0OiB0aGlzLmVuYWJsZSggZ2wuQ1VMTF9GQUNFICk7XHJcblxyXG5cdFx0bGV0IGZsaXBTaWRlZCA9ICggbWF0ZXJpYWwuc2lkZSA9PT0gQmFja1NpZGUgKTtcclxuXHRcdGlmICggZnJvbnRGYWNlQ1cgKSBmbGlwU2lkZWQgPSAhIGZsaXBTaWRlZDtcclxuXHJcblx0XHR0aGlzLnNldEZsaXBTaWRlZCggZmxpcFNpZGVkICk7XHJcblxyXG5cdFx0KCBtYXRlcmlhbC5ibGVuZGluZyA9PT0gTm9ybWFsQmxlbmRpbmcgJiYgbWF0ZXJpYWwudHJhbnNwYXJlbnQgPT09IGZhbHNlIClcclxuXHRcdFx0PyB0aGlzLnNldEJsZW5kaW5nKCBOb0JsZW5kaW5nIClcclxuXHRcdFx0OiB0aGlzLnNldEJsZW5kaW5nKCBtYXRlcmlhbC5ibGVuZGluZywgbWF0ZXJpYWwuYmxlbmRFcXVhdGlvbiwgbWF0ZXJpYWwuYmxlbmRTcmMsIG1hdGVyaWFsLmJsZW5kRHN0LCBtYXRlcmlhbC5ibGVuZEVxdWF0aW9uQWxwaGEsIG1hdGVyaWFsLmJsZW5kU3JjQWxwaGEsIG1hdGVyaWFsLmJsZW5kRHN0QWxwaGEsIG1hdGVyaWFsLnByZW11bHRpcGxpZWRBbHBoYSApO1xyXG5cclxuXHRcdHRoaXMuc2V0RGVwdGhGdW5jKCBtYXRlcmlhbC5kZXB0aEZ1bmMgKTtcclxuXHRcdHRoaXMuc2V0RGVwdGhUZXN0KCBtYXRlcmlhbC5kZXB0aFRlc3QgKTtcclxuXHRcdHRoaXMuc2V0RGVwdGhNYXNrKCBtYXRlcmlhbC5kZXB0aFdyaXRlICk7XHJcblx0XHR0aGlzLnNldENvbG9yTWFzayggbWF0ZXJpYWwuY29sb3JXcml0ZSApO1xyXG5cclxuXHRcdGNvbnN0IHN0ZW5jaWxXcml0ZSA9IG1hdGVyaWFsLnN0ZW5jaWxXcml0ZTtcclxuXHRcdHRoaXMuc2V0U3RlbmNpbFRlc3QoIHN0ZW5jaWxXcml0ZSApO1xyXG5cdFx0aWYgKCBzdGVuY2lsV3JpdGUgKSB7XHJcblxyXG5cdFx0XHR0aGlzLnNldFN0ZW5jaWxNYXNrKCBtYXRlcmlhbC5zdGVuY2lsV3JpdGVNYXNrICk7XHJcblx0XHRcdHRoaXMuc2V0U3RlbmNpbEZ1bmMoIG1hdGVyaWFsLnN0ZW5jaWxGdW5jLCBtYXRlcmlhbC5zdGVuY2lsUmVmLCBtYXRlcmlhbC5zdGVuY2lsRnVuY01hc2sgKTtcclxuXHRcdFx0dGhpcy5zZXRTdGVuY2lsT3AoIG1hdGVyaWFsLnN0ZW5jaWxGYWlsLCBtYXRlcmlhbC5zdGVuY2lsWkZhaWwsIG1hdGVyaWFsLnN0ZW5jaWxaUGFzcyApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLnNldFBvbHlnb25PZmZzZXQoIG1hdGVyaWFsLnBvbHlnb25PZmZzZXQsIG1hdGVyaWFsLnBvbHlnb25PZmZzZXRGYWN0b3IsIG1hdGVyaWFsLnBvbHlnb25PZmZzZXRVbml0cyApO1xyXG5cclxuXHRcdG1hdGVyaWFsLmFscGhhVG9Db3ZlcmFnZSA9PT0gdHJ1ZSAmJiB0aGlzLmJhY2tlbmQucmVuZGVyZXIuc2FtcGxlcyA+IDFcclxuXHRcdFx0PyB0aGlzLmVuYWJsZSggZ2wuU0FNUExFX0FMUEhBX1RPX0NPVkVSQUdFIClcclxuXHRcdFx0OiB0aGlzLmRpc2FibGUoIGdsLlNBTVBMRV9BTFBIQV9UT19DT1ZFUkFHRSApO1xyXG5cclxuXHRcdGlmICggaGFyZHdhcmVDbGlwcGluZ1BsYW5lcyA+IDAgKSB7XHJcblxyXG5cdFx0XHRpZiAoIHRoaXMuY3VycmVudENsaXBwaW5nUGxhbmVzICE9PSBoYXJkd2FyZUNsaXBwaW5nUGxhbmVzICkge1xyXG5cclxuXHRcdFx0XHRjb25zdCBDTElQX0RJU1RBTkNFMF9XRUJHTCA9IDB4MzAwMDtcclxuXHJcblx0XHRcdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgODsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0XHRpZiAoIGkgPCBoYXJkd2FyZUNsaXBwaW5nUGxhbmVzICkge1xyXG5cclxuXHRcdFx0XHRcdFx0dGhpcy5lbmFibGUoIENMSVBfRElTVEFOQ0UwX1dFQkdMICsgaSApO1xyXG5cclxuXHRcdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0XHR0aGlzLmRpc2FibGUoIENMSVBfRElTVEFOQ0UwX1dFQkdMICsgaSApO1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHRzZXRQb2x5Z29uT2Zmc2V0KCBwb2x5Z29uT2Zmc2V0LCBmYWN0b3IsIHVuaXRzICkge1xyXG5cclxuXHRcdGNvbnN0IHsgZ2wgfSA9IHRoaXM7XHJcblxyXG5cdFx0aWYgKCBwb2x5Z29uT2Zmc2V0ICkge1xyXG5cclxuXHRcdFx0dGhpcy5lbmFibGUoIGdsLlBPTFlHT05fT0ZGU0VUX0ZJTEwgKTtcclxuXHJcblx0XHRcdGlmICggdGhpcy5jdXJyZW50UG9seWdvbk9mZnNldEZhY3RvciAhPT0gZmFjdG9yIHx8IHRoaXMuY3VycmVudFBvbHlnb25PZmZzZXRVbml0cyAhPT0gdW5pdHMgKSB7XHJcblxyXG5cdFx0XHRcdGdsLnBvbHlnb25PZmZzZXQoIGZhY3RvciwgdW5pdHMgKTtcclxuXHJcblx0XHRcdFx0dGhpcy5jdXJyZW50UG9seWdvbk9mZnNldEZhY3RvciA9IGZhY3RvcjtcclxuXHRcdFx0XHR0aGlzLmN1cnJlbnRQb2x5Z29uT2Zmc2V0VW5pdHMgPSB1bml0cztcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0dGhpcy5kaXNhYmxlKCBnbC5QT0xZR09OX09GRlNFVF9GSUxMICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdHVzZVByb2dyYW0oIHByb2dyYW0gKSB7XHJcblxyXG5cdFx0aWYgKCB0aGlzLmN1cnJlbnRQcm9ncmFtICE9PSBwcm9ncmFtICkge1xyXG5cclxuXHRcdFx0dGhpcy5nbC51c2VQcm9ncmFtKCBwcm9ncmFtICk7XHJcblxyXG5cdFx0XHR0aGlzLmN1cnJlbnRQcm9ncmFtID0gcHJvZ3JhbTtcclxuXHJcblx0XHRcdHJldHVybiB0cnVlO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gZmFsc2U7XHJcblxyXG5cdH1cclxuXHJcblx0Ly8gZnJhbWVidWZmZXJcclxuXHJcblxyXG5cdGJpbmRGcmFtZWJ1ZmZlciggdGFyZ2V0LCBmcmFtZWJ1ZmZlciApIHtcclxuXHJcblx0XHRjb25zdCB7IGdsLCBjdXJyZW50Qm91bmRGcmFtZWJ1ZmZlcnMgfSA9IHRoaXM7XHJcblxyXG5cdFx0aWYgKCBjdXJyZW50Qm91bmRGcmFtZWJ1ZmZlcnNbIHRhcmdldCBdICE9PSBmcmFtZWJ1ZmZlciApIHtcclxuXHJcblx0XHRcdGdsLmJpbmRGcmFtZWJ1ZmZlciggdGFyZ2V0LCBmcmFtZWJ1ZmZlciApO1xyXG5cclxuXHRcdFx0Y3VycmVudEJvdW5kRnJhbWVidWZmZXJzWyB0YXJnZXQgXSA9IGZyYW1lYnVmZmVyO1xyXG5cclxuXHRcdFx0Ly8gZ2wuRFJBV19GUkFNRUJVRkZFUiBpcyBlcXVpdmFsZW50IHRvIGdsLkZSQU1FQlVGRkVSXHJcblxyXG5cdFx0XHRpZiAoIHRhcmdldCA9PT0gZ2wuRFJBV19GUkFNRUJVRkZFUiApIHtcclxuXHJcblx0XHRcdFx0Y3VycmVudEJvdW5kRnJhbWVidWZmZXJzWyBnbC5GUkFNRUJVRkZFUiBdID0gZnJhbWVidWZmZXI7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoIHRhcmdldCA9PT0gZ2wuRlJBTUVCVUZGRVIgKSB7XHJcblxyXG5cdFx0XHRcdGN1cnJlbnRCb3VuZEZyYW1lYnVmZmVyc1sgZ2wuRFJBV19GUkFNRUJVRkZFUiBdID0gZnJhbWVidWZmZXI7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGZhbHNlO1xyXG5cclxuXHR9XHJcblxyXG5cdGRyYXdCdWZmZXJzKCByZW5kZXJDb250ZXh0LCBmcmFtZWJ1ZmZlciApIHtcclxuXHJcblx0XHRjb25zdCB7IGdsIH0gPSB0aGlzO1xyXG5cclxuXHRcdGxldCBkcmF3QnVmZmVycyA9IFtdO1xyXG5cclxuXHRcdGxldCBuZWVkc1VwZGF0ZSA9IGZhbHNlO1xyXG5cclxuXHRcdGlmICggcmVuZGVyQ29udGV4dC50ZXh0dXJlcyAhPT0gbnVsbCApIHtcclxuXHJcblx0XHRcdGRyYXdCdWZmZXJzID0gdGhpcy5jdXJyZW50RHJhd2J1ZmZlcnMuZ2V0KCBmcmFtZWJ1ZmZlciApO1xyXG5cclxuXHRcdFx0aWYgKCBkcmF3QnVmZmVycyA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRkcmF3QnVmZmVycyA9IFtdO1xyXG5cdFx0XHRcdHRoaXMuY3VycmVudERyYXdidWZmZXJzLnNldCggZnJhbWVidWZmZXIsIGRyYXdCdWZmZXJzICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cclxuXHRcdFx0Y29uc3QgdGV4dHVyZXMgPSByZW5kZXJDb250ZXh0LnRleHR1cmVzO1xyXG5cclxuXHRcdFx0aWYgKCBkcmF3QnVmZmVycy5sZW5ndGggIT09IHRleHR1cmVzLmxlbmd0aCB8fCBkcmF3QnVmZmVyc1sgMCBdICE9PSBnbC5DT0xPUl9BVFRBQ0hNRU5UMCApIHtcclxuXHJcblx0XHRcdFx0Zm9yICggbGV0IGkgPSAwLCBpbCA9IHRleHR1cmVzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHRcdGRyYXdCdWZmZXJzWyBpIF0gPSBnbC5DT0xPUl9BVFRBQ0hNRU5UMCArIGk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0ZHJhd0J1ZmZlcnMubGVuZ3RoID0gdGV4dHVyZXMubGVuZ3RoO1xyXG5cclxuXHRcdFx0XHRuZWVkc1VwZGF0ZSA9IHRydWU7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRpZiAoIGRyYXdCdWZmZXJzWyAwIF0gIT09IGdsLkJBQ0sgKSB7XHJcblxyXG5cdFx0XHRcdGRyYXdCdWZmZXJzWyAwIF0gPSBnbC5CQUNLO1xyXG5cclxuXHRcdFx0XHRuZWVkc1VwZGF0ZSA9IHRydWU7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggbmVlZHNVcGRhdGUgKSB7XHJcblxyXG5cdFx0XHRnbC5kcmF3QnVmZmVycyggZHJhd0J1ZmZlcnMgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblxyXG5cdC8vIHRleHR1cmVcclxuXHJcblx0YWN0aXZlVGV4dHVyZSggd2ViZ2xTbG90ICkge1xyXG5cclxuXHRcdGNvbnN0IHsgZ2wsIGN1cnJlbnRUZXh0dXJlU2xvdCwgbWF4VGV4dHVyZXMgfSA9IHRoaXM7XHJcblxyXG5cdFx0aWYgKCB3ZWJnbFNsb3QgPT09IHVuZGVmaW5lZCApIHdlYmdsU2xvdCA9IGdsLlRFWFRVUkUwICsgbWF4VGV4dHVyZXMgLSAxO1xyXG5cclxuXHRcdGlmICggY3VycmVudFRleHR1cmVTbG90ICE9PSB3ZWJnbFNsb3QgKSB7XHJcblxyXG5cdFx0XHRnbC5hY3RpdmVUZXh0dXJlKCB3ZWJnbFNsb3QgKTtcclxuXHRcdFx0dGhpcy5jdXJyZW50VGV4dHVyZVNsb3QgPSB3ZWJnbFNsb3Q7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdGJpbmRUZXh0dXJlKCB3ZWJnbFR5cGUsIHdlYmdsVGV4dHVyZSwgd2ViZ2xTbG90ICkge1xyXG5cclxuXHRcdGNvbnN0IHsgZ2wsIGN1cnJlbnRUZXh0dXJlU2xvdCwgY3VycmVudEJvdW5kVGV4dHVyZXMsIG1heFRleHR1cmVzIH0gPSB0aGlzO1xyXG5cclxuXHRcdGlmICggd2ViZ2xTbG90ID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRpZiAoIGN1cnJlbnRUZXh0dXJlU2xvdCA9PT0gbnVsbCApIHtcclxuXHJcblx0XHRcdFx0d2ViZ2xTbG90ID0gZ2wuVEVYVFVSRTAgKyBtYXhUZXh0dXJlcyAtIDE7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHR3ZWJnbFNsb3QgPSBjdXJyZW50VGV4dHVyZVNsb3Q7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGxldCBib3VuZFRleHR1cmUgPSBjdXJyZW50Qm91bmRUZXh0dXJlc1sgd2ViZ2xTbG90IF07XHJcblxyXG5cdFx0aWYgKCBib3VuZFRleHR1cmUgPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdGJvdW5kVGV4dHVyZSA9IHsgdHlwZTogdW5kZWZpbmVkLCB0ZXh0dXJlOiB1bmRlZmluZWQgfTtcclxuXHRcdFx0Y3VycmVudEJvdW5kVGV4dHVyZXNbIHdlYmdsU2xvdCBdID0gYm91bmRUZXh0dXJlO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIGJvdW5kVGV4dHVyZS50eXBlICE9PSB3ZWJnbFR5cGUgfHwgYm91bmRUZXh0dXJlLnRleHR1cmUgIT09IHdlYmdsVGV4dHVyZSApIHtcclxuXHJcblx0XHRcdGlmICggY3VycmVudFRleHR1cmVTbG90ICE9PSB3ZWJnbFNsb3QgKSB7XHJcblxyXG5cdFx0XHRcdGdsLmFjdGl2ZVRleHR1cmUoIHdlYmdsU2xvdCApO1xyXG5cdFx0XHRcdHRoaXMuY3VycmVudFRleHR1cmVTbG90ID0gd2ViZ2xTbG90O1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Z2wuYmluZFRleHR1cmUoIHdlYmdsVHlwZSwgd2ViZ2xUZXh0dXJlICk7XHJcblxyXG5cdFx0XHRib3VuZFRleHR1cmUudHlwZSA9IHdlYmdsVHlwZTtcclxuXHRcdFx0Ym91bmRUZXh0dXJlLnRleHR1cmUgPSB3ZWJnbFRleHR1cmU7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdGJpbmRCdWZmZXJCYXNlKCB0YXJnZXQsIGluZGV4LCBidWZmZXIgKSB7XHJcblxyXG5cdFx0Y29uc3QgeyBnbCB9ID0gdGhpcztcclxuXHJcblx0XHRjb25zdCBrZXkgPSBgJHt0YXJnZXR9LSR7aW5kZXh9YDtcclxuXHJcblx0XHRpZiAoIHRoaXMuY3VycmVudEJvdW5kQnVmZmVyQmFzZXNbIGtleSBdICE9PSBidWZmZXIgKSB7XHJcblxyXG5cdFx0XHRnbC5iaW5kQnVmZmVyQmFzZSggdGFyZ2V0LCBpbmRleCwgYnVmZmVyICk7XHJcblx0XHRcdHRoaXMuY3VycmVudEJvdW5kQnVmZmVyQmFzZXNbIGtleSBdID0gYnVmZmVyO1xyXG5cclxuXHRcdFx0cmV0dXJuIHRydWU7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBmYWxzZTtcclxuXHJcblx0fVxyXG5cclxuXHJcblx0dW5iaW5kVGV4dHVyZSgpIHtcclxuXHJcblx0XHRjb25zdCB7IGdsLCBjdXJyZW50VGV4dHVyZVNsb3QsIGN1cnJlbnRCb3VuZFRleHR1cmVzIH0gPSB0aGlzO1xyXG5cclxuXHRcdGNvbnN0IGJvdW5kVGV4dHVyZSA9IGN1cnJlbnRCb3VuZFRleHR1cmVzWyBjdXJyZW50VGV4dHVyZVNsb3QgXTtcclxuXHJcblx0XHRpZiAoIGJvdW5kVGV4dHVyZSAhPT0gdW5kZWZpbmVkICYmIGJvdW5kVGV4dHVyZS50eXBlICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRnbC5iaW5kVGV4dHVyZSggYm91bmRUZXh0dXJlLnR5cGUsIG51bGwgKTtcclxuXHJcblx0XHRcdGJvdW5kVGV4dHVyZS50eXBlID0gdW5kZWZpbmVkO1xyXG5cdFx0XHRib3VuZFRleHR1cmUudGV4dHVyZSA9IHVuZGVmaW5lZDtcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IFdlYkdMU3RhdGU7XHJcbiIsImltcG9ydCB7IFJHQkFfQVNUQ180eDRfRm9ybWF0LCBSR0JBX0FTVENfNXg0X0Zvcm1hdCwgUkdCQV9BU1RDXzV4NV9Gb3JtYXQsIFJHQkFfQVNUQ182eDVfRm9ybWF0LCBSR0JBX0FTVENfNng2X0Zvcm1hdCwgUkdCQV9BU1RDXzh4NV9Gb3JtYXQsIFJHQkFfQVNUQ184eDZfRm9ybWF0LCBSR0JBX0FTVENfOHg4X0Zvcm1hdCwgUkdCQV9BU1RDXzEweDVfRm9ybWF0LCBSR0JBX0FTVENfMTB4Nl9Gb3JtYXQsIFJHQkFfQVNUQ18xMHg4X0Zvcm1hdCwgUkdCQV9BU1RDXzEweDEwX0Zvcm1hdCwgUkdCQV9BU1RDXzEyeDEwX0Zvcm1hdCwgUkdCQV9BU1RDXzEyeDEyX0Zvcm1hdCwgUkdCX0VUQzFfRm9ybWF0LCBSR0JfRVRDMl9Gb3JtYXQsIFJHQkFfRVRDMl9FQUNfRm9ybWF0LCBSR0JBX1BWUlRDXzJCUFBWMV9Gb3JtYXQsIFJHQkFfUFZSVENfNEJQUFYxX0Zvcm1hdCwgUkdCX1BWUlRDXzJCUFBWMV9Gb3JtYXQsIFJHQl9QVlJUQ180QlBQVjFfRm9ybWF0LCBSR0JBX1MzVENfRFhUNV9Gb3JtYXQsIFJHQkFfUzNUQ19EWFQzX0Zvcm1hdCwgUkdCQV9TM1RDX0RYVDFfRm9ybWF0LCBSR0JfUzNUQ19EWFQxX0Zvcm1hdCwgRGVwdGhGb3JtYXQsIERlcHRoU3RlbmNpbEZvcm1hdCwgTHVtaW5hbmNlQWxwaGFGb3JtYXQsIEx1bWluYW5jZUZvcm1hdCwgUmVkRm9ybWF0LCBSR0JGb3JtYXQsIFJHQkFGb3JtYXQsIEFscGhhRm9ybWF0LCBSZWRJbnRlZ2VyRm9ybWF0LCBSR0Zvcm1hdCwgUkdJbnRlZ2VyRm9ybWF0LCBSR0JBSW50ZWdlckZvcm1hdCwgSGFsZkZsb2F0VHlwZSwgRmxvYXRUeXBlLCBVbnNpZ25lZEludFR5cGUsIEludFR5cGUsIFVuc2lnbmVkU2hvcnRUeXBlLCBTaG9ydFR5cGUsIEJ5dGVUeXBlLCBVbnNpZ25lZEludDI0OFR5cGUsIFVuc2lnbmVkSW50NTk5OVR5cGUsIFVuc2lnbmVkU2hvcnQ1NTUxVHlwZSwgVW5zaWduZWRTaG9ydDQ0NDRUeXBlLCBVbnNpZ25lZEJ5dGVUeXBlLCBSR0JBX0JQVENfRm9ybWF0LCBSRURfUkdUQzFfRm9ybWF0LCBTSUdORURfUkVEX1JHVEMxX0Zvcm1hdCwgUkVEX0dSRUVOX1JHVEMyX0Zvcm1hdCwgU0lHTkVEX1JFRF9HUkVFTl9SR1RDMl9Gb3JtYXQsIFNSR0JDb2xvclNwYWNlLCBOb0NvbG9yU3BhY2UgfSBmcm9tICcuLi8uLi8uLi9jb25zdGFudHMuanMnO1xyXG5cclxuY2xhc3MgV2ViR0xVdGlscyB7XHJcblxyXG5cdGNvbnN0cnVjdG9yKCBiYWNrZW5kICkge1xyXG5cclxuXHRcdHRoaXMuYmFja2VuZCA9IGJhY2tlbmQ7XHJcblxyXG5cdFx0dGhpcy5nbCA9IHRoaXMuYmFja2VuZC5nbDtcclxuXHRcdHRoaXMuZXh0ZW5zaW9ucyA9IGJhY2tlbmQuZXh0ZW5zaW9ucztcclxuXHJcblx0fVxyXG5cclxuXHRjb252ZXJ0KCBwLCBjb2xvclNwYWNlID0gTm9Db2xvclNwYWNlICkge1xyXG5cclxuXHRcdGNvbnN0IHsgZ2wsIGV4dGVuc2lvbnMgfSA9IHRoaXM7XHJcblxyXG5cdFx0bGV0IGV4dGVuc2lvbjtcclxuXHJcblx0XHRpZiAoIHAgPT09IFVuc2lnbmVkQnl0ZVR5cGUgKSByZXR1cm4gZ2wuVU5TSUdORURfQllURTtcclxuXHRcdGlmICggcCA9PT0gVW5zaWduZWRTaG9ydDQ0NDRUeXBlICkgcmV0dXJuIGdsLlVOU0lHTkVEX1NIT1JUXzRfNF80XzQ7XHJcblx0XHRpZiAoIHAgPT09IFVuc2lnbmVkU2hvcnQ1NTUxVHlwZSApIHJldHVybiBnbC5VTlNJR05FRF9TSE9SVF81XzVfNV8xO1xyXG5cdFx0aWYgKCBwID09PSBVbnNpZ25lZEludDU5OTlUeXBlICkgcmV0dXJuIGdsLlVOU0lHTkVEX0lOVF81XzlfOV85X1JFVjtcclxuXHJcblx0XHRpZiAoIHAgPT09IEJ5dGVUeXBlICkgcmV0dXJuIGdsLkJZVEU7XHJcblx0XHRpZiAoIHAgPT09IFNob3J0VHlwZSApIHJldHVybiBnbC5TSE9SVDtcclxuXHRcdGlmICggcCA9PT0gVW5zaWduZWRTaG9ydFR5cGUgKSByZXR1cm4gZ2wuVU5TSUdORURfU0hPUlQ7XHJcblx0XHRpZiAoIHAgPT09IEludFR5cGUgKSByZXR1cm4gZ2wuSU5UO1xyXG5cdFx0aWYgKCBwID09PSBVbnNpZ25lZEludFR5cGUgKSByZXR1cm4gZ2wuVU5TSUdORURfSU5UO1xyXG5cdFx0aWYgKCBwID09PSBGbG9hdFR5cGUgKSByZXR1cm4gZ2wuRkxPQVQ7XHJcblxyXG5cdFx0aWYgKCBwID09PSBIYWxmRmxvYXRUeXBlICkge1xyXG5cclxuXHRcdFx0cmV0dXJuIGdsLkhBTEZfRkxPQVQ7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggcCA9PT0gQWxwaGFGb3JtYXQgKSByZXR1cm4gZ2wuQUxQSEE7XHJcblx0XHRpZiAoIHAgPT09IFJHQkZvcm1hdCApIHJldHVybiBnbC5SR0I7XHJcblx0XHRpZiAoIHAgPT09IFJHQkFGb3JtYXQgKSByZXR1cm4gZ2wuUkdCQTtcclxuXHRcdGlmICggcCA9PT0gTHVtaW5hbmNlRm9ybWF0ICkgcmV0dXJuIGdsLkxVTUlOQU5DRTtcclxuXHRcdGlmICggcCA9PT0gTHVtaW5hbmNlQWxwaGFGb3JtYXQgKSByZXR1cm4gZ2wuTFVNSU5BTkNFX0FMUEhBO1xyXG5cdFx0aWYgKCBwID09PSBEZXB0aEZvcm1hdCApIHJldHVybiBnbC5ERVBUSF9DT01QT05FTlQ7XHJcblx0XHRpZiAoIHAgPT09IERlcHRoU3RlbmNpbEZvcm1hdCApIHJldHVybiBnbC5ERVBUSF9TVEVOQ0lMO1xyXG5cclxuXHRcdC8vIFdlYkdMMiBmb3JtYXRzLlxyXG5cclxuXHRcdGlmICggcCA9PT0gUmVkRm9ybWF0ICkgcmV0dXJuIGdsLlJFRDtcclxuXHRcdGlmICggcCA9PT0gUmVkSW50ZWdlckZvcm1hdCApIHJldHVybiBnbC5SRURfSU5URUdFUjtcclxuXHRcdGlmICggcCA9PT0gUkdGb3JtYXQgKSByZXR1cm4gZ2wuUkc7XHJcblx0XHRpZiAoIHAgPT09IFJHSW50ZWdlckZvcm1hdCApIHJldHVybiBnbC5SR19JTlRFR0VSO1xyXG5cdFx0aWYgKCBwID09PSBSR0JBSW50ZWdlckZvcm1hdCApIHJldHVybiBnbC5SR0JBX0lOVEVHRVI7XHJcblxyXG5cdFx0Ly8gUzNUQ1xyXG5cclxuXHRcdGlmICggcCA9PT0gUkdCX1MzVENfRFhUMV9Gb3JtYXQgfHwgcCA9PT0gUkdCQV9TM1RDX0RYVDFfRm9ybWF0IHx8IHAgPT09IFJHQkFfUzNUQ19EWFQzX0Zvcm1hdCB8fCBwID09PSBSR0JBX1MzVENfRFhUNV9Gb3JtYXQgKSB7XHJcblxyXG5cdFx0XHRpZiAoIGNvbG9yU3BhY2UgPT09IFNSR0JDb2xvclNwYWNlICkge1xyXG5cclxuXHRcdFx0XHRleHRlbnNpb24gPSBleHRlbnNpb25zLmdldCggJ1dFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9zM3RjX3NyZ2InICk7XHJcblxyXG5cdFx0XHRcdGlmICggZXh0ZW5zaW9uICE9PSBudWxsICkge1xyXG5cclxuXHRcdFx0XHRcdGlmICggcCA9PT0gUkdCX1MzVENfRFhUMV9Gb3JtYXQgKSByZXR1cm4gZXh0ZW5zaW9uLkNPTVBSRVNTRURfU1JHQl9TM1RDX0RYVDFfRVhUO1xyXG5cdFx0XHRcdFx0aWYgKCBwID09PSBSR0JBX1MzVENfRFhUMV9Gb3JtYXQgKSByZXR1cm4gZXh0ZW5zaW9uLkNPTVBSRVNTRURfU1JHQl9BTFBIQV9TM1RDX0RYVDFfRVhUO1xyXG5cdFx0XHRcdFx0aWYgKCBwID09PSBSR0JBX1MzVENfRFhUM19Gb3JtYXQgKSByZXR1cm4gZXh0ZW5zaW9uLkNPTVBSRVNTRURfU1JHQl9BTFBIQV9TM1RDX0RYVDNfRVhUO1xyXG5cdFx0XHRcdFx0aWYgKCBwID09PSBSR0JBX1MzVENfRFhUNV9Gb3JtYXQgKSByZXR1cm4gZXh0ZW5zaW9uLkNPTVBSRVNTRURfU1JHQl9BTFBIQV9TM1RDX0RYVDVfRVhUO1xyXG5cclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdHJldHVybiBudWxsO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRleHRlbnNpb24gPSBleHRlbnNpb25zLmdldCggJ1dFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9zM3RjJyApO1xyXG5cclxuXHRcdFx0XHRpZiAoIGV4dGVuc2lvbiAhPT0gbnVsbCApIHtcclxuXHJcblx0XHRcdFx0XHRpZiAoIHAgPT09IFJHQl9TM1RDX0RYVDFfRm9ybWF0ICkgcmV0dXJuIGV4dGVuc2lvbi5DT01QUkVTU0VEX1JHQl9TM1RDX0RYVDFfRVhUO1xyXG5cdFx0XHRcdFx0aWYgKCBwID09PSBSR0JBX1MzVENfRFhUMV9Gb3JtYXQgKSByZXR1cm4gZXh0ZW5zaW9uLkNPTVBSRVNTRURfUkdCQV9TM1RDX0RYVDFfRVhUO1xyXG5cdFx0XHRcdFx0aWYgKCBwID09PSBSR0JBX1MzVENfRFhUM19Gb3JtYXQgKSByZXR1cm4gZXh0ZW5zaW9uLkNPTVBSRVNTRURfUkdCQV9TM1RDX0RYVDNfRVhUO1xyXG5cdFx0XHRcdFx0aWYgKCBwID09PSBSR0JBX1MzVENfRFhUNV9Gb3JtYXQgKSByZXR1cm4gZXh0ZW5zaW9uLkNPTVBSRVNTRURfUkdCQV9TM1RDX0RYVDVfRVhUO1xyXG5cclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdHJldHVybiBudWxsO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIFBWUlRDXHJcblxyXG5cdFx0aWYgKCBwID09PSBSR0JfUFZSVENfNEJQUFYxX0Zvcm1hdCB8fCBwID09PSBSR0JfUFZSVENfMkJQUFYxX0Zvcm1hdCB8fCBwID09PSBSR0JBX1BWUlRDXzRCUFBWMV9Gb3JtYXQgfHwgcCA9PT0gUkdCQV9QVlJUQ18yQlBQVjFfRm9ybWF0ICkge1xyXG5cclxuXHRcdFx0ZXh0ZW5zaW9uID0gZXh0ZW5zaW9ucy5nZXQoICdXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfcHZydGMnICk7XHJcblxyXG5cdFx0XHRpZiAoIGV4dGVuc2lvbiAhPT0gbnVsbCApIHtcclxuXHJcblx0XHRcdFx0aWYgKCBwID09PSBSR0JfUFZSVENfNEJQUFYxX0Zvcm1hdCApIHJldHVybiBleHRlbnNpb24uQ09NUFJFU1NFRF9SR0JfUFZSVENfNEJQUFYxX0lNRztcclxuXHRcdFx0XHRpZiAoIHAgPT09IFJHQl9QVlJUQ18yQlBQVjFfRm9ybWF0ICkgcmV0dXJuIGV4dGVuc2lvbi5DT01QUkVTU0VEX1JHQl9QVlJUQ18yQlBQVjFfSU1HO1xyXG5cdFx0XHRcdGlmICggcCA9PT0gUkdCQV9QVlJUQ180QlBQVjFfRm9ybWF0ICkgcmV0dXJuIGV4dGVuc2lvbi5DT01QUkVTU0VEX1JHQkFfUFZSVENfNEJQUFYxX0lNRztcclxuXHRcdFx0XHRpZiAoIHAgPT09IFJHQkFfUFZSVENfMkJQUFYxX0Zvcm1hdCApIHJldHVybiBleHRlbnNpb24uQ09NUFJFU1NFRF9SR0JBX1BWUlRDXzJCUFBWMV9JTUc7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRyZXR1cm4gbnVsbDtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gRVRDXHJcblxyXG5cdFx0aWYgKCBwID09PSBSR0JfRVRDMV9Gb3JtYXQgfHwgcCA9PT0gUkdCX0VUQzJfRm9ybWF0IHx8IHAgPT09IFJHQkFfRVRDMl9FQUNfRm9ybWF0ICkge1xyXG5cclxuXHRcdFx0ZXh0ZW5zaW9uID0gZXh0ZW5zaW9ucy5nZXQoICdXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfZXRjJyApO1xyXG5cclxuXHRcdFx0aWYgKCBleHRlbnNpb24gIT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHRcdGlmICggcCA9PT0gUkdCX0VUQzFfRm9ybWF0IHx8IHAgPT09IFJHQl9FVEMyX0Zvcm1hdCApIHJldHVybiAoIGNvbG9yU3BhY2UgPT09IFNSR0JDb2xvclNwYWNlICkgPyBleHRlbnNpb24uQ09NUFJFU1NFRF9TUkdCOF9FVEMyIDogZXh0ZW5zaW9uLkNPTVBSRVNTRURfUkdCOF9FVEMyO1xyXG5cdFx0XHRcdGlmICggcCA9PT0gUkdCQV9FVEMyX0VBQ19Gb3JtYXQgKSByZXR1cm4gKCBjb2xvclNwYWNlID09PSBTUkdCQ29sb3JTcGFjZSApID8gZXh0ZW5zaW9uLkNPTVBSRVNTRURfU1JHQjhfQUxQSEE4X0VUQzJfRUFDIDogZXh0ZW5zaW9uLkNPTVBSRVNTRURfUkdCQThfRVRDMl9FQUM7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRyZXR1cm4gbnVsbDtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gQVNUQ1xyXG5cclxuXHRcdGlmICggcCA9PT0gUkdCQV9BU1RDXzR4NF9Gb3JtYXQgfHwgcCA9PT0gUkdCQV9BU1RDXzV4NF9Gb3JtYXQgfHwgcCA9PT0gUkdCQV9BU1RDXzV4NV9Gb3JtYXQgfHxcclxuXHRcdFx0cCA9PT0gUkdCQV9BU1RDXzZ4NV9Gb3JtYXQgfHwgcCA9PT0gUkdCQV9BU1RDXzZ4Nl9Gb3JtYXQgfHwgcCA9PT0gUkdCQV9BU1RDXzh4NV9Gb3JtYXQgfHxcclxuXHRcdFx0cCA9PT0gUkdCQV9BU1RDXzh4Nl9Gb3JtYXQgfHwgcCA9PT0gUkdCQV9BU1RDXzh4OF9Gb3JtYXQgfHwgcCA9PT0gUkdCQV9BU1RDXzEweDVfRm9ybWF0IHx8XHJcblx0XHRcdHAgPT09IFJHQkFfQVNUQ18xMHg2X0Zvcm1hdCB8fCBwID09PSBSR0JBX0FTVENfMTB4OF9Gb3JtYXQgfHwgcCA9PT0gUkdCQV9BU1RDXzEweDEwX0Zvcm1hdCB8fFxyXG5cdFx0XHRwID09PSBSR0JBX0FTVENfMTJ4MTBfRm9ybWF0IHx8IHAgPT09IFJHQkFfQVNUQ18xMngxMl9Gb3JtYXQgKSB7XHJcblxyXG5cdFx0XHRleHRlbnNpb24gPSBleHRlbnNpb25zLmdldCggJ1dFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9hc3RjJyApO1xyXG5cclxuXHRcdFx0aWYgKCBleHRlbnNpb24gIT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHRcdGlmICggcCA9PT0gUkdCQV9BU1RDXzR4NF9Gb3JtYXQgKSByZXR1cm4gKCBjb2xvclNwYWNlID09PSBTUkdCQ29sb3JTcGFjZSApID8gZXh0ZW5zaW9uLkNPTVBSRVNTRURfU1JHQjhfQUxQSEE4X0FTVENfNHg0X0tIUiA6IGV4dGVuc2lvbi5DT01QUkVTU0VEX1JHQkFfQVNUQ180eDRfS0hSO1xyXG5cdFx0XHRcdGlmICggcCA9PT0gUkdCQV9BU1RDXzV4NF9Gb3JtYXQgKSByZXR1cm4gKCBjb2xvclNwYWNlID09PSBTUkdCQ29sb3JTcGFjZSApID8gZXh0ZW5zaW9uLkNPTVBSRVNTRURfU1JHQjhfQUxQSEE4X0FTVENfNXg0X0tIUiA6IGV4dGVuc2lvbi5DT01QUkVTU0VEX1JHQkFfQVNUQ181eDRfS0hSO1xyXG5cdFx0XHRcdGlmICggcCA9PT0gUkdCQV9BU1RDXzV4NV9Gb3JtYXQgKSByZXR1cm4gKCBjb2xvclNwYWNlID09PSBTUkdCQ29sb3JTcGFjZSApID8gZXh0ZW5zaW9uLkNPTVBSRVNTRURfU1JHQjhfQUxQSEE4X0FTVENfNXg1X0tIUiA6IGV4dGVuc2lvbi5DT01QUkVTU0VEX1JHQkFfQVNUQ181eDVfS0hSO1xyXG5cdFx0XHRcdGlmICggcCA9PT0gUkdCQV9BU1RDXzZ4NV9Gb3JtYXQgKSByZXR1cm4gKCBjb2xvclNwYWNlID09PSBTUkdCQ29sb3JTcGFjZSApID8gZXh0ZW5zaW9uLkNPTVBSRVNTRURfU1JHQjhfQUxQSEE4X0FTVENfNng1X0tIUiA6IGV4dGVuc2lvbi5DT01QUkVTU0VEX1JHQkFfQVNUQ182eDVfS0hSO1xyXG5cdFx0XHRcdGlmICggcCA9PT0gUkdCQV9BU1RDXzZ4Nl9Gb3JtYXQgKSByZXR1cm4gKCBjb2xvclNwYWNlID09PSBTUkdCQ29sb3JTcGFjZSApID8gZXh0ZW5zaW9uLkNPTVBSRVNTRURfU1JHQjhfQUxQSEE4X0FTVENfNng2X0tIUiA6IGV4dGVuc2lvbi5DT01QUkVTU0VEX1JHQkFfQVNUQ182eDZfS0hSO1xyXG5cdFx0XHRcdGlmICggcCA9PT0gUkdCQV9BU1RDXzh4NV9Gb3JtYXQgKSByZXR1cm4gKCBjb2xvclNwYWNlID09PSBTUkdCQ29sb3JTcGFjZSApID8gZXh0ZW5zaW9uLkNPTVBSRVNTRURfU1JHQjhfQUxQSEE4X0FTVENfOHg1X0tIUiA6IGV4dGVuc2lvbi5DT01QUkVTU0VEX1JHQkFfQVNUQ184eDVfS0hSO1xyXG5cdFx0XHRcdGlmICggcCA9PT0gUkdCQV9BU1RDXzh4Nl9Gb3JtYXQgKSByZXR1cm4gKCBjb2xvclNwYWNlID09PSBTUkdCQ29sb3JTcGFjZSApID8gZXh0ZW5zaW9uLkNPTVBSRVNTRURfU1JHQjhfQUxQSEE4X0FTVENfOHg2X0tIUiA6IGV4dGVuc2lvbi5DT01QUkVTU0VEX1JHQkFfQVNUQ184eDZfS0hSO1xyXG5cdFx0XHRcdGlmICggcCA9PT0gUkdCQV9BU1RDXzh4OF9Gb3JtYXQgKSByZXR1cm4gKCBjb2xvclNwYWNlID09PSBTUkdCQ29sb3JTcGFjZSApID8gZXh0ZW5zaW9uLkNPTVBSRVNTRURfU1JHQjhfQUxQSEE4X0FTVENfOHg4X0tIUiA6IGV4dGVuc2lvbi5DT01QUkVTU0VEX1JHQkFfQVNUQ184eDhfS0hSO1xyXG5cdFx0XHRcdGlmICggcCA9PT0gUkdCQV9BU1RDXzEweDVfRm9ybWF0ICkgcmV0dXJuICggY29sb3JTcGFjZSA9PT0gU1JHQkNvbG9yU3BhY2UgKSA/IGV4dGVuc2lvbi5DT01QUkVTU0VEX1NSR0I4X0FMUEhBOF9BU1RDXzEweDVfS0hSIDogZXh0ZW5zaW9uLkNPTVBSRVNTRURfUkdCQV9BU1RDXzEweDVfS0hSO1xyXG5cdFx0XHRcdGlmICggcCA9PT0gUkdCQV9BU1RDXzEweDZfRm9ybWF0ICkgcmV0dXJuICggY29sb3JTcGFjZSA9PT0gU1JHQkNvbG9yU3BhY2UgKSA/IGV4dGVuc2lvbi5DT01QUkVTU0VEX1NSR0I4X0FMUEhBOF9BU1RDXzEweDZfS0hSIDogZXh0ZW5zaW9uLkNPTVBSRVNTRURfUkdCQV9BU1RDXzEweDZfS0hSO1xyXG5cdFx0XHRcdGlmICggcCA9PT0gUkdCQV9BU1RDXzEweDhfRm9ybWF0ICkgcmV0dXJuICggY29sb3JTcGFjZSA9PT0gU1JHQkNvbG9yU3BhY2UgKSA/IGV4dGVuc2lvbi5DT01QUkVTU0VEX1NSR0I4X0FMUEhBOF9BU1RDXzEweDhfS0hSIDogZXh0ZW5zaW9uLkNPTVBSRVNTRURfUkdCQV9BU1RDXzEweDhfS0hSO1xyXG5cdFx0XHRcdGlmICggcCA9PT0gUkdCQV9BU1RDXzEweDEwX0Zvcm1hdCApIHJldHVybiAoIGNvbG9yU3BhY2UgPT09IFNSR0JDb2xvclNwYWNlICkgPyBleHRlbnNpb24uQ09NUFJFU1NFRF9TUkdCOF9BTFBIQThfQVNUQ18xMHgxMF9LSFIgOiBleHRlbnNpb24uQ09NUFJFU1NFRF9SR0JBX0FTVENfMTB4MTBfS0hSO1xyXG5cdFx0XHRcdGlmICggcCA9PT0gUkdCQV9BU1RDXzEyeDEwX0Zvcm1hdCApIHJldHVybiAoIGNvbG9yU3BhY2UgPT09IFNSR0JDb2xvclNwYWNlICkgPyBleHRlbnNpb24uQ09NUFJFU1NFRF9TUkdCOF9BTFBIQThfQVNUQ18xMngxMF9LSFIgOiBleHRlbnNpb24uQ09NUFJFU1NFRF9SR0JBX0FTVENfMTJ4MTBfS0hSO1xyXG5cdFx0XHRcdGlmICggcCA9PT0gUkdCQV9BU1RDXzEyeDEyX0Zvcm1hdCApIHJldHVybiAoIGNvbG9yU3BhY2UgPT09IFNSR0JDb2xvclNwYWNlICkgPyBleHRlbnNpb24uQ09NUFJFU1NFRF9TUkdCOF9BTFBIQThfQVNUQ18xMngxMl9LSFIgOiBleHRlbnNpb24uQ09NUFJFU1NFRF9SR0JBX0FTVENfMTJ4MTJfS0hSO1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0cmV0dXJuIG51bGw7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIEJQVENcclxuXHJcblx0XHRpZiAoIHAgPT09IFJHQkFfQlBUQ19Gb3JtYXQgKSB7XHJcblxyXG5cdFx0XHRleHRlbnNpb24gPSBleHRlbnNpb25zLmdldCggJ0VYVF90ZXh0dXJlX2NvbXByZXNzaW9uX2JwdGMnICk7XHJcblxyXG5cdFx0XHRpZiAoIGV4dGVuc2lvbiAhPT0gbnVsbCApIHtcclxuXHJcblx0XHRcdFx0aWYgKCBwID09PSBSR0JBX0JQVENfRm9ybWF0ICkgcmV0dXJuICggY29sb3JTcGFjZSA9PT0gU1JHQkNvbG9yU3BhY2UgKSA/IGV4dGVuc2lvbi5DT01QUkVTU0VEX1NSR0JfQUxQSEFfQlBUQ19VTk9STV9FWFQgOiBleHRlbnNpb24uQ09NUFJFU1NFRF9SR0JBX0JQVENfVU5PUk1fRVhUO1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0cmV0dXJuIG51bGw7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIFJHVENcclxuXHJcblx0XHRpZiAoIHAgPT09IFJFRF9SR1RDMV9Gb3JtYXQgfHwgcCA9PT0gU0lHTkVEX1JFRF9SR1RDMV9Gb3JtYXQgfHwgcCA9PT0gUkVEX0dSRUVOX1JHVEMyX0Zvcm1hdCB8fCBwID09PSBTSUdORURfUkVEX0dSRUVOX1JHVEMyX0Zvcm1hdCApIHtcclxuXHJcblx0XHRcdGV4dGVuc2lvbiA9IGV4dGVuc2lvbnMuZ2V0KCAnRVhUX3RleHR1cmVfY29tcHJlc3Npb25fcmd0YycgKTtcclxuXHJcblx0XHRcdGlmICggZXh0ZW5zaW9uICE9PSBudWxsICkge1xyXG5cclxuXHRcdFx0XHRpZiAoIHAgPT09IFJHQkFfQlBUQ19Gb3JtYXQgKSByZXR1cm4gZXh0ZW5zaW9uLkNPTVBSRVNTRURfUkVEX1JHVEMxX0VYVDtcclxuXHRcdFx0XHRpZiAoIHAgPT09IFNJR05FRF9SRURfUkdUQzFfRm9ybWF0ICkgcmV0dXJuIGV4dGVuc2lvbi5DT01QUkVTU0VEX1NJR05FRF9SRURfUkdUQzFfRVhUO1xyXG5cdFx0XHRcdGlmICggcCA9PT0gUkVEX0dSRUVOX1JHVEMyX0Zvcm1hdCApIHJldHVybiBleHRlbnNpb24uQ09NUFJFU1NFRF9SRURfR1JFRU5fUkdUQzJfRVhUO1xyXG5cdFx0XHRcdGlmICggcCA9PT0gU0lHTkVEX1JFRF9HUkVFTl9SR1RDMl9Gb3JtYXQgKSByZXR1cm4gZXh0ZW5zaW9uLkNPTVBSRVNTRURfU0lHTkVEX1JFRF9HUkVFTl9SR1RDMl9FWFQ7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRyZXR1cm4gbnVsbDtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly9cclxuXHJcblx0XHRpZiAoIHAgPT09IFVuc2lnbmVkSW50MjQ4VHlwZSApIHtcclxuXHJcblx0XHRcdHJldHVybiBnbC5VTlNJR05FRF9JTlRfMjRfODtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gaWYgXCJwXCIgY2FuJ3QgYmUgcmVzb2x2ZWQsIGFzc3VtZSB0aGUgdXNlciBkZWZpbmVzIGEgV2ViR0wgY29uc3RhbnQgYXMgYSBzdHJpbmcgKGZhbGxiYWNrL3dvcmthcm91bmQgZm9yIHBhY2tlZCBSR0IgZm9ybWF0cylcclxuXHJcblx0XHRyZXR1cm4gKCBnbFsgcCBdICE9PSB1bmRlZmluZWQgKSA/IGdsWyBwIF0gOiBudWxsO1xyXG5cclxuXHR9XHJcblxyXG5cdF9jbGllbnRXYWl0QXN5bmMoKSB7XHJcblxyXG5cdFx0Y29uc3QgeyBnbCB9ID0gdGhpcztcclxuXHJcblx0XHRjb25zdCBzeW5jID0gZ2wuZmVuY2VTeW5jKCBnbC5TWU5DX0dQVV9DT01NQU5EU19DT01QTEVURSwgMCApO1xyXG5cclxuXHRcdGdsLmZsdXNoKCk7XHJcblxyXG5cdFx0cmV0dXJuIG5ldyBQcm9taXNlKCAoIHJlc29sdmUsIHJlamVjdCApID0+IHtcclxuXHJcblx0XHRcdGZ1bmN0aW9uIHRlc3QoKSB7XHJcblxyXG5cdFx0XHRcdGNvbnN0IHJlcyA9IGdsLmNsaWVudFdhaXRTeW5jKCBzeW5jLCBnbC5TWU5DX0ZMVVNIX0NPTU1BTkRTX0JJVCwgMCApO1xyXG5cclxuXHRcdFx0XHRpZiAoIHJlcyA9PT0gZ2wuV0FJVF9GQUlMRUQgKSB7XHJcblxyXG5cdFx0XHRcdFx0Z2wuZGVsZXRlU3luYyggc3luYyApO1xyXG5cclxuXHRcdFx0XHRcdHJlamVjdCgpO1xyXG5cdFx0XHRcdFx0cmV0dXJuO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGlmICggcmVzID09PSBnbC5USU1FT1VUX0VYUElSRUQgKSB7XHJcblxyXG5cdFx0XHRcdFx0cmVxdWVzdEFuaW1hdGlvbkZyYW1lKCB0ZXN0ICk7XHJcblx0XHRcdFx0XHRyZXR1cm47XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0Z2wuZGVsZXRlU3luYyggc3luYyApO1xyXG5cclxuXHRcdFx0XHRyZXNvbHZlKCk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR0ZXN0KCk7XHJcblxyXG5cdFx0fSApO1xyXG5cclxuXHR9XHJcblxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBXZWJHTFV0aWxzO1xyXG4iLCJpbXBvcnQgeyBMaW5lYXJGaWx0ZXIsIExpbmVhck1pcG1hcExpbmVhckZpbHRlciwgTGluZWFyTWlwbWFwTmVhcmVzdEZpbHRlciwgTmVhcmVzdEZpbHRlciwgTmVhcmVzdE1pcG1hcExpbmVhckZpbHRlciwgTmVhcmVzdE1pcG1hcE5lYXJlc3RGaWx0ZXIsIEZsb2F0VHlwZSwgTWlycm9yZWRSZXBlYXRXcmFwcGluZywgQ2xhbXBUb0VkZ2VXcmFwcGluZywgUmVwZWF0V3JhcHBpbmcsIFNSR0JDb2xvclNwYWNlLCBOZXZlckNvbXBhcmUsIEFsd2F5c0NvbXBhcmUsIExlc3NDb21wYXJlLCBMZXNzRXF1YWxDb21wYXJlLCBFcXVhbENvbXBhcmUsIEdyZWF0ZXJFcXVhbENvbXBhcmUsIEdyZWF0ZXJDb21wYXJlLCBOb3RFcXVhbENvbXBhcmUgfSBmcm9tICcuLi8uLi8uLi9jb25zdGFudHMuanMnO1xyXG5cclxubGV0IGluaXRpYWxpemVkID0gZmFsc2UsIHdyYXBwaW5nVG9HTCwgZmlsdGVyVG9HTCwgY29tcGFyZVRvR0w7XHJcblxyXG5jbGFzcyBXZWJHTFRleHR1cmVVdGlscyB7XHJcblxyXG5cdGNvbnN0cnVjdG9yKCBiYWNrZW5kICkge1xyXG5cclxuXHRcdHRoaXMuYmFja2VuZCA9IGJhY2tlbmQ7XHJcblxyXG5cdFx0dGhpcy5nbCA9IGJhY2tlbmQuZ2w7XHJcblx0XHR0aGlzLmV4dGVuc2lvbnMgPSBiYWNrZW5kLmV4dGVuc2lvbnM7XHJcblx0XHR0aGlzLmRlZmF1bHRUZXh0dXJlcyA9IHt9O1xyXG5cclxuXHRcdGlmICggaW5pdGlhbGl6ZWQgPT09IGZhbHNlICkge1xyXG5cclxuXHRcdFx0dGhpcy5faW5pdCggdGhpcy5nbCApO1xyXG5cclxuXHRcdFx0aW5pdGlhbGl6ZWQgPSB0cnVlO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHRfaW5pdCggZ2wgKSB7XHJcblxyXG5cdFx0Ly8gU3RvcmUgb25seSBXZWJHTCBjb25zdGFudHMgaGVyZS5cclxuXHJcblx0XHR3cmFwcGluZ1RvR0wgPSB7XHJcblx0XHRcdFsgUmVwZWF0V3JhcHBpbmcgXTogZ2wuUkVQRUFULFxyXG5cdFx0XHRbIENsYW1wVG9FZGdlV3JhcHBpbmcgXTogZ2wuQ0xBTVBfVE9fRURHRSxcclxuXHRcdFx0WyBNaXJyb3JlZFJlcGVhdFdyYXBwaW5nIF06IGdsLk1JUlJPUkVEX1JFUEVBVFxyXG5cdFx0fTtcclxuXHJcblx0XHRmaWx0ZXJUb0dMID0ge1xyXG5cdFx0XHRbIE5lYXJlc3RGaWx0ZXIgXTogZ2wuTkVBUkVTVCxcclxuXHRcdFx0WyBOZWFyZXN0TWlwbWFwTmVhcmVzdEZpbHRlciBdOiBnbC5ORUFSRVNUX01JUE1BUF9ORUFSRVNULFxyXG5cdFx0XHRbIE5lYXJlc3RNaXBtYXBMaW5lYXJGaWx0ZXIgXTogZ2wuTkVBUkVTVF9NSVBNQVBfTElORUFSLFxyXG5cclxuXHRcdFx0WyBMaW5lYXJGaWx0ZXIgXTogZ2wuTElORUFSLFxyXG5cdFx0XHRbIExpbmVhck1pcG1hcE5lYXJlc3RGaWx0ZXIgXTogZ2wuTElORUFSX01JUE1BUF9ORUFSRVNULFxyXG5cdFx0XHRbIExpbmVhck1pcG1hcExpbmVhckZpbHRlciBdOiBnbC5MSU5FQVJfTUlQTUFQX0xJTkVBUlxyXG5cdFx0fTtcclxuXHJcblx0XHRjb21wYXJlVG9HTCA9IHtcclxuXHRcdFx0WyBOZXZlckNvbXBhcmUgXTogZ2wuTkVWRVIsXHJcblx0XHRcdFsgQWx3YXlzQ29tcGFyZSBdOiBnbC5BTFdBWVMsXHJcblx0XHRcdFsgTGVzc0NvbXBhcmUgXTogZ2wuTEVTUyxcclxuXHRcdFx0WyBMZXNzRXF1YWxDb21wYXJlIF06IGdsLkxFUVVBTCxcclxuXHRcdFx0WyBFcXVhbENvbXBhcmUgXTogZ2wuRVFVQUwsXHJcblx0XHRcdFsgR3JlYXRlckVxdWFsQ29tcGFyZSBdOiBnbC5HRVFVQUwsXHJcblx0XHRcdFsgR3JlYXRlckNvbXBhcmUgXTogZ2wuR1JFQVRFUixcclxuXHRcdFx0WyBOb3RFcXVhbENvbXBhcmUgXTogZ2wuTk9URVFVQUxcclxuXHRcdH07XHJcblxyXG5cdH1cclxuXHJcblx0ZmlsdGVyRmFsbGJhY2soIGYgKSB7XHJcblxyXG5cdFx0Y29uc3QgeyBnbCB9ID0gdGhpcztcclxuXHJcblx0XHRpZiAoIGYgPT09IE5lYXJlc3RGaWx0ZXIgfHwgZiA9PT0gTmVhcmVzdE1pcG1hcE5lYXJlc3RGaWx0ZXIgfHwgZiA9PT0gTmVhcmVzdE1pcG1hcExpbmVhckZpbHRlciApIHtcclxuXHJcblx0XHRcdHJldHVybiBnbC5ORUFSRVNUO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gZ2wuTElORUFSO1xyXG5cclxuXHR9XHJcblxyXG5cdGdldEdMVGV4dHVyZVR5cGUoIHRleHR1cmUgKSB7XHJcblxyXG5cdFx0Y29uc3QgeyBnbCB9ID0gdGhpcztcclxuXHJcblx0XHRsZXQgZ2xUZXh0dXJlVHlwZTtcclxuXHJcblx0XHRpZiAoIHRleHR1cmUuaXNDdWJlVGV4dHVyZSA9PT0gdHJ1ZSApIHtcclxuXHJcblx0XHRcdGdsVGV4dHVyZVR5cGUgPSBnbC5URVhUVVJFX0NVQkVfTUFQO1xyXG5cclxuXHRcdH0gZWxzZSBpZiAoIHRleHR1cmUuaXNEYXRhQXJyYXlUZXh0dXJlID09PSB0cnVlIHx8IHRleHR1cmUuaXNDb21wcmVzc2VkQXJyYXlUZXh0dXJlID09PSB0cnVlICkge1xyXG5cclxuXHRcdFx0Z2xUZXh0dXJlVHlwZSA9IGdsLlRFWFRVUkVfMkRfQVJSQVk7XHJcblxyXG5cdFx0fSBlbHNlIGlmICggdGV4dHVyZS5pc0RhdGEzRFRleHR1cmUgPT09IHRydWUgKSB7IC8vIFRPRE86IGlzQ29tcHJlc3NlZDNEVGV4dHVyZSwgd2FpdCBmb3IgIzI2NjQyXHJcblxyXG5cdFx0XHRnbFRleHR1cmVUeXBlID0gZ2wuVEVYVFVSRV8zRDtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0Z2xUZXh0dXJlVHlwZSA9IGdsLlRFWFRVUkVfMkQ7XHJcblxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gZ2xUZXh0dXJlVHlwZTtcclxuXHJcblx0fVxyXG5cclxuXHRnZXRJbnRlcm5hbEZvcm1hdCggaW50ZXJuYWxGb3JtYXROYW1lLCBnbEZvcm1hdCwgZ2xUeXBlLCBjb2xvclNwYWNlLCBmb3JjZUxpbmVhclRyYW5zZmVyID0gZmFsc2UgKSB7XHJcblxyXG5cdFx0Y29uc3QgeyBnbCwgZXh0ZW5zaW9ucyB9ID0gdGhpcztcclxuXHJcblx0XHRpZiAoIGludGVybmFsRm9ybWF0TmFtZSAhPT0gbnVsbCApIHtcclxuXHJcblx0XHRcdGlmICggZ2xbIGludGVybmFsRm9ybWF0TmFtZSBdICE9PSB1bmRlZmluZWQgKSByZXR1cm4gZ2xbIGludGVybmFsRm9ybWF0TmFtZSBdO1xyXG5cclxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJlcjogQXR0ZW1wdCB0byB1c2Ugbm9uLWV4aXN0aW5nIFdlYkdMIGludGVybmFsIGZvcm1hdCBcXCcnICsgaW50ZXJuYWxGb3JtYXROYW1lICsgJ1xcJycgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0bGV0IGludGVybmFsRm9ybWF0ID0gZ2xGb3JtYXQ7XHJcblxyXG5cdFx0aWYgKCBnbEZvcm1hdCA9PT0gZ2wuUkVEICkge1xyXG5cclxuXHRcdFx0aWYgKCBnbFR5cGUgPT09IGdsLkZMT0FUICkgaW50ZXJuYWxGb3JtYXQgPSBnbC5SMzJGO1xyXG5cdFx0XHRpZiAoIGdsVHlwZSA9PT0gZ2wuSEFMRl9GTE9BVCApIGludGVybmFsRm9ybWF0ID0gZ2wuUjE2RjtcclxuXHRcdFx0aWYgKCBnbFR5cGUgPT09IGdsLlVOU0lHTkVEX0JZVEUgKSBpbnRlcm5hbEZvcm1hdCA9IGdsLlI4O1xyXG5cdFx0XHRpZiAoIGdsVHlwZSA9PT0gZ2wuVU5TSUdORURfU0hPUlQgKSBpbnRlcm5hbEZvcm1hdCA9IGdsLlIxNjtcclxuXHRcdFx0aWYgKCBnbFR5cGUgPT09IGdsLlVOU0lHTkVEX0lOVCApIGludGVybmFsRm9ybWF0ID0gZ2wuUjMyVUk7XHJcblx0XHRcdGlmICggZ2xUeXBlID09PSBnbC5CWVRFICkgaW50ZXJuYWxGb3JtYXQgPSBnbC5SOEk7XHJcblx0XHRcdGlmICggZ2xUeXBlID09PSBnbC5TSE9SVCApIGludGVybmFsRm9ybWF0ID0gZ2wuUjE2STtcclxuXHRcdFx0aWYgKCBnbFR5cGUgPT09IGdsLklOVCApIGludGVybmFsRm9ybWF0ID0gZ2wuUjMySTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBnbEZvcm1hdCA9PT0gZ2wuUkVEX0lOVEVHRVIgKSB7XHJcblxyXG5cdFx0XHRpZiAoIGdsVHlwZSA9PT0gZ2wuVU5TSUdORURfQllURSApIGludGVybmFsRm9ybWF0ID0gZ2wuUjhVSTtcclxuXHRcdFx0aWYgKCBnbFR5cGUgPT09IGdsLlVOU0lHTkVEX1NIT1JUICkgaW50ZXJuYWxGb3JtYXQgPSBnbC5SMTZVSTtcclxuXHRcdFx0aWYgKCBnbFR5cGUgPT09IGdsLlVOU0lHTkVEX0lOVCApIGludGVybmFsRm9ybWF0ID0gZ2wuUjMyVUk7XHJcblx0XHRcdGlmICggZ2xUeXBlID09PSBnbC5CWVRFICkgaW50ZXJuYWxGb3JtYXQgPSBnbC5SOEk7XHJcblx0XHRcdGlmICggZ2xUeXBlID09PSBnbC5TSE9SVCApIGludGVybmFsRm9ybWF0ID0gZ2wuUjE2STtcclxuXHRcdFx0aWYgKCBnbFR5cGUgPT09IGdsLklOVCApIGludGVybmFsRm9ybWF0ID0gZ2wuUjMySTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBnbEZvcm1hdCA9PT0gZ2wuUkcgKSB7XHJcblxyXG5cdFx0XHRpZiAoIGdsVHlwZSA9PT0gZ2wuRkxPQVQgKSBpbnRlcm5hbEZvcm1hdCA9IGdsLlJHMzJGO1xyXG5cdFx0XHRpZiAoIGdsVHlwZSA9PT0gZ2wuSEFMRl9GTE9BVCApIGludGVybmFsRm9ybWF0ID0gZ2wuUkcxNkY7XHJcblx0XHRcdGlmICggZ2xUeXBlID09PSBnbC5VTlNJR05FRF9CWVRFICkgaW50ZXJuYWxGb3JtYXQgPSBnbC5SRzg7XHJcblx0XHRcdGlmICggZ2xUeXBlID09PSBnbC5VTlNJR05FRF9TSE9SVCApIGludGVybmFsRm9ybWF0ID0gZ2wuUkcxNjtcclxuXHRcdFx0aWYgKCBnbFR5cGUgPT09IGdsLlVOU0lHTkVEX0lOVCApIGludGVybmFsRm9ybWF0ID0gZ2wuUkczMlVJO1xyXG5cdFx0XHRpZiAoIGdsVHlwZSA9PT0gZ2wuQllURSApIGludGVybmFsRm9ybWF0ID0gZ2wuUkc4STtcclxuXHRcdFx0aWYgKCBnbFR5cGUgPT09IGdsLlNIT1JUICkgaW50ZXJuYWxGb3JtYXQgPSBnbC5SRzE2STtcclxuXHRcdFx0aWYgKCBnbFR5cGUgPT09IGdsLklOVCApIGludGVybmFsRm9ybWF0ID0gZ2wuUkczMkk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggZ2xGb3JtYXQgPT09IGdsLlJHX0lOVEVHRVIgKSB7XHJcblxyXG5cdFx0XHRpZiAoIGdsVHlwZSA9PT0gZ2wuVU5TSUdORURfQllURSApIGludGVybmFsRm9ybWF0ID0gZ2wuUkc4VUk7XHJcblx0XHRcdGlmICggZ2xUeXBlID09PSBnbC5VTlNJR05FRF9TSE9SVCApIGludGVybmFsRm9ybWF0ID0gZ2wuUkcxNlVJO1xyXG5cdFx0XHRpZiAoIGdsVHlwZSA9PT0gZ2wuVU5TSUdORURfSU5UICkgaW50ZXJuYWxGb3JtYXQgPSBnbC5SRzMyVUk7XHJcblx0XHRcdGlmICggZ2xUeXBlID09PSBnbC5CWVRFICkgaW50ZXJuYWxGb3JtYXQgPSBnbC5SRzhJO1xyXG5cdFx0XHRpZiAoIGdsVHlwZSA9PT0gZ2wuU0hPUlQgKSBpbnRlcm5hbEZvcm1hdCA9IGdsLlJHMTZJO1xyXG5cdFx0XHRpZiAoIGdsVHlwZSA9PT0gZ2wuSU5UICkgaW50ZXJuYWxGb3JtYXQgPSBnbC5SRzMySTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBnbEZvcm1hdCA9PT0gZ2wuUkdCICkge1xyXG5cclxuXHRcdFx0aWYgKCBnbFR5cGUgPT09IGdsLkZMT0FUICkgaW50ZXJuYWxGb3JtYXQgPSBnbC5SR0IzMkY7XHJcblx0XHRcdGlmICggZ2xUeXBlID09PSBnbC5IQUxGX0ZMT0FUICkgaW50ZXJuYWxGb3JtYXQgPSBnbC5SR0IxNkY7XHJcblx0XHRcdGlmICggZ2xUeXBlID09PSBnbC5VTlNJR05FRF9CWVRFICkgaW50ZXJuYWxGb3JtYXQgPSBnbC5SR0I4O1xyXG5cdFx0XHRpZiAoIGdsVHlwZSA9PT0gZ2wuVU5TSUdORURfU0hPUlQgKSBpbnRlcm5hbEZvcm1hdCA9IGdsLlJHQjE2O1xyXG5cdFx0XHRpZiAoIGdsVHlwZSA9PT0gZ2wuVU5TSUdORURfSU5UICkgaW50ZXJuYWxGb3JtYXQgPSBnbC5SR0IzMlVJO1xyXG5cdFx0XHRpZiAoIGdsVHlwZSA9PT0gZ2wuQllURSApIGludGVybmFsRm9ybWF0ID0gZ2wuUkdCOEk7XHJcblx0XHRcdGlmICggZ2xUeXBlID09PSBnbC5TSE9SVCApIGludGVybmFsRm9ybWF0ID0gZ2wuUkdCMTZJO1xyXG5cdFx0XHRpZiAoIGdsVHlwZSA9PT0gZ2wuSU5UICkgaW50ZXJuYWxGb3JtYXQgPSBnbC5SR0IzMkk7XHJcblx0XHRcdGlmICggZ2xUeXBlID09PSBnbC5VTlNJR05FRF9CWVRFICkgaW50ZXJuYWxGb3JtYXQgPSAoIGNvbG9yU3BhY2UgPT09IFNSR0JDb2xvclNwYWNlICYmIGZvcmNlTGluZWFyVHJhbnNmZXIgPT09IGZhbHNlICkgPyBnbC5TUkdCOCA6IGdsLlJHQjg7XHJcblx0XHRcdGlmICggZ2xUeXBlID09PSBnbC5VTlNJR05FRF9TSE9SVF81XzZfNSApIGludGVybmFsRm9ybWF0ID0gZ2wuUkdCNTY1O1xyXG5cdFx0XHRpZiAoIGdsVHlwZSA9PT0gZ2wuVU5TSUdORURfU0hPUlRfNV81XzVfMSApIGludGVybmFsRm9ybWF0ID0gZ2wuUkdCNV9BMTtcclxuXHRcdFx0aWYgKCBnbFR5cGUgPT09IGdsLlVOU0lHTkVEX1NIT1JUXzRfNF80XzQgKSBpbnRlcm5hbEZvcm1hdCA9IGdsLlJHQjQ7XHJcblx0XHRcdGlmICggZ2xUeXBlID09PSBnbC5VTlNJR05FRF9JTlRfNV85XzlfOV9SRVYgKSBpbnRlcm5hbEZvcm1hdCA9IGdsLlJHQjlfRTU7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggZ2xGb3JtYXQgPT09IGdsLlJHQl9JTlRFR0VSICkge1xyXG5cclxuXHRcdFx0aWYgKCBnbFR5cGUgPT09IGdsLlVOU0lHTkVEX0JZVEUgKSBpbnRlcm5hbEZvcm1hdCA9IGdsLlJHQjhVSTtcclxuXHRcdFx0aWYgKCBnbFR5cGUgPT09IGdsLlVOU0lHTkVEX1NIT1JUICkgaW50ZXJuYWxGb3JtYXQgPSBnbC5SR0IxNlVJO1xyXG5cdFx0XHRpZiAoIGdsVHlwZSA9PT0gZ2wuVU5TSUdORURfSU5UICkgaW50ZXJuYWxGb3JtYXQgPSBnbC5SR0IzMlVJO1xyXG5cdFx0XHRpZiAoIGdsVHlwZSA9PT0gZ2wuQllURSApIGludGVybmFsRm9ybWF0ID0gZ2wuUkdCOEk7XHJcblx0XHRcdGlmICggZ2xUeXBlID09PSBnbC5TSE9SVCApIGludGVybmFsRm9ybWF0ID0gZ2wuUkdCMTZJO1xyXG5cdFx0XHRpZiAoIGdsVHlwZSA9PT0gZ2wuSU5UICkgaW50ZXJuYWxGb3JtYXQgPSBnbC5SR0IzMkk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggZ2xGb3JtYXQgPT09IGdsLlJHQkEgKSB7XHJcblxyXG5cdFx0XHRpZiAoIGdsVHlwZSA9PT0gZ2wuRkxPQVQgKSBpbnRlcm5hbEZvcm1hdCA9IGdsLlJHQkEzMkY7XHJcblx0XHRcdGlmICggZ2xUeXBlID09PSBnbC5IQUxGX0ZMT0FUICkgaW50ZXJuYWxGb3JtYXQgPSBnbC5SR0JBMTZGO1xyXG5cdFx0XHRpZiAoIGdsVHlwZSA9PT0gZ2wuVU5TSUdORURfQllURSApIGludGVybmFsRm9ybWF0ID0gZ2wuUkdCQTg7XHJcblx0XHRcdGlmICggZ2xUeXBlID09PSBnbC5VTlNJR05FRF9TSE9SVCApIGludGVybmFsRm9ybWF0ID0gZ2wuUkdCQTE2O1xyXG5cdFx0XHRpZiAoIGdsVHlwZSA9PT0gZ2wuVU5TSUdORURfSU5UICkgaW50ZXJuYWxGb3JtYXQgPSBnbC5SR0JBMzJVSTtcclxuXHRcdFx0aWYgKCBnbFR5cGUgPT09IGdsLkJZVEUgKSBpbnRlcm5hbEZvcm1hdCA9IGdsLlJHQkE4STtcclxuXHRcdFx0aWYgKCBnbFR5cGUgPT09IGdsLlNIT1JUICkgaW50ZXJuYWxGb3JtYXQgPSBnbC5SR0JBMTZJO1xyXG5cdFx0XHRpZiAoIGdsVHlwZSA9PT0gZ2wuSU5UICkgaW50ZXJuYWxGb3JtYXQgPSBnbC5SR0JBMzJJO1xyXG5cdFx0XHRpZiAoIGdsVHlwZSA9PT0gZ2wuVU5TSUdORURfQllURSApIGludGVybmFsRm9ybWF0ID0gKCBjb2xvclNwYWNlID09PSBTUkdCQ29sb3JTcGFjZSAmJiBmb3JjZUxpbmVhclRyYW5zZmVyID09PSBmYWxzZSApID8gZ2wuU1JHQjhfQUxQSEE4IDogZ2wuUkdCQTg7XHJcblx0XHRcdGlmICggZ2xUeXBlID09PSBnbC5VTlNJR05FRF9TSE9SVF80XzRfNF80ICkgaW50ZXJuYWxGb3JtYXQgPSBnbC5SR0JBNDtcclxuXHRcdFx0aWYgKCBnbFR5cGUgPT09IGdsLlVOU0lHTkVEX1NIT1JUXzVfNV81XzEgKSBpbnRlcm5hbEZvcm1hdCA9IGdsLlJHQjVfQTE7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggZ2xGb3JtYXQgPT09IGdsLlJHQkFfSU5URUdFUiApIHtcclxuXHJcblx0XHRcdGlmICggZ2xUeXBlID09PSBnbC5VTlNJR05FRF9CWVRFICkgaW50ZXJuYWxGb3JtYXQgPSBnbC5SR0JBOFVJO1xyXG5cdFx0XHRpZiAoIGdsVHlwZSA9PT0gZ2wuVU5TSUdORURfU0hPUlQgKSBpbnRlcm5hbEZvcm1hdCA9IGdsLlJHQkExNlVJO1xyXG5cdFx0XHRpZiAoIGdsVHlwZSA9PT0gZ2wuVU5TSUdORURfSU5UICkgaW50ZXJuYWxGb3JtYXQgPSBnbC5SR0JBMzJVSTtcclxuXHRcdFx0aWYgKCBnbFR5cGUgPT09IGdsLkJZVEUgKSBpbnRlcm5hbEZvcm1hdCA9IGdsLlJHQkE4STtcclxuXHRcdFx0aWYgKCBnbFR5cGUgPT09IGdsLlNIT1JUICkgaW50ZXJuYWxGb3JtYXQgPSBnbC5SR0JBMTZJO1xyXG5cdFx0XHRpZiAoIGdsVHlwZSA9PT0gZ2wuSU5UICkgaW50ZXJuYWxGb3JtYXQgPSBnbC5SR0JBMzJJO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIGdsRm9ybWF0ID09PSBnbC5ERVBUSF9DT01QT05FTlQgKSB7XHJcblxyXG5cdFx0XHRpZiAoIGdsVHlwZSA9PT0gZ2wuVU5TSUdORURfSU5UICkgaW50ZXJuYWxGb3JtYXQgPSBnbC5ERVBUSDI0X1NURU5DSUw4O1xyXG5cdFx0XHRpZiAoIGdsVHlwZSA9PT0gZ2wuRkxPQVQgKSBpbnRlcm5hbEZvcm1hdCA9IGdsLkRFUFRIX0NPTVBPTkVOVDMyRjtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBnbEZvcm1hdCA9PT0gZ2wuREVQVEhfU1RFTkNJTCApIHtcclxuXHJcblx0XHRcdGlmICggZ2xUeXBlID09PSBnbC5VTlNJR05FRF9JTlRfMjRfOCApIGludGVybmFsRm9ybWF0ID0gZ2wuREVQVEgyNF9TVEVOQ0lMODtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBpbnRlcm5hbEZvcm1hdCA9PT0gZ2wuUjE2RiB8fCBpbnRlcm5hbEZvcm1hdCA9PT0gZ2wuUjMyRiB8fFxyXG5cdFx0XHRpbnRlcm5hbEZvcm1hdCA9PT0gZ2wuUkcxNkYgfHwgaW50ZXJuYWxGb3JtYXQgPT09IGdsLlJHMzJGIHx8XHJcblx0XHRcdGludGVybmFsRm9ybWF0ID09PSBnbC5SR0JBMTZGIHx8IGludGVybmFsRm9ybWF0ID09PSBnbC5SR0JBMzJGICkge1xyXG5cclxuXHRcdFx0ZXh0ZW5zaW9ucy5nZXQoICdFWFRfY29sb3JfYnVmZmVyX2Zsb2F0JyApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gaW50ZXJuYWxGb3JtYXQ7XHJcblxyXG5cdH1cclxuXHJcblx0c2V0VGV4dHVyZVBhcmFtZXRlcnMoIHRleHR1cmVUeXBlLCB0ZXh0dXJlICkge1xyXG5cclxuXHRcdGNvbnN0IHsgZ2wsIGV4dGVuc2lvbnMsIGJhY2tlbmQgfSA9IHRoaXM7XHJcblxyXG5cclxuXHRcdGdsLnBpeGVsU3RvcmVpKCBnbC5VTlBBQ0tfRkxJUF9ZX1dFQkdMLCB0ZXh0dXJlLmZsaXBZICk7XHJcblx0XHRnbC5waXhlbFN0b3JlaSggZ2wuVU5QQUNLX1BSRU1VTFRJUExZX0FMUEhBX1dFQkdMLCB0ZXh0dXJlLnByZW11bHRpcGx5QWxwaGEgKTtcclxuXHRcdGdsLnBpeGVsU3RvcmVpKCBnbC5VTlBBQ0tfQUxJR05NRU5ULCB0ZXh0dXJlLnVucGFja0FsaWdubWVudCApO1xyXG5cdFx0Z2wucGl4ZWxTdG9yZWkoIGdsLlVOUEFDS19DT0xPUlNQQUNFX0NPTlZFUlNJT05fV0VCR0wsIGdsLk5PTkUgKTtcclxuXHJcblx0XHRnbC50ZXhQYXJhbWV0ZXJpKCB0ZXh0dXJlVHlwZSwgZ2wuVEVYVFVSRV9XUkFQX1MsIHdyYXBwaW5nVG9HTFsgdGV4dHVyZS53cmFwUyBdICk7XHJcblx0XHRnbC50ZXhQYXJhbWV0ZXJpKCB0ZXh0dXJlVHlwZSwgZ2wuVEVYVFVSRV9XUkFQX1QsIHdyYXBwaW5nVG9HTFsgdGV4dHVyZS53cmFwVCBdICk7XHJcblxyXG5cdFx0aWYgKCB0ZXh0dXJlVHlwZSA9PT0gZ2wuVEVYVFVSRV8zRCB8fCB0ZXh0dXJlVHlwZSA9PT0gZ2wuVEVYVFVSRV8yRF9BUlJBWSApIHtcclxuXHJcblx0XHRcdGdsLnRleFBhcmFtZXRlcmkoIHRleHR1cmVUeXBlLCBnbC5URVhUVVJFX1dSQVBfUiwgd3JhcHBpbmdUb0dMWyB0ZXh0dXJlLndyYXBSIF0gKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Z2wudGV4UGFyYW1ldGVyaSggdGV4dHVyZVR5cGUsIGdsLlRFWFRVUkVfTUFHX0ZJTFRFUiwgZmlsdGVyVG9HTFsgdGV4dHVyZS5tYWdGaWx0ZXIgXSApO1xyXG5cclxuXHJcblx0XHRjb25zdCBoYXNNaXBtYXBzID0gdGV4dHVyZS5taXBtYXBzICE9PSB1bmRlZmluZWQgJiYgdGV4dHVyZS5taXBtYXBzLmxlbmd0aCA+IDA7XHJcblxyXG5cdFx0Ly8gZm9sbG93IFdlYkdQVSBiYWNrZW5kIG1hcHBpbmcgZm9yIHRleHR1cmUgZmlsdGVyaW5nXHJcblx0XHRjb25zdCBtaW5GaWx0ZXIgPSB0ZXh0dXJlLm1pbkZpbHRlciA9PT0gTGluZWFyRmlsdGVyICYmIGhhc01pcG1hcHMgPyBMaW5lYXJNaXBtYXBMaW5lYXJGaWx0ZXIgOiB0ZXh0dXJlLm1pbkZpbHRlcjtcclxuXHJcblx0XHRnbC50ZXhQYXJhbWV0ZXJpKCB0ZXh0dXJlVHlwZSwgZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCBmaWx0ZXJUb0dMWyBtaW5GaWx0ZXIgXSApO1xyXG5cclxuXHRcdGlmICggdGV4dHVyZS5jb21wYXJlRnVuY3Rpb24gKSB7XHJcblxyXG5cdFx0XHRnbC50ZXhQYXJhbWV0ZXJpKCB0ZXh0dXJlVHlwZSwgZ2wuVEVYVFVSRV9DT01QQVJFX01PREUsIGdsLkNPTVBBUkVfUkVGX1RPX1RFWFRVUkUgKTtcclxuXHRcdFx0Z2wudGV4UGFyYW1ldGVyaSggdGV4dHVyZVR5cGUsIGdsLlRFWFRVUkVfQ09NUEFSRV9GVU5DLCBjb21wYXJlVG9HTFsgdGV4dHVyZS5jb21wYXJlRnVuY3Rpb24gXSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIGV4dGVuc2lvbnMuaGFzKCAnRVhUX3RleHR1cmVfZmlsdGVyX2FuaXNvdHJvcGljJyApID09PSB0cnVlICkge1xyXG5cclxuXHRcdFx0aWYgKCB0ZXh0dXJlLm1hZ0ZpbHRlciA9PT0gTmVhcmVzdEZpbHRlciApIHJldHVybjtcclxuXHRcdFx0aWYgKCB0ZXh0dXJlLm1pbkZpbHRlciAhPT0gTmVhcmVzdE1pcG1hcExpbmVhckZpbHRlciAmJiB0ZXh0dXJlLm1pbkZpbHRlciAhPT0gTGluZWFyTWlwbWFwTGluZWFyRmlsdGVyICkgcmV0dXJuO1xyXG5cdFx0XHRpZiAoIHRleHR1cmUudHlwZSA9PT0gRmxvYXRUeXBlICYmIGV4dGVuc2lvbnMuaGFzKCAnT0VTX3RleHR1cmVfZmxvYXRfbGluZWFyJyApID09PSBmYWxzZSApIHJldHVybjsgLy8gdmVyaWZ5IGV4dGVuc2lvbiBmb3IgV2ViR0wgMSBhbmQgV2ViR0wgMlxyXG5cclxuXHRcdFx0aWYgKCB0ZXh0dXJlLmFuaXNvdHJvcHkgPiAxICkge1xyXG5cclxuXHRcdFx0XHRjb25zdCBleHRlbnNpb24gPSBleHRlbnNpb25zLmdldCggJ0VYVF90ZXh0dXJlX2ZpbHRlcl9hbmlzb3Ryb3BpYycgKTtcclxuXHRcdFx0XHRnbC50ZXhQYXJhbWV0ZXJmKCB0ZXh0dXJlVHlwZSwgZXh0ZW5zaW9uLlRFWFRVUkVfTUFYX0FOSVNPVFJPUFlfRVhULCBNYXRoLm1pbiggdGV4dHVyZS5hbmlzb3Ryb3B5LCBiYWNrZW5kLmdldE1heEFuaXNvdHJvcHkoKSApICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdGNyZWF0ZURlZmF1bHRUZXh0dXJlKCB0ZXh0dXJlICkge1xyXG5cclxuXHRcdGNvbnN0IHsgZ2wsIGJhY2tlbmQsIGRlZmF1bHRUZXh0dXJlcyB9ID0gdGhpcztcclxuXHJcblxyXG5cdFx0Y29uc3QgZ2xUZXh0dXJlVHlwZSA9IHRoaXMuZ2V0R0xUZXh0dXJlVHlwZSggdGV4dHVyZSApO1xyXG5cclxuXHRcdGxldCB0ZXh0dXJlR1BVID0gZGVmYXVsdFRleHR1cmVzWyBnbFRleHR1cmVUeXBlIF07XHJcblxyXG5cdFx0aWYgKCB0ZXh0dXJlR1BVID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHR0ZXh0dXJlR1BVID0gZ2wuY3JlYXRlVGV4dHVyZSgpO1xyXG5cclxuXHRcdFx0YmFja2VuZC5zdGF0ZS5iaW5kVGV4dHVyZSggZ2xUZXh0dXJlVHlwZSwgdGV4dHVyZUdQVSApO1xyXG5cdFx0XHRnbC50ZXhQYXJhbWV0ZXJpKCBnbFRleHR1cmVUeXBlLCBnbC5URVhUVVJFX01JTl9GSUxURVIsIGdsLk5FQVJFU1QgKTtcclxuXHRcdFx0Z2wudGV4UGFyYW1ldGVyaSggZ2xUZXh0dXJlVHlwZSwgZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCBnbC5ORUFSRVNUICk7XHJcblxyXG5cdFx0XHQvLyBnbC50ZXhJbWFnZTJEKCBnbFRleHR1cmVUeXBlLCAwLCBnbC5SR0JBLCAxLCAxLCAwLCBnbC5SR0JBLCBnbC5VTlNJR05FRF9CWVRFLCBkYXRhICk7XHJcblxyXG5cdFx0XHRkZWZhdWx0VGV4dHVyZXNbIGdsVGV4dHVyZVR5cGUgXSA9IHRleHR1cmVHUFU7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGJhY2tlbmQuc2V0KCB0ZXh0dXJlLCB7XHJcblx0XHRcdHRleHR1cmVHUFUsXHJcblx0XHRcdGdsVGV4dHVyZVR5cGUsXHJcblx0XHRcdGlzRGVmYXVsdDogdHJ1ZVxyXG5cdFx0fSApO1xyXG5cclxuXHR9XHJcblxyXG5cdGNyZWF0ZVRleHR1cmUoIHRleHR1cmUsIG9wdGlvbnMgKSB7XHJcblxyXG5cdFx0Y29uc3QgeyBnbCwgYmFja2VuZCB9ID0gdGhpcztcclxuXHRcdGNvbnN0IHsgbGV2ZWxzLCB3aWR0aCwgaGVpZ2h0LCBkZXB0aCB9ID0gb3B0aW9ucztcclxuXHJcblx0XHRjb25zdCBnbEZvcm1hdCA9IGJhY2tlbmQudXRpbHMuY29udmVydCggdGV4dHVyZS5mb3JtYXQsIHRleHR1cmUuY29sb3JTcGFjZSApO1xyXG5cdFx0Y29uc3QgZ2xUeXBlID0gYmFja2VuZC51dGlscy5jb252ZXJ0KCB0ZXh0dXJlLnR5cGUgKTtcclxuXHRcdGNvbnN0IGdsSW50ZXJuYWxGb3JtYXQgPSB0aGlzLmdldEludGVybmFsRm9ybWF0KCB0ZXh0dXJlLmludGVybmFsRm9ybWF0LCBnbEZvcm1hdCwgZ2xUeXBlLCB0ZXh0dXJlLmNvbG9yU3BhY2UsIHRleHR1cmUuaXNWaWRlb1RleHR1cmUgKTtcclxuXHJcblx0XHRjb25zdCB0ZXh0dXJlR1BVID0gZ2wuY3JlYXRlVGV4dHVyZSgpO1xyXG5cdFx0Y29uc3QgZ2xUZXh0dXJlVHlwZSA9IHRoaXMuZ2V0R0xUZXh0dXJlVHlwZSggdGV4dHVyZSApO1xyXG5cclxuXHRcdGJhY2tlbmQuc3RhdGUuYmluZFRleHR1cmUoIGdsVGV4dHVyZVR5cGUsIHRleHR1cmVHUFUgKTtcclxuXHJcblx0XHR0aGlzLnNldFRleHR1cmVQYXJhbWV0ZXJzKCBnbFRleHR1cmVUeXBlLCB0ZXh0dXJlICk7XHJcblxyXG5cdFx0aWYgKCB0ZXh0dXJlLmlzRGF0YUFycmF5VGV4dHVyZSB8fCB0ZXh0dXJlLmlzQ29tcHJlc3NlZEFycmF5VGV4dHVyZSApIHtcclxuXHJcblx0XHRcdGdsLnRleFN0b3JhZ2UzRCggZ2wuVEVYVFVSRV8yRF9BUlJBWSwgbGV2ZWxzLCBnbEludGVybmFsRm9ybWF0LCB3aWR0aCwgaGVpZ2h0LCBkZXB0aCApO1xyXG5cclxuXHRcdH0gZWxzZSBpZiAoIHRleHR1cmUuaXNEYXRhM0RUZXh0dXJlICkge1xyXG5cclxuXHRcdFx0Z2wudGV4U3RvcmFnZTNEKCBnbC5URVhUVVJFXzNELCBsZXZlbHMsIGdsSW50ZXJuYWxGb3JtYXQsIHdpZHRoLCBoZWlnaHQsIGRlcHRoICk7XHJcblxyXG5cdFx0fSBlbHNlIGlmICggISB0ZXh0dXJlLmlzVmlkZW9UZXh0dXJlICkge1xyXG5cclxuXHRcdFx0Z2wudGV4U3RvcmFnZTJEKCBnbFRleHR1cmVUeXBlLCBsZXZlbHMsIGdsSW50ZXJuYWxGb3JtYXQsIHdpZHRoLCBoZWlnaHQgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0YmFja2VuZC5zZXQoIHRleHR1cmUsIHtcclxuXHRcdFx0dGV4dHVyZUdQVSxcclxuXHRcdFx0Z2xUZXh0dXJlVHlwZSxcclxuXHRcdFx0Z2xGb3JtYXQsXHJcblx0XHRcdGdsVHlwZSxcclxuXHRcdFx0Z2xJbnRlcm5hbEZvcm1hdFxyXG5cdFx0fSApO1xyXG5cclxuXHR9XHJcblxyXG5cdGNvcHlCdWZmZXJUb1RleHR1cmUoIGJ1ZmZlciwgdGV4dHVyZSApIHtcclxuXHJcblx0XHRjb25zdCB7IGdsLCBiYWNrZW5kIH0gPSB0aGlzO1xyXG5cclxuXHRcdGNvbnN0IHsgdGV4dHVyZUdQVSwgZ2xUZXh0dXJlVHlwZSwgZ2xGb3JtYXQsIGdsVHlwZSB9ID0gYmFja2VuZC5nZXQoIHRleHR1cmUgKTtcclxuXHJcblx0XHRjb25zdCB7IHdpZHRoLCBoZWlnaHQgfSA9IHRleHR1cmUuc291cmNlLmRhdGE7XHJcblxyXG5cdFx0Z2wuYmluZEJ1ZmZlciggZ2wuUElYRUxfVU5QQUNLX0JVRkZFUiwgYnVmZmVyICk7XHJcblxyXG5cdFx0YmFja2VuZC5zdGF0ZS5iaW5kVGV4dHVyZSggZ2xUZXh0dXJlVHlwZSwgdGV4dHVyZUdQVSApO1xyXG5cclxuXHRcdGdsLnBpeGVsU3RvcmVpKCBnbC5VTlBBQ0tfRkxJUF9ZX1dFQkdMLCBmYWxzZSApO1xyXG5cdFx0Z2wucGl4ZWxTdG9yZWkoIGdsLlVOUEFDS19QUkVNVUxUSVBMWV9BTFBIQV9XRUJHTCwgZmFsc2UgKTtcclxuXHRcdGdsLnRleFN1YkltYWdlMkQoIGdsVGV4dHVyZVR5cGUsIDAsIDAsIDAsIHdpZHRoLCBoZWlnaHQsIGdsRm9ybWF0LCBnbFR5cGUsIDAgKTtcclxuXHJcblx0XHRnbC5iaW5kQnVmZmVyKCBnbC5QSVhFTF9VTlBBQ0tfQlVGRkVSLCBudWxsICk7XHJcblxyXG5cdFx0YmFja2VuZC5zdGF0ZS51bmJpbmRUZXh0dXJlKCk7XHJcblx0XHQvLyBkZWJ1Z1xyXG5cdFx0Ly8gY29uc3QgZnJhbWVidWZmZXIgPSBnbC5jcmVhdGVGcmFtZWJ1ZmZlcigpO1xyXG5cdFx0Ly8gZ2wuYmluZEZyYW1lYnVmZmVyKCBnbC5GUkFNRUJVRkZFUiwgZnJhbWVidWZmZXIgKTtcclxuXHRcdC8vIGdsLmZyYW1lYnVmZmVyVGV4dHVyZTJEKCBnbC5GUkFNRUJVRkZFUiwgZ2wuQ09MT1JfQVRUQUNITUVOVDAsIGdsVGV4dHVyZVR5cGUsIHRleHR1cmVHUFUsIDAgKTtcclxuXHJcblx0XHQvLyBjb25zdCByZWFkb3V0ID0gbmV3IEZsb2F0MzJBcnJheSggd2lkdGggKiBoZWlnaHQgKiA0ICk7XHJcblxyXG5cdFx0Ly8gY29uc3QgYWx0Rm9ybWF0ID0gZ2wuZ2V0UGFyYW1ldGVyKCBnbC5JTVBMRU1FTlRBVElPTl9DT0xPUl9SRUFEX0ZPUk1BVCApO1xyXG5cdFx0Ly8gY29uc3QgYWx0VHlwZSA9IGdsLmdldFBhcmFtZXRlciggZ2wuSU1QTEVNRU5UQVRJT05fQ09MT1JfUkVBRF9UWVBFICk7XHJcblxyXG5cdFx0Ly8gZ2wucmVhZFBpeGVscyggMCwgMCwgd2lkdGgsIGhlaWdodCwgYWx0Rm9ybWF0LCBhbHRUeXBlLCByZWFkb3V0ICk7XHJcblx0XHQvLyBnbC5iaW5kRnJhbWVidWZmZXIoIGdsLkZSQU1FQlVGRkVSLCBudWxsICk7XHJcblx0XHQvLyBjb25zb2xlLmxvZyggcmVhZG91dCApO1xyXG5cclxuXHR9XHJcblxyXG5cdHVwZGF0ZVRleHR1cmUoIHRleHR1cmUsIG9wdGlvbnMgKSB7XHJcblxyXG5cdFx0Y29uc3QgeyBnbCB9ID0gdGhpcztcclxuXHRcdGNvbnN0IHsgd2lkdGgsIGhlaWdodCB9ID0gb3B0aW9ucztcclxuXHRcdGNvbnN0IHsgdGV4dHVyZUdQVSwgZ2xUZXh0dXJlVHlwZSwgZ2xGb3JtYXQsIGdsVHlwZSwgZ2xJbnRlcm5hbEZvcm1hdCB9ID0gdGhpcy5iYWNrZW5kLmdldCggdGV4dHVyZSApO1xyXG5cclxuXHRcdGlmICggdGV4dHVyZS5pc1JlbmRlclRhcmdldFRleHR1cmUgfHwgKCB0ZXh0dXJlR1BVID09PSB1bmRlZmluZWQgLyogdW5zdXBwb3J0ZWQgdGV4dHVyZSBmb3JtYXQgKi8gKSApXHJcblx0XHRcdHJldHVybjtcclxuXHJcblx0XHRjb25zdCBnZXRJbWFnZSA9ICggc291cmNlICkgPT4ge1xyXG5cclxuXHRcdFx0aWYgKCBzb3VyY2UuaXNEYXRhVGV4dHVyZSApIHtcclxuXHJcblx0XHRcdFx0cmV0dXJuIHNvdXJjZS5pbWFnZS5kYXRhO1xyXG5cclxuXHRcdFx0fSBlbHNlIGlmICggKCB0eXBlb2YgSFRNTEltYWdlRWxlbWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgc291cmNlIGluc3RhbmNlb2YgSFRNTEltYWdlRWxlbWVudCApIHx8XHJcblx0XHRcdFx0KCB0eXBlb2YgSFRNTENhbnZhc0VsZW1lbnQgIT09ICd1bmRlZmluZWQnICYmIHNvdXJjZSBpbnN0YW5jZW9mIEhUTUxDYW52YXNFbGVtZW50ICkgfHxcclxuXHRcdFx0XHQoIHR5cGVvZiBJbWFnZUJpdG1hcCAhPT0gJ3VuZGVmaW5lZCcgJiYgc291cmNlIGluc3RhbmNlb2YgSW1hZ2VCaXRtYXAgKSB8fFxyXG5cdFx0XHRcdHNvdXJjZSBpbnN0YW5jZW9mIE9mZnNjcmVlbkNhbnZhcyApIHtcclxuXHJcblx0XHRcdFx0cmV0dXJuIHNvdXJjZTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHJldHVybiBzb3VyY2UuZGF0YTtcclxuXHJcblx0XHR9O1xyXG5cclxuXHRcdHRoaXMuYmFja2VuZC5zdGF0ZS5iaW5kVGV4dHVyZSggZ2xUZXh0dXJlVHlwZSwgdGV4dHVyZUdQVSApO1xyXG5cclxuXHRcdHRoaXMuc2V0VGV4dHVyZVBhcmFtZXRlcnMoIGdsVGV4dHVyZVR5cGUsIHRleHR1cmUgKTtcclxuXHJcblx0XHRpZiAoIHRleHR1cmUuaXNDb21wcmVzc2VkVGV4dHVyZSApIHtcclxuXHJcblx0XHRcdGNvbnN0IG1pcG1hcHMgPSB0ZXh0dXJlLm1pcG1hcHM7XHJcblx0XHRcdGNvbnN0IGltYWdlID0gb3B0aW9ucy5pbWFnZTtcclxuXHJcblx0XHRcdGZvciAoIGxldCBpID0gMDsgaSA8IG1pcG1hcHMubGVuZ3RoOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHRjb25zdCBtaXBtYXAgPSBtaXBtYXBzWyBpIF07XHJcblxyXG5cdFx0XHRcdGlmICggdGV4dHVyZS5pc0NvbXByZXNzZWRBcnJheVRleHR1cmUgKSB7XHJcblxyXG5cclxuXHRcdFx0XHRcdGlmICggdGV4dHVyZS5mb3JtYXQgIT09IGdsLlJHQkEgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRpZiAoIGdsRm9ybWF0ICE9PSBudWxsICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHRnbC5jb21wcmVzc2VkVGV4U3ViSW1hZ2UzRCggZ2wuVEVYVFVSRV8yRF9BUlJBWSwgaSwgMCwgMCwgMCwgbWlwbWFwLndpZHRoLCBtaXBtYXAuaGVpZ2h0LCBpbWFnZS5kZXB0aCwgZ2xGb3JtYXQsIG1pcG1hcC5kYXRhICk7XHJcblxyXG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlcmVyOiBBdHRlbXB0IHRvIGxvYWQgdW5zdXBwb3J0ZWQgY29tcHJlc3NlZCB0ZXh0dXJlIGZvcm1hdCBpbiAudXBsb2FkVGV4dHVyZSgpJyApO1xyXG5cclxuXHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0XHRnbC50ZXhTdWJJbWFnZTNEKCBnbC5URVhUVVJFXzJEX0FSUkFZLCBpLCAwLCAwLCAwLCBtaXBtYXAud2lkdGgsIG1pcG1hcC5oZWlnaHQsIGltYWdlLmRlcHRoLCBnbEZvcm1hdCwgZ2xUeXBlLCBtaXBtYXAuZGF0YSApO1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHRpZiAoIGdsRm9ybWF0ICE9PSBudWxsICkge1xyXG5cclxuXHRcdFx0XHRcdFx0Z2wuY29tcHJlc3NlZFRleFN1YkltYWdlMkQoIGdsLlRFWFRVUkVfMkQsIGksIDAsIDAsIG1pcG1hcC53aWR0aCwgbWlwbWFwLmhlaWdodCwgZ2xGb3JtYXQsIG1pcG1hcC5kYXRhICk7XHJcblxyXG5cdFx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHRcdGNvbnNvbGUud2FybiggJ1Vuc3VwcG9ydGVkIGNvbXByZXNzZWQgdGV4dHVyZSBmb3JtYXQnICk7XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cclxuXHRcdH0gZWxzZSBpZiAoIHRleHR1cmUuaXNDdWJlVGV4dHVyZSApIHtcclxuXHJcblx0XHRcdGNvbnN0IGltYWdlcyA9IG9wdGlvbnMuaW1hZ2VzO1xyXG5cclxuXHRcdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgNjsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0Y29uc3QgaW1hZ2UgPSBnZXRJbWFnZSggaW1hZ2VzWyBpIF0gKTtcclxuXHJcblx0XHRcdFx0Z2wudGV4U3ViSW1hZ2UyRCggZ2wuVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9YICsgaSwgMCwgMCwgMCwgd2lkdGgsIGhlaWdodCwgZ2xGb3JtYXQsIGdsVHlwZSwgaW1hZ2UgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9IGVsc2UgaWYgKCB0ZXh0dXJlLmlzRGF0YUFycmF5VGV4dHVyZSApIHtcclxuXHJcblx0XHRcdGNvbnN0IGltYWdlID0gb3B0aW9ucy5pbWFnZTtcclxuXHJcblx0XHRcdGdsLnRleFN1YkltYWdlM0QoIGdsLlRFWFRVUkVfMkRfQVJSQVksIDAsIDAsIDAsIDAsIGltYWdlLndpZHRoLCBpbWFnZS5oZWlnaHQsIGltYWdlLmRlcHRoLCBnbEZvcm1hdCwgZ2xUeXBlLCBpbWFnZS5kYXRhICk7XHJcblxyXG5cdFx0fSBlbHNlIGlmICggdGV4dHVyZS5pc0RhdGEzRFRleHR1cmUgKSB7XHJcblxyXG5cdFx0XHRjb25zdCBpbWFnZSA9IG9wdGlvbnMuaW1hZ2U7XHJcblxyXG5cdFx0XHRnbC50ZXhTdWJJbWFnZTNEKCBnbC5URVhUVVJFXzNELCAwLCAwLCAwLCAwLCBpbWFnZS53aWR0aCwgaW1hZ2UuaGVpZ2h0LCBpbWFnZS5kZXB0aCwgZ2xGb3JtYXQsIGdsVHlwZSwgaW1hZ2UuZGF0YSApO1xyXG5cclxuXHRcdH0gZWxzZSBpZiAoIHRleHR1cmUuaXNWaWRlb1RleHR1cmUgKSB7XHJcblxyXG5cdFx0XHR0ZXh0dXJlLnVwZGF0ZSgpO1xyXG5cclxuXHRcdFx0Z2wudGV4SW1hZ2UyRCggZ2xUZXh0dXJlVHlwZSwgMCwgZ2xJbnRlcm5hbEZvcm1hdCwgZ2xGb3JtYXQsIGdsVHlwZSwgb3B0aW9ucy5pbWFnZSApO1xyXG5cclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0Y29uc3QgaW1hZ2UgPSBnZXRJbWFnZSggb3B0aW9ucy5pbWFnZSApO1xyXG5cclxuXHRcdFx0Z2wudGV4U3ViSW1hZ2UyRCggZ2xUZXh0dXJlVHlwZSwgMCwgMCwgMCwgd2lkdGgsIGhlaWdodCwgZ2xGb3JtYXQsIGdsVHlwZSwgaW1hZ2UgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0Z2VuZXJhdGVNaXBtYXBzKCB0ZXh0dXJlICkge1xyXG5cclxuXHRcdGNvbnN0IHsgZ2wsIGJhY2tlbmQgfSA9IHRoaXM7XHJcblx0XHRjb25zdCB7IHRleHR1cmVHUFUsIGdsVGV4dHVyZVR5cGUgfSA9IGJhY2tlbmQuZ2V0KCB0ZXh0dXJlICk7XHJcblxyXG5cdFx0YmFja2VuZC5zdGF0ZS5iaW5kVGV4dHVyZSggZ2xUZXh0dXJlVHlwZSwgdGV4dHVyZUdQVSApO1xyXG5cdFx0Z2wuZ2VuZXJhdGVNaXBtYXAoIGdsVGV4dHVyZVR5cGUgKTtcclxuXHJcblx0fVxyXG5cclxuXHRkZWFsbG9jYXRlUmVuZGVyQnVmZmVycyggcmVuZGVyVGFyZ2V0ICkge1xyXG5cclxuXHRcdGNvbnN0IHsgZ2wsIGJhY2tlbmQgfSA9IHRoaXM7XHJcblxyXG5cdFx0Ly8gcmVtb3ZlIGZyYW1lYnVmZmVyIHJlZmVyZW5jZVxyXG5cdFx0aWYgKCByZW5kZXJUYXJnZXQgKSB7XHJcblxyXG5cdFx0XHRjb25zdCByZW5kZXJDb250ZXh0RGF0YSA9IGJhY2tlbmQuZ2V0KCByZW5kZXJUYXJnZXQgKTtcclxuXHJcblx0XHRcdHJlbmRlckNvbnRleHREYXRhLnJlbmRlckJ1ZmZlclN0b3JhZ2VTZXR1cCA9IHVuZGVmaW5lZDtcclxuXHJcblx0XHRcdGlmICggcmVuZGVyQ29udGV4dERhdGEuZnJhbWVidWZmZXJzICkge1xyXG5cclxuXHRcdFx0XHRmb3IgKCBjb25zdCBjYWNoZUtleSBpbiByZW5kZXJDb250ZXh0RGF0YS5mcmFtZWJ1ZmZlcnMgKSB7XHJcblxyXG5cdFx0XHRcdFx0Z2wuZGVsZXRlRnJhbWVidWZmZXIoIHJlbmRlckNvbnRleHREYXRhLmZyYW1lYnVmZmVyc1sgY2FjaGVLZXkgXSApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGRlbGV0ZSByZW5kZXJDb250ZXh0RGF0YS5mcmFtZWJ1ZmZlcnM7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoIHJlbmRlckNvbnRleHREYXRhLmRlcHRoUmVuZGVyYnVmZmVyICkge1xyXG5cclxuXHRcdFx0XHRnbC5kZWxldGVSZW5kZXJidWZmZXIoIHJlbmRlckNvbnRleHREYXRhLmRlcHRoUmVuZGVyYnVmZmVyICk7XHJcblx0XHRcdFx0ZGVsZXRlIHJlbmRlckNvbnRleHREYXRhLmRlcHRoUmVuZGVyYnVmZmVyO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKCByZW5kZXJDb250ZXh0RGF0YS5zdGVuY2lsUmVuZGVyYnVmZmVyICkge1xyXG5cclxuXHRcdFx0XHRnbC5kZWxldGVSZW5kZXJidWZmZXIoIHJlbmRlckNvbnRleHREYXRhLnN0ZW5jaWxSZW5kZXJidWZmZXIgKTtcclxuXHRcdFx0XHRkZWxldGUgcmVuZGVyQ29udGV4dERhdGEuc3RlbmNpbFJlbmRlcmJ1ZmZlcjtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICggcmVuZGVyQ29udGV4dERhdGEubXNhYUZyYW1lQnVmZmVyICkge1xyXG5cclxuXHRcdFx0XHRnbC5kZWxldGVGcmFtZWJ1ZmZlciggcmVuZGVyQ29udGV4dERhdGEubXNhYUZyYW1lQnVmZmVyICk7XHJcblx0XHRcdFx0ZGVsZXRlIHJlbmRlckNvbnRleHREYXRhLm1zYWFGcmFtZUJ1ZmZlcjtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICggcmVuZGVyQ29udGV4dERhdGEubXNhYVJlbmRlcmJ1ZmZlcnMgKSB7XHJcblxyXG5cdFx0XHRcdGZvciAoIGxldCBpID0gMDsgaSA8IHJlbmRlckNvbnRleHREYXRhLm1zYWFSZW5kZXJidWZmZXJzLmxlbmd0aDsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0XHRnbC5kZWxldGVSZW5kZXJidWZmZXIoIHJlbmRlckNvbnRleHREYXRhLm1zYWFSZW5kZXJidWZmZXJzWyBpIF0gKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRkZWxldGUgcmVuZGVyQ29udGV4dERhdGEubXNhYVJlbmRlcmJ1ZmZlcnM7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdGRlc3Ryb3lUZXh0dXJlKCB0ZXh0dXJlICkge1xyXG5cclxuXHRcdGNvbnN0IHsgZ2wsIGJhY2tlbmQgfSA9IHRoaXM7XHJcblx0XHRjb25zdCB7IHRleHR1cmVHUFUsIHJlbmRlclRhcmdldCB9ID0gYmFja2VuZC5nZXQoIHRleHR1cmUgKTtcclxuXHJcblx0XHR0aGlzLmRlYWxsb2NhdGVSZW5kZXJCdWZmZXJzKCByZW5kZXJUYXJnZXQgKTtcclxuXHRcdGdsLmRlbGV0ZVRleHR1cmUoIHRleHR1cmVHUFUgKTtcclxuXHJcblx0XHRiYWNrZW5kLmRlbGV0ZSggdGV4dHVyZSApO1xyXG5cclxuXHR9XHJcblxyXG5cdGNvcHlUZXh0dXJlVG9UZXh0dXJlKCBzcmNUZXh0dXJlLCBkc3RUZXh0dXJlLCBzcmNSZWdpb24gPSBudWxsLCBkc3RQb3NpdGlvbiA9IG51bGwsIGxldmVsID0gMCApIHtcclxuXHJcblx0XHRjb25zdCB7IGdsLCBiYWNrZW5kIH0gPSB0aGlzO1xyXG5cdFx0Y29uc3QgeyBzdGF0ZSB9ID0gdGhpcy5iYWNrZW5kO1xyXG5cclxuXHRcdGNvbnN0IHsgdGV4dHVyZUdQVTogZHN0VGV4dHVyZUdQVSwgZ2xUZXh0dXJlVHlwZSwgZ2xUeXBlLCBnbEZvcm1hdCB9ID0gYmFja2VuZC5nZXQoIGRzdFRleHR1cmUgKTtcclxuXHJcblx0XHRsZXQgd2lkdGgsIGhlaWdodCwgbWluWCwgbWluWTtcclxuXHRcdGxldCBkc3RYLCBkc3RZO1xyXG5cclxuXHRcdGlmICggc3JjUmVnaW9uICE9PSBudWxsICkge1xyXG5cclxuXHRcdFx0d2lkdGggPSBzcmNSZWdpb24ubWF4LnggLSBzcmNSZWdpb24ubWluLng7XHJcblx0XHRcdGhlaWdodCA9IHNyY1JlZ2lvbi5tYXgueSAtIHNyY1JlZ2lvbi5taW4ueTtcclxuXHRcdFx0bWluWCA9IHNyY1JlZ2lvbi5taW4ueDtcclxuXHRcdFx0bWluWSA9IHNyY1JlZ2lvbi5taW4ueTtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0d2lkdGggPSBzcmNUZXh0dXJlLmltYWdlLndpZHRoO1xyXG5cdFx0XHRoZWlnaHQgPSBzcmNUZXh0dXJlLmltYWdlLmhlaWdodDtcclxuXHRcdFx0bWluWCA9IDA7XHJcblx0XHRcdG1pblkgPSAwO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIGRzdFBvc2l0aW9uICE9PSBudWxsICkge1xyXG5cclxuXHRcdFx0ZHN0WCA9IGRzdFBvc2l0aW9uLng7XHJcblx0XHRcdGRzdFkgPSBkc3RQb3NpdGlvbi55O1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRkc3RYID0gMDtcclxuXHRcdFx0ZHN0WSA9IDA7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHN0YXRlLmJpbmRUZXh0dXJlKCBnbFRleHR1cmVUeXBlLCBkc3RUZXh0dXJlR1BVICk7XHJcblxyXG5cdFx0Ly8gQXMgYW5vdGhlciB0ZXh0dXJlIHVwbG9hZCBtYXkgaGF2ZSBjaGFuZ2VkIHBpeGVsU3RvcmVpXHJcblx0XHQvLyBwYXJhbWV0ZXJzLCBtYWtlIHN1cmUgdGhleSBhcmUgY29ycmVjdCBmb3IgdGhlIGRzdFRleHR1cmVcclxuXHRcdGdsLnBpeGVsU3RvcmVpKCBnbC5VTlBBQ0tfQUxJR05NRU5ULCBkc3RUZXh0dXJlLnVucGFja0FsaWdubWVudCApO1xyXG5cdFx0Z2wucGl4ZWxTdG9yZWkoIGdsLlVOUEFDS19GTElQX1lfV0VCR0wsIGRzdFRleHR1cmUuZmxpcFkgKTtcclxuXHRcdGdsLnBpeGVsU3RvcmVpKCBnbC5VTlBBQ0tfUFJFTVVMVElQTFlfQUxQSEFfV0VCR0wsIGRzdFRleHR1cmUucHJlbXVsdGlwbHlBbHBoYSApO1xyXG5cdFx0Z2wucGl4ZWxTdG9yZWkoIGdsLlVOUEFDS19BTElHTk1FTlQsIGRzdFRleHR1cmUudW5wYWNrQWxpZ25tZW50ICk7XHJcblxyXG5cdFx0Y29uc3QgY3VycmVudFVucGFja1Jvd0xlbiA9IGdsLmdldFBhcmFtZXRlciggZ2wuVU5QQUNLX1JPV19MRU5HVEggKTtcclxuXHRcdGNvbnN0IGN1cnJlbnRVbnBhY2tJbWFnZUhlaWdodCA9IGdsLmdldFBhcmFtZXRlciggZ2wuVU5QQUNLX0lNQUdFX0hFSUdIVCApO1xyXG5cdFx0Y29uc3QgY3VycmVudFVucGFja1NraXBQaXhlbHMgPSBnbC5nZXRQYXJhbWV0ZXIoIGdsLlVOUEFDS19TS0lQX1BJWEVMUyApO1xyXG5cdFx0Y29uc3QgY3VycmVudFVucGFja1NraXBSb3dzID0gZ2wuZ2V0UGFyYW1ldGVyKCBnbC5VTlBBQ0tfU0tJUF9ST1dTICk7XHJcblx0XHRjb25zdCBjdXJyZW50VW5wYWNrU2tpcEltYWdlcyA9IGdsLmdldFBhcmFtZXRlciggZ2wuVU5QQUNLX1NLSVBfSU1BR0VTICk7XHJcblxyXG5cdFx0Y29uc3QgaW1hZ2UgPSBzcmNUZXh0dXJlLmlzQ29tcHJlc3NlZFRleHR1cmUgPyBzcmNUZXh0dXJlLm1pcG1hcHNbIGxldmVsIF0gOiBzcmNUZXh0dXJlLmltYWdlO1xyXG5cclxuXHRcdGdsLnBpeGVsU3RvcmVpKCBnbC5VTlBBQ0tfUk9XX0xFTkdUSCwgaW1hZ2Uud2lkdGggKTtcclxuXHRcdGdsLnBpeGVsU3RvcmVpKCBnbC5VTlBBQ0tfSU1BR0VfSEVJR0hULCBpbWFnZS5oZWlnaHQgKTtcclxuXHRcdGdsLnBpeGVsU3RvcmVpKCBnbC5VTlBBQ0tfU0tJUF9QSVhFTFMsIG1pblggKTtcclxuXHRcdGdsLnBpeGVsU3RvcmVpKCBnbC5VTlBBQ0tfU0tJUF9ST1dTLCBtaW5ZICk7XHJcblxyXG5cdFx0aWYgKCBzcmNUZXh0dXJlLmlzUmVuZGVyVGFyZ2V0VGV4dHVyZSB8fCBzcmNUZXh0dXJlLmlzRGVwdGhUZXh0dXJlICkge1xyXG5cclxuXHRcdFx0Y29uc3Qgc3JjVGV4dHVyZURhdGEgPSBiYWNrZW5kLmdldCggc3JjVGV4dHVyZSApO1xyXG5cdFx0XHRjb25zdCBkc3RUZXh0dXJlRGF0YSA9IGJhY2tlbmQuZ2V0KCBkc3RUZXh0dXJlICk7XHJcblxyXG5cdFx0XHRjb25zdCBzcmNSZW5kZXJDb250ZXh0RGF0YSA9IGJhY2tlbmQuZ2V0KCBzcmNUZXh0dXJlRGF0YS5yZW5kZXJUYXJnZXQgKTtcclxuXHRcdFx0Y29uc3QgZHN0UmVuZGVyQ29udGV4dERhdGEgPSBiYWNrZW5kLmdldCggZHN0VGV4dHVyZURhdGEucmVuZGVyVGFyZ2V0ICk7XHJcblxyXG5cdFx0XHRjb25zdCBzcmNGcmFtZWJ1ZmZlciA9IHNyY1JlbmRlckNvbnRleHREYXRhLmZyYW1lYnVmZmVyc1sgc3JjVGV4dHVyZURhdGEuY2FjaGVLZXkgXTtcclxuXHRcdFx0Y29uc3QgZHN0RnJhbWVidWZmZXIgPSBkc3RSZW5kZXJDb250ZXh0RGF0YS5mcmFtZWJ1ZmZlcnNbIGRzdFRleHR1cmVEYXRhLmNhY2hlS2V5IF07XHJcblxyXG5cdFx0XHRzdGF0ZS5iaW5kRnJhbWVidWZmZXIoIGdsLlJFQURfRlJBTUVCVUZGRVIsIHNyY0ZyYW1lYnVmZmVyICk7XHJcblx0XHRcdHN0YXRlLmJpbmRGcmFtZWJ1ZmZlciggZ2wuRFJBV19GUkFNRUJVRkZFUiwgZHN0RnJhbWVidWZmZXIgKTtcclxuXHJcblx0XHRcdGxldCBtYXNrID0gZ2wuQ09MT1JfQlVGRkVSX0JJVDtcclxuXHJcblx0XHRcdGlmICggc3JjVGV4dHVyZS5pc0RlcHRoVGV4dHVyZSApIG1hc2sgPSBnbC5ERVBUSF9CVUZGRVJfQklUO1xyXG5cclxuXHRcdFx0Z2wuYmxpdEZyYW1lYnVmZmVyKCBtaW5YLCBtaW5ZLCB3aWR0aCwgaGVpZ2h0LCBkc3RYLCBkc3RZLCB3aWR0aCwgaGVpZ2h0LCBtYXNrLCBnbC5ORUFSRVNUICk7XHJcblxyXG5cdFx0XHRzdGF0ZS5iaW5kRnJhbWVidWZmZXIoIGdsLlJFQURfRlJBTUVCVUZGRVIsIG51bGwgKTtcclxuXHRcdFx0c3RhdGUuYmluZEZyYW1lYnVmZmVyKCBnbC5EUkFXX0ZSQU1FQlVGRkVSLCBudWxsICk7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdGlmICggc3JjVGV4dHVyZS5pc0RhdGFUZXh0dXJlICkge1xyXG5cclxuXHRcdFx0XHRnbC50ZXhTdWJJbWFnZTJEKCBnbC5URVhUVVJFXzJELCBsZXZlbCwgZHN0WCwgZHN0WSwgd2lkdGgsIGhlaWdodCwgZ2xGb3JtYXQsIGdsVHlwZSwgaW1hZ2UuZGF0YSApO1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0aWYgKCBzcmNUZXh0dXJlLmlzQ29tcHJlc3NlZFRleHR1cmUgKSB7XHJcblxyXG5cdFx0XHRcdFx0Z2wuY29tcHJlc3NlZFRleFN1YkltYWdlMkQoIGdsLlRFWFRVUkVfMkQsIGxldmVsLCBkc3RYLCBkc3RZLCBpbWFnZS53aWR0aCwgaW1hZ2UuaGVpZ2h0LCBnbEZvcm1hdCwgaW1hZ2UuZGF0YSApO1xyXG5cclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdGdsLnRleFN1YkltYWdlMkQoIGdsLlRFWFRVUkVfMkQsIGxldmVsLCBkc3RYLCBkc3RZLCB3aWR0aCwgaGVpZ2h0LCBnbEZvcm1hdCwgZ2xUeXBlLCBpbWFnZSApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGdsLnBpeGVsU3RvcmVpKCBnbC5VTlBBQ0tfUk9XX0xFTkdUSCwgY3VycmVudFVucGFja1Jvd0xlbiApO1xyXG5cdFx0Z2wucGl4ZWxTdG9yZWkoIGdsLlVOUEFDS19JTUFHRV9IRUlHSFQsIGN1cnJlbnRVbnBhY2tJbWFnZUhlaWdodCApO1xyXG5cdFx0Z2wucGl4ZWxTdG9yZWkoIGdsLlVOUEFDS19TS0lQX1BJWEVMUywgY3VycmVudFVucGFja1NraXBQaXhlbHMgKTtcclxuXHRcdGdsLnBpeGVsU3RvcmVpKCBnbC5VTlBBQ0tfU0tJUF9ST1dTLCBjdXJyZW50VW5wYWNrU2tpcFJvd3MgKTtcclxuXHRcdGdsLnBpeGVsU3RvcmVpKCBnbC5VTlBBQ0tfU0tJUF9JTUFHRVMsIGN1cnJlbnRVbnBhY2tTa2lwSW1hZ2VzICk7XHJcblxyXG5cdFx0Ly8gR2VuZXJhdGUgbWlwbWFwcyBvbmx5IHdoZW4gY29weWluZyBsZXZlbCAwXHJcblx0XHRpZiAoIGxldmVsID09PSAwICYmIGRzdFRleHR1cmUuZ2VuZXJhdGVNaXBtYXBzICkgZ2wuZ2VuZXJhdGVNaXBtYXAoIGdsLlRFWFRVUkVfMkQgKTtcclxuXHJcblx0XHRzdGF0ZS51bmJpbmRUZXh0dXJlKCk7XHJcblxyXG5cdH1cclxuXHJcblx0Y29weUZyYW1lYnVmZmVyVG9UZXh0dXJlKCB0ZXh0dXJlLCByZW5kZXJDb250ZXh0LCByZWN0YW5nbGUgKSB7XHJcblxyXG5cdFx0Y29uc3QgeyBnbCB9ID0gdGhpcztcclxuXHRcdGNvbnN0IHsgc3RhdGUgfSA9IHRoaXMuYmFja2VuZDtcclxuXHJcblx0XHRjb25zdCB7IHRleHR1cmVHUFUgfSA9IHRoaXMuYmFja2VuZC5nZXQoIHRleHR1cmUgKTtcclxuXHJcblx0XHRjb25zdCB7IHgsIHksIHo6IHdpZHRoLCB3OiBoZWlnaHQgfSA9IHJlY3RhbmdsZTtcclxuXHJcblx0XHRjb25zdCByZXF1aXJlRHJhd0ZyYW1lQnVmZmVyID0gdGV4dHVyZS5pc0RlcHRoVGV4dHVyZSA9PT0gdHJ1ZSB8fCAoIHJlbmRlckNvbnRleHQucmVuZGVyVGFyZ2V0ICYmIHJlbmRlckNvbnRleHQucmVuZGVyVGFyZ2V0LnNhbXBsZXMgPiAwICk7XHJcblxyXG5cdFx0Y29uc3Qgc3JjSGVpZ2h0ID0gcmVuZGVyQ29udGV4dC5yZW5kZXJUYXJnZXQgPyByZW5kZXJDb250ZXh0LnJlbmRlclRhcmdldC5oZWlnaHQgOiB0aGlzLmJhY2tlbmQuZ2VyRHJhd2luZ0J1ZmZlclNpemUoKS55O1xyXG5cclxuXHRcdGlmICggcmVxdWlyZURyYXdGcmFtZUJ1ZmZlciApIHtcclxuXHJcblx0XHRcdGNvbnN0IHBhcnRpYWwgPSAoIHggIT09IDAgfHwgeSAhPT0gMCApO1xyXG5cdFx0XHRsZXQgbWFzaztcclxuXHRcdFx0bGV0IGF0dGFjaG1lbnQ7XHJcblxyXG5cdFx0XHRpZiAoIHRleHR1cmUuaXNEZXB0aFRleHR1cmUgPT09IHRydWUgKSB7XHJcblxyXG5cdFx0XHRcdG1hc2sgPSBnbC5ERVBUSF9CVUZGRVJfQklUO1xyXG5cdFx0XHRcdGF0dGFjaG1lbnQgPSBnbC5ERVBUSF9BVFRBQ0hNRU5UO1xyXG5cclxuXHRcdFx0XHRpZiAoIHJlbmRlckNvbnRleHQuc3RlbmNpbCApIHtcclxuXHJcblx0XHRcdFx0XHRtYXNrIHw9IGdsLlNURU5DSUxfQlVGRkVSX0JJVDtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0bWFzayA9IGdsLkNPTE9SX0JVRkZFUl9CSVQ7XHJcblx0XHRcdFx0YXR0YWNobWVudCA9IGdsLkNPTE9SX0FUVEFDSE1FTlQwO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKCBwYXJ0aWFsICkge1xyXG5cclxuXHRcdFx0XHRjb25zdCByZW5kZXJUYXJnZXRDb250ZXh0RGF0YSA9IHRoaXMuYmFja2VuZC5nZXQoIHJlbmRlckNvbnRleHQucmVuZGVyVGFyZ2V0ICk7XHJcblxyXG5cdFx0XHRcdGNvbnN0IGZiID0gcmVuZGVyVGFyZ2V0Q29udGV4dERhdGEuZnJhbWVidWZmZXJzWyByZW5kZXJDb250ZXh0LmdldENhY2hlS2V5KCkgXTtcclxuXHRcdFx0XHRjb25zdCBtc2FhRnJhbWVCdWZmZXIgPSByZW5kZXJUYXJnZXRDb250ZXh0RGF0YS5tc2FhRnJhbWVCdWZmZXI7XHJcblxyXG5cdFx0XHRcdHN0YXRlLmJpbmRGcmFtZWJ1ZmZlciggZ2wuRFJBV19GUkFNRUJVRkZFUiwgZmIgKTtcclxuXHRcdFx0XHRzdGF0ZS5iaW5kRnJhbWVidWZmZXIoIGdsLlJFQURfRlJBTUVCVUZGRVIsIG1zYWFGcmFtZUJ1ZmZlciApO1xyXG5cclxuXHRcdFx0XHRjb25zdCBmbGlwcGVkWSA9IHNyY0hlaWdodCAtIHkgLSBoZWlnaHQ7XHJcblxyXG5cdFx0XHRcdGdsLmJsaXRGcmFtZWJ1ZmZlciggeCwgZmxpcHBlZFksIHggKyB3aWR0aCwgZmxpcHBlZFkgKyBoZWlnaHQsIHgsIGZsaXBwZWRZLCB4ICsgd2lkdGgsIGZsaXBwZWRZICsgaGVpZ2h0LCBtYXNrLCBnbC5ORUFSRVNUICk7XHJcblxyXG5cdFx0XHRcdHN0YXRlLmJpbmRGcmFtZWJ1ZmZlciggZ2wuUkVBRF9GUkFNRUJVRkZFUiwgZmIgKTtcclxuXHJcblx0XHRcdFx0c3RhdGUuYmluZFRleHR1cmUoIGdsLlRFWFRVUkVfMkQsIHRleHR1cmVHUFUgKTtcclxuXHJcblx0XHRcdFx0Z2wuY29weVRleFN1YkltYWdlMkQoIGdsLlRFWFRVUkVfMkQsIDAsIDAsIDAsIHgsIGZsaXBwZWRZLCB3aWR0aCwgaGVpZ2h0ICk7XHJcblxyXG5cdFx0XHRcdHN0YXRlLnVuYmluZFRleHR1cmUoKTtcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdGNvbnN0IGZiID0gZ2wuY3JlYXRlRnJhbWVidWZmZXIoKTtcclxuXHJcblx0XHRcdFx0c3RhdGUuYmluZEZyYW1lYnVmZmVyKCBnbC5EUkFXX0ZSQU1FQlVGRkVSLCBmYiApO1xyXG5cclxuXHRcdFx0XHRnbC5mcmFtZWJ1ZmZlclRleHR1cmUyRCggZ2wuRFJBV19GUkFNRUJVRkZFUiwgYXR0YWNobWVudCwgZ2wuVEVYVFVSRV8yRCwgdGV4dHVyZUdQVSwgMCApO1xyXG5cdFx0XHRcdGdsLmJsaXRGcmFtZWJ1ZmZlciggMCwgMCwgd2lkdGgsIGhlaWdodCwgMCwgMCwgd2lkdGgsIGhlaWdodCwgbWFzaywgZ2wuTkVBUkVTVCApO1xyXG5cclxuXHRcdFx0XHRnbC5kZWxldGVGcmFtZWJ1ZmZlciggZmIgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0c3RhdGUuYmluZFRleHR1cmUoIGdsLlRFWFRVUkVfMkQsIHRleHR1cmVHUFUgKTtcclxuXHRcdFx0Z2wuY29weVRleFN1YkltYWdlMkQoIGdsLlRFWFRVUkVfMkQsIDAsIDAsIDAsIHgsIHNyY0hlaWdodCAtIGhlaWdodCAtIHksIHdpZHRoLCBoZWlnaHQgKTtcclxuXHJcblx0XHRcdHN0YXRlLnVuYmluZFRleHR1cmUoKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCB0ZXh0dXJlLmdlbmVyYXRlTWlwbWFwcyApIHRoaXMuZ2VuZXJhdGVNaXBtYXBzKCB0ZXh0dXJlICk7XHJcblxyXG5cdFx0dGhpcy5iYWNrZW5kLl9zZXRGcmFtZWJ1ZmZlciggcmVuZGVyQ29udGV4dCApO1xyXG5cclxuXHR9XHJcblxyXG5cdC8vIFNldHVwIHN0b3JhZ2UgZm9yIGludGVybmFsIGRlcHRoL3N0ZW5jaWwgYnVmZmVycyBhbmQgYmluZCB0byBjb3JyZWN0IGZyYW1lYnVmZmVyXHJcblx0c2V0dXBSZW5kZXJCdWZmZXJTdG9yYWdlKCByZW5kZXJidWZmZXIsIHJlbmRlckNvbnRleHQgKSB7XHJcblxyXG5cdFx0Y29uc3QgeyBnbCB9ID0gdGhpcztcclxuXHRcdGNvbnN0IHJlbmRlclRhcmdldCA9IHJlbmRlckNvbnRleHQucmVuZGVyVGFyZ2V0O1xyXG5cclxuXHRcdGNvbnN0IHsgc2FtcGxlcywgZGVwdGhUZXh0dXJlLCBkZXB0aEJ1ZmZlciwgc3RlbmNpbEJ1ZmZlciwgd2lkdGgsIGhlaWdodCB9ID0gcmVuZGVyVGFyZ2V0O1xyXG5cclxuXHRcdGdsLmJpbmRSZW5kZXJidWZmZXIoIGdsLlJFTkRFUkJVRkZFUiwgcmVuZGVyYnVmZmVyICk7XHJcblxyXG5cdFx0aWYgKCBkZXB0aEJ1ZmZlciAmJiAhIHN0ZW5jaWxCdWZmZXIgKSB7XHJcblxyXG5cdFx0XHRsZXQgZ2xJbnRlcm5hbEZvcm1hdCA9IGdsLkRFUFRIX0NPTVBPTkVOVDI0O1xyXG5cclxuXHRcdFx0aWYgKCBzYW1wbGVzID4gMCApIHtcclxuXHJcblx0XHRcdFx0aWYgKCBkZXB0aFRleHR1cmUgJiYgZGVwdGhUZXh0dXJlLmlzRGVwdGhUZXh0dXJlICkge1xyXG5cclxuXHRcdFx0XHRcdGlmICggZGVwdGhUZXh0dXJlLnR5cGUgPT09IGdsLkZMT0FUICkge1xyXG5cclxuXHRcdFx0XHRcdFx0Z2xJbnRlcm5hbEZvcm1hdCA9IGdsLkRFUFRIX0NPTVBPTkVOVDMyRjtcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0Z2wucmVuZGVyYnVmZmVyU3RvcmFnZU11bHRpc2FtcGxlKCBnbC5SRU5ERVJCVUZGRVIsIHNhbXBsZXMsIGdsSW50ZXJuYWxGb3JtYXQsIHdpZHRoLCBoZWlnaHQgKTtcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdGdsLnJlbmRlcmJ1ZmZlclN0b3JhZ2UoIGdsLlJFTkRFUkJVRkZFUiwgZ2xJbnRlcm5hbEZvcm1hdCwgd2lkdGgsIGhlaWdodCApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Z2wuZnJhbWVidWZmZXJSZW5kZXJidWZmZXIoIGdsLkZSQU1FQlVGRkVSLCBnbC5ERVBUSF9BVFRBQ0hNRU5ULCBnbC5SRU5ERVJCVUZGRVIsIHJlbmRlcmJ1ZmZlciApO1xyXG5cclxuXHRcdH0gZWxzZSBpZiAoIGRlcHRoQnVmZmVyICYmIHN0ZW5jaWxCdWZmZXIgKSB7XHJcblxyXG5cdFx0XHRpZiAoIHNhbXBsZXMgPiAwICkge1xyXG5cclxuXHRcdFx0XHRnbC5yZW5kZXJidWZmZXJTdG9yYWdlTXVsdGlzYW1wbGUoIGdsLlJFTkRFUkJVRkZFUiwgc2FtcGxlcywgZ2wuREVQVEgyNF9TVEVOQ0lMOCwgd2lkdGgsIGhlaWdodCApO1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0Z2wucmVuZGVyYnVmZmVyU3RvcmFnZSggZ2wuUkVOREVSQlVGRkVSLCBnbC5ERVBUSF9TVEVOQ0lMLCB3aWR0aCwgaGVpZ2h0ICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cclxuXHRcdFx0Z2wuZnJhbWVidWZmZXJSZW5kZXJidWZmZXIoIGdsLkZSQU1FQlVGRkVSLCBnbC5ERVBUSF9TVEVOQ0lMX0FUVEFDSE1FTlQsIGdsLlJFTkRFUkJVRkZFUiwgcmVuZGVyYnVmZmVyICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdGFzeW5jIGNvcHlUZXh0dXJlVG9CdWZmZXIoIHRleHR1cmUsIHgsIHksIHdpZHRoLCBoZWlnaHQsIGZhY2VJbmRleCApIHtcclxuXHJcblx0XHRjb25zdCB7IGJhY2tlbmQsIGdsIH0gPSB0aGlzO1xyXG5cclxuXHRcdGNvbnN0IHsgdGV4dHVyZUdQVSwgZ2xGb3JtYXQsIGdsVHlwZSB9ID0gdGhpcy5iYWNrZW5kLmdldCggdGV4dHVyZSApO1xyXG5cclxuXHRcdGNvbnN0IGZiID0gZ2wuY3JlYXRlRnJhbWVidWZmZXIoKTtcclxuXHJcblx0XHRnbC5iaW5kRnJhbWVidWZmZXIoIGdsLlJFQURfRlJBTUVCVUZGRVIsIGZiICk7XHJcblxyXG5cdFx0Y29uc3QgdGFyZ2V0ID0gdGV4dHVyZS5pc0N1YmVUZXh0dXJlID8gZ2wuVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9YICsgZmFjZUluZGV4IDogZ2wuVEVYVFVSRV8yRDtcclxuXHJcblx0XHRnbC5mcmFtZWJ1ZmZlclRleHR1cmUyRCggZ2wuUkVBRF9GUkFNRUJVRkZFUiwgZ2wuQ09MT1JfQVRUQUNITUVOVDAsIHRhcmdldCwgdGV4dHVyZUdQVSwgMCApO1xyXG5cclxuXHRcdGNvbnN0IHR5cGVkQXJyYXlUeXBlID0gdGhpcy5fZ2V0VHlwZWRBcnJheVR5cGUoIGdsVHlwZSApO1xyXG5cdFx0Y29uc3QgYnl0ZXNQZXJUZXhlbCA9IHRoaXMuX2dldEJ5dGVzUGVyVGV4ZWwoIGdsVHlwZSwgZ2xGb3JtYXQgKTtcclxuXHJcblx0XHRjb25zdCBlbGVtZW50Q291bnQgPSB3aWR0aCAqIGhlaWdodDtcclxuXHRcdGNvbnN0IGJ5dGVMZW5ndGggPSBlbGVtZW50Q291bnQgKiBieXRlc1BlclRleGVsO1xyXG5cclxuXHRcdGNvbnN0IGJ1ZmZlciA9IGdsLmNyZWF0ZUJ1ZmZlcigpO1xyXG5cclxuXHRcdGdsLmJpbmRCdWZmZXIoIGdsLlBJWEVMX1BBQ0tfQlVGRkVSLCBidWZmZXIgKTtcclxuXHRcdGdsLmJ1ZmZlckRhdGEoIGdsLlBJWEVMX1BBQ0tfQlVGRkVSLCBieXRlTGVuZ3RoLCBnbC5TVFJFQU1fUkVBRCApO1xyXG5cdFx0Z2wucmVhZFBpeGVscyggeCwgeSwgd2lkdGgsIGhlaWdodCwgZ2xGb3JtYXQsIGdsVHlwZSwgMCApO1xyXG5cdFx0Z2wuYmluZEJ1ZmZlciggZ2wuUElYRUxfUEFDS19CVUZGRVIsIG51bGwgKTtcclxuXHJcblx0XHRhd2FpdCBiYWNrZW5kLnV0aWxzLl9jbGllbnRXYWl0QXN5bmMoKTtcclxuXHJcblx0XHRjb25zdCBkc3RCdWZmZXIgPSBuZXcgdHlwZWRBcnJheVR5cGUoIGJ5dGVMZW5ndGggLyB0eXBlZEFycmF5VHlwZS5CWVRFU19QRVJfRUxFTUVOVCApO1xyXG5cclxuXHRcdGdsLmJpbmRCdWZmZXIoIGdsLlBJWEVMX1BBQ0tfQlVGRkVSLCBidWZmZXIgKTtcclxuXHRcdGdsLmdldEJ1ZmZlclN1YkRhdGEoIGdsLlBJWEVMX1BBQ0tfQlVGRkVSLCAwLCBkc3RCdWZmZXIgKTtcclxuXHRcdGdsLmJpbmRCdWZmZXIoIGdsLlBJWEVMX1BBQ0tfQlVGRkVSLCBudWxsICk7XHJcblxyXG5cdFx0Z2wuZGVsZXRlRnJhbWVidWZmZXIoIGZiICk7XHJcblxyXG5cdFx0cmV0dXJuIGRzdEJ1ZmZlcjtcclxuXHJcblx0fVxyXG5cclxuXHRfZ2V0VHlwZWRBcnJheVR5cGUoIGdsVHlwZSApIHtcclxuXHJcblx0XHRjb25zdCB7IGdsIH0gPSB0aGlzO1xyXG5cclxuXHRcdGlmICggZ2xUeXBlID09PSBnbC5VTlNJR05FRF9CWVRFICkgcmV0dXJuIFVpbnQ4QXJyYXk7XHJcblxyXG5cdFx0aWYgKCBnbFR5cGUgPT09IGdsLlVOU0lHTkVEX1NIT1JUXzRfNF80XzQgKSByZXR1cm4gVWludDE2QXJyYXk7XHJcblx0XHRpZiAoIGdsVHlwZSA9PT0gZ2wuVU5TSUdORURfU0hPUlRfNV81XzVfMSApIHJldHVybiBVaW50MTZBcnJheTtcclxuXHRcdGlmICggZ2xUeXBlID09PSBnbC5VTlNJR05FRF9TSE9SVF81XzZfNSApIHJldHVybiBVaW50MTZBcnJheTtcclxuXHRcdGlmICggZ2xUeXBlID09PSBnbC5VTlNJR05FRF9TSE9SVCApIHJldHVybiBVaW50MTZBcnJheTtcclxuXHRcdGlmICggZ2xUeXBlID09PSBnbC5VTlNJR05FRF9JTlQgKSByZXR1cm4gVWludDMyQXJyYXk7XHJcblxyXG5cdFx0aWYgKCBnbFR5cGUgPT09IGdsLkhBTEZfRkxPQVQgKSByZXR1cm4gVWludDE2QXJyYXk7XHJcblx0XHRpZiAoIGdsVHlwZSA9PT0gZ2wuRkxPQVQgKSByZXR1cm4gRmxvYXQzMkFycmF5O1xyXG5cclxuXHRcdHRocm93IG5ldyBFcnJvciggYFVuc3VwcG9ydGVkIFdlYkdMIHR5cGU6ICR7Z2xUeXBlfWAgKTtcclxuXHJcblx0fVxyXG5cclxuXHRfZ2V0Qnl0ZXNQZXJUZXhlbCggZ2xUeXBlLCBnbEZvcm1hdCApIHtcclxuXHJcblx0XHRjb25zdCB7IGdsIH0gPSB0aGlzO1xyXG5cclxuXHRcdGxldCBieXRlc1BlckNvbXBvbmVudCA9IDA7XHJcblxyXG5cdFx0aWYgKCBnbFR5cGUgPT09IGdsLlVOU0lHTkVEX0JZVEUgKSBieXRlc1BlckNvbXBvbmVudCA9IDE7XHJcblxyXG5cdFx0aWYgKCBnbFR5cGUgPT09IGdsLlVOU0lHTkVEX1NIT1JUXzRfNF80XzQgfHxcclxuXHRcdFx0Z2xUeXBlID09PSBnbC5VTlNJR05FRF9TSE9SVF81XzVfNV8xIHx8XHJcblx0XHRcdGdsVHlwZSA9PT0gZ2wuVU5TSUdORURfU0hPUlRfNV82XzUgfHxcclxuXHRcdFx0Z2xUeXBlID09PSBnbC5VTlNJR05FRF9TSE9SVCB8fFxyXG5cdFx0XHRnbFR5cGUgPT09IGdsLkhBTEZfRkxPQVQgKSBieXRlc1BlckNvbXBvbmVudCA9IDI7XHJcblxyXG5cdFx0aWYgKCBnbFR5cGUgPT09IGdsLlVOU0lHTkVEX0lOVCB8fFxyXG5cdFx0XHRnbFR5cGUgPT09IGdsLkZMT0FUICkgYnl0ZXNQZXJDb21wb25lbnQgPSA0O1xyXG5cclxuXHRcdGlmICggZ2xGb3JtYXQgPT09IGdsLlJHQkEgKSByZXR1cm4gYnl0ZXNQZXJDb21wb25lbnQgKiA0O1xyXG5cdFx0aWYgKCBnbEZvcm1hdCA9PT0gZ2wuUkdCICkgcmV0dXJuIGJ5dGVzUGVyQ29tcG9uZW50ICogMztcclxuXHRcdGlmICggZ2xGb3JtYXQgPT09IGdsLkFMUEhBICkgcmV0dXJuIGJ5dGVzUGVyQ29tcG9uZW50O1xyXG5cclxuXHR9XHJcblxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBXZWJHTFRleHR1cmVVdGlscztcclxuIiwiY2xhc3MgV2ViR0xFeHRlbnNpb25zIHtcclxuXHJcblx0Y29uc3RydWN0b3IoIGJhY2tlbmQgKSB7XHJcblxyXG5cdFx0dGhpcy5iYWNrZW5kID0gYmFja2VuZDtcclxuXHJcblx0XHR0aGlzLmdsID0gdGhpcy5iYWNrZW5kLmdsO1xyXG5cdFx0dGhpcy5hdmFpbGFibGVFeHRlbnNpb25zID0gdGhpcy5nbC5nZXRTdXBwb3J0ZWRFeHRlbnNpb25zKCk7XHJcblxyXG5cdFx0dGhpcy5leHRlbnNpb25zID0ge307XHJcblxyXG5cdH1cclxuXHJcblx0Z2V0KCBuYW1lICkge1xyXG5cclxuXHRcdGxldCBleHRlbnNpb24gPSB0aGlzLmV4dGVuc2lvbnNbIG5hbWUgXTtcclxuXHJcblx0XHRpZiAoIGV4dGVuc2lvbiA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0ZXh0ZW5zaW9uID0gdGhpcy5nbC5nZXRFeHRlbnNpb24oIG5hbWUgKTtcclxuXHJcblx0XHRcdHRoaXMuZXh0ZW5zaW9uc1sgbmFtZSBdID0gZXh0ZW5zaW9uO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gZXh0ZW5zaW9uO1xyXG5cclxuXHR9XHJcblxyXG5cdGhhcyggbmFtZSApIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5hdmFpbGFibGVFeHRlbnNpb25zLmluY2x1ZGVzKCBuYW1lICk7XHJcblxyXG5cdH1cclxuXHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IFdlYkdMRXh0ZW5zaW9ucztcclxuIiwiY2xhc3MgV2ViR0xDYXBhYmlsaXRpZXMge1xyXG5cclxuXHRjb25zdHJ1Y3RvciggYmFja2VuZCApIHtcclxuXHJcblx0XHR0aGlzLmJhY2tlbmQgPSBiYWNrZW5kO1xyXG5cclxuXHRcdHRoaXMubWF4QW5pc290cm9weSA9IG51bGw7XHJcblxyXG5cdH1cclxuXHJcblx0Z2V0TWF4QW5pc290cm9weSgpIHtcclxuXHJcblx0XHRpZiAoIHRoaXMubWF4QW5pc290cm9weSAhPT0gbnVsbCApIHJldHVybiB0aGlzLm1heEFuaXNvdHJvcHk7XHJcblxyXG5cdFx0Y29uc3QgZ2wgPSB0aGlzLmJhY2tlbmQuZ2w7XHJcblx0XHRjb25zdCBleHRlbnNpb25zID0gdGhpcy5iYWNrZW5kLmV4dGVuc2lvbnM7XHJcblxyXG5cdFx0aWYgKCBleHRlbnNpb25zLmhhcyggJ0VYVF90ZXh0dXJlX2ZpbHRlcl9hbmlzb3Ryb3BpYycgKSA9PT0gdHJ1ZSApIHtcclxuXHJcblx0XHRcdGNvbnN0IGV4dGVuc2lvbiA9IGV4dGVuc2lvbnMuZ2V0KCAnRVhUX3RleHR1cmVfZmlsdGVyX2FuaXNvdHJvcGljJyApO1xyXG5cclxuXHRcdFx0dGhpcy5tYXhBbmlzb3Ryb3B5ID0gZ2wuZ2V0UGFyYW1ldGVyKCBleHRlbnNpb24uTUFYX1RFWFRVUkVfTUFYX0FOSVNPVFJPUFlfRVhUICk7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdHRoaXMubWF4QW5pc290cm9weSA9IDA7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzLm1heEFuaXNvdHJvcHk7XHJcblxyXG5cdH1cclxuXHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IFdlYkdMQ2FwYWJpbGl0aWVzO1xyXG4iLCJleHBvcnQgY29uc3QgR0xGZWF0dXJlTmFtZSA9IHtcclxuXHJcblx0J1dFQkdMX211bHRpX2RyYXcnOiAnV0VCR0xfbXVsdGlfZHJhdycsXHJcblx0J1dFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9hc3RjJzogJ3RleHR1cmUtY29tcHJlc3Npb24tYXN0YycsXHJcblx0J1dFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9ldGMnOiAndGV4dHVyZS1jb21wcmVzc2lvbi1ldGMyJyxcclxuXHQnV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX2V0YzEnOiAndGV4dHVyZS1jb21wcmVzc2lvbi1ldGMxJyxcclxuXHQnV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX3B2cnRjJzogJ3RleHR1cmUtY29tcHJlc3Npb24tcHZydGMnLFxyXG5cdCdXRUJLSVRfV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX3B2cnRjJzogJ3RleHR1cmUtY29tcHJlc3Npb24tcHZydGMnLFxyXG5cdCdXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfczN0Yyc6ICd0ZXh0dXJlLWNvbXByZXNzaW9uLWJjJyxcclxuXHQnRVhUX3RleHR1cmVfY29tcHJlc3Npb25fYnB0Yyc6ICd0ZXh0dXJlLWNvbXByZXNzaW9uLWJwdGMnLFxyXG5cdCdFWFRfZGlzam9pbnRfdGltZXJfcXVlcnlfd2ViZ2wyJzogJ3RpbWVzdGFtcC1xdWVyeScsXHJcblxyXG59O1xyXG4iLCJjbGFzcyBXZWJHTEJ1ZmZlclJlbmRlcmVyIHtcclxuXHJcblx0Y29uc3RydWN0b3IoIGJhY2tlbmQgKSB7XHJcblxyXG5cdFx0dGhpcy5nbCA9IGJhY2tlbmQuZ2w7XHJcblx0XHR0aGlzLmV4dGVuc2lvbnMgPSBiYWNrZW5kLmV4dGVuc2lvbnM7XHJcblx0XHR0aGlzLmluZm8gPSBiYWNrZW5kLnJlbmRlcmVyLmluZm87XHJcblx0XHR0aGlzLm1vZGUgPSBudWxsO1xyXG5cdFx0dGhpcy5pbmRleCA9IDA7XHJcblx0XHR0aGlzLnR5cGUgPSBudWxsO1xyXG5cdFx0dGhpcy5vYmplY3QgPSBudWxsO1xyXG5cclxuXHR9XHJcblxyXG5cdHJlbmRlciggc3RhcnQsIGNvdW50ICkge1xyXG5cclxuXHRcdGNvbnN0IHsgZ2wsIG1vZGUsIG9iamVjdCwgdHlwZSwgaW5mbywgaW5kZXggfSA9IHRoaXM7XHJcblxyXG5cdFx0aWYgKCBpbmRleCAhPT0gMCApIHtcclxuXHJcblx0XHRcdGdsLmRyYXdFbGVtZW50cyggbW9kZSwgY291bnQsIHR5cGUsIHN0YXJ0ICk7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdGdsLmRyYXdBcnJheXMoIG1vZGUsIHN0YXJ0LCBjb3VudCApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpbmZvLnVwZGF0ZSggb2JqZWN0LCBjb3VudCwgbW9kZSwgMSApO1xyXG5cclxuXHR9XHJcblxyXG5cdHJlbmRlckluc3RhbmNlcyggc3RhcnQsIGNvdW50LCBwcmltY291bnQgKSB7XHJcblxyXG5cdFx0Y29uc3QgeyBnbCwgbW9kZSwgdHlwZSwgaW5kZXgsIG9iamVjdCwgaW5mbyB9ID0gdGhpcztcclxuXHJcblx0XHRpZiAoIHByaW1jb3VudCA9PT0gMCApIHJldHVybjtcclxuXHJcblx0XHRpZiAoIGluZGV4ICE9PSAwICkge1xyXG5cclxuXHRcdFx0Z2wuZHJhd0VsZW1lbnRzSW5zdGFuY2VkKCBtb2RlLCBjb3VudCwgdHlwZSwgc3RhcnQsIHByaW1jb3VudCApO1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRnbC5kcmF3QXJyYXlzSW5zdGFuY2VkKCBtb2RlLCBzdGFydCwgY291bnQsIHByaW1jb3VudCApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpbmZvLnVwZGF0ZSggb2JqZWN0LCBjb3VudCwgbW9kZSwgcHJpbWNvdW50ICk7XHJcblxyXG5cdH1cclxuXHJcblx0cmVuZGVyTXVsdGlEcmF3KCBzdGFydHMsIGNvdW50cywgZHJhd0NvdW50ICkge1xyXG5cclxuXHRcdGNvbnN0IHsgZXh0ZW5zaW9ucywgbW9kZSwgb2JqZWN0LCBpbmZvIH0gPSB0aGlzO1xyXG5cclxuXHRcdGlmICggZHJhd0NvdW50ID09PSAwICkgcmV0dXJuO1xyXG5cclxuXHRcdGNvbnN0IGV4dGVuc2lvbiA9IGV4dGVuc2lvbnMuZ2V0KCAnV0VCR0xfbXVsdGlfZHJhdycgKTtcclxuXHJcblx0XHRpZiAoIGV4dGVuc2lvbiA9PT0gbnVsbCApIHtcclxuXHJcblx0XHRcdGZvciAoIGxldCBpID0gMDsgaSA8IGRyYXdDb3VudDsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0dGhpcy5yZW5kZXIoIHN0YXJ0c1sgaSBdLCBjb3VudHNbIGkgXSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRpZiAoIHRoaXMuaW5kZXggIT09IDAgKSB7XHJcblxyXG5cdFx0XHRcdGV4dGVuc2lvbi5tdWx0aURyYXdFbGVtZW50c1dFQkdMKCBtb2RlLCBjb3VudHMsIDAsIHRoaXMudHlwZSwgc3RhcnRzLCAwLCBkcmF3Q291bnQgKTtcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdGV4dGVuc2lvbi5tdWx0aURyYXdBcnJheXNXRUJHTCggbW9kZSwgc3RhcnRzLCAwLCBjb3VudHMsIDAsIGRyYXdDb3VudCApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0bGV0IGVsZW1lbnRDb3VudCA9IDA7XHJcblx0XHRcdGZvciAoIGxldCBpID0gMDsgaSA8IGRyYXdDb3VudDsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0ZWxlbWVudENvdW50ICs9IGNvdW50c1sgaSBdO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aW5mby51cGRhdGUoIG9iamVjdCwgZWxlbWVudENvdW50LCBtb2RlLCAxICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdHJlbmRlck11bHRpRHJhd0luc3RhbmNlcyggc3RhcnRzLCBjb3VudHMsIGRyYXdDb3VudCwgcHJpbWNvdW50ICkge1xyXG5cclxuXHRcdGNvbnN0IHsgZXh0ZW5zaW9ucywgbW9kZSwgb2JqZWN0LCBpbmZvIH0gPSB0aGlzO1xyXG5cclxuXHRcdGlmICggZHJhd0NvdW50ID09PSAwICkgcmV0dXJuO1xyXG5cclxuXHRcdGNvbnN0IGV4dGVuc2lvbiA9IGV4dGVuc2lvbnMuZ2V0KCAnV0VCR0xfbXVsdGlfZHJhdycgKTtcclxuXHJcblx0XHRpZiAoIGV4dGVuc2lvbiA9PT0gbnVsbCApIHtcclxuXHJcblx0XHRcdGZvciAoIGxldCBpID0gMDsgaSA8IGRyYXdDb3VudDsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0dGhpcy5yZW5kZXJJbnN0YW5jZXMoIHN0YXJ0c1sgaSBdLCBjb3VudHNbIGkgXSwgcHJpbWNvdW50WyBpIF0gKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0aWYgKCB0aGlzLmluZGV4ICE9PSAwICkge1xyXG5cclxuXHRcdFx0XHRleHRlbnNpb24ubXVsdGlEcmF3RWxlbWVudHNJbnN0YW5jZWRXRUJHTCggbW9kZSwgY291bnRzLCAwLCB0aGlzLnR5cGUsIHN0YXJ0cywgMCwgcHJpbWNvdW50LCAwLCBkcmF3Q291bnQgKTtcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdGV4dGVuc2lvbi5tdWx0aURyYXdBcnJheXNJbnN0YW5jZWRXRUJHTCggbW9kZSwgc3RhcnRzLCAwLCBjb3VudHMsIDAsIHByaW1jb3VudCwgMCwgZHJhd0NvdW50ICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRsZXQgZWxlbWVudENvdW50ID0gMDtcclxuXHRcdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgZHJhd0NvdW50OyBpICsrICkge1xyXG5cclxuXHRcdFx0XHRlbGVtZW50Q291bnQgKz0gY291bnRzWyBpIF0gKiBwcmltY291bnRbIGkgXTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGluZm8udXBkYXRlKCBvYmplY3QsIGVsZW1lbnRDb3VudCwgbW9kZSwgMSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHQvL1xyXG5cclxufVxyXG5cclxuXHJcbmV4cG9ydCB7IFdlYkdMQnVmZmVyUmVuZGVyZXIgfTtcclxuIiwiaW1wb3J0IEdMU0xOb2RlQnVpbGRlciBmcm9tICcuL25vZGVzL0dMU0xOb2RlQnVpbGRlci5qcyc7XHJcbmltcG9ydCBCYWNrZW5kIGZyb20gJy4uL2NvbW1vbi9CYWNrZW5kLmpzJztcclxuaW1wb3J0IHsgZ2V0Q2FjaGVLZXkgfSBmcm9tICcuLi9jb21tb24vUmVuZGVyQ29udGV4dC5qcyc7XHJcblxyXG5pbXBvcnQgV2ViR0xBdHRyaWJ1dGVVdGlscyBmcm9tICcuL3V0aWxzL1dlYkdMQXR0cmlidXRlVXRpbHMuanMnO1xyXG5pbXBvcnQgV2ViR0xTdGF0ZSBmcm9tICcuL3V0aWxzL1dlYkdMU3RhdGUuanMnO1xyXG5pbXBvcnQgV2ViR0xVdGlscyBmcm9tICcuL3V0aWxzL1dlYkdMVXRpbHMuanMnO1xyXG5pbXBvcnQgV2ViR0xUZXh0dXJlVXRpbHMgZnJvbSAnLi91dGlscy9XZWJHTFRleHR1cmVVdGlscy5qcyc7XHJcbmltcG9ydCBXZWJHTEV4dGVuc2lvbnMgZnJvbSAnLi91dGlscy9XZWJHTEV4dGVuc2lvbnMuanMnO1xyXG5pbXBvcnQgV2ViR0xDYXBhYmlsaXRpZXMgZnJvbSAnLi91dGlscy9XZWJHTENhcGFiaWxpdGllcy5qcyc7XHJcbmltcG9ydCB7IEdMRmVhdHVyZU5hbWUgfSBmcm9tICcuL3V0aWxzL1dlYkdMQ29uc3RhbnRzLmpzJztcclxuaW1wb3J0IHsgV2ViR0xCdWZmZXJSZW5kZXJlciB9IGZyb20gJy4vV2ViR0xCdWZmZXJSZW5kZXJlci5qcyc7XHJcblxyXG5pbXBvcnQgeyB3YXJuT25jZSB9IGZyb20gJy4uLy4uL3V0aWxzLmpzJztcclxuaW1wb3J0IHsgV2ViR0xDb29yZGluYXRlU3lzdGVtIH0gZnJvbSAnLi4vLi4vY29uc3RhbnRzLmpzJztcclxuXHJcbi8vXHJcblxyXG5jbGFzcyBXZWJHTEJhY2tlbmQgZXh0ZW5kcyBCYWNrZW5kIHtcclxuXHJcblx0Y29uc3RydWN0b3IoIHBhcmFtZXRlcnMgPSB7fSApIHtcclxuXHJcblx0XHRzdXBlciggcGFyYW1ldGVycyApO1xyXG5cclxuXHRcdHRoaXMuaXNXZWJHTEJhY2tlbmQgPSB0cnVlO1xyXG5cclxuXHR9XHJcblxyXG5cdGluaXQoIHJlbmRlcmVyICkge1xyXG5cclxuXHRcdHN1cGVyLmluaXQoIHJlbmRlcmVyICk7XHJcblxyXG5cdFx0Ly9cclxuXHJcblx0XHRjb25zdCBwYXJhbWV0ZXJzID0gdGhpcy5wYXJhbWV0ZXJzO1xyXG5cclxuXHRcdGNvbnN0IGdsQ29udGV4dCA9ICggcGFyYW1ldGVycy5jb250ZXh0ICE9PSB1bmRlZmluZWQgKSA/IHBhcmFtZXRlcnMuY29udGV4dCA6IHJlbmRlcmVyLmRvbUVsZW1lbnQuZ2V0Q29udGV4dCggJ3dlYmdsMicgKTtcclxuXHJcblx0IFx0ZnVuY3Rpb24gb25Db250ZXh0TG9zdCggZXZlbnQgKSB7XHJcblxyXG5cdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG5cclxuXHRcdFx0Y29uc3QgY29udGV4dExvc3NJbmZvID0ge1xyXG5cdFx0XHRcdGFwaTogJ1dlYkdMJyxcclxuXHRcdFx0XHRtZXNzYWdlOiBldmVudC5zdGF0dXNNZXNzYWdlIHx8ICdVbmtub3duIHJlYXNvbicsXHJcblx0XHRcdFx0cmVhc29uOiBudWxsLFxyXG5cdFx0XHRcdG9yaWdpbmFsRXZlbnQ6IGV2ZW50XHJcblx0XHRcdH07XHJcblxyXG5cdFx0XHRyZW5kZXJlci5vbkRldmljZUxvc3QoIGNvbnRleHRMb3NzSW5mbyApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9vbkNvbnRleHRMb3N0ID0gb25Db250ZXh0TG9zdDtcclxuXHJcblx0XHRyZW5kZXJlci5kb21FbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoICd3ZWJnbGNvbnRleHRsb3N0Jywgb25Db250ZXh0TG9zdCwgZmFsc2UgKTtcclxuXHJcblx0XHR0aGlzLmdsID0gZ2xDb250ZXh0O1xyXG5cclxuXHRcdHRoaXMuZXh0ZW5zaW9ucyA9IG5ldyBXZWJHTEV4dGVuc2lvbnMoIHRoaXMgKTtcclxuXHRcdHRoaXMuY2FwYWJpbGl0aWVzID0gbmV3IFdlYkdMQ2FwYWJpbGl0aWVzKCB0aGlzICk7XHJcblx0XHR0aGlzLmF0dHJpYnV0ZVV0aWxzID0gbmV3IFdlYkdMQXR0cmlidXRlVXRpbHMoIHRoaXMgKTtcclxuXHRcdHRoaXMudGV4dHVyZVV0aWxzID0gbmV3IFdlYkdMVGV4dHVyZVV0aWxzKCB0aGlzICk7XHJcblx0XHR0aGlzLmJ1ZmZlclJlbmRlcmVyID0gbmV3IFdlYkdMQnVmZmVyUmVuZGVyZXIoIHRoaXMgKTtcclxuXHJcblx0XHR0aGlzLnN0YXRlID0gbmV3IFdlYkdMU3RhdGUoIHRoaXMgKTtcclxuXHRcdHRoaXMudXRpbHMgPSBuZXcgV2ViR0xVdGlscyggdGhpcyApO1xyXG5cclxuXHRcdHRoaXMudmFvQ2FjaGUgPSB7fTtcclxuXHRcdHRoaXMudHJhbnNmb3JtRmVlZGJhY2tDYWNoZSA9IHt9O1xyXG5cdFx0dGhpcy5kaXNjYXJkID0gZmFsc2U7XHJcblx0XHR0aGlzLnRyYWNrVGltZXN0YW1wID0gKCBwYXJhbWV0ZXJzLnRyYWNrVGltZXN0YW1wID09PSB0cnVlICk7XHJcblxyXG5cdFx0dGhpcy5leHRlbnNpb25zLmdldCggJ0VYVF9jb2xvcl9idWZmZXJfZmxvYXQnICk7XHJcblx0XHR0aGlzLmV4dGVuc2lvbnMuZ2V0KCAnV0VCR0xfY2xpcF9jdWxsX2Rpc3RhbmNlJyApO1xyXG5cdFx0dGhpcy5leHRlbnNpb25zLmdldCggJ09FU190ZXh0dXJlX2Zsb2F0X2xpbmVhcicgKTtcclxuXHRcdHRoaXMuZXh0ZW5zaW9ucy5nZXQoICdFWFRfY29sb3JfYnVmZmVyX2hhbGZfZmxvYXQnICk7XHJcblx0XHR0aGlzLmV4dGVuc2lvbnMuZ2V0KCAnV0VCR0xfbXVsdGlzYW1wbGVkX3JlbmRlcl90b190ZXh0dXJlJyApO1xyXG5cdFx0dGhpcy5leHRlbnNpb25zLmdldCggJ1dFQkdMX3JlbmRlcl9zaGFyZWRfZXhwb25lbnQnICk7XHJcblx0XHR0aGlzLmV4dGVuc2lvbnMuZ2V0KCAnV0VCR0xfbXVsdGlfZHJhdycgKTtcclxuXHJcblx0XHR0aGlzLmRpc2pvaW50ID0gdGhpcy5leHRlbnNpb25zLmdldCggJ0VYVF9kaXNqb2ludF90aW1lcl9xdWVyeV93ZWJnbDInICk7XHJcblx0XHR0aGlzLnBhcmFsbGVsID0gdGhpcy5leHRlbnNpb25zLmdldCggJ0tIUl9wYXJhbGxlbF9zaGFkZXJfY29tcGlsZScgKTtcclxuXHJcblx0XHR0aGlzLl9rbm93bkJpbmRpbmdzID0gbmV3IFdlYWtTZXQoKTtcclxuXHJcblx0XHR0aGlzLl9jdXJyZW50Q29udGV4dCA9IG51bGw7XHJcblxyXG5cdH1cclxuXHJcblx0Z2V0IGNvb3JkaW5hdGVTeXN0ZW0oKSB7XHJcblxyXG5cdFx0cmV0dXJuIFdlYkdMQ29vcmRpbmF0ZVN5c3RlbTtcclxuXHJcblx0fVxyXG5cclxuXHRhc3luYyBnZXRBcnJheUJ1ZmZlckFzeW5jKCBhdHRyaWJ1dGUgKSB7XHJcblxyXG5cdFx0cmV0dXJuIGF3YWl0IHRoaXMuYXR0cmlidXRlVXRpbHMuZ2V0QXJyYXlCdWZmZXJBc3luYyggYXR0cmlidXRlICk7XHJcblxyXG5cdH1cclxuXHJcblx0YXN5bmMgd2FpdEZvckdQVSgpIHtcclxuXHJcblx0XHRhd2FpdCB0aGlzLnV0aWxzLl9jbGllbnRXYWl0QXN5bmMoKTtcclxuXHJcblx0fVxyXG5cclxuXHRpbml0VGltZXN0YW1wUXVlcnkoIHJlbmRlckNvbnRleHQgKSB7XHJcblxyXG5cdFx0aWYgKCAhIHRoaXMuZGlzam9pbnQgfHwgISB0aGlzLnRyYWNrVGltZXN0YW1wICkgcmV0dXJuO1xyXG5cclxuXHRcdGNvbnN0IHJlbmRlckNvbnRleHREYXRhID0gdGhpcy5nZXQoIHJlbmRlckNvbnRleHQgKTtcclxuXHJcblx0XHRpZiAoIHRoaXMucXVlcnlSdW5uaW5nICkge1xyXG5cclxuXHRcdCAgaWYgKCAhIHJlbmRlckNvbnRleHREYXRhLnF1ZXJ5UXVldWUgKSByZW5kZXJDb250ZXh0RGF0YS5xdWVyeVF1ZXVlID0gW107XHJcblx0XHQgIHJlbmRlckNvbnRleHREYXRhLnF1ZXJ5UXVldWUucHVzaCggcmVuZGVyQ29udGV4dCApO1xyXG5cdFx0ICByZXR1cm47XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggcmVuZGVyQ29udGV4dERhdGEuYWN0aXZlUXVlcnkgKSB7XHJcblxyXG5cdFx0ICB0aGlzLmdsLmVuZFF1ZXJ5KCB0aGlzLmRpc2pvaW50LlRJTUVfRUxBUFNFRF9FWFQgKTtcclxuXHRcdCAgcmVuZGVyQ29udGV4dERhdGEuYWN0aXZlUXVlcnkgPSBudWxsO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZW5kZXJDb250ZXh0RGF0YS5hY3RpdmVRdWVyeSA9IHRoaXMuZ2wuY3JlYXRlUXVlcnkoKTtcclxuXHJcblx0XHRpZiAoIHJlbmRlckNvbnRleHREYXRhLmFjdGl2ZVF1ZXJ5ICE9PSBudWxsICkge1xyXG5cclxuXHRcdCAgdGhpcy5nbC5iZWdpblF1ZXJ5KCB0aGlzLmRpc2pvaW50LlRJTUVfRUxBUFNFRF9FWFQsIHJlbmRlckNvbnRleHREYXRhLmFjdGl2ZVF1ZXJ5ICk7XHJcblx0XHQgIHRoaXMucXVlcnlSdW5uaW5nID0gdHJ1ZTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0Ly8gdGltZXN0YW1wIHV0aWxzXHJcblxyXG5cdHByZXBhcmVUaW1lc3RhbXBCdWZmZXIoIHJlbmRlckNvbnRleHQgKSB7XHJcblxyXG5cdFx0aWYgKCAhIHRoaXMuZGlzam9pbnQgfHwgISB0aGlzLnRyYWNrVGltZXN0YW1wICkgcmV0dXJuO1xyXG5cclxuXHRcdGNvbnN0IHJlbmRlckNvbnRleHREYXRhID0gdGhpcy5nZXQoIHJlbmRlckNvbnRleHQgKTtcclxuXHJcblx0XHRpZiAoIHJlbmRlckNvbnRleHREYXRhLmFjdGl2ZVF1ZXJ5ICkge1xyXG5cclxuXHRcdCAgdGhpcy5nbC5lbmRRdWVyeSggdGhpcy5kaXNqb2ludC5USU1FX0VMQVBTRURfRVhUICk7XHJcblxyXG5cdFx0ICBpZiAoICEgcmVuZGVyQ29udGV4dERhdGEuZ3B1UXVlcmllcyApIHJlbmRlckNvbnRleHREYXRhLmdwdVF1ZXJpZXMgPSBbXTtcclxuXHRcdCAgcmVuZGVyQ29udGV4dERhdGEuZ3B1UXVlcmllcy5wdXNoKCB7IHF1ZXJ5OiByZW5kZXJDb250ZXh0RGF0YS5hY3RpdmVRdWVyeSB9ICk7XHJcblx0XHQgIHJlbmRlckNvbnRleHREYXRhLmFjdGl2ZVF1ZXJ5ID0gbnVsbDtcclxuXHRcdCAgdGhpcy5xdWVyeVJ1bm5pbmcgPSBmYWxzZTtcclxuXHJcblx0XHQgIGlmICggcmVuZGVyQ29udGV4dERhdGEucXVlcnlRdWV1ZSAmJiByZW5kZXJDb250ZXh0RGF0YS5xdWVyeVF1ZXVlLmxlbmd0aCA+IDAgKSB7XHJcblxyXG5cdFx0XHRcdGNvbnN0IG5leHRSZW5kZXJDb250ZXh0ID0gcmVuZGVyQ29udGV4dERhdGEucXVlcnlRdWV1ZS5zaGlmdCgpO1xyXG5cdFx0XHRcdHRoaXMuaW5pdFRpbWVzdGFtcFF1ZXJ5KCBuZXh0UmVuZGVyQ29udGV4dCApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHRhc3luYyByZXNvbHZlVGltZXN0YW1wQXN5bmMoIHJlbmRlckNvbnRleHQsIHR5cGUgPSAncmVuZGVyJyApIHtcclxuXHJcblx0XHRpZiAoICEgdGhpcy5kaXNqb2ludCB8fCAhIHRoaXMudHJhY2tUaW1lc3RhbXAgKSByZXR1cm47XHJcblxyXG5cdFx0Y29uc3QgcmVuZGVyQ29udGV4dERhdGEgPSB0aGlzLmdldCggcmVuZGVyQ29udGV4dCApO1xyXG5cclxuXHRcdGlmICggISByZW5kZXJDb250ZXh0RGF0YS5ncHVRdWVyaWVzICkgcmVuZGVyQ29udGV4dERhdGEuZ3B1UXVlcmllcyA9IFtdO1xyXG5cclxuXHRcdGZvciAoIGxldCBpID0gMDsgaSA8IHJlbmRlckNvbnRleHREYXRhLmdwdVF1ZXJpZXMubGVuZ3RoOyBpICsrICkge1xyXG5cclxuXHRcdCAgY29uc3QgcXVlcnlJbmZvID0gcmVuZGVyQ29udGV4dERhdGEuZ3B1UXVlcmllc1sgaSBdO1xyXG5cdFx0ICBjb25zdCBhdmFpbGFibGUgPSB0aGlzLmdsLmdldFF1ZXJ5UGFyYW1ldGVyKCBxdWVyeUluZm8ucXVlcnksIHRoaXMuZ2wuUVVFUllfUkVTVUxUX0FWQUlMQUJMRSApO1xyXG5cdFx0ICBjb25zdCBkaXNqb2ludCA9IHRoaXMuZ2wuZ2V0UGFyYW1ldGVyKCB0aGlzLmRpc2pvaW50LkdQVV9ESVNKT0lOVF9FWFQgKTtcclxuXHJcblx0XHQgIGlmICggYXZhaWxhYmxlICYmICEgZGlzam9pbnQgKSB7XHJcblxyXG5cdFx0XHRcdGNvbnN0IGVsYXBzZWQgPSB0aGlzLmdsLmdldFF1ZXJ5UGFyYW1ldGVyKCBxdWVyeUluZm8ucXVlcnksIHRoaXMuZ2wuUVVFUllfUkVTVUxUICk7XHJcblx0XHRcdFx0Y29uc3QgZHVyYXRpb24gPSBOdW1iZXIoIGVsYXBzZWQgKSAvIDEwMDAwMDA7IC8vIENvbnZlcnQgbmFub3NlY29uZHMgdG8gbWlsbGlzZWNvbmRzXHJcblx0XHRcdFx0dGhpcy5nbC5kZWxldGVRdWVyeSggcXVlcnlJbmZvLnF1ZXJ5ICk7XHJcblx0XHRcdFx0cmVuZGVyQ29udGV4dERhdGEuZ3B1UXVlcmllcy5zcGxpY2UoIGksIDEgKTsgLy8gUmVtb3ZlIHRoZSBwcm9jZXNzZWQgcXVlcnlcclxuXHRcdFx0XHRpIC0tO1xyXG5cdFx0XHRcdHRoaXMucmVuZGVyZXIuaW5mby51cGRhdGVUaW1lc3RhbXAoIHR5cGUsIGR1cmF0aW9uICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdGdldENvbnRleHQoKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuZ2w7XHJcblxyXG5cdH1cclxuXHJcblx0YmVnaW5SZW5kZXIoIHJlbmRlckNvbnRleHQgKSB7XHJcblxyXG5cdFx0Y29uc3QgeyBnbCB9ID0gdGhpcztcclxuXHRcdGNvbnN0IHJlbmRlckNvbnRleHREYXRhID0gdGhpcy5nZXQoIHJlbmRlckNvbnRleHQgKTtcclxuXHJcblx0XHQvL1xyXG5cclxuXHRcdC8vXHJcblxyXG5cdFx0dGhpcy5pbml0VGltZXN0YW1wUXVlcnkoIHJlbmRlckNvbnRleHQgKTtcclxuXHJcblx0XHRyZW5kZXJDb250ZXh0RGF0YS5wcmV2aW91c0NvbnRleHQgPSB0aGlzLl9jdXJyZW50Q29udGV4dDtcclxuXHRcdHRoaXMuX2N1cnJlbnRDb250ZXh0ID0gcmVuZGVyQ29udGV4dDtcclxuXHJcblx0XHR0aGlzLl9zZXRGcmFtZWJ1ZmZlciggcmVuZGVyQ29udGV4dCApO1xyXG5cclxuXHRcdHRoaXMuY2xlYXIoIHJlbmRlckNvbnRleHQuY2xlYXJDb2xvciwgcmVuZGVyQ29udGV4dC5jbGVhckRlcHRoLCByZW5kZXJDb250ZXh0LmNsZWFyU3RlbmNpbCwgcmVuZGVyQ29udGV4dCwgZmFsc2UgKTtcclxuXHJcblx0XHQvL1xyXG5cdFx0aWYgKCByZW5kZXJDb250ZXh0LnZpZXdwb3J0ICkge1xyXG5cclxuXHRcdFx0dGhpcy51cGRhdGVWaWV3cG9ydCggcmVuZGVyQ29udGV4dCApO1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRnbC52aWV3cG9ydCggMCwgMCwgZ2wuZHJhd2luZ0J1ZmZlcldpZHRoLCBnbC5kcmF3aW5nQnVmZmVySGVpZ2h0ICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggcmVuZGVyQ29udGV4dC5zY2lzc29yICkge1xyXG5cclxuXHRcdFx0Y29uc3QgeyB4LCB5LCB3aWR0aCwgaGVpZ2h0IH0gPSByZW5kZXJDb250ZXh0LnNjaXNzb3JWYWx1ZTtcclxuXHJcblx0XHRcdGdsLnNjaXNzb3IoIHgsIHJlbmRlckNvbnRleHQuaGVpZ2h0IC0gaGVpZ2h0IC0geSwgd2lkdGgsIGhlaWdodCApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRjb25zdCBvY2NsdXNpb25RdWVyeUNvdW50ID0gcmVuZGVyQ29udGV4dC5vY2NsdXNpb25RdWVyeUNvdW50O1xyXG5cclxuXHRcdGlmICggb2NjbHVzaW9uUXVlcnlDb3VudCA+IDAgKSB7XHJcblxyXG5cdFx0XHQvLyBHZXQgYSByZWZlcmVuY2UgdG8gdGhlIGFycmF5IG9mIG9iamVjdHMgd2l0aCBxdWVyaWVzLiBUaGUgcmVuZGVyQ29udGV4dERhdGEgcHJvcGVydHlcclxuXHRcdFx0Ly8gY2FuIGJlIGNoYW5nZWQgYnkgYW5vdGhlciByZW5kZXIgcGFzcyBiZWZvcmUgdGhlIGFzeW5jIHJlYWRpbmcgb2YgYWxsIHByZXZpb3VzIHF1ZXJpZXMgY29tcGxldGVcclxuXHRcdFx0cmVuZGVyQ29udGV4dERhdGEuY3VycmVudE9jY2x1c2lvblF1ZXJpZXMgPSByZW5kZXJDb250ZXh0RGF0YS5vY2NsdXNpb25RdWVyaWVzO1xyXG5cdFx0XHRyZW5kZXJDb250ZXh0RGF0YS5jdXJyZW50T2NjbHVzaW9uUXVlcnlPYmplY3RzID0gcmVuZGVyQ29udGV4dERhdGEub2NjbHVzaW9uUXVlcnlPYmplY3RzO1xyXG5cclxuXHRcdFx0cmVuZGVyQ29udGV4dERhdGEubGFzdE9jY2x1c2lvbk9iamVjdCA9IG51bGw7XHJcblx0XHRcdHJlbmRlckNvbnRleHREYXRhLm9jY2x1c2lvblF1ZXJpZXMgPSBuZXcgQXJyYXkoIG9jY2x1c2lvblF1ZXJ5Q291bnQgKTtcclxuXHRcdFx0cmVuZGVyQ29udGV4dERhdGEub2NjbHVzaW9uUXVlcnlPYmplY3RzID0gbmV3IEFycmF5KCBvY2NsdXNpb25RdWVyeUNvdW50ICk7XHJcblx0XHRcdHJlbmRlckNvbnRleHREYXRhLm9jY2x1c2lvblF1ZXJ5SW5kZXggPSAwO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHRmaW5pc2hSZW5kZXIoIHJlbmRlckNvbnRleHQgKSB7XHJcblxyXG5cdFx0Y29uc3QgeyBnbCwgc3RhdGUgfSA9IHRoaXM7XHJcblx0XHRjb25zdCByZW5kZXJDb250ZXh0RGF0YSA9IHRoaXMuZ2V0KCByZW5kZXJDb250ZXh0ICk7XHJcblx0XHRjb25zdCBwcmV2aW91c0NvbnRleHQgPSByZW5kZXJDb250ZXh0RGF0YS5wcmV2aW91c0NvbnRleHQ7XHJcblxyXG5cdFx0Y29uc3Qgb2NjbHVzaW9uUXVlcnlDb3VudCA9IHJlbmRlckNvbnRleHQub2NjbHVzaW9uUXVlcnlDb3VudDtcclxuXHJcblx0XHRpZiAoIG9jY2x1c2lvblF1ZXJ5Q291bnQgPiAwICkge1xyXG5cclxuXHRcdFx0aWYgKCBvY2NsdXNpb25RdWVyeUNvdW50ID4gcmVuZGVyQ29udGV4dERhdGEub2NjbHVzaW9uUXVlcnlJbmRleCApIHtcclxuXHJcblx0XHRcdFx0Z2wuZW5kUXVlcnkoIGdsLkFOWV9TQU1QTEVTX1BBU1NFRCApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dGhpcy5yZXNvbHZlT2NjbHVkZWRBc3luYyggcmVuZGVyQ29udGV4dCApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRjb25zdCB0ZXh0dXJlcyA9IHJlbmRlckNvbnRleHQudGV4dHVyZXM7XHJcblxyXG5cdFx0aWYgKCB0ZXh0dXJlcyAhPT0gbnVsbCApIHtcclxuXHJcblx0XHRcdGZvciAoIGxldCBpID0gMDsgaSA8IHRleHR1cmVzLmxlbmd0aDsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0Y29uc3QgdGV4dHVyZSA9IHRleHR1cmVzWyBpIF07XHJcblxyXG5cdFx0XHRcdGlmICggdGV4dHVyZS5nZW5lcmF0ZU1pcG1hcHMgKSB7XHJcblxyXG5cdFx0XHRcdFx0dGhpcy5nZW5lcmF0ZU1pcG1hcHMoIHRleHR1cmUgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9jdXJyZW50Q29udGV4dCA9IHByZXZpb3VzQ29udGV4dDtcclxuXHJcblx0XHRpZiAoIHJlbmRlckNvbnRleHQudGV4dHVyZXMgIT09IG51bGwgJiYgcmVuZGVyQ29udGV4dC5yZW5kZXJUYXJnZXQgKSB7XHJcblxyXG5cdFx0XHRjb25zdCByZW5kZXJUYXJnZXRDb250ZXh0RGF0YSA9IHRoaXMuZ2V0KCByZW5kZXJDb250ZXh0LnJlbmRlclRhcmdldCApO1xyXG5cclxuXHRcdFx0Y29uc3QgeyBzYW1wbGVzIH0gPSByZW5kZXJDb250ZXh0LnJlbmRlclRhcmdldDtcclxuXHJcblx0XHRcdGlmICggc2FtcGxlcyA+IDAgKSB7XHJcblxyXG5cdFx0XHRcdGNvbnN0IGZiID0gcmVuZGVyVGFyZ2V0Q29udGV4dERhdGEuZnJhbWVidWZmZXJzWyByZW5kZXJDb250ZXh0LmdldENhY2hlS2V5KCkgXTtcclxuXHJcblx0XHRcdFx0Y29uc3QgbWFzayA9IGdsLkNPTE9SX0JVRkZFUl9CSVQ7XHJcblxyXG5cdFx0XHRcdGNvbnN0IG1zYWFGcmFtZUJ1ZmZlciA9IHJlbmRlclRhcmdldENvbnRleHREYXRhLm1zYWFGcmFtZUJ1ZmZlcjtcclxuXHJcblx0XHRcdFx0Y29uc3QgdGV4dHVyZXMgPSByZW5kZXJDb250ZXh0LnRleHR1cmVzO1xyXG5cclxuXHRcdFx0XHRzdGF0ZS5iaW5kRnJhbWVidWZmZXIoIGdsLlJFQURfRlJBTUVCVUZGRVIsIG1zYWFGcmFtZUJ1ZmZlciApO1xyXG5cdFx0XHRcdHN0YXRlLmJpbmRGcmFtZWJ1ZmZlciggZ2wuRFJBV19GUkFNRUJVRkZFUiwgZmIgKTtcclxuXHJcblx0XHRcdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgdGV4dHVyZXMubGVuZ3RoOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHRcdC8vIFRPRE8gQWRkIHN1cHBvcnQgZm9yIE1SVFxyXG5cclxuXHRcdFx0XHRcdGlmICggcmVuZGVyQ29udGV4dC5zY2lzc29yICkge1xyXG5cclxuXHRcdFx0XHRcdFx0Y29uc3QgeyB4LCB5LCB3aWR0aCwgaGVpZ2h0IH0gPSByZW5kZXJDb250ZXh0LnNjaXNzb3JWYWx1ZTtcclxuXHJcblx0XHRcdFx0XHRcdGNvbnN0IHZpZXdZID0gcmVuZGVyQ29udGV4dC5oZWlnaHQgLSBoZWlnaHQgLSB5O1xyXG5cclxuXHRcdFx0XHRcdFx0Z2wuYmxpdEZyYW1lYnVmZmVyKCB4LCB2aWV3WSwgeCArIHdpZHRoLCB2aWV3WSArIGhlaWdodCwgeCwgdmlld1ksIHggKyB3aWR0aCwgdmlld1kgKyBoZWlnaHQsIG1hc2ssIGdsLk5FQVJFU1QgKTtcclxuXHRcdFx0XHRcdFx0Z2wuaW52YWxpZGF0ZVN1YkZyYW1lYnVmZmVyKCBnbC5SRUFEX0ZSQU1FQlVGRkVSLCByZW5kZXJUYXJnZXRDb250ZXh0RGF0YS5pbnZhbGlkYXRpb25BcnJheSwgeCwgdmlld1ksIHdpZHRoLCBoZWlnaHQgKTtcclxuXHJcblx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdFx0Z2wuYmxpdEZyYW1lYnVmZmVyKCAwLCAwLCByZW5kZXJDb250ZXh0LndpZHRoLCByZW5kZXJDb250ZXh0LmhlaWdodCwgMCwgMCwgcmVuZGVyQ29udGV4dC53aWR0aCwgcmVuZGVyQ29udGV4dC5oZWlnaHQsIG1hc2ssIGdsLk5FQVJFU1QgKTtcclxuXHRcdFx0XHRcdFx0Z2wuaW52YWxpZGF0ZUZyYW1lYnVmZmVyKCBnbC5SRUFEX0ZSQU1FQlVGRkVSLCByZW5kZXJUYXJnZXRDb250ZXh0RGF0YS5pbnZhbGlkYXRpb25BcnJheSApO1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBwcmV2aW91c0NvbnRleHQgIT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHR0aGlzLl9zZXRGcmFtZWJ1ZmZlciggcHJldmlvdXNDb250ZXh0ICk7XHJcblxyXG5cdFx0XHRpZiAoIHByZXZpb3VzQ29udGV4dC52aWV3cG9ydCApIHtcclxuXHJcblx0XHRcdFx0dGhpcy51cGRhdGVWaWV3cG9ydCggcHJldmlvdXNDb250ZXh0ICk7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRnbC52aWV3cG9ydCggMCwgMCwgZ2wuZHJhd2luZ0J1ZmZlcldpZHRoLCBnbC5kcmF3aW5nQnVmZmVySGVpZ2h0ICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMucHJlcGFyZVRpbWVzdGFtcEJ1ZmZlciggcmVuZGVyQ29udGV4dCApO1xyXG5cclxuXHR9XHJcblxyXG5cdHJlc29sdmVPY2NsdWRlZEFzeW5jKCByZW5kZXJDb250ZXh0ICkge1xyXG5cclxuXHRcdGNvbnN0IHJlbmRlckNvbnRleHREYXRhID0gdGhpcy5nZXQoIHJlbmRlckNvbnRleHQgKTtcclxuXHJcblx0XHQvLyBoYW5kbGUgb2NjbHVzaW9uIHF1ZXJ5IHJlc3VsdHNcclxuXHJcblx0XHRjb25zdCB7IGN1cnJlbnRPY2NsdXNpb25RdWVyaWVzLCBjdXJyZW50T2NjbHVzaW9uUXVlcnlPYmplY3RzIH0gPSByZW5kZXJDb250ZXh0RGF0YTtcclxuXHJcblx0XHRpZiAoIGN1cnJlbnRPY2NsdXNpb25RdWVyaWVzICYmIGN1cnJlbnRPY2NsdXNpb25RdWVyeU9iamVjdHMgKSB7XHJcblxyXG5cdFx0XHRjb25zdCBvY2NsdWRlZCA9IG5ldyBXZWFrU2V0KCk7XHJcblx0XHRcdGNvbnN0IHsgZ2wgfSA9IHRoaXM7XHJcblxyXG5cdFx0XHRyZW5kZXJDb250ZXh0RGF0YS5jdXJyZW50T2NjbHVzaW9uUXVlcnlPYmplY3RzID0gbnVsbDtcclxuXHRcdFx0cmVuZGVyQ29udGV4dERhdGEuY3VycmVudE9jY2x1c2lvblF1ZXJpZXMgPSBudWxsO1xyXG5cclxuXHRcdFx0Y29uc3QgY2hlY2sgPSAoKSA9PiB7XHJcblxyXG5cdFx0XHRcdGxldCBjb21wbGV0ZWQgPSAwO1xyXG5cclxuXHRcdFx0XHQvLyBjaGVjayBhbGwgcXVlcmllcyBhbmQgcmVxdWV1ZSBhcyBhcHByb3ByaWF0ZVxyXG5cdFx0XHRcdGZvciAoIGxldCBpID0gMDsgaSA8IGN1cnJlbnRPY2NsdXNpb25RdWVyaWVzLmxlbmd0aDsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0XHRjb25zdCBxdWVyeSA9IGN1cnJlbnRPY2NsdXNpb25RdWVyaWVzWyBpIF07XHJcblxyXG5cdFx0XHRcdFx0aWYgKCBxdWVyeSA9PT0gbnVsbCApIGNvbnRpbnVlO1xyXG5cclxuXHRcdFx0XHRcdGlmICggZ2wuZ2V0UXVlcnlQYXJhbWV0ZXIoIHF1ZXJ5LCBnbC5RVUVSWV9SRVNVTFRfQVZBSUxBQkxFICkgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRpZiAoIGdsLmdldFF1ZXJ5UGFyYW1ldGVyKCBxdWVyeSwgZ2wuUVVFUllfUkVTVUxUICkgPiAwICkgb2NjbHVkZWQuYWRkKCBjdXJyZW50T2NjbHVzaW9uUXVlcnlPYmplY3RzWyBpIF0gKTtcclxuXHJcblx0XHRcdFx0XHRcdGN1cnJlbnRPY2NsdXNpb25RdWVyaWVzWyBpIF0gPSBudWxsO1xyXG5cdFx0XHRcdFx0XHRnbC5kZWxldGVRdWVyeSggcXVlcnkgKTtcclxuXHJcblx0XHRcdFx0XHRcdGNvbXBsZXRlZCArKztcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0aWYgKCBjb21wbGV0ZWQgPCBjdXJyZW50T2NjbHVzaW9uUXVlcmllcy5sZW5ndGggKSB7XHJcblxyXG5cdFx0XHRcdFx0cmVxdWVzdEFuaW1hdGlvbkZyYW1lKCBjaGVjayApO1xyXG5cclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdHJlbmRlckNvbnRleHREYXRhLm9jY2x1ZGVkID0gb2NjbHVkZWQ7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH07XHJcblxyXG5cdFx0XHRjaGVjaygpO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHRpc09jY2x1ZGVkKCByZW5kZXJDb250ZXh0LCBvYmplY3QgKSB7XHJcblxyXG5cdFx0Y29uc3QgcmVuZGVyQ29udGV4dERhdGEgPSB0aGlzLmdldCggcmVuZGVyQ29udGV4dCApO1xyXG5cclxuXHRcdHJldHVybiByZW5kZXJDb250ZXh0RGF0YS5vY2NsdWRlZCAmJiByZW5kZXJDb250ZXh0RGF0YS5vY2NsdWRlZC5oYXMoIG9iamVjdCApO1xyXG5cclxuXHR9XHJcblxyXG5cdHVwZGF0ZVZpZXdwb3J0KCByZW5kZXJDb250ZXh0ICkge1xyXG5cclxuXHRcdGNvbnN0IGdsID0gdGhpcy5nbDtcclxuXHRcdGNvbnN0IHsgeCwgeSwgd2lkdGgsIGhlaWdodCB9ID0gcmVuZGVyQ29udGV4dC52aWV3cG9ydFZhbHVlO1xyXG5cclxuXHRcdGdsLnZpZXdwb3J0KCB4LCByZW5kZXJDb250ZXh0LmhlaWdodCAtIGhlaWdodCAtIHksIHdpZHRoLCBoZWlnaHQgKTtcclxuXHJcblx0fVxyXG5cclxuXHRzZXRTY2lzc29yVGVzdCggYm9vbGVhbiApIHtcclxuXHJcblx0XHRjb25zdCBnbCA9IHRoaXMuZ2w7XHJcblxyXG5cdFx0aWYgKCBib29sZWFuICkge1xyXG5cclxuXHRcdFx0Z2wuZW5hYmxlKCBnbC5TQ0lTU09SX1RFU1QgKTtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0Z2wuZGlzYWJsZSggZ2wuU0NJU1NPUl9URVNUICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdGNsZWFyKCBjb2xvciwgZGVwdGgsIHN0ZW5jaWwsIGRlc2NyaXB0b3IgPSBudWxsLCBzZXRGcmFtZUJ1ZmZlciA9IHRydWUgKSB7XHJcblxyXG5cdFx0Y29uc3QgeyBnbCB9ID0gdGhpcztcclxuXHJcblx0XHRpZiAoIGRlc2NyaXB0b3IgPT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHRjb25zdCBjbGVhckNvbG9yID0gdGhpcy5nZXRDbGVhckNvbG9yKCk7XHJcblxyXG5cdFx0XHQvLyBwcmVtdWx0aXBseSBhbHBoYVxyXG5cclxuXHRcdFx0Y2xlYXJDb2xvci5yICo9IGNsZWFyQ29sb3IuYTtcclxuXHRcdFx0Y2xlYXJDb2xvci5nICo9IGNsZWFyQ29sb3IuYTtcclxuXHRcdFx0Y2xlYXJDb2xvci5iICo9IGNsZWFyQ29sb3IuYTtcclxuXHJcblx0XHRcdGRlc2NyaXB0b3IgPSB7XHJcblx0XHRcdFx0dGV4dHVyZXM6IG51bGwsXHJcblx0XHRcdFx0Y2xlYXJDb2xvclZhbHVlOiBjbGVhckNvbG9yXHJcblx0XHRcdH07XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vXHJcblxyXG5cdFx0bGV0IGNsZWFyID0gMDtcclxuXHJcblx0XHRpZiAoIGNvbG9yICkgY2xlYXIgfD0gZ2wuQ09MT1JfQlVGRkVSX0JJVDtcclxuXHRcdGlmICggZGVwdGggKSBjbGVhciB8PSBnbC5ERVBUSF9CVUZGRVJfQklUO1xyXG5cdFx0aWYgKCBzdGVuY2lsICkgY2xlYXIgfD0gZ2wuU1RFTkNJTF9CVUZGRVJfQklUO1xyXG5cclxuXHRcdGlmICggY2xlYXIgIT09IDAgKSB7XHJcblxyXG5cdFx0XHRsZXQgY2xlYXJDb2xvcjtcclxuXHJcblx0XHRcdGlmICggZGVzY3JpcHRvci5jbGVhckNvbG9yVmFsdWUgKSB7XHJcblxyXG5cdFx0XHRcdGNsZWFyQ29sb3IgPSBkZXNjcmlwdG9yLmNsZWFyQ29sb3JWYWx1ZTtcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdGNsZWFyQ29sb3IgPSB0aGlzLmdldENsZWFyQ29sb3IoKTtcclxuXHJcblx0XHRcdFx0Ly8gcHJlbXVsdGlwbHkgYWxwaGFcclxuXHJcblx0XHRcdFx0Y2xlYXJDb2xvci5yICo9IGNsZWFyQ29sb3IuYTtcclxuXHRcdFx0XHRjbGVhckNvbG9yLmcgKj0gY2xlYXJDb2xvci5hO1xyXG5cdFx0XHRcdGNsZWFyQ29sb3IuYiAqPSBjbGVhckNvbG9yLmE7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoIGRlcHRoICkgdGhpcy5zdGF0ZS5zZXREZXB0aE1hc2soIHRydWUgKTtcclxuXHJcblx0XHRcdGlmICggZGVzY3JpcHRvci50ZXh0dXJlcyA9PT0gbnVsbCApIHtcclxuXHJcblx0XHRcdFx0Z2wuY2xlYXJDb2xvciggY2xlYXJDb2xvci5yLCBjbGVhckNvbG9yLmcsIGNsZWFyQ29sb3IuYiwgY2xlYXJDb2xvci5hICk7XHJcblx0XHRcdFx0Z2wuY2xlYXIoIGNsZWFyICk7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRpZiAoIHNldEZyYW1lQnVmZmVyICkgdGhpcy5fc2V0RnJhbWVidWZmZXIoIGRlc2NyaXB0b3IgKTtcclxuXHJcblx0XHRcdFx0aWYgKCBjb2xvciApIHtcclxuXHJcblx0XHRcdFx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCBkZXNjcmlwdG9yLnRleHR1cmVzLmxlbmd0aDsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0XHRcdGdsLmNsZWFyQnVmZmVyZnYoIGdsLkNPTE9SLCBpLCBbIGNsZWFyQ29sb3IuciwgY2xlYXJDb2xvci5nLCBjbGVhckNvbG9yLmIsIGNsZWFyQ29sb3IuYSBdICk7XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGlmICggZGVwdGggJiYgc3RlbmNpbCApIHtcclxuXHJcblx0XHRcdFx0XHRnbC5jbGVhckJ1ZmZlcmZpKCBnbC5ERVBUSF9TVEVOQ0lMLCAwLCAxLCAwICk7XHJcblxyXG5cdFx0XHRcdH0gZWxzZSBpZiAoIGRlcHRoICkge1xyXG5cclxuXHRcdFx0XHRcdGdsLmNsZWFyQnVmZmVyZnYoIGdsLkRFUFRILCAwLCBbIDEuMCBdICk7XHJcblxyXG5cdFx0XHRcdH0gZWxzZSBpZiAoIHN0ZW5jaWwgKSB7XHJcblxyXG5cdFx0XHRcdFx0Z2wuY2xlYXJCdWZmZXJpdiggZ2wuU1RFTkNJTCwgMCwgWyAwIF0gKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHRiZWdpbkNvbXB1dGUoIGNvbXB1dGVHcm91cCApIHtcclxuXHJcblx0XHRjb25zdCB7IHN0YXRlLCBnbCB9ID0gdGhpcztcclxuXHJcblx0XHRzdGF0ZS5iaW5kRnJhbWVidWZmZXIoIGdsLkZSQU1FQlVGRkVSLCBudWxsICk7XHJcblx0XHR0aGlzLmluaXRUaW1lc3RhbXBRdWVyeSggY29tcHV0ZUdyb3VwICk7XHJcblxyXG5cdH1cclxuXHJcblx0Y29tcHV0ZSggY29tcHV0ZUdyb3VwLCBjb21wdXRlTm9kZSwgYmluZGluZ3MsIHBpcGVsaW5lICkge1xyXG5cclxuXHRcdGNvbnN0IHsgc3RhdGUsIGdsIH0gPSB0aGlzO1xyXG5cclxuXHRcdGlmICggISB0aGlzLmRpc2NhcmQgKSB7XHJcblxyXG5cdFx0XHQvLyByZXF1aXJlZCBoZXJlIHRvIGhhbmRsZSBhc3luYyBiZWhhdmlvdXIgb2YgcmVuZGVyLmNvbXB1dGUoKVxyXG5cdFx0XHRnbC5lbmFibGUoIGdsLlJBU1RFUklaRVJfRElTQ0FSRCApO1xyXG5cdFx0XHR0aGlzLmRpc2NhcmQgPSB0cnVlO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRjb25zdCB7IHByb2dyYW1HUFUsIHRyYW5zZm9ybUJ1ZmZlcnMsIGF0dHJpYnV0ZXMgfSA9IHRoaXMuZ2V0KCBwaXBlbGluZSApO1xyXG5cclxuXHRcdGNvbnN0IHZhb0tleSA9IHRoaXMuX2dldFZhb0tleSggbnVsbCwgYXR0cmlidXRlcyApO1xyXG5cclxuXHRcdGNvbnN0IHZhb0dQVSA9IHRoaXMudmFvQ2FjaGVbIHZhb0tleSBdO1xyXG5cclxuXHRcdGlmICggdmFvR1BVID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHR0aGlzLl9jcmVhdGVWYW8oIG51bGwsIGF0dHJpYnV0ZXMgKTtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0Z2wuYmluZFZlcnRleEFycmF5KCB2YW9HUFUgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0c3RhdGUudXNlUHJvZ3JhbSggcHJvZ3JhbUdQVSApO1xyXG5cclxuXHRcdHRoaXMuX2JpbmRVbmlmb3JtcyggYmluZGluZ3MgKTtcclxuXHJcblx0XHRjb25zdCB0cmFuc2Zvcm1GZWVkYmFja0dQVSA9IHRoaXMuX2dldFRyYW5zZm9ybUZlZWRiYWNrKCB0cmFuc2Zvcm1CdWZmZXJzICk7XHJcblxyXG5cdFx0Z2wuYmluZFRyYW5zZm9ybUZlZWRiYWNrKCBnbC5UUkFOU0ZPUk1fRkVFREJBQ0ssIHRyYW5zZm9ybUZlZWRiYWNrR1BVICk7XHJcblx0XHRnbC5iZWdpblRyYW5zZm9ybUZlZWRiYWNrKCBnbC5QT0lOVFMgKTtcclxuXHJcblx0XHRpZiAoIGF0dHJpYnV0ZXNbIDAgXS5pc1N0b3JhZ2VJbnN0YW5jZWRCdWZmZXJBdHRyaWJ1dGUgKSB7XHJcblxyXG5cdFx0XHRnbC5kcmF3QXJyYXlzSW5zdGFuY2VkKCBnbC5QT0lOVFMsIDAsIDEsIGNvbXB1dGVOb2RlLmNvdW50ICk7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdGdsLmRyYXdBcnJheXMoIGdsLlBPSU5UUywgMCwgY29tcHV0ZU5vZGUuY291bnQgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Z2wuZW5kVHJhbnNmb3JtRmVlZGJhY2soKTtcclxuXHRcdGdsLmJpbmRUcmFuc2Zvcm1GZWVkYmFjayggZ2wuVFJBTlNGT1JNX0ZFRURCQUNLLCBudWxsICk7XHJcblxyXG5cdFx0Ly8gc3dpdGNoIGFjdGl2ZSBidWZmZXJzXHJcblxyXG5cdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgdHJhbnNmb3JtQnVmZmVycy5sZW5ndGg7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRjb25zdCBkdWFsQXR0cmlidXRlRGF0YSA9IHRyYW5zZm9ybUJ1ZmZlcnNbIGkgXTtcclxuXHJcblx0XHRcdGlmICggZHVhbEF0dHJpYnV0ZURhdGEucGJvICkge1xyXG5cclxuXHRcdFx0XHR0aGlzLnRleHR1cmVVdGlscy5jb3B5QnVmZmVyVG9UZXh0dXJlKCBkdWFsQXR0cmlidXRlRGF0YS50cmFuc2Zvcm1CdWZmZXIsIGR1YWxBdHRyaWJ1dGVEYXRhLnBibyApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0ZHVhbEF0dHJpYnV0ZURhdGEuc3dpdGNoQnVmZmVycygpO1xyXG5cclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0ZmluaXNoQ29tcHV0ZSggY29tcHV0ZUdyb3VwICkge1xyXG5cclxuXHRcdGNvbnN0IGdsID0gdGhpcy5nbDtcclxuXHJcblx0XHR0aGlzLmRpc2NhcmQgPSBmYWxzZTtcclxuXHJcblx0XHRnbC5kaXNhYmxlKCBnbC5SQVNURVJJWkVSX0RJU0NBUkQgKTtcclxuXHJcblx0XHR0aGlzLnByZXBhcmVUaW1lc3RhbXBCdWZmZXIoIGNvbXB1dGVHcm91cCApO1xyXG5cclxuXHRcdGlmICggdGhpcy5fY3VycmVudENvbnRleHQgKSB7XHJcblxyXG5cdFx0XHR0aGlzLl9zZXRGcmFtZWJ1ZmZlciggdGhpcy5fY3VycmVudENvbnRleHQgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0ZHJhdyggcmVuZGVyT2JqZWN0LyosIGluZm8qLyApIHtcclxuXHJcblx0XHRjb25zdCB7IG9iamVjdCwgcGlwZWxpbmUsIG1hdGVyaWFsLCBjb250ZXh0LCBoYXJkd2FyZUNsaXBwaW5nUGxhbmVzIH0gPSByZW5kZXJPYmplY3Q7XHJcblx0XHRjb25zdCB7IHByb2dyYW1HUFUgfSA9IHRoaXMuZ2V0KCBwaXBlbGluZSApO1xyXG5cclxuXHRcdGNvbnN0IHsgZ2wsIHN0YXRlIH0gPSB0aGlzO1xyXG5cclxuXHRcdGNvbnN0IGNvbnRleHREYXRhID0gdGhpcy5nZXQoIGNvbnRleHQgKTtcclxuXHJcblx0XHRjb25zdCBkcmF3UGFyYW1zID0gcmVuZGVyT2JqZWN0LmdldERyYXdQYXJhbWV0ZXJzKCk7XHJcblxyXG5cdFx0aWYgKCBkcmF3UGFyYW1zID09PSBudWxsICkgcmV0dXJuO1xyXG5cclxuXHRcdC8vXHJcblxyXG5cdFx0dGhpcy5fYmluZFVuaWZvcm1zKCByZW5kZXJPYmplY3QuZ2V0QmluZGluZ3MoKSApO1xyXG5cclxuXHRcdGNvbnN0IGZyb250RmFjZUNXID0gKCBvYmplY3QuaXNNZXNoICYmIG9iamVjdC5tYXRyaXhXb3JsZC5kZXRlcm1pbmFudCgpIDwgMCApO1xyXG5cclxuXHRcdHN0YXRlLnNldE1hdGVyaWFsKCBtYXRlcmlhbCwgZnJvbnRGYWNlQ1csIGhhcmR3YXJlQ2xpcHBpbmdQbGFuZXMgKTtcclxuXHJcblx0XHRzdGF0ZS51c2VQcm9ncmFtKCBwcm9ncmFtR1BVICk7XHJcblxyXG5cdFx0Ly9cclxuXHJcblx0XHRjb25zdCByZW5kZXJPYmplY3REYXRhID0gdGhpcy5nZXQoIHJlbmRlck9iamVjdCApO1xyXG5cclxuXHRcdGxldCB2YW9HUFUgPSByZW5kZXJPYmplY3REYXRhLnN0YXRpY1ZhbztcclxuXHJcblx0XHRpZiAoIHZhb0dQVSA9PT0gdW5kZWZpbmVkIHx8IHJlbmRlck9iamVjdERhdGEuZ2VvbWV0cnlJZCAhPT0gcmVuZGVyT2JqZWN0Lmdlb21ldHJ5LmlkICkge1xyXG5cclxuXHRcdFx0Y29uc3QgdmFvS2V5ID0gdGhpcy5fZ2V0VmFvS2V5KCByZW5kZXJPYmplY3QuZ2V0SW5kZXgoKSwgcmVuZGVyT2JqZWN0LmdldEF0dHJpYnV0ZXMoKSApO1xyXG5cclxuXHRcdFx0dmFvR1BVID0gdGhpcy52YW9DYWNoZVsgdmFvS2V5IF07XHJcblxyXG5cdFx0XHRpZiAoIHZhb0dQVSA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRsZXQgc3RhdGljVmFvO1xyXG5cclxuXHRcdFx0XHQoIHsgdmFvR1BVLCBzdGF0aWNWYW8gfSA9IHRoaXMuX2NyZWF0ZVZhbyggcmVuZGVyT2JqZWN0LmdldEluZGV4KCksIHJlbmRlck9iamVjdC5nZXRBdHRyaWJ1dGVzKCkgKSApO1xyXG5cclxuXHRcdFx0XHRpZiAoIHN0YXRpY1ZhbyApIHtcclxuXHJcblx0XHRcdFx0XHRyZW5kZXJPYmplY3REYXRhLnN0YXRpY1ZhbyA9IHZhb0dQVTtcclxuXHRcdFx0XHRcdHJlbmRlck9iamVjdERhdGEuZ2VvbWV0cnlJZCA9IHJlbmRlck9iamVjdC5nZW9tZXRyeS5pZDtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRnbC5iaW5kVmVydGV4QXJyYXkoIHZhb0dQVSApO1xyXG5cclxuXHRcdC8vXHJcblxyXG5cdFx0Y29uc3QgaW5kZXggPSByZW5kZXJPYmplY3QuZ2V0SW5kZXgoKTtcclxuXHJcblx0XHQvL1xyXG5cclxuXHRcdGNvbnN0IGxhc3RPYmplY3QgPSBjb250ZXh0RGF0YS5sYXN0T2NjbHVzaW9uT2JqZWN0O1xyXG5cclxuXHRcdGlmICggbGFzdE9iamVjdCAhPT0gb2JqZWN0ICYmIGxhc3RPYmplY3QgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdGlmICggbGFzdE9iamVjdCAhPT0gbnVsbCAmJiBsYXN0T2JqZWN0Lm9jY2x1c2lvblRlc3QgPT09IHRydWUgKSB7XHJcblxyXG5cdFx0XHRcdGdsLmVuZFF1ZXJ5KCBnbC5BTllfU0FNUExFU19QQVNTRUQgKTtcclxuXHJcblx0XHRcdFx0Y29udGV4dERhdGEub2NjbHVzaW9uUXVlcnlJbmRleCArKztcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICggb2JqZWN0Lm9jY2x1c2lvblRlc3QgPT09IHRydWUgKSB7XHJcblxyXG5cdFx0XHRcdGNvbnN0IHF1ZXJ5ID0gZ2wuY3JlYXRlUXVlcnkoKTtcclxuXHJcblx0XHRcdFx0Z2wuYmVnaW5RdWVyeSggZ2wuQU5ZX1NBTVBMRVNfUEFTU0VELCBxdWVyeSApO1xyXG5cclxuXHRcdFx0XHRjb250ZXh0RGF0YS5vY2NsdXNpb25RdWVyaWVzWyBjb250ZXh0RGF0YS5vY2NsdXNpb25RdWVyeUluZGV4IF0gPSBxdWVyeTtcclxuXHRcdFx0XHRjb250ZXh0RGF0YS5vY2NsdXNpb25RdWVyeU9iamVjdHNbIGNvbnRleHREYXRhLm9jY2x1c2lvblF1ZXJ5SW5kZXggXSA9IG9iamVjdDtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGNvbnRleHREYXRhLmxhc3RPY2NsdXNpb25PYmplY3QgPSBvYmplY3Q7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vXHJcblx0XHRjb25zdCByZW5kZXJlciA9IHRoaXMuYnVmZmVyUmVuZGVyZXI7XHJcblxyXG5cdFx0aWYgKCBvYmplY3QuaXNQb2ludHMgKSByZW5kZXJlci5tb2RlID0gZ2wuUE9JTlRTO1xyXG5cdFx0ZWxzZSBpZiAoIG9iamVjdC5pc0xpbmVTZWdtZW50cyApIHJlbmRlcmVyLm1vZGUgPSBnbC5MSU5FUztcclxuXHRcdGVsc2UgaWYgKCBvYmplY3QuaXNMaW5lICkgcmVuZGVyZXIubW9kZSA9IGdsLkxJTkVfU1RSSVA7XHJcblx0XHRlbHNlIGlmICggb2JqZWN0LmlzTGluZUxvb3AgKSByZW5kZXJlci5tb2RlID0gZ2wuTElORV9MT09QO1xyXG5cdFx0ZWxzZSB7XHJcblxyXG5cdFx0XHRpZiAoIG1hdGVyaWFsLndpcmVmcmFtZSA9PT0gdHJ1ZSApIHtcclxuXHJcblx0XHRcdFx0c3RhdGUuc2V0TGluZVdpZHRoKCBtYXRlcmlhbC53aXJlZnJhbWVMaW5ld2lkdGggKiB0aGlzLnJlbmRlcmVyLmdldFBpeGVsUmF0aW8oKSApO1xyXG5cdFx0XHRcdHJlbmRlcmVyLm1vZGUgPSBnbC5MSU5FUztcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdHJlbmRlcmVyLm1vZGUgPSBnbC5UUklBTkdMRVM7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vXHJcblxyXG5cdFx0Y29uc3QgeyB2ZXJ0ZXhDb3VudCwgaW5zdGFuY2VDb3VudCB9ID0gZHJhd1BhcmFtcztcclxuXHRcdGxldCB7IGZpcnN0VmVydGV4IH0gPSBkcmF3UGFyYW1zO1xyXG5cclxuXHRcdHJlbmRlcmVyLm9iamVjdCA9IG9iamVjdDtcclxuXHJcblx0XHRpZiAoIGluZGV4ICE9PSBudWxsICkge1xyXG5cclxuXHRcdFx0Zmlyc3RWZXJ0ZXggKj0gaW5kZXguYXJyYXkuQllURVNfUEVSX0VMRU1FTlQ7XHJcblxyXG5cdFx0XHRjb25zdCBpbmRleERhdGEgPSB0aGlzLmdldCggaW5kZXggKTtcclxuXHJcblx0XHRcdHJlbmRlcmVyLmluZGV4ID0gaW5kZXguY291bnQ7XHJcblx0XHRcdHJlbmRlcmVyLnR5cGUgPSBpbmRleERhdGEudHlwZTtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0cmVuZGVyZXIuaW5kZXggPSAwO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIG9iamVjdC5pc0JhdGNoZWRNZXNoICkge1xyXG5cclxuXHRcdFx0aWYgKCBvYmplY3QuX211bHRpRHJhd0luc3RhbmNlcyAhPT0gbnVsbCApIHtcclxuXHJcblx0XHRcdFx0cmVuZGVyZXIucmVuZGVyTXVsdGlEcmF3SW5zdGFuY2VzKCBvYmplY3QuX211bHRpRHJhd1N0YXJ0cywgb2JqZWN0Ll9tdWx0aURyYXdDb3VudHMsIG9iamVjdC5fbXVsdGlEcmF3Q291bnQsIG9iamVjdC5fbXVsdGlEcmF3SW5zdGFuY2VzICk7XHJcblxyXG5cdFx0XHR9IGVsc2UgaWYgKCAhIHRoaXMuaGFzRmVhdHVyZSggJ1dFQkdMX211bHRpX2RyYXcnICkgKSB7XHJcblxyXG5cdFx0XHRcdHdhcm5PbmNlKCAnVEhSRUUuV2ViR0xSZW5kZXJlcjogV0VCR0xfbXVsdGlfZHJhdyBub3Qgc3VwcG9ydGVkLicgKTtcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdHJlbmRlcmVyLnJlbmRlck11bHRpRHJhdyggb2JqZWN0Ll9tdWx0aURyYXdTdGFydHMsIG9iamVjdC5fbXVsdGlEcmF3Q291bnRzLCBvYmplY3QuX211bHRpRHJhd0NvdW50ICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fSBlbHNlIGlmICggaW5zdGFuY2VDb3VudCA+IDEgKSB7XHJcblxyXG5cdFx0XHRyZW5kZXJlci5yZW5kZXJJbnN0YW5jZXMoIGZpcnN0VmVydGV4LCB2ZXJ0ZXhDb3VudCwgaW5zdGFuY2VDb3VudCApO1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRyZW5kZXJlci5yZW5kZXIoIGZpcnN0VmVydGV4LCB2ZXJ0ZXhDb3VudCApO1xyXG5cclxuXHRcdH1cclxuXHRcdC8vXHJcblxyXG5cdFx0Z2wuYmluZFZlcnRleEFycmF5KCBudWxsICk7XHJcblxyXG5cdH1cclxuXHJcblx0bmVlZHNSZW5kZXJVcGRhdGUoIC8qcmVuZGVyT2JqZWN0Ki8gKSB7XHJcblxyXG5cdFx0cmV0dXJuIGZhbHNlO1xyXG5cclxuXHR9XHJcblxyXG5cdGdldFJlbmRlckNhY2hlS2V5KCAvKnJlbmRlck9iamVjdCovICkge1xyXG5cclxuXHRcdHJldHVybiAnJztcclxuXHJcblx0fVxyXG5cclxuXHQvLyB0ZXh0dXJlc1xyXG5cclxuXHRjcmVhdGVEZWZhdWx0VGV4dHVyZSggdGV4dHVyZSApIHtcclxuXHJcblx0XHR0aGlzLnRleHR1cmVVdGlscy5jcmVhdGVEZWZhdWx0VGV4dHVyZSggdGV4dHVyZSApO1xyXG5cclxuXHR9XHJcblxyXG5cdGNyZWF0ZVRleHR1cmUoIHRleHR1cmUsIG9wdGlvbnMgKSB7XHJcblxyXG5cdFx0dGhpcy50ZXh0dXJlVXRpbHMuY3JlYXRlVGV4dHVyZSggdGV4dHVyZSwgb3B0aW9ucyApO1xyXG5cclxuXHR9XHJcblxyXG5cdHVwZGF0ZVRleHR1cmUoIHRleHR1cmUsIG9wdGlvbnMgKSB7XHJcblxyXG5cdFx0dGhpcy50ZXh0dXJlVXRpbHMudXBkYXRlVGV4dHVyZSggdGV4dHVyZSwgb3B0aW9ucyApO1xyXG5cclxuXHR9XHJcblxyXG5cdGdlbmVyYXRlTWlwbWFwcyggdGV4dHVyZSApIHtcclxuXHJcblx0XHR0aGlzLnRleHR1cmVVdGlscy5nZW5lcmF0ZU1pcG1hcHMoIHRleHR1cmUgKTtcclxuXHJcblx0fVxyXG5cclxuXHJcblx0ZGVzdHJveVRleHR1cmUoIHRleHR1cmUgKSB7XHJcblxyXG5cdFx0dGhpcy50ZXh0dXJlVXRpbHMuZGVzdHJveVRleHR1cmUoIHRleHR1cmUgKTtcclxuXHJcblx0fVxyXG5cclxuXHRjb3B5VGV4dHVyZVRvQnVmZmVyKCB0ZXh0dXJlLCB4LCB5LCB3aWR0aCwgaGVpZ2h0LCBmYWNlSW5kZXggKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMudGV4dHVyZVV0aWxzLmNvcHlUZXh0dXJlVG9CdWZmZXIoIHRleHR1cmUsIHgsIHksIHdpZHRoLCBoZWlnaHQsIGZhY2VJbmRleCApO1xyXG5cclxuXHR9XHJcblxyXG5cdGNyZWF0ZVNhbXBsZXIoIC8qdGV4dHVyZSovICkge1xyXG5cclxuXHRcdC8vY29uc29sZS53YXJuKCAnQWJzdHJhY3QgY2xhc3MuJyApO1xyXG5cclxuXHR9XHJcblxyXG5cdGRlc3Ryb3lTYW1wbGVyKCkge31cclxuXHJcblx0Ly8gbm9kZSBidWlsZGVyXHJcblxyXG5cdGNyZWF0ZU5vZGVCdWlsZGVyKCBvYmplY3QsIHJlbmRlcmVyICkge1xyXG5cclxuXHRcdHJldHVybiBuZXcgR0xTTE5vZGVCdWlsZGVyKCBvYmplY3QsIHJlbmRlcmVyICk7XHJcblxyXG5cdH1cclxuXHJcblx0Ly8gcHJvZ3JhbVxyXG5cclxuXHRjcmVhdGVQcm9ncmFtKCBwcm9ncmFtICkge1xyXG5cclxuXHRcdGNvbnN0IGdsID0gdGhpcy5nbDtcclxuXHRcdGNvbnN0IHsgc3RhZ2UsIGNvZGUgfSA9IHByb2dyYW07XHJcblxyXG5cdFx0Y29uc3Qgc2hhZGVyID0gc3RhZ2UgPT09ICdmcmFnbWVudCcgPyBnbC5jcmVhdGVTaGFkZXIoIGdsLkZSQUdNRU5UX1NIQURFUiApIDogZ2wuY3JlYXRlU2hhZGVyKCBnbC5WRVJURVhfU0hBREVSICk7XHJcblxyXG5cdFx0Z2wuc2hhZGVyU291cmNlKCBzaGFkZXIsIGNvZGUgKTtcclxuXHRcdGdsLmNvbXBpbGVTaGFkZXIoIHNoYWRlciApO1xyXG5cclxuXHRcdHRoaXMuc2V0KCBwcm9ncmFtLCB7XHJcblx0XHRcdHNoYWRlckdQVTogc2hhZGVyXHJcblx0XHR9ICk7XHJcblxyXG5cdH1cclxuXHJcblx0ZGVzdHJveVByb2dyYW0oIC8qcHJvZ3JhbSovICkge1xyXG5cclxuXHRcdGNvbnNvbGUud2FybiggJ0Fic3RyYWN0IGNsYXNzLicgKTtcclxuXHJcblx0fVxyXG5cclxuXHRjcmVhdGVSZW5kZXJQaXBlbGluZSggcmVuZGVyT2JqZWN0LCBwcm9taXNlcyApIHtcclxuXHJcblx0XHRjb25zdCBnbCA9IHRoaXMuZ2w7XHJcblx0XHRjb25zdCBwaXBlbGluZSA9IHJlbmRlck9iamVjdC5waXBlbGluZTtcclxuXHJcblx0XHQvLyBQcm9ncmFtXHJcblxyXG5cdFx0Y29uc3QgeyBmcmFnbWVudFByb2dyYW0sIHZlcnRleFByb2dyYW0gfSA9IHBpcGVsaW5lO1xyXG5cclxuXHRcdGNvbnN0IHByb2dyYW1HUFUgPSBnbC5jcmVhdGVQcm9ncmFtKCk7XHJcblxyXG5cdFx0Y29uc3QgZnJhZ21lbnRTaGFkZXIgPSB0aGlzLmdldCggZnJhZ21lbnRQcm9ncmFtICkuc2hhZGVyR1BVO1xyXG5cdFx0Y29uc3QgdmVydGV4U2hhZGVyID0gdGhpcy5nZXQoIHZlcnRleFByb2dyYW0gKS5zaGFkZXJHUFU7XHJcblxyXG5cdFx0Z2wuYXR0YWNoU2hhZGVyKCBwcm9ncmFtR1BVLCBmcmFnbWVudFNoYWRlciApO1xyXG5cdFx0Z2wuYXR0YWNoU2hhZGVyKCBwcm9ncmFtR1BVLCB2ZXJ0ZXhTaGFkZXIgKTtcclxuXHRcdGdsLmxpbmtQcm9ncmFtKCBwcm9ncmFtR1BVICk7XHJcblxyXG5cdFx0dGhpcy5zZXQoIHBpcGVsaW5lLCB7XHJcblx0XHRcdHByb2dyYW1HUFUsXHJcblx0XHRcdGZyYWdtZW50U2hhZGVyLFxyXG5cdFx0XHR2ZXJ0ZXhTaGFkZXJcclxuXHRcdH0gKTtcclxuXHJcblx0XHRpZiAoIHByb21pc2VzICE9PSBudWxsICYmIHRoaXMucGFyYWxsZWwgKSB7XHJcblxyXG5cdFx0XHRjb25zdCBwID0gbmV3IFByb21pc2UoICggcmVzb2x2ZSAvKiwgcmVqZWN0Ki8gKSA9PiB7XHJcblxyXG5cdFx0XHRcdGNvbnN0IHBhcmFsbGVsID0gdGhpcy5wYXJhbGxlbDtcclxuXHRcdFx0XHRjb25zdCBjaGVja1N0YXR1cyA9ICgpID0+IHtcclxuXHJcblx0XHRcdFx0XHRpZiAoIGdsLmdldFByb2dyYW1QYXJhbWV0ZXIoIHByb2dyYW1HUFUsIHBhcmFsbGVsLkNPTVBMRVRJT05fU1RBVFVTX0tIUiApICkge1xyXG5cclxuXHRcdFx0XHRcdFx0dGhpcy5fY29tcGxldGVDb21waWxlKCByZW5kZXJPYmplY3QsIHBpcGVsaW5lICk7XHJcblx0XHRcdFx0XHRcdHJlc29sdmUoKTtcclxuXHJcblx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdFx0cmVxdWVzdEFuaW1hdGlvbkZyYW1lKCBjaGVja1N0YXR1cyApO1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0fTtcclxuXHJcblx0XHRcdFx0Y2hlY2tTdGF0dXMoKTtcclxuXHJcblx0XHRcdH0gKTtcclxuXHJcblx0XHRcdHByb21pc2VzLnB1c2goIHAgKTtcclxuXHJcblx0XHRcdHJldHVybjtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fY29tcGxldGVDb21waWxlKCByZW5kZXJPYmplY3QsIHBpcGVsaW5lICk7XHJcblxyXG5cdH1cclxuXHJcblx0X2hhbmRsZVNvdXJjZSggc3RyaW5nLCBlcnJvckxpbmUgKSB7XHJcblxyXG5cdFx0Y29uc3QgbGluZXMgPSBzdHJpbmcuc3BsaXQoICdcXG4nICk7XHJcblx0XHRjb25zdCBsaW5lczIgPSBbXTtcclxuXHJcblx0XHRjb25zdCBmcm9tID0gTWF0aC5tYXgoIGVycm9yTGluZSAtIDYsIDAgKTtcclxuXHRcdGNvbnN0IHRvID0gTWF0aC5taW4oIGVycm9yTGluZSArIDYsIGxpbmVzLmxlbmd0aCApO1xyXG5cclxuXHRcdGZvciAoIGxldCBpID0gZnJvbTsgaSA8IHRvOyBpICsrICkge1xyXG5cclxuXHRcdFx0Y29uc3QgbGluZSA9IGkgKyAxO1xyXG5cdFx0XHRsaW5lczIucHVzaCggYCR7bGluZSA9PT0gZXJyb3JMaW5lID8gJz4nIDogJyAnfSAke2xpbmV9OiAke2xpbmVzWyBpIF19YCApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gbGluZXMyLmpvaW4oICdcXG4nICk7XHJcblxyXG5cdH1cclxuXHJcblx0X2dldFNoYWRlckVycm9ycyggZ2wsIHNoYWRlciwgdHlwZSApIHtcclxuXHJcblx0XHRjb25zdCBzdGF0dXMgPSBnbC5nZXRTaGFkZXJQYXJhbWV0ZXIoIHNoYWRlciwgZ2wuQ09NUElMRV9TVEFUVVMgKTtcclxuXHRcdGNvbnN0IGVycm9ycyA9IGdsLmdldFNoYWRlckluZm9Mb2coIHNoYWRlciApLnRyaW0oKTtcclxuXHJcblx0XHRpZiAoIHN0YXR1cyAmJiBlcnJvcnMgPT09ICcnICkgcmV0dXJuICcnO1xyXG5cclxuXHRcdGNvbnN0IGVycm9yTWF0Y2hlcyA9IC9FUlJPUjogMDooXFxkKykvLmV4ZWMoIGVycm9ycyApO1xyXG5cdFx0aWYgKCBlcnJvck1hdGNoZXMgKSB7XHJcblxyXG5cdFx0XHRjb25zdCBlcnJvckxpbmUgPSBwYXJzZUludCggZXJyb3JNYXRjaGVzWyAxIF0gKTtcclxuXHRcdFx0cmV0dXJuIHR5cGUudG9VcHBlckNhc2UoKSArICdcXG5cXG4nICsgZXJyb3JzICsgJ1xcblxcbicgKyB0aGlzLl9oYW5kbGVTb3VyY2UoIGdsLmdldFNoYWRlclNvdXJjZSggc2hhZGVyICksIGVycm9yTGluZSApO1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gZXJyb3JzO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHRfbG9nUHJvZ3JhbUVycm9yKCBwcm9ncmFtR1BVLCBnbEZyYWdtZW50U2hhZGVyLCBnbFZlcnRleFNoYWRlciApIHtcclxuXHJcblx0XHRpZiAoIHRoaXMucmVuZGVyZXIuZGVidWcuY2hlY2tTaGFkZXJFcnJvcnMgKSB7XHJcblxyXG5cdFx0XHRjb25zdCBnbCA9IHRoaXMuZ2w7XHJcblxyXG5cdFx0XHRjb25zdCBwcm9ncmFtTG9nID0gZ2wuZ2V0UHJvZ3JhbUluZm9Mb2coIHByb2dyYW1HUFUgKS50cmltKCk7XHJcblxyXG5cdFx0XHRpZiAoIGdsLmdldFByb2dyYW1QYXJhbWV0ZXIoIHByb2dyYW1HUFUsIGdsLkxJTktfU1RBVFVTICkgPT09IGZhbHNlICkge1xyXG5cclxuXHJcblx0XHRcdFx0aWYgKCB0eXBlb2YgdGhpcy5yZW5kZXJlci5kZWJ1Zy5vblNoYWRlckVycm9yID09PSAnZnVuY3Rpb24nICkge1xyXG5cclxuXHRcdFx0XHRcdHRoaXMucmVuZGVyZXIuZGVidWcub25TaGFkZXJFcnJvciggZ2wsIHByb2dyYW1HUFUsIGdsVmVydGV4U2hhZGVyLCBnbEZyYWdtZW50U2hhZGVyICk7XHJcblxyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0Ly8gZGVmYXVsdCBlcnJvciByZXBvcnRpbmdcclxuXHJcblx0XHRcdFx0XHRjb25zdCB2ZXJ0ZXhFcnJvcnMgPSB0aGlzLl9nZXRTaGFkZXJFcnJvcnMoIGdsLCBnbFZlcnRleFNoYWRlciwgJ3ZlcnRleCcgKTtcclxuXHRcdFx0XHRcdGNvbnN0IGZyYWdtZW50RXJyb3JzID0gdGhpcy5fZ2V0U2hhZGVyRXJyb3JzKCBnbCwgZ2xGcmFnbWVudFNoYWRlciwgJ2ZyYWdtZW50JyApO1xyXG5cclxuXHRcdFx0XHRcdGNvbnNvbGUuZXJyb3IoXHJcblx0XHRcdFx0XHRcdCdUSFJFRS5XZWJHTFByb2dyYW06IFNoYWRlciBFcnJvciAnICsgZ2wuZ2V0RXJyb3IoKSArICcgLSAnICtcclxuXHRcdFx0XHRcdFx0J1ZBTElEQVRFX1NUQVRVUyAnICsgZ2wuZ2V0UHJvZ3JhbVBhcmFtZXRlciggcHJvZ3JhbUdQVSwgZ2wuVkFMSURBVEVfU1RBVFVTICkgKyAnXFxuXFxuJyArXHJcblx0XHRcdFx0XHRcdCdQcm9ncmFtIEluZm8gTG9nOiAnICsgcHJvZ3JhbUxvZyArICdcXG4nICtcclxuXHRcdFx0XHRcdFx0dmVydGV4RXJyb3JzICsgJ1xcbicgK1xyXG5cdFx0XHRcdFx0XHRmcmFnbWVudEVycm9yc1xyXG5cdFx0XHRcdFx0KTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fSBlbHNlIGlmICggcHJvZ3JhbUxvZyAhPT0gJycgKSB7XHJcblxyXG5cdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUHJvZ3JhbTogUHJvZ3JhbSBJbmZvIExvZzonLCBwcm9ncmFtTG9nICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdF9jb21wbGV0ZUNvbXBpbGUoIHJlbmRlck9iamVjdCwgcGlwZWxpbmUgKSB7XHJcblxyXG5cdFx0Y29uc3QgeyBzdGF0ZSwgZ2wgfSA9IHRoaXM7XHJcblx0XHRjb25zdCBwaXBlbGluZURhdGEgPSB0aGlzLmdldCggcGlwZWxpbmUgKTtcclxuXHRcdGNvbnN0IHsgcHJvZ3JhbUdQVSwgZnJhZ21lbnRTaGFkZXIsIHZlcnRleFNoYWRlciB9ID0gcGlwZWxpbmVEYXRhO1xyXG5cclxuXHRcdGlmICggZ2wuZ2V0UHJvZ3JhbVBhcmFtZXRlciggcHJvZ3JhbUdQVSwgZ2wuTElOS19TVEFUVVMgKSA9PT0gZmFsc2UgKSB7XHJcblxyXG5cdFx0XHR0aGlzLl9sb2dQcm9ncmFtRXJyb3IoIHByb2dyYW1HUFUsIGZyYWdtZW50U2hhZGVyLCB2ZXJ0ZXhTaGFkZXIgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0c3RhdGUudXNlUHJvZ3JhbSggcHJvZ3JhbUdQVSApO1xyXG5cclxuXHRcdC8vIEJpbmRpbmdzXHJcblxyXG5cdFx0Y29uc3QgYmluZGluZ3MgPSByZW5kZXJPYmplY3QuZ2V0QmluZGluZ3MoKTtcclxuXHJcblx0XHR0aGlzLl9zZXR1cEJpbmRpbmdzKCBiaW5kaW5ncywgcHJvZ3JhbUdQVSApO1xyXG5cclxuXHRcdC8vXHJcblxyXG5cdFx0dGhpcy5zZXQoIHBpcGVsaW5lLCB7XHJcblx0XHRcdHByb2dyYW1HUFVcclxuXHRcdH0gKTtcclxuXHJcblx0fVxyXG5cclxuXHRjcmVhdGVDb21wdXRlUGlwZWxpbmUoIGNvbXB1dGVQaXBlbGluZSwgYmluZGluZ3MgKSB7XHJcblxyXG5cdFx0Y29uc3QgeyBzdGF0ZSwgZ2wgfSA9IHRoaXM7XHJcblxyXG5cdFx0Ly8gUHJvZ3JhbVxyXG5cclxuXHRcdGNvbnN0IGZyYWdtZW50UHJvZ3JhbSA9IHtcclxuXHRcdFx0c3RhZ2U6ICdmcmFnbWVudCcsXHJcblx0XHRcdGNvZGU6ICcjdmVyc2lvbiAzMDAgZXNcXG5wcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxudm9pZCBtYWluKCkge30nXHJcblx0XHR9O1xyXG5cclxuXHRcdHRoaXMuY3JlYXRlUHJvZ3JhbSggZnJhZ21lbnRQcm9ncmFtICk7XHJcblxyXG5cdFx0Y29uc3QgeyBjb21wdXRlUHJvZ3JhbSB9ID0gY29tcHV0ZVBpcGVsaW5lO1xyXG5cclxuXHRcdGNvbnN0IHByb2dyYW1HUFUgPSBnbC5jcmVhdGVQcm9ncmFtKCk7XHJcblxyXG5cdFx0Y29uc3QgZnJhZ21lbnRTaGFkZXIgPSB0aGlzLmdldCggZnJhZ21lbnRQcm9ncmFtICkuc2hhZGVyR1BVO1xyXG5cdFx0Y29uc3QgdmVydGV4U2hhZGVyID0gdGhpcy5nZXQoIGNvbXB1dGVQcm9ncmFtICkuc2hhZGVyR1BVO1xyXG5cclxuXHRcdGNvbnN0IHRyYW5zZm9ybXMgPSBjb21wdXRlUHJvZ3JhbS50cmFuc2Zvcm1zO1xyXG5cclxuXHRcdGNvbnN0IHRyYW5zZm9ybVZhcnlpbmdOYW1lcyA9IFtdO1xyXG5cdFx0Y29uc3QgdHJhbnNmb3JtQXR0cmlidXRlTm9kZXMgPSBbXTtcclxuXHJcblx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCB0cmFuc2Zvcm1zLmxlbmd0aDsgaSArKyApIHtcclxuXHJcblx0XHRcdGNvbnN0IHRyYW5zZm9ybSA9IHRyYW5zZm9ybXNbIGkgXTtcclxuXHJcblx0XHRcdHRyYW5zZm9ybVZhcnlpbmdOYW1lcy5wdXNoKCB0cmFuc2Zvcm0udmFyeWluZ05hbWUgKTtcclxuXHRcdFx0dHJhbnNmb3JtQXR0cmlidXRlTm9kZXMucHVzaCggdHJhbnNmb3JtLmF0dHJpYnV0ZU5vZGUgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Z2wuYXR0YWNoU2hhZGVyKCBwcm9ncmFtR1BVLCBmcmFnbWVudFNoYWRlciApO1xyXG5cdFx0Z2wuYXR0YWNoU2hhZGVyKCBwcm9ncmFtR1BVLCB2ZXJ0ZXhTaGFkZXIgKTtcclxuXHJcblx0XHRnbC50cmFuc2Zvcm1GZWVkYmFja1ZhcnlpbmdzKFxyXG5cdFx0XHRwcm9ncmFtR1BVLFxyXG5cdFx0XHR0cmFuc2Zvcm1WYXJ5aW5nTmFtZXMsXHJcblx0XHRcdGdsLlNFUEFSQVRFX0FUVFJJQlNcclxuXHRcdCk7XHJcblxyXG5cdFx0Z2wubGlua1Byb2dyYW0oIHByb2dyYW1HUFUgKTtcclxuXHJcblx0XHRpZiAoIGdsLmdldFByb2dyYW1QYXJhbWV0ZXIoIHByb2dyYW1HUFUsIGdsLkxJTktfU1RBVFVTICkgPT09IGZhbHNlICkge1xyXG5cclxuXHRcdFx0dGhpcy5fbG9nUHJvZ3JhbUVycm9yKCBwcm9ncmFtR1BVLCBmcmFnbWVudFNoYWRlciwgdmVydGV4U2hhZGVyICk7XHJcblxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRzdGF0ZS51c2VQcm9ncmFtKCBwcm9ncmFtR1BVICk7XHJcblxyXG5cdFx0Ly8gQmluZGluZ3NcclxuXHJcblx0XHR0aGlzLl9zZXR1cEJpbmRpbmdzKCBiaW5kaW5ncywgcHJvZ3JhbUdQVSApO1xyXG5cclxuXHRcdGNvbnN0IGF0dHJpYnV0ZU5vZGVzID0gY29tcHV0ZVByb2dyYW0uYXR0cmlidXRlcztcclxuXHRcdGNvbnN0IGF0dHJpYnV0ZXMgPSBbXTtcclxuXHRcdGNvbnN0IHRyYW5zZm9ybUJ1ZmZlcnMgPSBbXTtcclxuXHJcblx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCBhdHRyaWJ1dGVOb2Rlcy5sZW5ndGg7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRjb25zdCBhdHRyaWJ1dGUgPSBhdHRyaWJ1dGVOb2Rlc1sgaSBdLm5vZGUuYXR0cmlidXRlO1xyXG5cclxuXHRcdFx0YXR0cmlidXRlcy5wdXNoKCBhdHRyaWJ1dGUgKTtcclxuXHJcblx0XHRcdGlmICggISB0aGlzLmhhcyggYXR0cmlidXRlICkgKSB0aGlzLmF0dHJpYnV0ZVV0aWxzLmNyZWF0ZUF0dHJpYnV0ZSggYXR0cmlidXRlLCBnbC5BUlJBWV9CVUZGRVIgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgdHJhbnNmb3JtQXR0cmlidXRlTm9kZXMubGVuZ3RoOyBpICsrICkge1xyXG5cclxuXHRcdFx0Y29uc3QgYXR0cmlidXRlID0gdHJhbnNmb3JtQXR0cmlidXRlTm9kZXNbIGkgXS5hdHRyaWJ1dGU7XHJcblxyXG5cdFx0XHRpZiAoICEgdGhpcy5oYXMoIGF0dHJpYnV0ZSApICkgdGhpcy5hdHRyaWJ1dGVVdGlscy5jcmVhdGVBdHRyaWJ1dGUoIGF0dHJpYnV0ZSwgZ2wuQVJSQVlfQlVGRkVSICk7XHJcblxyXG5cdFx0XHRjb25zdCBhdHRyaWJ1dGVEYXRhID0gdGhpcy5nZXQoIGF0dHJpYnV0ZSApO1xyXG5cclxuXHRcdFx0dHJhbnNmb3JtQnVmZmVycy5wdXNoKCBhdHRyaWJ1dGVEYXRhICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vXHJcblxyXG5cdFx0dGhpcy5zZXQoIGNvbXB1dGVQaXBlbGluZSwge1xyXG5cdFx0XHRwcm9ncmFtR1BVLFxyXG5cdFx0XHR0cmFuc2Zvcm1CdWZmZXJzLFxyXG5cdFx0XHRhdHRyaWJ1dGVzXHJcblx0XHR9ICk7XHJcblxyXG5cdH1cclxuXHJcblx0Y3JlYXRlQmluZGluZ3MoIGJpbmRHcm91cCwgYmluZGluZ3MgKSB7XHJcblxyXG5cdFx0aWYgKCB0aGlzLl9rbm93bkJpbmRpbmdzLmhhcyggYmluZGluZ3MgKSA9PT0gZmFsc2UgKSB7XHJcblxyXG5cdFx0XHR0aGlzLl9rbm93bkJpbmRpbmdzLmFkZCggYmluZGluZ3MgKTtcclxuXHJcblx0XHRcdGxldCB1bmlmb3JtQnVmZmVycyA9IDA7XHJcblx0XHRcdGxldCB0ZXh0dXJlcyA9IDA7XHJcblxyXG5cdFx0XHRmb3IgKCBjb25zdCBiaW5kR3JvdXAgb2YgYmluZGluZ3MgKSB7XHJcblxyXG5cdFx0XHRcdHRoaXMuc2V0KCBiaW5kR3JvdXAsIHtcclxuXHRcdFx0XHRcdHRleHR1cmVzOiB0ZXh0dXJlcyxcclxuXHRcdFx0XHRcdHVuaWZvcm1CdWZmZXJzOiB1bmlmb3JtQnVmZmVyc1xyXG5cdFx0XHRcdH0gKTtcclxuXHJcblx0XHRcdFx0Zm9yICggY29uc3QgYmluZGluZyBvZiBiaW5kR3JvdXAuYmluZGluZ3MgKSB7XHJcblxyXG5cdFx0XHRcdFx0aWYgKCBiaW5kaW5nLmlzVW5pZm9ybUJ1ZmZlciApIHVuaWZvcm1CdWZmZXJzICsrO1xyXG5cdFx0XHRcdFx0aWYgKCBiaW5kaW5nLmlzU2FtcGxlZFRleHR1cmUgKSB0ZXh0dXJlcyArKztcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLnVwZGF0ZUJpbmRpbmdzKCBiaW5kR3JvdXAsIGJpbmRpbmdzICk7XHJcblxyXG5cdH1cclxuXHJcblx0dXBkYXRlQmluZGluZ3MoIGJpbmRHcm91cCAvKiwgYmluZGluZ3MqLyApIHtcclxuXHJcblx0XHRjb25zdCB7IGdsIH0gPSB0aGlzO1xyXG5cclxuXHRcdGNvbnN0IGJpbmRHcm91cERhdGEgPSB0aGlzLmdldCggYmluZEdyb3VwICk7XHJcblxyXG5cdFx0bGV0IGkgPSBiaW5kR3JvdXBEYXRhLnVuaWZvcm1CdWZmZXJzO1xyXG5cdFx0bGV0IHQgPSBiaW5kR3JvdXBEYXRhLnRleHR1cmVzO1xyXG5cclxuXHRcdGZvciAoIGNvbnN0IGJpbmRpbmcgb2YgYmluZEdyb3VwLmJpbmRpbmdzICkge1xyXG5cclxuXHRcdFx0aWYgKCBiaW5kaW5nLmlzVW5pZm9ybXNHcm91cCB8fCBiaW5kaW5nLmlzVW5pZm9ybUJ1ZmZlciApIHtcclxuXHJcblx0XHRcdFx0Y29uc3QgZGF0YSA9IGJpbmRpbmcuYnVmZmVyO1xyXG5cdFx0XHRcdGNvbnN0IGJ1ZmZlckdQVSA9IGdsLmNyZWF0ZUJ1ZmZlcigpO1xyXG5cclxuXHRcdFx0XHRnbC5iaW5kQnVmZmVyKCBnbC5VTklGT1JNX0JVRkZFUiwgYnVmZmVyR1BVICk7XHJcblx0XHRcdFx0Z2wuYnVmZmVyRGF0YSggZ2wuVU5JRk9STV9CVUZGRVIsIGRhdGEsIGdsLkRZTkFNSUNfRFJBVyApO1xyXG5cclxuXHRcdFx0XHR0aGlzLnNldCggYmluZGluZywge1xyXG5cdFx0XHRcdFx0aW5kZXg6IGkgKyssXHJcblx0XHRcdFx0XHRidWZmZXJHUFVcclxuXHRcdFx0XHR9ICk7XHJcblxyXG5cdFx0XHR9IGVsc2UgaWYgKCBiaW5kaW5nLmlzU2FtcGxlZFRleHR1cmUgKSB7XHJcblxyXG5cdFx0XHRcdGNvbnN0IHsgdGV4dHVyZUdQVSwgZ2xUZXh0dXJlVHlwZSB9ID0gdGhpcy5nZXQoIGJpbmRpbmcudGV4dHVyZSApO1xyXG5cclxuXHRcdFx0XHR0aGlzLnNldCggYmluZGluZywge1xyXG5cdFx0XHRcdFx0aW5kZXg6IHQgKyssXHJcblx0XHRcdFx0XHR0ZXh0dXJlR1BVLFxyXG5cdFx0XHRcdFx0Z2xUZXh0dXJlVHlwZVxyXG5cdFx0XHRcdH0gKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0dXBkYXRlQmluZGluZyggYmluZGluZyApIHtcclxuXHJcblx0XHRjb25zdCBnbCA9IHRoaXMuZ2w7XHJcblxyXG5cdFx0aWYgKCBiaW5kaW5nLmlzVW5pZm9ybXNHcm91cCB8fCBiaW5kaW5nLmlzVW5pZm9ybUJ1ZmZlciApIHtcclxuXHJcblx0XHRcdGNvbnN0IGJpbmRpbmdEYXRhID0gdGhpcy5nZXQoIGJpbmRpbmcgKTtcclxuXHRcdFx0Y29uc3QgYnVmZmVyR1BVID0gYmluZGluZ0RhdGEuYnVmZmVyR1BVO1xyXG5cdFx0XHRjb25zdCBkYXRhID0gYmluZGluZy5idWZmZXI7XHJcblxyXG5cdFx0XHRnbC5iaW5kQnVmZmVyKCBnbC5VTklGT1JNX0JVRkZFUiwgYnVmZmVyR1BVICk7XHJcblx0XHRcdGdsLmJ1ZmZlckRhdGEoIGdsLlVOSUZPUk1fQlVGRkVSLCBkYXRhLCBnbC5EWU5BTUlDX0RSQVcgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0Ly8gYXR0cmlidXRlc1xyXG5cclxuXHRjcmVhdGVJbmRleEF0dHJpYnV0ZSggYXR0cmlidXRlICkge1xyXG5cclxuXHRcdGNvbnN0IGdsID0gdGhpcy5nbDtcclxuXHJcblx0XHR0aGlzLmF0dHJpYnV0ZVV0aWxzLmNyZWF0ZUF0dHJpYnV0ZSggYXR0cmlidXRlLCBnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiApO1xyXG5cclxuXHR9XHJcblxyXG5cdGNyZWF0ZUF0dHJpYnV0ZSggYXR0cmlidXRlICkge1xyXG5cclxuXHRcdGlmICggdGhpcy5oYXMoIGF0dHJpYnV0ZSApICkgcmV0dXJuO1xyXG5cclxuXHRcdGNvbnN0IGdsID0gdGhpcy5nbDtcclxuXHJcblx0XHR0aGlzLmF0dHJpYnV0ZVV0aWxzLmNyZWF0ZUF0dHJpYnV0ZSggYXR0cmlidXRlLCBnbC5BUlJBWV9CVUZGRVIgKTtcclxuXHJcblx0fVxyXG5cclxuXHRjcmVhdGVTdG9yYWdlQXR0cmlidXRlKCBhdHRyaWJ1dGUgKSB7XHJcblxyXG5cdFx0aWYgKCB0aGlzLmhhcyggYXR0cmlidXRlICkgKSByZXR1cm47XHJcblxyXG5cdFx0Y29uc3QgZ2wgPSB0aGlzLmdsO1xyXG5cclxuXHRcdHRoaXMuYXR0cmlidXRlVXRpbHMuY3JlYXRlQXR0cmlidXRlKCBhdHRyaWJ1dGUsIGdsLkFSUkFZX0JVRkZFUiApO1xyXG5cclxuXHR9XHJcblxyXG5cdHVwZGF0ZUF0dHJpYnV0ZSggYXR0cmlidXRlICkge1xyXG5cclxuXHRcdHRoaXMuYXR0cmlidXRlVXRpbHMudXBkYXRlQXR0cmlidXRlKCBhdHRyaWJ1dGUgKTtcclxuXHJcblx0fVxyXG5cclxuXHRkZXN0cm95QXR0cmlidXRlKCBhdHRyaWJ1dGUgKSB7XHJcblxyXG5cdFx0dGhpcy5hdHRyaWJ1dGVVdGlscy5kZXN0cm95QXR0cmlidXRlKCBhdHRyaWJ1dGUgKTtcclxuXHJcblx0fVxyXG5cclxuXHR1cGRhdGVTaXplKCkge1xyXG5cclxuXHRcdC8vY29uc29sZS53YXJuKCAnQWJzdHJhY3QgY2xhc3MuJyApO1xyXG5cclxuXHR9XHJcblxyXG5cdGhhc0ZlYXR1cmUoIG5hbWUgKSB7XHJcblxyXG5cdFx0Y29uc3Qga2V5c01hdGNoaW5nID0gT2JqZWN0LmtleXMoIEdMRmVhdHVyZU5hbWUgKS5maWx0ZXIoIGtleSA9PiBHTEZlYXR1cmVOYW1lWyBrZXkgXSA9PT0gbmFtZSApO1xyXG5cclxuXHRcdGNvbnN0IGV4dGVuc2lvbnMgPSB0aGlzLmV4dGVuc2lvbnM7XHJcblxyXG5cdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwga2V5c01hdGNoaW5nLmxlbmd0aDsgaSArKyApIHtcclxuXHJcblx0XHRcdGlmICggZXh0ZW5zaW9ucy5oYXMoIGtleXNNYXRjaGluZ1sgaSBdICkgKSByZXR1cm4gdHJ1ZTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGZhbHNlO1xyXG5cclxuXHR9XHJcblxyXG5cdGdldE1heEFuaXNvdHJvcHkoKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuY2FwYWJpbGl0aWVzLmdldE1heEFuaXNvdHJvcHkoKTtcclxuXHJcblx0fVxyXG5cclxuXHRjb3B5VGV4dHVyZVRvVGV4dHVyZSggc3JjVGV4dHVyZSwgZHN0VGV4dHVyZSwgc3JjUmVnaW9uLCBkc3RQb3NpdGlvbiwgbGV2ZWwgKSB7XHJcblxyXG5cdFx0dGhpcy50ZXh0dXJlVXRpbHMuY29weVRleHR1cmVUb1RleHR1cmUoIHNyY1RleHR1cmUsIGRzdFRleHR1cmUsIHNyY1JlZ2lvbiwgZHN0UG9zaXRpb24sIGxldmVsICk7XHJcblxyXG5cdH1cclxuXHJcblx0Y29weUZyYW1lYnVmZmVyVG9UZXh0dXJlKCB0ZXh0dXJlLCByZW5kZXJDb250ZXh0LCByZWN0YW5nbGUgKSB7XHJcblxyXG5cdFx0dGhpcy50ZXh0dXJlVXRpbHMuY29weUZyYW1lYnVmZmVyVG9UZXh0dXJlKCB0ZXh0dXJlLCByZW5kZXJDb250ZXh0LCByZWN0YW5nbGUgKTtcclxuXHJcblx0fVxyXG5cclxuXHRfc2V0RnJhbWVidWZmZXIoIGRlc2NyaXB0b3IgKSB7XHJcblxyXG5cdFx0Y29uc3QgeyBnbCwgc3RhdGUgfSA9IHRoaXM7XHJcblxyXG5cdFx0bGV0IGN1cnJlbnRGcmFtZUJ1ZmZlciA9IG51bGw7XHJcblxyXG5cdFx0aWYgKCBkZXNjcmlwdG9yLnRleHR1cmVzICE9PSBudWxsICkge1xyXG5cclxuXHRcdFx0Y29uc3QgcmVuZGVyVGFyZ2V0ID0gZGVzY3JpcHRvci5yZW5kZXJUYXJnZXQ7XHJcblx0XHRcdGNvbnN0IHJlbmRlclRhcmdldENvbnRleHREYXRhID0gdGhpcy5nZXQoIHJlbmRlclRhcmdldCApO1xyXG5cdFx0XHRjb25zdCB7IHNhbXBsZXMsIGRlcHRoQnVmZmVyLCBzdGVuY2lsQnVmZmVyIH0gPSByZW5kZXJUYXJnZXQ7XHJcblxyXG5cdFx0XHRjb25zdCBpc0N1YmUgPSByZW5kZXJUYXJnZXQuaXNXZWJHTEN1YmVSZW5kZXJUYXJnZXQgPT09IHRydWU7XHJcblxyXG5cdFx0XHRsZXQgbXNhYUZiID0gcmVuZGVyVGFyZ2V0Q29udGV4dERhdGEubXNhYUZyYW1lQnVmZmVyO1xyXG5cdFx0XHRsZXQgZGVwdGhSZW5kZXJidWZmZXIgPSByZW5kZXJUYXJnZXRDb250ZXh0RGF0YS5kZXB0aFJlbmRlcmJ1ZmZlcjtcclxuXHJcblx0XHRcdGNvbnN0IGNhY2hlS2V5ID0gZ2V0Q2FjaGVLZXkoIGRlc2NyaXB0b3IgKTtcclxuXHJcblx0XHRcdGxldCBmYjtcclxuXHJcblx0XHRcdGlmICggaXNDdWJlICkge1xyXG5cclxuXHRcdFx0XHRyZW5kZXJUYXJnZXRDb250ZXh0RGF0YS5jdWJlRnJhbWVidWZmZXJzIHx8ICggcmVuZGVyVGFyZ2V0Q29udGV4dERhdGEuY3ViZUZyYW1lYnVmZmVycyA9IHt9ICk7XHJcblxyXG5cdFx0XHRcdGZiID0gcmVuZGVyVGFyZ2V0Q29udGV4dERhdGEuY3ViZUZyYW1lYnVmZmVyc1sgY2FjaGVLZXkgXTtcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdHJlbmRlclRhcmdldENvbnRleHREYXRhLmZyYW1lYnVmZmVycyB8fCAoIHJlbmRlclRhcmdldENvbnRleHREYXRhLmZyYW1lYnVmZmVycyA9IHt9ICk7XHJcblxyXG5cdFx0XHRcdGZiID0gcmVuZGVyVGFyZ2V0Q29udGV4dERhdGEuZnJhbWVidWZmZXJzWyBjYWNoZUtleSBdO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKCBmYiA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRmYiA9IGdsLmNyZWF0ZUZyYW1lYnVmZmVyKCk7XHJcblxyXG5cdFx0XHRcdHN0YXRlLmJpbmRGcmFtZWJ1ZmZlciggZ2wuRlJBTUVCVUZGRVIsIGZiICk7XHJcblxyXG5cdFx0XHRcdGNvbnN0IHRleHR1cmVzID0gZGVzY3JpcHRvci50ZXh0dXJlcztcclxuXHJcblx0XHRcdFx0aWYgKCBpc0N1YmUgKSB7XHJcblxyXG5cdFx0XHRcdFx0cmVuZGVyVGFyZ2V0Q29udGV4dERhdGEuY3ViZUZyYW1lYnVmZmVyc1sgY2FjaGVLZXkgXSA9IGZiO1xyXG5cclxuXHRcdFx0XHRcdGNvbnN0IHsgdGV4dHVyZUdQVSB9ID0gdGhpcy5nZXQoIHRleHR1cmVzWyAwIF0gKTtcclxuXHJcblx0XHRcdFx0XHRjb25zdCBjdWJlRmFjZSA9IHRoaXMucmVuZGVyZXIuX2FjdGl2ZUN1YmVGYWNlO1xyXG5cclxuXHRcdFx0XHRcdGdsLmZyYW1lYnVmZmVyVGV4dHVyZTJEKCBnbC5GUkFNRUJVRkZFUiwgZ2wuQ09MT1JfQVRUQUNITUVOVDAsIGdsLlRFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWCArIGN1YmVGYWNlLCB0ZXh0dXJlR1BVLCAwICk7XHJcblxyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0cmVuZGVyVGFyZ2V0Q29udGV4dERhdGEuZnJhbWVidWZmZXJzWyBjYWNoZUtleSBdID0gZmI7XHJcblxyXG5cdFx0XHRcdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgdGV4dHVyZXMubGVuZ3RoOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHRcdFx0Y29uc3QgdGV4dHVyZSA9IHRleHR1cmVzWyBpIF07XHJcblx0XHRcdFx0XHRcdGNvbnN0IHRleHR1cmVEYXRhID0gdGhpcy5nZXQoIHRleHR1cmUgKTtcclxuXHRcdFx0XHRcdFx0dGV4dHVyZURhdGEucmVuZGVyVGFyZ2V0ID0gZGVzY3JpcHRvci5yZW5kZXJUYXJnZXQ7XHJcblx0XHRcdFx0XHRcdHRleHR1cmVEYXRhLmNhY2hlS2V5ID0gY2FjaGVLZXk7IC8vIHJlcXVpcmVkIGZvciBjb3B5VGV4dHVyZVRvVGV4dHVyZSgpXHJcblxyXG5cdFx0XHRcdFx0XHRjb25zdCBhdHRhY2htZW50ID0gZ2wuQ09MT1JfQVRUQUNITUVOVDAgKyBpO1xyXG5cclxuXHRcdFx0XHRcdFx0Z2wuZnJhbWVidWZmZXJUZXh0dXJlMkQoIGdsLkZSQU1FQlVGRkVSLCBhdHRhY2htZW50LCBnbC5URVhUVVJFXzJELCB0ZXh0dXJlRGF0YS50ZXh0dXJlR1BVLCAwICk7XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdHN0YXRlLmRyYXdCdWZmZXJzKCBkZXNjcmlwdG9yLCBmYiApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGlmICggZGVzY3JpcHRvci5kZXB0aFRleHR1cmUgIT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHRcdFx0Y29uc3QgdGV4dHVyZURhdGEgPSB0aGlzLmdldCggZGVzY3JpcHRvci5kZXB0aFRleHR1cmUgKTtcclxuXHRcdFx0XHRcdGNvbnN0IGRlcHRoU3R5bGUgPSBzdGVuY2lsQnVmZmVyID8gZ2wuREVQVEhfU1RFTkNJTF9BVFRBQ0hNRU5UIDogZ2wuREVQVEhfQVRUQUNITUVOVDtcclxuXHRcdFx0XHRcdHRleHR1cmVEYXRhLnJlbmRlclRhcmdldCA9IGRlc2NyaXB0b3IucmVuZGVyVGFyZ2V0O1xyXG5cdFx0XHRcdFx0dGV4dHVyZURhdGEuY2FjaGVLZXkgPSBjYWNoZUtleTsgLy8gcmVxdWlyZWQgZm9yIGNvcHlUZXh0dXJlVG9UZXh0dXJlKClcclxuXHJcblx0XHRcdFx0XHRnbC5mcmFtZWJ1ZmZlclRleHR1cmUyRCggZ2wuRlJBTUVCVUZGRVIsIGRlcHRoU3R5bGUsIGdsLlRFWFRVUkVfMkQsIHRleHR1cmVEYXRhLnRleHR1cmVHUFUsIDAgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKCBzYW1wbGVzID4gMCApIHtcclxuXHJcblx0XHRcdFx0aWYgKCBtc2FhRmIgPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0XHRjb25zdCBpbnZhbGlkYXRpb25BcnJheSA9IFtdO1xyXG5cclxuXHRcdFx0XHRcdG1zYWFGYiA9IGdsLmNyZWF0ZUZyYW1lYnVmZmVyKCk7XHJcblxyXG5cdFx0XHRcdFx0c3RhdGUuYmluZEZyYW1lYnVmZmVyKCBnbC5GUkFNRUJVRkZFUiwgbXNhYUZiICk7XHJcblxyXG5cdFx0XHRcdFx0Y29uc3QgbXNhYVJlbmRlcmJ1ZmZlcnMgPSBbXTtcclxuXHJcblx0XHRcdFx0XHRjb25zdCB0ZXh0dXJlcyA9IGRlc2NyaXB0b3IudGV4dHVyZXM7XHJcblxyXG5cdFx0XHRcdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgdGV4dHVyZXMubGVuZ3RoOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHRcdFx0bXNhYVJlbmRlcmJ1ZmZlcnNbIGkgXSA9IGdsLmNyZWF0ZVJlbmRlcmJ1ZmZlcigpO1xyXG5cclxuXHRcdFx0XHRcdFx0Z2wuYmluZFJlbmRlcmJ1ZmZlciggZ2wuUkVOREVSQlVGRkVSLCBtc2FhUmVuZGVyYnVmZmVyc1sgaSBdICk7XHJcblxyXG5cdFx0XHRcdFx0XHRpbnZhbGlkYXRpb25BcnJheS5wdXNoKCBnbC5DT0xPUl9BVFRBQ0hNRU5UMCArIGkgKTtcclxuXHJcblx0XHRcdFx0XHRcdGlmICggZGVwdGhCdWZmZXIgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdGNvbnN0IGRlcHRoU3R5bGUgPSBzdGVuY2lsQnVmZmVyID8gZ2wuREVQVEhfU1RFTkNJTF9BVFRBQ0hNRU5UIDogZ2wuREVQVEhfQVRUQUNITUVOVDtcclxuXHRcdFx0XHRcdFx0XHRpbnZhbGlkYXRpb25BcnJheS5wdXNoKCBkZXB0aFN0eWxlICk7XHJcblxyXG5cdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0XHRjb25zdCB0ZXh0dXJlID0gZGVzY3JpcHRvci50ZXh0dXJlc1sgaSBdO1xyXG5cdFx0XHRcdFx0XHRjb25zdCB0ZXh0dXJlRGF0YSA9IHRoaXMuZ2V0KCB0ZXh0dXJlICk7XHJcblxyXG5cdFx0XHRcdFx0XHRnbC5yZW5kZXJidWZmZXJTdG9yYWdlTXVsdGlzYW1wbGUoIGdsLlJFTkRFUkJVRkZFUiwgc2FtcGxlcywgdGV4dHVyZURhdGEuZ2xJbnRlcm5hbEZvcm1hdCwgZGVzY3JpcHRvci53aWR0aCwgZGVzY3JpcHRvci5oZWlnaHQgKTtcclxuXHRcdFx0XHRcdFx0Z2wuZnJhbWVidWZmZXJSZW5kZXJidWZmZXIoIGdsLkZSQU1FQlVGRkVSLCBnbC5DT0xPUl9BVFRBQ0hNRU5UMCArIGksIGdsLlJFTkRFUkJVRkZFUiwgbXNhYVJlbmRlcmJ1ZmZlcnNbIGkgXSApO1xyXG5cclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0cmVuZGVyVGFyZ2V0Q29udGV4dERhdGEubXNhYUZyYW1lQnVmZmVyID0gbXNhYUZiO1xyXG5cdFx0XHRcdFx0cmVuZGVyVGFyZ2V0Q29udGV4dERhdGEubXNhYVJlbmRlcmJ1ZmZlcnMgPSBtc2FhUmVuZGVyYnVmZmVycztcclxuXHJcblx0XHRcdFx0XHRpZiAoIGRlcHRoUmVuZGVyYnVmZmVyID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRkZXB0aFJlbmRlcmJ1ZmZlciA9IGdsLmNyZWF0ZVJlbmRlcmJ1ZmZlcigpO1xyXG5cdFx0XHRcdFx0XHR0aGlzLnRleHR1cmVVdGlscy5zZXR1cFJlbmRlckJ1ZmZlclN0b3JhZ2UoIGRlcHRoUmVuZGVyYnVmZmVyLCBkZXNjcmlwdG9yICk7XHJcblxyXG5cdFx0XHRcdFx0XHRyZW5kZXJUYXJnZXRDb250ZXh0RGF0YS5kZXB0aFJlbmRlcmJ1ZmZlciA9IGRlcHRoUmVuZGVyYnVmZmVyO1xyXG5cclxuXHRcdFx0XHRcdFx0Y29uc3QgZGVwdGhTdHlsZSA9IHN0ZW5jaWxCdWZmZXIgPyBnbC5ERVBUSF9TVEVOQ0lMX0FUVEFDSE1FTlQgOiBnbC5ERVBUSF9BVFRBQ0hNRU5UO1xyXG5cdFx0XHRcdFx0XHRpbnZhbGlkYXRpb25BcnJheS5wdXNoKCBkZXB0aFN0eWxlICk7XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdHJlbmRlclRhcmdldENvbnRleHREYXRhLmludmFsaWRhdGlvbkFycmF5ID0gaW52YWxpZGF0aW9uQXJyYXk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0Y3VycmVudEZyYW1lQnVmZmVyID0gcmVuZGVyVGFyZ2V0Q29udGV4dERhdGEubXNhYUZyYW1lQnVmZmVyO1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0Y3VycmVudEZyYW1lQnVmZmVyID0gZmI7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHN0YXRlLmJpbmRGcmFtZWJ1ZmZlciggZ2wuRlJBTUVCVUZGRVIsIGN1cnJlbnRGcmFtZUJ1ZmZlciApO1xyXG5cclxuXHR9XHJcblxyXG5cclxuXHRfZ2V0VmFvS2V5KCBpbmRleCwgYXR0cmlidXRlcyApIHtcclxuXHJcblx0XHRsZXQga2V5ID0gW107XHJcblxyXG5cdFx0aWYgKCBpbmRleCAhPT0gbnVsbCApIHtcclxuXHJcblx0XHRcdGNvbnN0IGluZGV4RGF0YSA9IHRoaXMuZ2V0KCBpbmRleCApO1xyXG5cclxuXHRcdFx0a2V5ICs9ICc6JyArIGluZGV4RGF0YS5pZDtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgYXR0cmlidXRlcy5sZW5ndGg7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRjb25zdCBhdHRyaWJ1dGVEYXRhID0gdGhpcy5nZXQoIGF0dHJpYnV0ZXNbIGkgXSApO1xyXG5cclxuXHRcdFx0a2V5ICs9ICc6JyArIGF0dHJpYnV0ZURhdGEuaWQ7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBrZXk7XHJcblxyXG5cdH1cclxuXHJcblx0X2NyZWF0ZVZhbyggaW5kZXgsIGF0dHJpYnV0ZXMgKSB7XHJcblxyXG5cdFx0Y29uc3QgeyBnbCB9ID0gdGhpcztcclxuXHJcblx0XHRjb25zdCB2YW9HUFUgPSBnbC5jcmVhdGVWZXJ0ZXhBcnJheSgpO1xyXG5cdFx0bGV0IGtleSA9ICcnO1xyXG5cclxuXHRcdGxldCBzdGF0aWNWYW8gPSB0cnVlO1xyXG5cclxuXHRcdGdsLmJpbmRWZXJ0ZXhBcnJheSggdmFvR1BVICk7XHJcblxyXG5cdFx0aWYgKCBpbmRleCAhPT0gbnVsbCApIHtcclxuXHJcblx0XHRcdGNvbnN0IGluZGV4RGF0YSA9IHRoaXMuZ2V0KCBpbmRleCApO1xyXG5cclxuXHRcdFx0Z2wuYmluZEJ1ZmZlciggZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIGluZGV4RGF0YS5idWZmZXJHUFUgKTtcclxuXHJcblx0XHRcdGtleSArPSAnOicgKyBpbmRleERhdGEuaWQ7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGZvciAoIGxldCBpID0gMDsgaSA8IGF0dHJpYnV0ZXMubGVuZ3RoOyBpICsrICkge1xyXG5cclxuXHRcdFx0Y29uc3QgYXR0cmlidXRlID0gYXR0cmlidXRlc1sgaSBdO1xyXG5cdFx0XHRjb25zdCBhdHRyaWJ1dGVEYXRhID0gdGhpcy5nZXQoIGF0dHJpYnV0ZSApO1xyXG5cclxuXHRcdFx0a2V5ICs9ICc6JyArIGF0dHJpYnV0ZURhdGEuaWQ7XHJcblxyXG5cdFx0XHRnbC5iaW5kQnVmZmVyKCBnbC5BUlJBWV9CVUZGRVIsIGF0dHJpYnV0ZURhdGEuYnVmZmVyR1BVICk7XHJcblx0XHRcdGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KCBpICk7XHJcblxyXG5cdFx0XHRpZiAoIGF0dHJpYnV0ZS5pc1N0b3JhZ2VCdWZmZXJBdHRyaWJ1dGUgfHwgYXR0cmlidXRlLmlzU3RvcmFnZUluc3RhbmNlZEJ1ZmZlckF0dHJpYnV0ZSApIHN0YXRpY1ZhbyA9IGZhbHNlO1xyXG5cclxuXHRcdFx0bGV0IHN0cmlkZSwgb2Zmc2V0O1xyXG5cclxuXHRcdFx0aWYgKCBhdHRyaWJ1dGUuaXNJbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZSA9PT0gdHJ1ZSApIHtcclxuXHJcblx0XHRcdFx0c3RyaWRlID0gYXR0cmlidXRlLmRhdGEuc3RyaWRlICogYXR0cmlidXRlRGF0YS5ieXRlc1BlckVsZW1lbnQ7XHJcblx0XHRcdFx0b2Zmc2V0ID0gYXR0cmlidXRlLm9mZnNldCAqIGF0dHJpYnV0ZURhdGEuYnl0ZXNQZXJFbGVtZW50O1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0c3RyaWRlID0gMDtcclxuXHRcdFx0XHRvZmZzZXQgPSAwO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKCBhdHRyaWJ1dGVEYXRhLmlzSW50ZWdlciApIHtcclxuXHJcblx0XHRcdFx0Z2wudmVydGV4QXR0cmliSVBvaW50ZXIoIGksIGF0dHJpYnV0ZS5pdGVtU2l6ZSwgYXR0cmlidXRlRGF0YS50eXBlLCBzdHJpZGUsIG9mZnNldCApO1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0Z2wudmVydGV4QXR0cmliUG9pbnRlciggaSwgYXR0cmlidXRlLml0ZW1TaXplLCBhdHRyaWJ1dGVEYXRhLnR5cGUsIGF0dHJpYnV0ZS5ub3JtYWxpemVkLCBzdHJpZGUsIG9mZnNldCApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKCBhdHRyaWJ1dGUuaXNJbnN0YW5jZWRCdWZmZXJBdHRyaWJ1dGUgJiYgISBhdHRyaWJ1dGUuaXNJbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZSApIHtcclxuXHJcblx0XHRcdFx0Z2wudmVydGV4QXR0cmliRGl2aXNvciggaSwgYXR0cmlidXRlLm1lc2hQZXJBdHRyaWJ1dGUgKTtcclxuXHJcblx0XHRcdH0gZWxzZSBpZiAoIGF0dHJpYnV0ZS5pc0ludGVybGVhdmVkQnVmZmVyQXR0cmlidXRlICYmIGF0dHJpYnV0ZS5kYXRhLmlzSW5zdGFuY2VkSW50ZXJsZWF2ZWRCdWZmZXIgKSB7XHJcblxyXG5cdFx0XHRcdGdsLnZlcnRleEF0dHJpYkRpdmlzb3IoIGksIGF0dHJpYnV0ZS5kYXRhLm1lc2hQZXJBdHRyaWJ1dGUgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Z2wuYmluZEJ1ZmZlciggZ2wuQVJSQVlfQlVGRkVSLCBudWxsICk7XHJcblxyXG5cdFx0dGhpcy52YW9DYWNoZVsga2V5IF0gPSB2YW9HUFU7XHJcblxyXG5cdFx0cmV0dXJuIHsgdmFvR1BVLCBzdGF0aWNWYW8gfTtcclxuXHJcblx0fVxyXG5cclxuXHRfZ2V0VHJhbnNmb3JtRmVlZGJhY2soIHRyYW5zZm9ybUJ1ZmZlcnMgKSB7XHJcblxyXG5cdFx0bGV0IGtleSA9ICcnO1xyXG5cclxuXHRcdGZvciAoIGxldCBpID0gMDsgaSA8IHRyYW5zZm9ybUJ1ZmZlcnMubGVuZ3RoOyBpICsrICkge1xyXG5cclxuXHRcdFx0a2V5ICs9ICc6JyArIHRyYW5zZm9ybUJ1ZmZlcnNbIGkgXS5pZDtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0bGV0IHRyYW5zZm9ybUZlZWRiYWNrR1BVID0gdGhpcy50cmFuc2Zvcm1GZWVkYmFja0NhY2hlWyBrZXkgXTtcclxuXHJcblx0XHRpZiAoIHRyYW5zZm9ybUZlZWRiYWNrR1BVICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gdHJhbnNmb3JtRmVlZGJhY2tHUFU7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGNvbnN0IHsgZ2wgfSA9IHRoaXM7XHJcblxyXG5cdFx0dHJhbnNmb3JtRmVlZGJhY2tHUFUgPSBnbC5jcmVhdGVUcmFuc2Zvcm1GZWVkYmFjaygpO1xyXG5cclxuXHRcdGdsLmJpbmRUcmFuc2Zvcm1GZWVkYmFjayggZ2wuVFJBTlNGT1JNX0ZFRURCQUNLLCB0cmFuc2Zvcm1GZWVkYmFja0dQVSApO1xyXG5cclxuXHRcdGZvciAoIGxldCBpID0gMDsgaSA8IHRyYW5zZm9ybUJ1ZmZlcnMubGVuZ3RoOyBpICsrICkge1xyXG5cclxuXHRcdFx0Y29uc3QgYXR0cmlidXRlRGF0YSA9IHRyYW5zZm9ybUJ1ZmZlcnNbIGkgXTtcclxuXHJcblx0XHRcdGdsLmJpbmRCdWZmZXJCYXNlKCBnbC5UUkFOU0ZPUk1fRkVFREJBQ0tfQlVGRkVSLCBpLCBhdHRyaWJ1dGVEYXRhLnRyYW5zZm9ybUJ1ZmZlciApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRnbC5iaW5kVHJhbnNmb3JtRmVlZGJhY2soIGdsLlRSQU5TRk9STV9GRUVEQkFDSywgbnVsbCApO1xyXG5cclxuXHRcdHRoaXMudHJhbnNmb3JtRmVlZGJhY2tDYWNoZVsga2V5IF0gPSB0cmFuc2Zvcm1GZWVkYmFja0dQVTtcclxuXHJcblx0XHRyZXR1cm4gdHJhbnNmb3JtRmVlZGJhY2tHUFU7XHJcblxyXG5cdH1cclxuXHJcblxyXG5cdF9zZXR1cEJpbmRpbmdzKCBiaW5kaW5ncywgcHJvZ3JhbUdQVSApIHtcclxuXHJcblx0XHRjb25zdCBnbCA9IHRoaXMuZ2w7XHJcblxyXG5cdFx0Zm9yICggY29uc3QgYmluZEdyb3VwIG9mIGJpbmRpbmdzICkge1xyXG5cclxuXHRcdFx0Zm9yICggY29uc3QgYmluZGluZyBvZiBiaW5kR3JvdXAuYmluZGluZ3MgKSB7XHJcblxyXG5cdFx0XHRcdGNvbnN0IGJpbmRpbmdEYXRhID0gdGhpcy5nZXQoIGJpbmRpbmcgKTtcclxuXHRcdFx0XHRjb25zdCBpbmRleCA9IGJpbmRpbmdEYXRhLmluZGV4O1xyXG5cclxuXHRcdFx0XHRpZiAoIGJpbmRpbmcuaXNVbmlmb3Jtc0dyb3VwIHx8IGJpbmRpbmcuaXNVbmlmb3JtQnVmZmVyICkge1xyXG5cclxuXHRcdFx0XHRcdGNvbnN0IGxvY2F0aW9uID0gZ2wuZ2V0VW5pZm9ybUJsb2NrSW5kZXgoIHByb2dyYW1HUFUsIGJpbmRpbmcubmFtZSApO1xyXG5cdFx0XHRcdFx0Z2wudW5pZm9ybUJsb2NrQmluZGluZyggcHJvZ3JhbUdQVSwgbG9jYXRpb24sIGluZGV4ICk7XHJcblxyXG5cdFx0XHRcdH0gZWxzZSBpZiAoIGJpbmRpbmcuaXNTYW1wbGVkVGV4dHVyZSApIHtcclxuXHJcblx0XHRcdFx0XHRjb25zdCBsb2NhdGlvbiA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbiggcHJvZ3JhbUdQVSwgYmluZGluZy5uYW1lICk7XHJcblx0XHRcdFx0XHRnbC51bmlmb3JtMWkoIGxvY2F0aW9uLCBpbmRleCApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdF9iaW5kVW5pZm9ybXMoIGJpbmRpbmdzICkge1xyXG5cclxuXHRcdGNvbnN0IHsgZ2wsIHN0YXRlIH0gPSB0aGlzO1xyXG5cclxuXHRcdGZvciAoIGNvbnN0IGJpbmRHcm91cCBvZiBiaW5kaW5ncyApIHtcclxuXHJcblx0XHRcdGZvciAoIGNvbnN0IGJpbmRpbmcgb2YgYmluZEdyb3VwLmJpbmRpbmdzICkge1xyXG5cclxuXHRcdFx0XHRjb25zdCBiaW5kaW5nRGF0YSA9IHRoaXMuZ2V0KCBiaW5kaW5nICk7XHJcblx0XHRcdFx0Y29uc3QgaW5kZXggPSBiaW5kaW5nRGF0YS5pbmRleDtcclxuXHJcblx0XHRcdFx0aWYgKCBiaW5kaW5nLmlzVW5pZm9ybXNHcm91cCB8fCBiaW5kaW5nLmlzVW5pZm9ybUJ1ZmZlciApIHtcclxuXHJcblx0XHRcdFx0XHQvLyBUT0RPIFVTRSBiaW5kQnVmZmVyUmFuZ2UgdG8gZ3JvdXAgbXVsdGlwbGUgdW5pZm9ybSBidWZmZXJzXHJcblx0XHRcdFx0XHRzdGF0ZS5iaW5kQnVmZmVyQmFzZSggZ2wuVU5JRk9STV9CVUZGRVIsIGluZGV4LCBiaW5kaW5nRGF0YS5idWZmZXJHUFUgKTtcclxuXHJcblx0XHRcdFx0fSBlbHNlIGlmICggYmluZGluZy5pc1NhbXBsZWRUZXh0dXJlICkge1xyXG5cclxuXHRcdFx0XHRcdHN0YXRlLmJpbmRUZXh0dXJlKCBiaW5kaW5nRGF0YS5nbFRleHR1cmVUeXBlLCBiaW5kaW5nRGF0YS50ZXh0dXJlR1BVLCBnbC5URVhUVVJFMCArIGluZGV4ICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0ZGlzcG9zZSgpIHtcclxuXHJcblx0XHR0aGlzLnJlbmRlcmVyLmRvbUVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ3dlYmdsY29udGV4dGxvc3QnLCB0aGlzLl9vbkNvbnRleHRMb3N0ICk7XHJcblxyXG5cdH1cclxuXHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IFdlYkdMQmFja2VuZDtcclxuIiwiZXhwb3J0IGNvbnN0IEdQVVByaW1pdGl2ZVRvcG9sb2d5ID0ge1xyXG5cdFBvaW50TGlzdDogJ3BvaW50LWxpc3QnLFxyXG5cdExpbmVMaXN0OiAnbGluZS1saXN0JyxcclxuXHRMaW5lU3RyaXA6ICdsaW5lLXN0cmlwJyxcclxuXHRUcmlhbmdsZUxpc3Q6ICd0cmlhbmdsZS1saXN0JyxcclxuXHRUcmlhbmdsZVN0cmlwOiAndHJpYW5nbGUtc3RyaXAnLFxyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IEdQVUNvbXBhcmVGdW5jdGlvbiA9IHtcclxuXHROZXZlcjogJ25ldmVyJyxcclxuXHRMZXNzOiAnbGVzcycsXHJcblx0RXF1YWw6ICdlcXVhbCcsXHJcblx0TGVzc0VxdWFsOiAnbGVzcy1lcXVhbCcsXHJcblx0R3JlYXRlcjogJ2dyZWF0ZXInLFxyXG5cdE5vdEVxdWFsOiAnbm90LWVxdWFsJyxcclxuXHRHcmVhdGVyRXF1YWw6ICdncmVhdGVyLWVxdWFsJyxcclxuXHRBbHdheXM6ICdhbHdheXMnXHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgR1BVU3RvcmVPcCA9IHtcclxuXHRTdG9yZTogJ3N0b3JlJyxcclxuXHREaXNjYXJkOiAnZGlzY2FyZCdcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBHUFVMb2FkT3AgPSB7XHJcblx0TG9hZDogJ2xvYWQnLFxyXG5cdENsZWFyOiAnY2xlYXInXHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgR1BVRnJvbnRGYWNlID0ge1xyXG5cdENDVzogJ2NjdycsXHJcblx0Q1c6ICdjdydcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBHUFVDdWxsTW9kZSA9IHtcclxuXHROb25lOiAnbm9uZScsXHJcblx0RnJvbnQ6ICdmcm9udCcsXHJcblx0QmFjazogJ2JhY2snXHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgR1BVSW5kZXhGb3JtYXQgPSB7XHJcblx0VWludDE2OiAndWludDE2JyxcclxuXHRVaW50MzI6ICd1aW50MzInXHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgR1BVVmVydGV4Rm9ybWF0ID0ge1xyXG5cdFVpbnQ4eDI6ICd1aW50OHgyJyxcclxuXHRVaW50OHg0OiAndWludDh4NCcsXHJcblx0U2ludDh4MjogJ3NpbnQ4eDInLFxyXG5cdFNpbnQ4eDQ6ICdzaW50OHg0JyxcclxuXHRVbm9ybTh4MjogJ3Vub3JtOHgyJyxcclxuXHRVbm9ybTh4NDogJ3Vub3JtOHg0JyxcclxuXHRTbm9ybTh4MjogJ3Nub3JtOHgyJyxcclxuXHRTbm9ybTh4NDogJ3Nub3JtOHg0JyxcclxuXHRVaW50MTZ4MjogJ3VpbnQxNngyJyxcclxuXHRVaW50MTZ4NDogJ3VpbnQxNng0JyxcclxuXHRTaW50MTZ4MjogJ3NpbnQxNngyJyxcclxuXHRTaW50MTZ4NDogJ3NpbnQxNng0JyxcclxuXHRVbm9ybTE2eDI6ICd1bm9ybTE2eDInLFxyXG5cdFVub3JtMTZ4NDogJ3Vub3JtMTZ4NCcsXHJcblx0U25vcm0xNngyOiAnc25vcm0xNngyJyxcclxuXHRTbm9ybTE2eDQ6ICdzbm9ybTE2eDQnLFxyXG5cdEZsb2F0MTZ4MjogJ2Zsb2F0MTZ4MicsXHJcblx0RmxvYXQxNng0OiAnZmxvYXQxNng0JyxcclxuXHRGbG9hdDMyOiAnZmxvYXQzMicsXHJcblx0RmxvYXQzMngyOiAnZmxvYXQzMngyJyxcclxuXHRGbG9hdDMyeDM6ICdmbG9hdDMyeDMnLFxyXG5cdEZsb2F0MzJ4NDogJ2Zsb2F0MzJ4NCcsXHJcblx0VWludDMyOiAndWludDMyJyxcclxuXHRVaW50MzJ4MjogJ3VpbnQzMngyJyxcclxuXHRVaW50MzJ4MzogJ3VpbnQzMngzJyxcclxuXHRVaW50MzJ4NDogJ3VpbnQzMng0JyxcclxuXHRTaW50MzI6ICdzaW50MzInLFxyXG5cdFNpbnQzMngyOiAnc2ludDMyeDInLFxyXG5cdFNpbnQzMngzOiAnc2ludDMyeDMnLFxyXG5cdFNpbnQzMng0OiAnc2ludDMyeDQnXHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgR1BVVGV4dHVyZUZvcm1hdCA9IHtcclxuXHJcblx0Ly8gOC1iaXQgZm9ybWF0c1xyXG5cclxuXHRSOFVub3JtOiAncjh1bm9ybScsXHJcblx0UjhTbm9ybTogJ3I4c25vcm0nLFxyXG5cdFI4VWludDogJ3I4dWludCcsXHJcblx0UjhTaW50OiAncjhzaW50JyxcclxuXHJcblx0Ly8gMTYtYml0IGZvcm1hdHNcclxuXHJcblx0UjE2VWludDogJ3IxNnVpbnQnLFxyXG5cdFIxNlNpbnQ6ICdyMTZzaW50JyxcclxuXHRSMTZGbG9hdDogJ3IxNmZsb2F0JyxcclxuXHRSRzhVbm9ybTogJ3JnOHVub3JtJyxcclxuXHRSRzhTbm9ybTogJ3JnOHNub3JtJyxcclxuXHRSRzhVaW50OiAncmc4dWludCcsXHJcblx0Ukc4U2ludDogJ3JnOHNpbnQnLFxyXG5cclxuXHQvLyAzMi1iaXQgZm9ybWF0c1xyXG5cclxuXHRSMzJVaW50OiAncjMydWludCcsXHJcblx0UjMyU2ludDogJ3IzMnNpbnQnLFxyXG5cdFIzMkZsb2F0OiAncjMyZmxvYXQnLFxyXG5cdFJHMTZVaW50OiAncmcxNnVpbnQnLFxyXG5cdFJHMTZTaW50OiAncmcxNnNpbnQnLFxyXG5cdFJHMTZGbG9hdDogJ3JnMTZmbG9hdCcsXHJcblx0UkdCQThVbm9ybTogJ3JnYmE4dW5vcm0nLFxyXG5cdFJHQkE4VW5vcm1TUkdCOiAncmdiYTh1bm9ybS1zcmdiJyxcclxuXHRSR0JBOFNub3JtOiAncmdiYThzbm9ybScsXHJcblx0UkdCQThVaW50OiAncmdiYTh1aW50JyxcclxuXHRSR0JBOFNpbnQ6ICdyZ2JhOHNpbnQnLFxyXG5cdEJHUkE4VW5vcm06ICdiZ3JhOHVub3JtJyxcclxuXHRCR1JBOFVub3JtU1JHQjogJ2JncmE4dW5vcm0tc3JnYicsXHJcblx0Ly8gUGFja2VkIDMyLWJpdCBmb3JtYXRzXHJcblx0UkdCOUU1VUZsb2F0OiAncmdiOWU1dWZsb2F0JyxcclxuXHRSR0IxMEEyVW5vcm06ICdyZ2IxMGEydW5vcm0nLFxyXG5cdFJHMTFCMTB1RmxvYXQ6ICdyZ2IxMGEydW5vcm0nLFxyXG5cclxuXHQvLyA2NC1iaXQgZm9ybWF0c1xyXG5cclxuXHRSRzMyVWludDogJ3JnMzJ1aW50JyxcclxuXHRSRzMyU2ludDogJ3JnMzJzaW50JyxcclxuXHRSRzMyRmxvYXQ6ICdyZzMyZmxvYXQnLFxyXG5cdFJHQkExNlVpbnQ6ICdyZ2JhMTZ1aW50JyxcclxuXHRSR0JBMTZTaW50OiAncmdiYTE2c2ludCcsXHJcblx0UkdCQTE2RmxvYXQ6ICdyZ2JhMTZmbG9hdCcsXHJcblxyXG5cdC8vIDEyOC1iaXQgZm9ybWF0c1xyXG5cclxuXHRSR0JBMzJVaW50OiAncmdiYTMydWludCcsXHJcblx0UkdCQTMyU2ludDogJ3JnYmEzMnNpbnQnLFxyXG5cdFJHQkEzMkZsb2F0OiAncmdiYTMyZmxvYXQnLFxyXG5cclxuXHQvLyBEZXB0aCBhbmQgc3RlbmNpbCBmb3JtYXRzXHJcblxyXG5cdFN0ZW5jaWw4OiAnc3RlbmNpbDgnLFxyXG5cdERlcHRoMTZVbm9ybTogJ2RlcHRoMTZ1bm9ybScsXHJcblx0RGVwdGgyNFBsdXM6ICdkZXB0aDI0cGx1cycsXHJcblx0RGVwdGgyNFBsdXNTdGVuY2lsODogJ2RlcHRoMjRwbHVzLXN0ZW5jaWw4JyxcclxuXHREZXB0aDMyRmxvYXQ6ICdkZXB0aDMyZmxvYXQnLFxyXG5cclxuXHQvLyAnZGVwdGgzMmZsb2F0LXN0ZW5jaWw4JyBleHRlbnNpb25cclxuXHJcblx0RGVwdGgzMkZsb2F0U3RlbmNpbDg6ICdkZXB0aDMyZmxvYXQtc3RlbmNpbDgnLFxyXG5cclxuXHQvLyBCQyBjb21wcmVzc2VkIGZvcm1hdHMgdXNhYmxlIGlmICd0ZXh0dXJlLWNvbXByZXNzaW9uLWJjJyBpcyBib3RoXHJcblx0Ly8gc3VwcG9ydGVkIGJ5IHRoZSBkZXZpY2UvdXNlciBhZ2VudCBhbmQgZW5hYmxlZCBpbiByZXF1ZXN0RGV2aWNlLlxyXG5cclxuXHRCQzFSR0JBVW5vcm06ICdiYzEtcmdiYS11bm9ybScsXHJcblx0QkMxUkdCQVVub3JtU1JHQjogJ2JjMS1yZ2JhLXVub3JtLXNyZ2InLFxyXG5cdEJDMlJHQkFVbm9ybTogJ2JjMi1yZ2JhLXVub3JtJyxcclxuXHRCQzJSR0JBVW5vcm1TUkdCOiAnYmMyLXJnYmEtdW5vcm0tc3JnYicsXHJcblx0QkMzUkdCQVVub3JtOiAnYmMzLXJnYmEtdW5vcm0nLFxyXG5cdEJDM1JHQkFVbm9ybVNSR0I6ICdiYzMtcmdiYS11bm9ybS1zcmdiJyxcclxuXHRCQzRSVW5vcm06ICdiYzQtci11bm9ybScsXHJcblx0QkM0UlNub3JtOiAnYmM0LXItc25vcm0nLFxyXG5cdEJDNVJHVW5vcm06ICdiYzUtcmctdW5vcm0nLFxyXG5cdEJDNVJHU25vcm06ICdiYzUtcmctc25vcm0nLFxyXG5cdEJDNkhSR0JVRmxvYXQ6ICdiYzZoLXJnYi11ZmxvYXQnLFxyXG5cdEJDNkhSR0JGbG9hdDogJ2JjNmgtcmdiLWZsb2F0JyxcclxuXHRCQzdSR0JBVW5vcm06ICdiYzctcmdiYS11bm9ybScsXHJcblx0QkM3UkdCQVVub3JtU1JHQjogJ2JjNy1yZ2JhLXNyZ2InLFxyXG5cclxuXHQvLyBFVEMyIGNvbXByZXNzZWQgZm9ybWF0cyB1c2FibGUgaWYgJ3RleHR1cmUtY29tcHJlc3Npb24tZXRjMicgaXMgYm90aFxyXG5cdC8vIHN1cHBvcnRlZCBieSB0aGUgZGV2aWNlL3VzZXIgYWdlbnQgYW5kIGVuYWJsZWQgaW4gcmVxdWVzdERldmljZS5cclxuXHJcblx0RVRDMlJHQjhVbm9ybTogJ2V0YzItcmdiOHVub3JtJyxcclxuXHRFVEMyUkdCOFVub3JtU1JHQjogJ2V0YzItcmdiOHVub3JtLXNyZ2InLFxyXG5cdEVUQzJSR0I4QTFVbm9ybTogJ2V0YzItcmdiOGExdW5vcm0nLFxyXG5cdEVUQzJSR0I4QTFVbm9ybVNSR0I6ICdldGMyLXJnYjhhMXVub3JtLXNyZ2InLFxyXG5cdEVUQzJSR0JBOFVub3JtOiAnZXRjMi1yZ2JhOHVub3JtJyxcclxuXHRFVEMyUkdCQThVbm9ybVNSR0I6ICdldGMyLXJnYmE4dW5vcm0tc3JnYicsXHJcblx0RUFDUjExVW5vcm06ICdlYWMtcjExdW5vcm0nLFxyXG5cdEVBQ1IxMVNub3JtOiAnZWFjLXIxMXNub3JtJyxcclxuXHRFQUNSRzExVW5vcm06ICdlYWMtcmcxMXVub3JtJyxcclxuXHRFQUNSRzExU25vcm06ICdlYWMtcmcxMXNub3JtJyxcclxuXHJcblx0Ly8gQVNUQyBjb21wcmVzc2VkIGZvcm1hdHMgdXNhYmxlIGlmICd0ZXh0dXJlLWNvbXByZXNzaW9uLWFzdGMnIGlzIGJvdGhcclxuXHQvLyBzdXBwb3J0ZWQgYnkgdGhlIGRldmljZS91c2VyIGFnZW50IGFuZCBlbmFibGVkIGluIHJlcXVlc3REZXZpY2UuXHJcblxyXG5cdEFTVEM0eDRVbm9ybTogJ2FzdGMtNHg0LXVub3JtJyxcclxuXHRBU1RDNHg0VW5vcm1TUkdCOiAnYXN0Yy00eDQtdW5vcm0tc3JnYicsXHJcblx0QVNUQzV4NFVub3JtOiAnYXN0Yy01eDQtdW5vcm0nLFxyXG5cdEFTVEM1eDRVbm9ybVNSR0I6ICdhc3RjLTV4NC11bm9ybS1zcmdiJyxcclxuXHRBU1RDNXg1VW5vcm06ICdhc3RjLTV4NS11bm9ybScsXHJcblx0QVNUQzV4NVVub3JtU1JHQjogJ2FzdGMtNXg1LXVub3JtLXNyZ2InLFxyXG5cdEFTVEM2eDVVbm9ybTogJ2FzdGMtNng1LXVub3JtJyxcclxuXHRBU1RDNng1VW5vcm1TUkdCOiAnYXN0Yy02eDUtdW5vcm0tc3JnYicsXHJcblx0QVNUQzZ4NlVub3JtOiAnYXN0Yy02eDYtdW5vcm0nLFxyXG5cdEFTVEM2eDZVbm9ybVNSR0I6ICdhc3RjLTZ4Ni11bm9ybS1zcmdiJyxcclxuXHRBU1RDOHg1VW5vcm06ICdhc3RjLTh4NS11bm9ybScsXHJcblx0QVNUQzh4NVVub3JtU1JHQjogJ2FzdGMtOHg1LXVub3JtLXNyZ2InLFxyXG5cdEFTVEM4eDZVbm9ybTogJ2FzdGMtOHg2LXVub3JtJyxcclxuXHRBU1RDOHg2VW5vcm1TUkdCOiAnYXN0Yy04eDYtdW5vcm0tc3JnYicsXHJcblx0QVNUQzh4OFVub3JtOiAnYXN0Yy04eDgtdW5vcm0nLFxyXG5cdEFTVEM4eDhVbm9ybVNSR0I6ICdhc3RjLTh4OC11bm9ybS1zcmdiJyxcclxuXHRBU1RDMTB4NVVub3JtOiAnYXN0Yy0xMHg1LXVub3JtJyxcclxuXHRBU1RDMTB4NVVub3JtU1JHQjogJ2FzdGMtMTB4NS11bm9ybS1zcmdiJyxcclxuXHRBU1RDMTB4NlVub3JtOiAnYXN0Yy0xMHg2LXVub3JtJyxcclxuXHRBU1RDMTB4NlVub3JtU1JHQjogJ2FzdGMtMTB4Ni11bm9ybS1zcmdiJyxcclxuXHRBU1RDMTB4OFVub3JtOiAnYXN0Yy0xMHg4LXVub3JtJyxcclxuXHRBU1RDMTB4OFVub3JtU1JHQjogJ2FzdGMtMTB4OC11bm9ybS1zcmdiJyxcclxuXHRBU1RDMTB4MTBVbm9ybTogJ2FzdGMtMTB4MTAtdW5vcm0nLFxyXG5cdEFTVEMxMHgxMFVub3JtU1JHQjogJ2FzdGMtMTB4MTAtdW5vcm0tc3JnYicsXHJcblx0QVNUQzEyeDEwVW5vcm06ICdhc3RjLTEyeDEwLXVub3JtJyxcclxuXHRBU1RDMTJ4MTBVbm9ybVNSR0I6ICdhc3RjLTEyeDEwLXVub3JtLXNyZ2InLFxyXG5cdEFTVEMxMngxMlVub3JtOiAnYXN0Yy0xMngxMi11bm9ybScsXHJcblx0QVNUQzEyeDEyVW5vcm1TUkdCOiAnYXN0Yy0xMngxMi11bm9ybS1zcmdiJyxcclxuXHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgR1BVQWRkcmVzc01vZGUgPSB7XHJcblx0Q2xhbXBUb0VkZ2U6ICdjbGFtcC10by1lZGdlJyxcclxuXHRSZXBlYXQ6ICdyZXBlYXQnLFxyXG5cdE1pcnJvclJlcGVhdDogJ21pcnJvci1yZXBlYXQnXHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgR1BVRmlsdGVyTW9kZSA9IHtcclxuXHRMaW5lYXI6ICdsaW5lYXInLFxyXG5cdE5lYXJlc3Q6ICduZWFyZXN0J1xyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IEdQVUJsZW5kRmFjdG9yID0ge1xyXG5cdFplcm86ICd6ZXJvJyxcclxuXHRPbmU6ICdvbmUnLFxyXG5cdFNyYzogJ3NyYycsXHJcblx0T25lTWludXNTcmM6ICdvbmUtbWludXMtc3JjJyxcclxuXHRTcmNBbHBoYTogJ3NyYy1hbHBoYScsXHJcblx0T25lTWludXNTcmNBbHBoYTogJ29uZS1taW51cy1zcmMtYWxwaGEnLFxyXG5cdERzdDogJ2RzdCcsXHJcblx0T25lTWludXNEc3RDb2xvcjogJ29uZS1taW51cy1kc3QnLFxyXG5cdERzdEFscGhhOiAnZHN0LWFscGhhJyxcclxuXHRPbmVNaW51c0RzdEFscGhhOiAnb25lLW1pbnVzLWRzdC1hbHBoYScsXHJcblx0U3JjQWxwaGFTYXR1cmF0ZWQ6ICdzcmMtYWxwaGEtc2F0dXJhdGVkJyxcclxuXHRDb25zdGFudDogJ2NvbnN0YW50JyxcclxuXHRPbmVNaW51c0NvbnN0YW50OiAnb25lLW1pbnVzLWNvbnN0YW50J1xyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IEdQVUJsZW5kT3BlcmF0aW9uID0ge1xyXG5cdEFkZDogJ2FkZCcsXHJcblx0U3VidHJhY3Q6ICdzdWJ0cmFjdCcsXHJcblx0UmV2ZXJzZVN1YnRyYWN0OiAncmV2ZXJzZS1zdWJ0cmFjdCcsXHJcblx0TWluOiAnbWluJyxcclxuXHRNYXg6ICdtYXgnXHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgR1BVQ29sb3JXcml0ZUZsYWdzID0ge1xyXG5cdE5vbmU6IDAsXHJcblx0UmVkOiAweDEsXHJcblx0R3JlZW46IDB4MixcclxuXHRCbHVlOiAweDQsXHJcblx0QWxwaGE6IDB4OCxcclxuXHRBbGw6IDB4RlxyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IEdQVVN0ZW5jaWxPcGVyYXRpb24gPSB7XHJcblx0S2VlcDogJ2tlZXAnLFxyXG5cdFplcm86ICd6ZXJvJyxcclxuXHRSZXBsYWNlOiAncmVwbGFjZScsXHJcblx0SW52ZXJ0OiAnaW52ZXJ0JyxcclxuXHRJbmNyZW1lbnRDbGFtcDogJ2luY3JlbWVudC1jbGFtcCcsXHJcblx0RGVjcmVtZW50Q2xhbXA6ICdkZWNyZW1lbnQtY2xhbXAnLFxyXG5cdEluY3JlbWVudFdyYXA6ICdpbmNyZW1lbnQtd3JhcCcsXHJcblx0RGVjcmVtZW50V3JhcDogJ2RlY3JlbWVudC13cmFwJ1xyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IEdQVUJ1ZmZlckJpbmRpbmdUeXBlID0ge1xyXG5cdFVuaWZvcm06ICd1bmlmb3JtJyxcclxuXHRTdG9yYWdlOiAnc3RvcmFnZScsXHJcblx0UmVhZE9ubHlTdG9yYWdlOiAncmVhZC1vbmx5LXN0b3JhZ2UnXHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgR1BVU3RvcmFnZVRleHR1cmVBY2Nlc3MgPSB7XHJcblx0V3JpdGVPbmx5OiAnd3JpdGUtb25seScsXHJcblx0UmVhZE9ubHk6ICdyZWFkLW9ubHknLFxyXG5cdFJlYWRXcml0ZTogJ3JlYWQtd3JpdGUnLFxyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IEdQVVNhbXBsZXJCaW5kaW5nVHlwZSA9IHtcclxuXHRGaWx0ZXJpbmc6ICdmaWx0ZXJpbmcnLFxyXG5cdE5vbkZpbHRlcmluZzogJ25vbi1maWx0ZXJpbmcnLFxyXG5cdENvbXBhcmlzb246ICdjb21wYXJpc29uJ1xyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IEdQVVRleHR1cmVTYW1wbGVUeXBlID0ge1xyXG5cdEZsb2F0OiAnZmxvYXQnLFxyXG5cdFVuZmlsdGVyYWJsZUZsb2F0OiAndW5maWx0ZXJhYmxlLWZsb2F0JyxcclxuXHREZXB0aDogJ2RlcHRoJyxcclxuXHRTSW50OiAnc2ludCcsXHJcblx0VUludDogJ3VpbnQnXHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgR1BVVGV4dHVyZURpbWVuc2lvbiA9IHtcclxuXHRPbmVEOiAnMWQnLFxyXG5cdFR3b0Q6ICcyZCcsXHJcblx0VGhyZWVEOiAnM2QnXHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgR1BVVGV4dHVyZVZpZXdEaW1lbnNpb24gPSB7XHJcblx0T25lRDogJzFkJyxcclxuXHRUd29EOiAnMmQnLFxyXG5cdFR3b0RBcnJheTogJzJkLWFycmF5JyxcclxuXHRDdWJlOiAnY3ViZScsXHJcblx0Q3ViZUFycmF5OiAnY3ViZS1hcnJheScsXHJcblx0VGhyZWVEOiAnM2QnXHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgR1BVVGV4dHVyZUFzcGVjdCA9IHtcclxuXHRBbGw6ICdhbGwnLFxyXG5cdFN0ZW5jaWxPbmx5OiAnc3RlbmNpbC1vbmx5JyxcclxuXHREZXB0aE9ubHk6ICdkZXB0aC1vbmx5J1xyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IEdQVUlucHV0U3RlcE1vZGUgPSB7XHJcblx0VmVydGV4OiAndmVydGV4JyxcclxuXHRJbnN0YW5jZTogJ2luc3RhbmNlJ1xyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IEdQVUZlYXR1cmVOYW1lID0ge1xyXG5cdERlcHRoQ2xpcENvbnRyb2w6ICdkZXB0aC1jbGlwLWNvbnRyb2wnLFxyXG5cdERlcHRoMzJGbG9hdFN0ZW5jaWw4OiAnZGVwdGgzMmZsb2F0LXN0ZW5jaWw4JyxcclxuXHRUZXh0dXJlQ29tcHJlc3Npb25CQzogJ3RleHR1cmUtY29tcHJlc3Npb24tYmMnLFxyXG5cdFRleHR1cmVDb21wcmVzc2lvbkVUQzI6ICd0ZXh0dXJlLWNvbXByZXNzaW9uLWV0YzInLFxyXG5cdFRleHR1cmVDb21wcmVzc2lvbkFTVEM6ICd0ZXh0dXJlLWNvbXByZXNzaW9uLWFzdGMnLFxyXG5cdFRpbWVzdGFtcFF1ZXJ5OiAndGltZXN0YW1wLXF1ZXJ5JyxcclxuXHRJbmRpcmVjdEZpcnN0SW5zdGFuY2U6ICdpbmRpcmVjdC1maXJzdC1pbnN0YW5jZScsXHJcblx0U2hhZGVyRjE2OiAnc2hhZGVyLWYxNicsXHJcblx0UkcxMUIxMFVGbG9hdDogJ3JnMTFiMTB1ZmxvYXQtcmVuZGVyYWJsZScsXHJcblx0QkdSQThVTm9ybVN0b3JhZ2U6ICdiZ3JhOHVub3JtLXN0b3JhZ2UnLFxyXG5cdEZsb2F0MzJGaWx0ZXJhYmxlOiAnZmxvYXQzMi1maWx0ZXJhYmxlJyxcclxuXHRDbGlwRGlzdGFuY2VzOiAnY2xpcC1kaXN0YW5jZXMnLFxyXG5cdER1YWxTb3VyY2VCbGVuZGluZzogJ2R1YWwtc291cmNlLWJsZW5kaW5nJyxcclxuXHRTdWJncm91cHM6ICdzdWJncm91cHMnXHJcbn07XHJcbiIsImltcG9ydCBCaW5kaW5nIGZyb20gJy4vQmluZGluZy5qcyc7XHJcblxyXG5jbGFzcyBTYW1wbGVyIGV4dGVuZHMgQmluZGluZyB7XHJcblxyXG5cdGNvbnN0cnVjdG9yKCBuYW1lLCB0ZXh0dXJlICkge1xyXG5cclxuXHRcdHN1cGVyKCBuYW1lICk7XHJcblxyXG5cdFx0dGhpcy50ZXh0dXJlID0gdGV4dHVyZTtcclxuXHRcdHRoaXMudmVyc2lvbiA9IHRleHR1cmUgPyB0ZXh0dXJlLnZlcnNpb24gOiAwO1xyXG5cclxuXHRcdHRoaXMuaXNTYW1wbGVyID0gdHJ1ZTtcclxuXHJcblx0fVxyXG5cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgU2FtcGxlcjtcclxuIiwiaW1wb3J0IFNhbXBsZXIgZnJvbSAnLi4vU2FtcGxlci5qcyc7XHJcblxyXG5jbGFzcyBOb2RlU2FtcGxlciBleHRlbmRzIFNhbXBsZXIge1xyXG5cclxuXHRjb25zdHJ1Y3RvciggbmFtZSwgdGV4dHVyZU5vZGUsIGdyb3VwTm9kZSApIHtcclxuXHJcblx0XHRzdXBlciggbmFtZSwgdGV4dHVyZU5vZGUgPyB0ZXh0dXJlTm9kZS52YWx1ZSA6IG51bGwgKTtcclxuXHJcblx0XHR0aGlzLnRleHR1cmVOb2RlID0gdGV4dHVyZU5vZGU7XHJcblx0XHR0aGlzLmdyb3VwTm9kZSA9IGdyb3VwTm9kZTtcclxuXHJcblx0fVxyXG5cclxuXHR1cGRhdGUoKSB7XHJcblxyXG5cdFx0dGhpcy50ZXh0dXJlID0gdGhpcy50ZXh0dXJlTm9kZS52YWx1ZTtcclxuXHJcblx0fVxyXG5cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgTm9kZVNhbXBsZXI7XHJcbiIsImltcG9ydCBCdWZmZXIgZnJvbSAnLi9CdWZmZXIuanMnO1xyXG5cclxuY2xhc3MgU3RvcmFnZUJ1ZmZlciBleHRlbmRzIEJ1ZmZlciB7XHJcblxyXG5cdGNvbnN0cnVjdG9yKCBuYW1lLCBhdHRyaWJ1dGUgKSB7XHJcblxyXG5cdFx0c3VwZXIoIG5hbWUsIGF0dHJpYnV0ZSA/IGF0dHJpYnV0ZS5hcnJheSA6IG51bGwgKTtcclxuXHJcblx0XHR0aGlzLmF0dHJpYnV0ZSA9IGF0dHJpYnV0ZTtcclxuXHJcblx0XHR0aGlzLmlzU3RvcmFnZUJ1ZmZlciA9IHRydWU7XHJcblxyXG5cdH1cclxuXHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IFN0b3JhZ2VCdWZmZXI7XHJcbiIsImltcG9ydCBTdG9yYWdlQnVmZmVyIGZyb20gJy4uL1N0b3JhZ2VCdWZmZXIuanMnO1xyXG5pbXBvcnQgeyBOb2RlQWNjZXNzIH0gZnJvbSAnLi4vLi4vLi4vbm9kZXMvY29yZS9jb25zdGFudHMuanMnO1xyXG5cclxubGV0IF9pZCA9IDA7XHJcblxyXG5jbGFzcyBOb2RlU3RvcmFnZUJ1ZmZlciBleHRlbmRzIFN0b3JhZ2VCdWZmZXIge1xyXG5cclxuXHRjb25zdHJ1Y3Rvciggbm9kZVVuaWZvcm0sIGdyb3VwTm9kZSApIHtcclxuXHJcblx0XHRzdXBlciggJ1N0b3JhZ2VCdWZmZXJfJyArIF9pZCArKywgbm9kZVVuaWZvcm0gPyBub2RlVW5pZm9ybS52YWx1ZSA6IG51bGwgKTtcclxuXHJcblx0XHR0aGlzLm5vZGVVbmlmb3JtID0gbm9kZVVuaWZvcm07XHJcblx0XHR0aGlzLmFjY2VzcyA9IG5vZGVVbmlmb3JtID8gbm9kZVVuaWZvcm0uYWNjZXNzIDogTm9kZUFjY2Vzcy5SRUFEX1dSSVRFO1xyXG5cdFx0dGhpcy5ncm91cE5vZGUgPSBncm91cE5vZGU7XHJcblxyXG5cdH1cclxuXHJcblx0Z2V0IGJ1ZmZlcigpIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5ub2RlVW5pZm9ybS52YWx1ZTtcclxuXHJcblx0fVxyXG5cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgTm9kZVN0b3JhZ2VCdWZmZXI7XHJcbiIsImltcG9ydCBEYXRhTWFwIGZyb20gJy4uLy4uL2NvbW1vbi9EYXRhTWFwLmpzJztcclxuaW1wb3J0IHsgR1BVVGV4dHVyZVZpZXdEaW1lbnNpb24sIEdQVUluZGV4Rm9ybWF0LCBHUFVGaWx0ZXJNb2RlLCBHUFVQcmltaXRpdmVUb3BvbG9neSwgR1BVTG9hZE9wLCBHUFVTdG9yZU9wIH0gZnJvbSAnLi9XZWJHUFVDb25zdGFudHMuanMnO1xyXG5cclxuY2xhc3MgV2ViR1BVVGV4dHVyZVBhc3NVdGlscyBleHRlbmRzIERhdGFNYXAge1xyXG5cclxuXHRjb25zdHJ1Y3RvciggZGV2aWNlICkge1xyXG5cclxuXHRcdHN1cGVyKCk7XHJcblxyXG5cdFx0dGhpcy5kZXZpY2UgPSBkZXZpY2U7XHJcblxyXG5cdFx0Y29uc3QgbWlwbWFwVmVydGV4U291cmNlID0gYFxyXG5zdHJ1Y3QgVmFyeXNTdHJ1Y3Qge1xyXG5cdEBidWlsdGluKCBwb3NpdGlvbiApIFBvc2l0aW9uOiB2ZWM0PGYzMj4sXHJcblx0QGxvY2F0aW9uKCAwICkgdlRleCA6IHZlYzI8ZjMyPlxyXG59O1xyXG5cclxuQHZlcnRleFxyXG5mbiBtYWluKCBAYnVpbHRpbiggdmVydGV4X2luZGV4ICkgdmVydGV4SW5kZXggOiB1MzIgKSAtPiBWYXJ5c1N0cnVjdCB7XHJcblxyXG5cdHZhciBWYXJ5cyA6IFZhcnlzU3RydWN0O1xyXG5cclxuXHR2YXIgcG9zID0gYXJyYXk8IHZlYzI8ZjMyPiwgNCA+KFxyXG5cdFx0dmVjMjxmMzI+KCAtMS4wLCAgMS4wICksXHJcblx0XHR2ZWMyPGYzMj4oICAxLjAsICAxLjAgKSxcclxuXHRcdHZlYzI8ZjMyPiggLTEuMCwgLTEuMCApLFxyXG5cdFx0dmVjMjxmMzI+KCAgMS4wLCAtMS4wIClcclxuXHQpO1xyXG5cclxuXHR2YXIgdGV4ID0gYXJyYXk8IHZlYzI8ZjMyPiwgNCA+KFxyXG5cdFx0dmVjMjxmMzI+KCAwLjAsIDAuMCApLFxyXG5cdFx0dmVjMjxmMzI+KCAxLjAsIDAuMCApLFxyXG5cdFx0dmVjMjxmMzI+KCAwLjAsIDEuMCApLFxyXG5cdFx0dmVjMjxmMzI+KCAxLjAsIDEuMCApXHJcblx0KTtcclxuXHJcblx0VmFyeXMudlRleCA9IHRleFsgdmVydGV4SW5kZXggXTtcclxuXHRWYXJ5cy5Qb3NpdGlvbiA9IHZlYzQ8ZjMyPiggcG9zWyB2ZXJ0ZXhJbmRleCBdLCAwLjAsIDEuMCApO1xyXG5cclxuXHRyZXR1cm4gVmFyeXM7XHJcblxyXG59XHJcbmA7XHJcblxyXG5cdFx0Y29uc3QgbWlwbWFwRnJhZ21lbnRTb3VyY2UgPSBgXHJcbkBncm91cCggMCApIEBiaW5kaW5nKCAwIClcclxudmFyIGltZ1NhbXBsZXIgOiBzYW1wbGVyO1xyXG5cclxuQGdyb3VwKCAwICkgQGJpbmRpbmcoIDEgKVxyXG52YXIgaW1nIDogdGV4dHVyZV8yZDxmMzI+O1xyXG5cclxuQGZyYWdtZW50XHJcbmZuIG1haW4oIEBsb2NhdGlvbiggMCApIHZUZXggOiB2ZWMyPGYzMj4gKSAtPiBAbG9jYXRpb24oIDAgKSB2ZWM0PGYzMj4ge1xyXG5cclxuXHRyZXR1cm4gdGV4dHVyZVNhbXBsZSggaW1nLCBpbWdTYW1wbGVyLCB2VGV4ICk7XHJcblxyXG59XHJcbmA7XHJcblxyXG5cdFx0Y29uc3QgZmxpcFlGcmFnbWVudFNvdXJjZSA9IGBcclxuQGdyb3VwKCAwICkgQGJpbmRpbmcoIDAgKVxyXG52YXIgaW1nU2FtcGxlciA6IHNhbXBsZXI7XHJcblxyXG5AZ3JvdXAoIDAgKSBAYmluZGluZyggMSApXHJcbnZhciBpbWcgOiB0ZXh0dXJlXzJkPGYzMj47XHJcblxyXG5AZnJhZ21lbnRcclxuZm4gbWFpbiggQGxvY2F0aW9uKCAwICkgdlRleCA6IHZlYzI8ZjMyPiApIC0+IEBsb2NhdGlvbiggMCApIHZlYzQ8ZjMyPiB7XHJcblxyXG5cdHJldHVybiB0ZXh0dXJlU2FtcGxlKCBpbWcsIGltZ1NhbXBsZXIsIHZlYzIoIHZUZXgueCwgMS4wIC0gdlRleC55ICkgKTtcclxuXHJcbn1cclxuYDtcclxuXHRcdHRoaXMubWlwbWFwU2FtcGxlciA9IGRldmljZS5jcmVhdGVTYW1wbGVyKCB7IG1pbkZpbHRlcjogR1BVRmlsdGVyTW9kZS5MaW5lYXIgfSApO1xyXG5cdFx0dGhpcy5mbGlwWVNhbXBsZXIgPSBkZXZpY2UuY3JlYXRlU2FtcGxlciggeyBtaW5GaWx0ZXI6IEdQVUZpbHRlck1vZGUuTmVhcmVzdCB9ICk7IC8vQFRPRE8/OiBDb25zaWRlciB1c2luZyB0ZXh0dXJlTG9hZCgpXHJcblxyXG5cdFx0Ly8gV2UnbGwgbmVlZCBhIG5ldyBwaXBlbGluZSBmb3IgZXZlcnkgdGV4dHVyZSBmb3JtYXQgdXNlZC5cclxuXHRcdHRoaXMudHJhbnNmZXJQaXBlbGluZXMgPSB7fTtcclxuXHRcdHRoaXMuZmxpcFlQaXBlbGluZXMgPSB7fTtcclxuXHJcblx0XHR0aGlzLm1pcG1hcFZlcnRleFNoYWRlck1vZHVsZSA9IGRldmljZS5jcmVhdGVTaGFkZXJNb2R1bGUoIHtcclxuXHRcdFx0bGFiZWw6ICdtaXBtYXBWZXJ0ZXgnLFxyXG5cdFx0XHRjb2RlOiBtaXBtYXBWZXJ0ZXhTb3VyY2VcclxuXHRcdH0gKTtcclxuXHJcblx0XHR0aGlzLm1pcG1hcEZyYWdtZW50U2hhZGVyTW9kdWxlID0gZGV2aWNlLmNyZWF0ZVNoYWRlck1vZHVsZSgge1xyXG5cdFx0XHRsYWJlbDogJ21pcG1hcEZyYWdtZW50JyxcclxuXHRcdFx0Y29kZTogbWlwbWFwRnJhZ21lbnRTb3VyY2VcclxuXHRcdH0gKTtcclxuXHJcblx0XHR0aGlzLmZsaXBZRnJhZ21lbnRTaGFkZXJNb2R1bGUgPSBkZXZpY2UuY3JlYXRlU2hhZGVyTW9kdWxlKCB7XHJcblx0XHRcdGxhYmVsOiAnZmxpcFlGcmFnbWVudCcsXHJcblx0XHRcdGNvZGU6IGZsaXBZRnJhZ21lbnRTb3VyY2VcclxuXHRcdH0gKTtcclxuXHJcblx0fVxyXG5cclxuXHRnZXRUcmFuc2ZlclBpcGVsaW5lKCBmb3JtYXQgKSB7XHJcblxyXG5cdFx0bGV0IHBpcGVsaW5lID0gdGhpcy50cmFuc2ZlclBpcGVsaW5lc1sgZm9ybWF0IF07XHJcblxyXG5cdFx0aWYgKCBwaXBlbGluZSA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0cGlwZWxpbmUgPSB0aGlzLmRldmljZS5jcmVhdGVSZW5kZXJQaXBlbGluZSgge1xyXG5cdFx0XHRcdGxhYmVsOiBgbWlwbWFwLSR7IGZvcm1hdCB9YCxcclxuXHRcdFx0XHR2ZXJ0ZXg6IHtcclxuXHRcdFx0XHRcdG1vZHVsZTogdGhpcy5taXBtYXBWZXJ0ZXhTaGFkZXJNb2R1bGUsXHJcblx0XHRcdFx0XHRlbnRyeVBvaW50OiAnbWFpbidcclxuXHRcdFx0XHR9LFxyXG5cdFx0XHRcdGZyYWdtZW50OiB7XHJcblx0XHRcdFx0XHRtb2R1bGU6IHRoaXMubWlwbWFwRnJhZ21lbnRTaGFkZXJNb2R1bGUsXHJcblx0XHRcdFx0XHRlbnRyeVBvaW50OiAnbWFpbicsXHJcblx0XHRcdFx0XHR0YXJnZXRzOiBbIHsgZm9ybWF0IH0gXVxyXG5cdFx0XHRcdH0sXHJcblx0XHRcdFx0cHJpbWl0aXZlOiB7XHJcblx0XHRcdFx0XHR0b3BvbG9neTogR1BVUHJpbWl0aXZlVG9wb2xvZ3kuVHJpYW5nbGVTdHJpcCxcclxuXHRcdFx0XHRcdHN0cmlwSW5kZXhGb3JtYXQ6IEdQVUluZGV4Rm9ybWF0LlVpbnQzMlxyXG5cdFx0XHRcdH0sXHJcblx0XHRcdFx0bGF5b3V0OiAnYXV0bydcclxuXHRcdFx0fSApO1xyXG5cclxuXHRcdFx0dGhpcy50cmFuc2ZlclBpcGVsaW5lc1sgZm9ybWF0IF0gPSBwaXBlbGluZTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHBpcGVsaW5lO1xyXG5cclxuXHR9XHJcblxyXG5cdGdldEZsaXBZUGlwZWxpbmUoIGZvcm1hdCApIHtcclxuXHJcblx0XHRsZXQgcGlwZWxpbmUgPSB0aGlzLmZsaXBZUGlwZWxpbmVzWyBmb3JtYXQgXTtcclxuXHJcblx0XHRpZiAoIHBpcGVsaW5lID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRwaXBlbGluZSA9IHRoaXMuZGV2aWNlLmNyZWF0ZVJlbmRlclBpcGVsaW5lKCB7XHJcblx0XHRcdFx0bGFiZWw6IGBmbGlwWS0keyBmb3JtYXQgfWAsXHJcblx0XHRcdFx0dmVydGV4OiB7XHJcblx0XHRcdFx0XHRtb2R1bGU6IHRoaXMubWlwbWFwVmVydGV4U2hhZGVyTW9kdWxlLFxyXG5cdFx0XHRcdFx0ZW50cnlQb2ludDogJ21haW4nXHJcblx0XHRcdFx0fSxcclxuXHRcdFx0XHRmcmFnbWVudDoge1xyXG5cdFx0XHRcdFx0bW9kdWxlOiB0aGlzLmZsaXBZRnJhZ21lbnRTaGFkZXJNb2R1bGUsXHJcblx0XHRcdFx0XHRlbnRyeVBvaW50OiAnbWFpbicsXHJcblx0XHRcdFx0XHR0YXJnZXRzOiBbIHsgZm9ybWF0IH0gXVxyXG5cdFx0XHRcdH0sXHJcblx0XHRcdFx0cHJpbWl0aXZlOiB7XHJcblx0XHRcdFx0XHR0b3BvbG9neTogR1BVUHJpbWl0aXZlVG9wb2xvZ3kuVHJpYW5nbGVTdHJpcCxcclxuXHRcdFx0XHRcdHN0cmlwSW5kZXhGb3JtYXQ6IEdQVUluZGV4Rm9ybWF0LlVpbnQzMlxyXG5cdFx0XHRcdH0sXHJcblx0XHRcdFx0bGF5b3V0OiAnYXV0bydcclxuXHRcdFx0fSApO1xyXG5cclxuXHRcdFx0dGhpcy5mbGlwWVBpcGVsaW5lc1sgZm9ybWF0IF0gPSBwaXBlbGluZTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHBpcGVsaW5lO1xyXG5cclxuXHR9XHJcblxyXG5cdGZsaXBZKCB0ZXh0dXJlR1BVLCB0ZXh0dXJlR1BVRGVzY3JpcHRvciwgYmFzZUFycmF5TGF5ZXIgPSAwICkge1xyXG5cclxuXHRcdGNvbnN0IGZvcm1hdCA9IHRleHR1cmVHUFVEZXNjcmlwdG9yLmZvcm1hdDtcclxuXHRcdGNvbnN0IHsgd2lkdGgsIGhlaWdodCB9ID0gdGV4dHVyZUdQVURlc2NyaXB0b3Iuc2l6ZTtcclxuXHJcblx0XHRjb25zdCB0cmFuc2ZlclBpcGVsaW5lID0gdGhpcy5nZXRUcmFuc2ZlclBpcGVsaW5lKCBmb3JtYXQgKTtcclxuXHRcdGNvbnN0IGZsaXBZUGlwZWxpbmUgPSB0aGlzLmdldEZsaXBZUGlwZWxpbmUoIGZvcm1hdCApO1xyXG5cclxuXHRcdGNvbnN0IHRlbXBUZXh0dXJlID0gdGhpcy5kZXZpY2UuY3JlYXRlVGV4dHVyZSgge1xyXG5cdFx0XHRzaXplOiB7IHdpZHRoLCBoZWlnaHQsIGRlcHRoT3JBcnJheUxheWVyczogMSB9LFxyXG5cdFx0XHRmb3JtYXQsXHJcblx0XHRcdHVzYWdlOiBHUFVUZXh0dXJlVXNhZ2UuUkVOREVSX0FUVEFDSE1FTlQgfCBHUFVUZXh0dXJlVXNhZ2UuVEVYVFVSRV9CSU5ESU5HXHJcblx0XHR9ICk7XHJcblxyXG5cdFx0Y29uc3Qgc3JjVmlldyA9IHRleHR1cmVHUFUuY3JlYXRlVmlldygge1xyXG5cdFx0XHRiYXNlTWlwTGV2ZWw6IDAsXHJcblx0XHRcdG1pcExldmVsQ291bnQ6IDEsXHJcblx0XHRcdGRpbWVuc2lvbjogR1BVVGV4dHVyZVZpZXdEaW1lbnNpb24uVHdvRCxcclxuXHRcdFx0YmFzZUFycmF5TGF5ZXJcclxuXHRcdH0gKTtcclxuXHJcblx0XHRjb25zdCBkc3RWaWV3ID0gdGVtcFRleHR1cmUuY3JlYXRlVmlldygge1xyXG5cdFx0XHRiYXNlTWlwTGV2ZWw6IDAsXHJcblx0XHRcdG1pcExldmVsQ291bnQ6IDEsXHJcblx0XHRcdGRpbWVuc2lvbjogR1BVVGV4dHVyZVZpZXdEaW1lbnNpb24uVHdvRCxcclxuXHRcdFx0YmFzZUFycmF5TGF5ZXI6IDBcclxuXHRcdH0gKTtcclxuXHJcblx0XHRjb25zdCBjb21tYW5kRW5jb2RlciA9IHRoaXMuZGV2aWNlLmNyZWF0ZUNvbW1hbmRFbmNvZGVyKCB7fSApO1xyXG5cclxuXHRcdGNvbnN0IHBhc3MgPSAoIHBpcGVsaW5lLCBzb3VyY2VWaWV3LCBkZXN0aW5hdGlvblZpZXcgKSA9PiB7XHJcblxyXG5cdFx0XHRjb25zdCBiaW5kR3JvdXBMYXlvdXQgPSBwaXBlbGluZS5nZXRCaW5kR3JvdXBMYXlvdXQoIDAgKTsgLy8gQFRPRE86IENvbnNpZGVyIG1ha2luZyB0aGlzIHN0YXRpYy5cclxuXHJcblx0XHRcdGNvbnN0IGJpbmRHcm91cCA9IHRoaXMuZGV2aWNlLmNyZWF0ZUJpbmRHcm91cCgge1xyXG5cdFx0XHRcdGxheW91dDogYmluZEdyb3VwTGF5b3V0LFxyXG5cdFx0XHRcdGVudHJpZXM6IFsge1xyXG5cdFx0XHRcdFx0YmluZGluZzogMCxcclxuXHRcdFx0XHRcdHJlc291cmNlOiB0aGlzLmZsaXBZU2FtcGxlclxyXG5cdFx0XHRcdH0sIHtcclxuXHRcdFx0XHRcdGJpbmRpbmc6IDEsXHJcblx0XHRcdFx0XHRyZXNvdXJjZTogc291cmNlVmlld1xyXG5cdFx0XHRcdH0gXVxyXG5cdFx0XHR9ICk7XHJcblxyXG5cdFx0XHRjb25zdCBwYXNzRW5jb2RlciA9IGNvbW1hbmRFbmNvZGVyLmJlZ2luUmVuZGVyUGFzcygge1xyXG5cdFx0XHRcdGNvbG9yQXR0YWNobWVudHM6IFsge1xyXG5cdFx0XHRcdFx0dmlldzogZGVzdGluYXRpb25WaWV3LFxyXG5cdFx0XHRcdFx0bG9hZE9wOiBHUFVMb2FkT3AuQ2xlYXIsXHJcblx0XHRcdFx0XHRzdG9yZU9wOiBHUFVTdG9yZU9wLlN0b3JlLFxyXG5cdFx0XHRcdFx0Y2xlYXJWYWx1ZTogWyAwLCAwLCAwLCAwIF1cclxuXHRcdFx0XHR9IF1cclxuXHRcdFx0fSApO1xyXG5cclxuXHRcdFx0cGFzc0VuY29kZXIuc2V0UGlwZWxpbmUoIHBpcGVsaW5lICk7XHJcblx0XHRcdHBhc3NFbmNvZGVyLnNldEJpbmRHcm91cCggMCwgYmluZEdyb3VwICk7XHJcblx0XHRcdHBhc3NFbmNvZGVyLmRyYXcoIDQsIDEsIDAsIDAgKTtcclxuXHRcdFx0cGFzc0VuY29kZXIuZW5kKCk7XHJcblxyXG5cdFx0fTtcclxuXHJcblx0XHRwYXNzKCB0cmFuc2ZlclBpcGVsaW5lLCBzcmNWaWV3LCBkc3RWaWV3ICk7XHJcblx0XHRwYXNzKCBmbGlwWVBpcGVsaW5lLCBkc3RWaWV3LCBzcmNWaWV3ICk7XHJcblxyXG5cdFx0dGhpcy5kZXZpY2UucXVldWUuc3VibWl0KCBbIGNvbW1hbmRFbmNvZGVyLmZpbmlzaCgpIF0gKTtcclxuXHJcblx0XHR0ZW1wVGV4dHVyZS5kZXN0cm95KCk7XHJcblxyXG5cdH1cclxuXHJcblx0Z2VuZXJhdGVNaXBtYXBzKCB0ZXh0dXJlR1BVLCB0ZXh0dXJlR1BVRGVzY3JpcHRvciwgYmFzZUFycmF5TGF5ZXIgPSAwICkge1xyXG5cclxuXHRcdGNvbnN0IHRleHR1cmVEYXRhID0gdGhpcy5nZXQoIHRleHR1cmVHUFUgKTtcclxuXHJcblx0XHRpZiAoIHRleHR1cmVEYXRhLnVzZUNvdW50ID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHR0ZXh0dXJlRGF0YS51c2VDb3VudCA9IDA7XHJcblx0XHRcdHRleHR1cmVEYXRhLmxheWVycyA9IFtdO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRjb25zdCBwYXNzZXMgPSB0ZXh0dXJlRGF0YS5sYXllcnNbIGJhc2VBcnJheUxheWVyIF0gfHwgdGhpcy5fbWlwbWFwQ3JlYXRlQnVuZGxlcyggdGV4dHVyZUdQVSwgdGV4dHVyZUdQVURlc2NyaXB0b3IsIGJhc2VBcnJheUxheWVyICk7XHJcblxyXG5cdFx0Y29uc3QgY29tbWFuZEVuY29kZXIgPSB0aGlzLmRldmljZS5jcmVhdGVDb21tYW5kRW5jb2Rlcigge30gKTtcclxuXHJcblx0XHR0aGlzLl9taXBtYXBSdW5CdW5kbGVzKCBjb21tYW5kRW5jb2RlciwgcGFzc2VzICk7XHJcblxyXG5cdFx0dGhpcy5kZXZpY2UucXVldWUuc3VibWl0KCBbIGNvbW1hbmRFbmNvZGVyLmZpbmlzaCgpIF0gKTtcclxuXHJcblx0XHRpZiAoIHRleHR1cmVEYXRhLnVzZUNvdW50ICE9PSAwICkgdGV4dHVyZURhdGEubGF5ZXJzWyBiYXNlQXJyYXlMYXllciBdID0gcGFzc2VzO1xyXG5cclxuXHRcdHRleHR1cmVEYXRhLnVzZUNvdW50ICsrO1xyXG5cclxuXHR9XHJcblxyXG5cdF9taXBtYXBDcmVhdGVCdW5kbGVzKCB0ZXh0dXJlR1BVLCB0ZXh0dXJlR1BVRGVzY3JpcHRvciwgYmFzZUFycmF5TGF5ZXIgKSB7XHJcblxyXG5cdFx0Y29uc3QgcGlwZWxpbmUgPSB0aGlzLmdldFRyYW5zZmVyUGlwZWxpbmUoIHRleHR1cmVHUFVEZXNjcmlwdG9yLmZvcm1hdCApO1xyXG5cclxuXHRcdGNvbnN0IGJpbmRHcm91cExheW91dCA9IHBpcGVsaW5lLmdldEJpbmRHcm91cExheW91dCggMCApOyAvLyBAVE9ETzogQ29uc2lkZXIgbWFraW5nIHRoaXMgc3RhdGljLlxyXG5cclxuXHRcdGxldCBzcmNWaWV3ID0gdGV4dHVyZUdQVS5jcmVhdGVWaWV3KCB7XHJcblx0XHRcdGJhc2VNaXBMZXZlbDogMCxcclxuXHRcdFx0bWlwTGV2ZWxDb3VudDogMSxcclxuXHRcdFx0ZGltZW5zaW9uOiBHUFVUZXh0dXJlVmlld0RpbWVuc2lvbi5Ud29ELFxyXG5cdFx0XHRiYXNlQXJyYXlMYXllclxyXG5cdFx0fSApO1xyXG5cclxuXHRcdGNvbnN0IHBhc3NlcyA9IFtdO1xyXG5cclxuXHRcdGZvciAoIGxldCBpID0gMTsgaSA8IHRleHR1cmVHUFVEZXNjcmlwdG9yLm1pcExldmVsQ291bnQ7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRjb25zdCBiaW5kR3JvdXAgPSB0aGlzLmRldmljZS5jcmVhdGVCaW5kR3JvdXAoIHtcclxuXHRcdFx0XHRsYXlvdXQ6IGJpbmRHcm91cExheW91dCxcclxuXHRcdFx0XHRlbnRyaWVzOiBbIHtcclxuXHRcdFx0XHRcdGJpbmRpbmc6IDAsXHJcblx0XHRcdFx0XHRyZXNvdXJjZTogdGhpcy5taXBtYXBTYW1wbGVyXHJcblx0XHRcdFx0fSwge1xyXG5cdFx0XHRcdFx0YmluZGluZzogMSxcclxuXHRcdFx0XHRcdHJlc291cmNlOiBzcmNWaWV3XHJcblx0XHRcdFx0fSBdXHJcblx0XHRcdH0gKTtcclxuXHJcblx0XHRcdGNvbnN0IGRzdFZpZXcgPSB0ZXh0dXJlR1BVLmNyZWF0ZVZpZXcoIHtcclxuXHRcdFx0XHRiYXNlTWlwTGV2ZWw6IGksXHJcblx0XHRcdFx0bWlwTGV2ZWxDb3VudDogMSxcclxuXHRcdFx0XHRkaW1lbnNpb246IEdQVVRleHR1cmVWaWV3RGltZW5zaW9uLlR3b0QsXHJcblx0XHRcdFx0YmFzZUFycmF5TGF5ZXJcclxuXHRcdFx0fSApO1xyXG5cclxuXHRcdFx0Y29uc3QgcGFzc0Rlc2NyaXB0b3IgPSB7XHJcblx0XHRcdFx0Y29sb3JBdHRhY2htZW50czogWyB7XHJcblx0XHRcdFx0XHR2aWV3OiBkc3RWaWV3LFxyXG5cdFx0XHRcdFx0bG9hZE9wOiBHUFVMb2FkT3AuQ2xlYXIsXHJcblx0XHRcdFx0XHRzdG9yZU9wOiBHUFVTdG9yZU9wLlN0b3JlLFxyXG5cdFx0XHRcdFx0Y2xlYXJWYWx1ZTogWyAwLCAwLCAwLCAwIF1cclxuXHRcdFx0XHR9IF1cclxuXHRcdFx0fTtcclxuXHJcblx0XHRcdGNvbnN0IHBhc3NFbmNvZGVyID0gdGhpcy5kZXZpY2UuY3JlYXRlUmVuZGVyQnVuZGxlRW5jb2Rlcigge1xyXG5cdFx0XHRcdGNvbG9yRm9ybWF0czogWyB0ZXh0dXJlR1BVRGVzY3JpcHRvci5mb3JtYXQgXVxyXG5cdFx0XHR9ICk7XHJcblxyXG5cdFx0XHRwYXNzRW5jb2Rlci5zZXRQaXBlbGluZSggcGlwZWxpbmUgKTtcclxuXHRcdFx0cGFzc0VuY29kZXIuc2V0QmluZEdyb3VwKCAwLCBiaW5kR3JvdXAgKTtcclxuXHRcdFx0cGFzc0VuY29kZXIuZHJhdyggNCwgMSwgMCwgMCApO1xyXG5cclxuXHRcdFx0cGFzc2VzLnB1c2goIHtcclxuXHRcdFx0XHRyZW5kZXJCdW5kbGVzOiBbIHBhc3NFbmNvZGVyLmZpbmlzaCgpIF0sXHJcblx0XHRcdFx0cGFzc0Rlc2NyaXB0b3JcclxuXHRcdFx0fSApO1xyXG5cclxuXHRcdFx0c3JjVmlldyA9IGRzdFZpZXc7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBwYXNzZXM7XHJcblxyXG5cdH1cclxuXHJcblx0X21pcG1hcFJ1bkJ1bmRsZXMoIGNvbW1hbmRFbmNvZGVyLCBwYXNzZXMgKSB7XHJcblxyXG5cdFx0Y29uc3QgbGV2ZWxzID0gcGFzc2VzLmxlbmd0aDtcclxuXHJcblx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCBsZXZlbHM7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRjb25zdCBwYXNzID0gcGFzc2VzWyBpIF07XHJcblxyXG5cdFx0XHRjb25zdCBwYXNzRW5jb2RlciA9IGNvbW1hbmRFbmNvZGVyLmJlZ2luUmVuZGVyUGFzcyggcGFzcy5wYXNzRGVzY3JpcHRvciApO1xyXG5cclxuXHRcdFx0cGFzc0VuY29kZXIuZXhlY3V0ZUJ1bmRsZXMoIHBhc3MucmVuZGVyQnVuZGxlcyApO1xyXG5cclxuXHRcdFx0cGFzc0VuY29kZXIuZW5kKCk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBXZWJHUFVUZXh0dXJlUGFzc1V0aWxzO1xyXG4iLCJpbXBvcnQge1xyXG5cdEdQVVRleHR1cmVGb3JtYXQsIEdQVUFkZHJlc3NNb2RlLCBHUFVGaWx0ZXJNb2RlLCBHUFVUZXh0dXJlRGltZW5zaW9uLCBHUFVGZWF0dXJlTmFtZVxyXG59IGZyb20gJy4vV2ViR1BVQ29uc3RhbnRzLmpzJztcclxuXHJcbmltcG9ydCBXZWJHUFVUZXh0dXJlUGFzc1V0aWxzIGZyb20gJy4vV2ViR1BVVGV4dHVyZVBhc3NVdGlscy5qcyc7XHJcblxyXG5pbXBvcnQge1xyXG5cdEJ5dGVUeXBlLCBTaG9ydFR5cGUsXHJcblx0TmVhcmVzdEZpbHRlciwgTmVhcmVzdE1pcG1hcE5lYXJlc3RGaWx0ZXIsIE5lYXJlc3RNaXBtYXBMaW5lYXJGaWx0ZXIsXHJcblx0UmVwZWF0V3JhcHBpbmcsIE1pcnJvcmVkUmVwZWF0V3JhcHBpbmcsXHJcblx0UkdCX0VUQzJfRm9ybWF0LCBSR0JBX0VUQzJfRUFDX0Zvcm1hdCxcclxuXHRSR0JBRm9ybWF0LCBSR0JGb3JtYXQsIFJlZEZvcm1hdCwgUkdGb3JtYXQsIFJHQkFfUzNUQ19EWFQxX0Zvcm1hdCwgUkdCQV9TM1RDX0RYVDNfRm9ybWF0LCBSR0JBX1MzVENfRFhUNV9Gb3JtYXQsIFVuc2lnbmVkQnl0ZVR5cGUsIEZsb2F0VHlwZSwgSGFsZkZsb2F0VHlwZSwgU1JHQkNvbG9yU3BhY2UsIERlcHRoRm9ybWF0LCBEZXB0aFN0ZW5jaWxGb3JtYXQsXHJcblx0UkdCQV9BU1RDXzR4NF9Gb3JtYXQsIFJHQkFfQVNUQ181eDRfRm9ybWF0LCBSR0JBX0FTVENfNXg1X0Zvcm1hdCwgUkdCQV9BU1RDXzZ4NV9Gb3JtYXQsIFJHQkFfQVNUQ182eDZfRm9ybWF0LCBSR0JBX0FTVENfOHg1X0Zvcm1hdCwgUkdCQV9BU1RDXzh4Nl9Gb3JtYXQsIFJHQkFfQVNUQ184eDhfRm9ybWF0LCBSR0JBX0FTVENfMTB4NV9Gb3JtYXQsXHJcblx0UkdCQV9BU1RDXzEweDZfRm9ybWF0LCBSR0JBX0FTVENfMTB4OF9Gb3JtYXQsIFJHQkFfQVNUQ18xMHgxMF9Gb3JtYXQsIFJHQkFfQVNUQ18xMngxMF9Gb3JtYXQsIFJHQkFfQVNUQ18xMngxMl9Gb3JtYXQsIFVuc2lnbmVkSW50VHlwZSwgVW5zaWduZWRTaG9ydFR5cGUsIFVuc2lnbmVkSW50MjQ4VHlwZSwgVW5zaWduZWRJbnQ1OTk5VHlwZSxcclxuXHROZXZlckNvbXBhcmUsIEFsd2F5c0NvbXBhcmUsIExlc3NDb21wYXJlLCBMZXNzRXF1YWxDb21wYXJlLCBFcXVhbENvbXBhcmUsIEdyZWF0ZXJFcXVhbENvbXBhcmUsIEdyZWF0ZXJDb21wYXJlLCBOb3RFcXVhbENvbXBhcmUsIEludFR5cGUsIFJlZEludGVnZXJGb3JtYXQsIFJHSW50ZWdlckZvcm1hdCwgUkdCQUludGVnZXJGb3JtYXQsXHJcblx0Q3ViZVJlZmxlY3Rpb25NYXBwaW5nLCBDdWJlUmVmcmFjdGlvbk1hcHBpbmcsIEVxdWlyZWN0YW5ndWxhclJlZmxlY3Rpb25NYXBwaW5nLCBFcXVpcmVjdGFuZ3VsYXJSZWZyYWN0aW9uTWFwcGluZ1xyXG59IGZyb20gJy4uLy4uLy4uL2NvbnN0YW50cy5qcyc7XHJcbmltcG9ydCB7IEN1YmVUZXh0dXJlIH0gZnJvbSAnLi4vLi4vLi4vdGV4dHVyZXMvQ3ViZVRleHR1cmUuanMnO1xyXG5pbXBvcnQgeyBEZXB0aFRleHR1cmUgfSBmcm9tICcuLi8uLi8uLi90ZXh0dXJlcy9EZXB0aFRleHR1cmUuanMnO1xyXG5pbXBvcnQgeyBUZXh0dXJlIH0gZnJvbSAnLi4vLi4vLi4vdGV4dHVyZXMvVGV4dHVyZS5qcyc7XHJcblxyXG5jb25zdCBfY29tcGFyZVRvV2ViR1BVID0ge1xyXG5cdFsgTmV2ZXJDb21wYXJlIF06ICduZXZlcicsXHJcblx0WyBMZXNzQ29tcGFyZSBdOiAnbGVzcycsXHJcblx0WyBFcXVhbENvbXBhcmUgXTogJ2VxdWFsJyxcclxuXHRbIExlc3NFcXVhbENvbXBhcmUgXTogJ2xlc3MtZXF1YWwnLFxyXG5cdFsgR3JlYXRlckNvbXBhcmUgXTogJ2dyZWF0ZXInLFxyXG5cdFsgR3JlYXRlckVxdWFsQ29tcGFyZSBdOiAnZ3JlYXRlci1lcXVhbCcsXHJcblx0WyBBbHdheXNDb21wYXJlIF06ICdhbHdheXMnLFxyXG5cdFsgTm90RXF1YWxDb21wYXJlIF06ICdub3QtZXF1YWwnXHJcbn07XHJcblxyXG5jb25zdCBfZmxpcE1hcCA9IFsgMCwgMSwgMywgMiwgNCwgNSBdO1xyXG5cclxuY2xhc3MgV2ViR1BVVGV4dHVyZVV0aWxzIHtcclxuXHJcblx0Y29uc3RydWN0b3IoIGJhY2tlbmQgKSB7XHJcblxyXG5cdFx0dGhpcy5iYWNrZW5kID0gYmFja2VuZDtcclxuXHJcblx0XHR0aGlzLl9wYXNzVXRpbHMgPSBudWxsO1xyXG5cclxuXHRcdHRoaXMuZGVmYXVsdFRleHR1cmUgPSB7fTtcclxuXHRcdHRoaXMuZGVmYXVsdEN1YmVUZXh0dXJlID0ge307XHJcblx0XHR0aGlzLmRlZmF1bHRWaWRlb0ZyYW1lID0gbnVsbDtcclxuXHJcblx0XHR0aGlzLmNvbG9yQnVmZmVyID0gbnVsbDtcclxuXHJcblx0XHR0aGlzLmRlcHRoVGV4dHVyZSA9IG5ldyBEZXB0aFRleHR1cmUoKTtcclxuXHRcdHRoaXMuZGVwdGhUZXh0dXJlLm5hbWUgPSAnZGVwdGhCdWZmZXInO1xyXG5cclxuXHR9XHJcblxyXG5cdGNyZWF0ZVNhbXBsZXIoIHRleHR1cmUgKSB7XHJcblxyXG5cdFx0Y29uc3QgYmFja2VuZCA9IHRoaXMuYmFja2VuZDtcclxuXHRcdGNvbnN0IGRldmljZSA9IGJhY2tlbmQuZGV2aWNlO1xyXG5cclxuXHRcdGNvbnN0IHRleHR1cmVHUFUgPSBiYWNrZW5kLmdldCggdGV4dHVyZSApO1xyXG5cclxuXHRcdGNvbnN0IHNhbXBsZXJEZXNjcmlwdG9yR1BVID0ge1xyXG5cdFx0XHRhZGRyZXNzTW9kZVU6IHRoaXMuX2NvbnZlcnRBZGRyZXNzTW9kZSggdGV4dHVyZS53cmFwUyApLFxyXG5cdFx0XHRhZGRyZXNzTW9kZVY6IHRoaXMuX2NvbnZlcnRBZGRyZXNzTW9kZSggdGV4dHVyZS53cmFwVCApLFxyXG5cdFx0XHRhZGRyZXNzTW9kZVc6IHRoaXMuX2NvbnZlcnRBZGRyZXNzTW9kZSggdGV4dHVyZS53cmFwUiApLFxyXG5cdFx0XHRtYWdGaWx0ZXI6IHRoaXMuX2NvbnZlcnRGaWx0ZXJNb2RlKCB0ZXh0dXJlLm1hZ0ZpbHRlciApLFxyXG5cdFx0XHRtaW5GaWx0ZXI6IHRoaXMuX2NvbnZlcnRGaWx0ZXJNb2RlKCB0ZXh0dXJlLm1pbkZpbHRlciApLFxyXG5cdFx0XHRtaXBtYXBGaWx0ZXI6IHRoaXMuX2NvbnZlcnRGaWx0ZXJNb2RlKCB0ZXh0dXJlLm1pbkZpbHRlciApLFxyXG5cdFx0XHRtYXhBbmlzb3Ryb3B5OiAxXHJcblx0XHR9O1xyXG5cclxuXHRcdC8vIGFuaXNvdHJvcHkgY2FuIG9ubHkgYmUgdXNlZCB3aGVuIGFsbCBmaWx0ZXIgbW9kZXMgYXJlIHNldCB0byBsaW5lYXIuXHJcblxyXG5cdFx0aWYgKCBzYW1wbGVyRGVzY3JpcHRvckdQVS5tYWdGaWx0ZXIgPT09IEdQVUZpbHRlck1vZGUuTGluZWFyICYmIHNhbXBsZXJEZXNjcmlwdG9yR1BVLm1pbkZpbHRlciA9PT0gR1BVRmlsdGVyTW9kZS5MaW5lYXIgJiYgc2FtcGxlckRlc2NyaXB0b3JHUFUubWlwbWFwRmlsdGVyID09PSBHUFVGaWx0ZXJNb2RlLkxpbmVhciApIHtcclxuXHJcblx0XHRcdHNhbXBsZXJEZXNjcmlwdG9yR1BVLm1heEFuaXNvdHJvcHkgPSB0ZXh0dXJlLmFuaXNvdHJvcHk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggdGV4dHVyZS5pc0RlcHRoVGV4dHVyZSAmJiB0ZXh0dXJlLmNvbXBhcmVGdW5jdGlvbiAhPT0gbnVsbCApIHtcclxuXHJcblx0XHRcdHNhbXBsZXJEZXNjcmlwdG9yR1BVLmNvbXBhcmUgPSBfY29tcGFyZVRvV2ViR1BVWyB0ZXh0dXJlLmNvbXBhcmVGdW5jdGlvbiBdO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR0ZXh0dXJlR1BVLnNhbXBsZXIgPSBkZXZpY2UuY3JlYXRlU2FtcGxlciggc2FtcGxlckRlc2NyaXB0b3JHUFUgKTtcclxuXHJcblx0fVxyXG5cclxuXHRjcmVhdGVEZWZhdWx0VGV4dHVyZSggdGV4dHVyZSApIHtcclxuXHJcblx0XHRsZXQgdGV4dHVyZUdQVTtcclxuXHJcblx0XHRjb25zdCBmb3JtYXQgPSBnZXRGb3JtYXQoIHRleHR1cmUgKTtcclxuXHJcblx0XHRpZiAoIHRleHR1cmUuaXNDdWJlVGV4dHVyZSApIHtcclxuXHJcblx0XHRcdHRleHR1cmVHUFUgPSB0aGlzLl9nZXREZWZhdWx0Q3ViZVRleHR1cmVHUFUoIGZvcm1hdCApO1xyXG5cclxuXHRcdH0gZWxzZSBpZiAoIHRleHR1cmUuaXNWaWRlb1RleHR1cmUgKSB7XHJcblxyXG5cdFx0XHR0aGlzLmJhY2tlbmQuZ2V0KCB0ZXh0dXJlICkuZXh0ZXJuYWxUZXh0dXJlID0gdGhpcy5fZ2V0RGVmYXVsdFZpZGVvRnJhbWUoKTtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0dGV4dHVyZUdQVSA9IHRoaXMuX2dldERlZmF1bHRUZXh0dXJlR1BVKCBmb3JtYXQgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5iYWNrZW5kLmdldCggdGV4dHVyZSApLnRleHR1cmUgPSB0ZXh0dXJlR1BVO1xyXG5cclxuXHR9XHJcblxyXG5cdGNyZWF0ZVRleHR1cmUoIHRleHR1cmUsIG9wdGlvbnMgPSB7fSApIHtcclxuXHJcblx0XHRjb25zdCBiYWNrZW5kID0gdGhpcy5iYWNrZW5kO1xyXG5cdFx0Y29uc3QgdGV4dHVyZURhdGEgPSBiYWNrZW5kLmdldCggdGV4dHVyZSApO1xyXG5cclxuXHRcdGlmICggdGV4dHVyZURhdGEuaW5pdGlhbGl6ZWQgKSB7XHJcblxyXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoICdXZWJHUFVUZXh0dXJlVXRpbHM6IFRleHR1cmUgYWxyZWFkeSBpbml0aWFsaXplZC4nICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggb3B0aW9ucy5uZWVkc01pcG1hcHMgPT09IHVuZGVmaW5lZCApIG9wdGlvbnMubmVlZHNNaXBtYXBzID0gZmFsc2U7XHJcblx0XHRpZiAoIG9wdGlvbnMubGV2ZWxzID09PSB1bmRlZmluZWQgKSBvcHRpb25zLmxldmVscyA9IDE7XHJcblx0XHRpZiAoIG9wdGlvbnMuZGVwdGggPT09IHVuZGVmaW5lZCApIG9wdGlvbnMuZGVwdGggPSAxO1xyXG5cclxuXHRcdGNvbnN0IHsgd2lkdGgsIGhlaWdodCwgZGVwdGgsIGxldmVscyB9ID0gb3B0aW9ucztcclxuXHJcblx0XHRpZiAoIHRleHR1cmUuaXNGcmFtZWJ1ZmZlclRleHR1cmUgKSB7XHJcblxyXG5cdFx0XHRpZiAoIG9wdGlvbnMucmVuZGVyVGFyZ2V0ICkge1xyXG5cclxuXHRcdFx0XHRvcHRpb25zLmZvcm1hdCA9IHRoaXMuYmFja2VuZC51dGlscy5nZXRDdXJyZW50Q29sb3JGb3JtYXQoIG9wdGlvbnMucmVuZGVyVGFyZ2V0ICk7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRvcHRpb25zLmZvcm1hdCA9IHRoaXMuYmFja2VuZC51dGlscy5nZXRQcmVmZXJyZWRDYW52YXNGb3JtYXQoKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Y29uc3QgZGltZW5zaW9uID0gdGhpcy5fZ2V0RGltZW5zaW9uKCB0ZXh0dXJlICk7XHJcblx0XHRjb25zdCBmb3JtYXQgPSB0ZXh0dXJlLmludGVybmFsRm9ybWF0IHx8IG9wdGlvbnMuZm9ybWF0IHx8IGdldEZvcm1hdCggdGV4dHVyZSwgYmFja2VuZC5kZXZpY2UgKTtcclxuXHJcblx0XHR0ZXh0dXJlRGF0YS5mb3JtYXQgPSBmb3JtYXQ7XHJcblxyXG5cdFx0Y29uc3QgeyBzYW1wbGVzLCBwcmltYXJ5U2FtcGxlcywgaXNNU0FBIH0gPSBiYWNrZW5kLnV0aWxzLmdldFRleHR1cmVTYW1wbGVEYXRhKCB0ZXh0dXJlICk7XHJcblxyXG5cdFx0bGV0IHVzYWdlID0gR1BVVGV4dHVyZVVzYWdlLlRFWFRVUkVfQklORElORyB8IEdQVVRleHR1cmVVc2FnZS5DT1BZX0RTVCB8IEdQVVRleHR1cmVVc2FnZS5DT1BZX1NSQztcclxuXHJcblx0XHRpZiAoIHRleHR1cmUuaXNTdG9yYWdlVGV4dHVyZSA9PT0gdHJ1ZSApIHtcclxuXHJcblx0XHRcdHVzYWdlIHw9IEdQVVRleHR1cmVVc2FnZS5TVE9SQUdFX0JJTkRJTkc7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggdGV4dHVyZS5pc0NvbXByZXNzZWRUZXh0dXJlICE9PSB0cnVlICYmIHRleHR1cmUuaXNDb21wcmVzc2VkQXJyYXlUZXh0dXJlICE9PSB0cnVlICkge1xyXG5cclxuXHRcdFx0dXNhZ2UgfD0gR1BVVGV4dHVyZVVzYWdlLlJFTkRFUl9BVFRBQ0hNRU5UO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRjb25zdCB0ZXh0dXJlRGVzY3JpcHRvckdQVSA9IHtcclxuXHRcdFx0bGFiZWw6IHRleHR1cmUubmFtZSxcclxuXHRcdFx0c2l6ZToge1xyXG5cdFx0XHRcdHdpZHRoOiB3aWR0aCxcclxuXHRcdFx0XHRoZWlnaHQ6IGhlaWdodCxcclxuXHRcdFx0XHRkZXB0aE9yQXJyYXlMYXllcnM6IGRlcHRoLFxyXG5cdFx0XHR9LFxyXG5cdFx0XHRtaXBMZXZlbENvdW50OiBsZXZlbHMsXHJcblx0XHRcdHNhbXBsZUNvdW50OiBwcmltYXJ5U2FtcGxlcyxcclxuXHRcdFx0ZGltZW5zaW9uOiBkaW1lbnNpb24sXHJcblx0XHRcdGZvcm1hdDogZm9ybWF0LFxyXG5cdFx0XHR1c2FnZTogdXNhZ2VcclxuXHRcdH07XHJcblxyXG5cdFx0Ly8gdGV4dHVyZSBjcmVhdGlvblxyXG5cclxuXHRcdGlmICggdGV4dHVyZS5pc1ZpZGVvVGV4dHVyZSApIHtcclxuXHJcblx0XHRcdGNvbnN0IHZpZGVvID0gdGV4dHVyZS5zb3VyY2UuZGF0YTtcclxuXHRcdFx0Y29uc3QgdmlkZW9GcmFtZSA9IG5ldyBWaWRlb0ZyYW1lKCB2aWRlbyApO1xyXG5cclxuXHRcdFx0dGV4dHVyZURlc2NyaXB0b3JHUFUuc2l6ZS53aWR0aCA9IHZpZGVvRnJhbWUuZGlzcGxheVdpZHRoO1xyXG5cdFx0XHR0ZXh0dXJlRGVzY3JpcHRvckdQVS5zaXplLmhlaWdodCA9IHZpZGVvRnJhbWUuZGlzcGxheUhlaWdodDtcclxuXHJcblx0XHRcdHZpZGVvRnJhbWUuY2xvc2UoKTtcclxuXHJcblx0XHRcdHRleHR1cmVEYXRhLmV4dGVybmFsVGV4dHVyZSA9IHZpZGVvO1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRpZiAoIGZvcm1hdCA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRjb25zb2xlLndhcm4oICdXZWJHUFVSZW5kZXJlcjogVGV4dHVyZSBmb3JtYXQgbm90IHN1cHBvcnRlZC4nICk7XHJcblxyXG5cdFx0XHRcdHJldHVybiB0aGlzLmNyZWF0ZURlZmF1bHRUZXh0dXJlKCB0ZXh0dXJlICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR0ZXh0dXJlRGF0YS50ZXh0dXJlID0gYmFja2VuZC5kZXZpY2UuY3JlYXRlVGV4dHVyZSggdGV4dHVyZURlc2NyaXB0b3JHUFUgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBpc01TQUEgKSB7XHJcblxyXG5cdFx0XHRjb25zdCBtc2FhVGV4dHVyZURlc2NyaXB0b3JHUFUgPSBPYmplY3QuYXNzaWduKCB7fSwgdGV4dHVyZURlc2NyaXB0b3JHUFUgKTtcclxuXHJcblx0XHRcdG1zYWFUZXh0dXJlRGVzY3JpcHRvckdQVS5sYWJlbCA9IG1zYWFUZXh0dXJlRGVzY3JpcHRvckdQVS5sYWJlbCArICctbXNhYSc7XHJcblx0XHRcdG1zYWFUZXh0dXJlRGVzY3JpcHRvckdQVS5zYW1wbGVDb3VudCA9IHNhbXBsZXM7XHJcblxyXG5cdFx0XHR0ZXh0dXJlRGF0YS5tc2FhVGV4dHVyZSA9IGJhY2tlbmQuZGV2aWNlLmNyZWF0ZVRleHR1cmUoIG1zYWFUZXh0dXJlRGVzY3JpcHRvckdQVSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR0ZXh0dXJlRGF0YS5pbml0aWFsaXplZCA9IHRydWU7XHJcblxyXG5cdFx0dGV4dHVyZURhdGEudGV4dHVyZURlc2NyaXB0b3JHUFUgPSB0ZXh0dXJlRGVzY3JpcHRvckdQVTtcclxuXHJcblx0fVxyXG5cclxuXHRkZXN0cm95VGV4dHVyZSggdGV4dHVyZSApIHtcclxuXHJcblx0XHRjb25zdCBiYWNrZW5kID0gdGhpcy5iYWNrZW5kO1xyXG5cdFx0Y29uc3QgdGV4dHVyZURhdGEgPSBiYWNrZW5kLmdldCggdGV4dHVyZSApO1xyXG5cclxuXHRcdGlmICggdGV4dHVyZURhdGEudGV4dHVyZSAhPT0gdW5kZWZpbmVkICkgdGV4dHVyZURhdGEudGV4dHVyZS5kZXN0cm95KCk7XHJcblxyXG5cdFx0aWYgKCB0ZXh0dXJlRGF0YS5tc2FhVGV4dHVyZSAhPT0gdW5kZWZpbmVkICkgdGV4dHVyZURhdGEubXNhYVRleHR1cmUuZGVzdHJveSgpO1xyXG5cclxuXHRcdGJhY2tlbmQuZGVsZXRlKCB0ZXh0dXJlICk7XHJcblxyXG5cdH1cclxuXHJcblx0ZGVzdHJveVNhbXBsZXIoIHRleHR1cmUgKSB7XHJcblxyXG5cdFx0Y29uc3QgYmFja2VuZCA9IHRoaXMuYmFja2VuZDtcclxuXHRcdGNvbnN0IHRleHR1cmVEYXRhID0gYmFja2VuZC5nZXQoIHRleHR1cmUgKTtcclxuXHJcblx0XHRkZWxldGUgdGV4dHVyZURhdGEuc2FtcGxlcjtcclxuXHJcblx0fVxyXG5cclxuXHRnZW5lcmF0ZU1pcG1hcHMoIHRleHR1cmUgKSB7XHJcblxyXG5cdFx0Y29uc3QgdGV4dHVyZURhdGEgPSB0aGlzLmJhY2tlbmQuZ2V0KCB0ZXh0dXJlICk7XHJcblxyXG5cdFx0aWYgKCB0ZXh0dXJlLmlzQ3ViZVRleHR1cmUgKSB7XHJcblxyXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCA2OyBpICsrICkge1xyXG5cclxuXHRcdFx0XHR0aGlzLl9nZW5lcmF0ZU1pcG1hcHMoIHRleHR1cmVEYXRhLnRleHR1cmUsIHRleHR1cmVEYXRhLnRleHR1cmVEZXNjcmlwdG9yR1BVLCBpICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdGNvbnN0IGRlcHRoID0gdGV4dHVyZS5pbWFnZS5kZXB0aCB8fCAxO1xyXG5cclxuXHRcdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgZGVwdGg7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdHRoaXMuX2dlbmVyYXRlTWlwbWFwcyggdGV4dHVyZURhdGEudGV4dHVyZSwgdGV4dHVyZURhdGEudGV4dHVyZURlc2NyaXB0b3JHUFUsIGkgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0Z2V0Q29sb3JCdWZmZXIoKSB7XHJcblxyXG5cdFx0aWYgKCB0aGlzLmNvbG9yQnVmZmVyICkgdGhpcy5jb2xvckJ1ZmZlci5kZXN0cm95KCk7XHJcblxyXG5cdFx0Y29uc3QgYmFja2VuZCA9IHRoaXMuYmFja2VuZDtcclxuXHRcdGNvbnN0IHsgd2lkdGgsIGhlaWdodCB9ID0gYmFja2VuZC5nZXREcmF3aW5nQnVmZmVyU2l6ZSgpO1xyXG5cclxuXHRcdHRoaXMuY29sb3JCdWZmZXIgPSBiYWNrZW5kLmRldmljZS5jcmVhdGVUZXh0dXJlKCB7XHJcblx0XHRcdGxhYmVsOiAnY29sb3JCdWZmZXInLFxyXG5cdFx0XHRzaXplOiB7XHJcblx0XHRcdFx0d2lkdGg6IHdpZHRoLFxyXG5cdFx0XHRcdGhlaWdodDogaGVpZ2h0LFxyXG5cdFx0XHRcdGRlcHRoT3JBcnJheUxheWVyczogMVxyXG5cdFx0XHR9LFxyXG5cdFx0XHRzYW1wbGVDb3VudDogYmFja2VuZC51dGlscy5nZXRTYW1wbGVDb3VudCggYmFja2VuZC5yZW5kZXJlci5zYW1wbGVzICksXHJcblx0XHRcdGZvcm1hdDogYmFja2VuZC51dGlscy5nZXRQcmVmZXJyZWRDYW52YXNGb3JtYXQoKSxcclxuXHRcdFx0dXNhZ2U6IEdQVVRleHR1cmVVc2FnZS5SRU5ERVJfQVRUQUNITUVOVCB8IEdQVVRleHR1cmVVc2FnZS5DT1BZX1NSQ1xyXG5cdFx0fSApO1xyXG5cclxuXHRcdHJldHVybiB0aGlzLmNvbG9yQnVmZmVyO1xyXG5cclxuXHR9XHJcblxyXG5cdGdldERlcHRoQnVmZmVyKCBkZXB0aCA9IHRydWUsIHN0ZW5jaWwgPSBmYWxzZSApIHtcclxuXHJcblx0XHRjb25zdCBiYWNrZW5kID0gdGhpcy5iYWNrZW5kO1xyXG5cdFx0Y29uc3QgeyB3aWR0aCwgaGVpZ2h0IH0gPSBiYWNrZW5kLmdldERyYXdpbmdCdWZmZXJTaXplKCk7XHJcblxyXG5cdFx0Y29uc3QgZGVwdGhUZXh0dXJlID0gdGhpcy5kZXB0aFRleHR1cmU7XHJcblx0XHRjb25zdCBkZXB0aFRleHR1cmVHUFUgPSBiYWNrZW5kLmdldCggZGVwdGhUZXh0dXJlICkudGV4dHVyZTtcclxuXHJcblx0XHRsZXQgZm9ybWF0LCB0eXBlO1xyXG5cclxuXHRcdGlmICggc3RlbmNpbCApIHtcclxuXHJcblx0XHRcdGZvcm1hdCA9IERlcHRoU3RlbmNpbEZvcm1hdDtcclxuXHRcdFx0dHlwZSA9IFVuc2lnbmVkSW50MjQ4VHlwZTtcclxuXHJcblx0XHR9IGVsc2UgaWYgKCBkZXB0aCApIHtcclxuXHJcblx0XHRcdGZvcm1hdCA9IERlcHRoRm9ybWF0O1xyXG5cdFx0XHR0eXBlID0gVW5zaWduZWRJbnRUeXBlO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIGRlcHRoVGV4dHVyZUdQVSAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0aWYgKCBkZXB0aFRleHR1cmUuaW1hZ2Uud2lkdGggPT09IHdpZHRoICYmIGRlcHRoVGV4dHVyZS5pbWFnZS5oZWlnaHQgPT09IGhlaWdodCAmJiBkZXB0aFRleHR1cmUuZm9ybWF0ID09PSBmb3JtYXQgJiYgZGVwdGhUZXh0dXJlLnR5cGUgPT09IHR5cGUgKSB7XHJcblxyXG5cdFx0XHRcdHJldHVybiBkZXB0aFRleHR1cmVHUFU7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR0aGlzLmRlc3Ryb3lUZXh0dXJlKCBkZXB0aFRleHR1cmUgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0ZGVwdGhUZXh0dXJlLm5hbWUgPSAnZGVwdGhCdWZmZXInO1xyXG5cdFx0ZGVwdGhUZXh0dXJlLmZvcm1hdCA9IGZvcm1hdDtcclxuXHRcdGRlcHRoVGV4dHVyZS50eXBlID0gdHlwZTtcclxuXHRcdGRlcHRoVGV4dHVyZS5pbWFnZS53aWR0aCA9IHdpZHRoO1xyXG5cdFx0ZGVwdGhUZXh0dXJlLmltYWdlLmhlaWdodCA9IGhlaWdodDtcclxuXHJcblx0XHR0aGlzLmNyZWF0ZVRleHR1cmUoIGRlcHRoVGV4dHVyZSwgeyB3aWR0aCwgaGVpZ2h0IH0gKTtcclxuXHJcblx0XHRyZXR1cm4gYmFja2VuZC5nZXQoIGRlcHRoVGV4dHVyZSApLnRleHR1cmU7XHJcblxyXG5cdH1cclxuXHJcblx0dXBkYXRlVGV4dHVyZSggdGV4dHVyZSwgb3B0aW9ucyApIHtcclxuXHJcblx0XHRjb25zdCB0ZXh0dXJlRGF0YSA9IHRoaXMuYmFja2VuZC5nZXQoIHRleHR1cmUgKTtcclxuXHJcblx0XHRjb25zdCB7IHRleHR1cmVEZXNjcmlwdG9yR1BVIH0gPSB0ZXh0dXJlRGF0YTtcclxuXHJcblx0XHRpZiAoIHRleHR1cmUuaXNSZW5kZXJUYXJnZXRUZXh0dXJlIHx8ICggdGV4dHVyZURlc2NyaXB0b3JHUFUgPT09IHVuZGVmaW5lZCAvKiB1bnN1cHBvcnRlZCB0ZXh0dXJlIGZvcm1hdCAqLyApIClcclxuXHRcdFx0cmV0dXJuO1xyXG5cclxuXHRcdC8vIHRyYW5zZmVyIHRleHR1cmUgZGF0YVxyXG5cclxuXHRcdGlmICggdGV4dHVyZS5pc0RhdGFUZXh0dXJlICkge1xyXG5cclxuXHRcdFx0dGhpcy5fY29weUJ1ZmZlclRvVGV4dHVyZSggb3B0aW9ucy5pbWFnZSwgdGV4dHVyZURhdGEudGV4dHVyZSwgdGV4dHVyZURlc2NyaXB0b3JHUFUsIDAsIHRleHR1cmUuZmxpcFkgKTtcclxuXHJcblx0XHR9IGVsc2UgaWYgKCB0ZXh0dXJlLmlzRGF0YUFycmF5VGV4dHVyZSB8fCB0ZXh0dXJlLmlzRGF0YTNEVGV4dHVyZSApIHtcclxuXHJcblx0XHRcdGZvciAoIGxldCBpID0gMDsgaSA8IG9wdGlvbnMuaW1hZ2UuZGVwdGg7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdHRoaXMuX2NvcHlCdWZmZXJUb1RleHR1cmUoIG9wdGlvbnMuaW1hZ2UsIHRleHR1cmVEYXRhLnRleHR1cmUsIHRleHR1cmVEZXNjcmlwdG9yR1BVLCBpLCB0ZXh0dXJlLmZsaXBZLCBpICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fSBlbHNlIGlmICggdGV4dHVyZS5pc0NvbXByZXNzZWRUZXh0dXJlIHx8IHRleHR1cmUuaXNDb21wcmVzc2VkQXJyYXlUZXh0dXJlICkge1xyXG5cclxuXHRcdFx0dGhpcy5fY29weUNvbXByZXNzZWRCdWZmZXJUb1RleHR1cmUoIHRleHR1cmUubWlwbWFwcywgdGV4dHVyZURhdGEudGV4dHVyZSwgdGV4dHVyZURlc2NyaXB0b3JHUFUgKTtcclxuXHJcblx0XHR9IGVsc2UgaWYgKCB0ZXh0dXJlLmlzQ3ViZVRleHR1cmUgKSB7XHJcblxyXG5cdFx0XHR0aGlzLl9jb3B5Q3ViZU1hcFRvVGV4dHVyZSggb3B0aW9ucy5pbWFnZXMsIHRleHR1cmVEYXRhLnRleHR1cmUsIHRleHR1cmVEZXNjcmlwdG9yR1BVLCB0ZXh0dXJlLmZsaXBZICk7XHJcblxyXG5cdFx0fSBlbHNlIGlmICggdGV4dHVyZS5pc1ZpZGVvVGV4dHVyZSApIHtcclxuXHJcblx0XHRcdGNvbnN0IHZpZGVvID0gdGV4dHVyZS5zb3VyY2UuZGF0YTtcclxuXHJcblx0XHRcdHRleHR1cmVEYXRhLmV4dGVybmFsVGV4dHVyZSA9IHZpZGVvO1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHR0aGlzLl9jb3B5SW1hZ2VUb1RleHR1cmUoIG9wdGlvbnMuaW1hZ2UsIHRleHR1cmVEYXRhLnRleHR1cmUsIHRleHR1cmVEZXNjcmlwdG9yR1BVLCAwLCB0ZXh0dXJlLmZsaXBZICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vXHJcblxyXG5cdFx0dGV4dHVyZURhdGEudmVyc2lvbiA9IHRleHR1cmUudmVyc2lvbjtcclxuXHJcblx0XHRpZiAoIHRleHR1cmUub25VcGRhdGUgKSB0ZXh0dXJlLm9uVXBkYXRlKCB0ZXh0dXJlICk7XHJcblxyXG5cdH1cclxuXHJcblx0YXN5bmMgY29weVRleHR1cmVUb0J1ZmZlciggdGV4dHVyZSwgeCwgeSwgd2lkdGgsIGhlaWdodCwgZmFjZUluZGV4ICkge1xyXG5cclxuXHRcdGNvbnN0IGRldmljZSA9IHRoaXMuYmFja2VuZC5kZXZpY2U7XHJcblxyXG5cdFx0Y29uc3QgdGV4dHVyZURhdGEgPSB0aGlzLmJhY2tlbmQuZ2V0KCB0ZXh0dXJlICk7XHJcblx0XHRjb25zdCB0ZXh0dXJlR1BVID0gdGV4dHVyZURhdGEudGV4dHVyZTtcclxuXHRcdGNvbnN0IGZvcm1hdCA9IHRleHR1cmVEYXRhLnRleHR1cmVEZXNjcmlwdG9yR1BVLmZvcm1hdDtcclxuXHRcdGNvbnN0IGJ5dGVzUGVyVGV4ZWwgPSB0aGlzLl9nZXRCeXRlc1BlclRleGVsKCBmb3JtYXQgKTtcclxuXHJcblx0XHRsZXQgYnl0ZXNQZXJSb3cgPSB3aWR0aCAqIGJ5dGVzUGVyVGV4ZWw7XHJcblx0XHRieXRlc1BlclJvdyA9IE1hdGguY2VpbCggYnl0ZXNQZXJSb3cgLyAyNTYgKSAqIDI1NjsgLy8gQWxpZ24gdG8gMjU2IGJ5dGVzXHJcblxyXG5cdFx0Y29uc3QgcmVhZEJ1ZmZlciA9IGRldmljZS5jcmVhdGVCdWZmZXIoXHJcblx0XHRcdHtcclxuXHRcdFx0XHRzaXplOiB3aWR0aCAqIGhlaWdodCAqIGJ5dGVzUGVyVGV4ZWwsXHJcblx0XHRcdFx0dXNhZ2U6IEdQVUJ1ZmZlclVzYWdlLkNPUFlfRFNUIHwgR1BVQnVmZmVyVXNhZ2UuTUFQX1JFQURcclxuXHRcdFx0fVxyXG5cdFx0KTtcclxuXHJcblx0XHRjb25zdCBlbmNvZGVyID0gZGV2aWNlLmNyZWF0ZUNvbW1hbmRFbmNvZGVyKCk7XHJcblxyXG5cdFx0ZW5jb2Rlci5jb3B5VGV4dHVyZVRvQnVmZmVyKFxyXG5cdFx0XHR7XHJcblx0XHRcdFx0dGV4dHVyZTogdGV4dHVyZUdQVSxcclxuXHRcdFx0XHRvcmlnaW46IHsgeCwgeSwgejogZmFjZUluZGV4IH0sXHJcblx0XHRcdH0sXHJcblx0XHRcdHtcclxuXHRcdFx0XHRidWZmZXI6IHJlYWRCdWZmZXIsXHJcblx0XHRcdFx0Ynl0ZXNQZXJSb3c6IGJ5dGVzUGVyUm93XHJcblx0XHRcdH0sXHJcblx0XHRcdHtcclxuXHRcdFx0XHR3aWR0aDogd2lkdGgsXHJcblx0XHRcdFx0aGVpZ2h0OiBoZWlnaHRcclxuXHRcdFx0fVxyXG5cclxuXHRcdCk7XHJcblxyXG5cdFx0Y29uc3QgdHlwZWRBcnJheVR5cGUgPSB0aGlzLl9nZXRUeXBlZEFycmF5VHlwZSggZm9ybWF0ICk7XHJcblxyXG5cdFx0ZGV2aWNlLnF1ZXVlLnN1Ym1pdCggWyBlbmNvZGVyLmZpbmlzaCgpIF0gKTtcclxuXHJcblx0XHRhd2FpdCByZWFkQnVmZmVyLm1hcEFzeW5jKCBHUFVNYXBNb2RlLlJFQUQgKTtcclxuXHJcblx0XHRjb25zdCBidWZmZXIgPSByZWFkQnVmZmVyLmdldE1hcHBlZFJhbmdlKCk7XHJcblxyXG5cdFx0cmV0dXJuIG5ldyB0eXBlZEFycmF5VHlwZSggYnVmZmVyICk7XHJcblxyXG5cdH1cclxuXHJcblx0X2lzRW52aXJvbm1lbnRUZXh0dXJlKCB0ZXh0dXJlICkge1xyXG5cclxuXHRcdGNvbnN0IG1hcHBpbmcgPSB0ZXh0dXJlLm1hcHBpbmc7XHJcblxyXG5cdFx0cmV0dXJuICggbWFwcGluZyA9PT0gRXF1aXJlY3Rhbmd1bGFyUmVmbGVjdGlvbk1hcHBpbmcgfHwgbWFwcGluZyA9PT0gRXF1aXJlY3Rhbmd1bGFyUmVmcmFjdGlvbk1hcHBpbmcgKSB8fCAoIG1hcHBpbmcgPT09IEN1YmVSZWZsZWN0aW9uTWFwcGluZyB8fCBtYXBwaW5nID09PSBDdWJlUmVmcmFjdGlvbk1hcHBpbmcgKTtcclxuXHJcblx0fVxyXG5cclxuXHRfZ2V0RGVmYXVsdFRleHR1cmVHUFUoIGZvcm1hdCApIHtcclxuXHJcblx0XHRsZXQgZGVmYXVsdFRleHR1cmUgPSB0aGlzLmRlZmF1bHRUZXh0dXJlWyBmb3JtYXQgXTtcclxuXHJcblx0XHRpZiAoIGRlZmF1bHRUZXh0dXJlID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRjb25zdCB0ZXh0dXJlID0gbmV3IFRleHR1cmUoKTtcclxuXHRcdFx0dGV4dHVyZS5taW5GaWx0ZXIgPSBOZWFyZXN0RmlsdGVyO1xyXG5cdFx0XHR0ZXh0dXJlLm1hZ0ZpbHRlciA9IE5lYXJlc3RGaWx0ZXI7XHJcblxyXG5cdFx0XHR0aGlzLmNyZWF0ZVRleHR1cmUoIHRleHR1cmUsIHsgd2lkdGg6IDEsIGhlaWdodDogMSwgZm9ybWF0IH0gKTtcclxuXHJcblx0XHRcdHRoaXMuZGVmYXVsdFRleHR1cmVbIGZvcm1hdCBdID0gZGVmYXVsdFRleHR1cmUgPSB0ZXh0dXJlO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcy5iYWNrZW5kLmdldCggZGVmYXVsdFRleHR1cmUgKS50ZXh0dXJlO1xyXG5cclxuXHR9XHJcblxyXG5cdF9nZXREZWZhdWx0Q3ViZVRleHR1cmVHUFUoIGZvcm1hdCApIHtcclxuXHJcblx0XHRsZXQgZGVmYXVsdEN1YmVUZXh0dXJlID0gdGhpcy5kZWZhdWx0VGV4dHVyZVsgZm9ybWF0IF07XHJcblxyXG5cdFx0aWYgKCBkZWZhdWx0Q3ViZVRleHR1cmUgPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdGNvbnN0IHRleHR1cmUgPSBuZXcgQ3ViZVRleHR1cmUoKTtcclxuXHRcdFx0dGV4dHVyZS5taW5GaWx0ZXIgPSBOZWFyZXN0RmlsdGVyO1xyXG5cdFx0XHR0ZXh0dXJlLm1hZ0ZpbHRlciA9IE5lYXJlc3RGaWx0ZXI7XHJcblxyXG5cdFx0XHR0aGlzLmNyZWF0ZVRleHR1cmUoIHRleHR1cmUsIHsgd2lkdGg6IDEsIGhlaWdodDogMSwgZGVwdGg6IDYgfSApO1xyXG5cclxuXHRcdFx0dGhpcy5kZWZhdWx0Q3ViZVRleHR1cmVbIGZvcm1hdCBdID0gZGVmYXVsdEN1YmVUZXh0dXJlID0gdGV4dHVyZTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuYmFja2VuZC5nZXQoIGRlZmF1bHRDdWJlVGV4dHVyZSApLnRleHR1cmU7XHJcblxyXG5cdH1cclxuXHJcblx0X2dldERlZmF1bHRWaWRlb0ZyYW1lKCkge1xyXG5cclxuXHRcdGxldCBkZWZhdWx0VmlkZW9GcmFtZSA9IHRoaXMuZGVmYXVsdFZpZGVvRnJhbWU7XHJcblxyXG5cdFx0aWYgKCBkZWZhdWx0VmlkZW9GcmFtZSA9PT0gbnVsbCApIHtcclxuXHJcblx0XHRcdGNvbnN0IGluaXQgPSB7XHJcblx0XHRcdFx0dGltZXN0YW1wOiAwLFxyXG5cdFx0XHRcdGNvZGVkV2lkdGg6IDEsXHJcblx0XHRcdFx0Y29kZWRIZWlnaHQ6IDEsXHJcblx0XHRcdFx0Zm9ybWF0OiAnUkdCQScsXHJcblx0XHRcdH07XHJcblxyXG5cdFx0XHR0aGlzLmRlZmF1bHRWaWRlb0ZyYW1lID0gZGVmYXVsdFZpZGVvRnJhbWUgPSBuZXcgVmlkZW9GcmFtZSggbmV3IFVpbnQ4QXJyYXkoIFsgMCwgMCwgMCwgMHhmZiBdICksIGluaXQgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGRlZmF1bHRWaWRlb0ZyYW1lO1xyXG5cclxuXHR9XHJcblxyXG5cdF9jb3B5Q3ViZU1hcFRvVGV4dHVyZSggaW1hZ2VzLCB0ZXh0dXJlR1BVLCB0ZXh0dXJlRGVzY3JpcHRvckdQVSwgZmxpcFkgKSB7XHJcblxyXG5cdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgNjsgaSArKyApIHtcclxuXHJcblx0XHRcdGNvbnN0IGltYWdlID0gaW1hZ2VzWyBpIF07XHJcblxyXG5cdFx0XHRjb25zdCBmbGlwSW5kZXggPSBmbGlwWSA9PT0gdHJ1ZSA/IF9mbGlwTWFwWyBpIF0gOiBpO1xyXG5cclxuXHRcdFx0aWYgKCBpbWFnZS5pc0RhdGFUZXh0dXJlICkge1xyXG5cclxuXHRcdFx0XHR0aGlzLl9jb3B5QnVmZmVyVG9UZXh0dXJlKCBpbWFnZS5pbWFnZSwgdGV4dHVyZUdQVSwgdGV4dHVyZURlc2NyaXB0b3JHUFUsIGZsaXBJbmRleCwgZmxpcFkgKTtcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdHRoaXMuX2NvcHlJbWFnZVRvVGV4dHVyZSggaW1hZ2UsIHRleHR1cmVHUFUsIHRleHR1cmVEZXNjcmlwdG9yR1BVLCBmbGlwSW5kZXgsIGZsaXBZICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdF9jb3B5SW1hZ2VUb1RleHR1cmUoIGltYWdlLCB0ZXh0dXJlR1BVLCB0ZXh0dXJlRGVzY3JpcHRvckdQVSwgb3JpZ2luRGVwdGgsIGZsaXBZICkge1xyXG5cclxuXHRcdGNvbnN0IGRldmljZSA9IHRoaXMuYmFja2VuZC5kZXZpY2U7XHJcblxyXG5cdFx0ZGV2aWNlLnF1ZXVlLmNvcHlFeHRlcm5hbEltYWdlVG9UZXh0dXJlKFxyXG5cdFx0XHR7XHJcblx0XHRcdFx0c291cmNlOiBpbWFnZVxyXG5cdFx0XHR9LCB7XHJcblx0XHRcdFx0dGV4dHVyZTogdGV4dHVyZUdQVSxcclxuXHRcdFx0XHRtaXBMZXZlbDogMCxcclxuXHRcdFx0XHRvcmlnaW46IHsgeDogMCwgeTogMCwgejogb3JpZ2luRGVwdGggfVxyXG5cdFx0XHR9LCB7XHJcblx0XHRcdFx0d2lkdGg6IGltYWdlLndpZHRoLFxyXG5cdFx0XHRcdGhlaWdodDogaW1hZ2UuaGVpZ2h0LFxyXG5cdFx0XHRcdGRlcHRoT3JBcnJheUxheWVyczogMVxyXG5cdFx0XHR9XHJcblx0XHQpO1xyXG5cclxuXHRcdGlmICggZmxpcFkgPT09IHRydWUgKSB7XHJcblxyXG5cdFx0XHR0aGlzLl9mbGlwWSggdGV4dHVyZUdQVSwgdGV4dHVyZURlc2NyaXB0b3JHUFUsIG9yaWdpbkRlcHRoICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdF9nZXRQYXNzVXRpbHMoKSB7XHJcblxyXG5cdFx0bGV0IHBhc3NVdGlscyA9IHRoaXMuX3Bhc3NVdGlscztcclxuXHJcblx0XHRpZiAoIHBhc3NVdGlscyA9PT0gbnVsbCApIHtcclxuXHJcblx0XHRcdHRoaXMuX3Bhc3NVdGlscyA9IHBhc3NVdGlscyA9IG5ldyBXZWJHUFVUZXh0dXJlUGFzc1V0aWxzKCB0aGlzLmJhY2tlbmQuZGV2aWNlICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBwYXNzVXRpbHM7XHJcblxyXG5cdH1cclxuXHJcblx0X2dlbmVyYXRlTWlwbWFwcyggdGV4dHVyZUdQVSwgdGV4dHVyZURlc2NyaXB0b3JHUFUsIGJhc2VBcnJheUxheWVyID0gMCApIHtcclxuXHJcblx0XHR0aGlzLl9nZXRQYXNzVXRpbHMoKS5nZW5lcmF0ZU1pcG1hcHMoIHRleHR1cmVHUFUsIHRleHR1cmVEZXNjcmlwdG9yR1BVLCBiYXNlQXJyYXlMYXllciApO1xyXG5cclxuXHR9XHJcblxyXG5cdF9mbGlwWSggdGV4dHVyZUdQVSwgdGV4dHVyZURlc2NyaXB0b3JHUFUsIG9yaWdpbkRlcHRoID0gMCApIHtcclxuXHJcblx0XHR0aGlzLl9nZXRQYXNzVXRpbHMoKS5mbGlwWSggdGV4dHVyZUdQVSwgdGV4dHVyZURlc2NyaXB0b3JHUFUsIG9yaWdpbkRlcHRoICk7XHJcblxyXG5cdH1cclxuXHJcblx0X2NvcHlCdWZmZXJUb1RleHR1cmUoIGltYWdlLCB0ZXh0dXJlR1BVLCB0ZXh0dXJlRGVzY3JpcHRvckdQVSwgb3JpZ2luRGVwdGgsIGZsaXBZLCBkZXB0aCA9IDAgKSB7XHJcblxyXG5cdFx0Ly8gQFRPRE86IENvbnNpZGVyIHRvIHVzZSBHUFVDb21tYW5kRW5jb2Rlci5jb3B5QnVmZmVyVG9UZXh0dXJlKClcclxuXHRcdC8vIEBUT0RPOiBDb25zaWRlciB0byBzdXBwb3J0IHZhbGlkIGJ1ZmZlciBsYXlvdXRzIHdpdGggb3RoZXIgZm9ybWF0cyBsaWtlIFJHQlxyXG5cclxuXHRcdGNvbnN0IGRldmljZSA9IHRoaXMuYmFja2VuZC5kZXZpY2U7XHJcblxyXG5cdFx0Y29uc3QgZGF0YSA9IGltYWdlLmRhdGE7XHJcblxyXG5cdFx0Y29uc3QgYnl0ZXNQZXJUZXhlbCA9IHRoaXMuX2dldEJ5dGVzUGVyVGV4ZWwoIHRleHR1cmVEZXNjcmlwdG9yR1BVLmZvcm1hdCApO1xyXG5cdFx0Y29uc3QgYnl0ZXNQZXJSb3cgPSBpbWFnZS53aWR0aCAqIGJ5dGVzUGVyVGV4ZWw7XHJcblxyXG5cdFx0ZGV2aWNlLnF1ZXVlLndyaXRlVGV4dHVyZShcclxuXHRcdFx0e1xyXG5cdFx0XHRcdHRleHR1cmU6IHRleHR1cmVHUFUsXHJcblx0XHRcdFx0bWlwTGV2ZWw6IDAsXHJcblx0XHRcdFx0b3JpZ2luOiB7IHg6IDAsIHk6IDAsIHo6IG9yaWdpbkRlcHRoIH1cclxuXHRcdFx0fSxcclxuXHRcdFx0ZGF0YSxcclxuXHRcdFx0e1xyXG5cdFx0XHRcdG9mZnNldDogaW1hZ2Uud2lkdGggKiBpbWFnZS5oZWlnaHQgKiBieXRlc1BlclRleGVsICogZGVwdGgsXHJcblx0XHRcdFx0Ynl0ZXNQZXJSb3dcclxuXHRcdFx0fSxcclxuXHRcdFx0e1xyXG5cdFx0XHRcdHdpZHRoOiBpbWFnZS53aWR0aCxcclxuXHRcdFx0XHRoZWlnaHQ6IGltYWdlLmhlaWdodCxcclxuXHRcdFx0XHRkZXB0aE9yQXJyYXlMYXllcnM6IDFcclxuXHRcdFx0fSApO1xyXG5cclxuXHRcdGlmICggZmxpcFkgPT09IHRydWUgKSB7XHJcblxyXG5cdFx0XHR0aGlzLl9mbGlwWSggdGV4dHVyZUdQVSwgdGV4dHVyZURlc2NyaXB0b3JHUFUsIG9yaWdpbkRlcHRoICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdF9jb3B5Q29tcHJlc3NlZEJ1ZmZlclRvVGV4dHVyZSggbWlwbWFwcywgdGV4dHVyZUdQVSwgdGV4dHVyZURlc2NyaXB0b3JHUFUgKSB7XHJcblxyXG5cdFx0Ly8gQFRPRE86IENvbnNpZGVyIHRvIHVzZSBHUFVDb21tYW5kRW5jb2Rlci5jb3B5QnVmZmVyVG9UZXh0dXJlKClcclxuXHJcblx0XHRjb25zdCBkZXZpY2UgPSB0aGlzLmJhY2tlbmQuZGV2aWNlO1xyXG5cclxuXHRcdGNvbnN0IGJsb2NrRGF0YSA9IHRoaXMuX2dldEJsb2NrRGF0YSggdGV4dHVyZURlc2NyaXB0b3JHUFUuZm9ybWF0ICk7XHJcblx0XHRjb25zdCBpc1RleHR1cmVBcnJheSA9IHRleHR1cmVEZXNjcmlwdG9yR1BVLnNpemUuZGVwdGhPckFycmF5TGF5ZXJzID4gMTtcclxuXHJcblx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCBtaXBtYXBzLmxlbmd0aDsgaSArKyApIHtcclxuXHJcblx0XHRcdGNvbnN0IG1pcG1hcCA9IG1pcG1hcHNbIGkgXTtcclxuXHJcblx0XHRcdGNvbnN0IHdpZHRoID0gbWlwbWFwLndpZHRoO1xyXG5cdFx0XHRjb25zdCBoZWlnaHQgPSBtaXBtYXAuaGVpZ2h0O1xyXG5cdFx0XHRjb25zdCBkZXB0aCA9IGlzVGV4dHVyZUFycmF5ID8gdGV4dHVyZURlc2NyaXB0b3JHUFUuc2l6ZS5kZXB0aE9yQXJyYXlMYXllcnMgOiAxO1xyXG5cclxuXHRcdFx0Y29uc3QgYnl0ZXNQZXJSb3cgPSBNYXRoLmNlaWwoIHdpZHRoIC8gYmxvY2tEYXRhLndpZHRoICkgKiBibG9ja0RhdGEuYnl0ZUxlbmd0aDtcclxuXHRcdFx0Y29uc3QgYnl0ZXNQZXJJbWFnZSA9IGJ5dGVzUGVyUm93ICogTWF0aC5jZWlsKCBoZWlnaHQgLyBibG9ja0RhdGEuaGVpZ2h0ICk7XHJcblxyXG5cdFx0XHRmb3IgKCBsZXQgaiA9IDA7IGogPCBkZXB0aDsgaiArKyApIHtcclxuXHJcblx0XHRcdFx0ZGV2aWNlLnF1ZXVlLndyaXRlVGV4dHVyZShcclxuXHRcdFx0XHRcdHtcclxuXHRcdFx0XHRcdFx0dGV4dHVyZTogdGV4dHVyZUdQVSxcclxuXHRcdFx0XHRcdFx0bWlwTGV2ZWw6IGksXHJcblx0XHRcdFx0XHRcdG9yaWdpbjogeyB4OiAwLCB5OiAwLCB6OiBqIH1cclxuXHRcdFx0XHRcdH0sXHJcblx0XHRcdFx0XHRtaXBtYXAuZGF0YSxcclxuXHRcdFx0XHRcdHtcclxuXHRcdFx0XHRcdFx0b2Zmc2V0OiBqICogYnl0ZXNQZXJJbWFnZSxcclxuXHRcdFx0XHRcdFx0Ynl0ZXNQZXJSb3csXHJcblx0XHRcdFx0XHRcdHJvd3NQZXJJbWFnZTogTWF0aC5jZWlsKCBoZWlnaHQgLyBibG9ja0RhdGEuaGVpZ2h0IClcclxuXHRcdFx0XHRcdH0sXHJcblx0XHRcdFx0XHR7XHJcblx0XHRcdFx0XHRcdHdpZHRoOiBNYXRoLmNlaWwoIHdpZHRoIC8gYmxvY2tEYXRhLndpZHRoICkgKiBibG9ja0RhdGEud2lkdGgsXHJcblx0XHRcdFx0XHRcdGhlaWdodDogTWF0aC5jZWlsKCBoZWlnaHQgLyBibG9ja0RhdGEuaGVpZ2h0ICkgKiBibG9ja0RhdGEuaGVpZ2h0LFxyXG5cdFx0XHRcdFx0XHRkZXB0aE9yQXJyYXlMYXllcnM6IDFcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHQpO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHRfZ2V0QmxvY2tEYXRhKCBmb3JtYXQgKSB7XHJcblxyXG5cdFx0Ly8gdGhpcyBtZXRob2QgaXMgb25seSByZWxldmFudCBmb3IgY29tcHJlc3NlZCB0ZXh0dXJlIGZvcm1hdHNcclxuXHJcblx0XHRpZiAoIGZvcm1hdCA9PT0gR1BVVGV4dHVyZUZvcm1hdC5CQzFSR0JBVW5vcm0gfHwgZm9ybWF0ID09PSBHUFVUZXh0dXJlRm9ybWF0LkJDMVJHQkFVbm9ybVNSR0IgKSByZXR1cm4geyBieXRlTGVuZ3RoOiA4LCB3aWR0aDogNCwgaGVpZ2h0OiA0IH07IC8vIERYVDFcclxuXHRcdGlmICggZm9ybWF0ID09PSBHUFVUZXh0dXJlRm9ybWF0LkJDMlJHQkFVbm9ybSB8fCBmb3JtYXQgPT09IEdQVVRleHR1cmVGb3JtYXQuQkMyUkdCQVVub3JtU1JHQiApIHJldHVybiB7IGJ5dGVMZW5ndGg6IDE2LCB3aWR0aDogNCwgaGVpZ2h0OiA0IH07IC8vIERYVDNcclxuXHRcdGlmICggZm9ybWF0ID09PSBHUFVUZXh0dXJlRm9ybWF0LkJDM1JHQkFVbm9ybSB8fCBmb3JtYXQgPT09IEdQVVRleHR1cmVGb3JtYXQuQkMzUkdCQVVub3JtU1JHQiApIHJldHVybiB7IGJ5dGVMZW5ndGg6IDE2LCB3aWR0aDogNCwgaGVpZ2h0OiA0IH07IC8vIERYVDVcclxuXHRcdGlmICggZm9ybWF0ID09PSBHUFVUZXh0dXJlRm9ybWF0LkJDNFJVbm9ybSB8fCBmb3JtYXQgPT09IEdQVVRleHR1cmVGb3JtYXQuQkM0UlNOb3JtICkgcmV0dXJuIHsgYnl0ZUxlbmd0aDogOCwgd2lkdGg6IDQsIGhlaWdodDogNCB9OyAvLyBSR1RDMVxyXG5cdFx0aWYgKCBmb3JtYXQgPT09IEdQVVRleHR1cmVGb3JtYXQuQkM1UkdVbm9ybSB8fCBmb3JtYXQgPT09IEdQVVRleHR1cmVGb3JtYXQuQkM1UkdTbm9ybSApIHJldHVybiB7IGJ5dGVMZW5ndGg6IDE2LCB3aWR0aDogNCwgaGVpZ2h0OiA0IH07IC8vIFJHVEMyXHJcblx0XHRpZiAoIGZvcm1hdCA9PT0gR1BVVGV4dHVyZUZvcm1hdC5CQzZIUkdCVUZsb2F0IHx8IGZvcm1hdCA9PT0gR1BVVGV4dHVyZUZvcm1hdC5CQzZIUkdCRmxvYXQgKSByZXR1cm4geyBieXRlTGVuZ3RoOiAxNiwgd2lkdGg6IDQsIGhlaWdodDogNCB9OyAvLyBCUFRDIChmbG9hdClcclxuXHRcdGlmICggZm9ybWF0ID09PSBHUFVUZXh0dXJlRm9ybWF0LkJDN1JHQkFVbm9ybSB8fCBmb3JtYXQgPT09IEdQVVRleHR1cmVGb3JtYXQuQkM3UkdCQVVub3JtU1JHQiApIHJldHVybiB7IGJ5dGVMZW5ndGg6IDE2LCB3aWR0aDogNCwgaGVpZ2h0OiA0IH07IC8vIEJQVEMgKHVub3JtKVxyXG5cclxuXHRcdGlmICggZm9ybWF0ID09PSBHUFVUZXh0dXJlRm9ybWF0LkVUQzJSR0I4VW5vcm0gfHwgZm9ybWF0ID09PSBHUFVUZXh0dXJlRm9ybWF0LkVUQzJSR0I4VW5vcm1TUkdCICkgcmV0dXJuIHsgYnl0ZUxlbmd0aDogOCwgd2lkdGg6IDQsIGhlaWdodDogNCB9O1xyXG5cdFx0aWYgKCBmb3JtYXQgPT09IEdQVVRleHR1cmVGb3JtYXQuRVRDMlJHQjhBMVVub3JtIHx8IGZvcm1hdCA9PT0gR1BVVGV4dHVyZUZvcm1hdC5FVEMyUkdCOEExVW5vcm1TUkdCICkgcmV0dXJuIHsgYnl0ZUxlbmd0aDogOCwgd2lkdGg6IDQsIGhlaWdodDogNCB9O1xyXG5cdFx0aWYgKCBmb3JtYXQgPT09IEdQVVRleHR1cmVGb3JtYXQuRVRDMlJHQkE4VW5vcm0gfHwgZm9ybWF0ID09PSBHUFVUZXh0dXJlRm9ybWF0LkVUQzJSR0JBOFVub3JtU1JHQiApIHJldHVybiB7IGJ5dGVMZW5ndGg6IDE2LCB3aWR0aDogNCwgaGVpZ2h0OiA0IH07XHJcblx0XHRpZiAoIGZvcm1hdCA9PT0gR1BVVGV4dHVyZUZvcm1hdC5FQUNSMTFVbm9ybSApIHJldHVybiB7IGJ5dGVMZW5ndGg6IDgsIHdpZHRoOiA0LCBoZWlnaHQ6IDQgfTtcclxuXHRcdGlmICggZm9ybWF0ID09PSBHUFVUZXh0dXJlRm9ybWF0LkVBQ1IxMVNub3JtICkgcmV0dXJuIHsgYnl0ZUxlbmd0aDogOCwgd2lkdGg6IDQsIGhlaWdodDogNCB9O1xyXG5cdFx0aWYgKCBmb3JtYXQgPT09IEdQVVRleHR1cmVGb3JtYXQuRUFDUkcxMVVub3JtICkgcmV0dXJuIHsgYnl0ZUxlbmd0aDogMTYsIHdpZHRoOiA0LCBoZWlnaHQ6IDQgfTtcclxuXHRcdGlmICggZm9ybWF0ID09PSBHUFVUZXh0dXJlRm9ybWF0LkVBQ1JHMTFTbm9ybSApIHJldHVybiB7IGJ5dGVMZW5ndGg6IDE2LCB3aWR0aDogNCwgaGVpZ2h0OiA0IH07XHJcblxyXG5cdFx0aWYgKCBmb3JtYXQgPT09IEdQVVRleHR1cmVGb3JtYXQuQVNUQzR4NFVub3JtIHx8IGZvcm1hdCA9PT0gR1BVVGV4dHVyZUZvcm1hdC5BU1RDNHg0VW5vcm1TUkdCICkgcmV0dXJuIHsgYnl0ZUxlbmd0aDogMTYsIHdpZHRoOiA0LCBoZWlnaHQ6IDQgfTtcclxuXHRcdGlmICggZm9ybWF0ID09PSBHUFVUZXh0dXJlRm9ybWF0LkFTVEM1eDRVbm9ybSB8fCBmb3JtYXQgPT09IEdQVVRleHR1cmVGb3JtYXQuQVNUQzV4NFVub3JtU1JHQiApIHJldHVybiB7IGJ5dGVMZW5ndGg6IDE2LCB3aWR0aDogNSwgaGVpZ2h0OiA0IH07XHJcblx0XHRpZiAoIGZvcm1hdCA9PT0gR1BVVGV4dHVyZUZvcm1hdC5BU1RDNXg1VW5vcm0gfHwgZm9ybWF0ID09PSBHUFVUZXh0dXJlRm9ybWF0LkFTVEM1eDVVbm9ybVNSR0IgKSByZXR1cm4geyBieXRlTGVuZ3RoOiAxNiwgd2lkdGg6IDUsIGhlaWdodDogNSB9O1xyXG5cdFx0aWYgKCBmb3JtYXQgPT09IEdQVVRleHR1cmVGb3JtYXQuQVNUQzZ4NVVub3JtIHx8IGZvcm1hdCA9PT0gR1BVVGV4dHVyZUZvcm1hdC5BU1RDNng1VW5vcm1TUkdCICkgcmV0dXJuIHsgYnl0ZUxlbmd0aDogMTYsIHdpZHRoOiA2LCBoZWlnaHQ6IDUgfTtcclxuXHRcdGlmICggZm9ybWF0ID09PSBHUFVUZXh0dXJlRm9ybWF0LkFTVEM2eDZVbm9ybSB8fCBmb3JtYXQgPT09IEdQVVRleHR1cmVGb3JtYXQuQVNUQzZ4NlVub3JtU1JHQiApIHJldHVybiB7IGJ5dGVMZW5ndGg6IDE2LCB3aWR0aDogNiwgaGVpZ2h0OiA2IH07XHJcblx0XHRpZiAoIGZvcm1hdCA9PT0gR1BVVGV4dHVyZUZvcm1hdC5BU1RDOHg1VW5vcm0gfHwgZm9ybWF0ID09PSBHUFVUZXh0dXJlRm9ybWF0LkFTVEM4eDVVbm9ybVNSR0IgKSByZXR1cm4geyBieXRlTGVuZ3RoOiAxNiwgd2lkdGg6IDgsIGhlaWdodDogNSB9O1xyXG5cdFx0aWYgKCBmb3JtYXQgPT09IEdQVVRleHR1cmVGb3JtYXQuQVNUQzh4NlVub3JtIHx8IGZvcm1hdCA9PT0gR1BVVGV4dHVyZUZvcm1hdC5BU1RDOHg2VW5vcm1TUkdCICkgcmV0dXJuIHsgYnl0ZUxlbmd0aDogMTYsIHdpZHRoOiA4LCBoZWlnaHQ6IDYgfTtcclxuXHRcdGlmICggZm9ybWF0ID09PSBHUFVUZXh0dXJlRm9ybWF0LkFTVEM4eDhVbm9ybSB8fCBmb3JtYXQgPT09IEdQVVRleHR1cmVGb3JtYXQuQVNUQzh4OFVub3JtU1JHQiApIHJldHVybiB7IGJ5dGVMZW5ndGg6IDE2LCB3aWR0aDogOCwgaGVpZ2h0OiA4IH07XHJcblx0XHRpZiAoIGZvcm1hdCA9PT0gR1BVVGV4dHVyZUZvcm1hdC5BU1RDMTB4NVVub3JtIHx8IGZvcm1hdCA9PT0gR1BVVGV4dHVyZUZvcm1hdC5BU1RDMTB4NVVub3JtU1JHQiApIHJldHVybiB7IGJ5dGVMZW5ndGg6IDE2LCB3aWR0aDogMTAsIGhlaWdodDogNSB9O1xyXG5cdFx0aWYgKCBmb3JtYXQgPT09IEdQVVRleHR1cmVGb3JtYXQuQVNUQzEweDZVbm9ybSB8fCBmb3JtYXQgPT09IEdQVVRleHR1cmVGb3JtYXQuQVNUQzEweDZVbm9ybVNSR0IgKSByZXR1cm4geyBieXRlTGVuZ3RoOiAxNiwgd2lkdGg6IDEwLCBoZWlnaHQ6IDYgfTtcclxuXHRcdGlmICggZm9ybWF0ID09PSBHUFVUZXh0dXJlRm9ybWF0LkFTVEMxMHg4VW5vcm0gfHwgZm9ybWF0ID09PSBHUFVUZXh0dXJlRm9ybWF0LkFTVEMxMHg4VW5vcm1TUkdCICkgcmV0dXJuIHsgYnl0ZUxlbmd0aDogMTYsIHdpZHRoOiAxMCwgaGVpZ2h0OiA4IH07XHJcblx0XHRpZiAoIGZvcm1hdCA9PT0gR1BVVGV4dHVyZUZvcm1hdC5BU1RDMTB4MTBVbm9ybSB8fCBmb3JtYXQgPT09IEdQVVRleHR1cmVGb3JtYXQuQVNUQzEweDEwVW5vcm1TUkdCICkgcmV0dXJuIHsgYnl0ZUxlbmd0aDogMTYsIHdpZHRoOiAxMCwgaGVpZ2h0OiAxMCB9O1xyXG5cdFx0aWYgKCBmb3JtYXQgPT09IEdQVVRleHR1cmVGb3JtYXQuQVNUQzEyeDEwVW5vcm0gfHwgZm9ybWF0ID09PSBHUFVUZXh0dXJlRm9ybWF0LkFTVEMxMngxMFVub3JtU1JHQiApIHJldHVybiB7IGJ5dGVMZW5ndGg6IDE2LCB3aWR0aDogMTIsIGhlaWdodDogMTAgfTtcclxuXHRcdGlmICggZm9ybWF0ID09PSBHUFVUZXh0dXJlRm9ybWF0LkFTVEMxMngxMlVub3JtIHx8IGZvcm1hdCA9PT0gR1BVVGV4dHVyZUZvcm1hdC5BU1RDMTJ4MTJVbm9ybVNSR0IgKSByZXR1cm4geyBieXRlTGVuZ3RoOiAxNiwgd2lkdGg6IDEyLCBoZWlnaHQ6IDEyIH07XHJcblxyXG5cdH1cclxuXHJcblx0X2NvbnZlcnRBZGRyZXNzTW9kZSggdmFsdWUgKSB7XHJcblxyXG5cdFx0bGV0IGFkZHJlc3NNb2RlID0gR1BVQWRkcmVzc01vZGUuQ2xhbXBUb0VkZ2U7XHJcblxyXG5cdFx0aWYgKCB2YWx1ZSA9PT0gUmVwZWF0V3JhcHBpbmcgKSB7XHJcblxyXG5cdFx0XHRhZGRyZXNzTW9kZSA9IEdQVUFkZHJlc3NNb2RlLlJlcGVhdDtcclxuXHJcblx0XHR9IGVsc2UgaWYgKCB2YWx1ZSA9PT0gTWlycm9yZWRSZXBlYXRXcmFwcGluZyApIHtcclxuXHJcblx0XHRcdGFkZHJlc3NNb2RlID0gR1BVQWRkcmVzc01vZGUuTWlycm9yUmVwZWF0O1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gYWRkcmVzc01vZGU7XHJcblxyXG5cdH1cclxuXHJcblx0X2NvbnZlcnRGaWx0ZXJNb2RlKCB2YWx1ZSApIHtcclxuXHJcblx0XHRsZXQgZmlsdGVyTW9kZSA9IEdQVUZpbHRlck1vZGUuTGluZWFyO1xyXG5cclxuXHRcdGlmICggdmFsdWUgPT09IE5lYXJlc3RGaWx0ZXIgfHwgdmFsdWUgPT09IE5lYXJlc3RNaXBtYXBOZWFyZXN0RmlsdGVyIHx8IHZhbHVlID09PSBOZWFyZXN0TWlwbWFwTGluZWFyRmlsdGVyICkge1xyXG5cclxuXHRcdFx0ZmlsdGVyTW9kZSA9IEdQVUZpbHRlck1vZGUuTmVhcmVzdDtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGZpbHRlck1vZGU7XHJcblxyXG5cdH1cclxuXHJcblx0X2dldEJ5dGVzUGVyVGV4ZWwoIGZvcm1hdCApIHtcclxuXHJcblx0XHQvLyA4LWJpdCBmb3JtYXRzXHJcblx0XHRpZiAoIGZvcm1hdCA9PT0gR1BVVGV4dHVyZUZvcm1hdC5SOFVub3JtIHx8XHJcblx0XHRcdGZvcm1hdCA9PT0gR1BVVGV4dHVyZUZvcm1hdC5SOFNub3JtIHx8XHJcblx0XHRcdGZvcm1hdCA9PT0gR1BVVGV4dHVyZUZvcm1hdC5SOFVpbnQgfHxcclxuXHRcdFx0Zm9ybWF0ID09PSBHUFVUZXh0dXJlRm9ybWF0LlI4U2ludCApIHJldHVybiAxO1xyXG5cclxuXHRcdC8vIDE2LWJpdCBmb3JtYXRzXHJcblx0XHRpZiAoIGZvcm1hdCA9PT0gR1BVVGV4dHVyZUZvcm1hdC5SMTZVaW50IHx8XHJcblx0XHRcdGZvcm1hdCA9PT0gR1BVVGV4dHVyZUZvcm1hdC5SMTZTaW50IHx8XHJcblx0XHRcdGZvcm1hdCA9PT0gR1BVVGV4dHVyZUZvcm1hdC5SMTZGbG9hdCB8fFxyXG5cdFx0XHRmb3JtYXQgPT09IEdQVVRleHR1cmVGb3JtYXQuUkc4VW5vcm0gfHxcclxuXHRcdFx0Zm9ybWF0ID09PSBHUFVUZXh0dXJlRm9ybWF0LlJHOFNub3JtIHx8XHJcblx0XHRcdGZvcm1hdCA9PT0gR1BVVGV4dHVyZUZvcm1hdC5SRzhVaW50IHx8XHJcblx0XHRcdGZvcm1hdCA9PT0gR1BVVGV4dHVyZUZvcm1hdC5SRzhTaW50ICkgcmV0dXJuIDI7XHJcblxyXG5cdFx0Ly8gMzItYml0IGZvcm1hdHNcclxuXHRcdGlmICggZm9ybWF0ID09PSBHUFVUZXh0dXJlRm9ybWF0LlIzMlVpbnQgfHxcclxuXHRcdFx0Zm9ybWF0ID09PSBHUFVUZXh0dXJlRm9ybWF0LlIzMlNpbnQgfHxcclxuXHRcdFx0Zm9ybWF0ID09PSBHUFVUZXh0dXJlRm9ybWF0LlIzMkZsb2F0IHx8XHJcblx0XHRcdGZvcm1hdCA9PT0gR1BVVGV4dHVyZUZvcm1hdC5SRzE2VWludCB8fFxyXG5cdFx0XHRmb3JtYXQgPT09IEdQVVRleHR1cmVGb3JtYXQuUkcxNlNpbnQgfHxcclxuXHRcdFx0Zm9ybWF0ID09PSBHUFVUZXh0dXJlRm9ybWF0LlJHMTZGbG9hdCB8fFxyXG5cdFx0XHRmb3JtYXQgPT09IEdQVVRleHR1cmVGb3JtYXQuUkdCQThVbm9ybSB8fFxyXG5cdFx0XHRmb3JtYXQgPT09IEdQVVRleHR1cmVGb3JtYXQuUkdCQThVbm9ybVNSR0IgfHxcclxuXHRcdFx0Zm9ybWF0ID09PSBHUFVUZXh0dXJlRm9ybWF0LlJHQkE4U25vcm0gfHxcclxuXHRcdFx0Zm9ybWF0ID09PSBHUFVUZXh0dXJlRm9ybWF0LlJHQkE4VWludCB8fFxyXG5cdFx0XHRmb3JtYXQgPT09IEdQVVRleHR1cmVGb3JtYXQuUkdCQThTaW50IHx8XHJcblx0XHRcdGZvcm1hdCA9PT0gR1BVVGV4dHVyZUZvcm1hdC5CR1JBOFVub3JtIHx8XHJcblx0XHRcdGZvcm1hdCA9PT0gR1BVVGV4dHVyZUZvcm1hdC5CR1JBOFVub3JtU1JHQiB8fFxyXG5cdFx0XHQvLyBQYWNrZWQgMzItYml0IGZvcm1hdHNcclxuXHRcdFx0Zm9ybWF0ID09PSBHUFVUZXh0dXJlRm9ybWF0LlJHQjlFNVVGbG9hdCB8fFxyXG5cdFx0XHRmb3JtYXQgPT09IEdQVVRleHR1cmVGb3JtYXQuUkdCMTBBMlVub3JtIHx8XHJcblx0XHRcdGZvcm1hdCA9PT0gR1BVVGV4dHVyZUZvcm1hdC5SRzExQjEwVUZsb2F0IHx8XHJcblx0XHRcdGZvcm1hdCA9PT0gR1BVVGV4dHVyZUZvcm1hdC5EZXB0aDMyRmxvYXQgfHxcclxuXHRcdFx0Zm9ybWF0ID09PSBHUFVUZXh0dXJlRm9ybWF0LkRlcHRoMjRQbHVzIHx8XHJcblx0XHRcdGZvcm1hdCA9PT0gR1BVVGV4dHVyZUZvcm1hdC5EZXB0aDI0UGx1c1N0ZW5jaWw4IHx8XHJcblx0XHRcdGZvcm1hdCA9PT0gR1BVVGV4dHVyZUZvcm1hdC5EZXB0aDMyRmxvYXRTdGVuY2lsOCApIHJldHVybiA0O1xyXG5cclxuXHRcdC8vIDY0LWJpdCBmb3JtYXRzXHJcblx0XHRpZiAoIGZvcm1hdCA9PT0gR1BVVGV4dHVyZUZvcm1hdC5SRzMyVWludCB8fFxyXG5cdFx0XHRmb3JtYXQgPT09IEdQVVRleHR1cmVGb3JtYXQuUkczMlNpbnQgfHxcclxuXHRcdFx0Zm9ybWF0ID09PSBHUFVUZXh0dXJlRm9ybWF0LlJHMzJGbG9hdCB8fFxyXG5cdFx0XHRmb3JtYXQgPT09IEdQVVRleHR1cmVGb3JtYXQuUkdCQTE2VWludCB8fFxyXG5cdFx0XHRmb3JtYXQgPT09IEdQVVRleHR1cmVGb3JtYXQuUkdCQTE2U2ludCB8fFxyXG5cdFx0XHRmb3JtYXQgPT09IEdQVVRleHR1cmVGb3JtYXQuUkdCQTE2RmxvYXQgKSByZXR1cm4gODtcclxuXHJcblx0XHQvLyAxMjgtYml0IGZvcm1hdHNcclxuXHRcdGlmICggZm9ybWF0ID09PSBHUFVUZXh0dXJlRm9ybWF0LlJHQkEzMlVpbnQgfHxcclxuXHRcdFx0Zm9ybWF0ID09PSBHUFVUZXh0dXJlRm9ybWF0LlJHQkEzMlNpbnQgfHxcclxuXHRcdFx0Zm9ybWF0ID09PSBHUFVUZXh0dXJlRm9ybWF0LlJHQkEzMkZsb2F0ICkgcmV0dXJuIDE2O1xyXG5cclxuXHJcblx0fVxyXG5cclxuXHRfZ2V0VHlwZWRBcnJheVR5cGUoIGZvcm1hdCApIHtcclxuXHJcblx0XHRpZiAoIGZvcm1hdCA9PT0gR1BVVGV4dHVyZUZvcm1hdC5SOFVpbnQgKSByZXR1cm4gVWludDhBcnJheTtcclxuXHRcdGlmICggZm9ybWF0ID09PSBHUFVUZXh0dXJlRm9ybWF0LlI4U2ludCApIHJldHVybiBJbnQ4QXJyYXk7XHJcblx0XHRpZiAoIGZvcm1hdCA9PT0gR1BVVGV4dHVyZUZvcm1hdC5SOFVub3JtICkgcmV0dXJuIFVpbnQ4QXJyYXk7XHJcblx0XHRpZiAoIGZvcm1hdCA9PT0gR1BVVGV4dHVyZUZvcm1hdC5SOFNub3JtICkgcmV0dXJuIEludDhBcnJheTtcclxuXHRcdGlmICggZm9ybWF0ID09PSBHUFVUZXh0dXJlRm9ybWF0LlJHOFVpbnQgKSByZXR1cm4gVWludDhBcnJheTtcclxuXHRcdGlmICggZm9ybWF0ID09PSBHUFVUZXh0dXJlRm9ybWF0LlJHOFNpbnQgKSByZXR1cm4gSW50OEFycmF5O1xyXG5cdFx0aWYgKCBmb3JtYXQgPT09IEdQVVRleHR1cmVGb3JtYXQuUkc4VW5vcm0gKSByZXR1cm4gVWludDhBcnJheTtcclxuXHRcdGlmICggZm9ybWF0ID09PSBHUFVUZXh0dXJlRm9ybWF0LlJHOFNub3JtICkgcmV0dXJuIEludDhBcnJheTtcclxuXHRcdGlmICggZm9ybWF0ID09PSBHUFVUZXh0dXJlRm9ybWF0LlJHQkE4VWludCApIHJldHVybiBVaW50OEFycmF5O1xyXG5cdFx0aWYgKCBmb3JtYXQgPT09IEdQVVRleHR1cmVGb3JtYXQuUkdCQThTaW50ICkgcmV0dXJuIEludDhBcnJheTtcclxuXHRcdGlmICggZm9ybWF0ID09PSBHUFVUZXh0dXJlRm9ybWF0LlJHQkE4VW5vcm0gKSByZXR1cm4gVWludDhBcnJheTtcclxuXHRcdGlmICggZm9ybWF0ID09PSBHUFVUZXh0dXJlRm9ybWF0LlJHQkE4U25vcm0gKSByZXR1cm4gSW50OEFycmF5O1xyXG5cclxuXHJcblx0XHRpZiAoIGZvcm1hdCA9PT0gR1BVVGV4dHVyZUZvcm1hdC5SMTZVaW50ICkgcmV0dXJuIFVpbnQxNkFycmF5O1xyXG5cdFx0aWYgKCBmb3JtYXQgPT09IEdQVVRleHR1cmVGb3JtYXQuUjE2U2ludCApIHJldHVybiBJbnQxNkFycmF5O1xyXG5cdFx0aWYgKCBmb3JtYXQgPT09IEdQVVRleHR1cmVGb3JtYXQuUkcxNlVpbnQgKSByZXR1cm4gVWludDE2QXJyYXk7XHJcblx0XHRpZiAoIGZvcm1hdCA9PT0gR1BVVGV4dHVyZUZvcm1hdC5SRzE2U2ludCApIHJldHVybiBJbnQxNkFycmF5O1xyXG5cdFx0aWYgKCBmb3JtYXQgPT09IEdQVVRleHR1cmVGb3JtYXQuUkdCQTE2VWludCApIHJldHVybiBVaW50MTZBcnJheTtcclxuXHRcdGlmICggZm9ybWF0ID09PSBHUFVUZXh0dXJlRm9ybWF0LlJHQkExNlNpbnQgKSByZXR1cm4gSW50MTZBcnJheTtcclxuXHRcdGlmICggZm9ybWF0ID09PSBHUFVUZXh0dXJlRm9ybWF0LlIxNkZsb2F0ICkgcmV0dXJuIFVpbnQxNkFycmF5O1xyXG5cdFx0aWYgKCBmb3JtYXQgPT09IEdQVVRleHR1cmVGb3JtYXQuUkcxNkZsb2F0ICkgcmV0dXJuIFVpbnQxNkFycmF5O1xyXG5cdFx0aWYgKCBmb3JtYXQgPT09IEdQVVRleHR1cmVGb3JtYXQuUkdCQTE2RmxvYXQgKSByZXR1cm4gVWludDE2QXJyYXk7XHJcblxyXG5cclxuXHRcdGlmICggZm9ybWF0ID09PSBHUFVUZXh0dXJlRm9ybWF0LlIzMlVpbnQgKSByZXR1cm4gVWludDMyQXJyYXk7XHJcblx0XHRpZiAoIGZvcm1hdCA9PT0gR1BVVGV4dHVyZUZvcm1hdC5SMzJTaW50ICkgcmV0dXJuIEludDMyQXJyYXk7XHJcblx0XHRpZiAoIGZvcm1hdCA9PT0gR1BVVGV4dHVyZUZvcm1hdC5SMzJGbG9hdCApIHJldHVybiBGbG9hdDMyQXJyYXk7XHJcblx0XHRpZiAoIGZvcm1hdCA9PT0gR1BVVGV4dHVyZUZvcm1hdC5SRzMyVWludCApIHJldHVybiBVaW50MzJBcnJheTtcclxuXHRcdGlmICggZm9ybWF0ID09PSBHUFVUZXh0dXJlRm9ybWF0LlJHMzJTaW50ICkgcmV0dXJuIEludDMyQXJyYXk7XHJcblx0XHRpZiAoIGZvcm1hdCA9PT0gR1BVVGV4dHVyZUZvcm1hdC5SRzMyRmxvYXQgKSByZXR1cm4gRmxvYXQzMkFycmF5O1xyXG5cdFx0aWYgKCBmb3JtYXQgPT09IEdQVVRleHR1cmVGb3JtYXQuUkdCQTMyVWludCApIHJldHVybiBVaW50MzJBcnJheTtcclxuXHRcdGlmICggZm9ybWF0ID09PSBHUFVUZXh0dXJlRm9ybWF0LlJHQkEzMlNpbnQgKSByZXR1cm4gSW50MzJBcnJheTtcclxuXHRcdGlmICggZm9ybWF0ID09PSBHUFVUZXh0dXJlRm9ybWF0LlJHQkEzMkZsb2F0ICkgcmV0dXJuIEZsb2F0MzJBcnJheTtcclxuXHJcblx0XHRpZiAoIGZvcm1hdCA9PT0gR1BVVGV4dHVyZUZvcm1hdC5CR1JBOFVub3JtICkgcmV0dXJuIFVpbnQ4QXJyYXk7XHJcblx0XHRpZiAoIGZvcm1hdCA9PT0gR1BVVGV4dHVyZUZvcm1hdC5CR1JBOFVub3JtU1JHQiApIHJldHVybiBVaW50OEFycmF5O1xyXG5cdFx0aWYgKCBmb3JtYXQgPT09IEdQVVRleHR1cmVGb3JtYXQuUkdCMTBBMlVub3JtICkgcmV0dXJuIFVpbnQzMkFycmF5O1xyXG5cdFx0aWYgKCBmb3JtYXQgPT09IEdQVVRleHR1cmVGb3JtYXQuUkdCOUU1VUZsb2F0ICkgcmV0dXJuIFVpbnQzMkFycmF5O1xyXG5cdFx0aWYgKCBmb3JtYXQgPT09IEdQVVRleHR1cmVGb3JtYXQuUkcxMUIxMFVGbG9hdCApIHJldHVybiBVaW50MzJBcnJheTtcclxuXHJcblx0XHRpZiAoIGZvcm1hdCA9PT0gR1BVVGV4dHVyZUZvcm1hdC5EZXB0aDMyRmxvYXQgKSByZXR1cm4gRmxvYXQzMkFycmF5O1xyXG5cdFx0aWYgKCBmb3JtYXQgPT09IEdQVVRleHR1cmVGb3JtYXQuRGVwdGgyNFBsdXMgKSByZXR1cm4gVWludDMyQXJyYXk7XHJcblx0XHRpZiAoIGZvcm1hdCA9PT0gR1BVVGV4dHVyZUZvcm1hdC5EZXB0aDI0UGx1c1N0ZW5jaWw4ICkgcmV0dXJuIFVpbnQzMkFycmF5O1xyXG5cdFx0aWYgKCBmb3JtYXQgPT09IEdQVVRleHR1cmVGb3JtYXQuRGVwdGgzMkZsb2F0U3RlbmNpbDggKSByZXR1cm4gRmxvYXQzMkFycmF5O1xyXG5cclxuXHR9XHJcblxyXG5cdF9nZXREaW1lbnNpb24oIHRleHR1cmUgKSB7XHJcblxyXG5cdFx0bGV0IGRpbWVuc2lvbjtcclxuXHJcblx0XHRpZiAoIHRleHR1cmUuaXNEYXRhM0RUZXh0dXJlICkge1xyXG5cclxuXHRcdFx0ZGltZW5zaW9uID0gR1BVVGV4dHVyZURpbWVuc2lvbi5UaHJlZUQ7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdGRpbWVuc2lvbiA9IEdQVVRleHR1cmVEaW1lbnNpb24uVHdvRDtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGRpbWVuc2lvbjtcclxuXHJcblx0fVxyXG5cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGdldEZvcm1hdCggdGV4dHVyZSwgZGV2aWNlID0gbnVsbCApIHtcclxuXHJcblx0Y29uc3QgZm9ybWF0ID0gdGV4dHVyZS5mb3JtYXQ7XHJcblx0Y29uc3QgdHlwZSA9IHRleHR1cmUudHlwZTtcclxuXHRjb25zdCBjb2xvclNwYWNlID0gdGV4dHVyZS5jb2xvclNwYWNlO1xyXG5cclxuXHRsZXQgZm9ybWF0R1BVO1xyXG5cclxuXHRpZiAoIHRleHR1cmUuaXNDb21wcmVzc2VkVGV4dHVyZSA9PT0gdHJ1ZSB8fCB0ZXh0dXJlLmlzQ29tcHJlc3NlZEFycmF5VGV4dHVyZSA9PT0gdHJ1ZSApIHtcclxuXHJcblx0XHRzd2l0Y2ggKCBmb3JtYXQgKSB7XHJcblxyXG5cdFx0XHRjYXNlIFJHQkFfUzNUQ19EWFQxX0Zvcm1hdDpcclxuXHRcdFx0XHRmb3JtYXRHUFUgPSAoIGNvbG9yU3BhY2UgPT09IFNSR0JDb2xvclNwYWNlICkgPyBHUFVUZXh0dXJlRm9ybWF0LkJDMVJHQkFVbm9ybVNSR0IgOiBHUFVUZXh0dXJlRm9ybWF0LkJDMVJHQkFVbm9ybTtcclxuXHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdGNhc2UgUkdCQV9TM1RDX0RYVDNfRm9ybWF0OlxyXG5cdFx0XHRcdGZvcm1hdEdQVSA9ICggY29sb3JTcGFjZSA9PT0gU1JHQkNvbG9yU3BhY2UgKSA/IEdQVVRleHR1cmVGb3JtYXQuQkMyUkdCQVVub3JtU1JHQiA6IEdQVVRleHR1cmVGb3JtYXQuQkMyUkdCQVVub3JtO1xyXG5cdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0Y2FzZSBSR0JBX1MzVENfRFhUNV9Gb3JtYXQ6XHJcblx0XHRcdFx0Zm9ybWF0R1BVID0gKCBjb2xvclNwYWNlID09PSBTUkdCQ29sb3JTcGFjZSApID8gR1BVVGV4dHVyZUZvcm1hdC5CQzNSR0JBVW5vcm1TUkdCIDogR1BVVGV4dHVyZUZvcm1hdC5CQzNSR0JBVW5vcm07XHJcblx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRjYXNlIFJHQl9FVEMyX0Zvcm1hdDpcclxuXHRcdFx0XHRmb3JtYXRHUFUgPSAoIGNvbG9yU3BhY2UgPT09IFNSR0JDb2xvclNwYWNlICkgPyBHUFVUZXh0dXJlRm9ybWF0LkVUQzJSR0I4VW5vcm1TUkdCIDogR1BVVGV4dHVyZUZvcm1hdC5FVEMyUkdCOFVub3JtO1xyXG5cdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0Y2FzZSBSR0JBX0VUQzJfRUFDX0Zvcm1hdDpcclxuXHRcdFx0XHRmb3JtYXRHUFUgPSAoIGNvbG9yU3BhY2UgPT09IFNSR0JDb2xvclNwYWNlICkgPyBHUFVUZXh0dXJlRm9ybWF0LkVUQzJSR0JBOFVub3JtU1JHQiA6IEdQVVRleHR1cmVGb3JtYXQuRVRDMlJHQkE4VW5vcm07XHJcblx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRjYXNlIFJHQkFfQVNUQ180eDRfRm9ybWF0OlxyXG5cdFx0XHRcdGZvcm1hdEdQVSA9ICggY29sb3JTcGFjZSA9PT0gU1JHQkNvbG9yU3BhY2UgKSA/IEdQVVRleHR1cmVGb3JtYXQuQVNUQzR4NFVub3JtU1JHQiA6IEdQVVRleHR1cmVGb3JtYXQuQVNUQzR4NFVub3JtO1xyXG5cdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0Y2FzZSBSR0JBX0FTVENfNXg0X0Zvcm1hdDpcclxuXHRcdFx0XHRmb3JtYXRHUFUgPSAoIGNvbG9yU3BhY2UgPT09IFNSR0JDb2xvclNwYWNlICkgPyBHUFVUZXh0dXJlRm9ybWF0LkFTVEM1eDRVbm9ybVNSR0IgOiBHUFVUZXh0dXJlRm9ybWF0LkFTVEM1eDRVbm9ybTtcclxuXHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdGNhc2UgUkdCQV9BU1RDXzV4NV9Gb3JtYXQ6XHJcblx0XHRcdFx0Zm9ybWF0R1BVID0gKCBjb2xvclNwYWNlID09PSBTUkdCQ29sb3JTcGFjZSApID8gR1BVVGV4dHVyZUZvcm1hdC5BU1RDNXg1VW5vcm1TUkdCIDogR1BVVGV4dHVyZUZvcm1hdC5BU1RDNXg1VW5vcm07XHJcblx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRjYXNlIFJHQkFfQVNUQ182eDVfRm9ybWF0OlxyXG5cdFx0XHRcdGZvcm1hdEdQVSA9ICggY29sb3JTcGFjZSA9PT0gU1JHQkNvbG9yU3BhY2UgKSA/IEdQVVRleHR1cmVGb3JtYXQuQVNUQzZ4NVVub3JtU1JHQiA6IEdQVVRleHR1cmVGb3JtYXQuQVNUQzZ4NVVub3JtO1xyXG5cdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0Y2FzZSBSR0JBX0FTVENfNng2X0Zvcm1hdDpcclxuXHRcdFx0XHRmb3JtYXRHUFUgPSAoIGNvbG9yU3BhY2UgPT09IFNSR0JDb2xvclNwYWNlICkgPyBHUFVUZXh0dXJlRm9ybWF0LkFTVEM2eDZVbm9ybVNSR0IgOiBHUFVUZXh0dXJlRm9ybWF0LkFTVEM2eDZVbm9ybTtcclxuXHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdGNhc2UgUkdCQV9BU1RDXzh4NV9Gb3JtYXQ6XHJcblx0XHRcdFx0Zm9ybWF0R1BVID0gKCBjb2xvclNwYWNlID09PSBTUkdCQ29sb3JTcGFjZSApID8gR1BVVGV4dHVyZUZvcm1hdC5BU1RDOHg1VW5vcm1TUkdCIDogR1BVVGV4dHVyZUZvcm1hdC5BU1RDOHg1VW5vcm07XHJcblx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRjYXNlIFJHQkFfQVNUQ184eDZfRm9ybWF0OlxyXG5cdFx0XHRcdGZvcm1hdEdQVSA9ICggY29sb3JTcGFjZSA9PT0gU1JHQkNvbG9yU3BhY2UgKSA/IEdQVVRleHR1cmVGb3JtYXQuQVNUQzh4NlVub3JtU1JHQiA6IEdQVVRleHR1cmVGb3JtYXQuQVNUQzh4NlVub3JtO1xyXG5cdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0Y2FzZSBSR0JBX0FTVENfOHg4X0Zvcm1hdDpcclxuXHRcdFx0XHRmb3JtYXRHUFUgPSAoIGNvbG9yU3BhY2UgPT09IFNSR0JDb2xvclNwYWNlICkgPyBHUFVUZXh0dXJlRm9ybWF0LkFTVEM4eDhVbm9ybVNSR0IgOiBHUFVUZXh0dXJlRm9ybWF0LkFTVEM4eDhVbm9ybTtcclxuXHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdGNhc2UgUkdCQV9BU1RDXzEweDVfRm9ybWF0OlxyXG5cdFx0XHRcdGZvcm1hdEdQVSA9ICggY29sb3JTcGFjZSA9PT0gU1JHQkNvbG9yU3BhY2UgKSA/IEdQVVRleHR1cmVGb3JtYXQuQVNUQzEweDVVbm9ybVNSR0IgOiBHUFVUZXh0dXJlRm9ybWF0LkFTVEMxMHg1VW5vcm07XHJcblx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRjYXNlIFJHQkFfQVNUQ18xMHg2X0Zvcm1hdDpcclxuXHRcdFx0XHRmb3JtYXRHUFUgPSAoIGNvbG9yU3BhY2UgPT09IFNSR0JDb2xvclNwYWNlICkgPyBHUFVUZXh0dXJlRm9ybWF0LkFTVEMxMHg2VW5vcm1TUkdCIDogR1BVVGV4dHVyZUZvcm1hdC5BU1RDMTB4NlVub3JtO1xyXG5cdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0Y2FzZSBSR0JBX0FTVENfMTB4OF9Gb3JtYXQ6XHJcblx0XHRcdFx0Zm9ybWF0R1BVID0gKCBjb2xvclNwYWNlID09PSBTUkdCQ29sb3JTcGFjZSApID8gR1BVVGV4dHVyZUZvcm1hdC5BU1RDMTB4OFVub3JtU1JHQiA6IEdQVVRleHR1cmVGb3JtYXQuQVNUQzEweDhVbm9ybTtcclxuXHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdGNhc2UgUkdCQV9BU1RDXzEweDEwX0Zvcm1hdDpcclxuXHRcdFx0XHRmb3JtYXRHUFUgPSAoIGNvbG9yU3BhY2UgPT09IFNSR0JDb2xvclNwYWNlICkgPyBHUFVUZXh0dXJlRm9ybWF0LkFTVEMxMHgxMFVub3JtU1JHQiA6IEdQVVRleHR1cmVGb3JtYXQuQVNUQzEweDEwVW5vcm07XHJcblx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRjYXNlIFJHQkFfQVNUQ18xMngxMF9Gb3JtYXQ6XHJcblx0XHRcdFx0Zm9ybWF0R1BVID0gKCBjb2xvclNwYWNlID09PSBTUkdCQ29sb3JTcGFjZSApID8gR1BVVGV4dHVyZUZvcm1hdC5BU1RDMTJ4MTBVbm9ybVNSR0IgOiBHUFVUZXh0dXJlRm9ybWF0LkFTVEMxMngxMFVub3JtO1xyXG5cdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0Y2FzZSBSR0JBX0FTVENfMTJ4MTJfRm9ybWF0OlxyXG5cdFx0XHRcdGZvcm1hdEdQVSA9ICggY29sb3JTcGFjZSA9PT0gU1JHQkNvbG9yU3BhY2UgKSA/IEdQVVRleHR1cmVGb3JtYXQuQVNUQzEyeDEyVW5vcm1TUkdCIDogR1BVVGV4dHVyZUZvcm1hdC5BU1RDMTJ4MTJVbm9ybTtcclxuXHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdGNhc2UgUkdCQUZvcm1hdDpcclxuXHRcdFx0XHRmb3JtYXRHUFUgPSAoIGNvbG9yU3BhY2UgPT09IFNSR0JDb2xvclNwYWNlICkgPyBHUFVUZXh0dXJlRm9ybWF0LlJHQkE4VW5vcm1TUkdCIDogR1BVVGV4dHVyZUZvcm1hdC5SR0JBOFVub3JtO1xyXG5cdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0ZGVmYXVsdDpcclxuXHRcdFx0XHRjb25zb2xlLmVycm9yKCAnV2ViR1BVUmVuZGVyZXI6IFVuc3VwcG9ydGVkIHRleHR1cmUgZm9ybWF0LicsIGZvcm1hdCApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fSBlbHNlIHtcclxuXHJcblx0XHRzd2l0Y2ggKCBmb3JtYXQgKSB7XHJcblxyXG5cdFx0XHRjYXNlIFJHQkFGb3JtYXQ6XHJcblxyXG5cdFx0XHRcdHN3aXRjaCAoIHR5cGUgKSB7XHJcblxyXG5cdFx0XHRcdFx0Y2FzZSBCeXRlVHlwZTpcclxuXHRcdFx0XHRcdFx0Zm9ybWF0R1BVID0gR1BVVGV4dHVyZUZvcm1hdC5SR0JBOFNub3JtO1xyXG5cdFx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0XHRjYXNlIFNob3J0VHlwZTpcclxuXHRcdFx0XHRcdFx0Zm9ybWF0R1BVID0gR1BVVGV4dHVyZUZvcm1hdC5SR0JBMTZTaW50O1xyXG5cdFx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0XHRjYXNlIFVuc2lnbmVkU2hvcnRUeXBlOlxyXG5cdFx0XHRcdFx0XHRmb3JtYXRHUFUgPSBHUFVUZXh0dXJlRm9ybWF0LlJHQkExNlVpbnQ7XHJcblx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdFx0Y2FzZSBVbnNpZ25lZEludFR5cGU6XHJcblx0XHRcdFx0XHRcdGZvcm1hdEdQVSA9IEdQVVRleHR1cmVGb3JtYXQuUkdCQTMyVWludDtcclxuXHRcdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdFx0Y2FzZSBJbnRUeXBlOlxyXG5cdFx0XHRcdFx0XHRmb3JtYXRHUFUgPSBHUFVUZXh0dXJlRm9ybWF0LlJHQkEzMlNpbnQ7XHJcblx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRcdGNhc2UgVW5zaWduZWRCeXRlVHlwZTpcclxuXHRcdFx0XHRcdFx0Zm9ybWF0R1BVID0gKCBjb2xvclNwYWNlID09PSBTUkdCQ29sb3JTcGFjZSApID8gR1BVVGV4dHVyZUZvcm1hdC5SR0JBOFVub3JtU1JHQiA6IEdQVVRleHR1cmVGb3JtYXQuUkdCQThVbm9ybTtcclxuXHRcdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdFx0Y2FzZSBIYWxmRmxvYXRUeXBlOlxyXG5cdFx0XHRcdFx0XHRmb3JtYXRHUFUgPSBHUFVUZXh0dXJlRm9ybWF0LlJHQkExNkZsb2F0O1xyXG5cdFx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0XHRjYXNlIEZsb2F0VHlwZTpcclxuXHRcdFx0XHRcdFx0Zm9ybWF0R1BVID0gR1BVVGV4dHVyZUZvcm1hdC5SR0JBMzJGbG9hdDtcclxuXHRcdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdFx0ZGVmYXVsdDpcclxuXHRcdFx0XHRcdFx0Y29uc29sZS5lcnJvciggJ1dlYkdQVVJlbmRlcmVyOiBVbnN1cHBvcnRlZCB0ZXh0dXJlIHR5cGUgd2l0aCBSR0JBRm9ybWF0LicsIHR5cGUgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdGNhc2UgUkdCRm9ybWF0OlxyXG5cclxuXHRcdFx0XHRzd2l0Y2ggKCB0eXBlICkge1xyXG5cclxuXHRcdFx0XHRcdGNhc2UgVW5zaWduZWRJbnQ1OTk5VHlwZTpcclxuXHRcdFx0XHRcdFx0Zm9ybWF0R1BVID0gR1BVVGV4dHVyZUZvcm1hdC5SR0I5RTVVRmxvYXQ7XHJcblx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRcdGRlZmF1bHQ6XHJcblx0XHRcdFx0XHRcdGNvbnNvbGUuZXJyb3IoICdXZWJHUFVSZW5kZXJlcjogVW5zdXBwb3J0ZWQgdGV4dHVyZSB0eXBlIHdpdGggUkdCRm9ybWF0LicsIHR5cGUgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdGNhc2UgUmVkRm9ybWF0OlxyXG5cclxuXHRcdFx0XHRzd2l0Y2ggKCB0eXBlICkge1xyXG5cclxuXHRcdFx0XHRcdGNhc2UgQnl0ZVR5cGU6XHJcblx0XHRcdFx0XHRcdGZvcm1hdEdQVSA9IEdQVVRleHR1cmVGb3JtYXQuUjhTbm9ybTtcclxuXHRcdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdFx0Y2FzZSBTaG9ydFR5cGU6XHJcblx0XHRcdFx0XHRcdGZvcm1hdEdQVSA9IEdQVVRleHR1cmVGb3JtYXQuUjE2U2ludDtcclxuXHRcdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdFx0Y2FzZSBVbnNpZ25lZFNob3J0VHlwZTpcclxuXHRcdFx0XHRcdFx0Zm9ybWF0R1BVID0gR1BVVGV4dHVyZUZvcm1hdC5SMTZVaW50O1xyXG5cdFx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0XHRjYXNlIFVuc2lnbmVkSW50VHlwZTpcclxuXHRcdFx0XHRcdFx0Zm9ybWF0R1BVID0gR1BVVGV4dHVyZUZvcm1hdC5SMzJVaW50O1xyXG5cdFx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0XHRjYXNlIEludFR5cGU6XHJcblx0XHRcdFx0XHRcdGZvcm1hdEdQVSA9IEdQVVRleHR1cmVGb3JtYXQuUjMyU2ludDtcclxuXHRcdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdFx0Y2FzZSBVbnNpZ25lZEJ5dGVUeXBlOlxyXG5cdFx0XHRcdFx0XHRmb3JtYXRHUFUgPSBHUFVUZXh0dXJlRm9ybWF0LlI4VW5vcm07XHJcblx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRcdGNhc2UgSGFsZkZsb2F0VHlwZTpcclxuXHRcdFx0XHRcdFx0Zm9ybWF0R1BVID0gR1BVVGV4dHVyZUZvcm1hdC5SMTZGbG9hdDtcclxuXHRcdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdFx0Y2FzZSBGbG9hdFR5cGU6XHJcblx0XHRcdFx0XHRcdGZvcm1hdEdQVSA9IEdQVVRleHR1cmVGb3JtYXQuUjMyRmxvYXQ7XHJcblx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRcdGRlZmF1bHQ6XHJcblx0XHRcdFx0XHRcdGNvbnNvbGUuZXJyb3IoICdXZWJHUFVSZW5kZXJlcjogVW5zdXBwb3J0ZWQgdGV4dHVyZSB0eXBlIHdpdGggUmVkRm9ybWF0LicsIHR5cGUgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdGNhc2UgUkdGb3JtYXQ6XHJcblxyXG5cdFx0XHRcdHN3aXRjaCAoIHR5cGUgKSB7XHJcblxyXG5cdFx0XHRcdFx0Y2FzZSBCeXRlVHlwZTpcclxuXHRcdFx0XHRcdFx0Zm9ybWF0R1BVID0gR1BVVGV4dHVyZUZvcm1hdC5SRzhTbm9ybTtcclxuXHRcdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdFx0Y2FzZSBTaG9ydFR5cGU6XHJcblx0XHRcdFx0XHRcdGZvcm1hdEdQVSA9IEdQVVRleHR1cmVGb3JtYXQuUkcxNlNpbnQ7XHJcblx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRcdGNhc2UgVW5zaWduZWRTaG9ydFR5cGU6XHJcblx0XHRcdFx0XHRcdGZvcm1hdEdQVSA9IEdQVVRleHR1cmVGb3JtYXQuUkcxNlVpbnQ7XHJcblx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRcdGNhc2UgVW5zaWduZWRJbnRUeXBlOlxyXG5cdFx0XHRcdFx0XHRmb3JtYXRHUFUgPSBHUFVUZXh0dXJlRm9ybWF0LlJHMzJVaW50O1xyXG5cdFx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0XHRjYXNlIEludFR5cGU6XHJcblx0XHRcdFx0XHRcdGZvcm1hdEdQVSA9IEdQVVRleHR1cmVGb3JtYXQuUkczMlNpbnQ7XHJcblx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRcdGNhc2UgVW5zaWduZWRCeXRlVHlwZTpcclxuXHRcdFx0XHRcdFx0Zm9ybWF0R1BVID0gR1BVVGV4dHVyZUZvcm1hdC5SRzhVbm9ybTtcclxuXHRcdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdFx0Y2FzZSBIYWxmRmxvYXRUeXBlOlxyXG5cdFx0XHRcdFx0XHRmb3JtYXRHUFUgPSBHUFVUZXh0dXJlRm9ybWF0LlJHMTZGbG9hdDtcclxuXHRcdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdFx0Y2FzZSBGbG9hdFR5cGU6XHJcblx0XHRcdFx0XHRcdGZvcm1hdEdQVSA9IEdQVVRleHR1cmVGb3JtYXQuUkczMkZsb2F0O1xyXG5cdFx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0XHRkZWZhdWx0OlxyXG5cdFx0XHRcdFx0XHRjb25zb2xlLmVycm9yKCAnV2ViR1BVUmVuZGVyZXI6IFVuc3VwcG9ydGVkIHRleHR1cmUgdHlwZSB3aXRoIFJHRm9ybWF0LicsIHR5cGUgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdGNhc2UgRGVwdGhGb3JtYXQ6XHJcblxyXG5cdFx0XHRcdHN3aXRjaCAoIHR5cGUgKSB7XHJcblxyXG5cdFx0XHRcdFx0Y2FzZSBVbnNpZ25lZFNob3J0VHlwZTpcclxuXHRcdFx0XHRcdFx0Zm9ybWF0R1BVID0gR1BVVGV4dHVyZUZvcm1hdC5EZXB0aDE2VW5vcm07XHJcblx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRcdGNhc2UgVW5zaWduZWRJbnRUeXBlOlxyXG5cdFx0XHRcdFx0XHRmb3JtYXRHUFUgPSBHUFVUZXh0dXJlRm9ybWF0LkRlcHRoMjRQbHVzO1xyXG5cdFx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0XHRjYXNlIEZsb2F0VHlwZTpcclxuXHRcdFx0XHRcdFx0Zm9ybWF0R1BVID0gR1BVVGV4dHVyZUZvcm1hdC5EZXB0aDMyRmxvYXQ7XHJcblx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRcdGRlZmF1bHQ6XHJcblx0XHRcdFx0XHRcdGNvbnNvbGUuZXJyb3IoICdXZWJHUFVSZW5kZXJlcjogVW5zdXBwb3J0ZWQgdGV4dHVyZSB0eXBlIHdpdGggRGVwdGhGb3JtYXQuJywgdHlwZSApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0Y2FzZSBEZXB0aFN0ZW5jaWxGb3JtYXQ6XHJcblxyXG5cdFx0XHRcdHN3aXRjaCAoIHR5cGUgKSB7XHJcblxyXG5cdFx0XHRcdFx0Y2FzZSBVbnNpZ25lZEludDI0OFR5cGU6XHJcblx0XHRcdFx0XHRcdGZvcm1hdEdQVSA9IEdQVVRleHR1cmVGb3JtYXQuRGVwdGgyNFBsdXNTdGVuY2lsODtcclxuXHRcdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdFx0Y2FzZSBGbG9hdFR5cGU6XHJcblxyXG5cdFx0XHRcdFx0XHRpZiAoIGRldmljZSAmJiBkZXZpY2UuZmVhdHVyZXMuaGFzKCBHUFVGZWF0dXJlTmFtZS5EZXB0aDMyRmxvYXRTdGVuY2lsOCApID09PSBmYWxzZSApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0Y29uc29sZS5lcnJvciggJ1dlYkdQVVJlbmRlcmVyOiBEZXB0aCB0ZXh0dXJlcyB3aXRoIERlcHRoU3RlbmNpbEZvcm1hdCArIEZsb2F0VHlwZSBjYW4gb25seSBiZSB1c2VkIHdpdGggdGhlIFwiZGVwdGgzMmZsb2F0LXN0ZW5jaWw4XCIgR1BVIGZlYXR1cmUuJyApO1xyXG5cclxuXHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdFx0Zm9ybWF0R1BVID0gR1BVVGV4dHVyZUZvcm1hdC5EZXB0aDMyRmxvYXRTdGVuY2lsODtcclxuXHJcblx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRcdGRlZmF1bHQ6XHJcblx0XHRcdFx0XHRcdGNvbnNvbGUuZXJyb3IoICdXZWJHUFVSZW5kZXJlcjogVW5zdXBwb3J0ZWQgdGV4dHVyZSB0eXBlIHdpdGggRGVwdGhTdGVuY2lsRm9ybWF0LicsIHR5cGUgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdGNhc2UgUmVkSW50ZWdlckZvcm1hdDpcclxuXHJcblx0XHRcdFx0c3dpdGNoICggdHlwZSApIHtcclxuXHJcblx0XHRcdFx0XHRjYXNlIEludFR5cGU6XHJcblx0XHRcdFx0XHRcdGZvcm1hdEdQVSA9IEdQVVRleHR1cmVGb3JtYXQuUjMyU2ludDtcclxuXHRcdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdFx0Y2FzZSBVbnNpZ25lZEludFR5cGU6XHJcblx0XHRcdFx0XHRcdGZvcm1hdEdQVSA9IEdQVVRleHR1cmVGb3JtYXQuUjMyVWludDtcclxuXHRcdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdFx0ZGVmYXVsdDpcclxuXHRcdFx0XHRcdFx0Y29uc29sZS5lcnJvciggJ1dlYkdQVVJlbmRlcmVyOiBVbnN1cHBvcnRlZCB0ZXh0dXJlIHR5cGUgd2l0aCBSZWRJbnRlZ2VyRm9ybWF0LicsIHR5cGUgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdGNhc2UgUkdJbnRlZ2VyRm9ybWF0OlxyXG5cclxuXHRcdFx0XHRzd2l0Y2ggKCB0eXBlICkge1xyXG5cclxuXHRcdFx0XHRcdGNhc2UgSW50VHlwZTpcclxuXHRcdFx0XHRcdFx0Zm9ybWF0R1BVID0gR1BVVGV4dHVyZUZvcm1hdC5SRzMyU2ludDtcclxuXHRcdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdFx0Y2FzZSBVbnNpZ25lZEludFR5cGU6XHJcblx0XHRcdFx0XHRcdGZvcm1hdEdQVSA9IEdQVVRleHR1cmVGb3JtYXQuUkczMlVpbnQ7XHJcblx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRcdGRlZmF1bHQ6XHJcblx0XHRcdFx0XHRcdGNvbnNvbGUuZXJyb3IoICdXZWJHUFVSZW5kZXJlcjogVW5zdXBwb3J0ZWQgdGV4dHVyZSB0eXBlIHdpdGggUkdJbnRlZ2VyRm9ybWF0LicsIHR5cGUgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdGNhc2UgUkdCQUludGVnZXJGb3JtYXQ6XHJcblxyXG5cdFx0XHRcdHN3aXRjaCAoIHR5cGUgKSB7XHJcblxyXG5cdFx0XHRcdFx0Y2FzZSBJbnRUeXBlOlxyXG5cdFx0XHRcdFx0XHRmb3JtYXRHUFUgPSBHUFVUZXh0dXJlRm9ybWF0LlJHQkEzMlNpbnQ7XHJcblx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRcdGNhc2UgVW5zaWduZWRJbnRUeXBlOlxyXG5cdFx0XHRcdFx0XHRmb3JtYXRHUFUgPSBHUFVUZXh0dXJlRm9ybWF0LlJHQkEzMlVpbnQ7XHJcblx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRcdGRlZmF1bHQ6XHJcblx0XHRcdFx0XHRcdGNvbnNvbGUuZXJyb3IoICdXZWJHUFVSZW5kZXJlcjogVW5zdXBwb3J0ZWQgdGV4dHVyZSB0eXBlIHdpdGggUkdCQUludGVnZXJGb3JtYXQuJywgdHlwZSApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0ZGVmYXVsdDpcclxuXHRcdFx0XHRjb25zb2xlLmVycm9yKCAnV2ViR1BVUmVuZGVyZXI6IFVuc3VwcG9ydGVkIHRleHR1cmUgZm9ybWF0LicsIGZvcm1hdCApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHRyZXR1cm4gZm9ybWF0R1BVO1xyXG5cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgV2ViR1BVVGV4dHVyZVV0aWxzO1xyXG4iLCJpbXBvcnQgTm9kZUZ1bmN0aW9uIGZyb20gJy4uLy4uLy4uL25vZGVzL2NvcmUvTm9kZUZ1bmN0aW9uLmpzJztcclxuaW1wb3J0IE5vZGVGdW5jdGlvbklucHV0IGZyb20gJy4uLy4uLy4uL25vZGVzL2NvcmUvTm9kZUZ1bmN0aW9uSW5wdXQuanMnO1xyXG5cclxuY29uc3QgZGVjbGFyYXRpb25SZWdleHAgPSAvXltmbl0qXFxzKihbYS16XzAtOV0rKT9cXHMqXFwoKFtcXHNcXFNdKj8pXFwpXFxzKltcXC1cXD5dKlxccyooW2Etel8wLTldKyg/OjxbXFxzXFxTXSs/Pik/KS9pO1xyXG5jb25zdCBwcm9wZXJ0aWVzUmVnZXhwID0gLyhbYS16XzAtOV0rKVxccyo6XFxzKihbYS16XzAtOV0rKD86PFtcXHNcXFNdKz8+KT8pL2lnO1xyXG5cclxuY29uc3Qgd2dzbFR5cGVMaWIgPSB7XHJcblx0J2YzMic6ICdmbG9hdCcsXHJcblx0J2kzMic6ICdpbnQnLFxyXG5cdCd1MzInOiAndWludCcsXHJcblx0J2Jvb2wnOiAnYm9vbCcsXHJcblxyXG5cdCd2ZWMyPGYzMj4nOiAndmVjMicsXHJcbiBcdCd2ZWMyPGkzMj4nOiAnaXZlYzInLFxyXG4gXHQndmVjMjx1MzI+JzogJ3V2ZWMyJyxcclxuIFx0J3ZlYzI8Ym9vbD4nOiAnYnZlYzInLFxyXG5cclxuXHQndmVjMmYnOiAndmVjMicsXHJcblx0J3ZlYzJpJzogJ2l2ZWMyJyxcclxuXHQndmVjMnUnOiAndXZlYzInLFxyXG5cdCd2ZWMyYic6ICdidmVjMicsXHJcblxyXG5cdCd2ZWMzPGYzMj4nOiAndmVjMycsXHJcblx0J3ZlYzM8aTMyPic6ICdpdmVjMycsXHJcblx0J3ZlYzM8dTMyPic6ICd1dmVjMycsXHJcblx0J3ZlYzM8Ym9vbD4nOiAnYnZlYzMnLFxyXG5cclxuXHQndmVjM2YnOiAndmVjMycsXHJcblx0J3ZlYzNpJzogJ2l2ZWMzJyxcclxuXHQndmVjM3UnOiAndXZlYzMnLFxyXG5cdCd2ZWMzYic6ICdidmVjMycsXHJcblxyXG5cdCd2ZWM0PGYzMj4nOiAndmVjNCcsXHJcblx0J3ZlYzQ8aTMyPic6ICdpdmVjNCcsXHJcblx0J3ZlYzQ8dTMyPic6ICd1dmVjNCcsXHJcblx0J3ZlYzQ8Ym9vbD4nOiAnYnZlYzQnLFxyXG5cclxuXHQndmVjNGYnOiAndmVjNCcsXHJcblx0J3ZlYzRpJzogJ2l2ZWM0JyxcclxuXHQndmVjNHUnOiAndXZlYzQnLFxyXG5cdCd2ZWM0Yic6ICdidmVjNCcsXHJcblxyXG5cdCdtYXQyeDI8ZjMyPic6ICdtYXQyJyxcclxuXHQnbWF0MngyZic6ICdtYXQyJyxcclxuXHJcblx0J21hdDN4MzxmMzI+JzogJ21hdDMnLFxyXG5cdCdtYXQzeDNmJzogJ21hdDMnLFxyXG5cclxuXHQnbWF0NHg0PGYzMj4nOiAnbWF0NCcsXHJcblx0J21hdDR4NGYnOiAnbWF0NCcsXHJcblxyXG5cdCdzYW1wbGVyJzogJ3NhbXBsZXInLFxyXG5cclxuXHQndGV4dHVyZV8xZCc6ICd0ZXh0dXJlJyxcclxuXHJcblx0J3RleHR1cmVfMmQnOiAndGV4dHVyZScsXHJcblx0J3RleHR1cmVfMmRfYXJyYXknOiAndGV4dHVyZScsXHJcblx0J3RleHR1cmVfbXVsdGlzYW1wbGVkXzJkJzogJ2N1YmVUZXh0dXJlJyxcclxuXHJcblx0J3RleHR1cmVfZGVwdGhfMmQnOiAnZGVwdGhUZXh0dXJlJyxcclxuXHQndGV4dHVyZV9kZXB0aF9tdWx0aXNhbXBsZWRfMmQnOiAnZGVwdGhUZXh0dXJlJyxcclxuXHJcblx0J3RleHR1cmVfM2QnOiAndGV4dHVyZTNEJyxcclxuXHJcblx0J3RleHR1cmVfY3ViZSc6ICdjdWJlVGV4dHVyZScsXHJcblx0J3RleHR1cmVfY3ViZV9hcnJheSc6ICdjdWJlVGV4dHVyZScsXHJcblxyXG5cdCd0ZXh0dXJlX3N0b3JhZ2VfMWQnOiAnc3RvcmFnZVRleHR1cmUnLFxyXG5cdCd0ZXh0dXJlX3N0b3JhZ2VfMmQnOiAnc3RvcmFnZVRleHR1cmUnLFxyXG5cdCd0ZXh0dXJlX3N0b3JhZ2VfMmRfYXJyYXknOiAnc3RvcmFnZVRleHR1cmUnLFxyXG5cdCd0ZXh0dXJlX3N0b3JhZ2VfM2QnOiAnc3RvcmFnZVRleHR1cmUnXHJcblxyXG59O1xyXG5cclxuY29uc3QgcGFyc2UgPSAoIHNvdXJjZSApID0+IHtcclxuXHJcblx0c291cmNlID0gc291cmNlLnRyaW0oKTtcclxuXHJcblx0Y29uc3QgZGVjbGFyYXRpb24gPSBzb3VyY2UubWF0Y2goIGRlY2xhcmF0aW9uUmVnZXhwICk7XHJcblxyXG5cdGlmICggZGVjbGFyYXRpb24gIT09IG51bGwgJiYgZGVjbGFyYXRpb24ubGVuZ3RoID09PSA0ICkge1xyXG5cclxuXHRcdGNvbnN0IGlucHV0c0NvZGUgPSBkZWNsYXJhdGlvblsgMiBdO1xyXG5cdFx0Y29uc3QgcHJvcHNNYXRjaGVzID0gW107XHJcblx0XHRsZXQgbWF0Y2ggPSBudWxsO1xyXG5cclxuXHRcdHdoaWxlICggKCBtYXRjaCA9IHByb3BlcnRpZXNSZWdleHAuZXhlYyggaW5wdXRzQ29kZSApICkgIT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHRwcm9wc01hdGNoZXMucHVzaCggeyBuYW1lOiBtYXRjaFsgMSBdLCB0eXBlOiBtYXRjaFsgMiBdIH0gKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gUHJvY2VzcyBtYXRjaGVzIHRvIGNvcnJlY3RseSBwYWlyIG5hbWVzIGFuZCB0eXBlc1xyXG5cdFx0Y29uc3QgaW5wdXRzID0gW107XHJcblx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCBwcm9wc01hdGNoZXMubGVuZ3RoOyBpICsrICkge1xyXG5cclxuXHRcdFx0Y29uc3QgeyBuYW1lLCB0eXBlIH0gPSBwcm9wc01hdGNoZXNbIGkgXTtcclxuXHJcblx0XHRcdGxldCByZXNvbHZlZFR5cGUgPSB0eXBlO1xyXG5cclxuXHRcdFx0aWYgKCByZXNvbHZlZFR5cGUuc3RhcnRzV2l0aCggJ3B0cicgKSApIHtcclxuXHJcblx0XHRcdFx0cmVzb2x2ZWRUeXBlID0gJ3BvaW50ZXInO1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0aWYgKCByZXNvbHZlZFR5cGUuc3RhcnRzV2l0aCggJ3RleHR1cmUnICkgKSB7XHJcblxyXG5cdFx0XHRcdFx0cmVzb2x2ZWRUeXBlID0gdHlwZS5zcGxpdCggJzwnIClbIDAgXTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRyZXNvbHZlZFR5cGUgPSB3Z3NsVHlwZUxpYlsgcmVzb2x2ZWRUeXBlIF07XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpbnB1dHMucHVzaCggbmV3IE5vZGVGdW5jdGlvbklucHV0KCByZXNvbHZlZFR5cGUsIG5hbWUgKSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRjb25zdCBibG9ja0NvZGUgPSBzb3VyY2Uuc3Vic3RyaW5nKCBkZWNsYXJhdGlvblsgMCBdLmxlbmd0aCApO1xyXG5cdFx0Y29uc3Qgb3V0cHV0VHlwZSA9IGRlY2xhcmF0aW9uWyAzIF0gfHwgJ3ZvaWQnO1xyXG5cclxuXHRcdGNvbnN0IG5hbWUgPSBkZWNsYXJhdGlvblsgMSBdICE9PSB1bmRlZmluZWQgPyBkZWNsYXJhdGlvblsgMSBdIDogJyc7XHJcblx0XHRjb25zdCB0eXBlID0gd2dzbFR5cGVMaWJbIG91dHB1dFR5cGUgXSB8fCBvdXRwdXRUeXBlO1xyXG5cclxuXHRcdHJldHVybiB7XHJcblx0XHRcdHR5cGUsXHJcblx0XHRcdGlucHV0cyxcclxuXHRcdFx0bmFtZSxcclxuXHRcdFx0aW5wdXRzQ29kZSxcclxuXHRcdFx0YmxvY2tDb2RlLFxyXG5cdFx0XHRvdXRwdXRUeXBlXHJcblx0XHR9O1xyXG5cclxuXHR9IGVsc2Uge1xyXG5cclxuXHRcdHRocm93IG5ldyBFcnJvciggJ0Z1bmN0aW9uTm9kZTogRnVuY3Rpb24gaXMgbm90IGEgV0dTTCBjb2RlLicgKTtcclxuXHJcblx0fVxyXG5cclxufTtcclxuXHJcbi8qKlxyXG4gKiBUaGlzIGNsYXNzIHJlcHJlc2VudHMgYSBXU0wgbm9kZSBmdW5jdGlvbi5cclxuICpcclxuICogQGF1Z21lbnRzIE5vZGVGdW5jdGlvblxyXG4gKi9cclxuY2xhc3MgV0dTTE5vZGVGdW5jdGlvbiBleHRlbmRzIE5vZGVGdW5jdGlvbiB7XHJcblxyXG5cdC8qKlxyXG5cdCAqIENvbnN0cnVjdHMgYSBuZXcgV0dTTCBub2RlIGZ1bmN0aW9uLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtTdHJpbmd9IHNvdXJjZSAtIFRoZSBXR1NMIHNvdXJjZS5cclxuXHQgKi9cclxuXHRjb25zdHJ1Y3Rvciggc291cmNlICkge1xyXG5cclxuXHRcdGNvbnN0IHsgdHlwZSwgaW5wdXRzLCBuYW1lLCBpbnB1dHNDb2RlLCBibG9ja0NvZGUsIG91dHB1dFR5cGUgfSA9IHBhcnNlKCBzb3VyY2UgKTtcclxuXHJcblx0XHRzdXBlciggdHlwZSwgaW5wdXRzLCBuYW1lICk7XHJcblxyXG5cdFx0dGhpcy5pbnB1dHNDb2RlID0gaW5wdXRzQ29kZTtcclxuXHRcdHRoaXMuYmxvY2tDb2RlID0gYmxvY2tDb2RlO1xyXG5cdFx0dGhpcy5vdXRwdXRUeXBlID0gb3V0cHV0VHlwZTtcclxuXHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBUaGlzIG1ldGhvZCByZXR1cm5zIHRoZSBXR1NMIGNvZGUgb2YgdGhlIG5vZGUgZnVuY3Rpb24uXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge1N0cmluZ30gW25hbWU9dGhpcy5uYW1lXSAtIFRoZSBmdW5jdGlvbidzIG5hbWUuXHJcblx0ICogQHJldHVybiB7U3RyaW5nfSBUaGUgc2hhZGVyIGNvZGUuXHJcblx0ICovXHJcblx0Z2V0Q29kZSggbmFtZSA9IHRoaXMubmFtZSApIHtcclxuXHJcblx0XHRjb25zdCBvdXRwdXRUeXBlID0gdGhpcy5vdXRwdXRUeXBlICE9PSAndm9pZCcgPyAnLT4gJyArIHRoaXMub3V0cHV0VHlwZSA6ICcnO1xyXG5cclxuXHRcdHJldHVybiBgZm4gJHsgbmFtZSB9ICggJHsgdGhpcy5pbnB1dHNDb2RlLnRyaW0oKSB9ICkgJHsgb3V0cHV0VHlwZSB9YCArIHRoaXMuYmxvY2tDb2RlO1xyXG5cclxuXHR9XHJcblxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBXR1NMTm9kZUZ1bmN0aW9uO1xyXG4iLCJpbXBvcnQgTm9kZVBhcnNlciBmcm9tICcuLi8uLi8uLi9ub2Rlcy9jb3JlL05vZGVQYXJzZXIuanMnO1xyXG5pbXBvcnQgV0dTTE5vZGVGdW5jdGlvbiBmcm9tICcuL1dHU0xOb2RlRnVuY3Rpb24uanMnO1xyXG5cclxuLyoqXHJcbiAqIEEgV0dTTCBub2RlIHBhcnNlci5cclxuICpcclxuICogQGF1Z21lbnRzIE5vZGVQYXJzZXJcclxuICovXHJcbmNsYXNzIFdHU0xOb2RlUGFyc2VyIGV4dGVuZHMgTm9kZVBhcnNlciB7XHJcblxyXG5cdC8qKlxyXG5cdCAqIFRoZSBtZXRob2QgcGFyc2VzIHRoZSBnaXZlbiBXR1NMIGNvZGUgYW4gcmV0dXJucyBhIG5vZGUgZnVuY3Rpb24uXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge1N0cmluZ30gc291cmNlIC0gVGhlIFdHU0wgY29kZS5cclxuXHQgKiBAcmV0dXJuIHtXR1NMTm9kZUZ1bmN0aW9ufSBBIG5vZGUgZnVuY3Rpb24uXHJcblx0ICovXHJcblx0cGFyc2VGdW5jdGlvbiggc291cmNlICkge1xyXG5cclxuXHRcdHJldHVybiBuZXcgV0dTTE5vZGVGdW5jdGlvbiggc291cmNlICk7XHJcblxyXG5cdH1cclxuXHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IFdHU0xOb2RlUGFyc2VyO1xyXG4iLCJpbXBvcnQgTm9kZVVuaWZvcm1zR3JvdXAgZnJvbSAnLi4vLi4vY29tbW9uL25vZGVzL05vZGVVbmlmb3Jtc0dyb3VwLmpzJztcclxuXHJcbmltcG9ydCBOb2RlU2FtcGxlciBmcm9tICcuLi8uLi9jb21tb24vbm9kZXMvTm9kZVNhbXBsZXIuanMnO1xyXG5pbXBvcnQgeyBOb2RlU2FtcGxlZFRleHR1cmUsIE5vZGVTYW1wbGVkQ3ViZVRleHR1cmUsIE5vZGVTYW1wbGVkVGV4dHVyZTNEIH0gZnJvbSAnLi4vLi4vY29tbW9uL25vZGVzL05vZGVTYW1wbGVkVGV4dHVyZS5qcyc7XHJcblxyXG5pbXBvcnQgTm9kZVVuaWZvcm1CdWZmZXIgZnJvbSAnLi4vLi4vY29tbW9uL25vZGVzL05vZGVVbmlmb3JtQnVmZmVyLmpzJztcclxuaW1wb3J0IE5vZGVTdG9yYWdlQnVmZmVyIGZyb20gJy4uLy4uL2NvbW1vbi9ub2Rlcy9Ob2RlU3RvcmFnZUJ1ZmZlci5qcyc7XHJcblxyXG5pbXBvcnQgeyBOb2RlQnVpbGRlciwgQ29kZU5vZGUgfSBmcm9tICcuLi8uLi8uLi9ub2Rlcy9Ob2Rlcy5qcyc7XHJcblxyXG5pbXBvcnQgeyBnZXRGb3JtYXQgfSBmcm9tICcuLi91dGlscy9XZWJHUFVUZXh0dXJlVXRpbHMuanMnO1xyXG5cclxuaW1wb3J0IFdHU0xOb2RlUGFyc2VyIGZyb20gJy4vV0dTTE5vZGVQYXJzZXIuanMnO1xyXG5pbXBvcnQgeyBOb2RlQWNjZXNzIH0gZnJvbSAnLi4vLi4vLi4vbm9kZXMvY29yZS9jb25zdGFudHMuanMnO1xyXG5cclxuaW1wb3J0IFZhck5vZGUgZnJvbSAnLi4vLi4vLi4vbm9kZXMvY29yZS9WYXJOb2RlLmpzJztcclxuaW1wb3J0IEV4cHJlc3Npb25Ob2RlIGZyb20gJy4uLy4uLy4uL25vZGVzL2NvZGUvRXhwcmVzc2lvbk5vZGUuanMnO1xyXG5cclxuaW1wb3J0IHsgTm9Db2xvclNwYWNlLCBGbG9hdFR5cGUsIFJlcGVhdFdyYXBwaW5nLCBDbGFtcFRvRWRnZVdyYXBwaW5nLCBNaXJyb3JlZFJlcGVhdFdyYXBwaW5nLCBOZWFyZXN0RmlsdGVyIH0gZnJvbSAnLi4vLi4vLi4vY29uc3RhbnRzLmpzJztcclxuXHJcbi8vIEdQVVNoYWRlclN0YWdlIGlzIG5vdCBkZWZpbmVkIGluIGJyb3dzZXJzIG5vdCBzdXBwb3J0aW5nIFdlYkdQVVxyXG5jb25zdCBHUFVTaGFkZXJTdGFnZSA9ICggdHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnICkgPyBzZWxmLkdQVVNoYWRlclN0YWdlIDogeyBWRVJURVg6IDEsIEZSQUdNRU5UOiAyLCBDT01QVVRFOiA0IH07XHJcblxyXG5jb25zdCBhY2Nlc3NOYW1lcyA9IHtcclxuXHRbIE5vZGVBY2Nlc3MuUkVBRF9PTkxZIF06ICdyZWFkJyxcclxuXHRbIE5vZGVBY2Nlc3MuV1JJVEVfT05MWSBdOiAnd3JpdGUnLFxyXG5cdFsgTm9kZUFjY2Vzcy5SRUFEX1dSSVRFIF06ICdyZWFkX3dyaXRlJ1xyXG59O1xyXG5cclxuY29uc3Qgd3JhcE5hbWVzID0ge1xyXG5cdFsgUmVwZWF0V3JhcHBpbmcgXTogJ3JlcGVhdCcsXHJcblx0WyBDbGFtcFRvRWRnZVdyYXBwaW5nIF06ICdjbGFtcCcsXHJcblx0WyBNaXJyb3JlZFJlcGVhdFdyYXBwaW5nIF06ICdtaXJyb3InXHJcbn07XHJcblxyXG5jb25zdCBncHVTaGFkZXJTdGFnZUxpYiA9IHtcclxuXHQndmVydGV4JzogR1BVU2hhZGVyU3RhZ2UgPyBHUFVTaGFkZXJTdGFnZS5WRVJURVggOiAxLFxyXG5cdCdmcmFnbWVudCc6IEdQVVNoYWRlclN0YWdlID8gR1BVU2hhZGVyU3RhZ2UuRlJBR01FTlQgOiAyLFxyXG5cdCdjb21wdXRlJzogR1BVU2hhZGVyU3RhZ2UgPyBHUFVTaGFkZXJTdGFnZS5DT01QVVRFIDogNFxyXG59O1xyXG5cclxuY29uc3Qgc3VwcG9ydHMgPSB7XHJcblx0aW5zdGFuY2U6IHRydWUsXHJcblx0c3dpenpsZUFzc2lnbjogZmFsc2UsXHJcblx0c3RvcmFnZUJ1ZmZlcjogdHJ1ZVxyXG59O1xyXG5cclxuY29uc3Qgd2dzbEZuT3BMaWIgPSB7XHJcblx0J15eJzogJ3RzbF94b3InXHJcbn07XHJcblxyXG5jb25zdCB3Z3NsVHlwZUxpYiA9IHtcclxuXHRmbG9hdDogJ2YzMicsXHJcblx0aW50OiAnaTMyJyxcclxuXHR1aW50OiAndTMyJyxcclxuXHRib29sOiAnYm9vbCcsXHJcblx0Y29sb3I6ICd2ZWMzPGYzMj4nLFxyXG5cclxuXHR2ZWMyOiAndmVjMjxmMzI+JyxcclxuXHRpdmVjMjogJ3ZlYzI8aTMyPicsXHJcblx0dXZlYzI6ICd2ZWMyPHUzMj4nLFxyXG5cdGJ2ZWMyOiAndmVjMjxib29sPicsXHJcblxyXG5cdHZlYzM6ICd2ZWMzPGYzMj4nLFxyXG5cdGl2ZWMzOiAndmVjMzxpMzI+JyxcclxuXHR1dmVjMzogJ3ZlYzM8dTMyPicsXHJcblx0YnZlYzM6ICd2ZWMzPGJvb2w+JyxcclxuXHJcblx0dmVjNDogJ3ZlYzQ8ZjMyPicsXHJcblx0aXZlYzQ6ICd2ZWM0PGkzMj4nLFxyXG5cdHV2ZWM0OiAndmVjNDx1MzI+JyxcclxuXHRidmVjNDogJ3ZlYzQ8Ym9vbD4nLFxyXG5cclxuXHRtYXQyOiAnbWF0MngyPGYzMj4nLFxyXG5cdG1hdDM6ICdtYXQzeDM8ZjMyPicsXHJcblx0bWF0NDogJ21hdDR4NDxmMzI+J1xyXG59O1xyXG5cclxuY29uc3Qgd2dzbENvZGVDYWNoZSA9IHt9O1xyXG5cclxuY29uc3Qgd2dzbFBvbHlmaWxsID0ge1xyXG5cdHRzbF94b3I6IG5ldyBDb2RlTm9kZSggJ2ZuIHRzbF94b3IoIGEgOiBib29sLCBiIDogYm9vbCApIC0+IGJvb2wgeyByZXR1cm4gKCBhIHx8IGIgKSAmJiAhKCBhICYmIGIgKTsgfScgKSxcclxuXHRtb2RfZmxvYXQ6IG5ldyBDb2RlTm9kZSggJ2ZuIHRzbF9tb2RfZmxvYXQoIHggOiBmMzIsIHkgOiBmMzIgKSAtPiBmMzIgeyByZXR1cm4geCAtIHkgKiBmbG9vciggeCAvIHkgKTsgfScgKSxcclxuXHRtb2RfdmVjMjogbmV3IENvZGVOb2RlKCAnZm4gdHNsX21vZF92ZWMyKCB4IDogdmVjMmYsIHkgOiB2ZWMyZiApIC0+IHZlYzJmIHsgcmV0dXJuIHggLSB5ICogZmxvb3IoIHggLyB5ICk7IH0nICksXHJcblx0bW9kX3ZlYzM6IG5ldyBDb2RlTm9kZSggJ2ZuIHRzbF9tb2RfdmVjMyggeCA6IHZlYzNmLCB5IDogdmVjM2YgKSAtPiB2ZWMzZiB7IHJldHVybiB4IC0geSAqIGZsb29yKCB4IC8geSApOyB9JyApLFxyXG5cdG1vZF92ZWM0OiBuZXcgQ29kZU5vZGUoICdmbiB0c2xfbW9kX3ZlYzQoIHggOiB2ZWM0ZiwgeSA6IHZlYzRmICkgLT4gdmVjNGYgeyByZXR1cm4geCAtIHkgKiBmbG9vciggeCAvIHkgKTsgfScgKSxcclxuXHRlcXVhbHNfYm9vbDogbmV3IENvZGVOb2RlKCAnZm4gdHNsX2VxdWFsc19ib29sKCBhIDogYm9vbCwgYiA6IGJvb2wgKSAtPiBib29sIHsgcmV0dXJuIGEgPT0gYjsgfScgKSxcclxuXHRlcXVhbHNfYnZlYzI6IG5ldyBDb2RlTm9kZSggJ2ZuIHRzbF9lcXVhbHNfYnZlYzIoIGEgOiB2ZWMyZiwgYiA6IHZlYzJmICkgLT4gdmVjMjxib29sPiB7IHJldHVybiB2ZWMyPGJvb2w+KCBhLnggPT0gYi54LCBhLnkgPT0gYi55ICk7IH0nICksXHJcblx0ZXF1YWxzX2J2ZWMzOiBuZXcgQ29kZU5vZGUoICdmbiB0c2xfZXF1YWxzX2J2ZWMzKCBhIDogdmVjM2YsIGIgOiB2ZWMzZiApIC0+IHZlYzM8Ym9vbD4geyByZXR1cm4gdmVjMzxib29sPiggYS54ID09IGIueCwgYS55ID09IGIueSwgYS56ID09IGIueiApOyB9JyApLFxyXG5cdGVxdWFsc19idmVjNDogbmV3IENvZGVOb2RlKCAnZm4gdHNsX2VxdWFsc19idmVjNCggYSA6IHZlYzRmLCBiIDogdmVjNGYgKSAtPiB2ZWM0PGJvb2w+IHsgcmV0dXJuIHZlYzQ8Ym9vbD4oIGEueCA9PSBiLngsIGEueSA9PSBiLnksIGEueiA9PSBiLnosIGEudyA9PSBiLncgKTsgfScgKSxcclxuXHRyZXBlYXRXcmFwcGluZ19mbG9hdDogbmV3IENvZGVOb2RlKCAnZm4gdHNsX3JlcGVhdFdyYXBwaW5nX2Zsb2F0KCBjb29yZDogZjMyICkgLT4gZjMyIHsgcmV0dXJuIGZyYWN0KCBjb29yZCApOyB9JyApLFxyXG5cdG1pcnJvcldyYXBwaW5nX2Zsb2F0OiBuZXcgQ29kZU5vZGUoICdmbiB0c2xfbWlycm9yV3JhcHBpbmdfZmxvYXQoIGNvb3JkOiBmMzIgKSAtPiBmMzIgeyBsZXQgbWlycm9yZWQgPSBmcmFjdCggY29vcmQgKiAwLjUgKSAqIDIuMDsgcmV0dXJuIDEuMCAtIGFicyggMS4wIC0gbWlycm9yZWQgKTsgfScgKSxcclxuXHRjbGFtcFdyYXBwaW5nX2Zsb2F0OiBuZXcgQ29kZU5vZGUoICdmbiB0c2xfY2xhbXBXcmFwcGluZ19mbG9hdCggY29vcmQ6IGYzMiApIC0+IGYzMiB7IHJldHVybiBjbGFtcCggY29vcmQsIDAuMCwgMS4wICk7IH0nICksXHJcblx0YmlxdWFkcmF0aWNUZXh0dXJlOiBuZXcgQ29kZU5vZGUoIC8qIHdnc2wgKi9gXHJcbmZuIHRzbF9iaXF1YWRyYXRpY1RleHR1cmUoIG1hcCA6IHRleHR1cmVfMmQ8ZjMyPiwgY29vcmQgOiB2ZWMyZiwgaVJlcyA6IHZlYzJ1LCBsZXZlbCA6IHUzMiApIC0+IHZlYzRmIHtcclxuXHJcblx0bGV0IHJlcyA9IHZlYzJmKCBpUmVzICk7XHJcblxyXG5cdGxldCB1dlNjYWxlZCA9IGNvb3JkICogcmVzO1xyXG5cdGxldCB1dldyYXBwaW5nID0gKCAoIHV2U2NhbGVkICUgcmVzICkgKyByZXMgKSAlIHJlcztcclxuXHJcblx0Ly8gaHR0cHM6Ly93d3cuc2hhZGVydG95LmNvbS92aWV3L1d0eVhSeVxyXG5cclxuXHRsZXQgdXYgPSB1dldyYXBwaW5nIC0gMC41O1xyXG5cdGxldCBpdXYgPSBmbG9vciggdXYgKTtcclxuXHRsZXQgZiA9IGZyYWN0KCB1diApO1xyXG5cclxuXHRsZXQgcmcxID0gdGV4dHVyZUxvYWQoIG1hcCwgdmVjMnUoIGl1diArIHZlYzIoIDAuNSwgMC41ICkgKSAlIGlSZXMsIGxldmVsICk7XHJcblx0bGV0IHJnMiA9IHRleHR1cmVMb2FkKCBtYXAsIHZlYzJ1KCBpdXYgKyB2ZWMyKCAxLjUsIDAuNSApICkgJSBpUmVzLCBsZXZlbCApO1xyXG5cdGxldCByZzMgPSB0ZXh0dXJlTG9hZCggbWFwLCB2ZWMydSggaXV2ICsgdmVjMiggMC41LCAxLjUgKSApICUgaVJlcywgbGV2ZWwgKTtcclxuXHRsZXQgcmc0ID0gdGV4dHVyZUxvYWQoIG1hcCwgdmVjMnUoIGl1diArIHZlYzIoIDEuNSwgMS41ICkgKSAlIGlSZXMsIGxldmVsICk7XHJcblxyXG5cdHJldHVybiBtaXgoIG1peCggcmcxLCByZzIsIGYueCApLCBtaXgoIHJnMywgcmc0LCBmLnggKSwgZi55ICk7XHJcblxyXG59XHJcbmAgKVxyXG59O1xyXG5cclxuY29uc3Qgd2dzbE1ldGhvZHMgPSB7XHJcblx0ZEZkeDogJ2RwZHgnLFxyXG5cdGRGZHk6ICctIGRwZHknLFxyXG5cdG1vZF9mbG9hdDogJ3RzbF9tb2RfZmxvYXQnLFxyXG5cdG1vZF92ZWMyOiAndHNsX21vZF92ZWMyJyxcclxuXHRtb2RfdmVjMzogJ3RzbF9tb2RfdmVjMycsXHJcblx0bW9kX3ZlYzQ6ICd0c2xfbW9kX3ZlYzQnLFxyXG5cdGVxdWFsc19ib29sOiAndHNsX2VxdWFsc19ib29sJyxcclxuXHRlcXVhbHNfYnZlYzI6ICd0c2xfZXF1YWxzX2J2ZWMyJyxcclxuXHRlcXVhbHNfYnZlYzM6ICd0c2xfZXF1YWxzX2J2ZWMzJyxcclxuXHRlcXVhbHNfYnZlYzQ6ICd0c2xfZXF1YWxzX2J2ZWM0JyxcclxuXHRpbnZlcnNlc3FydDogJ2ludmVyc2VTcXJ0JyxcclxuXHRiaXRjYXN0OiAnYml0Y2FzdDxmMzI+J1xyXG59O1xyXG5cclxuLy8gV2ViR1BVIGlzc3VlOiBkb2VzIG5vdCBzdXBwb3J0IHBvdygpIHdpdGggbmVnYXRpdmUgYmFzZSBvbiBXaW5kb3dzXHJcblxyXG5pZiAoIHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIC9XaW5kb3dzL2cudGVzdCggbmF2aWdhdG9yLnVzZXJBZ2VudCApICkge1xyXG5cclxuXHR3Z3NsUG9seWZpbGwucG93X2Zsb2F0ID0gbmV3IENvZGVOb2RlKCAnZm4gdHNsX3Bvd19mbG9hdCggYSA6IGYzMiwgYiA6IGYzMiApIC0+IGYzMiB7IHJldHVybiBzZWxlY3QoIC1wb3coIC1hLCBiICksIHBvdyggYSwgYiApLCBhID4gMC4wICk7IH0nICk7XHJcblx0d2dzbFBvbHlmaWxsLnBvd192ZWMyID0gbmV3IENvZGVOb2RlKCAnZm4gdHNsX3Bvd192ZWMyKCBhIDogdmVjMmYsIGIgOiB2ZWMyZiApIC0+IHZlYzJmIHsgcmV0dXJuIHZlYzJmKCB0c2xfcG93X2Zsb2F0KCBhLngsIGIueCApLCB0c2xfcG93X2Zsb2F0KCBhLnksIGIueSApICk7IH0nLCBbIHdnc2xQb2x5ZmlsbC5wb3dfZmxvYXQgXSApO1xyXG5cdHdnc2xQb2x5ZmlsbC5wb3dfdmVjMyA9IG5ldyBDb2RlTm9kZSggJ2ZuIHRzbF9wb3dfdmVjMyggYSA6IHZlYzNmLCBiIDogdmVjM2YgKSAtPiB2ZWMzZiB7IHJldHVybiB2ZWMzZiggdHNsX3Bvd19mbG9hdCggYS54LCBiLnggKSwgdHNsX3Bvd19mbG9hdCggYS55LCBiLnkgKSwgdHNsX3Bvd19mbG9hdCggYS56LCBiLnogKSApOyB9JywgWyB3Z3NsUG9seWZpbGwucG93X2Zsb2F0IF0gKTtcclxuXHR3Z3NsUG9seWZpbGwucG93X3ZlYzQgPSBuZXcgQ29kZU5vZGUoICdmbiB0c2xfcG93X3ZlYzQoIGEgOiB2ZWM0ZiwgYiA6IHZlYzRmICkgLT4gdmVjNGYgeyByZXR1cm4gdmVjNGYoIHRzbF9wb3dfZmxvYXQoIGEueCwgYi54ICksIHRzbF9wb3dfZmxvYXQoIGEueSwgYi55ICksIHRzbF9wb3dfZmxvYXQoIGEueiwgYi56ICksIHRzbF9wb3dfZmxvYXQoIGEudywgYi53ICkgKTsgfScsIFsgd2dzbFBvbHlmaWxsLnBvd19mbG9hdCBdICk7XHJcblxyXG5cdHdnc2xNZXRob2RzLnBvd19mbG9hdCA9ICd0c2xfcG93X2Zsb2F0JztcclxuXHR3Z3NsTWV0aG9kcy5wb3dfdmVjMiA9ICd0c2xfcG93X3ZlYzInO1xyXG5cdHdnc2xNZXRob2RzLnBvd192ZWMzID0gJ3RzbF9wb3dfdmVjMyc7XHJcblx0d2dzbE1ldGhvZHMucG93X3ZlYzQgPSAndHNsX3Bvd192ZWM0JztcclxuXHJcbn1cclxuXHJcbi8vXHJcblxyXG5sZXQgZGlhZ25vc3RpY3MgPSAnJztcclxuXHJcbmlmICggKCB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiAvRmlyZWZveHxEZW5vL2cudGVzdCggbmF2aWdhdG9yLnVzZXJBZ2VudCApICkgIT09IHRydWUgKSB7XHJcblxyXG5cdGRpYWdub3N0aWNzICs9ICdkaWFnbm9zdGljKCBvZmYsIGRlcml2YXRpdmVfdW5pZm9ybWl0eSApO1xcbic7XHJcblxyXG59XHJcblxyXG4vL1xyXG5cclxuY2xhc3MgV0dTTE5vZGVCdWlsZGVyIGV4dGVuZHMgTm9kZUJ1aWxkZXIge1xyXG5cclxuXHRjb25zdHJ1Y3Rvciggb2JqZWN0LCByZW5kZXJlciApIHtcclxuXHJcblx0XHRzdXBlciggb2JqZWN0LCByZW5kZXJlciwgbmV3IFdHU0xOb2RlUGFyc2VyKCkgKTtcclxuXHJcblx0XHR0aGlzLnVuaWZvcm1Hcm91cHMgPSB7fTtcclxuXHJcblx0XHR0aGlzLmJ1aWx0aW5zID0ge307XHJcblxyXG5cdFx0dGhpcy5kaXJlY3RpdmVzID0ge307XHJcblxyXG5cdFx0dGhpcy5zY29wZWRBcnJheXMgPSBuZXcgTWFwKCk7XHJcblxyXG5cdH1cclxuXHJcblx0bmVlZHNUb1dvcmtpbmdDb2xvclNwYWNlKCB0ZXh0dXJlICkge1xyXG5cclxuXHRcdHJldHVybiB0ZXh0dXJlLmlzVmlkZW9UZXh0dXJlID09PSB0cnVlICYmIHRleHR1cmUuY29sb3JTcGFjZSAhPT0gTm9Db2xvclNwYWNlO1xyXG5cclxuXHR9XHJcblxyXG5cdF9nZW5lcmF0ZVRleHR1cmVTYW1wbGUoIHRleHR1cmUsIHRleHR1cmVQcm9wZXJ0eSwgdXZTbmlwcGV0LCBkZXB0aFNuaXBwZXQsIHNoYWRlclN0YWdlID0gdGhpcy5zaGFkZXJTdGFnZSApIHtcclxuXHJcblx0XHRpZiAoIHNoYWRlclN0YWdlID09PSAnZnJhZ21lbnQnICkge1xyXG5cclxuXHRcdFx0aWYgKCBkZXB0aFNuaXBwZXQgKSB7XHJcblxyXG5cdFx0XHRcdHJldHVybiBgdGV4dHVyZVNhbXBsZSggJHsgdGV4dHVyZVByb3BlcnR5IH0sICR7IHRleHR1cmVQcm9wZXJ0eSB9X3NhbXBsZXIsICR7IHV2U25pcHBldCB9LCAkeyBkZXB0aFNuaXBwZXQgfSApYDtcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdHJldHVybiBgdGV4dHVyZVNhbXBsZSggJHsgdGV4dHVyZVByb3BlcnR5IH0sICR7IHRleHR1cmVQcm9wZXJ0eSB9X3NhbXBsZXIsICR7IHV2U25pcHBldCB9IClgO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH0gZWxzZSBpZiAoIHRoaXMuaXNGaWx0ZXJlZFRleHR1cmUoIHRleHR1cmUgKSApIHtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzLmdlbmVyYXRlRmlsdGVyZWRUZXh0dXJlKCB0ZXh0dXJlLCB0ZXh0dXJlUHJvcGVydHksIHV2U25pcHBldCApO1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcy5nZW5lcmF0ZVRleHR1cmVMb2QoIHRleHR1cmUsIHRleHR1cmVQcm9wZXJ0eSwgdXZTbmlwcGV0LCBkZXB0aFNuaXBwZXQsICcwJyApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHRfZ2VuZXJhdGVWaWRlb1NhbXBsZSggdGV4dHVyZVByb3BlcnR5LCB1dlNuaXBwZXQsIHNoYWRlclN0YWdlID0gdGhpcy5zaGFkZXJTdGFnZSApIHtcclxuXHJcblx0XHRpZiAoIHNoYWRlclN0YWdlID09PSAnZnJhZ21lbnQnICkge1xyXG5cclxuXHRcdFx0cmV0dXJuIGB0ZXh0dXJlU2FtcGxlQmFzZUNsYW1wVG9FZGdlKCAkeyB0ZXh0dXJlUHJvcGVydHkgfSwgJHsgdGV4dHVyZVByb3BlcnR5IH1fc2FtcGxlciwgdmVjMjxmMzI+KCAkeyB1dlNuaXBwZXQgfS54LCAxLjAgLSAkeyB1dlNuaXBwZXQgfS55ICkgKWA7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdGNvbnNvbGUuZXJyb3IoIGBXZWJHUFVSZW5kZXJlcjogVEhSRUUuVmlkZW9UZXh0dXJlIGRvZXMgbm90IHN1cHBvcnQgJHsgc2hhZGVyU3RhZ2UgfSBzaGFkZXIuYCApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHRfZ2VuZXJhdGVUZXh0dXJlU2FtcGxlTGV2ZWwoIHRleHR1cmUsIHRleHR1cmVQcm9wZXJ0eSwgdXZTbmlwcGV0LCBsZXZlbFNuaXBwZXQsIGRlcHRoU25pcHBldCwgc2hhZGVyU3RhZ2UgPSB0aGlzLnNoYWRlclN0YWdlICkge1xyXG5cclxuXHRcdGlmICggKCBzaGFkZXJTdGFnZSA9PT0gJ2ZyYWdtZW50JyB8fCBzaGFkZXJTdGFnZSA9PT0gJ2NvbXB1dGUnICkgJiYgdGhpcy5pc1VuZmlsdGVyYWJsZSggdGV4dHVyZSApID09PSBmYWxzZSApIHtcclxuXHJcblx0XHRcdHJldHVybiBgdGV4dHVyZVNhbXBsZUxldmVsKCAkeyB0ZXh0dXJlUHJvcGVydHkgfSwgJHsgdGV4dHVyZVByb3BlcnR5IH1fc2FtcGxlciwgJHsgdXZTbmlwcGV0IH0sICR7IGxldmVsU25pcHBldCB9IClgO1xyXG5cclxuXHRcdH0gZWxzZSBpZiAoIHRoaXMuaXNGaWx0ZXJlZFRleHR1cmUoIHRleHR1cmUgKSApIHtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzLmdlbmVyYXRlRmlsdGVyZWRUZXh0dXJlKCB0ZXh0dXJlLCB0ZXh0dXJlUHJvcGVydHksIHV2U25pcHBldCwgbGV2ZWxTbmlwcGV0ICk7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzLmdlbmVyYXRlVGV4dHVyZUxvZCggdGV4dHVyZSwgdGV4dHVyZVByb3BlcnR5LCB1dlNuaXBwZXQsIGRlcHRoU25pcHBldCwgbGV2ZWxTbmlwcGV0ICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdGdlbmVyYXRlV3JhcEZ1bmN0aW9uKCB0ZXh0dXJlICkge1xyXG5cclxuXHRcdGNvbnN0IGZ1bmN0aW9uTmFtZSA9IGB0c2xfY29vcmRfJHsgd3JhcE5hbWVzWyB0ZXh0dXJlLndyYXBTIF0gfVNfJHsgd3JhcE5hbWVzWyB0ZXh0dXJlLndyYXBUIF0gfVRgO1xyXG5cclxuXHRcdGxldCBub2RlQ29kZSA9IHdnc2xDb2RlQ2FjaGVbIGZ1bmN0aW9uTmFtZSBdO1xyXG5cclxuXHRcdGlmICggbm9kZUNvZGUgPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdGNvbnN0IGluY2x1ZGVzID0gW107XHJcblxyXG5cdFx0XHRsZXQgY29kZSA9IGBmbiAkeyBmdW5jdGlvbk5hbWUgfSggY29vcmQgOiB2ZWMyZiApIC0+IHZlYzJmIHtcXG5cXG5cXHRyZXR1cm4gdmVjMmYoXFxuYDtcclxuXHJcblx0XHRcdGNvbnN0IGFkZFdyYXBTbmlwcGV0ID0gKCB3cmFwLCBheGlzICkgPT4ge1xyXG5cclxuXHRcdFx0XHRpZiAoIHdyYXAgPT09IFJlcGVhdFdyYXBwaW5nICkge1xyXG5cclxuXHRcdFx0XHRcdGluY2x1ZGVzLnB1c2goIHdnc2xQb2x5ZmlsbC5yZXBlYXRXcmFwcGluZ19mbG9hdCApO1xyXG5cclxuXHRcdFx0XHRcdGNvZGUgKz0gYFxcdFxcdHRzbF9yZXBlYXRXcmFwcGluZ19mbG9hdCggY29vcmQuJHsgYXhpcyB9IClgO1xyXG5cclxuXHRcdFx0XHR9IGVsc2UgaWYgKCB3cmFwID09PSBDbGFtcFRvRWRnZVdyYXBwaW5nICkge1xyXG5cclxuXHRcdFx0XHRcdGluY2x1ZGVzLnB1c2goIHdnc2xQb2x5ZmlsbC5jbGFtcFdyYXBwaW5nX2Zsb2F0ICk7XHJcblxyXG5cdFx0XHRcdFx0Y29kZSArPSBgXFx0XFx0dHNsX2NsYW1wV3JhcHBpbmdfZmxvYXQoIGNvb3JkLiR7IGF4aXMgfSApYDtcclxuXHJcblx0XHRcdFx0fSBlbHNlIGlmICggd3JhcCA9PT0gTWlycm9yZWRSZXBlYXRXcmFwcGluZyApIHtcclxuXHJcblx0XHRcdFx0XHRpbmNsdWRlcy5wdXNoKCB3Z3NsUG9seWZpbGwubWlycm9yV3JhcHBpbmdfZmxvYXQgKTtcclxuXHJcblx0XHRcdFx0XHRjb2RlICs9IGBcXHRcXHR0c2xfbWlycm9yV3JhcHBpbmdfZmxvYXQoIGNvb3JkLiR7IGF4aXMgfSApYDtcclxuXHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHRjb2RlICs9IGBcXHRcXHRjb29yZC4keyBheGlzIH1gO1xyXG5cclxuXHRcdFx0XHRcdGNvbnNvbGUud2FybiggYFdlYkdQVVJlbmRlcmVyOiBVbnN1cHBvcnRlZCB0ZXh0dXJlIHdyYXAgdHlwZSBcIiR7IHdyYXAgfVwiIGZvciB2ZXJ0ZXggc2hhZGVyLmAgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fTtcclxuXHJcblx0XHRcdGFkZFdyYXBTbmlwcGV0KCB0ZXh0dXJlLndyYXBTLCAneCcgKTtcclxuXHJcblx0XHRcdGNvZGUgKz0gJyxcXG4nO1xyXG5cclxuXHRcdFx0YWRkV3JhcFNuaXBwZXQoIHRleHR1cmUud3JhcFQsICd5JyApO1xyXG5cclxuXHRcdFx0Y29kZSArPSAnXFxuXFx0KTtcXG5cXG59XFxuJztcclxuXHJcblx0XHRcdHdnc2xDb2RlQ2FjaGVbIGZ1bmN0aW9uTmFtZSBdID0gbm9kZUNvZGUgPSBuZXcgQ29kZU5vZGUoIGNvZGUsIGluY2x1ZGVzICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdG5vZGVDb2RlLmJ1aWxkKCB0aGlzICk7XHJcblxyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uTmFtZTtcclxuXHJcblx0fVxyXG5cclxuXHRnZW5lcmF0ZVRleHR1cmVEaW1lbnNpb24oIHRleHR1cmUsIHRleHR1cmVQcm9wZXJ0eSwgbGV2ZWxTbmlwcGV0ICkge1xyXG5cclxuXHRcdGNvbnN0IHRleHR1cmVEYXRhID0gdGhpcy5nZXREYXRhRnJvbU5vZGUoIHRleHR1cmUsIHRoaXMuc2hhZGVyU3RhZ2UsIHRoaXMuZ2xvYmFsQ2FjaGUgKTtcclxuXHJcblx0XHRpZiAoIHRleHR1cmVEYXRhLmRpbWVuc2lvbnNTbmlwcGV0ID09PSB1bmRlZmluZWQgKSB0ZXh0dXJlRGF0YS5kaW1lbnNpb25zU25pcHBldCA9IHt9O1xyXG5cclxuXHRcdGxldCB0ZXh0dXJlRGltZW5zaW9uTm9kZSA9IHRleHR1cmVEYXRhLmRpbWVuc2lvbnNTbmlwcGV0WyBsZXZlbFNuaXBwZXQgXTtcclxuXHJcblx0XHRpZiAoIHRleHR1cmVEYXRhLmRpbWVuc2lvbnNTbmlwcGV0WyBsZXZlbFNuaXBwZXQgXSA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0bGV0IHRleHR1cmVEaW1lbnNpb25zUGFyYW1zO1xyXG5cclxuXHRcdFx0Y29uc3QgeyBwcmltYXJ5U2FtcGxlcyB9ID0gdGhpcy5yZW5kZXJlci5iYWNrZW5kLnV0aWxzLmdldFRleHR1cmVTYW1wbGVEYXRhKCB0ZXh0dXJlICk7XHJcblxyXG5cdFx0XHRpZiAoIHByaW1hcnlTYW1wbGVzID4gMSApIHtcclxuXHJcblx0XHRcdFx0dGV4dHVyZURpbWVuc2lvbnNQYXJhbXMgPSB0ZXh0dXJlUHJvcGVydHk7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHR0ZXh0dXJlRGltZW5zaW9uc1BhcmFtcyA9IGAkeyB0ZXh0dXJlUHJvcGVydHkgfSwgdTMyKCAkeyBsZXZlbFNuaXBwZXQgfSApYDtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHRleHR1cmVEaW1lbnNpb25Ob2RlID0gbmV3IFZhck5vZGUoIG5ldyBFeHByZXNzaW9uTm9kZSggYHRleHR1cmVEaW1lbnNpb25zKCAkeyB0ZXh0dXJlRGltZW5zaW9uc1BhcmFtcyB9IClgLCAndXZlYzInICkgKTtcclxuXHJcblx0XHRcdHRleHR1cmVEYXRhLmRpbWVuc2lvbnNTbmlwcGV0WyBsZXZlbFNuaXBwZXQgXSA9IHRleHR1cmVEaW1lbnNpb25Ob2RlO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGV4dHVyZURpbWVuc2lvbk5vZGUuYnVpbGQoIHRoaXMgKTtcclxuXHJcblx0fVxyXG5cclxuXHRnZW5lcmF0ZUZpbHRlcmVkVGV4dHVyZSggdGV4dHVyZSwgdGV4dHVyZVByb3BlcnR5LCB1dlNuaXBwZXQsIGxldmVsU25pcHBldCA9ICcwdScgKSB7XHJcblxyXG5cdFx0dGhpcy5faW5jbHVkZSggJ2JpcXVhZHJhdGljVGV4dHVyZScgKTtcclxuXHJcblx0XHRjb25zdCB3cmFwRnVuY3Rpb24gPSB0aGlzLmdlbmVyYXRlV3JhcEZ1bmN0aW9uKCB0ZXh0dXJlICk7XHJcblx0XHRjb25zdCB0ZXh0dXJlRGltZW5zaW9uID0gdGhpcy5nZW5lcmF0ZVRleHR1cmVEaW1lbnNpb24oIHRleHR1cmUsIHRleHR1cmVQcm9wZXJ0eSwgbGV2ZWxTbmlwcGV0ICk7XHJcblxyXG5cdFx0cmV0dXJuIGB0c2xfYmlxdWFkcmF0aWNUZXh0dXJlKCAkeyB0ZXh0dXJlUHJvcGVydHkgfSwgJHsgd3JhcEZ1bmN0aW9uIH0oICR7IHV2U25pcHBldCB9ICksICR7IHRleHR1cmVEaW1lbnNpb24gfSwgdTMyKCAkeyBsZXZlbFNuaXBwZXQgfSApIClgO1xyXG5cclxuXHR9XHJcblxyXG5cdGdlbmVyYXRlVGV4dHVyZUxvZCggdGV4dHVyZSwgdGV4dHVyZVByb3BlcnR5LCB1dlNuaXBwZXQsIGRlcHRoU25pcHBldCwgbGV2ZWxTbmlwcGV0ID0gJzB1JyApIHtcclxuXHJcblx0XHRjb25zdCB3cmFwRnVuY3Rpb24gPSB0aGlzLmdlbmVyYXRlV3JhcEZ1bmN0aW9uKCB0ZXh0dXJlICk7XHJcblx0XHRjb25zdCB0ZXh0dXJlRGltZW5zaW9uID0gdGhpcy5nZW5lcmF0ZVRleHR1cmVEaW1lbnNpb24oIHRleHR1cmUsIHRleHR1cmVQcm9wZXJ0eSwgbGV2ZWxTbmlwcGV0ICk7XHJcblxyXG5cdFx0Y29uc3QgY29vcmRTbmlwcGV0ID0gYHZlYzJ1KCAkeyB3cmFwRnVuY3Rpb24gfSggJHsgdXZTbmlwcGV0IH0gKSAqIHZlYzJmKCAkeyB0ZXh0dXJlRGltZW5zaW9uIH0gKSApYDtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5nZW5lcmF0ZVRleHR1cmVMb2FkKCB0ZXh0dXJlLCB0ZXh0dXJlUHJvcGVydHksIGNvb3JkU25pcHBldCwgZGVwdGhTbmlwcGV0LCBsZXZlbFNuaXBwZXQgKTtcclxuXHJcblx0fVxyXG5cclxuXHRnZW5lcmF0ZVRleHR1cmVMb2FkKCB0ZXh0dXJlLCB0ZXh0dXJlUHJvcGVydHksIHV2SW5kZXhTbmlwcGV0LCBkZXB0aFNuaXBwZXQsIGxldmVsU25pcHBldCA9ICcwdScgKSB7XHJcblxyXG5cdFx0aWYgKCB0ZXh0dXJlLmlzVmlkZW9UZXh0dXJlID09PSB0cnVlIHx8IHRleHR1cmUuaXNTdG9yYWdlVGV4dHVyZSA9PT0gdHJ1ZSApIHtcclxuXHJcblx0XHRcdHJldHVybiBgdGV4dHVyZUxvYWQoICR7IHRleHR1cmVQcm9wZXJ0eSB9LCAkeyB1dkluZGV4U25pcHBldCB9IClgO1xyXG5cclxuXHRcdH0gZWxzZSBpZiAoIGRlcHRoU25pcHBldCApIHtcclxuXHJcblx0XHRcdHJldHVybiBgdGV4dHVyZUxvYWQoICR7IHRleHR1cmVQcm9wZXJ0eSB9LCAkeyB1dkluZGV4U25pcHBldCB9LCAkeyBkZXB0aFNuaXBwZXQgfSwgdTMyKCAkeyBsZXZlbFNuaXBwZXQgfSApIClgO1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gYHRleHR1cmVMb2FkKCAkeyB0ZXh0dXJlUHJvcGVydHkgfSwgJHsgdXZJbmRleFNuaXBwZXQgfSwgdTMyKCAkeyBsZXZlbFNuaXBwZXQgfSApIClgO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHRnZW5lcmF0ZVRleHR1cmVTdG9yZSggdGV4dHVyZSwgdGV4dHVyZVByb3BlcnR5LCB1dkluZGV4U25pcHBldCwgdmFsdWVTbmlwcGV0ICkge1xyXG5cclxuXHRcdHJldHVybiBgdGV4dHVyZVN0b3JlKCAkeyB0ZXh0dXJlUHJvcGVydHkgfSwgJHsgdXZJbmRleFNuaXBwZXQgfSwgJHsgdmFsdWVTbmlwcGV0IH0gKWA7XHJcblxyXG5cdH1cclxuXHJcblx0aXNTYW1wbGVDb21wYXJlKCB0ZXh0dXJlICkge1xyXG5cclxuXHRcdHJldHVybiB0ZXh0dXJlLmlzRGVwdGhUZXh0dXJlID09PSB0cnVlICYmIHRleHR1cmUuY29tcGFyZUZ1bmN0aW9uICE9PSBudWxsO1xyXG5cclxuXHR9XHJcblxyXG5cdGlzVW5maWx0ZXJhYmxlKCB0ZXh0dXJlICkge1xyXG5cclxuXHRcdHJldHVybiB0aGlzLmdldENvbXBvbmVudFR5cGVGcm9tVGV4dHVyZSggdGV4dHVyZSApICE9PSAnZmxvYXQnIHx8XHJcblx0XHRcdCggISB0aGlzLmlzQXZhaWxhYmxlKCAnZmxvYXQzMkZpbHRlcmFibGUnICkgJiYgdGV4dHVyZS5pc0RhdGFUZXh0dXJlID09PSB0cnVlICYmIHRleHR1cmUudHlwZSA9PT0gRmxvYXRUeXBlICkgfHxcclxuXHRcdFx0KCB0aGlzLmlzU2FtcGxlQ29tcGFyZSggdGV4dHVyZSApID09PSBmYWxzZSAmJiB0ZXh0dXJlLm1pbkZpbHRlciA9PT0gTmVhcmVzdEZpbHRlciAmJiB0ZXh0dXJlLm1hZ0ZpbHRlciA9PT0gTmVhcmVzdEZpbHRlciApIHx8XHJcblx0XHRcdHRoaXMucmVuZGVyZXIuYmFja2VuZC51dGlscy5nZXRUZXh0dXJlU2FtcGxlRGF0YSggdGV4dHVyZSApLnByaW1hcnlTYW1wbGVzID4gMTtcclxuXHJcblx0fVxyXG5cclxuXHRnZW5lcmF0ZVRleHR1cmUoIHRleHR1cmUsIHRleHR1cmVQcm9wZXJ0eSwgdXZTbmlwcGV0LCBkZXB0aFNuaXBwZXQsIHNoYWRlclN0YWdlID0gdGhpcy5zaGFkZXJTdGFnZSApIHtcclxuXHJcblx0XHRsZXQgc25pcHBldCA9IG51bGw7XHJcblxyXG5cdFx0aWYgKCB0ZXh0dXJlLmlzVmlkZW9UZXh0dXJlID09PSB0cnVlICkge1xyXG5cclxuXHRcdFx0c25pcHBldCA9IHRoaXMuX2dlbmVyYXRlVmlkZW9TYW1wbGUoIHRleHR1cmVQcm9wZXJ0eSwgdXZTbmlwcGV0LCBzaGFkZXJTdGFnZSApO1xyXG5cclxuXHRcdH0gZWxzZSBpZiAoIHRoaXMuaXNVbmZpbHRlcmFibGUoIHRleHR1cmUgKSApIHtcclxuXHJcblx0XHRcdHNuaXBwZXQgPSB0aGlzLmdlbmVyYXRlVGV4dHVyZUxvZCggdGV4dHVyZSwgdGV4dHVyZVByb3BlcnR5LCB1dlNuaXBwZXQsIGRlcHRoU25pcHBldCwgJzAnLCBzaGFkZXJTdGFnZSApO1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRzbmlwcGV0ID0gdGhpcy5fZ2VuZXJhdGVUZXh0dXJlU2FtcGxlKCB0ZXh0dXJlLCB0ZXh0dXJlUHJvcGVydHksIHV2U25pcHBldCwgZGVwdGhTbmlwcGV0LCBzaGFkZXJTdGFnZSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gc25pcHBldDtcclxuXHJcblx0fVxyXG5cclxuXHRnZW5lcmF0ZVRleHR1cmVHcmFkKCB0ZXh0dXJlLCB0ZXh0dXJlUHJvcGVydHksIHV2U25pcHBldCwgZ3JhZFNuaXBwZXQsIGRlcHRoU25pcHBldCwgc2hhZGVyU3RhZ2UgPSB0aGlzLnNoYWRlclN0YWdlICkge1xyXG5cclxuXHRcdGlmICggc2hhZGVyU3RhZ2UgPT09ICdmcmFnbWVudCcgKSB7XHJcblxyXG5cdFx0XHQvLyBUT0RPIGhhbmRsZSBpMzIgb3IgdTMyIC0tPiB1dlNuaXBwZXQsIGFycmF5X2luZGV4OiBBLCBkZHgsIGRkeVxyXG5cdFx0XHRyZXR1cm4gYHRleHR1cmVTYW1wbGVHcmFkKCAkeyB0ZXh0dXJlUHJvcGVydHkgfSwgJHsgdGV4dHVyZVByb3BlcnR5IH1fc2FtcGxlciwgJHsgdXZTbmlwcGV0IH0sICAkeyBncmFkU25pcHBldFsgMCBdIH0sICR7IGdyYWRTbmlwcGV0WyAxIF0gfSApYDtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0Y29uc29sZS5lcnJvciggYFdlYkdQVVJlbmRlcmVyOiBUSFJFRS5UZXh0dXJlTm9kZS5ncmFkaWVudCgpIGRvZXMgbm90IHN1cHBvcnQgJHsgc2hhZGVyU3RhZ2UgfSBzaGFkZXIuYCApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHRnZW5lcmF0ZVRleHR1cmVDb21wYXJlKCB0ZXh0dXJlLCB0ZXh0dXJlUHJvcGVydHksIHV2U25pcHBldCwgY29tcGFyZVNuaXBwZXQsIGRlcHRoU25pcHBldCwgc2hhZGVyU3RhZ2UgPSB0aGlzLnNoYWRlclN0YWdlICkge1xyXG5cclxuXHRcdGlmICggc2hhZGVyU3RhZ2UgPT09ICdmcmFnbWVudCcgKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gYHRleHR1cmVTYW1wbGVDb21wYXJlKCAkeyB0ZXh0dXJlUHJvcGVydHkgfSwgJHsgdGV4dHVyZVByb3BlcnR5IH1fc2FtcGxlciwgJHsgdXZTbmlwcGV0IH0sICR7IGNvbXBhcmVTbmlwcGV0IH0gKWA7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdGNvbnNvbGUuZXJyb3IoIGBXZWJHUFVSZW5kZXJlcjogVEhSRUUuRGVwdGhUZXh0dXJlLmNvbXBhcmVGdW5jdGlvbigpIGRvZXMgbm90IHN1cHBvcnQgJHsgc2hhZGVyU3RhZ2UgfSBzaGFkZXIuYCApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHRnZW5lcmF0ZVRleHR1cmVMZXZlbCggdGV4dHVyZSwgdGV4dHVyZVByb3BlcnR5LCB1dlNuaXBwZXQsIGxldmVsU25pcHBldCwgZGVwdGhTbmlwcGV0LCBzaGFkZXJTdGFnZSA9IHRoaXMuc2hhZGVyU3RhZ2UgKSB7XHJcblxyXG5cdFx0bGV0IHNuaXBwZXQgPSBudWxsO1xyXG5cclxuXHRcdGlmICggdGV4dHVyZS5pc1ZpZGVvVGV4dHVyZSA9PT0gdHJ1ZSApIHtcclxuXHJcblx0XHRcdHNuaXBwZXQgPSB0aGlzLl9nZW5lcmF0ZVZpZGVvU2FtcGxlKCB0ZXh0dXJlUHJvcGVydHksIHV2U25pcHBldCwgc2hhZGVyU3RhZ2UgKTtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0c25pcHBldCA9IHRoaXMuX2dlbmVyYXRlVGV4dHVyZVNhbXBsZUxldmVsKCB0ZXh0dXJlLCB0ZXh0dXJlUHJvcGVydHksIHV2U25pcHBldCwgbGV2ZWxTbmlwcGV0LCBkZXB0aFNuaXBwZXQsIHNoYWRlclN0YWdlICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBzbmlwcGV0O1xyXG5cclxuXHR9XHJcblxyXG5cdGdlbmVyYXRlVGV4dHVyZUJpYXMoIHRleHR1cmUsIHRleHR1cmVQcm9wZXJ0eSwgdXZTbmlwcGV0LCBiaWFzU25pcHBldCwgZGVwdGhTbmlwcGV0LCBzaGFkZXJTdGFnZSA9IHRoaXMuc2hhZGVyU3RhZ2UgKSB7XHJcblxyXG5cdFx0aWYgKCBzaGFkZXJTdGFnZSA9PT0gJ2ZyYWdtZW50JyApIHtcclxuXHJcblx0XHRcdHJldHVybiBgdGV4dHVyZVNhbXBsZUJpYXMoICR7IHRleHR1cmVQcm9wZXJ0eSB9LCAkeyB0ZXh0dXJlUHJvcGVydHkgfV9zYW1wbGVyLCAkeyB1dlNuaXBwZXQgfSwgJHsgYmlhc1NuaXBwZXQgfSApYDtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0Y29uc29sZS5lcnJvciggYFdlYkdQVVJlbmRlcmVyOiBUSFJFRS5UZXh0dXJlTm9kZS5iaWFzTm9kZSBkb2VzIG5vdCBzdXBwb3J0ICR7IHNoYWRlclN0YWdlIH0gc2hhZGVyLmAgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0Z2V0UHJvcGVydHlOYW1lKCBub2RlLCBzaGFkZXJTdGFnZSA9IHRoaXMuc2hhZGVyU3RhZ2UgKSB7XHJcblxyXG5cdFx0aWYgKCBub2RlLmlzTm9kZVZhcnlpbmcgPT09IHRydWUgJiYgbm9kZS5uZWVkc0ludGVycG9sYXRpb24gPT09IHRydWUgKSB7XHJcblxyXG5cdFx0XHRpZiAoIHNoYWRlclN0YWdlID09PSAndmVydGV4JyApIHtcclxuXHJcblx0XHRcdFx0cmV0dXJuIGB2YXJ5aW5ncy4keyBub2RlLm5hbWUgfWA7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fSBlbHNlIGlmICggbm9kZS5pc05vZGVVbmlmb3JtID09PSB0cnVlICkge1xyXG5cclxuXHRcdFx0Y29uc3QgbmFtZSA9IG5vZGUubmFtZTtcclxuXHRcdFx0Y29uc3QgdHlwZSA9IG5vZGUudHlwZTtcclxuXHJcblx0XHRcdGlmICggdHlwZSA9PT0gJ3RleHR1cmUnIHx8IHR5cGUgPT09ICdjdWJlVGV4dHVyZScgfHwgdHlwZSA9PT0gJ3N0b3JhZ2VUZXh0dXJlJyB8fCB0eXBlID09PSAndGV4dHVyZTNEJyApIHtcclxuXHJcblx0XHRcdFx0cmV0dXJuIG5hbWU7XHJcblxyXG5cdFx0XHR9IGVsc2UgaWYgKCB0eXBlID09PSAnYnVmZmVyJyB8fCB0eXBlID09PSAnc3RvcmFnZUJ1ZmZlcicgfHwgdHlwZSA9PT0gJ2luZGlyZWN0U3RvcmFnZUJ1ZmZlcicgKSB7XHJcblxyXG5cdFx0XHRcdHJldHVybiBgTm9kZUJ1ZmZlcl8keyBub2RlLmlkIH0uJHtuYW1lfWA7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRyZXR1cm4gbm9kZS5ncm91cE5vZGUubmFtZSArICcuJyArIG5hbWU7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBzdXBlci5nZXRQcm9wZXJ0eU5hbWUoIG5vZGUgKTtcclxuXHJcblx0fVxyXG5cclxuXHRnZXRPdXRwdXRTdHJ1Y3ROYW1lKCkge1xyXG5cclxuXHRcdHJldHVybiAnb3V0cHV0JztcclxuXHJcblx0fVxyXG5cclxuXHRfZ2V0VW5pZm9ybUdyb3VwQ291bnQoIHNoYWRlclN0YWdlICkge1xyXG5cclxuXHRcdHJldHVybiBPYmplY3Qua2V5cyggdGhpcy51bmlmb3Jtc1sgc2hhZGVyU3RhZ2UgXSApLmxlbmd0aDtcclxuXHJcblx0fVxyXG5cclxuXHRnZXRGdW5jdGlvbk9wZXJhdG9yKCBvcCApIHtcclxuXHJcblx0XHRjb25zdCBmbk9wID0gd2dzbEZuT3BMaWJbIG9wIF07XHJcblxyXG5cdFx0aWYgKCBmbk9wICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHR0aGlzLl9pbmNsdWRlKCBmbk9wICk7XHJcblxyXG5cdFx0XHRyZXR1cm4gZm5PcDtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIG51bGw7XHJcblxyXG5cdH1cclxuXHJcblx0Z2V0Tm9kZUFjY2Vzcyggbm9kZSwgc2hhZGVyU3RhZ2UgKSB7XHJcblxyXG5cdFx0aWYgKCBzaGFkZXJTdGFnZSAhPT0gJ2NvbXB1dGUnIClcclxuXHRcdFx0cmV0dXJuIE5vZGVBY2Nlc3MuUkVBRF9PTkxZO1xyXG5cclxuXHRcdHJldHVybiBub2RlLmFjY2VzcztcclxuXHJcblx0fVxyXG5cclxuXHRnZXRTdG9yYWdlQWNjZXNzKCBub2RlLCBzaGFkZXJTdGFnZSApIHtcclxuXHJcblx0XHRyZXR1cm4gYWNjZXNzTmFtZXNbIHRoaXMuZ2V0Tm9kZUFjY2Vzcyggbm9kZSwgc2hhZGVyU3RhZ2UgKSBdO1xyXG5cclxuXHR9XHJcblxyXG5cdGdldFVuaWZvcm1Gcm9tTm9kZSggbm9kZSwgdHlwZSwgc2hhZGVyU3RhZ2UsIG5hbWUgPSBudWxsICkge1xyXG5cclxuXHRcdGNvbnN0IHVuaWZvcm1Ob2RlID0gc3VwZXIuZ2V0VW5pZm9ybUZyb21Ob2RlKCBub2RlLCB0eXBlLCBzaGFkZXJTdGFnZSwgbmFtZSApO1xyXG5cdFx0Y29uc3Qgbm9kZURhdGEgPSB0aGlzLmdldERhdGFGcm9tTm9kZSggbm9kZSwgc2hhZGVyU3RhZ2UsIHRoaXMuZ2xvYmFsQ2FjaGUgKTtcclxuXHJcblx0XHRpZiAoIG5vZGVEYXRhLnVuaWZvcm1HUFUgPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdGxldCB1bmlmb3JtR1BVO1xyXG5cclxuXHRcdFx0Y29uc3QgZ3JvdXAgPSBub2RlLmdyb3VwTm9kZTtcclxuXHRcdFx0Y29uc3QgZ3JvdXBOYW1lID0gZ3JvdXAubmFtZTtcclxuXHJcblx0XHRcdGNvbnN0IGJpbmRpbmdzID0gdGhpcy5nZXRCaW5kR3JvdXBBcnJheSggZ3JvdXBOYW1lLCBzaGFkZXJTdGFnZSApO1xyXG5cclxuXHRcdFx0aWYgKCB0eXBlID09PSAndGV4dHVyZScgfHwgdHlwZSA9PT0gJ2N1YmVUZXh0dXJlJyB8fCB0eXBlID09PSAnc3RvcmFnZVRleHR1cmUnIHx8IHR5cGUgPT09ICd0ZXh0dXJlM0QnICkge1xyXG5cclxuXHRcdFx0XHRsZXQgdGV4dHVyZSA9IG51bGw7XHJcblxyXG5cdFx0XHRcdGNvbnN0IGFjY2VzcyA9IHRoaXMuZ2V0Tm9kZUFjY2Vzcyggbm9kZSwgc2hhZGVyU3RhZ2UgKTtcclxuXHJcblx0XHRcdFx0aWYgKCB0eXBlID09PSAndGV4dHVyZScgfHwgdHlwZSA9PT0gJ3N0b3JhZ2VUZXh0dXJlJyApIHtcclxuXHJcblx0XHRcdFx0XHR0ZXh0dXJlID0gbmV3IE5vZGVTYW1wbGVkVGV4dHVyZSggdW5pZm9ybU5vZGUubmFtZSwgdW5pZm9ybU5vZGUubm9kZSwgZ3JvdXAsIGFjY2VzcyApO1xyXG5cclxuXHRcdFx0XHR9IGVsc2UgaWYgKCB0eXBlID09PSAnY3ViZVRleHR1cmUnICkge1xyXG5cclxuXHRcdFx0XHRcdHRleHR1cmUgPSBuZXcgTm9kZVNhbXBsZWRDdWJlVGV4dHVyZSggdW5pZm9ybU5vZGUubmFtZSwgdW5pZm9ybU5vZGUubm9kZSwgZ3JvdXAsIGFjY2VzcyApO1xyXG5cclxuXHRcdFx0XHR9IGVsc2UgaWYgKCB0eXBlID09PSAndGV4dHVyZTNEJyApIHtcclxuXHJcblx0XHRcdFx0XHR0ZXh0dXJlID0gbmV3IE5vZGVTYW1wbGVkVGV4dHVyZTNEKCB1bmlmb3JtTm9kZS5uYW1lLCB1bmlmb3JtTm9kZS5ub2RlLCBncm91cCwgYWNjZXNzICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0dGV4dHVyZS5zdG9yZSA9IG5vZGUuaXNTdG9yYWdlVGV4dHVyZU5vZGUgPT09IHRydWU7XHJcblx0XHRcdFx0dGV4dHVyZS5zZXRWaXNpYmlsaXR5KCBncHVTaGFkZXJTdGFnZUxpYlsgc2hhZGVyU3RhZ2UgXSApO1xyXG5cclxuXHRcdFx0XHRpZiAoICggc2hhZGVyU3RhZ2UgPT09ICdmcmFnbWVudCcgfHwgc2hhZGVyU3RhZ2UgPT09ICdjb21wdXRlJyApICYmIHRoaXMuaXNVbmZpbHRlcmFibGUoIG5vZGUudmFsdWUgKSA9PT0gZmFsc2UgJiYgdGV4dHVyZS5zdG9yZSA9PT0gZmFsc2UgKSB7XHJcblxyXG5cdFx0XHRcdFx0Y29uc3Qgc2FtcGxlciA9IG5ldyBOb2RlU2FtcGxlciggYCR7dW5pZm9ybU5vZGUubmFtZX1fc2FtcGxlcmAsIHVuaWZvcm1Ob2RlLm5vZGUsIGdyb3VwICk7XHJcblx0XHRcdFx0XHRzYW1wbGVyLnNldFZpc2liaWxpdHkoIGdwdVNoYWRlclN0YWdlTGliWyBzaGFkZXJTdGFnZSBdICk7XHJcblxyXG5cdFx0XHRcdFx0YmluZGluZ3MucHVzaCggc2FtcGxlciwgdGV4dHVyZSApO1xyXG5cclxuXHRcdFx0XHRcdHVuaWZvcm1HUFUgPSBbIHNhbXBsZXIsIHRleHR1cmUgXTtcclxuXHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHRiaW5kaW5ncy5wdXNoKCB0ZXh0dXJlICk7XHJcblxyXG5cdFx0XHRcdFx0dW5pZm9ybUdQVSA9IFsgdGV4dHVyZSBdO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9IGVsc2UgaWYgKCB0eXBlID09PSAnYnVmZmVyJyB8fCB0eXBlID09PSAnc3RvcmFnZUJ1ZmZlcicgfHwgdHlwZSA9PT0gJ2luZGlyZWN0U3RvcmFnZUJ1ZmZlcicgKSB7XHJcblxyXG5cdFx0XHRcdGNvbnN0IGJ1ZmZlckNsYXNzID0gdHlwZSA9PT0gJ2J1ZmZlcicgPyBOb2RlVW5pZm9ybUJ1ZmZlciA6IE5vZGVTdG9yYWdlQnVmZmVyO1xyXG5cclxuXHRcdFx0XHRjb25zdCBidWZmZXIgPSBuZXcgYnVmZmVyQ2xhc3MoIG5vZGUsIGdyb3VwICk7XHJcblx0XHRcdFx0YnVmZmVyLnNldFZpc2liaWxpdHkoIGdwdVNoYWRlclN0YWdlTGliWyBzaGFkZXJTdGFnZSBdICk7XHJcblxyXG5cdFx0XHRcdGJpbmRpbmdzLnB1c2goIGJ1ZmZlciApO1xyXG5cclxuXHRcdFx0XHR1bmlmb3JtR1BVID0gYnVmZmVyO1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0Y29uc3QgdW5pZm9ybXNTdGFnZSA9IHRoaXMudW5pZm9ybUdyb3Vwc1sgc2hhZGVyU3RhZ2UgXSB8fCAoIHRoaXMudW5pZm9ybUdyb3Vwc1sgc2hhZGVyU3RhZ2UgXSA9IHt9ICk7XHJcblxyXG5cdFx0XHRcdGxldCB1bmlmb3Jtc0dyb3VwID0gdW5pZm9ybXNTdGFnZVsgZ3JvdXBOYW1lIF07XHJcblxyXG5cdFx0XHRcdGlmICggdW5pZm9ybXNHcm91cCA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRcdHVuaWZvcm1zR3JvdXAgPSBuZXcgTm9kZVVuaWZvcm1zR3JvdXAoIGdyb3VwTmFtZSwgZ3JvdXAgKTtcclxuXHRcdFx0XHRcdHVuaWZvcm1zR3JvdXAuc2V0VmlzaWJpbGl0eSggZ3B1U2hhZGVyU3RhZ2VMaWJbIHNoYWRlclN0YWdlIF0gKTtcclxuXHJcblx0XHRcdFx0XHR1bmlmb3Jtc1N0YWdlWyBncm91cE5hbWUgXSA9IHVuaWZvcm1zR3JvdXA7XHJcblxyXG5cdFx0XHRcdFx0YmluZGluZ3MucHVzaCggdW5pZm9ybXNHcm91cCApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHVuaWZvcm1HUFUgPSB0aGlzLmdldE5vZGVVbmlmb3JtKCB1bmlmb3JtTm9kZSwgdHlwZSApO1xyXG5cclxuXHRcdFx0XHR1bmlmb3Jtc0dyb3VwLmFkZFVuaWZvcm0oIHVuaWZvcm1HUFUgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdG5vZGVEYXRhLnVuaWZvcm1HUFUgPSB1bmlmb3JtR1BVO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdW5pZm9ybU5vZGU7XHJcblxyXG5cdH1cclxuXHJcblx0Z2V0QnVpbHRpbiggbmFtZSwgcHJvcGVydHksIHR5cGUsIHNoYWRlclN0YWdlID0gdGhpcy5zaGFkZXJTdGFnZSApIHtcclxuXHJcblx0XHRjb25zdCBtYXAgPSB0aGlzLmJ1aWx0aW5zWyBzaGFkZXJTdGFnZSBdIHx8ICggdGhpcy5idWlsdGluc1sgc2hhZGVyU3RhZ2UgXSA9IG5ldyBNYXAoKSApO1xyXG5cclxuXHRcdGlmICggbWFwLmhhcyggbmFtZSApID09PSBmYWxzZSApIHtcclxuXHJcblx0XHRcdG1hcC5zZXQoIG5hbWUsIHtcclxuXHRcdFx0XHRuYW1lLFxyXG5cdFx0XHRcdHByb3BlcnR5LFxyXG5cdFx0XHRcdHR5cGVcclxuXHRcdFx0fSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gcHJvcGVydHk7XHJcblxyXG5cdH1cclxuXHJcblx0aGFzQnVpbHRpbiggbmFtZSwgc2hhZGVyU3RhZ2UgPSB0aGlzLnNoYWRlclN0YWdlICkge1xyXG5cclxuXHRcdHJldHVybiAoIHRoaXMuYnVpbHRpbnNbIHNoYWRlclN0YWdlIF0gIT09IHVuZGVmaW5lZCAmJiB0aGlzLmJ1aWx0aW5zWyBzaGFkZXJTdGFnZSBdLmhhcyggbmFtZSApICk7XHJcblxyXG5cdH1cclxuXHJcblx0Z2V0VmVydGV4SW5kZXgoKSB7XHJcblxyXG5cdFx0aWYgKCB0aGlzLnNoYWRlclN0YWdlID09PSAndmVydGV4JyApIHtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzLmdldEJ1aWx0aW4oICd2ZXJ0ZXhfaW5kZXgnLCAndmVydGV4SW5kZXgnLCAndTMyJywgJ2F0dHJpYnV0ZScgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuICd2ZXJ0ZXhJbmRleCc7XHJcblxyXG5cdH1cclxuXHJcblx0YnVpbGRGdW5jdGlvbkNvZGUoIHNoYWRlck5vZGUgKSB7XHJcblxyXG5cdFx0Y29uc3QgbGF5b3V0ID0gc2hhZGVyTm9kZS5sYXlvdXQ7XHJcblx0XHRjb25zdCBmbG93RGF0YSA9IHRoaXMuZmxvd1NoYWRlck5vZGUoIHNoYWRlck5vZGUgKTtcclxuXHJcblx0XHRjb25zdCBwYXJhbWV0ZXJzID0gW107XHJcblxyXG5cdFx0Zm9yICggY29uc3QgaW5wdXQgb2YgbGF5b3V0LmlucHV0cyApIHtcclxuXHJcblx0XHRcdHBhcmFtZXRlcnMucHVzaCggaW5wdXQubmFtZSArICcgOiAnICsgdGhpcy5nZXRUeXBlKCBpbnB1dC50eXBlICkgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly9cclxuXHJcblx0XHRsZXQgY29kZSA9IGBmbiAkeyBsYXlvdXQubmFtZSB9KCAkeyBwYXJhbWV0ZXJzLmpvaW4oICcsICcgKSB9ICkgLT4gJHsgdGhpcy5nZXRUeXBlKCBsYXlvdXQudHlwZSApIH0ge1xyXG4keyBmbG93RGF0YS52YXJzIH1cclxuJHsgZmxvd0RhdGEuY29kZSB9XHJcbmA7XHJcblxyXG5cdFx0aWYgKCBmbG93RGF0YS5yZXN1bHQgKSB7XHJcblxyXG5cdFx0XHRjb2RlICs9IGBcXHRyZXR1cm4gJHsgZmxvd0RhdGEucmVzdWx0IH07XFxuYDtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Y29kZSArPSAnXFxufVxcbic7XHJcblxyXG5cdFx0Ly9cclxuXHJcblx0XHRyZXR1cm4gY29kZTtcclxuXHJcblx0fVxyXG5cclxuXHRnZXRJbnN0YW5jZUluZGV4KCkge1xyXG5cclxuXHRcdGlmICggdGhpcy5zaGFkZXJTdGFnZSA9PT0gJ3ZlcnRleCcgKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcy5nZXRCdWlsdGluKCAnaW5zdGFuY2VfaW5kZXgnLCAnaW5zdGFuY2VJbmRleCcsICd1MzInLCAnYXR0cmlidXRlJyApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gJ2luc3RhbmNlSW5kZXgnO1xyXG5cclxuXHR9XHJcblxyXG5cdGdldEludm9jYXRpb25Mb2NhbEluZGV4KCkge1xyXG5cclxuXHRcdHJldHVybiB0aGlzLmdldEJ1aWx0aW4oICdsb2NhbF9pbnZvY2F0aW9uX2luZGV4JywgJ2ludm9jYXRpb25Mb2NhbEluZGV4JywgJ3UzMicsICdhdHRyaWJ1dGUnICk7XHJcblxyXG5cdH1cclxuXHJcblx0Z2V0U3ViZ3JvdXBTaXplKCkge1xyXG5cclxuXHRcdHRoaXMuZW5hYmxlU3ViR3JvdXBzKCk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuZ2V0QnVpbHRpbiggJ3N1Ymdyb3VwX3NpemUnLCAnc3ViZ3JvdXBTaXplJywgJ3UzMicsICdhdHRyaWJ1dGUnICk7XHJcblxyXG5cdH1cclxuXHJcblx0Z2V0SW52b2NhdGlvblN1Ymdyb3VwSW5kZXgoKSB7XHJcblxyXG5cdFx0dGhpcy5lbmFibGVTdWJHcm91cHMoKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5nZXRCdWlsdGluKCAnc3ViZ3JvdXBfaW52b2NhdGlvbl9pZCcsICdpbnZvY2F0aW9uU3ViZ3JvdXBJbmRleCcsICd1MzInLCAnYXR0cmlidXRlJyApO1xyXG5cclxuXHR9XHJcblxyXG5cdGdldFN1Ymdyb3VwSW5kZXgoKSB7XHJcblxyXG5cdFx0dGhpcy5lbmFibGVTdWJHcm91cHMoKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5nZXRCdWlsdGluKCAnc3ViZ3JvdXBfaWQnLCAnc3ViZ3JvdXBJbmRleCcsICd1MzInLCAnYXR0cmlidXRlJyApO1xyXG5cclxuXHR9XHJcblxyXG5cdGdldERyYXdJbmRleCgpIHtcclxuXHJcblx0XHRyZXR1cm4gbnVsbDtcclxuXHJcblx0fVxyXG5cclxuXHRnZXRGcm9udEZhY2luZygpIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5nZXRCdWlsdGluKCAnZnJvbnRfZmFjaW5nJywgJ2lzRnJvbnQnLCAnYm9vbCcgKTtcclxuXHJcblx0fVxyXG5cclxuXHRnZXRGcmFnQ29vcmQoKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuZ2V0QnVpbHRpbiggJ3Bvc2l0aW9uJywgJ2ZyYWdDb29yZCcsICd2ZWM0PGYzMj4nICkgKyAnLnh5JztcclxuXHJcblx0fVxyXG5cclxuXHRnZXRGcmFnRGVwdGgoKSB7XHJcblxyXG5cdFx0cmV0dXJuICdvdXRwdXQuJyArIHRoaXMuZ2V0QnVpbHRpbiggJ2ZyYWdfZGVwdGgnLCAnZGVwdGgnLCAnZjMyJywgJ291dHB1dCcgKTtcclxuXHJcblx0fVxyXG5cclxuXHRnZXRDbGlwRGlzdGFuY2UoKSB7XHJcblxyXG5cdFx0cmV0dXJuICd2YXJ5aW5ncy5od19jbGlwX2Rpc3RhbmNlcyc7XHJcblxyXG5cdH1cclxuXHJcblx0aXNGbGlwWSgpIHtcclxuXHJcblx0XHRyZXR1cm4gZmFsc2U7XHJcblxyXG5cdH1cclxuXHJcblx0ZW5hYmxlRGlyZWN0aXZlKCBuYW1lLCBzaGFkZXJTdGFnZSA9IHRoaXMuc2hhZGVyU3RhZ2UgKSB7XHJcblxyXG5cdFx0Y29uc3Qgc3RhZ2UgPSB0aGlzLmRpcmVjdGl2ZXNbIHNoYWRlclN0YWdlIF0gfHwgKCB0aGlzLmRpcmVjdGl2ZXNbIHNoYWRlclN0YWdlIF0gPSBuZXcgU2V0KCkgKTtcclxuXHRcdHN0YWdlLmFkZCggbmFtZSApO1xyXG5cclxuXHR9XHJcblxyXG5cdGdldERpcmVjdGl2ZXMoIHNoYWRlclN0YWdlICkge1xyXG5cclxuXHRcdGNvbnN0IHNuaXBwZXRzID0gW107XHJcblx0XHRjb25zdCBkaXJlY3RpdmVzID0gdGhpcy5kaXJlY3RpdmVzWyBzaGFkZXJTdGFnZSBdO1xyXG5cclxuXHRcdGlmICggZGlyZWN0aXZlcyAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0Zm9yICggY29uc3QgZGlyZWN0aXZlIG9mIGRpcmVjdGl2ZXMgKSB7XHJcblxyXG5cdFx0XHRcdHNuaXBwZXRzLnB1c2goIGBlbmFibGUgJHtkaXJlY3RpdmV9O2AgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHNuaXBwZXRzLmpvaW4oICdcXG4nICk7XHJcblxyXG5cdH1cclxuXHJcblx0ZW5hYmxlU3ViR3JvdXBzKCkge1xyXG5cclxuXHRcdHRoaXMuZW5hYmxlRGlyZWN0aXZlKCAnc3ViZ3JvdXBzJyApO1xyXG5cclxuXHR9XHJcblxyXG5cdGVuYWJsZVN1Ymdyb3Vwc0YxNigpIHtcclxuXHJcblx0XHR0aGlzLmVuYWJsZURpcmVjdGl2ZSggJ3N1Ymdyb3Vwcy1mMTYnICk7XHJcblxyXG5cdH1cclxuXHJcblx0ZW5hYmxlQ2xpcERpc3RhbmNlcygpIHtcclxuXHJcblx0XHR0aGlzLmVuYWJsZURpcmVjdGl2ZSggJ2NsaXBfZGlzdGFuY2VzJyApO1xyXG5cclxuXHR9XHJcblxyXG5cdGVuYWJsZVNoYWRlckYxNigpIHtcclxuXHJcblx0XHR0aGlzLmVuYWJsZURpcmVjdGl2ZSggJ2YxNicgKTtcclxuXHJcblx0fVxyXG5cclxuXHRlbmFibGVEdWFsU291cmNlQmxlbmRpbmcoKSB7XHJcblxyXG5cdFx0dGhpcy5lbmFibGVEaXJlY3RpdmUoICdkdWFsX3NvdXJjZV9ibGVuZGluZycgKTtcclxuXHJcblx0fVxyXG5cclxuXHRlbmFibGVIYXJkd2FyZUNsaXBwaW5nKCBwbGFuZUNvdW50ICkge1xyXG5cclxuXHRcdHRoaXMuZW5hYmxlQ2xpcERpc3RhbmNlcygpO1xyXG5cdFx0dGhpcy5nZXRCdWlsdGluKCAnY2xpcF9kaXN0YW5jZXMnLCAnaHdfY2xpcF9kaXN0YW5jZXMnLCBgYXJyYXk8ZjMyLCAkeyBwbGFuZUNvdW50IH0gPmAsICd2ZXJ0ZXgnICk7XHJcblxyXG5cdH1cclxuXHJcblx0Z2V0QnVpbHRpbnMoIHNoYWRlclN0YWdlICkge1xyXG5cclxuXHRcdGNvbnN0IHNuaXBwZXRzID0gW107XHJcblx0XHRjb25zdCBidWlsdGlucyA9IHRoaXMuYnVpbHRpbnNbIHNoYWRlclN0YWdlIF07XHJcblxyXG5cdFx0aWYgKCBidWlsdGlucyAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0Zm9yICggY29uc3QgeyBuYW1lLCBwcm9wZXJ0eSwgdHlwZSB9IG9mIGJ1aWx0aW5zLnZhbHVlcygpICkge1xyXG5cclxuXHRcdFx0XHRzbmlwcGV0cy5wdXNoKCBgQGJ1aWx0aW4oICR7bmFtZX0gKSAke3Byb3BlcnR5fSA6ICR7dHlwZX1gICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBzbmlwcGV0cy5qb2luKCAnLFxcblxcdCcgKTtcclxuXHJcblx0fVxyXG5cclxuXHRnZXRTY29wZWRBcnJheSggbmFtZSwgc2NvcGUsIGJ1ZmZlclR5cGUsIGJ1ZmZlckNvdW50ICkge1xyXG5cclxuXHRcdGlmICggdGhpcy5zY29wZWRBcnJheXMuaGFzKCBuYW1lICkgPT09IGZhbHNlICkge1xyXG5cclxuXHRcdFx0dGhpcy5zY29wZWRBcnJheXMuc2V0KCBuYW1lLCB7XHJcblx0XHRcdFx0bmFtZSxcclxuXHRcdFx0XHRzY29wZSxcclxuXHRcdFx0XHRidWZmZXJUeXBlLFxyXG5cdFx0XHRcdGJ1ZmZlckNvdW50XHJcblx0XHRcdH0gKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIG5hbWU7XHJcblxyXG5cdH1cclxuXHJcblx0Z2V0U2NvcGVkQXJyYXlzKCBzaGFkZXJTdGFnZSApIHtcclxuXHJcblx0XHRpZiAoIHNoYWRlclN0YWdlICE9PSAnY29tcHV0ZScgKSB7XHJcblxyXG5cdFx0XHRyZXR1cm47XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGNvbnN0IHNuaXBwZXRzID0gW107XHJcblxyXG5cdFx0Zm9yICggY29uc3QgeyBuYW1lLCBzY29wZSwgYnVmZmVyVHlwZSwgYnVmZmVyQ291bnQgfSBvZiB0aGlzLnNjb3BlZEFycmF5cy52YWx1ZXMoKSApIHtcclxuXHJcblx0XHRcdGNvbnN0IHR5cGUgPSB0aGlzLmdldFR5cGUoIGJ1ZmZlclR5cGUgKTtcclxuXHJcblx0XHRcdHNuaXBwZXRzLnB1c2goIGB2YXI8JHtzY29wZX0+ICR7bmFtZX06IGFycmF5PCAke3R5cGV9LCAke2J1ZmZlckNvdW50fSA+O2AgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHNuaXBwZXRzLmpvaW4oICdcXG4nICk7XHJcblxyXG5cdH1cclxuXHJcblx0Z2V0QXR0cmlidXRlcyggc2hhZGVyU3RhZ2UgKSB7XHJcblxyXG5cdFx0Y29uc3Qgc25pcHBldHMgPSBbXTtcclxuXHJcblx0XHRpZiAoIHNoYWRlclN0YWdlID09PSAnY29tcHV0ZScgKSB7XHJcblxyXG5cdFx0XHR0aGlzLmdldEJ1aWx0aW4oICdnbG9iYWxfaW52b2NhdGlvbl9pZCcsICdpZCcsICd2ZWMzPHUzMj4nLCAnYXR0cmlidXRlJyApO1xyXG5cdFx0XHR0aGlzLmdldEJ1aWx0aW4oICd3b3JrZ3JvdXBfaWQnLCAnd29ya2dyb3VwSWQnLCAndmVjMzx1MzI+JywgJ2F0dHJpYnV0ZScgKTtcclxuXHRcdFx0dGhpcy5nZXRCdWlsdGluKCAnbG9jYWxfaW52b2NhdGlvbl9pZCcsICdsb2NhbElkJywgJ3ZlYzM8dTMyPicsICdhdHRyaWJ1dGUnICk7XHJcblx0XHRcdHRoaXMuZ2V0QnVpbHRpbiggJ251bV93b3JrZ3JvdXBzJywgJ251bVdvcmtncm91cHMnLCAndmVjMzx1MzI+JywgJ2F0dHJpYnV0ZScgKTtcclxuXHJcblx0XHRcdGlmICggdGhpcy5yZW5kZXJlci5oYXNGZWF0dXJlKCAnc3ViZ3JvdXBzJyApICkge1xyXG5cclxuXHRcdFx0XHR0aGlzLmVuYWJsZURpcmVjdGl2ZSggJ3N1Ymdyb3VwcycsIHNoYWRlclN0YWdlICk7XHJcblx0XHRcdFx0dGhpcy5nZXRCdWlsdGluKCAnc3ViZ3JvdXBfc2l6ZScsICdzdWJncm91cFNpemUnLCAndTMyJywgJ2F0dHJpYnV0ZScgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBzaGFkZXJTdGFnZSA9PT0gJ3ZlcnRleCcgfHwgc2hhZGVyU3RhZ2UgPT09ICdjb21wdXRlJyApIHtcclxuXHJcblx0XHRcdGNvbnN0IGJ1aWx0aW5zID0gdGhpcy5nZXRCdWlsdGlucyggJ2F0dHJpYnV0ZScgKTtcclxuXHJcblx0XHRcdGlmICggYnVpbHRpbnMgKSBzbmlwcGV0cy5wdXNoKCBidWlsdGlucyApO1xyXG5cclxuXHRcdFx0Y29uc3QgYXR0cmlidXRlcyA9IHRoaXMuZ2V0QXR0cmlidXRlc0FycmF5KCk7XHJcblxyXG5cdFx0XHRmb3IgKCBsZXQgaW5kZXggPSAwLCBsZW5ndGggPSBhdHRyaWJ1dGVzLmxlbmd0aDsgaW5kZXggPCBsZW5ndGg7IGluZGV4ICsrICkge1xyXG5cclxuXHRcdFx0XHRjb25zdCBhdHRyaWJ1dGUgPSBhdHRyaWJ1dGVzWyBpbmRleCBdO1xyXG5cdFx0XHRcdGNvbnN0IG5hbWUgPSBhdHRyaWJ1dGUubmFtZTtcclxuXHRcdFx0XHRjb25zdCB0eXBlID0gdGhpcy5nZXRUeXBlKCBhdHRyaWJ1dGUudHlwZSApO1xyXG5cclxuXHRcdFx0XHRzbmlwcGV0cy5wdXNoKCBgQGxvY2F0aW9uKCAke2luZGV4fSApICR7IG5hbWUgfSA6ICR7IHR5cGUgfWAgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHNuaXBwZXRzLmpvaW4oICcsXFxuXFx0JyApO1xyXG5cclxuXHR9XHJcblxyXG5cdGdldFN0cnVjdE1lbWJlcnMoIHN0cnVjdCApIHtcclxuXHJcblx0XHRjb25zdCBzbmlwcGV0cyA9IFtdO1xyXG5cdFx0Y29uc3QgbWVtYmVycyA9IHN0cnVjdC5nZXRNZW1iZXJUeXBlcygpO1xyXG5cclxuXHRcdGZvciAoIGxldCBpID0gMDsgaSA8IG1lbWJlcnMubGVuZ3RoOyBpICsrICkge1xyXG5cclxuXHRcdFx0Y29uc3QgbWVtYmVyID0gbWVtYmVyc1sgaSBdO1xyXG5cdFx0XHRzbmlwcGV0cy5wdXNoKCBgXFx0QGxvY2F0aW9uKCAke2l9ICkgbSR7aX0gOiAkeyBtZW1iZXIgfTxmMzI+YCApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRjb25zdCBidWlsdGlucyA9IHRoaXMuZ2V0QnVpbHRpbnMoICdvdXRwdXQnICk7XHJcblxyXG5cdFx0aWYgKCBidWlsdGlucyApIHNuaXBwZXRzLnB1c2goICdcXHQnICsgYnVpbHRpbnMgKTtcclxuXHJcblx0XHRyZXR1cm4gc25pcHBldHMuam9pbiggJyxcXG4nICk7XHJcblxyXG5cdH1cclxuXHJcblx0Z2V0U3RydWN0cyggc2hhZGVyU3RhZ2UgKSB7XHJcblxyXG5cdFx0Y29uc3Qgc25pcHBldHMgPSBbXTtcclxuXHRcdGNvbnN0IHN0cnVjdHMgPSB0aGlzLnN0cnVjdHNbIHNoYWRlclN0YWdlIF07XHJcblxyXG5cdFx0Zm9yICggbGV0IGluZGV4ID0gMCwgbGVuZ3RoID0gc3RydWN0cy5sZW5ndGg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCArKyApIHtcclxuXHJcblx0XHRcdGNvbnN0IHN0cnVjdCA9IHN0cnVjdHNbIGluZGV4IF07XHJcblx0XHRcdGNvbnN0IG5hbWUgPSBzdHJ1Y3QubmFtZTtcclxuXHJcblx0XHRcdGxldCBzbmlwcGV0ID0gYFxcc3RydWN0ICR7IG5hbWUgfSB7XFxuYDtcclxuXHRcdFx0c25pcHBldCArPSB0aGlzLmdldFN0cnVjdE1lbWJlcnMoIHN0cnVjdCApO1xyXG5cdFx0XHRzbmlwcGV0ICs9ICdcXG59JztcclxuXHJcblxyXG5cdFx0XHRzbmlwcGV0cy5wdXNoKCBzbmlwcGV0ICk7XHJcblxyXG5cdFx0XHRzbmlwcGV0cy5wdXNoKCBgXFxudmFyPHByaXZhdGU+IG91dHB1dCA6ICR7IG5hbWUgfTtcXG5cXG5gICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBzbmlwcGV0cy5qb2luKCAnXFxuXFxuJyApO1xyXG5cclxuXHR9XHJcblxyXG5cdGdldFZhciggdHlwZSwgbmFtZSApIHtcclxuXHJcblx0XHRyZXR1cm4gYHZhciAkeyBuYW1lIH0gOiAkeyB0aGlzLmdldFR5cGUoIHR5cGUgKSB9YDtcclxuXHJcblx0fVxyXG5cclxuXHRnZXRWYXJzKCBzaGFkZXJTdGFnZSApIHtcclxuXHJcblx0XHRjb25zdCBzbmlwcGV0cyA9IFtdO1xyXG5cdFx0Y29uc3QgdmFycyA9IHRoaXMudmFyc1sgc2hhZGVyU3RhZ2UgXTtcclxuXHJcblx0XHRpZiAoIHZhcnMgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdGZvciAoIGNvbnN0IHZhcmlhYmxlIG9mIHZhcnMgKSB7XHJcblxyXG5cdFx0XHRcdHNuaXBwZXRzLnB1c2goIGBcXHQkeyB0aGlzLmdldFZhciggdmFyaWFibGUudHlwZSwgdmFyaWFibGUubmFtZSApIH07YCApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gYFxcbiR7IHNuaXBwZXRzLmpvaW4oICdcXG4nICkgfVxcbmA7XHJcblxyXG5cdH1cclxuXHJcblx0Z2V0VmFyeWluZ3MoIHNoYWRlclN0YWdlICkge1xyXG5cclxuXHRcdGNvbnN0IHNuaXBwZXRzID0gW107XHJcblxyXG5cdFx0aWYgKCBzaGFkZXJTdGFnZSA9PT0gJ3ZlcnRleCcgKSB7XHJcblxyXG5cdFx0XHR0aGlzLmdldEJ1aWx0aW4oICdwb3NpdGlvbicsICdWZXJ0ZXgnLCAndmVjNDxmMzI+JywgJ3ZlcnRleCcgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBzaGFkZXJTdGFnZSA9PT0gJ3ZlcnRleCcgfHwgc2hhZGVyU3RhZ2UgPT09ICdmcmFnbWVudCcgKSB7XHJcblxyXG5cdFx0XHRjb25zdCB2YXJ5aW5ncyA9IHRoaXMudmFyeWluZ3M7XHJcblx0XHRcdGNvbnN0IHZhcnMgPSB0aGlzLnZhcnNbIHNoYWRlclN0YWdlIF07XHJcblxyXG5cdFx0XHRmb3IgKCBsZXQgaW5kZXggPSAwOyBpbmRleCA8IHZhcnlpbmdzLmxlbmd0aDsgaW5kZXggKysgKSB7XHJcblxyXG5cdFx0XHRcdGNvbnN0IHZhcnlpbmcgPSB2YXJ5aW5nc1sgaW5kZXggXTtcclxuXHJcblx0XHRcdFx0aWYgKCB2YXJ5aW5nLm5lZWRzSW50ZXJwb2xhdGlvbiApIHtcclxuXHJcblx0XHRcdFx0XHRsZXQgYXR0cmlidXRlc1NuaXBwZXQgPSBgQGxvY2F0aW9uKCAke2luZGV4fSApYDtcclxuXHJcblx0XHRcdFx0XHRpZiAoIC9eKGludHx1aW50fGl2ZWN8dXZlYykvLnRlc3QoIHZhcnlpbmcudHlwZSApICkge1xyXG5cclxuXHRcdFx0XHRcdFx0YXR0cmlidXRlc1NuaXBwZXQgKz0gJyBAaW50ZXJwb2xhdGUoIGZsYXQgKSc7XHJcblxyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRzbmlwcGV0cy5wdXNoKCBgJHsgYXR0cmlidXRlc1NuaXBwZXQgfSAkeyB2YXJ5aW5nLm5hbWUgfSA6ICR7IHRoaXMuZ2V0VHlwZSggdmFyeWluZy50eXBlICkgfWAgKTtcclxuXHJcblx0XHRcdFx0fSBlbHNlIGlmICggc2hhZGVyU3RhZ2UgPT09ICd2ZXJ0ZXgnICYmIHZhcnMuaW5jbHVkZXMoIHZhcnlpbmcgKSA9PT0gZmFsc2UgKSB7XHJcblxyXG5cdFx0XHRcdFx0dmFycy5wdXNoKCB2YXJ5aW5nICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Y29uc3QgYnVpbHRpbnMgPSB0aGlzLmdldEJ1aWx0aW5zKCBzaGFkZXJTdGFnZSApO1xyXG5cclxuXHRcdGlmICggYnVpbHRpbnMgKSBzbmlwcGV0cy5wdXNoKCBidWlsdGlucyApO1xyXG5cclxuXHRcdGNvbnN0IGNvZGUgPSBzbmlwcGV0cy5qb2luKCAnLFxcblxcdCcgKTtcclxuXHJcblx0XHRyZXR1cm4gc2hhZGVyU3RhZ2UgPT09ICd2ZXJ0ZXgnID8gdGhpcy5fZ2V0V0dTTFN0cnVjdCggJ1ZhcnlpbmdzU3RydWN0JywgJ1xcdCcgKyBjb2RlICkgOiBjb2RlO1xyXG5cclxuXHR9XHJcblxyXG5cdGdldFVuaWZvcm1zKCBzaGFkZXJTdGFnZSApIHtcclxuXHJcblx0XHRjb25zdCB1bmlmb3JtcyA9IHRoaXMudW5pZm9ybXNbIHNoYWRlclN0YWdlIF07XHJcblxyXG5cdFx0Y29uc3QgYmluZGluZ1NuaXBwZXRzID0gW107XHJcblx0XHRjb25zdCBidWZmZXJTbmlwcGV0cyA9IFtdO1xyXG5cdFx0Y29uc3Qgc3RydWN0U25pcHBldHMgPSBbXTtcclxuXHRcdGNvbnN0IHVuaWZvcm1Hcm91cHMgPSB7fTtcclxuXHJcblx0XHRmb3IgKCBjb25zdCB1bmlmb3JtIG9mIHVuaWZvcm1zICkge1xyXG5cclxuXHRcdFx0Y29uc3QgZ3JvdXBOYW1lID0gdW5pZm9ybS5ncm91cE5vZGUubmFtZTtcclxuXHRcdFx0Y29uc3QgdW5pZm9ybUluZGV4ZXMgPSB0aGlzLmJpbmRpbmdzSW5kZXhlc1sgZ3JvdXBOYW1lIF07XHJcblxyXG5cdFx0XHRpZiAoIHVuaWZvcm0udHlwZSA9PT0gJ3RleHR1cmUnIHx8IHVuaWZvcm0udHlwZSA9PT0gJ2N1YmVUZXh0dXJlJyB8fCB1bmlmb3JtLnR5cGUgPT09ICdzdG9yYWdlVGV4dHVyZScgfHwgdW5pZm9ybS50eXBlID09PSAndGV4dHVyZTNEJyApIHtcclxuXHJcblx0XHRcdFx0Y29uc3QgdGV4dHVyZSA9IHVuaWZvcm0ubm9kZS52YWx1ZTtcclxuXHJcblx0XHRcdFx0aWYgKCAoIHNoYWRlclN0YWdlID09PSAnZnJhZ21lbnQnIHx8IHNoYWRlclN0YWdlID09PSAnY29tcHV0ZScgKSAmJiB0aGlzLmlzVW5maWx0ZXJhYmxlKCB0ZXh0dXJlICkgPT09IGZhbHNlICYmIHVuaWZvcm0ubm9kZS5pc1N0b3JhZ2VUZXh0dXJlTm9kZSAhPT0gdHJ1ZSApIHtcclxuXHJcblx0XHRcdFx0XHRpZiAoIHRoaXMuaXNTYW1wbGVDb21wYXJlKCB0ZXh0dXJlICkgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRiaW5kaW5nU25pcHBldHMucHVzaCggYEBiaW5kaW5nKCAkeyB1bmlmb3JtSW5kZXhlcy5iaW5kaW5nICsrIH0gKSBAZ3JvdXAoICR7IHVuaWZvcm1JbmRleGVzLmdyb3VwIH0gKSB2YXIgJHsgdW5pZm9ybS5uYW1lIH1fc2FtcGxlciA6IHNhbXBsZXJfY29tcGFyaXNvbjtgICk7XHJcblxyXG5cdFx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHRcdGJpbmRpbmdTbmlwcGV0cy5wdXNoKCBgQGJpbmRpbmcoICR7IHVuaWZvcm1JbmRleGVzLmJpbmRpbmcgKysgfSApIEBncm91cCggJHsgdW5pZm9ybUluZGV4ZXMuZ3JvdXAgfSApIHZhciAkeyB1bmlmb3JtLm5hbWUgfV9zYW1wbGVyIDogc2FtcGxlcjtgICk7XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGxldCB0ZXh0dXJlVHlwZTtcclxuXHJcblx0XHRcdFx0bGV0IG11bHRpc2FtcGxlZCA9ICcnO1xyXG5cclxuXHRcdFx0XHRjb25zdCB7IHByaW1hcnlTYW1wbGVzIH0gPSB0aGlzLnJlbmRlcmVyLmJhY2tlbmQudXRpbHMuZ2V0VGV4dHVyZVNhbXBsZURhdGEoIHRleHR1cmUgKTtcclxuXHJcblx0XHRcdFx0aWYgKCBwcmltYXJ5U2FtcGxlcyA+IDEgKSB7XHJcblxyXG5cdFx0XHRcdFx0bXVsdGlzYW1wbGVkID0gJ19tdWx0aXNhbXBsZWQnO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGlmICggdGV4dHVyZS5pc0N1YmVUZXh0dXJlID09PSB0cnVlICkge1xyXG5cclxuXHRcdFx0XHRcdHRleHR1cmVUeXBlID0gJ3RleHR1cmVfY3ViZTxmMzI+JztcclxuXHJcblx0XHRcdFx0fSBlbHNlIGlmICggdGV4dHVyZS5pc0RhdGFBcnJheVRleHR1cmUgPT09IHRydWUgfHwgdGV4dHVyZS5pc0NvbXByZXNzZWRBcnJheVRleHR1cmUgPT09IHRydWUgKSB7XHJcblxyXG5cdFx0XHRcdFx0dGV4dHVyZVR5cGUgPSAndGV4dHVyZV8yZF9hcnJheTxmMzI+JztcclxuXHJcblx0XHRcdFx0fSBlbHNlIGlmICggdGV4dHVyZS5pc0RlcHRoVGV4dHVyZSA9PT0gdHJ1ZSApIHtcclxuXHJcblx0XHRcdFx0XHR0ZXh0dXJlVHlwZSA9IGB0ZXh0dXJlX2RlcHRoJHttdWx0aXNhbXBsZWR9XzJkYDtcclxuXHJcblx0XHRcdFx0fSBlbHNlIGlmICggdGV4dHVyZS5pc1ZpZGVvVGV4dHVyZSA9PT0gdHJ1ZSApIHtcclxuXHJcblx0XHRcdFx0XHR0ZXh0dXJlVHlwZSA9ICd0ZXh0dXJlX2V4dGVybmFsJztcclxuXHJcblx0XHRcdFx0fSBlbHNlIGlmICggdGV4dHVyZS5pc0RhdGEzRFRleHR1cmUgPT09IHRydWUgKSB7XHJcblxyXG5cdFx0XHRcdFx0dGV4dHVyZVR5cGUgPSAndGV4dHVyZV8zZDxmMzI+JztcclxuXHJcblx0XHRcdFx0fSBlbHNlIGlmICggdW5pZm9ybS5ub2RlLmlzU3RvcmFnZVRleHR1cmVOb2RlID09PSB0cnVlICkge1xyXG5cclxuXHRcdFx0XHRcdGNvbnN0IGZvcm1hdCA9IGdldEZvcm1hdCggdGV4dHVyZSApO1xyXG5cdFx0XHRcdFx0Y29uc3QgYWNjZXNzID0gdGhpcy5nZXRTdG9yYWdlQWNjZXNzKCB1bmlmb3JtLm5vZGUsIHNoYWRlclN0YWdlICk7XHJcblxyXG5cdFx0XHRcdFx0dGV4dHVyZVR5cGUgPSBgdGV4dHVyZV9zdG9yYWdlXzJkPCR7IGZvcm1hdCB9LCAkeyBhY2Nlc3MgfT5gO1xyXG5cclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdGNvbnN0IGNvbXBvbmVudFByZWZpeCA9IHRoaXMuZ2V0Q29tcG9uZW50VHlwZUZyb21UZXh0dXJlKCB0ZXh0dXJlICkuY2hhckF0KCAwICk7XHJcblxyXG5cdFx0XHRcdFx0dGV4dHVyZVR5cGUgPSBgdGV4dHVyZSR7bXVsdGlzYW1wbGVkfV8yZDwkeyBjb21wb25lbnRQcmVmaXggfTMyPmA7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0YmluZGluZ1NuaXBwZXRzLnB1c2goIGBAYmluZGluZyggJHsgdW5pZm9ybUluZGV4ZXMuYmluZGluZyArKyB9ICkgQGdyb3VwKCAkeyB1bmlmb3JtSW5kZXhlcy5ncm91cCB9ICkgdmFyICR7IHVuaWZvcm0ubmFtZSB9IDogJHsgdGV4dHVyZVR5cGUgfTtgICk7XHJcblxyXG5cdFx0XHR9IGVsc2UgaWYgKCB1bmlmb3JtLnR5cGUgPT09ICdidWZmZXInIHx8IHVuaWZvcm0udHlwZSA9PT0gJ3N0b3JhZ2VCdWZmZXInIHx8IHVuaWZvcm0udHlwZSA9PT0gJ2luZGlyZWN0U3RvcmFnZUJ1ZmZlcicgKSB7XHJcblxyXG5cdFx0XHRcdGNvbnN0IGJ1ZmZlck5vZGUgPSB1bmlmb3JtLm5vZGU7XHJcblx0XHRcdFx0Y29uc3QgYnVmZmVyVHlwZSA9IHRoaXMuZ2V0VHlwZSggYnVmZmVyTm9kZS5idWZmZXJUeXBlICk7XHJcblx0XHRcdFx0Y29uc3QgYnVmZmVyQ291bnQgPSBidWZmZXJOb2RlLmJ1ZmZlckNvdW50O1xyXG5cclxuXHRcdFx0XHRjb25zdCBidWZmZXJDb3VudFNuaXBwZXQgPSBidWZmZXJDb3VudCA+IDAgJiYgdW5pZm9ybS50eXBlID09PSAnYnVmZmVyJyA/ICcsICcgKyBidWZmZXJDb3VudCA6ICcnO1xyXG5cdFx0XHRcdGNvbnN0IGJ1ZmZlclR5cGVTbmlwcGV0ID0gYnVmZmVyTm9kZS5pc0F0b21pYyA/IGBhdG9taWM8JHtidWZmZXJUeXBlfT5gIDogYCR7YnVmZmVyVHlwZX1gO1xyXG5cdFx0XHRcdGNvbnN0IGJ1ZmZlclNuaXBwZXQgPSBgXFx0JHsgdW5pZm9ybS5uYW1lIH0gOiBhcnJheTwgJHsgYnVmZmVyVHlwZVNuaXBwZXQgfSR7IGJ1ZmZlckNvdW50U25pcHBldCB9ID5cXG5gO1xyXG5cdFx0XHRcdGNvbnN0IGJ1ZmZlckFjY2Vzc01vZGUgPSBidWZmZXJOb2RlLmlzU3RvcmFnZUJ1ZmZlck5vZGUgPyBgc3RvcmFnZSwgJHsgdGhpcy5nZXRTdG9yYWdlQWNjZXNzKCBidWZmZXJOb2RlLCBzaGFkZXJTdGFnZSApIH1gIDogJ3VuaWZvcm0nO1xyXG5cclxuXHRcdFx0XHRidWZmZXJTbmlwcGV0cy5wdXNoKCB0aGlzLl9nZXRXR1NMU3RydWN0QmluZGluZyggJ05vZGVCdWZmZXJfJyArIGJ1ZmZlck5vZGUuaWQsIGJ1ZmZlclNuaXBwZXQsIGJ1ZmZlckFjY2Vzc01vZGUsIHVuaWZvcm1JbmRleGVzLmJpbmRpbmcgKyssIHVuaWZvcm1JbmRleGVzLmdyb3VwICkgKTtcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdGNvbnN0IHZlY3RvclR5cGUgPSB0aGlzLmdldFR5cGUoIHRoaXMuZ2V0VmVjdG9yVHlwZSggdW5pZm9ybS50eXBlICkgKTtcclxuXHRcdFx0XHRjb25zdCBncm91cE5hbWUgPSB1bmlmb3JtLmdyb3VwTm9kZS5uYW1lO1xyXG5cclxuXHRcdFx0XHRjb25zdCBncm91cCA9IHVuaWZvcm1Hcm91cHNbIGdyb3VwTmFtZSBdIHx8ICggdW5pZm9ybUdyb3Vwc1sgZ3JvdXBOYW1lIF0gPSB7XHJcblx0XHRcdFx0XHRpbmRleDogdW5pZm9ybUluZGV4ZXMuYmluZGluZyArKyxcclxuXHRcdFx0XHRcdGlkOiB1bmlmb3JtSW5kZXhlcy5ncm91cCxcclxuXHRcdFx0XHRcdHNuaXBwZXRzOiBbXVxyXG5cdFx0XHRcdH0gKTtcclxuXHJcblx0XHRcdFx0Z3JvdXAuc25pcHBldHMucHVzaCggYFxcdCR7IHVuaWZvcm0ubmFtZSB9IDogJHsgdmVjdG9yVHlwZSB9YCApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRmb3IgKCBjb25zdCBuYW1lIGluIHVuaWZvcm1Hcm91cHMgKSB7XHJcblxyXG5cdFx0XHRjb25zdCBncm91cCA9IHVuaWZvcm1Hcm91cHNbIG5hbWUgXTtcclxuXHJcblx0XHRcdHN0cnVjdFNuaXBwZXRzLnB1c2goIHRoaXMuX2dldFdHU0xTdHJ1Y3RCaW5kaW5nKCBuYW1lLCBncm91cC5zbmlwcGV0cy5qb2luKCAnLFxcbicgKSwgJ3VuaWZvcm0nLCBncm91cC5pbmRleCwgZ3JvdXAuaWQgKSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRsZXQgY29kZSA9IGJpbmRpbmdTbmlwcGV0cy5qb2luKCAnXFxuJyApO1xyXG5cdFx0Y29kZSArPSBidWZmZXJTbmlwcGV0cy5qb2luKCAnXFxuJyApO1xyXG5cdFx0Y29kZSArPSBzdHJ1Y3RTbmlwcGV0cy5qb2luKCAnXFxuJyApO1xyXG5cclxuXHRcdHJldHVybiBjb2RlO1xyXG5cclxuXHR9XHJcblxyXG5cdGJ1aWxkQ29kZSgpIHtcclxuXHJcblx0XHRjb25zdCBzaGFkZXJzRGF0YSA9IHRoaXMubWF0ZXJpYWwgIT09IG51bGwgPyB7IGZyYWdtZW50OiB7fSwgdmVydGV4OiB7fSB9IDogeyBjb21wdXRlOiB7fSB9O1xyXG5cclxuXHRcdHRoaXMuc29ydEJpbmRpbmdHcm91cHMoKTtcclxuXHJcblx0XHRmb3IgKCBjb25zdCBzaGFkZXJTdGFnZSBpbiBzaGFkZXJzRGF0YSApIHtcclxuXHJcblx0XHRcdGNvbnN0IHN0YWdlRGF0YSA9IHNoYWRlcnNEYXRhWyBzaGFkZXJTdGFnZSBdO1xyXG5cdFx0XHRzdGFnZURhdGEudW5pZm9ybXMgPSB0aGlzLmdldFVuaWZvcm1zKCBzaGFkZXJTdGFnZSApO1xyXG5cdFx0XHRzdGFnZURhdGEuYXR0cmlidXRlcyA9IHRoaXMuZ2V0QXR0cmlidXRlcyggc2hhZGVyU3RhZ2UgKTtcclxuXHRcdFx0c3RhZ2VEYXRhLnZhcnlpbmdzID0gdGhpcy5nZXRWYXJ5aW5ncyggc2hhZGVyU3RhZ2UgKTtcclxuXHRcdFx0c3RhZ2VEYXRhLnN0cnVjdHMgPSB0aGlzLmdldFN0cnVjdHMoIHNoYWRlclN0YWdlICk7XHJcblx0XHRcdHN0YWdlRGF0YS52YXJzID0gdGhpcy5nZXRWYXJzKCBzaGFkZXJTdGFnZSApO1xyXG5cdFx0XHRzdGFnZURhdGEuY29kZXMgPSB0aGlzLmdldENvZGVzKCBzaGFkZXJTdGFnZSApO1xyXG5cdFx0XHRzdGFnZURhdGEuZGlyZWN0aXZlcyA9IHRoaXMuZ2V0RGlyZWN0aXZlcyggc2hhZGVyU3RhZ2UgKTtcclxuXHRcdFx0c3RhZ2VEYXRhLnNjb3BlZEFycmF5cyA9IHRoaXMuZ2V0U2NvcGVkQXJyYXlzKCBzaGFkZXJTdGFnZSApO1xyXG5cclxuXHRcdFx0Ly9cclxuXHJcblx0XHRcdGxldCBmbG93ID0gJy8vIGNvZGVcXG5cXG4nO1xyXG5cdFx0XHRmbG93ICs9IHRoaXMuZmxvd0NvZGVbIHNoYWRlclN0YWdlIF07XHJcblxyXG5cdFx0XHRjb25zdCBmbG93Tm9kZXMgPSB0aGlzLmZsb3dOb2Rlc1sgc2hhZGVyU3RhZ2UgXTtcclxuXHRcdFx0Y29uc3QgbWFpbk5vZGUgPSBmbG93Tm9kZXNbIGZsb3dOb2Rlcy5sZW5ndGggLSAxIF07XHJcblxyXG5cdFx0XHRjb25zdCBvdXRwdXROb2RlID0gbWFpbk5vZGUub3V0cHV0Tm9kZTtcclxuXHRcdFx0Y29uc3QgaXNPdXRwdXRTdHJ1Y3QgPSAoIG91dHB1dE5vZGUgIT09IHVuZGVmaW5lZCAmJiBvdXRwdXROb2RlLmlzT3V0cHV0U3RydWN0Tm9kZSA9PT0gdHJ1ZSApO1xyXG5cclxuXHRcdFx0Zm9yICggY29uc3Qgbm9kZSBvZiBmbG93Tm9kZXMgKSB7XHJcblxyXG5cdFx0XHRcdGNvbnN0IGZsb3dTbG90RGF0YSA9IHRoaXMuZ2V0Rmxvd0RhdGEoIG5vZGUvKiwgc2hhZGVyU3RhZ2UqLyApO1xyXG5cdFx0XHRcdGNvbnN0IHNsb3ROYW1lID0gbm9kZS5uYW1lO1xyXG5cclxuXHRcdFx0XHRpZiAoIHNsb3ROYW1lICkge1xyXG5cclxuXHRcdFx0XHRcdGlmICggZmxvdy5sZW5ndGggPiAwICkgZmxvdyArPSAnXFxuJztcclxuXHJcblx0XHRcdFx0XHRmbG93ICs9IGBcXHQvLyBmbG93IC0+ICR7IHNsb3ROYW1lIH1cXG5cXHRgO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGZsb3cgKz0gYCR7IGZsb3dTbG90RGF0YS5jb2RlIH1cXG5cXHRgO1xyXG5cclxuXHRcdFx0XHRpZiAoIG5vZGUgPT09IG1haW5Ob2RlICYmIHNoYWRlclN0YWdlICE9PSAnY29tcHV0ZScgKSB7XHJcblxyXG5cdFx0XHRcdFx0ZmxvdyArPSAnLy8gcmVzdWx0XFxuXFxuXFx0JztcclxuXHJcblx0XHRcdFx0XHRpZiAoIHNoYWRlclN0YWdlID09PSAndmVydGV4JyApIHtcclxuXHJcblx0XHRcdFx0XHRcdGZsb3cgKz0gYHZhcnlpbmdzLlZlcnRleCA9ICR7IGZsb3dTbG90RGF0YS5yZXN1bHQgfTtgO1xyXG5cclxuXHRcdFx0XHRcdH0gZWxzZSBpZiAoIHNoYWRlclN0YWdlID09PSAnZnJhZ21lbnQnICkge1xyXG5cclxuXHRcdFx0XHRcdFx0aWYgKCBpc091dHB1dFN0cnVjdCApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0c3RhZ2VEYXRhLnJldHVyblR5cGUgPSBvdXRwdXROb2RlLm5vZGVUeXBlO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRmbG93ICs9IGByZXR1cm4gJHsgZmxvd1Nsb3REYXRhLnJlc3VsdCB9O2A7XHJcblxyXG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdFx0XHRsZXQgc3RydWN0U25pcHBldCA9ICdcXHRAbG9jYXRpb24oMCkgY29sb3I6IHZlYzQ8ZjMyPic7XHJcblxyXG5cdFx0XHRcdFx0XHRcdGNvbnN0IGJ1aWx0aW5zID0gdGhpcy5nZXRCdWlsdGlucyggJ291dHB1dCcgKTtcclxuXHJcblx0XHRcdFx0XHRcdFx0aWYgKCBidWlsdGlucyApIHN0cnVjdFNuaXBwZXQgKz0gJyxcXG5cXHQnICsgYnVpbHRpbnM7XHJcblxyXG5cdFx0XHRcdFx0XHRcdHN0YWdlRGF0YS5yZXR1cm5UeXBlID0gJ091dHB1dFN0cnVjdCc7XHJcblx0XHRcdFx0XHRcdFx0c3RhZ2VEYXRhLnN0cnVjdHMgKz0gdGhpcy5fZ2V0V0dTTFN0cnVjdCggJ091dHB1dFN0cnVjdCcsIHN0cnVjdFNuaXBwZXQgKTtcclxuXHRcdFx0XHRcdFx0XHRzdGFnZURhdGEuc3RydWN0cyArPSAnXFxudmFyPHByaXZhdGU+IG91dHB1dCA6IE91dHB1dFN0cnVjdDtcXG5cXG4nO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRmbG93ICs9IGBvdXRwdXQuY29sb3IgPSAkeyBmbG93U2xvdERhdGEucmVzdWx0IH07XFxuXFxuXFx0cmV0dXJuIG91dHB1dDtgO1xyXG5cclxuXHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0c3RhZ2VEYXRhLmZsb3cgPSBmbG93O1xyXG5cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCB0aGlzLm1hdGVyaWFsICE9PSBudWxsICkge1xyXG5cclxuXHRcdFx0dGhpcy52ZXJ0ZXhTaGFkZXIgPSB0aGlzLl9nZXRXR1NMVmVydGV4Q29kZSggc2hhZGVyc0RhdGEudmVydGV4ICk7XHJcblx0XHRcdHRoaXMuZnJhZ21lbnRTaGFkZXIgPSB0aGlzLl9nZXRXR1NMRnJhZ21lbnRDb2RlKCBzaGFkZXJzRGF0YS5mcmFnbWVudCApO1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHR0aGlzLmNvbXB1dGVTaGFkZXIgPSB0aGlzLl9nZXRXR1NMQ29tcHV0ZUNvZGUoIHNoYWRlcnNEYXRhLmNvbXB1dGUsICggdGhpcy5vYmplY3Qud29ya2dyb3VwU2l6ZSB8fCBbIDY0IF0gKS5qb2luKCAnLCAnICkgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0Z2V0TWV0aG9kKCBtZXRob2QsIG91dHB1dCA9IG51bGwgKSB7XHJcblxyXG5cdFx0bGV0IHdnc2xNZXRob2Q7XHJcblxyXG5cdFx0aWYgKCBvdXRwdXQgIT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHR3Z3NsTWV0aG9kID0gdGhpcy5fZ2V0V0dTTE1ldGhvZCggbWV0aG9kICsgJ18nICsgb3V0cHV0ICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggd2dzbE1ldGhvZCA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0d2dzbE1ldGhvZCA9IHRoaXMuX2dldFdHU0xNZXRob2QoIG1ldGhvZCApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gd2dzbE1ldGhvZCB8fCBtZXRob2Q7XHJcblxyXG5cdH1cclxuXHJcblx0Z2V0VHlwZSggdHlwZSApIHtcclxuXHJcblx0XHRyZXR1cm4gd2dzbFR5cGVMaWJbIHR5cGUgXSB8fCB0eXBlO1xyXG5cclxuXHR9XHJcblxyXG5cdGlzQXZhaWxhYmxlKCBuYW1lICkge1xyXG5cclxuXHRcdGxldCByZXN1bHQgPSBzdXBwb3J0c1sgbmFtZSBdO1xyXG5cclxuXHRcdGlmICggcmVzdWx0ID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRpZiAoIG5hbWUgPT09ICdmbG9hdDMyRmlsdGVyYWJsZScgKSB7XHJcblxyXG5cdFx0XHRcdHJlc3VsdCA9IHRoaXMucmVuZGVyZXIuaGFzRmVhdHVyZSggJ2Zsb2F0MzItZmlsdGVyYWJsZScgKTtcclxuXHJcblx0XHRcdH0gZWxzZSBpZiAoIG5hbWUgPT09ICdjbGlwRGlzdGFuY2UnICkge1xyXG5cclxuXHRcdFx0XHRyZXN1bHQgPSB0aGlzLnJlbmRlcmVyLmhhc0ZlYXR1cmUoICdjbGlwLWRpc3RhbmNlcycgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHN1cHBvcnRzWyBuYW1lIF0gPSByZXN1bHQ7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiByZXN1bHQ7XHJcblxyXG5cdH1cclxuXHJcblx0X2dldFdHU0xNZXRob2QoIG1ldGhvZCApIHtcclxuXHJcblx0XHRpZiAoIHdnc2xQb2x5ZmlsbFsgbWV0aG9kIF0gIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdHRoaXMuX2luY2x1ZGUoIG1ldGhvZCApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gd2dzbE1ldGhvZHNbIG1ldGhvZCBdO1xyXG5cclxuXHR9XHJcblxyXG5cdF9pbmNsdWRlKCBuYW1lICkge1xyXG5cclxuXHRcdGNvbnN0IGNvZGVOb2RlID0gd2dzbFBvbHlmaWxsWyBuYW1lIF07XHJcblx0XHRjb2RlTm9kZS5idWlsZCggdGhpcyApO1xyXG5cclxuXHRcdGlmICggdGhpcy5jdXJyZW50RnVuY3Rpb25Ob2RlICE9PSBudWxsICkge1xyXG5cclxuXHRcdFx0dGhpcy5jdXJyZW50RnVuY3Rpb25Ob2RlLmluY2x1ZGVzLnB1c2goIGNvZGVOb2RlICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBjb2RlTm9kZTtcclxuXHJcblx0fVxyXG5cclxuXHRfZ2V0V0dTTFZlcnRleENvZGUoIHNoYWRlckRhdGEgKSB7XHJcblxyXG5cdFx0cmV0dXJuIGAkeyB0aGlzLmdldFNpZ25hdHVyZSgpIH1cclxuLy8gZGlyZWN0aXZlc1xyXG4ke3NoYWRlckRhdGEuZGlyZWN0aXZlc31cclxuXHJcbi8vIHVuaWZvcm1zXHJcbiR7c2hhZGVyRGF0YS51bmlmb3Jtc31cclxuXHJcbi8vIHZhcnlpbmdzXHJcbiR7c2hhZGVyRGF0YS52YXJ5aW5nc31cclxudmFyPHByaXZhdGU+IHZhcnlpbmdzIDogVmFyeWluZ3NTdHJ1Y3Q7XHJcblxyXG4vLyBjb2Rlc1xyXG4ke3NoYWRlckRhdGEuY29kZXN9XHJcblxyXG5AdmVydGV4XHJcbmZuIG1haW4oICR7c2hhZGVyRGF0YS5hdHRyaWJ1dGVzfSApIC0+IFZhcnlpbmdzU3RydWN0IHtcclxuXHJcblx0Ly8gdmFyc1xyXG5cdCR7c2hhZGVyRGF0YS52YXJzfVxyXG5cclxuXHQvLyBmbG93XHJcblx0JHtzaGFkZXJEYXRhLmZsb3d9XHJcblxyXG5cdHJldHVybiB2YXJ5aW5ncztcclxuXHJcbn1cclxuYDtcclxuXHJcblx0fVxyXG5cclxuXHRfZ2V0V0dTTEZyYWdtZW50Q29kZSggc2hhZGVyRGF0YSApIHtcclxuXHJcblx0XHRyZXR1cm4gYCR7IHRoaXMuZ2V0U2lnbmF0dXJlKCkgfVxyXG4vLyBnbG9iYWxcclxuJHsgZGlhZ25vc3RpY3MgfVxyXG5cclxuLy8gdW5pZm9ybXNcclxuJHtzaGFkZXJEYXRhLnVuaWZvcm1zfVxyXG5cclxuLy8gc3RydWN0c1xyXG4ke3NoYWRlckRhdGEuc3RydWN0c31cclxuXHJcbi8vIGNvZGVzXHJcbiR7c2hhZGVyRGF0YS5jb2Rlc31cclxuXHJcbkBmcmFnbWVudFxyXG5mbiBtYWluKCAke3NoYWRlckRhdGEudmFyeWluZ3N9ICkgLT4gJHtzaGFkZXJEYXRhLnJldHVyblR5cGV9IHtcclxuXHJcblx0Ly8gdmFyc1xyXG5cdCR7c2hhZGVyRGF0YS52YXJzfVxyXG5cclxuXHQvLyBmbG93XHJcblx0JHtzaGFkZXJEYXRhLmZsb3d9XHJcblxyXG59XHJcbmA7XHJcblxyXG5cdH1cclxuXHJcblx0X2dldFdHU0xDb21wdXRlQ29kZSggc2hhZGVyRGF0YSwgd29ya2dyb3VwU2l6ZSApIHtcclxuXHJcblx0XHRyZXR1cm4gYCR7IHRoaXMuZ2V0U2lnbmF0dXJlKCkgfVxyXG4vLyBkaXJlY3RpdmVzXHJcbiR7c2hhZGVyRGF0YS5kaXJlY3RpdmVzfVxyXG5cclxuLy8gc3lzdGVtXHJcbnZhcjxwcml2YXRlPiBpbnN0YW5jZUluZGV4IDogdTMyO1xyXG5cclxuLy8gbG9jYWxzXHJcbiR7c2hhZGVyRGF0YS5zY29wZWRBcnJheXN9XHJcblxyXG4vLyB1bmlmb3Jtc1xyXG4ke3NoYWRlckRhdGEudW5pZm9ybXN9XHJcblxyXG4vLyBjb2Rlc1xyXG4ke3NoYWRlckRhdGEuY29kZXN9XHJcblxyXG5AY29tcHV0ZSBAd29ya2dyb3VwX3NpemUoICR7d29ya2dyb3VwU2l6ZX0gKVxyXG5mbiBtYWluKCAke3NoYWRlckRhdGEuYXR0cmlidXRlc30gKSB7XHJcblxyXG5cdC8vIHN5c3RlbVxyXG5cdGluc3RhbmNlSW5kZXggPSBpZC54ICsgaWQueSAqIG51bVdvcmtncm91cHMueCAqIHUzMigke3dvcmtncm91cFNpemV9KSArIGlkLnogKiBudW1Xb3JrZ3JvdXBzLnggKiBudW1Xb3JrZ3JvdXBzLnkgKiB1MzIoJHt3b3JrZ3JvdXBTaXplfSk7XHJcblxyXG5cdC8vIHZhcnNcclxuXHQke3NoYWRlckRhdGEudmFyc31cclxuXHJcblx0Ly8gZmxvd1xyXG5cdCR7c2hhZGVyRGF0YS5mbG93fVxyXG5cclxufVxyXG5gO1xyXG5cclxuXHR9XHJcblxyXG5cdF9nZXRXR1NMU3RydWN0KCBuYW1lLCB2YXJzICkge1xyXG5cclxuXHRcdHJldHVybiBgXHJcbnN0cnVjdCAke25hbWV9IHtcclxuJHt2YXJzfVxyXG59O2A7XHJcblxyXG5cdH1cclxuXHJcblx0X2dldFdHU0xTdHJ1Y3RCaW5kaW5nKCBuYW1lLCB2YXJzLCBhY2Nlc3MsIGJpbmRpbmcgPSAwLCBncm91cCA9IDAgKSB7XHJcblxyXG5cdFx0Y29uc3Qgc3RydWN0TmFtZSA9IG5hbWUgKyAnU3RydWN0JztcclxuXHRcdGNvbnN0IHN0cnVjdFNuaXBwZXQgPSB0aGlzLl9nZXRXR1NMU3RydWN0KCBzdHJ1Y3ROYW1lLCB2YXJzICk7XHJcblxyXG5cdFx0cmV0dXJuIGAke3N0cnVjdFNuaXBwZXR9XHJcbkBiaW5kaW5nKCAke2JpbmRpbmd9ICkgQGdyb3VwKCAke2dyb3VwfSApXHJcbnZhcjwke2FjY2Vzc30+ICR7bmFtZX0gOiAke3N0cnVjdE5hbWV9O2A7XHJcblxyXG5cdH1cclxuXHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IFdHU0xOb2RlQnVpbGRlcjtcclxuIiwiaW1wb3J0IHsgR1BVUHJpbWl0aXZlVG9wb2xvZ3ksIEdQVVRleHR1cmVGb3JtYXQgfSBmcm9tICcuL1dlYkdQVUNvbnN0YW50cy5qcyc7XHJcblxyXG5jbGFzcyBXZWJHUFVVdGlscyB7XHJcblxyXG5cdGNvbnN0cnVjdG9yKCBiYWNrZW5kICkge1xyXG5cclxuXHRcdHRoaXMuYmFja2VuZCA9IGJhY2tlbmQ7XHJcblxyXG5cdH1cclxuXHJcblx0Z2V0Q3VycmVudERlcHRoU3RlbmNpbEZvcm1hdCggcmVuZGVyQ29udGV4dCApIHtcclxuXHJcblx0XHRsZXQgZm9ybWF0O1xyXG5cclxuXHRcdGlmICggcmVuZGVyQ29udGV4dC5kZXB0aFRleHR1cmUgIT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHRmb3JtYXQgPSB0aGlzLmdldFRleHR1cmVGb3JtYXRHUFUoIHJlbmRlckNvbnRleHQuZGVwdGhUZXh0dXJlICk7XHJcblxyXG5cdFx0fSBlbHNlIGlmICggcmVuZGVyQ29udGV4dC5kZXB0aCAmJiByZW5kZXJDb250ZXh0LnN0ZW5jaWwgKSB7XHJcblxyXG5cdFx0XHRmb3JtYXQgPSBHUFVUZXh0dXJlRm9ybWF0LkRlcHRoMjRQbHVzU3RlbmNpbDg7XHJcblxyXG5cdFx0fSBlbHNlIGlmICggcmVuZGVyQ29udGV4dC5kZXB0aCApIHtcclxuXHJcblx0XHRcdGZvcm1hdCA9IEdQVVRleHR1cmVGb3JtYXQuRGVwdGgyNFBsdXM7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBmb3JtYXQ7XHJcblxyXG5cdH1cclxuXHJcblx0Z2V0VGV4dHVyZUZvcm1hdEdQVSggdGV4dHVyZSApIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5iYWNrZW5kLmdldCggdGV4dHVyZSApLmZvcm1hdDtcclxuXHJcblx0fVxyXG5cclxuXHRnZXRUZXh0dXJlU2FtcGxlRGF0YSggdGV4dHVyZSApIHtcclxuXHJcblx0XHRsZXQgc2FtcGxlcztcclxuXHJcblx0XHRpZiAoIHRleHR1cmUuaXNGcmFtZWJ1ZmZlclRleHR1cmUgKSB7XHJcblxyXG5cdFx0XHRzYW1wbGVzID0gMTtcclxuXHJcblx0XHR9IGVsc2UgaWYgKCB0ZXh0dXJlLmlzRGVwdGhUZXh0dXJlICYmICEgdGV4dHVyZS5yZW5kZXJUYXJnZXQgKSB7XHJcblxyXG5cdFx0XHRjb25zdCByZW5kZXJlciA9IHRoaXMuYmFja2VuZC5yZW5kZXJlcjtcclxuXHRcdFx0Y29uc3QgcmVuZGVyVGFyZ2V0ID0gcmVuZGVyZXIuZ2V0UmVuZGVyVGFyZ2V0KCk7XHJcblxyXG5cdFx0XHRzYW1wbGVzID0gcmVuZGVyVGFyZ2V0ID8gcmVuZGVyVGFyZ2V0LnNhbXBsZXMgOiByZW5kZXJlci5zYW1wbGVzO1xyXG5cclxuXHRcdH0gZWxzZSBpZiAoIHRleHR1cmUucmVuZGVyVGFyZ2V0ICkge1xyXG5cclxuXHRcdFx0c2FtcGxlcyA9IHRleHR1cmUucmVuZGVyVGFyZ2V0LnNhbXBsZXM7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHNhbXBsZXMgPSBzYW1wbGVzIHx8IDE7XHJcblxyXG5cdFx0Y29uc3QgaXNNU0FBID0gc2FtcGxlcyA+IDEgJiYgdGV4dHVyZS5yZW5kZXJUYXJnZXQgIT09IG51bGwgJiYgKCB0ZXh0dXJlLmlzRGVwdGhUZXh0dXJlICE9PSB0cnVlICYmIHRleHR1cmUuaXNGcmFtZWJ1ZmZlclRleHR1cmUgIT09IHRydWUgKTtcclxuXHRcdGNvbnN0IHByaW1hcnlTYW1wbGVzID0gaXNNU0FBID8gMSA6IHNhbXBsZXM7XHJcblxyXG5cdFx0cmV0dXJuIHsgc2FtcGxlcywgcHJpbWFyeVNhbXBsZXMsIGlzTVNBQSB9O1xyXG5cclxuXHR9XHJcblxyXG5cdGdldEN1cnJlbnRDb2xvckZvcm1hdCggcmVuZGVyQ29udGV4dCApIHtcclxuXHJcblx0XHRsZXQgZm9ybWF0O1xyXG5cclxuXHRcdGlmICggcmVuZGVyQ29udGV4dC50ZXh0dXJlcyAhPT0gbnVsbCApIHtcclxuXHJcblx0XHRcdGZvcm1hdCA9IHRoaXMuZ2V0VGV4dHVyZUZvcm1hdEdQVSggcmVuZGVyQ29udGV4dC50ZXh0dXJlc1sgMCBdICk7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdGZvcm1hdCA9IHRoaXMuZ2V0UHJlZmVycmVkQ2FudmFzRm9ybWF0KCk7IC8vIGRlZmF1bHQgY29udGV4dCBmb3JtYXRcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGZvcm1hdDtcclxuXHJcblx0fVxyXG5cclxuXHRnZXRDdXJyZW50Q29sb3JTcGFjZSggcmVuZGVyQ29udGV4dCApIHtcclxuXHJcblx0XHRpZiAoIHJlbmRlckNvbnRleHQudGV4dHVyZXMgIT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gcmVuZGVyQ29udGV4dC50ZXh0dXJlc1sgMCBdLmNvbG9yU3BhY2U7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzLmJhY2tlbmQucmVuZGVyZXIub3V0cHV0Q29sb3JTcGFjZTtcclxuXHJcblx0fVxyXG5cclxuXHRnZXRQcmltaXRpdmVUb3BvbG9neSggb2JqZWN0LCBtYXRlcmlhbCApIHtcclxuXHJcblx0XHRpZiAoIG9iamVjdC5pc1BvaW50cyApIHJldHVybiBHUFVQcmltaXRpdmVUb3BvbG9neS5Qb2ludExpc3Q7XHJcblx0XHRlbHNlIGlmICggb2JqZWN0LmlzTGluZVNlZ21lbnRzIHx8ICggb2JqZWN0LmlzTWVzaCAmJiBtYXRlcmlhbC53aXJlZnJhbWUgPT09IHRydWUgKSApIHJldHVybiBHUFVQcmltaXRpdmVUb3BvbG9neS5MaW5lTGlzdDtcclxuXHRcdGVsc2UgaWYgKCBvYmplY3QuaXNMaW5lICkgcmV0dXJuIEdQVVByaW1pdGl2ZVRvcG9sb2d5LkxpbmVTdHJpcDtcclxuXHRcdGVsc2UgaWYgKCBvYmplY3QuaXNNZXNoICkgcmV0dXJuIEdQVVByaW1pdGl2ZVRvcG9sb2d5LlRyaWFuZ2xlTGlzdDtcclxuXHJcblx0fVxyXG5cclxuXHRnZXRTYW1wbGVDb3VudCggc2FtcGxlQ291bnQgKSB7XHJcblxyXG5cdFx0bGV0IGNvdW50ID0gMTtcclxuXHJcblx0XHRpZiAoIHNhbXBsZUNvdW50ID4gMSApIHtcclxuXHJcblx0XHRcdC8vIFdlYkdQVSBvbmx5IHN1cHBvcnRzIHBvd2VyLW9mLXR3byBzYW1wbGUgY291bnRzIGFuZCAyIGlzIG5vdCBhIHZhbGlkIHZhbHVlXHJcblx0XHRcdGNvdW50ID0gTWF0aC5wb3coIDIsIE1hdGguZmxvb3IoIE1hdGgubG9nMiggc2FtcGxlQ291bnQgKSApICk7XHJcblxyXG5cdFx0XHRpZiAoIGNvdW50ID09PSAyICkge1xyXG5cclxuXHRcdFx0XHRjb3VudCA9IDQ7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBjb3VudDtcclxuXHJcblx0fVxyXG5cclxuXHRnZXRTYW1wbGVDb3VudFJlbmRlckNvbnRleHQoIHJlbmRlckNvbnRleHQgKSB7XHJcblxyXG5cdFx0aWYgKCByZW5kZXJDb250ZXh0LnRleHR1cmVzICE9PSBudWxsICkge1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXMuZ2V0U2FtcGxlQ291bnQoIHJlbmRlckNvbnRleHQuc2FtcGxlQ291bnQgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuZ2V0U2FtcGxlQ291bnQoIHRoaXMuYmFja2VuZC5yZW5kZXJlci5zYW1wbGVzICk7XHJcblxyXG5cdH1cclxuXHJcblx0Z2V0UHJlZmVycmVkQ2FudmFzRm9ybWF0KCkge1xyXG5cclxuXHRcdC8vIFRPRE86IFJlbW92ZSB0aGlzIGNoZWNrIHdoZW4gUXVlc3QgMzQuNSBpcyBvdXRcclxuXHRcdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tcmRvb2IvdGhyZWUuanMvcHVsbC8yOTIyMS9maWxlcyNyMTczMTgzMzk0OVxyXG5cclxuXHRcdGlmICggbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmNsdWRlcyggJ1F1ZXN0JyApICkge1xyXG5cclxuXHRcdFx0cmV0dXJuIEdQVVRleHR1cmVGb3JtYXQuQkdSQThVbm9ybTtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0cmV0dXJuIG5hdmlnYXRvci5ncHUuZ2V0UHJlZmVycmVkQ2FudmFzRm9ybWF0KCk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBXZWJHUFVVdGlscztcclxuIiwiaW1wb3J0IHsgR1BVSW5wdXRTdGVwTW9kZSB9IGZyb20gJy4vV2ViR1BVQ29uc3RhbnRzLmpzJztcclxuXHJcbmltcG9ydCB7IEZsb2F0MTZCdWZmZXJBdHRyaWJ1dGUgfSBmcm9tICcuLi8uLi8uLi9jb3JlL0J1ZmZlckF0dHJpYnV0ZS5qcyc7XHJcblxyXG5jb25zdCB0eXBlZEFycmF5c1RvVmVydGV4Rm9ybWF0UHJlZml4ID0gbmV3IE1hcCggW1xyXG5cdFsgSW50OEFycmF5LCBbICdzaW50OCcsICdzbm9ybTgnIF1dLFxyXG5cdFsgVWludDhBcnJheSwgWyAndWludDgnLCAndW5vcm04JyBdXSxcclxuXHRbIEludDE2QXJyYXksIFsgJ3NpbnQxNicsICdzbm9ybTE2JyBdXSxcclxuXHRbIFVpbnQxNkFycmF5LCBbICd1aW50MTYnLCAndW5vcm0xNicgXV0sXHJcblx0WyBJbnQzMkFycmF5LCBbICdzaW50MzInLCAnc25vcm0zMicgXV0sXHJcblx0WyBVaW50MzJBcnJheSwgWyAndWludDMyJywgJ3Vub3JtMzInIF1dLFxyXG5cdFsgRmxvYXQzMkFycmF5LCBbICdmbG9hdDMyJywgXV0sXHJcbl0gKTtcclxuXHJcbmNvbnN0IHR5cGVkQXR0cmlidXRlVG9WZXJ0ZXhGb3JtYXRQcmVmaXggPSBuZXcgTWFwKCBbXHJcblx0WyBGbG9hdDE2QnVmZmVyQXR0cmlidXRlLCBbICdmbG9hdDE2JywgXV0sXHJcbl0gKTtcclxuXHJcbmNvbnN0IHR5cGVBcnJheXNUb1ZlcnRleEZvcm1hdFByZWZpeEZvckl0ZW1TaXplMSA9IG5ldyBNYXAoIFtcclxuXHRbIEludDMyQXJyYXksICdzaW50MzInIF0sXHJcblx0WyBJbnQxNkFycmF5LCAnc2ludDMyJyBdLCAvLyBwYXRjaCBmb3IgSU5UMTZcclxuXHRbIFVpbnQzMkFycmF5LCAndWludDMyJyBdLFxyXG5cdFsgVWludDE2QXJyYXksICd1aW50MzInIF0sIC8vIHBhdGNoIGZvciBVSU5UMTZcclxuXHRbIEZsb2F0MzJBcnJheSwgJ2Zsb2F0MzInIF1cclxuXSApO1xyXG5cclxuY2xhc3MgV2ViR1BVQXR0cmlidXRlVXRpbHMge1xyXG5cclxuXHRjb25zdHJ1Y3RvciggYmFja2VuZCApIHtcclxuXHJcblx0XHR0aGlzLmJhY2tlbmQgPSBiYWNrZW5kO1xyXG5cclxuXHR9XHJcblxyXG5cdGNyZWF0ZUF0dHJpYnV0ZSggYXR0cmlidXRlLCB1c2FnZSApIHtcclxuXHJcblx0XHRjb25zdCBidWZmZXJBdHRyaWJ1dGUgPSB0aGlzLl9nZXRCdWZmZXJBdHRyaWJ1dGUoIGF0dHJpYnV0ZSApO1xyXG5cclxuXHRcdGNvbnN0IGJhY2tlbmQgPSB0aGlzLmJhY2tlbmQ7XHJcblx0XHRjb25zdCBidWZmZXJEYXRhID0gYmFja2VuZC5nZXQoIGJ1ZmZlckF0dHJpYnV0ZSApO1xyXG5cclxuXHRcdGxldCBidWZmZXIgPSBidWZmZXJEYXRhLmJ1ZmZlcjtcclxuXHJcblx0XHRpZiAoIGJ1ZmZlciA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0Y29uc3QgZGV2aWNlID0gYmFja2VuZC5kZXZpY2U7XHJcblxyXG5cdFx0XHRsZXQgYXJyYXkgPSBidWZmZXJBdHRyaWJ1dGUuYXJyYXk7XHJcblxyXG5cdFx0XHQvLyBwYXRjaCBmb3IgSU5UMTYgYW5kIFVJTlQxNlxyXG5cdFx0XHRpZiAoIGF0dHJpYnV0ZS5ub3JtYWxpemVkID09PSBmYWxzZSAmJiAoIGFycmF5LmNvbnN0cnVjdG9yID09PSBJbnQxNkFycmF5IHx8IGFycmF5LmNvbnN0cnVjdG9yID09PSBVaW50MTZBcnJheSApICkge1xyXG5cclxuXHRcdFx0XHRjb25zdCB0ZW1wQXJyYXkgPSBuZXcgVWludDMyQXJyYXkoIGFycmF5Lmxlbmd0aCApO1xyXG5cdFx0XHRcdGZvciAoIGxldCBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0XHR0ZW1wQXJyYXlbIGkgXSA9IGFycmF5WyBpIF07XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0YXJyYXkgPSB0ZW1wQXJyYXk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRidWZmZXJBdHRyaWJ1dGUuYXJyYXkgPSBhcnJheTtcclxuXHJcblx0XHRcdGlmICggKCBidWZmZXJBdHRyaWJ1dGUuaXNTdG9yYWdlQnVmZmVyQXR0cmlidXRlIHx8IGJ1ZmZlckF0dHJpYnV0ZS5pc1N0b3JhZ2VJbnN0YW5jZWRCdWZmZXJBdHRyaWJ1dGUgKSAmJiBidWZmZXJBdHRyaWJ1dGUuaXRlbVNpemUgPT09IDMgKSB7XHJcblxyXG5cdFx0XHRcdGFycmF5ID0gbmV3IGFycmF5LmNvbnN0cnVjdG9yKCBidWZmZXJBdHRyaWJ1dGUuY291bnQgKiA0ICk7XHJcblxyXG5cdFx0XHRcdGZvciAoIGxldCBpID0gMDsgaSA8IGJ1ZmZlckF0dHJpYnV0ZS5jb3VudDsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0XHRhcnJheS5zZXQoIGJ1ZmZlckF0dHJpYnV0ZS5hcnJheS5zdWJhcnJheSggaSAqIDMsIGkgKiAzICsgMyApLCBpICogNCApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdC8vIFVwZGF0ZSBCdWZmZXJBdHRyaWJ1dGVcclxuXHRcdFx0XHRidWZmZXJBdHRyaWJ1dGUuaXRlbVNpemUgPSA0O1xyXG5cdFx0XHRcdGJ1ZmZlckF0dHJpYnV0ZS5hcnJheSA9IGFycmF5O1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Y29uc3Qgc2l6ZSA9IGFycmF5LmJ5dGVMZW5ndGggKyAoICggNCAtICggYXJyYXkuYnl0ZUxlbmd0aCAlIDQgKSApICUgNCApOyAvLyBlbnN1cmUgNCBieXRlIGFsaWdubWVudCwgc2VlICMyMDQ0MVxyXG5cclxuXHRcdFx0YnVmZmVyID0gZGV2aWNlLmNyZWF0ZUJ1ZmZlcigge1xyXG5cdFx0XHRcdGxhYmVsOiBidWZmZXJBdHRyaWJ1dGUubmFtZSxcclxuXHRcdFx0XHRzaXplOiBzaXplLFxyXG5cdFx0XHRcdHVzYWdlOiB1c2FnZSxcclxuXHRcdFx0XHRtYXBwZWRBdENyZWF0aW9uOiB0cnVlXHJcblx0XHRcdH0gKTtcclxuXHJcblx0XHRcdG5ldyBhcnJheS5jb25zdHJ1Y3RvciggYnVmZmVyLmdldE1hcHBlZFJhbmdlKCkgKS5zZXQoIGFycmF5ICk7XHJcblxyXG5cdFx0XHRidWZmZXIudW5tYXAoKTtcclxuXHJcblx0XHRcdGJ1ZmZlckRhdGEuYnVmZmVyID0gYnVmZmVyO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHR1cGRhdGVBdHRyaWJ1dGUoIGF0dHJpYnV0ZSApIHtcclxuXHJcblx0XHRjb25zdCBidWZmZXJBdHRyaWJ1dGUgPSB0aGlzLl9nZXRCdWZmZXJBdHRyaWJ1dGUoIGF0dHJpYnV0ZSApO1xyXG5cclxuXHRcdGNvbnN0IGJhY2tlbmQgPSB0aGlzLmJhY2tlbmQ7XHJcblx0XHRjb25zdCBkZXZpY2UgPSBiYWNrZW5kLmRldmljZTtcclxuXHJcblx0XHRjb25zdCBidWZmZXIgPSBiYWNrZW5kLmdldCggYnVmZmVyQXR0cmlidXRlICkuYnVmZmVyO1xyXG5cclxuXHRcdGNvbnN0IGFycmF5ID0gYnVmZmVyQXR0cmlidXRlLmFycmF5O1xyXG5cdFx0Y29uc3QgaXNUeXBlZEFycmF5ID0gdGhpcy5faXNUeXBlZEFycmF5KCBhcnJheSApO1xyXG5cdFx0Y29uc3QgdXBkYXRlUmFuZ2VzID0gYnVmZmVyQXR0cmlidXRlLnVwZGF0ZVJhbmdlcztcclxuXHJcblx0XHRpZiAoIHVwZGF0ZVJhbmdlcy5sZW5ndGggPT09IDAgKSB7XHJcblxyXG5cdFx0XHQvLyBOb3QgdXNpbmcgdXBkYXRlIHJhbmdlc1xyXG5cclxuXHRcdFx0ZGV2aWNlLnF1ZXVlLndyaXRlQnVmZmVyKFxyXG5cdFx0XHRcdGJ1ZmZlcixcclxuXHRcdFx0XHQwLFxyXG5cdFx0XHRcdGFycmF5LFxyXG5cdFx0XHRcdDBcclxuXHRcdFx0KTtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0Y29uc3QgYnl0ZU9mZnNldEZhY3RvciA9IGlzVHlwZWRBcnJheSA/IDEgOiBhcnJheS5CWVRFU19QRVJfRUxFTUVOVDtcclxuXHJcblx0XHRcdGZvciAoIGxldCBpID0gMCwgbCA9IHVwZGF0ZVJhbmdlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHRjb25zdCByYW5nZSA9IHVwZGF0ZVJhbmdlc1sgaSBdO1xyXG5cclxuXHRcdFx0XHRjb25zdCBkYXRhT2Zmc2V0ID0gcmFuZ2Uuc3RhcnQgKiBieXRlT2Zmc2V0RmFjdG9yO1xyXG5cdFx0XHRcdGNvbnN0IHNpemUgPSByYW5nZS5jb3VudCAqIGJ5dGVPZmZzZXRGYWN0b3I7XHJcblxyXG5cdFx0XHRcdGRldmljZS5xdWV1ZS53cml0ZUJ1ZmZlcihcclxuXHRcdFx0XHRcdGJ1ZmZlcixcclxuXHRcdFx0XHRcdDAsXHJcblx0XHRcdFx0XHRhcnJheSxcclxuXHRcdFx0XHRcdGRhdGFPZmZzZXQsXHJcblx0XHRcdFx0XHRzaXplXHJcblx0XHRcdFx0KTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGJ1ZmZlckF0dHJpYnV0ZS5jbGVhclVwZGF0ZVJhbmdlcygpO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHRjcmVhdGVTaGFkZXJWZXJ0ZXhCdWZmZXJzKCByZW5kZXJPYmplY3QgKSB7XHJcblxyXG5cdFx0Y29uc3QgYXR0cmlidXRlcyA9IHJlbmRlck9iamVjdC5nZXRBdHRyaWJ1dGVzKCk7XHJcblx0XHRjb25zdCB2ZXJ0ZXhCdWZmZXJzID0gbmV3IE1hcCgpO1xyXG5cclxuXHRcdGZvciAoIGxldCBzbG90ID0gMDsgc2xvdCA8IGF0dHJpYnV0ZXMubGVuZ3RoOyBzbG90ICsrICkge1xyXG5cclxuXHRcdFx0Y29uc3QgZ2VvbWV0cnlBdHRyaWJ1dGUgPSBhdHRyaWJ1dGVzWyBzbG90IF07XHJcblx0XHRcdGNvbnN0IGJ5dGVzUGVyRWxlbWVudCA9IGdlb21ldHJ5QXR0cmlidXRlLmFycmF5LkJZVEVTX1BFUl9FTEVNRU5UO1xyXG5cdFx0XHRjb25zdCBidWZmZXJBdHRyaWJ1dGUgPSB0aGlzLl9nZXRCdWZmZXJBdHRyaWJ1dGUoIGdlb21ldHJ5QXR0cmlidXRlICk7XHJcblxyXG5cdFx0XHRsZXQgdmVydGV4QnVmZmVyTGF5b3V0ID0gdmVydGV4QnVmZmVycy5nZXQoIGJ1ZmZlckF0dHJpYnV0ZSApO1xyXG5cclxuXHRcdFx0aWYgKCB2ZXJ0ZXhCdWZmZXJMYXlvdXQgPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0bGV0IGFycmF5U3RyaWRlLCBzdGVwTW9kZTtcclxuXHJcblx0XHRcdFx0aWYgKCBnZW9tZXRyeUF0dHJpYnV0ZS5pc0ludGVybGVhdmVkQnVmZmVyQXR0cmlidXRlID09PSB0cnVlICkge1xyXG5cclxuXHRcdFx0XHRcdGFycmF5U3RyaWRlID0gZ2VvbWV0cnlBdHRyaWJ1dGUuZGF0YS5zdHJpZGUgKiBieXRlc1BlckVsZW1lbnQ7XHJcblx0XHRcdFx0XHRzdGVwTW9kZSA9IGdlb21ldHJ5QXR0cmlidXRlLmRhdGEuaXNJbnN0YW5jZWRJbnRlcmxlYXZlZEJ1ZmZlciA/IEdQVUlucHV0U3RlcE1vZGUuSW5zdGFuY2UgOiBHUFVJbnB1dFN0ZXBNb2RlLlZlcnRleDtcclxuXHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHRhcnJheVN0cmlkZSA9IGdlb21ldHJ5QXR0cmlidXRlLml0ZW1TaXplICogYnl0ZXNQZXJFbGVtZW50O1xyXG5cdFx0XHRcdFx0c3RlcE1vZGUgPSBnZW9tZXRyeUF0dHJpYnV0ZS5pc0luc3RhbmNlZEJ1ZmZlckF0dHJpYnV0ZSA/IEdQVUlucHV0U3RlcE1vZGUuSW5zdGFuY2UgOiBHUFVJbnB1dFN0ZXBNb2RlLlZlcnRleDtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHQvLyBwYXRjaCBmb3IgSU5UMTYgYW5kIFVJTlQxNlxyXG5cdFx0XHRcdGlmICggZ2VvbWV0cnlBdHRyaWJ1dGUubm9ybWFsaXplZCA9PT0gZmFsc2UgJiYgKCBnZW9tZXRyeUF0dHJpYnV0ZS5hcnJheS5jb25zdHJ1Y3RvciA9PT0gSW50MTZBcnJheSB8fCBnZW9tZXRyeUF0dHJpYnV0ZS5hcnJheS5jb25zdHJ1Y3RvciA9PT0gVWludDE2QXJyYXkgKSApIHtcclxuXHJcblx0XHRcdFx0XHRhcnJheVN0cmlkZSA9IDQ7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0dmVydGV4QnVmZmVyTGF5b3V0ID0ge1xyXG5cdFx0XHRcdFx0YXJyYXlTdHJpZGUsXHJcblx0XHRcdFx0XHRhdHRyaWJ1dGVzOiBbXSxcclxuXHRcdFx0XHRcdHN0ZXBNb2RlXHJcblx0XHRcdFx0fTtcclxuXHJcblx0XHRcdFx0dmVydGV4QnVmZmVycy5zZXQoIGJ1ZmZlckF0dHJpYnV0ZSwgdmVydGV4QnVmZmVyTGF5b3V0ICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRjb25zdCBmb3JtYXQgPSB0aGlzLl9nZXRWZXJ0ZXhGb3JtYXQoIGdlb21ldHJ5QXR0cmlidXRlICk7XHJcblx0XHRcdGNvbnN0IG9mZnNldCA9ICggZ2VvbWV0cnlBdHRyaWJ1dGUuaXNJbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZSA9PT0gdHJ1ZSApID8gZ2VvbWV0cnlBdHRyaWJ1dGUub2Zmc2V0ICogYnl0ZXNQZXJFbGVtZW50IDogMDtcclxuXHJcblx0XHRcdHZlcnRleEJ1ZmZlckxheW91dC5hdHRyaWJ1dGVzLnB1c2goIHtcclxuXHRcdFx0XHRzaGFkZXJMb2NhdGlvbjogc2xvdCxcclxuXHRcdFx0XHRvZmZzZXQsXHJcblx0XHRcdFx0Zm9ybWF0XHJcblx0XHRcdH0gKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIEFycmF5LmZyb20oIHZlcnRleEJ1ZmZlcnMudmFsdWVzKCkgKTtcclxuXHJcblx0fVxyXG5cclxuXHRkZXN0cm95QXR0cmlidXRlKCBhdHRyaWJ1dGUgKSB7XHJcblxyXG5cdFx0Y29uc3QgYmFja2VuZCA9IHRoaXMuYmFja2VuZDtcclxuXHRcdGNvbnN0IGRhdGEgPSBiYWNrZW5kLmdldCggdGhpcy5fZ2V0QnVmZmVyQXR0cmlidXRlKCBhdHRyaWJ1dGUgKSApO1xyXG5cclxuXHRcdGRhdGEuYnVmZmVyLmRlc3Ryb3koKTtcclxuXHJcblx0XHRiYWNrZW5kLmRlbGV0ZSggYXR0cmlidXRlICk7XHJcblxyXG5cdH1cclxuXHJcblx0YXN5bmMgZ2V0QXJyYXlCdWZmZXJBc3luYyggYXR0cmlidXRlICkge1xyXG5cclxuXHRcdGNvbnN0IGJhY2tlbmQgPSB0aGlzLmJhY2tlbmQ7XHJcblx0XHRjb25zdCBkZXZpY2UgPSBiYWNrZW5kLmRldmljZTtcclxuXHJcblx0XHRjb25zdCBkYXRhID0gYmFja2VuZC5nZXQoIHRoaXMuX2dldEJ1ZmZlckF0dHJpYnV0ZSggYXR0cmlidXRlICkgKTtcclxuXHJcblx0XHRjb25zdCBidWZmZXJHUFUgPSBkYXRhLmJ1ZmZlcjtcclxuXHRcdGNvbnN0IHNpemUgPSBidWZmZXJHUFUuc2l6ZTtcclxuXHJcblx0XHRjb25zdCByZWFkQnVmZmVyR1BVID0gZGV2aWNlLmNyZWF0ZUJ1ZmZlcigge1xyXG5cdFx0XHRsYWJlbDogYXR0cmlidXRlLm5hbWUsXHJcblx0XHRcdHNpemUsXHJcblx0XHRcdHVzYWdlOiBHUFVCdWZmZXJVc2FnZS5DT1BZX0RTVCB8IEdQVUJ1ZmZlclVzYWdlLk1BUF9SRUFEXHJcblx0XHR9ICk7XHJcblxyXG5cclxuXHRcdGNvbnN0IGNtZEVuY29kZXIgPSBkZXZpY2UuY3JlYXRlQ29tbWFuZEVuY29kZXIoIHt9ICk7XHJcblxyXG5cdFx0Y21kRW5jb2Rlci5jb3B5QnVmZmVyVG9CdWZmZXIoXHJcblx0XHRcdGJ1ZmZlckdQVSxcclxuXHRcdFx0MCxcclxuXHRcdFx0cmVhZEJ1ZmZlckdQVSxcclxuXHRcdFx0MCxcclxuXHRcdFx0c2l6ZVxyXG5cdFx0KTtcclxuXHJcblx0XHRyZWFkQnVmZmVyR1BVLnVubWFwKCk7XHJcblxyXG5cdFx0Y29uc3QgZ3B1Q29tbWFuZHMgPSBjbWRFbmNvZGVyLmZpbmlzaCgpO1xyXG5cdFx0ZGV2aWNlLnF1ZXVlLnN1Ym1pdCggWyBncHVDb21tYW5kcyBdICk7XHJcblxyXG5cdFx0YXdhaXQgcmVhZEJ1ZmZlckdQVS5tYXBBc3luYyggR1BVTWFwTW9kZS5SRUFEICk7XHJcblxyXG5cdFx0Y29uc3QgYXJyYXlCdWZmZXIgPSByZWFkQnVmZmVyR1BVLmdldE1hcHBlZFJhbmdlKCk7XHJcblxyXG5cdFx0cmV0dXJuIGFycmF5QnVmZmVyO1xyXG5cclxuXHR9XHJcblxyXG5cdF9nZXRWZXJ0ZXhGb3JtYXQoIGdlb21ldHJ5QXR0cmlidXRlICkge1xyXG5cclxuXHRcdGNvbnN0IHsgaXRlbVNpemUsIG5vcm1hbGl6ZWQgfSA9IGdlb21ldHJ5QXR0cmlidXRlO1xyXG5cdFx0Y29uc3QgQXJyYXlUeXBlID0gZ2VvbWV0cnlBdHRyaWJ1dGUuYXJyYXkuY29uc3RydWN0b3I7XHJcblx0XHRjb25zdCBBdHRyaWJ1dGVUeXBlID0gZ2VvbWV0cnlBdHRyaWJ1dGUuY29uc3RydWN0b3I7XHJcblxyXG5cdFx0bGV0IGZvcm1hdDtcclxuXHJcblx0XHRpZiAoIGl0ZW1TaXplID09PSAxICkge1xyXG5cclxuXHRcdFx0Zm9ybWF0ID0gdHlwZUFycmF5c1RvVmVydGV4Rm9ybWF0UHJlZml4Rm9ySXRlbVNpemUxLmdldCggQXJyYXlUeXBlICk7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdGNvbnN0IHByZWZpeE9wdGlvbnMgPSB0eXBlZEF0dHJpYnV0ZVRvVmVydGV4Rm9ybWF0UHJlZml4LmdldCggQXR0cmlidXRlVHlwZSApIHx8IHR5cGVkQXJyYXlzVG9WZXJ0ZXhGb3JtYXRQcmVmaXguZ2V0KCBBcnJheVR5cGUgKTtcclxuXHRcdFx0Y29uc3QgcHJlZml4ID0gcHJlZml4T3B0aW9uc1sgbm9ybWFsaXplZCA/IDEgOiAwIF07XHJcblxyXG5cdFx0XHRpZiAoIHByZWZpeCApIHtcclxuXHJcblx0XHRcdFx0Y29uc3QgYnl0ZXNQZXJVbml0ID0gQXJyYXlUeXBlLkJZVEVTX1BFUl9FTEVNRU5UICogaXRlbVNpemU7XHJcblx0XHRcdFx0Y29uc3QgcGFkZGVkQnl0ZXNQZXJVbml0ID0gTWF0aC5mbG9vciggKCBieXRlc1BlclVuaXQgKyAzICkgLyA0ICkgKiA0O1xyXG5cdFx0XHRcdGNvbnN0IHBhZGRlZEl0ZW1TaXplID0gcGFkZGVkQnl0ZXNQZXJVbml0IC8gQXJyYXlUeXBlLkJZVEVTX1BFUl9FTEVNRU5UO1xyXG5cclxuXHRcdFx0XHRpZiAoIHBhZGRlZEl0ZW1TaXplICUgMSApIHtcclxuXHJcblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoICdUSFJFRS5XZWJHUFVBdHRyaWJ1dGVVdGlsczogQmFkIHZlcnRleCBmb3JtYXQgaXRlbSBzaXplLicgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRmb3JtYXQgPSBgJHtwcmVmaXh9eCR7cGFkZGVkSXRlbVNpemV9YDtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCAhIGZvcm1hdCApIHtcclxuXHJcblx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5XZWJHUFVBdHRyaWJ1dGVVdGlsczogVmVydGV4IGZvcm1hdCBub3Qgc3VwcG9ydGVkIHlldC4nICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBmb3JtYXQ7XHJcblxyXG5cdH1cclxuXHJcblx0X2lzVHlwZWRBcnJheSggYXJyYXkgKSB7XHJcblxyXG5cdFx0cmV0dXJuIEFycmF5QnVmZmVyLmlzVmlldyggYXJyYXkgKSAmJiAhICggYXJyYXkgaW5zdGFuY2VvZiBEYXRhVmlldyApO1xyXG5cclxuXHR9XHJcblxyXG5cdF9nZXRCdWZmZXJBdHRyaWJ1dGUoIGF0dHJpYnV0ZSApIHtcclxuXHJcblx0XHRpZiAoIGF0dHJpYnV0ZS5pc0ludGVybGVhdmVkQnVmZmVyQXR0cmlidXRlICkgYXR0cmlidXRlID0gYXR0cmlidXRlLmRhdGE7XHJcblxyXG5cdFx0cmV0dXJuIGF0dHJpYnV0ZTtcclxuXHJcblx0fVxyXG5cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgV2ViR1BVQXR0cmlidXRlVXRpbHM7XHJcbiIsImltcG9ydCB7XHJcblx0R1BVVGV4dHVyZUFzcGVjdCwgR1BVVGV4dHVyZVZpZXdEaW1lbnNpb24sIEdQVVRleHR1cmVTYW1wbGVUeXBlLCBHUFVCdWZmZXJCaW5kaW5nVHlwZSwgR1BVU3RvcmFnZVRleHR1cmVBY2Nlc3NcclxufSBmcm9tICcuL1dlYkdQVUNvbnN0YW50cy5qcyc7XHJcblxyXG5pbXBvcnQgeyBGbG9hdFR5cGUsIEludFR5cGUsIFVuc2lnbmVkSW50VHlwZSB9IGZyb20gJy4uLy4uLy4uL2NvbnN0YW50cy5qcyc7XHJcbmltcG9ydCB7IE5vZGVBY2Nlc3MgfSBmcm9tICcuLi8uLi8uLi9ub2Rlcy9jb3JlL2NvbnN0YW50cy5qcyc7XHJcblxyXG5jbGFzcyBXZWJHUFVCaW5kaW5nVXRpbHMge1xyXG5cclxuXHRjb25zdHJ1Y3RvciggYmFja2VuZCApIHtcclxuXHJcblx0XHR0aGlzLmJhY2tlbmQgPSBiYWNrZW5kO1xyXG5cdFx0dGhpcy5iaW5kR3JvdXBMYXlvdXRDYWNoZSA9IG5ldyBXZWFrTWFwKCk7XHJcblxyXG5cdH1cclxuXHJcblx0Y3JlYXRlQmluZGluZ3NMYXlvdXQoIGJpbmRHcm91cCApIHtcclxuXHJcblx0XHRjb25zdCBiYWNrZW5kID0gdGhpcy5iYWNrZW5kO1xyXG5cdFx0Y29uc3QgZGV2aWNlID0gYmFja2VuZC5kZXZpY2U7XHJcblxyXG5cdFx0Y29uc3QgZW50cmllcyA9IFtdO1xyXG5cclxuXHRcdGxldCBpbmRleCA9IDA7XHJcblxyXG5cdFx0Zm9yICggY29uc3QgYmluZGluZyBvZiBiaW5kR3JvdXAuYmluZGluZ3MgKSB7XHJcblxyXG5cdFx0XHRjb25zdCBiaW5kaW5nR1BVID0ge1xyXG5cdFx0XHRcdGJpbmRpbmc6IGluZGV4ICsrLFxyXG5cdFx0XHRcdHZpc2liaWxpdHk6IGJpbmRpbmcudmlzaWJpbGl0eVxyXG5cdFx0XHR9O1xyXG5cclxuXHRcdFx0aWYgKCBiaW5kaW5nLmlzVW5pZm9ybUJ1ZmZlciB8fCBiaW5kaW5nLmlzU3RvcmFnZUJ1ZmZlciApIHtcclxuXHJcblx0XHRcdFx0Y29uc3QgYnVmZmVyID0ge307IC8vIEdQVUJ1ZmZlckJpbmRpbmdMYXlvdXRcclxuXHJcblx0XHRcdFx0aWYgKCBiaW5kaW5nLmlzU3RvcmFnZUJ1ZmZlciApIHtcclxuXHJcblx0XHRcdFx0XHRpZiAoIGJpbmRpbmcudmlzaWJpbGl0eSAmIDQgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHQvLyBjb21wdXRlXHJcblxyXG5cdFx0XHRcdFx0XHRpZiAoIGJpbmRpbmcuYWNjZXNzID09PSBOb2RlQWNjZXNzLlJFQURfV1JJVEUgfHwgYmluZGluZy5hY2Nlc3MgPT09IE5vZGVBY2Nlc3MuV1JJVEVfT05MWSApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0YnVmZmVyLnR5cGUgPSBHUFVCdWZmZXJCaW5kaW5nVHlwZS5TdG9yYWdlO1xyXG5cclxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0YnVmZmVyLnR5cGUgPSBHUFVCdWZmZXJCaW5kaW5nVHlwZS5SZWFkT25seVN0b3JhZ2U7XHJcblxyXG5cdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHRcdGJ1ZmZlci50eXBlID0gR1BVQnVmZmVyQmluZGluZ1R5cGUuUmVhZE9ubHlTdG9yYWdlO1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRiaW5kaW5nR1BVLmJ1ZmZlciA9IGJ1ZmZlcjtcclxuXHJcblx0XHRcdH0gZWxzZSBpZiAoIGJpbmRpbmcuaXNTYW1wbGVyICkge1xyXG5cclxuXHRcdFx0XHRjb25zdCBzYW1wbGVyID0ge307IC8vIEdQVVNhbXBsZXJCaW5kaW5nTGF5b3V0XHJcblxyXG5cdFx0XHRcdGlmICggYmluZGluZy50ZXh0dXJlLmlzRGVwdGhUZXh0dXJlICkge1xyXG5cclxuXHRcdFx0XHRcdGlmICggYmluZGluZy50ZXh0dXJlLmNvbXBhcmVGdW5jdGlvbiAhPT0gbnVsbCApIHtcclxuXHJcblx0XHRcdFx0XHRcdHNhbXBsZXIudHlwZSA9ICdjb21wYXJpc29uJztcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0YmluZGluZ0dQVS5zYW1wbGVyID0gc2FtcGxlcjtcclxuXHJcblx0XHRcdH0gZWxzZSBpZiAoIGJpbmRpbmcuaXNTYW1wbGVkVGV4dHVyZSAmJiBiaW5kaW5nLnRleHR1cmUuaXNWaWRlb1RleHR1cmUgKSB7XHJcblxyXG5cdFx0XHRcdGJpbmRpbmdHUFUuZXh0ZXJuYWxUZXh0dXJlID0ge307IC8vIEdQVUV4dGVybmFsVGV4dHVyZUJpbmRpbmdMYXlvdXRcclxuXHJcblx0XHRcdH0gZWxzZSBpZiAoIGJpbmRpbmcuaXNTYW1wbGVkVGV4dHVyZSAmJiBiaW5kaW5nLnN0b3JlICkge1xyXG5cclxuXHRcdFx0XHRjb25zdCBzdG9yYWdlVGV4dHVyZSA9IHt9OyAvLyBHUFVTdG9yYWdlVGV4dHVyZUJpbmRpbmdMYXlvdXRcclxuXHRcdFx0XHRzdG9yYWdlVGV4dHVyZS5mb3JtYXQgPSB0aGlzLmJhY2tlbmQuZ2V0KCBiaW5kaW5nLnRleHR1cmUgKS50ZXh0dXJlLmZvcm1hdDtcclxuXHJcblx0XHRcdFx0Y29uc3QgYWNjZXNzID0gYmluZGluZy5hY2Nlc3M7XHJcblxyXG5cdFx0XHRcdGlmICggYWNjZXNzID09PSBOb2RlQWNjZXNzLlJFQURfV1JJVEUgKSB7XHJcblxyXG5cdFx0XHRcdFx0c3RvcmFnZVRleHR1cmUuYWNjZXNzID0gR1BVU3RvcmFnZVRleHR1cmVBY2Nlc3MuUmVhZFdyaXRlO1xyXG5cclxuXHRcdFx0XHR9IGVsc2UgaWYgKCBhY2Nlc3MgPT09IE5vZGVBY2Nlc3MuV1JJVEVfT05MWSApIHtcclxuXHJcblx0XHRcdFx0XHRzdG9yYWdlVGV4dHVyZS5hY2Nlc3MgPSBHUFVTdG9yYWdlVGV4dHVyZUFjY2Vzcy5Xcml0ZU9ubHk7XHJcblxyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0c3RvcmFnZVRleHR1cmUuYWNjZXNzID0gR1BVU3RvcmFnZVRleHR1cmVBY2Nlc3MuUmVhZE9ubHk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0YmluZGluZ0dQVS5zdG9yYWdlVGV4dHVyZSA9IHN0b3JhZ2VUZXh0dXJlO1xyXG5cclxuXHRcdFx0fSBlbHNlIGlmICggYmluZGluZy5pc1NhbXBsZWRUZXh0dXJlICkge1xyXG5cclxuXHRcdFx0XHRjb25zdCB0ZXh0dXJlID0ge307IC8vIEdQVVRleHR1cmVCaW5kaW5nTGF5b3V0XHJcblxyXG5cdFx0XHRcdGNvbnN0IHsgcHJpbWFyeVNhbXBsZXMgfSA9IGJhY2tlbmQudXRpbHMuZ2V0VGV4dHVyZVNhbXBsZURhdGEoIGJpbmRpbmcudGV4dHVyZSApO1xyXG5cclxuXHRcdFx0XHRpZiAoIHByaW1hcnlTYW1wbGVzID4gMSApIHtcclxuXHJcblx0XHRcdFx0XHR0ZXh0dXJlLm11bHRpc2FtcGxlZCA9IHRydWU7XHJcblxyXG5cdFx0XHRcdFx0aWYgKCAhIGJpbmRpbmcudGV4dHVyZS5pc0RlcHRoVGV4dHVyZSApIHtcclxuXHJcblx0XHRcdFx0XHRcdHRleHR1cmUuc2FtcGxlVHlwZSA9IEdQVVRleHR1cmVTYW1wbGVUeXBlLlVuZmlsdGVyYWJsZUZsb2F0O1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRpZiAoIGJpbmRpbmcudGV4dHVyZS5pc0RlcHRoVGV4dHVyZSApIHtcclxuXHJcblx0XHRcdFx0XHR0ZXh0dXJlLnNhbXBsZVR5cGUgPSBHUFVUZXh0dXJlU2FtcGxlVHlwZS5EZXB0aDtcclxuXHJcblx0XHRcdFx0fSBlbHNlIGlmICggYmluZGluZy50ZXh0dXJlLmlzRGF0YVRleHR1cmUgfHwgYmluZGluZy50ZXh0dXJlLmlzRGF0YUFycmF5VGV4dHVyZSB8fCBiaW5kaW5nLnRleHR1cmUuaXNEYXRhM0RUZXh0dXJlICkge1xyXG5cclxuXHRcdFx0XHRcdGNvbnN0IHR5cGUgPSBiaW5kaW5nLnRleHR1cmUudHlwZTtcclxuXHJcblx0XHRcdFx0XHRpZiAoIHR5cGUgPT09IEludFR5cGUgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHR0ZXh0dXJlLnNhbXBsZVR5cGUgPSBHUFVUZXh0dXJlU2FtcGxlVHlwZS5TSW50O1xyXG5cclxuXHRcdFx0XHRcdH0gZWxzZSBpZiAoIHR5cGUgPT09IFVuc2lnbmVkSW50VHlwZSApIHtcclxuXHJcblx0XHRcdFx0XHRcdHRleHR1cmUuc2FtcGxlVHlwZSA9IEdQVVRleHR1cmVTYW1wbGVUeXBlLlVJbnQ7XHJcblxyXG5cdFx0XHRcdFx0fSBlbHNlIGlmICggdHlwZSA9PT0gRmxvYXRUeXBlICkge1xyXG5cclxuXHRcdFx0XHRcdFx0aWYgKCB0aGlzLmJhY2tlbmQuaGFzRmVhdHVyZSggJ2Zsb2F0MzItZmlsdGVyYWJsZScgKSApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0dGV4dHVyZS5zYW1wbGVUeXBlID0gR1BVVGV4dHVyZVNhbXBsZVR5cGUuRmxvYXQ7XHJcblxyXG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdFx0XHR0ZXh0dXJlLnNhbXBsZVR5cGUgPSBHUFVUZXh0dXJlU2FtcGxlVHlwZS5VbmZpbHRlcmFibGVGbG9hdDtcclxuXHJcblx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0aWYgKCBiaW5kaW5nLmlzU2FtcGxlZEN1YmVUZXh0dXJlICkge1xyXG5cclxuXHRcdFx0XHRcdHRleHR1cmUudmlld0RpbWVuc2lvbiA9IEdQVVRleHR1cmVWaWV3RGltZW5zaW9uLkN1YmU7XHJcblxyXG5cdFx0XHRcdH0gZWxzZSBpZiAoIGJpbmRpbmcudGV4dHVyZS5pc0RhdGFBcnJheVRleHR1cmUgfHwgYmluZGluZy50ZXh0dXJlLmlzQ29tcHJlc3NlZEFycmF5VGV4dHVyZSApIHtcclxuXHJcblx0XHRcdFx0XHR0ZXh0dXJlLnZpZXdEaW1lbnNpb24gPSBHUFVUZXh0dXJlVmlld0RpbWVuc2lvbi5Ud29EQXJyYXk7XHJcblxyXG5cdFx0XHRcdH0gZWxzZSBpZiAoIGJpbmRpbmcuaXNTYW1wbGVkVGV4dHVyZTNEICkge1xyXG5cclxuXHRcdFx0XHRcdHRleHR1cmUudmlld0RpbWVuc2lvbiA9IEdQVVRleHR1cmVWaWV3RGltZW5zaW9uLlRocmVlRDtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRiaW5kaW5nR1BVLnRleHR1cmUgPSB0ZXh0dXJlO1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0Y29uc29sZS5lcnJvciggYFdlYkdQVUJpbmRpbmdVdGlsczogVW5zdXBwb3J0ZWQgYmluZGluZyBcIiR7IGJpbmRpbmcgfVwiLmAgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGVudHJpZXMucHVzaCggYmluZGluZ0dQVSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gZGV2aWNlLmNyZWF0ZUJpbmRHcm91cExheW91dCggeyBlbnRyaWVzIH0gKTtcclxuXHJcblx0fVxyXG5cclxuXHRjcmVhdGVCaW5kaW5ncyggYmluZEdyb3VwLCBiaW5kaW5ncywgY2FjaGVJbmRleCwgdmVyc2lvbiA9IDAgKSB7XHJcblxyXG5cdFx0Y29uc3QgeyBiYWNrZW5kLCBiaW5kR3JvdXBMYXlvdXRDYWNoZSB9ID0gdGhpcztcclxuXHRcdGNvbnN0IGJpbmRpbmdzRGF0YSA9IGJhY2tlbmQuZ2V0KCBiaW5kR3JvdXAgKTtcclxuXHJcblx0XHQvLyBzZXR1cCAoc3RhdGljKSBiaW5kaW5nIGxheW91dCBhbmQgKGR5bmFtaWMpIGJpbmRpbmcgZ3JvdXBcclxuXHJcblx0XHRsZXQgYmluZExheW91dEdQVSA9IGJpbmRHcm91cExheW91dENhY2hlLmdldCggYmluZEdyb3VwLmJpbmRpbmdzUmVmZXJlbmNlICk7XHJcblxyXG5cdFx0aWYgKCBiaW5kTGF5b3V0R1BVID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRiaW5kTGF5b3V0R1BVID0gdGhpcy5jcmVhdGVCaW5kaW5nc0xheW91dCggYmluZEdyb3VwICk7XHJcblx0XHRcdGJpbmRHcm91cExheW91dENhY2hlLnNldCggYmluZEdyb3VwLmJpbmRpbmdzUmVmZXJlbmNlLCBiaW5kTGF5b3V0R1BVICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGxldCBiaW5kR3JvdXBHUFU7XHJcblxyXG5cdFx0aWYgKCBjYWNoZUluZGV4ID4gMCApIHtcclxuXHJcblx0XHRcdGlmICggYmluZGluZ3NEYXRhLmdyb3VwcyA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRiaW5kaW5nc0RhdGEuZ3JvdXBzID0gW107XHJcblx0XHRcdFx0YmluZGluZ3NEYXRhLnZlcnNpb25zID0gW107XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoIGJpbmRpbmdzRGF0YS52ZXJzaW9uc1sgY2FjaGVJbmRleCBdID09PSB2ZXJzaW9uICkge1xyXG5cclxuXHRcdFx0XHRiaW5kR3JvdXBHUFUgPSBiaW5kaW5nc0RhdGEuZ3JvdXBzWyBjYWNoZUluZGV4IF07XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggYmluZEdyb3VwR1BVID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRiaW5kR3JvdXBHUFUgPSB0aGlzLmNyZWF0ZUJpbmRHcm91cCggYmluZEdyb3VwLCBiaW5kTGF5b3V0R1BVICk7XHJcblxyXG5cdFx0XHRpZiAoIGNhY2hlSW5kZXggPiAwICkge1xyXG5cclxuXHRcdFx0XHRiaW5kaW5nc0RhdGEuZ3JvdXBzWyBjYWNoZUluZGV4IF0gPSBiaW5kR3JvdXBHUFU7XHJcblx0XHRcdFx0YmluZGluZ3NEYXRhLnZlcnNpb25zWyBjYWNoZUluZGV4IF0gPSB2ZXJzaW9uO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRiaW5kaW5nc0RhdGEuZ3JvdXAgPSBiaW5kR3JvdXBHUFU7XHJcblx0XHRiaW5kaW5nc0RhdGEubGF5b3V0ID0gYmluZExheW91dEdQVTtcclxuXHJcblx0fVxyXG5cclxuXHR1cGRhdGVCaW5kaW5nKCBiaW5kaW5nICkge1xyXG5cclxuXHRcdGNvbnN0IGJhY2tlbmQgPSB0aGlzLmJhY2tlbmQ7XHJcblx0XHRjb25zdCBkZXZpY2UgPSBiYWNrZW5kLmRldmljZTtcclxuXHJcblx0XHRjb25zdCBidWZmZXIgPSBiaW5kaW5nLmJ1ZmZlcjtcclxuXHRcdGNvbnN0IGJ1ZmZlckdQVSA9IGJhY2tlbmQuZ2V0KCBiaW5kaW5nICkuYnVmZmVyO1xyXG5cclxuXHRcdGRldmljZS5xdWV1ZS53cml0ZUJ1ZmZlciggYnVmZmVyR1BVLCAwLCBidWZmZXIsIDAgKTtcclxuXHJcblx0fVxyXG5cclxuXHRjcmVhdGVCaW5kR3JvdXAoIGJpbmRHcm91cCwgbGF5b3V0R1BVICkge1xyXG5cclxuXHRcdGNvbnN0IGJhY2tlbmQgPSB0aGlzLmJhY2tlbmQ7XHJcblx0XHRjb25zdCBkZXZpY2UgPSBiYWNrZW5kLmRldmljZTtcclxuXHJcblx0XHRsZXQgYmluZGluZ1BvaW50ID0gMDtcclxuXHRcdGNvbnN0IGVudHJpZXNHUFUgPSBbXTtcclxuXHJcblx0XHRmb3IgKCBjb25zdCBiaW5kaW5nIG9mIGJpbmRHcm91cC5iaW5kaW5ncyApIHtcclxuXHJcblx0XHRcdGlmICggYmluZGluZy5pc1VuaWZvcm1CdWZmZXIgKSB7XHJcblxyXG5cdFx0XHRcdGNvbnN0IGJpbmRpbmdEYXRhID0gYmFja2VuZC5nZXQoIGJpbmRpbmcgKTtcclxuXHJcblx0XHRcdFx0aWYgKCBiaW5kaW5nRGF0YS5idWZmZXIgPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0XHRjb25zdCBieXRlTGVuZ3RoID0gYmluZGluZy5ieXRlTGVuZ3RoO1xyXG5cclxuXHRcdFx0XHRcdGNvbnN0IHVzYWdlID0gR1BVQnVmZmVyVXNhZ2UuVU5JRk9STSB8IEdQVUJ1ZmZlclVzYWdlLkNPUFlfRFNUO1xyXG5cclxuXHRcdFx0XHRcdGNvbnN0IGJ1ZmZlckdQVSA9IGRldmljZS5jcmVhdGVCdWZmZXIoIHtcclxuXHRcdFx0XHRcdFx0bGFiZWw6ICdiaW5kaW5nQnVmZmVyXycgKyBiaW5kaW5nLm5hbWUsXHJcblx0XHRcdFx0XHRcdHNpemU6IGJ5dGVMZW5ndGgsXHJcblx0XHRcdFx0XHRcdHVzYWdlOiB1c2FnZVxyXG5cdFx0XHRcdFx0fSApO1xyXG5cclxuXHRcdFx0XHRcdGJpbmRpbmdEYXRhLmJ1ZmZlciA9IGJ1ZmZlckdQVTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRlbnRyaWVzR1BVLnB1c2goIHsgYmluZGluZzogYmluZGluZ1BvaW50LCByZXNvdXJjZTogeyBidWZmZXI6IGJpbmRpbmdEYXRhLmJ1ZmZlciB9IH0gKTtcclxuXHJcblx0XHRcdH0gZWxzZSBpZiAoIGJpbmRpbmcuaXNTdG9yYWdlQnVmZmVyICkge1xyXG5cclxuXHRcdFx0XHRjb25zdCBiaW5kaW5nRGF0YSA9IGJhY2tlbmQuZ2V0KCBiaW5kaW5nICk7XHJcblxyXG5cdFx0XHRcdGlmICggYmluZGluZ0RhdGEuYnVmZmVyID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdFx0Y29uc3QgYXR0cmlidXRlID0gYmluZGluZy5hdHRyaWJ1dGU7XHJcblx0XHRcdFx0XHQvL2NvbnN0IHVzYWdlID0gR1BVQnVmZmVyVXNhZ2UuU1RPUkFHRSB8IEdQVUJ1ZmZlclVzYWdlLlZFUlRFWCB8IC8qR1BVQnVmZmVyVXNhZ2UuQ09QWV9TUkMgfCovIEdQVUJ1ZmZlclVzYWdlLkNPUFlfRFNUO1xyXG5cclxuXHRcdFx0XHRcdC8vYmFja2VuZC5hdHRyaWJ1dGVVdGlscy5jcmVhdGVBdHRyaWJ1dGUoIGF0dHJpYnV0ZSwgdXNhZ2UgKTsgLy8gQFRPRE86IE1vdmUgaXQgdG8gdW5pdmVyc2FsIHJlbmRlcmVyXHJcblxyXG5cdFx0XHRcdFx0YmluZGluZ0RhdGEuYnVmZmVyID0gYmFja2VuZC5nZXQoIGF0dHJpYnV0ZSApLmJ1ZmZlcjtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRlbnRyaWVzR1BVLnB1c2goIHsgYmluZGluZzogYmluZGluZ1BvaW50LCByZXNvdXJjZTogeyBidWZmZXI6IGJpbmRpbmdEYXRhLmJ1ZmZlciB9IH0gKTtcclxuXHJcblx0XHRcdH0gZWxzZSBpZiAoIGJpbmRpbmcuaXNTYW1wbGVyICkge1xyXG5cclxuXHRcdFx0XHRjb25zdCB0ZXh0dXJlR1BVID0gYmFja2VuZC5nZXQoIGJpbmRpbmcudGV4dHVyZSApO1xyXG5cclxuXHRcdFx0XHRlbnRyaWVzR1BVLnB1c2goIHsgYmluZGluZzogYmluZGluZ1BvaW50LCByZXNvdXJjZTogdGV4dHVyZUdQVS5zYW1wbGVyIH0gKTtcclxuXHJcblx0XHRcdH0gZWxzZSBpZiAoIGJpbmRpbmcuaXNTYW1wbGVkVGV4dHVyZSApIHtcclxuXHJcblx0XHRcdFx0Y29uc3QgdGV4dHVyZURhdGEgPSBiYWNrZW5kLmdldCggYmluZGluZy50ZXh0dXJlICk7XHJcblxyXG5cdFx0XHRcdGxldCByZXNvdXJjZUdQVTtcclxuXHJcblx0XHRcdFx0aWYgKCB0ZXh0dXJlRGF0YS5leHRlcm5hbFRleHR1cmUgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0XHRyZXNvdXJjZUdQVSA9IGRldmljZS5pbXBvcnRFeHRlcm5hbFRleHR1cmUoIHsgc291cmNlOiB0ZXh0dXJlRGF0YS5leHRlcm5hbFRleHR1cmUgfSApO1xyXG5cclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdGNvbnN0IG1pcExldmVsQ291bnQgPSBiaW5kaW5nLnN0b3JlID8gMSA6IHRleHR1cmVEYXRhLnRleHR1cmUubWlwTGV2ZWxDb3VudDtcclxuXHRcdFx0XHRcdGNvbnN0IHByb3BlcnR5TmFtZSA9IGB2aWV3LSR7IHRleHR1cmVEYXRhLnRleHR1cmUud2lkdGggfS0keyB0ZXh0dXJlRGF0YS50ZXh0dXJlLmhlaWdodCB9LSR7IG1pcExldmVsQ291bnQgfWA7XHJcblxyXG5cdFx0XHRcdFx0cmVzb3VyY2VHUFUgPSB0ZXh0dXJlRGF0YVsgcHJvcGVydHlOYW1lIF07XHJcblxyXG5cdFx0XHRcdFx0aWYgKCByZXNvdXJjZUdQVSA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRcdFx0Y29uc3QgYXNwZWN0R1BVID0gR1BVVGV4dHVyZUFzcGVjdC5BbGw7XHJcblxyXG5cdFx0XHRcdFx0XHRsZXQgZGltZW5zaW9uVmlld0dQVTtcclxuXHJcblx0XHRcdFx0XHRcdGlmICggYmluZGluZy5pc1NhbXBsZWRDdWJlVGV4dHVyZSApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0ZGltZW5zaW9uVmlld0dQVSA9IEdQVVRleHR1cmVWaWV3RGltZW5zaW9uLkN1YmU7XHJcblxyXG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKCBiaW5kaW5nLmlzU2FtcGxlZFRleHR1cmUzRCApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0ZGltZW5zaW9uVmlld0dQVSA9IEdQVVRleHR1cmVWaWV3RGltZW5zaW9uLlRocmVlRDtcclxuXHJcblx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoIGJpbmRpbmcudGV4dHVyZS5pc0RhdGFBcnJheVRleHR1cmUgfHwgYmluZGluZy50ZXh0dXJlLmlzQ29tcHJlc3NlZEFycmF5VGV4dHVyZSApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0ZGltZW5zaW9uVmlld0dQVSA9IEdQVVRleHR1cmVWaWV3RGltZW5zaW9uLlR3b0RBcnJheTtcclxuXHJcblx0XHRcdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdGRpbWVuc2lvblZpZXdHUFUgPSBHUFVUZXh0dXJlVmlld0RpbWVuc2lvbi5Ud29EO1xyXG5cclxuXHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdFx0cmVzb3VyY2VHUFUgPSB0ZXh0dXJlRGF0YVsgcHJvcGVydHlOYW1lIF0gPSB0ZXh0dXJlRGF0YS50ZXh0dXJlLmNyZWF0ZVZpZXcoIHsgYXNwZWN0OiBhc3BlY3RHUFUsIGRpbWVuc2lvbjogZGltZW5zaW9uVmlld0dQVSwgbWlwTGV2ZWxDb3VudCB9ICk7XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGVudHJpZXNHUFUucHVzaCggeyBiaW5kaW5nOiBiaW5kaW5nUG9pbnQsIHJlc291cmNlOiByZXNvdXJjZUdQVSB9ICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRiaW5kaW5nUG9pbnQgKys7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBkZXZpY2UuY3JlYXRlQmluZEdyb3VwKCB7XHJcblx0XHRcdGxhYmVsOiAnYmluZEdyb3VwXycgKyBiaW5kR3JvdXAubmFtZSxcclxuXHRcdFx0bGF5b3V0OiBsYXlvdXRHUFUsXHJcblx0XHRcdGVudHJpZXM6IGVudHJpZXNHUFVcclxuXHRcdH0gKTtcclxuXHJcblx0fVxyXG5cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgV2ViR1BVQmluZGluZ1V0aWxzO1xyXG4iLCJpbXBvcnQgeyBCbGVuZENvbG9yRmFjdG9yLCBPbmVNaW51c0JsZW5kQ29sb3JGYWN0b3IsIH0gZnJvbSAnLi4vLi4vY29tbW9uL0NvbnN0YW50cy5qcyc7XHJcblxyXG5pbXBvcnQge1xyXG5cdEdQVUZyb250RmFjZSwgR1BVQ3VsbE1vZGUsIEdQVUNvbG9yV3JpdGVGbGFncywgR1BVQ29tcGFyZUZ1bmN0aW9uLCBHUFVCbGVuZEZhY3RvciwgR1BVQmxlbmRPcGVyYXRpb24sIEdQVUluZGV4Rm9ybWF0LCBHUFVTdGVuY2lsT3BlcmF0aW9uXHJcbn0gZnJvbSAnLi9XZWJHUFVDb25zdGFudHMuanMnO1xyXG5cclxuaW1wb3J0IHtcclxuXHRGcm9udFNpZGUsIEJhY2tTaWRlLCBEb3VibGVTaWRlLFxyXG5cdE5ldmVyRGVwdGgsIEFsd2F5c0RlcHRoLCBMZXNzRGVwdGgsIExlc3NFcXVhbERlcHRoLCBFcXVhbERlcHRoLCBHcmVhdGVyRXF1YWxEZXB0aCwgR3JlYXRlckRlcHRoLCBOb3RFcXVhbERlcHRoLFxyXG5cdE5vQmxlbmRpbmcsIE5vcm1hbEJsZW5kaW5nLCBBZGRpdGl2ZUJsZW5kaW5nLCBTdWJ0cmFjdGl2ZUJsZW5kaW5nLCBNdWx0aXBseUJsZW5kaW5nLCBDdXN0b21CbGVuZGluZyxcclxuXHRaZXJvRmFjdG9yLCBPbmVGYWN0b3IsIFNyY0NvbG9yRmFjdG9yLCBPbmVNaW51c1NyY0NvbG9yRmFjdG9yLCBTcmNBbHBoYUZhY3RvciwgT25lTWludXNTcmNBbHBoYUZhY3RvciwgRHN0Q29sb3JGYWN0b3IsXHJcblx0T25lTWludXNEc3RDb2xvckZhY3RvciwgRHN0QWxwaGFGYWN0b3IsIE9uZU1pbnVzRHN0QWxwaGFGYWN0b3IsIFNyY0FscGhhU2F0dXJhdGVGYWN0b3IsXHJcblx0QWRkRXF1YXRpb24sIFN1YnRyYWN0RXF1YXRpb24sIFJldmVyc2VTdWJ0cmFjdEVxdWF0aW9uLCBNaW5FcXVhdGlvbiwgTWF4RXF1YXRpb24sXHJcblx0S2VlcFN0ZW5jaWxPcCwgWmVyb1N0ZW5jaWxPcCwgUmVwbGFjZVN0ZW5jaWxPcCwgSW52ZXJ0U3RlbmNpbE9wLCBJbmNyZW1lbnRTdGVuY2lsT3AsIERlY3JlbWVudFN0ZW5jaWxPcCwgSW5jcmVtZW50V3JhcFN0ZW5jaWxPcCwgRGVjcmVtZW50V3JhcFN0ZW5jaWxPcCxcclxuXHROZXZlclN0ZW5jaWxGdW5jLCBBbHdheXNTdGVuY2lsRnVuYywgTGVzc1N0ZW5jaWxGdW5jLCBMZXNzRXF1YWxTdGVuY2lsRnVuYywgRXF1YWxTdGVuY2lsRnVuYywgR3JlYXRlckVxdWFsU3RlbmNpbEZ1bmMsIEdyZWF0ZXJTdGVuY2lsRnVuYywgTm90RXF1YWxTdGVuY2lsRnVuY1xyXG59IGZyb20gJy4uLy4uLy4uL2NvbnN0YW50cy5qcyc7XHJcblxyXG5jbGFzcyBXZWJHUFVQaXBlbGluZVV0aWxzIHtcclxuXHJcblx0Y29uc3RydWN0b3IoIGJhY2tlbmQgKSB7XHJcblxyXG5cdFx0dGhpcy5iYWNrZW5kID0gYmFja2VuZDtcclxuXHJcblx0fVxyXG5cclxuXHRfZ2V0U2FtcGxlQ291bnQoIHJlbmRlck9iamVjdENvbnRleHQgKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuYmFja2VuZC51dGlscy5nZXRTYW1wbGVDb3VudFJlbmRlckNvbnRleHQoIHJlbmRlck9iamVjdENvbnRleHQgKTtcclxuXHJcblx0fVxyXG5cclxuXHRjcmVhdGVSZW5kZXJQaXBlbGluZSggcmVuZGVyT2JqZWN0LCBwcm9taXNlcyApIHtcclxuXHJcblx0XHRjb25zdCB7IG9iamVjdCwgbWF0ZXJpYWwsIGdlb21ldHJ5LCBwaXBlbGluZSB9ID0gcmVuZGVyT2JqZWN0O1xyXG5cdFx0Y29uc3QgeyB2ZXJ0ZXhQcm9ncmFtLCBmcmFnbWVudFByb2dyYW0gfSA9IHBpcGVsaW5lO1xyXG5cclxuXHRcdGNvbnN0IGJhY2tlbmQgPSB0aGlzLmJhY2tlbmQ7XHJcblx0XHRjb25zdCBkZXZpY2UgPSBiYWNrZW5kLmRldmljZTtcclxuXHRcdGNvbnN0IHV0aWxzID0gYmFja2VuZC51dGlscztcclxuXHJcblx0XHRjb25zdCBwaXBlbGluZURhdGEgPSBiYWNrZW5kLmdldCggcGlwZWxpbmUgKTtcclxuXHJcblx0XHQvLyBiaW5kIGdyb3VwIGxheW91dHNcclxuXHJcblx0XHRjb25zdCBiaW5kR3JvdXBMYXlvdXRzID0gW107XHJcblxyXG5cdFx0Zm9yICggY29uc3QgYmluZEdyb3VwIG9mIHJlbmRlck9iamVjdC5nZXRCaW5kaW5ncygpICkge1xyXG5cclxuXHRcdFx0Y29uc3QgYmluZGluZ3NEYXRhID0gYmFja2VuZC5nZXQoIGJpbmRHcm91cCApO1xyXG5cclxuXHRcdFx0YmluZEdyb3VwTGF5b3V0cy5wdXNoKCBiaW5kaW5nc0RhdGEubGF5b3V0ICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIHZlcnRleCBidWZmZXJzXHJcblxyXG5cdFx0Y29uc3QgdmVydGV4QnVmZmVycyA9IGJhY2tlbmQuYXR0cmlidXRlVXRpbHMuY3JlYXRlU2hhZGVyVmVydGV4QnVmZmVycyggcmVuZGVyT2JqZWN0ICk7XHJcblxyXG5cdFx0Ly8gYmxlbmRpbmdcclxuXHJcblx0XHRsZXQgYmxlbmRpbmc7XHJcblxyXG5cdFx0aWYgKCBtYXRlcmlhbC50cmFuc3BhcmVudCA9PT0gdHJ1ZSAmJiBtYXRlcmlhbC5ibGVuZGluZyAhPT0gTm9CbGVuZGluZyApIHtcclxuXHJcblx0XHRcdGJsZW5kaW5nID0gdGhpcy5fZ2V0QmxlbmRpbmcoIG1hdGVyaWFsICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIHN0ZW5jaWxcclxuXHJcblx0XHRsZXQgc3RlbmNpbEZyb250ID0ge307XHJcblxyXG5cdFx0aWYgKCBtYXRlcmlhbC5zdGVuY2lsV3JpdGUgPT09IHRydWUgKSB7XHJcblxyXG5cdFx0XHRzdGVuY2lsRnJvbnQgPSB7XHJcblx0XHRcdFx0Y29tcGFyZTogdGhpcy5fZ2V0U3RlbmNpbENvbXBhcmUoIG1hdGVyaWFsICksXHJcblx0XHRcdFx0ZmFpbE9wOiB0aGlzLl9nZXRTdGVuY2lsT3BlcmF0aW9uKCBtYXRlcmlhbC5zdGVuY2lsRmFpbCApLFxyXG5cdFx0XHRcdGRlcHRoRmFpbE9wOiB0aGlzLl9nZXRTdGVuY2lsT3BlcmF0aW9uKCBtYXRlcmlhbC5zdGVuY2lsWkZhaWwgKSxcclxuXHRcdFx0XHRwYXNzT3A6IHRoaXMuX2dldFN0ZW5jaWxPcGVyYXRpb24oIG1hdGVyaWFsLnN0ZW5jaWxaUGFzcyApXHJcblx0XHRcdH07XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGNvbnN0IGNvbG9yV3JpdGVNYXNrID0gdGhpcy5fZ2V0Q29sb3JXcml0ZU1hc2soIG1hdGVyaWFsICk7XHJcblxyXG5cdFx0Y29uc3QgdGFyZ2V0cyA9IFtdO1xyXG5cclxuXHRcdGlmICggcmVuZGVyT2JqZWN0LmNvbnRleHQudGV4dHVyZXMgIT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHRjb25zdCB0ZXh0dXJlcyA9IHJlbmRlck9iamVjdC5jb250ZXh0LnRleHR1cmVzO1xyXG5cclxuXHRcdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgdGV4dHVyZXMubGVuZ3RoOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHRjb25zdCBjb2xvckZvcm1hdCA9IHV0aWxzLmdldFRleHR1cmVGb3JtYXRHUFUoIHRleHR1cmVzWyBpIF0gKTtcclxuXHJcblx0XHRcdFx0dGFyZ2V0cy5wdXNoKCB7XHJcblx0XHRcdFx0XHRmb3JtYXQ6IGNvbG9yRm9ybWF0LFxyXG5cdFx0XHRcdFx0YmxlbmQ6IGJsZW5kaW5nLFxyXG5cdFx0XHRcdFx0d3JpdGVNYXNrOiBjb2xvcldyaXRlTWFza1xyXG5cdFx0XHRcdH0gKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0Y29uc3QgY29sb3JGb3JtYXQgPSB1dGlscy5nZXRDdXJyZW50Q29sb3JGb3JtYXQoIHJlbmRlck9iamVjdC5jb250ZXh0ICk7XHJcblxyXG5cdFx0XHR0YXJnZXRzLnB1c2goIHtcclxuXHRcdFx0XHRmb3JtYXQ6IGNvbG9yRm9ybWF0LFxyXG5cdFx0XHRcdGJsZW5kOiBibGVuZGluZyxcclxuXHRcdFx0XHR3cml0ZU1hc2s6IGNvbG9yV3JpdGVNYXNrXHJcblx0XHRcdH0gKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Y29uc3QgdmVydGV4TW9kdWxlID0gYmFja2VuZC5nZXQoIHZlcnRleFByb2dyYW0gKS5tb2R1bGU7XHJcblx0XHRjb25zdCBmcmFnbWVudE1vZHVsZSA9IGJhY2tlbmQuZ2V0KCBmcmFnbWVudFByb2dyYW0gKS5tb2R1bGU7XHJcblxyXG5cdFx0Y29uc3QgcHJpbWl0aXZlU3RhdGUgPSB0aGlzLl9nZXRQcmltaXRpdmVTdGF0ZSggb2JqZWN0LCBnZW9tZXRyeSwgbWF0ZXJpYWwgKTtcclxuXHRcdGNvbnN0IGRlcHRoQ29tcGFyZSA9IHRoaXMuX2dldERlcHRoQ29tcGFyZSggbWF0ZXJpYWwgKTtcclxuXHRcdGNvbnN0IGRlcHRoU3RlbmNpbEZvcm1hdCA9IHV0aWxzLmdldEN1cnJlbnREZXB0aFN0ZW5jaWxGb3JtYXQoIHJlbmRlck9iamVjdC5jb250ZXh0ICk7XHJcblxyXG5cdFx0Y29uc3Qgc2FtcGxlQ291bnQgPSB0aGlzLl9nZXRTYW1wbGVDb3VudCggcmVuZGVyT2JqZWN0LmNvbnRleHQgKTtcclxuXHJcblx0XHRjb25zdCBwaXBlbGluZURlc2NyaXB0b3IgPSB7XHJcblx0XHRcdGxhYmVsOiBgcmVuZGVyUGlwZWxpbmVfJHsgbWF0ZXJpYWwubmFtZSB8fCBtYXRlcmlhbC50eXBlIH1fJHsgbWF0ZXJpYWwuaWQgfWAsXHJcblx0XHRcdHZlcnRleDogT2JqZWN0LmFzc2lnbigge30sIHZlcnRleE1vZHVsZSwgeyBidWZmZXJzOiB2ZXJ0ZXhCdWZmZXJzIH0gKSxcclxuXHRcdFx0ZnJhZ21lbnQ6IE9iamVjdC5hc3NpZ24oIHt9LCBmcmFnbWVudE1vZHVsZSwgeyB0YXJnZXRzIH0gKSxcclxuXHRcdFx0cHJpbWl0aXZlOiBwcmltaXRpdmVTdGF0ZSxcclxuXHRcdFx0bXVsdGlzYW1wbGU6IHtcclxuXHRcdFx0XHRjb3VudDogc2FtcGxlQ291bnQsXHJcblx0XHRcdFx0YWxwaGFUb0NvdmVyYWdlRW5hYmxlZDogbWF0ZXJpYWwuYWxwaGFUb0NvdmVyYWdlICYmIHNhbXBsZUNvdW50ID4gMVxyXG5cdFx0XHR9LFxyXG5cdFx0XHRsYXlvdXQ6IGRldmljZS5jcmVhdGVQaXBlbGluZUxheW91dCgge1xyXG5cdFx0XHRcdGJpbmRHcm91cExheW91dHNcclxuXHRcdFx0fSApXHJcblx0XHR9O1xyXG5cclxuXHJcblx0XHRjb25zdCBkZXB0aFN0ZW5jaWwgPSB7fTtcclxuXHRcdGNvbnN0IHJlbmRlckRlcHRoID0gcmVuZGVyT2JqZWN0LmNvbnRleHQuZGVwdGg7XHJcblx0XHRjb25zdCByZW5kZXJTdGVuY2lsID0gcmVuZGVyT2JqZWN0LmNvbnRleHQuc3RlbmNpbDtcclxuXHJcblx0XHRpZiAoIHJlbmRlckRlcHRoID09PSB0cnVlIHx8IHJlbmRlclN0ZW5jaWwgPT09IHRydWUgKSB7XHJcblxyXG5cdFx0XHRpZiAoIHJlbmRlckRlcHRoID09PSB0cnVlICkge1xyXG5cclxuXHRcdFx0XHRkZXB0aFN0ZW5jaWwuZm9ybWF0ID0gZGVwdGhTdGVuY2lsRm9ybWF0O1xyXG5cdFx0XHRcdGRlcHRoU3RlbmNpbC5kZXB0aFdyaXRlRW5hYmxlZCA9IG1hdGVyaWFsLmRlcHRoV3JpdGU7XHJcblx0XHRcdFx0ZGVwdGhTdGVuY2lsLmRlcHRoQ29tcGFyZSA9IGRlcHRoQ29tcGFyZTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICggcmVuZGVyU3RlbmNpbCA9PT0gdHJ1ZSApIHtcclxuXHJcblx0XHRcdFx0ZGVwdGhTdGVuY2lsLnN0ZW5jaWxGcm9udCA9IHN0ZW5jaWxGcm9udDtcclxuXHRcdFx0XHRkZXB0aFN0ZW5jaWwuc3RlbmNpbEJhY2sgPSB7fTsgLy8gdGhyZWUuanMgZG9lcyBub3QgcHJvdmlkZSBhbiBBUEkgdG8gY29uZmlndXJlIHRoZSBiYWNrIGZ1bmN0aW9uIChnbC5zdGVuY2lsRnVuY1NlcGFyYXRlKCkgd2FzIG5ldmVyIHVzZWQpXHJcblx0XHRcdFx0ZGVwdGhTdGVuY2lsLnN0ZW5jaWxSZWFkTWFzayA9IG1hdGVyaWFsLnN0ZW5jaWxGdW5jTWFzaztcclxuXHRcdFx0XHRkZXB0aFN0ZW5jaWwuc3RlbmNpbFdyaXRlTWFzayA9IG1hdGVyaWFsLnN0ZW5jaWxXcml0ZU1hc2s7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRwaXBlbGluZURlc2NyaXB0b3IuZGVwdGhTdGVuY2lsID0gZGVwdGhTdGVuY2lsO1xyXG5cclxuXHRcdH1cclxuXHJcblxyXG5cdFx0aWYgKCBwcm9taXNlcyA9PT0gbnVsbCApIHtcclxuXHJcblx0XHRcdHBpcGVsaW5lRGF0YS5waXBlbGluZSA9IGRldmljZS5jcmVhdGVSZW5kZXJQaXBlbGluZSggcGlwZWxpbmVEZXNjcmlwdG9yICk7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdGNvbnN0IHAgPSBuZXcgUHJvbWlzZSggKCByZXNvbHZlIC8qLCByZWplY3QqLyApID0+IHtcclxuXHJcblx0XHRcdFx0ZGV2aWNlLmNyZWF0ZVJlbmRlclBpcGVsaW5lQXN5bmMoIHBpcGVsaW5lRGVzY3JpcHRvciApLnRoZW4oIHBpcGVsaW5lID0+IHtcclxuXHJcblx0XHRcdFx0XHRwaXBlbGluZURhdGEucGlwZWxpbmUgPSBwaXBlbGluZTtcclxuXHRcdFx0XHRcdHJlc29sdmUoKTtcclxuXHJcblx0XHRcdFx0fSApO1xyXG5cclxuXHRcdFx0fSApO1xyXG5cclxuXHRcdFx0cHJvbWlzZXMucHVzaCggcCApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHRjcmVhdGVCdW5kbGVFbmNvZGVyKCByZW5kZXJDb250ZXh0ICkge1xyXG5cclxuXHRcdGNvbnN0IGJhY2tlbmQgPSB0aGlzLmJhY2tlbmQ7XHJcblx0XHRjb25zdCB7IHV0aWxzLCBkZXZpY2UgfSA9IGJhY2tlbmQ7XHJcblxyXG5cdFx0Y29uc3QgZGVwdGhTdGVuY2lsRm9ybWF0ID0gdXRpbHMuZ2V0Q3VycmVudERlcHRoU3RlbmNpbEZvcm1hdCggcmVuZGVyQ29udGV4dCApO1xyXG5cdFx0Y29uc3QgY29sb3JGb3JtYXQgPSB1dGlscy5nZXRDdXJyZW50Q29sb3JGb3JtYXQoIHJlbmRlckNvbnRleHQgKTtcclxuXHRcdGNvbnN0IHNhbXBsZUNvdW50ID0gdGhpcy5fZ2V0U2FtcGxlQ291bnQoIHJlbmRlckNvbnRleHQgKTtcclxuXHJcblx0XHRjb25zdCBkZXNjcmlwdG9yID0ge1xyXG5cdFx0XHRsYWJlbDogJ3JlbmRlckJ1bmRsZUVuY29kZXInLFxyXG5cdFx0XHRjb2xvckZvcm1hdHM6IFsgY29sb3JGb3JtYXQgXSxcclxuXHRcdFx0ZGVwdGhTdGVuY2lsRm9ybWF0LFxyXG5cdFx0XHRzYW1wbGVDb3VudFxyXG5cdFx0fTtcclxuXHJcblx0XHRyZXR1cm4gZGV2aWNlLmNyZWF0ZVJlbmRlckJ1bmRsZUVuY29kZXIoIGRlc2NyaXB0b3IgKTtcclxuXHJcblx0fVxyXG5cclxuXHRjcmVhdGVDb21wdXRlUGlwZWxpbmUoIHBpcGVsaW5lLCBiaW5kaW5ncyApIHtcclxuXHJcblx0XHRjb25zdCBiYWNrZW5kID0gdGhpcy5iYWNrZW5kO1xyXG5cdFx0Y29uc3QgZGV2aWNlID0gYmFja2VuZC5kZXZpY2U7XHJcblxyXG5cdFx0Y29uc3QgY29tcHV0ZVByb2dyYW0gPSBiYWNrZW5kLmdldCggcGlwZWxpbmUuY29tcHV0ZVByb2dyYW0gKS5tb2R1bGU7XHJcblxyXG5cdFx0Y29uc3QgcGlwZWxpbmVHUFUgPSBiYWNrZW5kLmdldCggcGlwZWxpbmUgKTtcclxuXHJcblx0XHQvLyBiaW5kIGdyb3VwIGxheW91dHNcclxuXHJcblx0XHRjb25zdCBiaW5kR3JvdXBMYXlvdXRzID0gW107XHJcblxyXG5cdFx0Zm9yICggY29uc3QgYmluZGluZ3NHcm91cCBvZiBiaW5kaW5ncyApIHtcclxuXHJcblx0XHRcdGNvbnN0IGJpbmRpbmdzRGF0YSA9IGJhY2tlbmQuZ2V0KCBiaW5kaW5nc0dyb3VwICk7XHJcblxyXG5cdFx0XHRiaW5kR3JvdXBMYXlvdXRzLnB1c2goIGJpbmRpbmdzRGF0YS5sYXlvdXQgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cGlwZWxpbmVHUFUucGlwZWxpbmUgPSBkZXZpY2UuY3JlYXRlQ29tcHV0ZVBpcGVsaW5lKCB7XHJcblx0XHRcdGNvbXB1dGU6IGNvbXB1dGVQcm9ncmFtLFxyXG5cdFx0XHRsYXlvdXQ6IGRldmljZS5jcmVhdGVQaXBlbGluZUxheW91dCgge1xyXG5cdFx0XHRcdGJpbmRHcm91cExheW91dHNcclxuXHRcdFx0fSApXHJcblx0XHR9ICk7XHJcblxyXG5cdH1cclxuXHJcblx0X2dldEJsZW5kaW5nKCBtYXRlcmlhbCApIHtcclxuXHJcblx0XHRsZXQgY29sb3IsIGFscGhhO1xyXG5cclxuXHRcdGNvbnN0IGJsZW5kaW5nID0gbWF0ZXJpYWwuYmxlbmRpbmc7XHJcblx0XHRjb25zdCBibGVuZFNyYyA9IG1hdGVyaWFsLmJsZW5kU3JjO1xyXG5cdFx0Y29uc3QgYmxlbmREc3QgPSBtYXRlcmlhbC5ibGVuZERzdDtcclxuXHRcdGNvbnN0IGJsZW5kRXF1YXRpb24gPSBtYXRlcmlhbC5ibGVuZEVxdWF0aW9uO1xyXG5cclxuXHJcblx0XHRpZiAoIGJsZW5kaW5nID09PSBDdXN0b21CbGVuZGluZyApIHtcclxuXHJcblx0XHRcdGNvbnN0IGJsZW5kU3JjQWxwaGEgPSBtYXRlcmlhbC5ibGVuZFNyY0FscGhhICE9PSBudWxsID8gbWF0ZXJpYWwuYmxlbmRTcmNBbHBoYSA6IGJsZW5kU3JjO1xyXG5cdFx0XHRjb25zdCBibGVuZERzdEFscGhhID0gbWF0ZXJpYWwuYmxlbmREc3RBbHBoYSAhPT0gbnVsbCA/IG1hdGVyaWFsLmJsZW5kRHN0QWxwaGEgOiBibGVuZERzdDtcclxuXHRcdFx0Y29uc3QgYmxlbmRFcXVhdGlvbkFscGhhID0gbWF0ZXJpYWwuYmxlbmRFcXVhdGlvbkFscGhhICE9PSBudWxsID8gbWF0ZXJpYWwuYmxlbmRFcXVhdGlvbkFscGhhIDogYmxlbmRFcXVhdGlvbjtcclxuXHJcblx0XHRcdGNvbG9yID0ge1xyXG5cdFx0XHRcdHNyY0ZhY3RvcjogdGhpcy5fZ2V0QmxlbmRGYWN0b3IoIGJsZW5kU3JjICksXHJcblx0XHRcdFx0ZHN0RmFjdG9yOiB0aGlzLl9nZXRCbGVuZEZhY3RvciggYmxlbmREc3QgKSxcclxuXHRcdFx0XHRvcGVyYXRpb246IHRoaXMuX2dldEJsZW5kT3BlcmF0aW9uKCBibGVuZEVxdWF0aW9uIClcclxuXHRcdFx0fTtcclxuXHJcblx0XHRcdGFscGhhID0ge1xyXG5cdFx0XHRcdHNyY0ZhY3RvcjogdGhpcy5fZ2V0QmxlbmRGYWN0b3IoIGJsZW5kU3JjQWxwaGEgKSxcclxuXHRcdFx0XHRkc3RGYWN0b3I6IHRoaXMuX2dldEJsZW5kRmFjdG9yKCBibGVuZERzdEFscGhhICksXHJcblx0XHRcdFx0b3BlcmF0aW9uOiB0aGlzLl9nZXRCbGVuZE9wZXJhdGlvbiggYmxlbmRFcXVhdGlvbkFscGhhIClcclxuXHRcdFx0fTtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0Y29uc3QgcHJlbXVsdGlwbGllZEFscGhhID0gbWF0ZXJpYWwucHJlbXVsdGlwbGllZEFscGhhO1xyXG5cclxuXHRcdFx0Y29uc3Qgc2V0QmxlbmQgPSAoIHNyY1JHQiwgZHN0UkdCLCBzcmNBbHBoYSwgZHN0QWxwaGEgKSA9PiB7XHJcblxyXG5cdFx0XHRcdGNvbG9yID0ge1xyXG5cdFx0XHRcdFx0c3JjRmFjdG9yOiBzcmNSR0IsXHJcblx0XHRcdFx0XHRkc3RGYWN0b3I6IGRzdFJHQixcclxuXHRcdFx0XHRcdG9wZXJhdGlvbjogR1BVQmxlbmRPcGVyYXRpb24uQWRkXHJcblx0XHRcdFx0fTtcclxuXHJcblx0XHRcdFx0YWxwaGEgPSB7XHJcblx0XHRcdFx0XHRzcmNGYWN0b3I6IHNyY0FscGhhLFxyXG5cdFx0XHRcdFx0ZHN0RmFjdG9yOiBkc3RBbHBoYSxcclxuXHRcdFx0XHRcdG9wZXJhdGlvbjogR1BVQmxlbmRPcGVyYXRpb24uQWRkXHJcblx0XHRcdFx0fTtcclxuXHJcblx0XHRcdH07XHJcblxyXG5cdFx0XHRpZiAoIHByZW11bHRpcGxpZWRBbHBoYSApIHtcclxuXHJcblx0XHRcdFx0c3dpdGNoICggYmxlbmRpbmcgKSB7XHJcblxyXG5cdFx0XHRcdFx0Y2FzZSBOb3JtYWxCbGVuZGluZzpcclxuXHRcdFx0XHRcdFx0c2V0QmxlbmQoIEdQVUJsZW5kRmFjdG9yLk9uZSwgR1BVQmxlbmRGYWN0b3IuT25lTWludXNTcmNBbHBoYSwgR1BVQmxlbmRGYWN0b3IuT25lLCBHUFVCbGVuZEZhY3Rvci5PbmVNaW51c1NyY0FscGhhICk7XHJcblx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRcdGNhc2UgQWRkaXRpdmVCbGVuZGluZzpcclxuXHRcdFx0XHRcdFx0c2V0QmxlbmQoIEdQVUJsZW5kRmFjdG9yLk9uZSwgR1BVQmxlbmRGYWN0b3IuT25lLCBHUFVCbGVuZEZhY3Rvci5PbmUsIEdQVUJsZW5kRmFjdG9yLk9uZSApO1xyXG5cdFx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0XHRjYXNlIFN1YnRyYWN0aXZlQmxlbmRpbmc6XHJcblx0XHRcdFx0XHRcdHNldEJsZW5kKCBHUFVCbGVuZEZhY3Rvci5aZXJvLCBHUFVCbGVuZEZhY3Rvci5PbmVNaW51c1NyYywgR1BVQmxlbmRGYWN0b3IuWmVybywgR1BVQmxlbmRGYWN0b3IuT25lICk7XHJcblx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRcdGNhc2UgTXVsdGlwbHlCbGVuZGluZzpcclxuXHRcdFx0XHRcdFx0c2V0QmxlbmQoIEdQVUJsZW5kRmFjdG9yLlplcm8sIEdQVUJsZW5kRmFjdG9yLlNyYywgR1BVQmxlbmRGYWN0b3IuWmVybywgR1BVQmxlbmRGYWN0b3IuU3JjQWxwaGEgKTtcclxuXHRcdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdHN3aXRjaCAoIGJsZW5kaW5nICkge1xyXG5cclxuXHRcdFx0XHRcdGNhc2UgTm9ybWFsQmxlbmRpbmc6XHJcblx0XHRcdFx0XHRcdHNldEJsZW5kKCBHUFVCbGVuZEZhY3Rvci5TcmNBbHBoYSwgR1BVQmxlbmRGYWN0b3IuT25lTWludXNTcmNBbHBoYSwgR1BVQmxlbmRGYWN0b3IuT25lLCBHUFVCbGVuZEZhY3Rvci5PbmVNaW51c1NyY0FscGhhICk7XHJcblx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRcdGNhc2UgQWRkaXRpdmVCbGVuZGluZzpcclxuXHRcdFx0XHRcdFx0c2V0QmxlbmQoIEdQVUJsZW5kRmFjdG9yLlNyY0FscGhhLCBHUFVCbGVuZEZhY3Rvci5PbmUsIEdQVUJsZW5kRmFjdG9yLlNyY0FscGhhLCBHUFVCbGVuZEZhY3Rvci5PbmUgKTtcclxuXHRcdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdFx0Y2FzZSBTdWJ0cmFjdGl2ZUJsZW5kaW5nOlxyXG5cdFx0XHRcdFx0XHRzZXRCbGVuZCggR1BVQmxlbmRGYWN0b3IuWmVybywgR1BVQmxlbmRGYWN0b3IuT25lTWludXNTcmMsIEdQVUJsZW5kRmFjdG9yLlplcm8sIEdQVUJsZW5kRmFjdG9yLk9uZSApO1xyXG5cdFx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0XHRjYXNlIE11bHRpcGx5QmxlbmRpbmc6XHJcblx0XHRcdFx0XHRcdHNldEJsZW5kKCBHUFVCbGVuZEZhY3Rvci5aZXJvLCBHUFVCbGVuZEZhY3Rvci5TcmMsIEdQVUJsZW5kRmFjdG9yLlplcm8sIEdQVUJsZW5kRmFjdG9yLlNyYyApO1xyXG5cdFx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIGNvbG9yICE9PSB1bmRlZmluZWQgJiYgYWxwaGEgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdHJldHVybiB7IGNvbG9yLCBhbHBoYSB9O1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuV2ViR1BVUmVuZGVyZXI6IEludmFsaWQgYmxlbmRpbmc6ICcsIGJsZW5kaW5nICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdF9nZXRCbGVuZEZhY3RvciggYmxlbmQgKSB7XHJcblxyXG5cdFx0bGV0IGJsZW5kRmFjdG9yO1xyXG5cclxuXHRcdHN3aXRjaCAoIGJsZW5kICkge1xyXG5cclxuXHRcdFx0Y2FzZSBaZXJvRmFjdG9yOlxyXG5cdFx0XHRcdGJsZW5kRmFjdG9yID0gR1BVQmxlbmRGYWN0b3IuWmVybztcclxuXHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdGNhc2UgT25lRmFjdG9yOlxyXG5cdFx0XHRcdGJsZW5kRmFjdG9yID0gR1BVQmxlbmRGYWN0b3IuT25lO1xyXG5cdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0Y2FzZSBTcmNDb2xvckZhY3RvcjpcclxuXHRcdFx0XHRibGVuZEZhY3RvciA9IEdQVUJsZW5kRmFjdG9yLlNyYztcclxuXHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdGNhc2UgT25lTWludXNTcmNDb2xvckZhY3RvcjpcclxuXHRcdFx0XHRibGVuZEZhY3RvciA9IEdQVUJsZW5kRmFjdG9yLk9uZU1pbnVzU3JjO1xyXG5cdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0Y2FzZSBTcmNBbHBoYUZhY3RvcjpcclxuXHRcdFx0XHRibGVuZEZhY3RvciA9IEdQVUJsZW5kRmFjdG9yLlNyY0FscGhhO1xyXG5cdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0Y2FzZSBPbmVNaW51c1NyY0FscGhhRmFjdG9yOlxyXG5cdFx0XHRcdGJsZW5kRmFjdG9yID0gR1BVQmxlbmRGYWN0b3IuT25lTWludXNTcmNBbHBoYTtcclxuXHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdGNhc2UgRHN0Q29sb3JGYWN0b3I6XHJcblx0XHRcdFx0YmxlbmRGYWN0b3IgPSBHUFVCbGVuZEZhY3Rvci5Ec3Q7XHJcblx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRjYXNlIE9uZU1pbnVzRHN0Q29sb3JGYWN0b3I6XHJcblx0XHRcdFx0YmxlbmRGYWN0b3IgPSBHUFVCbGVuZEZhY3Rvci5PbmVNaW51c0RzdENvbG9yO1xyXG5cdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0Y2FzZSBEc3RBbHBoYUZhY3RvcjpcclxuXHRcdFx0XHRibGVuZEZhY3RvciA9IEdQVUJsZW5kRmFjdG9yLkRzdEFscGhhO1xyXG5cdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0Y2FzZSBPbmVNaW51c0RzdEFscGhhRmFjdG9yOlxyXG5cdFx0XHRcdGJsZW5kRmFjdG9yID0gR1BVQmxlbmRGYWN0b3IuT25lTWludXNEc3RBbHBoYTtcclxuXHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdGNhc2UgU3JjQWxwaGFTYXR1cmF0ZUZhY3RvcjpcclxuXHRcdFx0XHRibGVuZEZhY3RvciA9IEdQVUJsZW5kRmFjdG9yLlNyY0FscGhhU2F0dXJhdGVkO1xyXG5cdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0Y2FzZSBCbGVuZENvbG9yRmFjdG9yOlxyXG5cdFx0XHRcdGJsZW5kRmFjdG9yID0gR1BVQmxlbmRGYWN0b3IuQ29uc3RhbnQ7XHJcblx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRjYXNlIE9uZU1pbnVzQmxlbmRDb2xvckZhY3RvcjpcclxuXHRcdFx0XHRibGVuZEZhY3RvciA9IEdQVUJsZW5kRmFjdG9yLk9uZU1pbnVzQ29uc3RhbnQ7XHJcblx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRkZWZhdWx0OlxyXG5cdFx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5XZWJHUFVSZW5kZXJlcjogQmxlbmQgZmFjdG9yIG5vdCBzdXBwb3J0ZWQuJywgYmxlbmQgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGJsZW5kRmFjdG9yO1xyXG5cclxuXHR9XHJcblxyXG5cdF9nZXRTdGVuY2lsQ29tcGFyZSggbWF0ZXJpYWwgKSB7XHJcblxyXG5cdFx0bGV0IHN0ZW5jaWxDb21wYXJlO1xyXG5cclxuXHRcdGNvbnN0IHN0ZW5jaWxGdW5jID0gbWF0ZXJpYWwuc3RlbmNpbEZ1bmM7XHJcblxyXG5cdFx0c3dpdGNoICggc3RlbmNpbEZ1bmMgKSB7XHJcblxyXG5cdFx0XHRjYXNlIE5ldmVyU3RlbmNpbEZ1bmM6XHJcblx0XHRcdFx0c3RlbmNpbENvbXBhcmUgPSBHUFVDb21wYXJlRnVuY3Rpb24uTmV2ZXI7XHJcblx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRjYXNlIEFsd2F5c1N0ZW5jaWxGdW5jOlxyXG5cdFx0XHRcdHN0ZW5jaWxDb21wYXJlID0gR1BVQ29tcGFyZUZ1bmN0aW9uLkFsd2F5cztcclxuXHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdGNhc2UgTGVzc1N0ZW5jaWxGdW5jOlxyXG5cdFx0XHRcdHN0ZW5jaWxDb21wYXJlID0gR1BVQ29tcGFyZUZ1bmN0aW9uLkxlc3M7XHJcblx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRjYXNlIExlc3NFcXVhbFN0ZW5jaWxGdW5jOlxyXG5cdFx0XHRcdHN0ZW5jaWxDb21wYXJlID0gR1BVQ29tcGFyZUZ1bmN0aW9uLkxlc3NFcXVhbDtcclxuXHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdGNhc2UgRXF1YWxTdGVuY2lsRnVuYzpcclxuXHRcdFx0XHRzdGVuY2lsQ29tcGFyZSA9IEdQVUNvbXBhcmVGdW5jdGlvbi5FcXVhbDtcclxuXHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdGNhc2UgR3JlYXRlckVxdWFsU3RlbmNpbEZ1bmM6XHJcblx0XHRcdFx0c3RlbmNpbENvbXBhcmUgPSBHUFVDb21wYXJlRnVuY3Rpb24uR3JlYXRlckVxdWFsO1xyXG5cdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0Y2FzZSBHcmVhdGVyU3RlbmNpbEZ1bmM6XHJcblx0XHRcdFx0c3RlbmNpbENvbXBhcmUgPSBHUFVDb21wYXJlRnVuY3Rpb24uR3JlYXRlcjtcclxuXHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdGNhc2UgTm90RXF1YWxTdGVuY2lsRnVuYzpcclxuXHRcdFx0XHRzdGVuY2lsQ29tcGFyZSA9IEdQVUNvbXBhcmVGdW5jdGlvbi5Ob3RFcXVhbDtcclxuXHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdGRlZmF1bHQ6XHJcblx0XHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLldlYkdQVVJlbmRlcmVyOiBJbnZhbGlkIHN0ZW5jaWwgZnVuY3Rpb24uJywgc3RlbmNpbEZ1bmMgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHN0ZW5jaWxDb21wYXJlO1xyXG5cclxuXHR9XHJcblxyXG5cdF9nZXRTdGVuY2lsT3BlcmF0aW9uKCBvcCApIHtcclxuXHJcblx0XHRsZXQgc3RlbmNpbE9wZXJhdGlvbjtcclxuXHJcblx0XHRzd2l0Y2ggKCBvcCApIHtcclxuXHJcblx0XHRcdGNhc2UgS2VlcFN0ZW5jaWxPcDpcclxuXHRcdFx0XHRzdGVuY2lsT3BlcmF0aW9uID0gR1BVU3RlbmNpbE9wZXJhdGlvbi5LZWVwO1xyXG5cdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0Y2FzZSBaZXJvU3RlbmNpbE9wOlxyXG5cdFx0XHRcdHN0ZW5jaWxPcGVyYXRpb24gPSBHUFVTdGVuY2lsT3BlcmF0aW9uLlplcm87XHJcblx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRjYXNlIFJlcGxhY2VTdGVuY2lsT3A6XHJcblx0XHRcdFx0c3RlbmNpbE9wZXJhdGlvbiA9IEdQVVN0ZW5jaWxPcGVyYXRpb24uUmVwbGFjZTtcclxuXHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdGNhc2UgSW52ZXJ0U3RlbmNpbE9wOlxyXG5cdFx0XHRcdHN0ZW5jaWxPcGVyYXRpb24gPSBHUFVTdGVuY2lsT3BlcmF0aW9uLkludmVydDtcclxuXHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdGNhc2UgSW5jcmVtZW50U3RlbmNpbE9wOlxyXG5cdFx0XHRcdHN0ZW5jaWxPcGVyYXRpb24gPSBHUFVTdGVuY2lsT3BlcmF0aW9uLkluY3JlbWVudENsYW1wO1xyXG5cdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0Y2FzZSBEZWNyZW1lbnRTdGVuY2lsT3A6XHJcblx0XHRcdFx0c3RlbmNpbE9wZXJhdGlvbiA9IEdQVVN0ZW5jaWxPcGVyYXRpb24uRGVjcmVtZW50Q2xhbXA7XHJcblx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRjYXNlIEluY3JlbWVudFdyYXBTdGVuY2lsT3A6XHJcblx0XHRcdFx0c3RlbmNpbE9wZXJhdGlvbiA9IEdQVVN0ZW5jaWxPcGVyYXRpb24uSW5jcmVtZW50V3JhcDtcclxuXHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdGNhc2UgRGVjcmVtZW50V3JhcFN0ZW5jaWxPcDpcclxuXHRcdFx0XHRzdGVuY2lsT3BlcmF0aW9uID0gR1BVU3RlbmNpbE9wZXJhdGlvbi5EZWNyZW1lbnRXcmFwO1xyXG5cdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0ZGVmYXVsdDpcclxuXHRcdFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuV2ViR1BVUmVuZGVyZXI6IEludmFsaWQgc3RlbmNpbCBvcGVyYXRpb24uJywgc3RlbmNpbE9wZXJhdGlvbiApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gc3RlbmNpbE9wZXJhdGlvbjtcclxuXHJcblx0fVxyXG5cclxuXHRfZ2V0QmxlbmRPcGVyYXRpb24oIGJsZW5kRXF1YXRpb24gKSB7XHJcblxyXG5cdFx0bGV0IGJsZW5kT3BlcmF0aW9uO1xyXG5cclxuXHRcdHN3aXRjaCAoIGJsZW5kRXF1YXRpb24gKSB7XHJcblxyXG5cdFx0XHRjYXNlIEFkZEVxdWF0aW9uOlxyXG5cdFx0XHRcdGJsZW5kT3BlcmF0aW9uID0gR1BVQmxlbmRPcGVyYXRpb24uQWRkO1xyXG5cdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0Y2FzZSBTdWJ0cmFjdEVxdWF0aW9uOlxyXG5cdFx0XHRcdGJsZW5kT3BlcmF0aW9uID0gR1BVQmxlbmRPcGVyYXRpb24uU3VidHJhY3Q7XHJcblx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRjYXNlIFJldmVyc2VTdWJ0cmFjdEVxdWF0aW9uOlxyXG5cdFx0XHRcdGJsZW5kT3BlcmF0aW9uID0gR1BVQmxlbmRPcGVyYXRpb24uUmV2ZXJzZVN1YnRyYWN0O1xyXG5cdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0Y2FzZSBNaW5FcXVhdGlvbjpcclxuXHRcdFx0XHRibGVuZE9wZXJhdGlvbiA9IEdQVUJsZW5kT3BlcmF0aW9uLk1pbjtcclxuXHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdGNhc2UgTWF4RXF1YXRpb246XHJcblx0XHRcdFx0YmxlbmRPcGVyYXRpb24gPSBHUFVCbGVuZE9wZXJhdGlvbi5NYXg7XHJcblx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRkZWZhdWx0OlxyXG5cdFx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5XZWJHUFVQaXBlbGluZVV0aWxzOiBCbGVuZCBlcXVhdGlvbiBub3Qgc3VwcG9ydGVkLicsIGJsZW5kRXF1YXRpb24gKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGJsZW5kT3BlcmF0aW9uO1xyXG5cclxuXHR9XHJcblxyXG5cdF9nZXRQcmltaXRpdmVTdGF0ZSggb2JqZWN0LCBnZW9tZXRyeSwgbWF0ZXJpYWwgKSB7XHJcblxyXG5cdFx0Y29uc3QgZGVzY3JpcHRvciA9IHt9O1xyXG5cdFx0Y29uc3QgdXRpbHMgPSB0aGlzLmJhY2tlbmQudXRpbHM7XHJcblxyXG5cdFx0ZGVzY3JpcHRvci50b3BvbG9neSA9IHV0aWxzLmdldFByaW1pdGl2ZVRvcG9sb2d5KCBvYmplY3QsIG1hdGVyaWFsICk7XHJcblxyXG5cdFx0aWYgKCBnZW9tZXRyeS5pbmRleCAhPT0gbnVsbCAmJiBvYmplY3QuaXNMaW5lID09PSB0cnVlICYmIG9iamVjdC5pc0xpbmVTZWdtZW50cyAhPT0gdHJ1ZSApIHtcclxuXHJcblx0XHRcdGRlc2NyaXB0b3Iuc3RyaXBJbmRleEZvcm1hdCA9ICggZ2VvbWV0cnkuaW5kZXguYXJyYXkgaW5zdGFuY2VvZiBVaW50MTZBcnJheSApID8gR1BVSW5kZXhGb3JtYXQuVWludDE2IDogR1BVSW5kZXhGb3JtYXQuVWludDMyO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRzd2l0Y2ggKCBtYXRlcmlhbC5zaWRlICkge1xyXG5cclxuXHRcdFx0Y2FzZSBGcm9udFNpZGU6XHJcblx0XHRcdFx0ZGVzY3JpcHRvci5mcm9udEZhY2UgPSBHUFVGcm9udEZhY2UuQ0NXO1xyXG5cdFx0XHRcdGRlc2NyaXB0b3IuY3VsbE1vZGUgPSBHUFVDdWxsTW9kZS5CYWNrO1xyXG5cdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0Y2FzZSBCYWNrU2lkZTpcclxuXHRcdFx0XHRkZXNjcmlwdG9yLmZyb250RmFjZSA9IEdQVUZyb250RmFjZS5DQ1c7XHJcblx0XHRcdFx0ZGVzY3JpcHRvci5jdWxsTW9kZSA9IEdQVUN1bGxNb2RlLkZyb250O1xyXG5cdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0Y2FzZSBEb3VibGVTaWRlOlxyXG5cdFx0XHRcdGRlc2NyaXB0b3IuZnJvbnRGYWNlID0gR1BVRnJvbnRGYWNlLkNDVztcclxuXHRcdFx0XHRkZXNjcmlwdG9yLmN1bGxNb2RlID0gR1BVQ3VsbE1vZGUuTm9uZTtcclxuXHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdGRlZmF1bHQ6XHJcblx0XHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLldlYkdQVVBpcGVsaW5lVXRpbHM6IFVua25vd24gbWF0ZXJpYWwuc2lkZSB2YWx1ZS4nLCBtYXRlcmlhbC5zaWRlICk7XHJcblx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBkZXNjcmlwdG9yO1xyXG5cclxuXHR9XHJcblxyXG5cdF9nZXRDb2xvcldyaXRlTWFzayggbWF0ZXJpYWwgKSB7XHJcblxyXG5cdFx0cmV0dXJuICggbWF0ZXJpYWwuY29sb3JXcml0ZSA9PT0gdHJ1ZSApID8gR1BVQ29sb3JXcml0ZUZsYWdzLkFsbCA6IEdQVUNvbG9yV3JpdGVGbGFncy5Ob25lO1xyXG5cclxuXHR9XHJcblxyXG5cdF9nZXREZXB0aENvbXBhcmUoIG1hdGVyaWFsICkge1xyXG5cclxuXHRcdGxldCBkZXB0aENvbXBhcmU7XHJcblxyXG5cdFx0aWYgKCBtYXRlcmlhbC5kZXB0aFRlc3QgPT09IGZhbHNlICkge1xyXG5cclxuXHRcdFx0ZGVwdGhDb21wYXJlID0gR1BVQ29tcGFyZUZ1bmN0aW9uLkFsd2F5cztcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0Y29uc3QgZGVwdGhGdW5jID0gbWF0ZXJpYWwuZGVwdGhGdW5jO1xyXG5cclxuXHRcdFx0c3dpdGNoICggZGVwdGhGdW5jICkge1xyXG5cclxuXHRcdFx0XHRjYXNlIE5ldmVyRGVwdGg6XHJcblx0XHRcdFx0XHRkZXB0aENvbXBhcmUgPSBHUFVDb21wYXJlRnVuY3Rpb24uTmV2ZXI7XHJcblx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0Y2FzZSBBbHdheXNEZXB0aDpcclxuXHRcdFx0XHRcdGRlcHRoQ29tcGFyZSA9IEdQVUNvbXBhcmVGdW5jdGlvbi5BbHdheXM7XHJcblx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0Y2FzZSBMZXNzRGVwdGg6XHJcblx0XHRcdFx0XHRkZXB0aENvbXBhcmUgPSBHUFVDb21wYXJlRnVuY3Rpb24uTGVzcztcclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRjYXNlIExlc3NFcXVhbERlcHRoOlxyXG5cdFx0XHRcdFx0ZGVwdGhDb21wYXJlID0gR1BVQ29tcGFyZUZ1bmN0aW9uLkxlc3NFcXVhbDtcclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRjYXNlIEVxdWFsRGVwdGg6XHJcblx0XHRcdFx0XHRkZXB0aENvbXBhcmUgPSBHUFVDb21wYXJlRnVuY3Rpb24uRXF1YWw7XHJcblx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0Y2FzZSBHcmVhdGVyRXF1YWxEZXB0aDpcclxuXHRcdFx0XHRcdGRlcHRoQ29tcGFyZSA9IEdQVUNvbXBhcmVGdW5jdGlvbi5HcmVhdGVyRXF1YWw7XHJcblx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0Y2FzZSBHcmVhdGVyRGVwdGg6XHJcblx0XHRcdFx0XHRkZXB0aENvbXBhcmUgPSBHUFVDb21wYXJlRnVuY3Rpb24uR3JlYXRlcjtcclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRjYXNlIE5vdEVxdWFsRGVwdGg6XHJcblx0XHRcdFx0XHRkZXB0aENvbXBhcmUgPSBHUFVDb21wYXJlRnVuY3Rpb24uTm90RXF1YWw7XHJcblx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0ZGVmYXVsdDpcclxuXHRcdFx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5XZWJHUFVQaXBlbGluZVV0aWxzOiBJbnZhbGlkIGRlcHRoIGZ1bmN0aW9uLicsIGRlcHRoRnVuYyApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gZGVwdGhDb21wYXJlO1xyXG5cclxuXHR9XHJcblxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBXZWJHUFVQaXBlbGluZVV0aWxzO1xyXG4iLCIvKi8vIGRlYnVnZ2VyIHRvb2xzXHJcbmltcG9ydCAnaHR0cHM6Ly9ncmVnZ21hbi5naXRodWIuaW8vd2ViZ3B1LWF2b2lkLXJlZHVuZGFudC1zdGF0ZS1zZXR0aW5nL3dlYmdwdS1jaGVjay1yZWR1bmRhbnQtc3RhdGUtc2V0dGluZy5qcyc7XHJcbi8vKi9cclxuXHJcbmltcG9ydCB7IEdQVUZlYXR1cmVOYW1lLCBHUFVMb2FkT3AsIEdQVVN0b3JlT3AsIEdQVUluZGV4Rm9ybWF0LCBHUFVUZXh0dXJlVmlld0RpbWVuc2lvbiB9IGZyb20gJy4vdXRpbHMvV2ViR1BVQ29uc3RhbnRzLmpzJztcclxuXHJcbmltcG9ydCBXR1NMTm9kZUJ1aWxkZXIgZnJvbSAnLi9ub2Rlcy9XR1NMTm9kZUJ1aWxkZXIuanMnO1xyXG5pbXBvcnQgQmFja2VuZCBmcm9tICcuLi9jb21tb24vQmFja2VuZC5qcyc7XHJcblxyXG5pbXBvcnQgV2ViR1BVVXRpbHMgZnJvbSAnLi91dGlscy9XZWJHUFVVdGlscy5qcyc7XHJcbmltcG9ydCBXZWJHUFVBdHRyaWJ1dGVVdGlscyBmcm9tICcuL3V0aWxzL1dlYkdQVUF0dHJpYnV0ZVV0aWxzLmpzJztcclxuaW1wb3J0IFdlYkdQVUJpbmRpbmdVdGlscyBmcm9tICcuL3V0aWxzL1dlYkdQVUJpbmRpbmdVdGlscy5qcyc7XHJcbmltcG9ydCBXZWJHUFVQaXBlbGluZVV0aWxzIGZyb20gJy4vdXRpbHMvV2ViR1BVUGlwZWxpbmVVdGlscy5qcyc7XHJcbmltcG9ydCBXZWJHUFVUZXh0dXJlVXRpbHMgZnJvbSAnLi91dGlscy9XZWJHUFVUZXh0dXJlVXRpbHMuanMnO1xyXG5cclxuaW1wb3J0IHsgV2ViR1BVQ29vcmRpbmF0ZVN5c3RlbSB9IGZyb20gJy4uLy4uL2NvbnN0YW50cy5qcyc7XHJcblxyXG4vL1xyXG5cclxuY2xhc3MgV2ViR1BVQmFja2VuZCBleHRlbmRzIEJhY2tlbmQge1xyXG5cclxuXHRjb25zdHJ1Y3RvciggcGFyYW1ldGVycyA9IHt9ICkge1xyXG5cclxuXHRcdHN1cGVyKCBwYXJhbWV0ZXJzICk7XHJcblxyXG5cdFx0dGhpcy5pc1dlYkdQVUJhY2tlbmQgPSB0cnVlO1xyXG5cclxuXHRcdC8vIHNvbWUgcGFyYW1ldGVycyByZXF1aXJlIGRlZmF1bHQgdmFsdWVzIG90aGVyIHRoYW4gXCJ1bmRlZmluZWRcIlxyXG5cdFx0dGhpcy5wYXJhbWV0ZXJzLmFscGhhID0gKCBwYXJhbWV0ZXJzLmFscGhhID09PSB1bmRlZmluZWQgKSA/IHRydWUgOiBwYXJhbWV0ZXJzLmFscGhhO1xyXG5cclxuXHRcdHRoaXMucGFyYW1ldGVycy5yZXF1aXJlZExpbWl0cyA9ICggcGFyYW1ldGVycy5yZXF1aXJlZExpbWl0cyA9PT0gdW5kZWZpbmVkICkgPyB7fSA6IHBhcmFtZXRlcnMucmVxdWlyZWRMaW1pdHM7XHJcblxyXG5cdFx0dGhpcy50cmFja1RpbWVzdGFtcCA9ICggcGFyYW1ldGVycy50cmFja1RpbWVzdGFtcCA9PT0gdHJ1ZSApO1xyXG5cclxuXHRcdHRoaXMuZGV2aWNlID0gbnVsbDtcclxuXHRcdHRoaXMuY29udGV4dCA9IG51bGw7XHJcblx0XHR0aGlzLmNvbG9yQnVmZmVyID0gbnVsbDtcclxuXHRcdHRoaXMuZGVmYXVsdFJlbmRlclBhc3NkZXNjcmlwdG9yID0gbnVsbDtcclxuXHJcblx0XHR0aGlzLnV0aWxzID0gbmV3IFdlYkdQVVV0aWxzKCB0aGlzICk7XHJcblx0XHR0aGlzLmF0dHJpYnV0ZVV0aWxzID0gbmV3IFdlYkdQVUF0dHJpYnV0ZVV0aWxzKCB0aGlzICk7XHJcblx0XHR0aGlzLmJpbmRpbmdVdGlscyA9IG5ldyBXZWJHUFVCaW5kaW5nVXRpbHMoIHRoaXMgKTtcclxuXHRcdHRoaXMucGlwZWxpbmVVdGlscyA9IG5ldyBXZWJHUFVQaXBlbGluZVV0aWxzKCB0aGlzICk7XHJcblx0XHR0aGlzLnRleHR1cmVVdGlscyA9IG5ldyBXZWJHUFVUZXh0dXJlVXRpbHMoIHRoaXMgKTtcclxuXHRcdHRoaXMub2NjbHVkZWRSZXNvbHZlQ2FjaGUgPSBuZXcgTWFwKCk7XHJcblxyXG5cdH1cclxuXHJcblx0YXN5bmMgaW5pdCggcmVuZGVyZXIgKSB7XHJcblxyXG5cdFx0YXdhaXQgc3VwZXIuaW5pdCggcmVuZGVyZXIgKTtcclxuXHJcblx0XHQvL1xyXG5cclxuXHRcdGNvbnN0IHBhcmFtZXRlcnMgPSB0aGlzLnBhcmFtZXRlcnM7XHJcblxyXG5cdFx0Ly8gY3JlYXRlIHRoZSBkZXZpY2UgaWYgaXQgaXMgbm90IHBhc3NlZCB3aXRoIHBhcmFtZXRlcnNcclxuXHJcblx0XHRsZXQgZGV2aWNlO1xyXG5cclxuXHRcdGlmICggcGFyYW1ldGVycy5kZXZpY2UgPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdGNvbnN0IGFkYXB0ZXJPcHRpb25zID0ge1xyXG5cdFx0XHRcdHBvd2VyUHJlZmVyZW5jZTogcGFyYW1ldGVycy5wb3dlclByZWZlcmVuY2VcclxuXHRcdFx0fTtcclxuXHJcblx0XHRcdGNvbnN0IGFkYXB0ZXIgPSAoIHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICkgPyBhd2FpdCBuYXZpZ2F0b3IuZ3B1LnJlcXVlc3RBZGFwdGVyKCBhZGFwdGVyT3B0aW9ucyApIDogbnVsbDtcclxuXHJcblx0XHRcdGlmICggYWRhcHRlciA9PT0gbnVsbCApIHtcclxuXHJcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCAnV2ViR1BVQmFja2VuZDogVW5hYmxlIHRvIGNyZWF0ZSBXZWJHUFUgYWRhcHRlci4nICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBmZWF0dXJlIHN1cHBvcnRcclxuXHJcblx0XHRcdGNvbnN0IGZlYXR1cmVzID0gT2JqZWN0LnZhbHVlcyggR1BVRmVhdHVyZU5hbWUgKTtcclxuXHJcblx0XHRcdGNvbnN0IHN1cHBvcnRlZEZlYXR1cmVzID0gW107XHJcblxyXG5cdFx0XHRmb3IgKCBjb25zdCBuYW1lIG9mIGZlYXR1cmVzICkge1xyXG5cclxuXHRcdFx0XHRpZiAoIGFkYXB0ZXIuZmVhdHVyZXMuaGFzKCBuYW1lICkgKSB7XHJcblxyXG5cdFx0XHRcdFx0c3VwcG9ydGVkRmVhdHVyZXMucHVzaCggbmFtZSApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRjb25zdCBkZXZpY2VEZXNjcmlwdG9yID0ge1xyXG5cdFx0XHRcdHJlcXVpcmVkRmVhdHVyZXM6IHN1cHBvcnRlZEZlYXR1cmVzLFxyXG5cdFx0XHRcdHJlcXVpcmVkTGltaXRzOiBwYXJhbWV0ZXJzLnJlcXVpcmVkTGltaXRzXHJcblx0XHRcdH07XHJcblxyXG5cdFx0XHRkZXZpY2UgPSBhd2FpdCBhZGFwdGVyLnJlcXVlc3REZXZpY2UoIGRldmljZURlc2NyaXB0b3IgKTtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0ZGV2aWNlID0gcGFyYW1ldGVycy5kZXZpY2U7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGRldmljZS5sb3N0LnRoZW4oICggaW5mbyApID0+IHtcclxuXHJcblx0XHRcdGNvbnN0IGRldmljZUxvc3NJbmZvID0ge1xyXG5cdFx0XHRcdGFwaTogJ1dlYkdQVScsXHJcblx0XHRcdFx0bWVzc2FnZTogaW5mby5tZXNzYWdlIHx8ICdVbmtub3duIHJlYXNvbicsXHJcblx0XHRcdFx0cmVhc29uOiBpbmZvLnJlYXNvbiB8fCBudWxsLFxyXG5cdFx0XHRcdG9yaWdpbmFsRXZlbnQ6IGluZm9cclxuXHRcdFx0fTtcclxuXHJcblx0XHRcdHJlbmRlcmVyLm9uRGV2aWNlTG9zdCggZGV2aWNlTG9zc0luZm8gKTtcclxuXHJcblx0XHR9ICk7XHJcblxyXG5cdFx0Y29uc3QgY29udGV4dCA9ICggcGFyYW1ldGVycy5jb250ZXh0ICE9PSB1bmRlZmluZWQgKSA/IHBhcmFtZXRlcnMuY29udGV4dCA6IHJlbmRlcmVyLmRvbUVsZW1lbnQuZ2V0Q29udGV4dCggJ3dlYmdwdScgKTtcclxuXHJcblx0XHR0aGlzLmRldmljZSA9IGRldmljZTtcclxuXHRcdHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XHJcblxyXG5cdFx0Y29uc3QgYWxwaGFNb2RlID0gcGFyYW1ldGVycy5hbHBoYSA/ICdwcmVtdWx0aXBsaWVkJyA6ICdvcGFxdWUnO1xyXG5cclxuXHRcdHRoaXMudHJhY2tUaW1lc3RhbXAgPSB0aGlzLnRyYWNrVGltZXN0YW1wICYmIHRoaXMuaGFzRmVhdHVyZSggR1BVRmVhdHVyZU5hbWUuVGltZXN0YW1wUXVlcnkgKTtcclxuXHJcblx0XHR0aGlzLmNvbnRleHQuY29uZmlndXJlKCB7XHJcblx0XHRcdGRldmljZTogdGhpcy5kZXZpY2UsXHJcblx0XHRcdGZvcm1hdDogdGhpcy51dGlscy5nZXRQcmVmZXJyZWRDYW52YXNGb3JtYXQoKSxcclxuXHRcdFx0dXNhZ2U6IEdQVVRleHR1cmVVc2FnZS5SRU5ERVJfQVRUQUNITUVOVCB8IEdQVVRleHR1cmVVc2FnZS5DT1BZX1NSQyxcclxuXHRcdFx0YWxwaGFNb2RlOiBhbHBoYU1vZGVcclxuXHRcdH0gKTtcclxuXHJcblx0XHR0aGlzLnVwZGF0ZVNpemUoKTtcclxuXHJcblx0fVxyXG5cclxuXHRnZXQgY29vcmRpbmF0ZVN5c3RlbSgpIHtcclxuXHJcblx0XHRyZXR1cm4gV2ViR1BVQ29vcmRpbmF0ZVN5c3RlbTtcclxuXHJcblx0fVxyXG5cclxuXHRhc3luYyBnZXRBcnJheUJ1ZmZlckFzeW5jKCBhdHRyaWJ1dGUgKSB7XHJcblxyXG5cdFx0cmV0dXJuIGF3YWl0IHRoaXMuYXR0cmlidXRlVXRpbHMuZ2V0QXJyYXlCdWZmZXJBc3luYyggYXR0cmlidXRlICk7XHJcblxyXG5cdH1cclxuXHJcblx0Z2V0Q29udGV4dCgpIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5jb250ZXh0O1xyXG5cclxuXHR9XHJcblxyXG5cdF9nZXREZWZhdWx0UmVuZGVyUGFzc0Rlc2NyaXB0b3IoKSB7XHJcblxyXG5cdFx0bGV0IGRlc2NyaXB0b3IgPSB0aGlzLmRlZmF1bHRSZW5kZXJQYXNzZGVzY3JpcHRvcjtcclxuXHJcblx0XHRpZiAoIGRlc2NyaXB0b3IgPT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHRjb25zdCByZW5kZXJlciA9IHRoaXMucmVuZGVyZXI7XHJcblxyXG5cdFx0XHRkZXNjcmlwdG9yID0ge1xyXG5cdFx0XHRcdGNvbG9yQXR0YWNobWVudHM6IFsge1xyXG5cdFx0XHRcdFx0dmlldzogbnVsbFxyXG5cdFx0XHRcdH0gXSxcclxuXHRcdFx0fTtcclxuXHJcblx0XHRcdGlmICggdGhpcy5yZW5kZXJlci5kZXB0aCA9PT0gdHJ1ZSB8fCB0aGlzLnJlbmRlcmVyLnN0ZW5jaWwgPT09IHRydWUgKSB7XHJcblxyXG5cdFx0XHRcdGRlc2NyaXB0b3IuZGVwdGhTdGVuY2lsQXR0YWNobWVudCA9IHtcclxuXHRcdFx0XHRcdHZpZXc6IHRoaXMudGV4dHVyZVV0aWxzLmdldERlcHRoQnVmZmVyKCByZW5kZXJlci5kZXB0aCwgcmVuZGVyZXIuc3RlbmNpbCApLmNyZWF0ZVZpZXcoKVxyXG5cdFx0XHRcdH07XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRjb25zdCBjb2xvckF0dGFjaG1lbnQgPSBkZXNjcmlwdG9yLmNvbG9yQXR0YWNobWVudHNbIDAgXTtcclxuXHJcblx0XHRcdGlmICggdGhpcy5yZW5kZXJlci5zYW1wbGVzID4gMCApIHtcclxuXHJcblx0XHRcdFx0Y29sb3JBdHRhY2htZW50LnZpZXcgPSB0aGlzLmNvbG9yQnVmZmVyLmNyZWF0ZVZpZXcoKTtcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdGNvbG9yQXR0YWNobWVudC5yZXNvbHZlVGFyZ2V0ID0gdW5kZWZpbmVkO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dGhpcy5kZWZhdWx0UmVuZGVyUGFzc2Rlc2NyaXB0b3IgPSBkZXNjcmlwdG9yO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRjb25zdCBjb2xvckF0dGFjaG1lbnQgPSBkZXNjcmlwdG9yLmNvbG9yQXR0YWNobWVudHNbIDAgXTtcclxuXHJcblx0XHRpZiAoIHRoaXMucmVuZGVyZXIuc2FtcGxlcyA+IDAgKSB7XHJcblxyXG5cdFx0XHRjb2xvckF0dGFjaG1lbnQucmVzb2x2ZVRhcmdldCA9IHRoaXMuY29udGV4dC5nZXRDdXJyZW50VGV4dHVyZSgpLmNyZWF0ZVZpZXcoKTtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0Y29sb3JBdHRhY2htZW50LnZpZXcgPSB0aGlzLmNvbnRleHQuZ2V0Q3VycmVudFRleHR1cmUoKS5jcmVhdGVWaWV3KCk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBkZXNjcmlwdG9yO1xyXG5cclxuXHR9XHJcblxyXG5cdF9nZXRSZW5kZXJQYXNzRGVzY3JpcHRvciggcmVuZGVyQ29udGV4dCApIHtcclxuXHJcblx0XHRjb25zdCByZW5kZXJUYXJnZXQgPSByZW5kZXJDb250ZXh0LnJlbmRlclRhcmdldDtcclxuXHRcdGNvbnN0IHJlbmRlclRhcmdldERhdGEgPSB0aGlzLmdldCggcmVuZGVyVGFyZ2V0ICk7XHJcblxyXG5cdFx0bGV0IGRlc2NyaXB0b3JzID0gcmVuZGVyVGFyZ2V0RGF0YS5kZXNjcmlwdG9ycztcclxuXHJcblx0XHRpZiAoIGRlc2NyaXB0b3JzID09PSB1bmRlZmluZWQgfHxcclxuXHRcdFx0cmVuZGVyVGFyZ2V0RGF0YS53aWR0aCAhPT0gcmVuZGVyVGFyZ2V0LndpZHRoIHx8XHJcblx0XHRcdHJlbmRlclRhcmdldERhdGEuaGVpZ2h0ICE9PSByZW5kZXJUYXJnZXQuaGVpZ2h0IHx8XHJcblx0XHRcdHJlbmRlclRhcmdldERhdGEuYWN0aXZlTWlwbWFwTGV2ZWwgIT09IHJlbmRlclRhcmdldC5hY3RpdmVNaXBtYXBMZXZlbCB8fFxyXG5cdFx0XHRyZW5kZXJUYXJnZXREYXRhLnNhbXBsZXMgIT09IHJlbmRlclRhcmdldC5zYW1wbGVzXHJcblx0XHQpIHtcclxuXHJcblx0XHRcdGRlc2NyaXB0b3JzID0ge307XHJcblxyXG5cdFx0XHRyZW5kZXJUYXJnZXREYXRhLmRlc2NyaXB0b3JzID0gZGVzY3JpcHRvcnM7XHJcblxyXG5cdFx0XHQvLyBkaXNwb3NlXHJcblxyXG5cdFx0XHRjb25zdCBvbkRpc3Bvc2UgPSAoKSA9PiB7XHJcblxyXG5cdFx0XHRcdHJlbmRlclRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKCAnZGlzcG9zZScsIG9uRGlzcG9zZSApO1xyXG5cclxuXHRcdFx0XHR0aGlzLmRlbGV0ZSggcmVuZGVyVGFyZ2V0ICk7XHJcblxyXG5cdFx0XHR9O1xyXG5cclxuXHRcdFx0cmVuZGVyVGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoICdkaXNwb3NlJywgb25EaXNwb3NlICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGNvbnN0IGNhY2hlS2V5ID0gcmVuZGVyQ29udGV4dC5nZXRDYWNoZUtleSgpO1xyXG5cclxuXHRcdGxldCBkZXNjcmlwdG9yID0gZGVzY3JpcHRvcnNbIGNhY2hlS2V5IF07XHJcblxyXG5cdFx0aWYgKCBkZXNjcmlwdG9yID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRjb25zdCB0ZXh0dXJlcyA9IHJlbmRlckNvbnRleHQudGV4dHVyZXM7XHJcblx0XHRcdGNvbnN0IGNvbG9yQXR0YWNobWVudHMgPSBbXTtcclxuXHJcblx0XHRcdGZvciAoIGxldCBpID0gMDsgaSA8IHRleHR1cmVzLmxlbmd0aDsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0Y29uc3QgdGV4dHVyZURhdGEgPSB0aGlzLmdldCggdGV4dHVyZXNbIGkgXSApO1xyXG5cclxuXHRcdFx0XHRjb25zdCB0ZXh0dXJlVmlldyA9IHRleHR1cmVEYXRhLnRleHR1cmUuY3JlYXRlVmlldygge1xyXG5cdFx0XHRcdFx0YmFzZU1pcExldmVsOiByZW5kZXJDb250ZXh0LmFjdGl2ZU1pcG1hcExldmVsLFxyXG5cdFx0XHRcdFx0bWlwTGV2ZWxDb3VudDogMSxcclxuXHRcdFx0XHRcdGJhc2VBcnJheUxheWVyOiByZW5kZXJDb250ZXh0LmFjdGl2ZUN1YmVGYWNlLFxyXG5cdFx0XHRcdFx0ZGltZW5zaW9uOiBHUFVUZXh0dXJlVmlld0RpbWVuc2lvbi5Ud29EXHJcblx0XHRcdFx0fSApO1xyXG5cclxuXHRcdFx0XHRsZXQgdmlldywgcmVzb2x2ZVRhcmdldDtcclxuXHJcblx0XHRcdFx0aWYgKCB0ZXh0dXJlRGF0YS5tc2FhVGV4dHVyZSAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRcdHZpZXcgPSB0ZXh0dXJlRGF0YS5tc2FhVGV4dHVyZS5jcmVhdGVWaWV3KCk7XHJcblx0XHRcdFx0XHRyZXNvbHZlVGFyZ2V0ID0gdGV4dHVyZVZpZXc7XHJcblxyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0dmlldyA9IHRleHR1cmVWaWV3O1xyXG5cdFx0XHRcdFx0cmVzb2x2ZVRhcmdldCA9IHVuZGVmaW5lZDtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRjb2xvckF0dGFjaG1lbnRzLnB1c2goIHtcclxuXHRcdFx0XHRcdHZpZXcsXHJcblx0XHRcdFx0XHRyZXNvbHZlVGFyZ2V0LFxyXG5cdFx0XHRcdFx0bG9hZE9wOiBHUFVMb2FkT3AuTG9hZCxcclxuXHRcdFx0XHRcdHN0b3JlT3A6IEdQVVN0b3JlT3AuU3RvcmVcclxuXHRcdFx0XHR9ICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cclxuXHRcdFx0ZGVzY3JpcHRvciA9IHtcclxuXHRcdFx0XHRjb2xvckF0dGFjaG1lbnRzLFxyXG5cdFx0XHR9O1xyXG5cclxuXHRcdFx0aWYgKCByZW5kZXJDb250ZXh0LmRlcHRoICkge1xyXG5cclxuXHRcdFx0XHRjb25zdCBkZXB0aFRleHR1cmVEYXRhID0gdGhpcy5nZXQoIHJlbmRlckNvbnRleHQuZGVwdGhUZXh0dXJlICk7XHJcblxyXG5cdFx0XHRcdGNvbnN0IGRlcHRoU3RlbmNpbEF0dGFjaG1lbnQgPSB7XHJcblx0XHRcdFx0XHR2aWV3OiBkZXB0aFRleHR1cmVEYXRhLnRleHR1cmUuY3JlYXRlVmlldygpXHJcblx0XHRcdFx0fTtcclxuXHRcdFx0XHRkZXNjcmlwdG9yLmRlcHRoU3RlbmNpbEF0dGFjaG1lbnQgPSBkZXB0aFN0ZW5jaWxBdHRhY2htZW50O1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0ZGVzY3JpcHRvcnNbIGNhY2hlS2V5IF0gPSBkZXNjcmlwdG9yO1xyXG5cclxuXHRcdFx0cmVuZGVyVGFyZ2V0RGF0YS53aWR0aCA9IHJlbmRlclRhcmdldC53aWR0aDtcclxuXHRcdFx0cmVuZGVyVGFyZ2V0RGF0YS5oZWlnaHQgPSByZW5kZXJUYXJnZXQuaGVpZ2h0O1xyXG5cdFx0XHRyZW5kZXJUYXJnZXREYXRhLnNhbXBsZXMgPSByZW5kZXJUYXJnZXQuc2FtcGxlcztcclxuXHRcdFx0cmVuZGVyVGFyZ2V0RGF0YS5hY3RpdmVNaXBtYXBMZXZlbCA9IHJlbmRlclRhcmdldC5hY3RpdmVNaXBtYXBMZXZlbDtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGRlc2NyaXB0b3I7XHJcblxyXG5cdH1cclxuXHJcblx0YmVnaW5SZW5kZXIoIHJlbmRlckNvbnRleHQgKSB7XHJcblxyXG5cdFx0Y29uc3QgcmVuZGVyQ29udGV4dERhdGEgPSB0aGlzLmdldCggcmVuZGVyQ29udGV4dCApO1xyXG5cclxuXHRcdGNvbnN0IGRldmljZSA9IHRoaXMuZGV2aWNlO1xyXG5cdFx0Y29uc3Qgb2NjbHVzaW9uUXVlcnlDb3VudCA9IHJlbmRlckNvbnRleHQub2NjbHVzaW9uUXVlcnlDb3VudDtcclxuXHJcblx0XHRsZXQgb2NjbHVzaW9uUXVlcnlTZXQ7XHJcblxyXG5cdFx0aWYgKCBvY2NsdXNpb25RdWVyeUNvdW50ID4gMCApIHtcclxuXHJcblx0XHRcdGlmICggcmVuZGVyQ29udGV4dERhdGEuY3VycmVudE9jY2x1c2lvblF1ZXJ5U2V0ICkgcmVuZGVyQ29udGV4dERhdGEuY3VycmVudE9jY2x1c2lvblF1ZXJ5U2V0LmRlc3Ryb3koKTtcclxuXHRcdFx0aWYgKCByZW5kZXJDb250ZXh0RGF0YS5jdXJyZW50T2NjbHVzaW9uUXVlcnlCdWZmZXIgKSByZW5kZXJDb250ZXh0RGF0YS5jdXJyZW50T2NjbHVzaW9uUXVlcnlCdWZmZXIuZGVzdHJveSgpO1xyXG5cclxuXHRcdFx0Ly8gR2V0IGEgcmVmZXJlbmNlIHRvIHRoZSBhcnJheSBvZiBvYmplY3RzIHdpdGggcXVlcmllcy4gVGhlIHJlbmRlckNvbnRleHREYXRhIHByb3BlcnR5XHJcblx0XHRcdC8vIGNhbiBiZSBjaGFuZ2VkIGJ5IGFub3RoZXIgcmVuZGVyIHBhc3MgYmVmb3JlIHRoZSBidWZmZXIubWFwQXN5YygpIGNvbXBsZXRlcy5cclxuXHRcdFx0cmVuZGVyQ29udGV4dERhdGEuY3VycmVudE9jY2x1c2lvblF1ZXJ5U2V0ID0gcmVuZGVyQ29udGV4dERhdGEub2NjbHVzaW9uUXVlcnlTZXQ7XHJcblx0XHRcdHJlbmRlckNvbnRleHREYXRhLmN1cnJlbnRPY2NsdXNpb25RdWVyeUJ1ZmZlciA9IHJlbmRlckNvbnRleHREYXRhLm9jY2x1c2lvblF1ZXJ5QnVmZmVyO1xyXG5cdFx0XHRyZW5kZXJDb250ZXh0RGF0YS5jdXJyZW50T2NjbHVzaW9uUXVlcnlPYmplY3RzID0gcmVuZGVyQ29udGV4dERhdGEub2NjbHVzaW9uUXVlcnlPYmplY3RzO1xyXG5cclxuXHRcdFx0Ly9cclxuXHJcblx0XHRcdG9jY2x1c2lvblF1ZXJ5U2V0ID0gZGV2aWNlLmNyZWF0ZVF1ZXJ5U2V0KCB7IHR5cGU6ICdvY2NsdXNpb24nLCBjb3VudDogb2NjbHVzaW9uUXVlcnlDb3VudCwgbGFiZWw6IGBvY2NsdXNpb25RdWVyeVNldF8keyByZW5kZXJDb250ZXh0LmlkIH1gIH0gKTtcclxuXHJcblx0XHRcdHJlbmRlckNvbnRleHREYXRhLm9jY2x1c2lvblF1ZXJ5U2V0ID0gb2NjbHVzaW9uUXVlcnlTZXQ7XHJcblx0XHRcdHJlbmRlckNvbnRleHREYXRhLm9jY2x1c2lvblF1ZXJ5SW5kZXggPSAwO1xyXG5cdFx0XHRyZW5kZXJDb250ZXh0RGF0YS5vY2NsdXNpb25RdWVyeU9iamVjdHMgPSBuZXcgQXJyYXkoIG9jY2x1c2lvblF1ZXJ5Q291bnQgKTtcclxuXHJcblx0XHRcdHJlbmRlckNvbnRleHREYXRhLmxhc3RPY2NsdXNpb25PYmplY3QgPSBudWxsO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRsZXQgZGVzY3JpcHRvcjtcclxuXHJcblx0XHRpZiAoIHJlbmRlckNvbnRleHQudGV4dHVyZXMgPT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHRkZXNjcmlwdG9yID0gdGhpcy5fZ2V0RGVmYXVsdFJlbmRlclBhc3NEZXNjcmlwdG9yKCk7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdGRlc2NyaXB0b3IgPSB0aGlzLl9nZXRSZW5kZXJQYXNzRGVzY3JpcHRvciggcmVuZGVyQ29udGV4dCApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLmluaXRUaW1lc3RhbXBRdWVyeSggcmVuZGVyQ29udGV4dCwgZGVzY3JpcHRvciApO1xyXG5cclxuXHRcdGRlc2NyaXB0b3Iub2NjbHVzaW9uUXVlcnlTZXQgPSBvY2NsdXNpb25RdWVyeVNldDtcclxuXHJcblx0XHRjb25zdCBkZXB0aFN0ZW5jaWxBdHRhY2htZW50ID0gZGVzY3JpcHRvci5kZXB0aFN0ZW5jaWxBdHRhY2htZW50O1xyXG5cclxuXHRcdGlmICggcmVuZGVyQ29udGV4dC50ZXh0dXJlcyAhPT0gbnVsbCApIHtcclxuXHJcblx0XHRcdGNvbnN0IGNvbG9yQXR0YWNobWVudHMgPSBkZXNjcmlwdG9yLmNvbG9yQXR0YWNobWVudHM7XHJcblxyXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCBjb2xvckF0dGFjaG1lbnRzLmxlbmd0aDsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0Y29uc3QgY29sb3JBdHRhY2htZW50ID0gY29sb3JBdHRhY2htZW50c1sgaSBdO1xyXG5cclxuXHRcdFx0XHRpZiAoIHJlbmRlckNvbnRleHQuY2xlYXJDb2xvciApIHtcclxuXHJcblx0XHRcdFx0XHRjb2xvckF0dGFjaG1lbnQuY2xlYXJWYWx1ZSA9IGkgPT09IDAgPyByZW5kZXJDb250ZXh0LmNsZWFyQ29sb3JWYWx1ZSA6IHsgcjogMCwgZzogMCwgYjogMCwgYTogMSB9O1xyXG5cdFx0XHRcdFx0Y29sb3JBdHRhY2htZW50LmxvYWRPcCA9IEdQVUxvYWRPcC5DbGVhcjtcclxuXHRcdFx0XHRcdGNvbG9yQXR0YWNobWVudC5zdG9yZU9wID0gR1BVU3RvcmVPcC5TdG9yZTtcclxuXHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHRjb2xvckF0dGFjaG1lbnQubG9hZE9wID0gR1BVTG9hZE9wLkxvYWQ7XHJcblx0XHRcdFx0XHRjb2xvckF0dGFjaG1lbnQuc3RvcmVPcCA9IEdQVVN0b3JlT3AuU3RvcmU7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0Y29uc3QgY29sb3JBdHRhY2htZW50ID0gZGVzY3JpcHRvci5jb2xvckF0dGFjaG1lbnRzWyAwIF07XHJcblxyXG5cdFx0XHRpZiAoIHJlbmRlckNvbnRleHQuY2xlYXJDb2xvciApIHtcclxuXHJcblx0XHRcdFx0Y29sb3JBdHRhY2htZW50LmNsZWFyVmFsdWUgPSByZW5kZXJDb250ZXh0LmNsZWFyQ29sb3JWYWx1ZTtcclxuXHRcdFx0XHRjb2xvckF0dGFjaG1lbnQubG9hZE9wID0gR1BVTG9hZE9wLkNsZWFyO1xyXG5cdFx0XHRcdGNvbG9yQXR0YWNobWVudC5zdG9yZU9wID0gR1BVU3RvcmVPcC5TdG9yZTtcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdGNvbG9yQXR0YWNobWVudC5sb2FkT3AgPSBHUFVMb2FkT3AuTG9hZDtcclxuXHRcdFx0XHRjb2xvckF0dGFjaG1lbnQuc3RvcmVPcCA9IEdQVVN0b3JlT3AuU3RvcmU7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vXHJcblxyXG5cdFx0aWYgKCByZW5kZXJDb250ZXh0LmRlcHRoICkge1xyXG5cclxuXHRcdFx0aWYgKCByZW5kZXJDb250ZXh0LmNsZWFyRGVwdGggKSB7XHJcblxyXG5cdFx0XHRcdGRlcHRoU3RlbmNpbEF0dGFjaG1lbnQuZGVwdGhDbGVhclZhbHVlID0gcmVuZGVyQ29udGV4dC5jbGVhckRlcHRoVmFsdWU7XHJcblx0XHRcdFx0ZGVwdGhTdGVuY2lsQXR0YWNobWVudC5kZXB0aExvYWRPcCA9IEdQVUxvYWRPcC5DbGVhcjtcclxuXHRcdFx0XHRkZXB0aFN0ZW5jaWxBdHRhY2htZW50LmRlcHRoU3RvcmVPcCA9IEdQVVN0b3JlT3AuU3RvcmU7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRkZXB0aFN0ZW5jaWxBdHRhY2htZW50LmRlcHRoTG9hZE9wID0gR1BVTG9hZE9wLkxvYWQ7XHJcblx0XHRcdFx0ZGVwdGhTdGVuY2lsQXR0YWNobWVudC5kZXB0aFN0b3JlT3AgPSBHUFVTdG9yZU9wLlN0b3JlO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIHJlbmRlckNvbnRleHQuc3RlbmNpbCApIHtcclxuXHJcblx0XHRcdGlmICggcmVuZGVyQ29udGV4dC5jbGVhclN0ZW5jaWwgKSB7XHJcblxyXG5cdFx0XHRcdGRlcHRoU3RlbmNpbEF0dGFjaG1lbnQuc3RlbmNpbENsZWFyVmFsdWUgPSByZW5kZXJDb250ZXh0LmNsZWFyU3RlbmNpbFZhbHVlO1xyXG5cdFx0XHRcdGRlcHRoU3RlbmNpbEF0dGFjaG1lbnQuc3RlbmNpbExvYWRPcCA9IEdQVUxvYWRPcC5DbGVhcjtcclxuXHRcdFx0XHRkZXB0aFN0ZW5jaWxBdHRhY2htZW50LnN0ZW5jaWxTdG9yZU9wID0gR1BVU3RvcmVPcC5TdG9yZTtcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdGRlcHRoU3RlbmNpbEF0dGFjaG1lbnQuc3RlbmNpbExvYWRPcCA9IEdQVUxvYWRPcC5Mb2FkO1xyXG5cdFx0XHRcdGRlcHRoU3RlbmNpbEF0dGFjaG1lbnQuc3RlbmNpbFN0b3JlT3AgPSBHUFVTdG9yZU9wLlN0b3JlO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvL1xyXG5cclxuXHRcdGNvbnN0IGVuY29kZXIgPSBkZXZpY2UuY3JlYXRlQ29tbWFuZEVuY29kZXIoIHsgbGFiZWw6ICdyZW5kZXJDb250ZXh0XycgKyByZW5kZXJDb250ZXh0LmlkIH0gKTtcclxuXHRcdGNvbnN0IGN1cnJlbnRQYXNzID0gZW5jb2Rlci5iZWdpblJlbmRlclBhc3MoIGRlc2NyaXB0b3IgKTtcclxuXHJcblx0XHQvL1xyXG5cclxuXHRcdHJlbmRlckNvbnRleHREYXRhLmRlc2NyaXB0b3IgPSBkZXNjcmlwdG9yO1xyXG5cdFx0cmVuZGVyQ29udGV4dERhdGEuZW5jb2RlciA9IGVuY29kZXI7XHJcblx0XHRyZW5kZXJDb250ZXh0RGF0YS5jdXJyZW50UGFzcyA9IGN1cnJlbnRQYXNzO1xyXG5cdFx0cmVuZGVyQ29udGV4dERhdGEuY3VycmVudFNldHMgPSB7IGF0dHJpYnV0ZXM6IHt9LCBiaW5kaW5nR3JvdXBzOiBbXSwgcGlwZWxpbmU6IG51bGwsIGluZGV4OiBudWxsIH07XHJcblx0XHRyZW5kZXJDb250ZXh0RGF0YS5yZW5kZXJCdW5kbGVzID0gW107XHJcblxyXG5cdFx0Ly9cclxuXHJcblx0XHRpZiAoIHJlbmRlckNvbnRleHQudmlld3BvcnQgKSB7XHJcblxyXG5cdFx0XHR0aGlzLnVwZGF0ZVZpZXdwb3J0KCByZW5kZXJDb250ZXh0ICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggcmVuZGVyQ29udGV4dC5zY2lzc29yICkge1xyXG5cclxuXHRcdFx0Y29uc3QgeyB4LCB5LCB3aWR0aCwgaGVpZ2h0IH0gPSByZW5kZXJDb250ZXh0LnNjaXNzb3JWYWx1ZTtcclxuXHJcblx0XHRcdGN1cnJlbnRQYXNzLnNldFNjaXNzb3JSZWN0KCB4LCB5LCB3aWR0aCwgaGVpZ2h0ICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdGZpbmlzaFJlbmRlciggcmVuZGVyQ29udGV4dCApIHtcclxuXHJcblx0XHRjb25zdCByZW5kZXJDb250ZXh0RGF0YSA9IHRoaXMuZ2V0KCByZW5kZXJDb250ZXh0ICk7XHJcblx0XHRjb25zdCBvY2NsdXNpb25RdWVyeUNvdW50ID0gcmVuZGVyQ29udGV4dC5vY2NsdXNpb25RdWVyeUNvdW50O1xyXG5cclxuXHRcdGlmICggcmVuZGVyQ29udGV4dERhdGEucmVuZGVyQnVuZGxlcy5sZW5ndGggPiAwICkge1xyXG5cclxuXHRcdFx0cmVuZGVyQ29udGV4dERhdGEuY3VycmVudFBhc3MuZXhlY3V0ZUJ1bmRsZXMoIHJlbmRlckNvbnRleHREYXRhLnJlbmRlckJ1bmRsZXMgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBvY2NsdXNpb25RdWVyeUNvdW50ID4gcmVuZGVyQ29udGV4dERhdGEub2NjbHVzaW9uUXVlcnlJbmRleCApIHtcclxuXHJcblx0XHRcdHJlbmRlckNvbnRleHREYXRhLmN1cnJlbnRQYXNzLmVuZE9jY2x1c2lvblF1ZXJ5KCk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJlbmRlckNvbnRleHREYXRhLmN1cnJlbnRQYXNzLmVuZCgpO1xyXG5cclxuXHRcdGlmICggb2NjbHVzaW9uUXVlcnlDb3VudCA+IDAgKSB7XHJcblxyXG5cdFx0XHRjb25zdCBidWZmZXJTaXplID0gb2NjbHVzaW9uUXVlcnlDb3VudCAqIDg7IC8vIDggYnl0ZSBlbnRyaWVzIGZvciBxdWVyeSByZXN1bHRzXHJcblxyXG5cdFx0XHQvL1xyXG5cclxuXHRcdFx0bGV0IHF1ZXJ5UmVzb2x2ZUJ1ZmZlciA9IHRoaXMub2NjbHVkZWRSZXNvbHZlQ2FjaGUuZ2V0KCBidWZmZXJTaXplICk7XHJcblxyXG5cdFx0XHRpZiAoIHF1ZXJ5UmVzb2x2ZUJ1ZmZlciA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRxdWVyeVJlc29sdmVCdWZmZXIgPSB0aGlzLmRldmljZS5jcmVhdGVCdWZmZXIoXHJcblx0XHRcdFx0XHR7XHJcblx0XHRcdFx0XHRcdHNpemU6IGJ1ZmZlclNpemUsXHJcblx0XHRcdFx0XHRcdHVzYWdlOiBHUFVCdWZmZXJVc2FnZS5RVUVSWV9SRVNPTFZFIHwgR1BVQnVmZmVyVXNhZ2UuQ09QWV9TUkNcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHQpO1xyXG5cclxuXHRcdFx0XHR0aGlzLm9jY2x1ZGVkUmVzb2x2ZUNhY2hlLnNldCggYnVmZmVyU2l6ZSwgcXVlcnlSZXNvbHZlQnVmZmVyICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvL1xyXG5cclxuXHRcdFx0Y29uc3QgcmVhZEJ1ZmZlciA9IHRoaXMuZGV2aWNlLmNyZWF0ZUJ1ZmZlcihcclxuXHRcdFx0XHR7XHJcblx0XHRcdFx0XHRzaXplOiBidWZmZXJTaXplLFxyXG5cdFx0XHRcdFx0dXNhZ2U6IEdQVUJ1ZmZlclVzYWdlLkNPUFlfRFNUIHwgR1BVQnVmZmVyVXNhZ2UuTUFQX1JFQURcclxuXHRcdFx0XHR9XHJcblx0XHRcdCk7XHJcblxyXG5cdFx0XHQvLyB0d28gYnVmZmVycyByZXF1aXJlZCBoZXJlIC0gV2ViR1BVIGRvZXNuJ3QgYWxsb3cgdXNhZ2Ugb2YgUVVFUllfUkVTT0xWRSAmIE1BUF9SRUFEIHRvIGJlIGNvbWJpbmVkXHJcblx0XHRcdHJlbmRlckNvbnRleHREYXRhLmVuY29kZXIucmVzb2x2ZVF1ZXJ5U2V0KCByZW5kZXJDb250ZXh0RGF0YS5vY2NsdXNpb25RdWVyeVNldCwgMCwgb2NjbHVzaW9uUXVlcnlDb3VudCwgcXVlcnlSZXNvbHZlQnVmZmVyLCAwICk7XHJcblx0XHRcdHJlbmRlckNvbnRleHREYXRhLmVuY29kZXIuY29weUJ1ZmZlclRvQnVmZmVyKCBxdWVyeVJlc29sdmVCdWZmZXIsIDAsIHJlYWRCdWZmZXIsIDAsIGJ1ZmZlclNpemUgKTtcclxuXHJcblx0XHRcdHJlbmRlckNvbnRleHREYXRhLm9jY2x1c2lvblF1ZXJ5QnVmZmVyID0gcmVhZEJ1ZmZlcjtcclxuXHJcblx0XHRcdC8vXHJcblxyXG5cdFx0XHR0aGlzLnJlc29sdmVPY2NsdWRlZEFzeW5jKCByZW5kZXJDb250ZXh0ICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMucHJlcGFyZVRpbWVzdGFtcEJ1ZmZlciggcmVuZGVyQ29udGV4dCwgcmVuZGVyQ29udGV4dERhdGEuZW5jb2RlciApO1xyXG5cclxuXHRcdHRoaXMuZGV2aWNlLnF1ZXVlLnN1Ym1pdCggWyByZW5kZXJDb250ZXh0RGF0YS5lbmNvZGVyLmZpbmlzaCgpIF0gKTtcclxuXHJcblxyXG5cdFx0Ly9cclxuXHJcblx0XHRpZiAoIHJlbmRlckNvbnRleHQudGV4dHVyZXMgIT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHRjb25zdCB0ZXh0dXJlcyA9IHJlbmRlckNvbnRleHQudGV4dHVyZXM7XHJcblxyXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCB0ZXh0dXJlcy5sZW5ndGg7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdGNvbnN0IHRleHR1cmUgPSB0ZXh0dXJlc1sgaSBdO1xyXG5cclxuXHRcdFx0XHRpZiAoIHRleHR1cmUuZ2VuZXJhdGVNaXBtYXBzID09PSB0cnVlICkge1xyXG5cclxuXHRcdFx0XHRcdHRoaXMudGV4dHVyZVV0aWxzLmdlbmVyYXRlTWlwbWFwcyggdGV4dHVyZSApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdGlzT2NjbHVkZWQoIHJlbmRlckNvbnRleHQsIG9iamVjdCApIHtcclxuXHJcblx0XHRjb25zdCByZW5kZXJDb250ZXh0RGF0YSA9IHRoaXMuZ2V0KCByZW5kZXJDb250ZXh0ICk7XHJcblxyXG5cdFx0cmV0dXJuIHJlbmRlckNvbnRleHREYXRhLm9jY2x1ZGVkICYmIHJlbmRlckNvbnRleHREYXRhLm9jY2x1ZGVkLmhhcyggb2JqZWN0ICk7XHJcblxyXG5cdH1cclxuXHJcblx0YXN5bmMgcmVzb2x2ZU9jY2x1ZGVkQXN5bmMoIHJlbmRlckNvbnRleHQgKSB7XHJcblxyXG5cdFx0Y29uc3QgcmVuZGVyQ29udGV4dERhdGEgPSB0aGlzLmdldCggcmVuZGVyQ29udGV4dCApO1xyXG5cclxuXHRcdC8vIGhhbmRsZSBvY2NsdXNpb24gcXVlcnkgcmVzdWx0c1xyXG5cclxuXHRcdGNvbnN0IHsgY3VycmVudE9jY2x1c2lvblF1ZXJ5QnVmZmVyLCBjdXJyZW50T2NjbHVzaW9uUXVlcnlPYmplY3RzIH0gPSByZW5kZXJDb250ZXh0RGF0YTtcclxuXHJcblx0XHRpZiAoIGN1cnJlbnRPY2NsdXNpb25RdWVyeUJ1ZmZlciAmJiBjdXJyZW50T2NjbHVzaW9uUXVlcnlPYmplY3RzICkge1xyXG5cclxuXHRcdFx0Y29uc3Qgb2NjbHVkZWQgPSBuZXcgV2Vha1NldCgpO1xyXG5cclxuXHRcdFx0cmVuZGVyQ29udGV4dERhdGEuY3VycmVudE9jY2x1c2lvblF1ZXJ5T2JqZWN0cyA9IG51bGw7XHJcblx0XHRcdHJlbmRlckNvbnRleHREYXRhLmN1cnJlbnRPY2NsdXNpb25RdWVyeUJ1ZmZlciA9IG51bGw7XHJcblxyXG5cdFx0XHRhd2FpdCBjdXJyZW50T2NjbHVzaW9uUXVlcnlCdWZmZXIubWFwQXN5bmMoIEdQVU1hcE1vZGUuUkVBRCApO1xyXG5cclxuXHRcdFx0Y29uc3QgYnVmZmVyID0gY3VycmVudE9jY2x1c2lvblF1ZXJ5QnVmZmVyLmdldE1hcHBlZFJhbmdlKCk7XHJcblx0XHRcdGNvbnN0IHJlc3VsdHMgPSBuZXcgQmlnVWludDY0QXJyYXkoIGJ1ZmZlciApO1xyXG5cclxuXHRcdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgY3VycmVudE9jY2x1c2lvblF1ZXJ5T2JqZWN0cy5sZW5ndGg7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdGlmICggcmVzdWx0c1sgaSBdICE9PSBCaWdJbnQoIDAgKSApIHtcclxuXHJcblx0XHRcdFx0XHRvY2NsdWRlZC5hZGQoIGN1cnJlbnRPY2NsdXNpb25RdWVyeU9iamVjdHNbIGkgXSApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRjdXJyZW50T2NjbHVzaW9uUXVlcnlCdWZmZXIuZGVzdHJveSgpO1xyXG5cclxuXHRcdFx0cmVuZGVyQ29udGV4dERhdGEub2NjbHVkZWQgPSBvY2NsdWRlZDtcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0dXBkYXRlVmlld3BvcnQoIHJlbmRlckNvbnRleHQgKSB7XHJcblxyXG5cdFx0Y29uc3QgeyBjdXJyZW50UGFzcyB9ID0gdGhpcy5nZXQoIHJlbmRlckNvbnRleHQgKTtcclxuXHRcdGNvbnN0IHsgeCwgeSwgd2lkdGgsIGhlaWdodCwgbWluRGVwdGgsIG1heERlcHRoIH0gPSByZW5kZXJDb250ZXh0LnZpZXdwb3J0VmFsdWU7XHJcblxyXG5cdFx0Y3VycmVudFBhc3Muc2V0Vmlld3BvcnQoIHgsIHksIHdpZHRoLCBoZWlnaHQsIG1pbkRlcHRoLCBtYXhEZXB0aCApO1xyXG5cclxuXHR9XHJcblxyXG5cdGNsZWFyKCBjb2xvciwgZGVwdGgsIHN0ZW5jaWwsIHJlbmRlclRhcmdldERhdGEgPSBudWxsICkge1xyXG5cclxuXHRcdGNvbnN0IGRldmljZSA9IHRoaXMuZGV2aWNlO1xyXG5cdFx0Y29uc3QgcmVuZGVyZXIgPSB0aGlzLnJlbmRlcmVyO1xyXG5cclxuXHRcdGxldCBjb2xvckF0dGFjaG1lbnRzID0gW107XHJcblxyXG5cdFx0bGV0IGRlcHRoU3RlbmNpbEF0dGFjaG1lbnQ7XHJcblx0XHRsZXQgY2xlYXJWYWx1ZTtcclxuXHJcblx0XHRsZXQgc3VwcG9ydHNEZXB0aDtcclxuXHRcdGxldCBzdXBwb3J0c1N0ZW5jaWw7XHJcblxyXG5cdFx0aWYgKCBjb2xvciApIHtcclxuXHJcblx0XHRcdGNvbnN0IGNsZWFyQ29sb3IgPSB0aGlzLmdldENsZWFyQ29sb3IoKTtcclxuXHJcblx0XHRcdGlmICggdGhpcy5yZW5kZXJlci5hbHBoYSA9PT0gdHJ1ZSApIHtcclxuXHJcblx0XHRcdFx0Ly8gcHJlbXVsdGlwbHkgYWxwaGFcclxuXHJcblx0XHRcdFx0Y29uc3QgYSA9IGNsZWFyQ29sb3IuYTtcclxuXHJcblx0XHRcdFx0Y2xlYXJWYWx1ZSA9IHsgcjogY2xlYXJDb2xvci5yICogYSwgZzogY2xlYXJDb2xvci5nICogYSwgYjogY2xlYXJDb2xvci5iICogYSwgYTogYSB9O1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0Y2xlYXJWYWx1ZSA9IHsgcjogY2xlYXJDb2xvci5yLCBnOiBjbGVhckNvbG9yLmcsIGI6IGNsZWFyQ29sb3IuYiwgYTogY2xlYXJDb2xvci5hIH07XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggcmVuZGVyVGFyZ2V0RGF0YSA9PT0gbnVsbCApIHtcclxuXHJcblx0XHRcdHN1cHBvcnRzRGVwdGggPSByZW5kZXJlci5kZXB0aDtcclxuXHRcdFx0c3VwcG9ydHNTdGVuY2lsID0gcmVuZGVyZXIuc3RlbmNpbDtcclxuXHJcblx0XHRcdGNvbnN0IGRlc2NyaXB0b3IgPSB0aGlzLl9nZXREZWZhdWx0UmVuZGVyUGFzc0Rlc2NyaXB0b3IoKTtcclxuXHJcblx0XHRcdGlmICggY29sb3IgKSB7XHJcblxyXG5cdFx0XHRcdGNvbG9yQXR0YWNobWVudHMgPSBkZXNjcmlwdG9yLmNvbG9yQXR0YWNobWVudHM7XHJcblxyXG5cdFx0XHRcdGNvbnN0IGNvbG9yQXR0YWNobWVudCA9IGNvbG9yQXR0YWNobWVudHNbIDAgXTtcclxuXHJcblx0XHRcdFx0Y29sb3JBdHRhY2htZW50LmNsZWFyVmFsdWUgPSBjbGVhclZhbHVlO1xyXG5cdFx0XHRcdGNvbG9yQXR0YWNobWVudC5sb2FkT3AgPSBHUFVMb2FkT3AuQ2xlYXI7XHJcblx0XHRcdFx0Y29sb3JBdHRhY2htZW50LnN0b3JlT3AgPSBHUFVTdG9yZU9wLlN0b3JlO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKCBzdXBwb3J0c0RlcHRoIHx8IHN1cHBvcnRzU3RlbmNpbCApIHtcclxuXHJcblx0XHRcdFx0ZGVwdGhTdGVuY2lsQXR0YWNobWVudCA9IGRlc2NyaXB0b3IuZGVwdGhTdGVuY2lsQXR0YWNobWVudDtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0c3VwcG9ydHNEZXB0aCA9IHJlbmRlclRhcmdldERhdGEuZGVwdGg7XHJcblx0XHRcdHN1cHBvcnRzU3RlbmNpbCA9IHJlbmRlclRhcmdldERhdGEuc3RlbmNpbDtcclxuXHJcblx0XHRcdGlmICggY29sb3IgKSB7XHJcblxyXG5cdFx0XHRcdGZvciAoIGNvbnN0IHRleHR1cmUgb2YgcmVuZGVyVGFyZ2V0RGF0YS50ZXh0dXJlcyApIHtcclxuXHJcblx0XHRcdFx0XHRjb25zdCB0ZXh0dXJlRGF0YSA9IHRoaXMuZ2V0KCB0ZXh0dXJlICk7XHJcblx0XHRcdFx0XHRjb25zdCB0ZXh0dXJlVmlldyA9IHRleHR1cmVEYXRhLnRleHR1cmUuY3JlYXRlVmlldygpO1xyXG5cclxuXHRcdFx0XHRcdGxldCB2aWV3LCByZXNvbHZlVGFyZ2V0O1xyXG5cclxuXHRcdFx0XHRcdGlmICggdGV4dHVyZURhdGEubXNhYVRleHR1cmUgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0XHRcdHZpZXcgPSB0ZXh0dXJlRGF0YS5tc2FhVGV4dHVyZS5jcmVhdGVWaWV3KCk7XHJcblx0XHRcdFx0XHRcdHJlc29sdmVUYXJnZXQgPSB0ZXh0dXJlVmlldztcclxuXHJcblx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdFx0dmlldyA9IHRleHR1cmVWaWV3O1xyXG5cdFx0XHRcdFx0XHRyZXNvbHZlVGFyZ2V0ID0gdW5kZWZpbmVkO1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRjb2xvckF0dGFjaG1lbnRzLnB1c2goIHtcclxuXHRcdFx0XHRcdFx0dmlldyxcclxuXHRcdFx0XHRcdFx0cmVzb2x2ZVRhcmdldCxcclxuXHRcdFx0XHRcdFx0Y2xlYXJWYWx1ZSxcclxuXHRcdFx0XHRcdFx0bG9hZE9wOiBHUFVMb2FkT3AuQ2xlYXIsXHJcblx0XHRcdFx0XHRcdHN0b3JlT3A6IEdQVVN0b3JlT3AuU3RvcmVcclxuXHRcdFx0XHRcdH0gKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKCBzdXBwb3J0c0RlcHRoIHx8IHN1cHBvcnRzU3RlbmNpbCApIHtcclxuXHJcblx0XHRcdFx0Y29uc3QgZGVwdGhUZXh0dXJlRGF0YSA9IHRoaXMuZ2V0KCByZW5kZXJUYXJnZXREYXRhLmRlcHRoVGV4dHVyZSApO1xyXG5cclxuXHRcdFx0XHRkZXB0aFN0ZW5jaWxBdHRhY2htZW50ID0ge1xyXG5cdFx0XHRcdFx0dmlldzogZGVwdGhUZXh0dXJlRGF0YS50ZXh0dXJlLmNyZWF0ZVZpZXcoKVxyXG5cdFx0XHRcdH07XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vXHJcblxyXG5cdFx0aWYgKCBzdXBwb3J0c0RlcHRoICkge1xyXG5cclxuXHRcdFx0aWYgKCBkZXB0aCApIHtcclxuXHJcblx0XHRcdFx0ZGVwdGhTdGVuY2lsQXR0YWNobWVudC5kZXB0aExvYWRPcCA9IEdQVUxvYWRPcC5DbGVhcjtcclxuXHRcdFx0XHRkZXB0aFN0ZW5jaWxBdHRhY2htZW50LmRlcHRoQ2xlYXJWYWx1ZSA9IHJlbmRlcmVyLmdldENsZWFyRGVwdGgoKTtcclxuXHRcdFx0XHRkZXB0aFN0ZW5jaWxBdHRhY2htZW50LmRlcHRoU3RvcmVPcCA9IEdQVVN0b3JlT3AuU3RvcmU7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRkZXB0aFN0ZW5jaWxBdHRhY2htZW50LmRlcHRoTG9hZE9wID0gR1BVTG9hZE9wLkxvYWQ7XHJcblx0XHRcdFx0ZGVwdGhTdGVuY2lsQXR0YWNobWVudC5kZXB0aFN0b3JlT3AgPSBHUFVTdG9yZU9wLlN0b3JlO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvL1xyXG5cclxuXHRcdGlmICggc3VwcG9ydHNTdGVuY2lsICkge1xyXG5cclxuXHRcdFx0aWYgKCBzdGVuY2lsICkge1xyXG5cclxuXHRcdFx0XHRkZXB0aFN0ZW5jaWxBdHRhY2htZW50LnN0ZW5jaWxMb2FkT3AgPSBHUFVMb2FkT3AuQ2xlYXI7XHJcblx0XHRcdFx0ZGVwdGhTdGVuY2lsQXR0YWNobWVudC5zdGVuY2lsQ2xlYXJWYWx1ZSA9IHJlbmRlcmVyLmdldENsZWFyU3RlbmNpbCgpO1xyXG5cdFx0XHRcdGRlcHRoU3RlbmNpbEF0dGFjaG1lbnQuc3RlbmNpbFN0b3JlT3AgPSBHUFVTdG9yZU9wLlN0b3JlO1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0ZGVwdGhTdGVuY2lsQXR0YWNobWVudC5zdGVuY2lsTG9hZE9wID0gR1BVTG9hZE9wLkxvYWQ7XHJcblx0XHRcdFx0ZGVwdGhTdGVuY2lsQXR0YWNobWVudC5zdGVuY2lsU3RvcmVPcCA9IEdQVVN0b3JlT3AuU3RvcmU7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vXHJcblxyXG5cdFx0Y29uc3QgZW5jb2RlciA9IGRldmljZS5jcmVhdGVDb21tYW5kRW5jb2Rlcigge30gKTtcclxuXHRcdGNvbnN0IGN1cnJlbnRQYXNzID0gZW5jb2Rlci5iZWdpblJlbmRlclBhc3MoIHtcclxuXHRcdFx0Y29sb3JBdHRhY2htZW50cyxcclxuXHRcdFx0ZGVwdGhTdGVuY2lsQXR0YWNobWVudFxyXG5cdFx0fSApO1xyXG5cclxuXHRcdGN1cnJlbnRQYXNzLmVuZCgpO1xyXG5cclxuXHRcdGRldmljZS5xdWV1ZS5zdWJtaXQoIFsgZW5jb2Rlci5maW5pc2goKSBdICk7XHJcblxyXG5cdH1cclxuXHJcblx0Ly8gY29tcHV0ZVxyXG5cclxuXHRiZWdpbkNvbXB1dGUoIGNvbXB1dGVHcm91cCApIHtcclxuXHJcblx0XHRjb25zdCBncm91cEdQVSA9IHRoaXMuZ2V0KCBjb21wdXRlR3JvdXAgKTtcclxuXHJcblxyXG5cdFx0Y29uc3QgZGVzY3JpcHRvciA9IHt9O1xyXG5cclxuXHRcdHRoaXMuaW5pdFRpbWVzdGFtcFF1ZXJ5KCBjb21wdXRlR3JvdXAsIGRlc2NyaXB0b3IgKTtcclxuXHJcblx0XHRncm91cEdQVS5jbWRFbmNvZGVyR1BVID0gdGhpcy5kZXZpY2UuY3JlYXRlQ29tbWFuZEVuY29kZXIoKTtcclxuXHJcblx0XHRncm91cEdQVS5wYXNzRW5jb2RlckdQVSA9IGdyb3VwR1BVLmNtZEVuY29kZXJHUFUuYmVnaW5Db21wdXRlUGFzcyggZGVzY3JpcHRvciApO1xyXG5cclxuXHR9XHJcblxyXG5cdGNvbXB1dGUoIGNvbXB1dGVHcm91cCwgY29tcHV0ZU5vZGUsIGJpbmRpbmdzLCBwaXBlbGluZSApIHtcclxuXHJcblx0XHRjb25zdCB7IHBhc3NFbmNvZGVyR1BVIH0gPSB0aGlzLmdldCggY29tcHV0ZUdyb3VwICk7XHJcblxyXG5cdFx0Ly8gcGlwZWxpbmVcclxuXHJcblx0XHRjb25zdCBwaXBlbGluZUdQVSA9IHRoaXMuZ2V0KCBwaXBlbGluZSApLnBpcGVsaW5lO1xyXG5cdFx0cGFzc0VuY29kZXJHUFUuc2V0UGlwZWxpbmUoIHBpcGVsaW5lR1BVICk7XHJcblxyXG5cdFx0Ly8gYmluZCBncm91cHNcclxuXHJcblx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSBiaW5kaW5ncy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xyXG5cclxuXHRcdFx0Y29uc3QgYmluZEdyb3VwID0gYmluZGluZ3NbIGkgXTtcclxuXHRcdFx0Y29uc3QgYmluZGluZ3NEYXRhID0gdGhpcy5nZXQoIGJpbmRHcm91cCApO1xyXG5cclxuXHRcdFx0cGFzc0VuY29kZXJHUFUuc2V0QmluZEdyb3VwKCBpLCBiaW5kaW5nc0RhdGEuZ3JvdXAgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Y29uc3QgbWF4Q29tcHV0ZVdvcmtncm91cHNQZXJEaW1lbnNpb24gPSB0aGlzLmRldmljZS5saW1pdHMubWF4Q29tcHV0ZVdvcmtncm91cHNQZXJEaW1lbnNpb247XHJcblxyXG5cdFx0Y29uc3QgY29tcHV0ZU5vZGVEYXRhID0gdGhpcy5nZXQoIGNvbXB1dGVOb2RlICk7XHJcblxyXG5cdFx0aWYgKCBjb21wdXRlTm9kZURhdGEuZGlzcGF0Y2hTaXplID09PSB1bmRlZmluZWQgKSBjb21wdXRlTm9kZURhdGEuZGlzcGF0Y2hTaXplID0geyB4OiAwLCB5OiAxLCB6OiAxIH07XHJcblxyXG5cdFx0Y29uc3QgeyBkaXNwYXRjaFNpemUgfSA9IGNvbXB1dGVOb2RlRGF0YTtcclxuXHJcblx0XHRpZiAoIGNvbXB1dGVOb2RlLmRpc3BhdGNoQ291bnQgPiBtYXhDb21wdXRlV29ya2dyb3Vwc1BlckRpbWVuc2lvbiApIHtcclxuXHJcblx0XHRcdGRpc3BhdGNoU2l6ZS54ID0gTWF0aC5taW4oIGNvbXB1dGVOb2RlLmRpc3BhdGNoQ291bnQsIG1heENvbXB1dGVXb3JrZ3JvdXBzUGVyRGltZW5zaW9uICk7XHJcblx0XHRcdGRpc3BhdGNoU2l6ZS55ID0gTWF0aC5jZWlsKCBjb21wdXRlTm9kZS5kaXNwYXRjaENvdW50IC8gbWF4Q29tcHV0ZVdvcmtncm91cHNQZXJEaW1lbnNpb24gKTtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0ZGlzcGF0Y2hTaXplLnggPSBjb21wdXRlTm9kZS5kaXNwYXRjaENvdW50O1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRwYXNzRW5jb2RlckdQVS5kaXNwYXRjaFdvcmtncm91cHMoXHJcblx0XHRcdGRpc3BhdGNoU2l6ZS54LFxyXG5cdFx0XHRkaXNwYXRjaFNpemUueSxcclxuXHRcdFx0ZGlzcGF0Y2hTaXplLnpcclxuXHRcdCk7XHJcblxyXG5cdH1cclxuXHJcblx0ZmluaXNoQ29tcHV0ZSggY29tcHV0ZUdyb3VwICkge1xyXG5cclxuXHRcdGNvbnN0IGdyb3VwRGF0YSA9IHRoaXMuZ2V0KCBjb21wdXRlR3JvdXAgKTtcclxuXHJcblx0XHRncm91cERhdGEucGFzc0VuY29kZXJHUFUuZW5kKCk7XHJcblxyXG5cdFx0dGhpcy5wcmVwYXJlVGltZXN0YW1wQnVmZmVyKCBjb21wdXRlR3JvdXAsIGdyb3VwRGF0YS5jbWRFbmNvZGVyR1BVICk7XHJcblxyXG5cdFx0dGhpcy5kZXZpY2UucXVldWUuc3VibWl0KCBbIGdyb3VwRGF0YS5jbWRFbmNvZGVyR1BVLmZpbmlzaCgpIF0gKTtcclxuXHJcblx0fVxyXG5cclxuXHRhc3luYyB3YWl0Rm9yR1BVKCkge1xyXG5cclxuXHRcdGF3YWl0IHRoaXMuZGV2aWNlLnF1ZXVlLm9uU3VibWl0dGVkV29ya0RvbmUoKTtcclxuXHJcblx0fVxyXG5cclxuXHQvLyByZW5kZXIgb2JqZWN0XHJcblxyXG5cdGRyYXcoIHJlbmRlck9iamVjdCwgaW5mbyApIHtcclxuXHJcblx0XHRjb25zdCB7IG9iamVjdCwgY29udGV4dCwgcGlwZWxpbmUgfSA9IHJlbmRlck9iamVjdDtcclxuXHRcdGNvbnN0IGJpbmRpbmdzID0gcmVuZGVyT2JqZWN0LmdldEJpbmRpbmdzKCk7XHJcblx0XHRjb25zdCByZW5kZXJDb250ZXh0RGF0YSA9IHRoaXMuZ2V0KCBjb250ZXh0ICk7XHJcblx0XHRjb25zdCBwaXBlbGluZUdQVSA9IHRoaXMuZ2V0KCBwaXBlbGluZSApLnBpcGVsaW5lO1xyXG5cdFx0Y29uc3QgY3VycmVudFNldHMgPSByZW5kZXJDb250ZXh0RGF0YS5jdXJyZW50U2V0cztcclxuXHRcdGNvbnN0IHBhc3NFbmNvZGVyR1BVID0gcmVuZGVyQ29udGV4dERhdGEuY3VycmVudFBhc3M7XHJcblxyXG5cdFx0Y29uc3QgZHJhd1BhcmFtcyA9IHJlbmRlck9iamVjdC5nZXREcmF3UGFyYW1ldGVycygpO1xyXG5cclxuXHRcdGlmICggZHJhd1BhcmFtcyA9PT0gbnVsbCApIHJldHVybjtcclxuXHJcblx0XHQvLyBwaXBlbGluZVxyXG5cclxuXHRcdGlmICggY3VycmVudFNldHMucGlwZWxpbmUgIT09IHBpcGVsaW5lR1BVICkge1xyXG5cclxuXHRcdFx0cGFzc0VuY29kZXJHUFUuc2V0UGlwZWxpbmUoIHBpcGVsaW5lR1BVICk7XHJcblxyXG5cdFx0XHRjdXJyZW50U2V0cy5waXBlbGluZSA9IHBpcGVsaW5lR1BVO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvLyBiaW5kIGdyb3Vwc1xyXG5cclxuXHRcdGNvbnN0IGN1cnJlbnRCaW5kaW5nR3JvdXBzID0gY3VycmVudFNldHMuYmluZGluZ0dyb3VwcztcclxuXHJcblx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSBiaW5kaW5ncy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xyXG5cclxuXHRcdFx0Y29uc3QgYmluZEdyb3VwID0gYmluZGluZ3NbIGkgXTtcclxuXHRcdFx0Y29uc3QgYmluZGluZ3NEYXRhID0gdGhpcy5nZXQoIGJpbmRHcm91cCApO1xyXG5cclxuXHRcdFx0aWYgKCBjdXJyZW50QmluZGluZ0dyb3Vwc1sgYmluZEdyb3VwLmluZGV4IF0gIT09IGJpbmRHcm91cC5pZCApIHtcclxuXHJcblx0XHRcdFx0cGFzc0VuY29kZXJHUFUuc2V0QmluZEdyb3VwKCBiaW5kR3JvdXAuaW5kZXgsIGJpbmRpbmdzRGF0YS5ncm91cCApO1xyXG5cdFx0XHRcdGN1cnJlbnRCaW5kaW5nR3JvdXBzWyBiaW5kR3JvdXAuaW5kZXggXSA9IGJpbmRHcm91cC5pZDtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gYXR0cmlidXRlc1xyXG5cclxuXHRcdGNvbnN0IGluZGV4ID0gcmVuZGVyT2JqZWN0LmdldEluZGV4KCk7XHJcblxyXG5cdFx0Y29uc3QgaGFzSW5kZXggPSAoIGluZGV4ICE9PSBudWxsICk7XHJcblxyXG5cdFx0Ly8gaW5kZXhcclxuXHJcblx0XHRpZiAoIGhhc0luZGV4ID09PSB0cnVlICkge1xyXG5cclxuXHRcdFx0aWYgKCBjdXJyZW50U2V0cy5pbmRleCAhPT0gaW5kZXggKSB7XHJcblxyXG5cdFx0XHRcdGNvbnN0IGJ1ZmZlciA9IHRoaXMuZ2V0KCBpbmRleCApLmJ1ZmZlcjtcclxuXHRcdFx0XHRjb25zdCBpbmRleEZvcm1hdCA9ICggaW5kZXguYXJyYXkgaW5zdGFuY2VvZiBVaW50MTZBcnJheSApID8gR1BVSW5kZXhGb3JtYXQuVWludDE2IDogR1BVSW5kZXhGb3JtYXQuVWludDMyO1xyXG5cclxuXHRcdFx0XHRwYXNzRW5jb2RlckdQVS5zZXRJbmRleEJ1ZmZlciggYnVmZmVyLCBpbmRleEZvcm1hdCApO1xyXG5cclxuXHRcdFx0XHRjdXJyZW50U2V0cy5pbmRleCA9IGluZGV4O1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvLyB2ZXJ0ZXggYnVmZmVyc1xyXG5cclxuXHRcdGNvbnN0IHZlcnRleEJ1ZmZlcnMgPSByZW5kZXJPYmplY3QuZ2V0VmVydGV4QnVmZmVycygpO1xyXG5cclxuXHRcdGZvciAoIGxldCBpID0gMCwgbCA9IHZlcnRleEJ1ZmZlcnMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcclxuXHJcblx0XHRcdGNvbnN0IHZlcnRleEJ1ZmZlciA9IHZlcnRleEJ1ZmZlcnNbIGkgXTtcclxuXHJcblx0XHRcdGlmICggY3VycmVudFNldHMuYXR0cmlidXRlc1sgaSBdICE9PSB2ZXJ0ZXhCdWZmZXIgKSB7XHJcblxyXG5cdFx0XHRcdGNvbnN0IGJ1ZmZlciA9IHRoaXMuZ2V0KCB2ZXJ0ZXhCdWZmZXIgKS5idWZmZXI7XHJcblx0XHRcdFx0cGFzc0VuY29kZXJHUFUuc2V0VmVydGV4QnVmZmVyKCBpLCBidWZmZXIgKTtcclxuXHJcblx0XHRcdFx0Y3VycmVudFNldHMuYXR0cmlidXRlc1sgaSBdID0gdmVydGV4QnVmZmVyO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvLyBvY2NsdXNpb24gcXVlcmllcyAtIGhhbmRsZSBtdWx0aXBsZSBjb25zZWN1dGl2ZSBkcmF3IGNhbGxzIGZvciBhbiBvYmplY3RcclxuXHJcblx0XHRpZiAoIHJlbmRlckNvbnRleHREYXRhLm9jY2x1c2lvblF1ZXJ5U2V0ICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRjb25zdCBsYXN0T2JqZWN0ID0gcmVuZGVyQ29udGV4dERhdGEubGFzdE9jY2x1c2lvbk9iamVjdDtcclxuXHJcblx0XHRcdGlmICggbGFzdE9iamVjdCAhPT0gb2JqZWN0ICkge1xyXG5cclxuXHRcdFx0XHRpZiAoIGxhc3RPYmplY3QgIT09IG51bGwgJiYgbGFzdE9iamVjdC5vY2NsdXNpb25UZXN0ID09PSB0cnVlICkge1xyXG5cclxuXHRcdFx0XHRcdHBhc3NFbmNvZGVyR1BVLmVuZE9jY2x1c2lvblF1ZXJ5KCk7XHJcblx0XHRcdFx0XHRyZW5kZXJDb250ZXh0RGF0YS5vY2NsdXNpb25RdWVyeUluZGV4ICsrO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGlmICggb2JqZWN0Lm9jY2x1c2lvblRlc3QgPT09IHRydWUgKSB7XHJcblxyXG5cdFx0XHRcdFx0cGFzc0VuY29kZXJHUFUuYmVnaW5PY2NsdXNpb25RdWVyeSggcmVuZGVyQ29udGV4dERhdGEub2NjbHVzaW9uUXVlcnlJbmRleCApO1xyXG5cdFx0XHRcdFx0cmVuZGVyQ29udGV4dERhdGEub2NjbHVzaW9uUXVlcnlPYmplY3RzWyByZW5kZXJDb250ZXh0RGF0YS5vY2NsdXNpb25RdWVyeUluZGV4IF0gPSBvYmplY3Q7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0cmVuZGVyQ29udGV4dERhdGEubGFzdE9jY2x1c2lvbk9iamVjdCA9IG9iamVjdDtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gZHJhd1xyXG5cclxuXHRcdGlmICggb2JqZWN0LmlzQmF0Y2hlZE1lc2ggPT09IHRydWUgKSB7XHJcblxyXG5cdFx0XHRjb25zdCBzdGFydHMgPSBvYmplY3QuX211bHRpRHJhd1N0YXJ0cztcclxuXHRcdFx0Y29uc3QgY291bnRzID0gb2JqZWN0Ll9tdWx0aURyYXdDb3VudHM7XHJcblx0XHRcdGNvbnN0IGRyYXdDb3VudCA9IG9iamVjdC5fbXVsdGlEcmF3Q291bnQ7XHJcblx0XHRcdGNvbnN0IGRyYXdJbnN0YW5jZXMgPSBvYmplY3QuX211bHRpRHJhd0luc3RhbmNlcztcclxuXHJcblx0XHRcdGZvciAoIGxldCBpID0gMDsgaSA8IGRyYXdDb3VudDsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0Y29uc3QgY291bnQgPSBkcmF3SW5zdGFuY2VzID8gZHJhd0luc3RhbmNlc1sgaSBdIDogMTtcclxuXHRcdFx0XHRjb25zdCBmaXJzdEluc3RhbmNlID0gY291bnQgPiAxID8gMCA6IGk7XHJcblxyXG5cdFx0XHRcdGlmICggaGFzSW5kZXggPT09IHRydWUgKSB7XHJcblxyXG5cdFx0XHRcdFx0cGFzc0VuY29kZXJHUFUuZHJhd0luZGV4ZWQoIGNvdW50c1sgaSBdLCBjb3VudCwgc3RhcnRzWyBpIF0gLyBpbmRleC5hcnJheS5CWVRFU19QRVJfRUxFTUVOVCwgMCwgZmlyc3RJbnN0YW5jZSApO1xyXG5cclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdHBhc3NFbmNvZGVyR1BVLmRyYXcoIGNvdW50c1sgaSBdLCBjb3VudCwgc3RhcnRzWyBpIF0sIGZpcnN0SW5zdGFuY2UgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH0gZWxzZSBpZiAoIGhhc0luZGV4ID09PSB0cnVlICkge1xyXG5cclxuXHRcdFx0Y29uc3QgeyB2ZXJ0ZXhDb3VudDogaW5kZXhDb3VudCwgaW5zdGFuY2VDb3VudCwgZmlyc3RWZXJ0ZXg6IGZpcnN0SW5kZXggfSA9IGRyYXdQYXJhbXM7XHJcblxyXG5cdFx0XHRjb25zdCBpbmRpcmVjdCA9IHJlbmRlck9iamVjdC5nZXRJbmRpcmVjdCgpO1xyXG5cclxuXHRcdFx0aWYgKCBpbmRpcmVjdCAhPT0gbnVsbCApIHtcclxuXHJcblx0XHRcdFx0Y29uc3QgYnVmZmVyID0gdGhpcy5nZXQoIGluZGlyZWN0ICkuYnVmZmVyO1xyXG5cclxuXHRcdFx0XHRwYXNzRW5jb2RlckdQVS5kcmF3SW5kZXhlZEluZGlyZWN0KCBidWZmZXIsIDAgKTtcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdHBhc3NFbmNvZGVyR1BVLmRyYXdJbmRleGVkKCBpbmRleENvdW50LCBpbnN0YW5jZUNvdW50LCBmaXJzdEluZGV4LCAwLCAwICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpbmZvLnVwZGF0ZSggb2JqZWN0LCBpbmRleENvdW50LCBpbnN0YW5jZUNvdW50ICk7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdGNvbnN0IHsgdmVydGV4Q291bnQsIGluc3RhbmNlQ291bnQsIGZpcnN0VmVydGV4IH0gPSBkcmF3UGFyYW1zO1xyXG5cclxuXHRcdFx0Y29uc3QgaW5kaXJlY3QgPSByZW5kZXJPYmplY3QuZ2V0SW5kaXJlY3QoKTtcclxuXHJcblx0XHRcdGlmICggaW5kaXJlY3QgIT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHRcdGNvbnN0IGJ1ZmZlciA9IHRoaXMuZ2V0KCBpbmRpcmVjdCApLmJ1ZmZlcjtcclxuXHJcblx0XHRcdFx0cGFzc0VuY29kZXJHUFUuZHJhd0luZGlyZWN0KCBidWZmZXIsIDAgKTtcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdHBhc3NFbmNvZGVyR1BVLmRyYXcoIHZlcnRleENvdW50LCBpbnN0YW5jZUNvdW50LCBmaXJzdFZlcnRleCwgMCApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aW5mby51cGRhdGUoIG9iamVjdCwgdmVydGV4Q291bnQsIGluc3RhbmNlQ291bnQgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0Ly8gY2FjaGUga2V5XHJcblxyXG5cdG5lZWRzUmVuZGVyVXBkYXRlKCByZW5kZXJPYmplY3QgKSB7XHJcblxyXG5cdFx0Y29uc3QgZGF0YSA9IHRoaXMuZ2V0KCByZW5kZXJPYmplY3QgKTtcclxuXHJcblx0XHRjb25zdCB7IG9iamVjdCwgbWF0ZXJpYWwgfSA9IHJlbmRlck9iamVjdDtcclxuXHJcblx0XHRjb25zdCB1dGlscyA9IHRoaXMudXRpbHM7XHJcblxyXG5cdFx0Y29uc3Qgc2FtcGxlQ291bnQgPSB1dGlscy5nZXRTYW1wbGVDb3VudFJlbmRlckNvbnRleHQoIHJlbmRlck9iamVjdC5jb250ZXh0ICk7XHJcblx0XHRjb25zdCBjb2xvclNwYWNlID0gdXRpbHMuZ2V0Q3VycmVudENvbG9yU3BhY2UoIHJlbmRlck9iamVjdC5jb250ZXh0ICk7XHJcblx0XHRjb25zdCBjb2xvckZvcm1hdCA9IHV0aWxzLmdldEN1cnJlbnRDb2xvckZvcm1hdCggcmVuZGVyT2JqZWN0LmNvbnRleHQgKTtcclxuXHRcdGNvbnN0IGRlcHRoU3RlbmNpbEZvcm1hdCA9IHV0aWxzLmdldEN1cnJlbnREZXB0aFN0ZW5jaWxGb3JtYXQoIHJlbmRlck9iamVjdC5jb250ZXh0ICk7XHJcblx0XHRjb25zdCBwcmltaXRpdmVUb3BvbG9neSA9IHV0aWxzLmdldFByaW1pdGl2ZVRvcG9sb2d5KCBvYmplY3QsIG1hdGVyaWFsICk7XHJcblxyXG5cdFx0bGV0IG5lZWRzVXBkYXRlID0gZmFsc2U7XHJcblxyXG5cdFx0aWYgKCBkYXRhLm1hdGVyaWFsICE9PSBtYXRlcmlhbCB8fCBkYXRhLm1hdGVyaWFsVmVyc2lvbiAhPT0gbWF0ZXJpYWwudmVyc2lvbiB8fFxyXG5cdFx0XHRkYXRhLnRyYW5zcGFyZW50ICE9PSBtYXRlcmlhbC50cmFuc3BhcmVudCB8fCBkYXRhLmJsZW5kaW5nICE9PSBtYXRlcmlhbC5ibGVuZGluZyB8fCBkYXRhLnByZW11bHRpcGxpZWRBbHBoYSAhPT0gbWF0ZXJpYWwucHJlbXVsdGlwbGllZEFscGhhIHx8XHJcblx0XHRcdGRhdGEuYmxlbmRTcmMgIT09IG1hdGVyaWFsLmJsZW5kU3JjIHx8IGRhdGEuYmxlbmREc3QgIT09IG1hdGVyaWFsLmJsZW5kRHN0IHx8IGRhdGEuYmxlbmRFcXVhdGlvbiAhPT0gbWF0ZXJpYWwuYmxlbmRFcXVhdGlvbiB8fFxyXG5cdFx0XHRkYXRhLmJsZW5kU3JjQWxwaGEgIT09IG1hdGVyaWFsLmJsZW5kU3JjQWxwaGEgfHwgZGF0YS5ibGVuZERzdEFscGhhICE9PSBtYXRlcmlhbC5ibGVuZERzdEFscGhhIHx8IGRhdGEuYmxlbmRFcXVhdGlvbkFscGhhICE9PSBtYXRlcmlhbC5ibGVuZEVxdWF0aW9uQWxwaGEgfHxcclxuXHRcdFx0ZGF0YS5jb2xvcldyaXRlICE9PSBtYXRlcmlhbC5jb2xvcldyaXRlIHx8IGRhdGEuZGVwdGhXcml0ZSAhPT0gbWF0ZXJpYWwuZGVwdGhXcml0ZSB8fCBkYXRhLmRlcHRoVGVzdCAhPT0gbWF0ZXJpYWwuZGVwdGhUZXN0IHx8IGRhdGEuZGVwdGhGdW5jICE9PSBtYXRlcmlhbC5kZXB0aEZ1bmMgfHxcclxuXHRcdFx0ZGF0YS5zdGVuY2lsV3JpdGUgIT09IG1hdGVyaWFsLnN0ZW5jaWxXcml0ZSB8fCBkYXRhLnN0ZW5jaWxGdW5jICE9PSBtYXRlcmlhbC5zdGVuY2lsRnVuYyB8fFxyXG5cdFx0XHRkYXRhLnN0ZW5jaWxGYWlsICE9PSBtYXRlcmlhbC5zdGVuY2lsRmFpbCB8fCBkYXRhLnN0ZW5jaWxaRmFpbCAhPT0gbWF0ZXJpYWwuc3RlbmNpbFpGYWlsIHx8IGRhdGEuc3RlbmNpbFpQYXNzICE9PSBtYXRlcmlhbC5zdGVuY2lsWlBhc3MgfHxcclxuXHRcdFx0ZGF0YS5zdGVuY2lsRnVuY01hc2sgIT09IG1hdGVyaWFsLnN0ZW5jaWxGdW5jTWFzayB8fCBkYXRhLnN0ZW5jaWxXcml0ZU1hc2sgIT09IG1hdGVyaWFsLnN0ZW5jaWxXcml0ZU1hc2sgfHxcclxuXHRcdFx0ZGF0YS5zaWRlICE9PSBtYXRlcmlhbC5zaWRlIHx8IGRhdGEuYWxwaGFUb0NvdmVyYWdlICE9PSBtYXRlcmlhbC5hbHBoYVRvQ292ZXJhZ2UgfHxcclxuXHRcdFx0ZGF0YS5zYW1wbGVDb3VudCAhPT0gc2FtcGxlQ291bnQgfHwgZGF0YS5jb2xvclNwYWNlICE9PSBjb2xvclNwYWNlIHx8XHJcblx0XHRcdGRhdGEuY29sb3JGb3JtYXQgIT09IGNvbG9yRm9ybWF0IHx8IGRhdGEuZGVwdGhTdGVuY2lsRm9ybWF0ICE9PSBkZXB0aFN0ZW5jaWxGb3JtYXQgfHxcclxuXHRcdFx0ZGF0YS5wcmltaXRpdmVUb3BvbG9neSAhPT0gcHJpbWl0aXZlVG9wb2xvZ3kgfHxcclxuXHRcdFx0ZGF0YS5jbGlwcGluZ0NvbnRleHRDYWNoZUtleSAhPT0gcmVuZGVyT2JqZWN0LmNsaXBwaW5nQ29udGV4dENhY2hlS2V5XHJcblx0XHQpIHtcclxuXHJcblx0XHRcdGRhdGEubWF0ZXJpYWwgPSBtYXRlcmlhbDsgZGF0YS5tYXRlcmlhbFZlcnNpb24gPSBtYXRlcmlhbC52ZXJzaW9uO1xyXG5cdFx0XHRkYXRhLnRyYW5zcGFyZW50ID0gbWF0ZXJpYWwudHJhbnNwYXJlbnQ7IGRhdGEuYmxlbmRpbmcgPSBtYXRlcmlhbC5ibGVuZGluZzsgZGF0YS5wcmVtdWx0aXBsaWVkQWxwaGEgPSBtYXRlcmlhbC5wcmVtdWx0aXBsaWVkQWxwaGE7XHJcblx0XHRcdGRhdGEuYmxlbmRTcmMgPSBtYXRlcmlhbC5ibGVuZFNyYzsgZGF0YS5ibGVuZERzdCA9IG1hdGVyaWFsLmJsZW5kRHN0OyBkYXRhLmJsZW5kRXF1YXRpb24gPSBtYXRlcmlhbC5ibGVuZEVxdWF0aW9uO1xyXG5cdFx0XHRkYXRhLmJsZW5kU3JjQWxwaGEgPSBtYXRlcmlhbC5ibGVuZFNyY0FscGhhOyBkYXRhLmJsZW5kRHN0QWxwaGEgPSBtYXRlcmlhbC5ibGVuZERzdEFscGhhOyBkYXRhLmJsZW5kRXF1YXRpb25BbHBoYSA9IG1hdGVyaWFsLmJsZW5kRXF1YXRpb25BbHBoYTtcclxuXHRcdFx0ZGF0YS5jb2xvcldyaXRlID0gbWF0ZXJpYWwuY29sb3JXcml0ZTtcclxuXHRcdFx0ZGF0YS5kZXB0aFdyaXRlID0gbWF0ZXJpYWwuZGVwdGhXcml0ZTsgZGF0YS5kZXB0aFRlc3QgPSBtYXRlcmlhbC5kZXB0aFRlc3Q7IGRhdGEuZGVwdGhGdW5jID0gbWF0ZXJpYWwuZGVwdGhGdW5jO1xyXG5cdFx0XHRkYXRhLnN0ZW5jaWxXcml0ZSA9IG1hdGVyaWFsLnN0ZW5jaWxXcml0ZTsgZGF0YS5zdGVuY2lsRnVuYyA9IG1hdGVyaWFsLnN0ZW5jaWxGdW5jO1xyXG5cdFx0XHRkYXRhLnN0ZW5jaWxGYWlsID0gbWF0ZXJpYWwuc3RlbmNpbEZhaWw7IGRhdGEuc3RlbmNpbFpGYWlsID0gbWF0ZXJpYWwuc3RlbmNpbFpGYWlsOyBkYXRhLnN0ZW5jaWxaUGFzcyA9IG1hdGVyaWFsLnN0ZW5jaWxaUGFzcztcclxuXHRcdFx0ZGF0YS5zdGVuY2lsRnVuY01hc2sgPSBtYXRlcmlhbC5zdGVuY2lsRnVuY01hc2s7IGRhdGEuc3RlbmNpbFdyaXRlTWFzayA9IG1hdGVyaWFsLnN0ZW5jaWxXcml0ZU1hc2s7XHJcblx0XHRcdGRhdGEuc2lkZSA9IG1hdGVyaWFsLnNpZGU7IGRhdGEuYWxwaGFUb0NvdmVyYWdlID0gbWF0ZXJpYWwuYWxwaGFUb0NvdmVyYWdlO1xyXG5cdFx0XHRkYXRhLnNhbXBsZUNvdW50ID0gc2FtcGxlQ291bnQ7XHJcblx0XHRcdGRhdGEuY29sb3JTcGFjZSA9IGNvbG9yU3BhY2U7XHJcblx0XHRcdGRhdGEuY29sb3JGb3JtYXQgPSBjb2xvckZvcm1hdDtcclxuXHRcdFx0ZGF0YS5kZXB0aFN0ZW5jaWxGb3JtYXQgPSBkZXB0aFN0ZW5jaWxGb3JtYXQ7XHJcblx0XHRcdGRhdGEucHJpbWl0aXZlVG9wb2xvZ3kgPSBwcmltaXRpdmVUb3BvbG9neTtcclxuXHRcdFx0ZGF0YS5jbGlwcGluZ0NvbnRleHRDYWNoZUtleSA9IHJlbmRlck9iamVjdC5jbGlwcGluZ0NvbnRleHRDYWNoZUtleTtcclxuXHJcblx0XHRcdG5lZWRzVXBkYXRlID0gdHJ1ZTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIG5lZWRzVXBkYXRlO1xyXG5cclxuXHR9XHJcblxyXG5cdGdldFJlbmRlckNhY2hlS2V5KCByZW5kZXJPYmplY3QgKSB7XHJcblxyXG5cdFx0Y29uc3QgeyBvYmplY3QsIG1hdGVyaWFsIH0gPSByZW5kZXJPYmplY3Q7XHJcblxyXG5cdFx0Y29uc3QgdXRpbHMgPSB0aGlzLnV0aWxzO1xyXG5cdFx0Y29uc3QgcmVuZGVyQ29udGV4dCA9IHJlbmRlck9iamVjdC5jb250ZXh0O1xyXG5cclxuXHRcdHJldHVybiBbXHJcblx0XHRcdG1hdGVyaWFsLnRyYW5zcGFyZW50LCBtYXRlcmlhbC5ibGVuZGluZywgbWF0ZXJpYWwucHJlbXVsdGlwbGllZEFscGhhLFxyXG5cdFx0XHRtYXRlcmlhbC5ibGVuZFNyYywgbWF0ZXJpYWwuYmxlbmREc3QsIG1hdGVyaWFsLmJsZW5kRXF1YXRpb24sXHJcblx0XHRcdG1hdGVyaWFsLmJsZW5kU3JjQWxwaGEsIG1hdGVyaWFsLmJsZW5kRHN0QWxwaGEsIG1hdGVyaWFsLmJsZW5kRXF1YXRpb25BbHBoYSxcclxuXHRcdFx0bWF0ZXJpYWwuY29sb3JXcml0ZSxcclxuXHRcdFx0bWF0ZXJpYWwuZGVwdGhXcml0ZSwgbWF0ZXJpYWwuZGVwdGhUZXN0LCBtYXRlcmlhbC5kZXB0aEZ1bmMsXHJcblx0XHRcdG1hdGVyaWFsLnN0ZW5jaWxXcml0ZSwgbWF0ZXJpYWwuc3RlbmNpbEZ1bmMsXHJcblx0XHRcdG1hdGVyaWFsLnN0ZW5jaWxGYWlsLCBtYXRlcmlhbC5zdGVuY2lsWkZhaWwsIG1hdGVyaWFsLnN0ZW5jaWxaUGFzcyxcclxuXHRcdFx0bWF0ZXJpYWwuc3RlbmNpbEZ1bmNNYXNrLCBtYXRlcmlhbC5zdGVuY2lsV3JpdGVNYXNrLFxyXG5cdFx0XHRtYXRlcmlhbC5zaWRlLFxyXG5cdFx0XHR1dGlscy5nZXRTYW1wbGVDb3VudFJlbmRlckNvbnRleHQoIHJlbmRlckNvbnRleHQgKSxcclxuXHRcdFx0dXRpbHMuZ2V0Q3VycmVudENvbG9yU3BhY2UoIHJlbmRlckNvbnRleHQgKSwgdXRpbHMuZ2V0Q3VycmVudENvbG9yRm9ybWF0KCByZW5kZXJDb250ZXh0ICksIHV0aWxzLmdldEN1cnJlbnREZXB0aFN0ZW5jaWxGb3JtYXQoIHJlbmRlckNvbnRleHQgKSxcclxuXHRcdFx0dXRpbHMuZ2V0UHJpbWl0aXZlVG9wb2xvZ3koIG9iamVjdCwgbWF0ZXJpYWwgKSxcclxuXHRcdFx0cmVuZGVyT2JqZWN0LmdldEdlb21ldHJ5Q2FjaGVLZXkoKSxcclxuXHRcdFx0cmVuZGVyT2JqZWN0LmNsaXBwaW5nQ29udGV4dENhY2hlS2V5XHJcblx0XHRdLmpvaW4oKTtcclxuXHJcblx0fVxyXG5cclxuXHQvLyB0ZXh0dXJlc1xyXG5cclxuXHRjcmVhdGVTYW1wbGVyKCB0ZXh0dXJlICkge1xyXG5cclxuXHRcdHRoaXMudGV4dHVyZVV0aWxzLmNyZWF0ZVNhbXBsZXIoIHRleHR1cmUgKTtcclxuXHJcblx0fVxyXG5cclxuXHRkZXN0cm95U2FtcGxlciggdGV4dHVyZSApIHtcclxuXHJcblx0XHR0aGlzLnRleHR1cmVVdGlscy5kZXN0cm95U2FtcGxlciggdGV4dHVyZSApO1xyXG5cclxuXHR9XHJcblxyXG5cdGNyZWF0ZURlZmF1bHRUZXh0dXJlKCB0ZXh0dXJlICkge1xyXG5cclxuXHRcdHRoaXMudGV4dHVyZVV0aWxzLmNyZWF0ZURlZmF1bHRUZXh0dXJlKCB0ZXh0dXJlICk7XHJcblxyXG5cdH1cclxuXHJcblx0Y3JlYXRlVGV4dHVyZSggdGV4dHVyZSwgb3B0aW9ucyApIHtcclxuXHJcblx0XHR0aGlzLnRleHR1cmVVdGlscy5jcmVhdGVUZXh0dXJlKCB0ZXh0dXJlLCBvcHRpb25zICk7XHJcblxyXG5cdH1cclxuXHJcblx0dXBkYXRlVGV4dHVyZSggdGV4dHVyZSwgb3B0aW9ucyApIHtcclxuXHJcblx0XHR0aGlzLnRleHR1cmVVdGlscy51cGRhdGVUZXh0dXJlKCB0ZXh0dXJlLCBvcHRpb25zICk7XHJcblxyXG5cdH1cclxuXHJcblx0Z2VuZXJhdGVNaXBtYXBzKCB0ZXh0dXJlICkge1xyXG5cclxuXHRcdHRoaXMudGV4dHVyZVV0aWxzLmdlbmVyYXRlTWlwbWFwcyggdGV4dHVyZSApO1xyXG5cclxuXHR9XHJcblxyXG5cdGRlc3Ryb3lUZXh0dXJlKCB0ZXh0dXJlICkge1xyXG5cclxuXHRcdHRoaXMudGV4dHVyZVV0aWxzLmRlc3Ryb3lUZXh0dXJlKCB0ZXh0dXJlICk7XHJcblxyXG5cdH1cclxuXHJcblx0Y29weVRleHR1cmVUb0J1ZmZlciggdGV4dHVyZSwgeCwgeSwgd2lkdGgsIGhlaWdodCwgZmFjZUluZGV4ICkge1xyXG5cclxuXHRcdHJldHVybiB0aGlzLnRleHR1cmVVdGlscy5jb3B5VGV4dHVyZVRvQnVmZmVyKCB0ZXh0dXJlLCB4LCB5LCB3aWR0aCwgaGVpZ2h0LCBmYWNlSW5kZXggKTtcclxuXHJcblx0fVxyXG5cclxuXHJcblx0aW5pdFRpbWVzdGFtcFF1ZXJ5KCByZW5kZXJDb250ZXh0LCBkZXNjcmlwdG9yICkge1xyXG5cclxuXHRcdGlmICggISB0aGlzLnRyYWNrVGltZXN0YW1wICkgcmV0dXJuO1xyXG5cclxuXHRcdGNvbnN0IHJlbmRlckNvbnRleHREYXRhID0gdGhpcy5nZXQoIHJlbmRlckNvbnRleHQgKTtcclxuXHJcblx0XHRpZiAoICEgcmVuZGVyQ29udGV4dERhdGEudGltZVN0YW1wUXVlcnlTZXQgKSB7XHJcblxyXG5cclxuXHRcdFx0Y29uc3QgdHlwZSA9IHJlbmRlckNvbnRleHQuaXNDb21wdXRlTm9kZSA/ICdjb21wdXRlJyA6ICdyZW5kZXInO1xyXG5cdFx0XHRjb25zdCB0aW1lU3RhbXBRdWVyeVNldCA9IHRoaXMuZGV2aWNlLmNyZWF0ZVF1ZXJ5U2V0KCB7IHR5cGU6ICd0aW1lc3RhbXAnLCBjb3VudDogMiwgbGFiZWw6IGB0aW1lc3RhbXBfJHt0eXBlfV8ke3JlbmRlckNvbnRleHQuaWR9YCB9ICk7XHJcblxyXG5cdFx0XHRjb25zdCB0aW1lc3RhbXBXcml0ZXMgPSB7XHJcblx0XHRcdFx0cXVlcnlTZXQ6IHRpbWVTdGFtcFF1ZXJ5U2V0LFxyXG5cdFx0XHRcdGJlZ2lubmluZ09mUGFzc1dyaXRlSW5kZXg6IDAsIC8vIFdyaXRlIHRpbWVzdGFtcCBpbiBpbmRleCAwIHdoZW4gcGFzcyBiZWdpbnMuXHJcblx0XHRcdFx0ZW5kT2ZQYXNzV3JpdGVJbmRleDogMSwgLy8gV3JpdGUgdGltZXN0YW1wIGluIGluZGV4IDEgd2hlbiBwYXNzIGVuZHMuXHJcblx0XHRcdH07XHJcblxyXG5cdFx0XHRPYmplY3QuYXNzaWduKCBkZXNjcmlwdG9yLCB7IHRpbWVzdGFtcFdyaXRlcyB9ICk7XHJcblxyXG5cdFx0XHRyZW5kZXJDb250ZXh0RGF0YS50aW1lU3RhbXBRdWVyeVNldCA9IHRpbWVTdGFtcFF1ZXJ5U2V0O1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHQvLyB0aW1lc3RhbXAgdXRpbHNcclxuXHJcblx0cHJlcGFyZVRpbWVzdGFtcEJ1ZmZlciggcmVuZGVyQ29udGV4dCwgZW5jb2RlciApIHtcclxuXHJcblx0XHRpZiAoICEgdGhpcy50cmFja1RpbWVzdGFtcCApIHJldHVybjtcclxuXHJcblx0XHRjb25zdCByZW5kZXJDb250ZXh0RGF0YSA9IHRoaXMuZ2V0KCByZW5kZXJDb250ZXh0ICk7XHJcblxyXG5cclxuXHRcdGNvbnN0IHNpemUgPSAyICogQmlnSW50NjRBcnJheS5CWVRFU19QRVJfRUxFTUVOVDtcclxuXHJcblx0XHRpZiAoIHJlbmRlckNvbnRleHREYXRhLmN1cnJlbnRUaW1lc3RhbXBRdWVyeUJ1ZmZlcnMgPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdHJlbmRlckNvbnRleHREYXRhLmN1cnJlbnRUaW1lc3RhbXBRdWVyeUJ1ZmZlcnMgPSB7XHJcblx0XHRcdFx0cmVzb2x2ZUJ1ZmZlcjogdGhpcy5kZXZpY2UuY3JlYXRlQnVmZmVyKCB7XHJcblx0XHRcdFx0XHRsYWJlbDogJ3RpbWVzdGFtcCByZXNvbHZlIGJ1ZmZlcicsXHJcblx0XHRcdFx0XHRzaXplOiBzaXplLFxyXG5cdFx0XHRcdFx0dXNhZ2U6IEdQVUJ1ZmZlclVzYWdlLlFVRVJZX1JFU09MVkUgfCBHUFVCdWZmZXJVc2FnZS5DT1BZX1NSQyxcclxuXHRcdFx0XHR9ICksXHJcblx0XHRcdFx0cmVzdWx0QnVmZmVyOiB0aGlzLmRldmljZS5jcmVhdGVCdWZmZXIoIHtcclxuXHRcdFx0XHRcdGxhYmVsOiAndGltZXN0YW1wIHJlc3VsdCBidWZmZXInLFxyXG5cdFx0XHRcdFx0c2l6ZTogc2l6ZSxcclxuXHRcdFx0XHRcdHVzYWdlOiBHUFVCdWZmZXJVc2FnZS5DT1BZX0RTVCB8IEdQVUJ1ZmZlclVzYWdlLk1BUF9SRUFELFxyXG5cdFx0XHRcdH0gKVxyXG5cdFx0XHR9O1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRjb25zdCB7IHJlc29sdmVCdWZmZXIsIHJlc3VsdEJ1ZmZlciB9ID0gcmVuZGVyQ29udGV4dERhdGEuY3VycmVudFRpbWVzdGFtcFF1ZXJ5QnVmZmVycztcclxuXHJcblxyXG5cdFx0ZW5jb2Rlci5yZXNvbHZlUXVlcnlTZXQoIHJlbmRlckNvbnRleHREYXRhLnRpbWVTdGFtcFF1ZXJ5U2V0LCAwLCAyLCByZXNvbHZlQnVmZmVyLCAwICk7XHJcblxyXG5cdFx0aWYgKCByZXN1bHRCdWZmZXIubWFwU3RhdGUgPT09ICd1bm1hcHBlZCcgKSB7XHJcblxyXG5cdFx0XHRlbmNvZGVyLmNvcHlCdWZmZXJUb0J1ZmZlciggcmVzb2x2ZUJ1ZmZlciwgMCwgcmVzdWx0QnVmZmVyLCAwLCBzaXplICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdGFzeW5jIHJlc29sdmVUaW1lc3RhbXBBc3luYyggcmVuZGVyQ29udGV4dCwgdHlwZSA9ICdyZW5kZXInICkge1xyXG5cclxuXHRcdGlmICggISB0aGlzLnRyYWNrVGltZXN0YW1wICkgcmV0dXJuO1xyXG5cclxuXHRcdGNvbnN0IHJlbmRlckNvbnRleHREYXRhID0gdGhpcy5nZXQoIHJlbmRlckNvbnRleHQgKTtcclxuXHJcblx0XHRpZiAoIHJlbmRlckNvbnRleHREYXRhLmN1cnJlbnRUaW1lc3RhbXBRdWVyeUJ1ZmZlcnMgPT09IHVuZGVmaW5lZCApIHJldHVybjtcclxuXHJcblx0XHRjb25zdCB7IHJlc3VsdEJ1ZmZlciB9ID0gcmVuZGVyQ29udGV4dERhdGEuY3VycmVudFRpbWVzdGFtcFF1ZXJ5QnVmZmVycztcclxuXHJcblx0XHRpZiAoIHJlc3VsdEJ1ZmZlci5tYXBTdGF0ZSA9PT0gJ3VubWFwcGVkJyApIHtcclxuXHJcblx0XHRcdHJlc3VsdEJ1ZmZlci5tYXBBc3luYyggR1BVTWFwTW9kZS5SRUFEICkudGhlbiggKCkgPT4ge1xyXG5cclxuXHRcdFx0XHRjb25zdCB0aW1lcyA9IG5ldyBCaWdVaW50NjRBcnJheSggcmVzdWx0QnVmZmVyLmdldE1hcHBlZFJhbmdlKCkgKTtcclxuXHRcdFx0XHRjb25zdCBkdXJhdGlvbiA9IE51bWJlciggdGltZXNbIDEgXSAtIHRpbWVzWyAwIF0gKSAvIDEwMDAwMDA7XHJcblxyXG5cclxuXHRcdFx0XHR0aGlzLnJlbmRlcmVyLmluZm8udXBkYXRlVGltZXN0YW1wKCB0eXBlLCBkdXJhdGlvbiApO1xyXG5cclxuXHRcdFx0XHRyZXN1bHRCdWZmZXIudW5tYXAoKTtcclxuXHJcblxyXG5cdFx0XHR9ICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdC8vIG5vZGUgYnVpbGRlclxyXG5cclxuXHRjcmVhdGVOb2RlQnVpbGRlciggb2JqZWN0LCByZW5kZXJlciApIHtcclxuXHJcblx0XHRyZXR1cm4gbmV3IFdHU0xOb2RlQnVpbGRlciggb2JqZWN0LCByZW5kZXJlciApO1xyXG5cclxuXHR9XHJcblxyXG5cdC8vIHByb2dyYW1cclxuXHJcblx0Y3JlYXRlUHJvZ3JhbSggcHJvZ3JhbSApIHtcclxuXHJcblx0XHRjb25zdCBwcm9ncmFtR1BVID0gdGhpcy5nZXQoIHByb2dyYW0gKTtcclxuXHJcblx0XHRwcm9ncmFtR1BVLm1vZHVsZSA9IHtcclxuXHRcdFx0bW9kdWxlOiB0aGlzLmRldmljZS5jcmVhdGVTaGFkZXJNb2R1bGUoIHsgY29kZTogcHJvZ3JhbS5jb2RlLCBsYWJlbDogcHJvZ3JhbS5zdGFnZSB9ICksXHJcblx0XHRcdGVudHJ5UG9pbnQ6ICdtYWluJ1xyXG5cdFx0fTtcclxuXHJcblx0fVxyXG5cclxuXHRkZXN0cm95UHJvZ3JhbSggcHJvZ3JhbSApIHtcclxuXHJcblx0XHR0aGlzLmRlbGV0ZSggcHJvZ3JhbSApO1xyXG5cclxuXHR9XHJcblxyXG5cdC8vIHBpcGVsaW5lc1xyXG5cclxuXHRjcmVhdGVSZW5kZXJQaXBlbGluZSggcmVuZGVyT2JqZWN0LCBwcm9taXNlcyApIHtcclxuXHJcblx0XHR0aGlzLnBpcGVsaW5lVXRpbHMuY3JlYXRlUmVuZGVyUGlwZWxpbmUoIHJlbmRlck9iamVjdCwgcHJvbWlzZXMgKTtcclxuXHJcblx0fVxyXG5cclxuXHRjcmVhdGVDb21wdXRlUGlwZWxpbmUoIGNvbXB1dGVQaXBlbGluZSwgYmluZGluZ3MgKSB7XHJcblxyXG5cdFx0dGhpcy5waXBlbGluZVV0aWxzLmNyZWF0ZUNvbXB1dGVQaXBlbGluZSggY29tcHV0ZVBpcGVsaW5lLCBiaW5kaW5ncyApO1xyXG5cclxuXHR9XHJcblxyXG5cdGJlZ2luQnVuZGxlKCByZW5kZXJDb250ZXh0ICkge1xyXG5cclxuXHRcdGNvbnN0IHJlbmRlckNvbnRleHREYXRhID0gdGhpcy5nZXQoIHJlbmRlckNvbnRleHQgKTtcclxuXHJcblx0XHRyZW5kZXJDb250ZXh0RGF0YS5fY3VycmVudFBhc3MgPSByZW5kZXJDb250ZXh0RGF0YS5jdXJyZW50UGFzcztcclxuXHRcdHJlbmRlckNvbnRleHREYXRhLl9jdXJyZW50U2V0cyA9IHJlbmRlckNvbnRleHREYXRhLmN1cnJlbnRTZXRzO1xyXG5cclxuXHRcdHJlbmRlckNvbnRleHREYXRhLmN1cnJlbnRTZXRzID0geyBhdHRyaWJ1dGVzOiB7fSwgYmluZGluZ0dyb3VwczogW10sIHBpcGVsaW5lOiBudWxsLCBpbmRleDogbnVsbCB9O1xyXG5cdFx0cmVuZGVyQ29udGV4dERhdGEuY3VycmVudFBhc3MgPSB0aGlzLnBpcGVsaW5lVXRpbHMuY3JlYXRlQnVuZGxlRW5jb2RlciggcmVuZGVyQ29udGV4dCApO1xyXG5cclxuXHR9XHJcblxyXG5cdGZpbmlzaEJ1bmRsZSggcmVuZGVyQ29udGV4dCwgYnVuZGxlICkge1xyXG5cclxuXHRcdGNvbnN0IHJlbmRlckNvbnRleHREYXRhID0gdGhpcy5nZXQoIHJlbmRlckNvbnRleHQgKTtcclxuXHJcblx0XHRjb25zdCBidW5kbGVFbmNvZGVyID0gcmVuZGVyQ29udGV4dERhdGEuY3VycmVudFBhc3M7XHJcblx0XHRjb25zdCBidW5kbGVHUFUgPSBidW5kbGVFbmNvZGVyLmZpbmlzaCgpO1xyXG5cclxuXHRcdHRoaXMuZ2V0KCBidW5kbGUgKS5idW5kbGVHUFUgPSBidW5kbGVHUFU7XHJcblxyXG5cdFx0Ly8gcmVzdG9yZSByZW5kZXIgcGFzcyBzdGF0ZVxyXG5cclxuXHRcdHJlbmRlckNvbnRleHREYXRhLmN1cnJlbnRTZXRzID0gcmVuZGVyQ29udGV4dERhdGEuX2N1cnJlbnRTZXRzO1xyXG5cdFx0cmVuZGVyQ29udGV4dERhdGEuY3VycmVudFBhc3MgPSByZW5kZXJDb250ZXh0RGF0YS5fY3VycmVudFBhc3M7XHJcblxyXG5cdH1cclxuXHJcblx0YWRkQnVuZGxlKCByZW5kZXJDb250ZXh0LCBidW5kbGUgKSB7XHJcblxyXG5cdFx0Y29uc3QgcmVuZGVyQ29udGV4dERhdGEgPSB0aGlzLmdldCggcmVuZGVyQ29udGV4dCApO1xyXG5cclxuXHRcdHJlbmRlckNvbnRleHREYXRhLnJlbmRlckJ1bmRsZXMucHVzaCggdGhpcy5nZXQoIGJ1bmRsZSApLmJ1bmRsZUdQVSApO1xyXG5cclxuXHR9XHJcblxyXG5cdC8vIGJpbmRpbmdzXHJcblxyXG5cdGNyZWF0ZUJpbmRpbmdzKCBiaW5kR3JvdXAsIGJpbmRpbmdzLCBjYWNoZUluZGV4LCB2ZXJzaW9uICkge1xyXG5cclxuXHRcdHRoaXMuYmluZGluZ1V0aWxzLmNyZWF0ZUJpbmRpbmdzKCBiaW5kR3JvdXAsIGJpbmRpbmdzLCBjYWNoZUluZGV4LCB2ZXJzaW9uICk7XHJcblxyXG5cdH1cclxuXHJcblx0dXBkYXRlQmluZGluZ3MoIGJpbmRHcm91cCwgYmluZGluZ3MsIGNhY2hlSW5kZXgsIHZlcnNpb24gKSB7XHJcblxyXG5cdFx0dGhpcy5iaW5kaW5nVXRpbHMuY3JlYXRlQmluZGluZ3MoIGJpbmRHcm91cCwgYmluZGluZ3MsIGNhY2hlSW5kZXgsIHZlcnNpb24gKTtcclxuXHJcblx0fVxyXG5cclxuXHR1cGRhdGVCaW5kaW5nKCBiaW5kaW5nICkge1xyXG5cclxuXHRcdHRoaXMuYmluZGluZ1V0aWxzLnVwZGF0ZUJpbmRpbmcoIGJpbmRpbmcgKTtcclxuXHJcblx0fVxyXG5cclxuXHQvLyBhdHRyaWJ1dGVzXHJcblxyXG5cdGNyZWF0ZUluZGV4QXR0cmlidXRlKCBhdHRyaWJ1dGUgKSB7XHJcblxyXG5cdFx0dGhpcy5hdHRyaWJ1dGVVdGlscy5jcmVhdGVBdHRyaWJ1dGUoIGF0dHJpYnV0ZSwgR1BVQnVmZmVyVXNhZ2UuSU5ERVggfCBHUFVCdWZmZXJVc2FnZS5DT1BZX1NSQyB8IEdQVUJ1ZmZlclVzYWdlLkNPUFlfRFNUICk7XHJcblxyXG5cdH1cclxuXHJcblx0Y3JlYXRlQXR0cmlidXRlKCBhdHRyaWJ1dGUgKSB7XHJcblxyXG5cdFx0dGhpcy5hdHRyaWJ1dGVVdGlscy5jcmVhdGVBdHRyaWJ1dGUoIGF0dHJpYnV0ZSwgR1BVQnVmZmVyVXNhZ2UuVkVSVEVYIHwgR1BVQnVmZmVyVXNhZ2UuQ09QWV9TUkMgfCBHUFVCdWZmZXJVc2FnZS5DT1BZX0RTVCApO1xyXG5cclxuXHR9XHJcblxyXG5cdGNyZWF0ZVN0b3JhZ2VBdHRyaWJ1dGUoIGF0dHJpYnV0ZSApIHtcclxuXHJcblx0XHR0aGlzLmF0dHJpYnV0ZVV0aWxzLmNyZWF0ZUF0dHJpYnV0ZSggYXR0cmlidXRlLCBHUFVCdWZmZXJVc2FnZS5TVE9SQUdFIHwgR1BVQnVmZmVyVXNhZ2UuVkVSVEVYIHwgR1BVQnVmZmVyVXNhZ2UuQ09QWV9TUkMgfCBHUFVCdWZmZXJVc2FnZS5DT1BZX0RTVCApO1xyXG5cclxuXHR9XHJcblxyXG5cdGNyZWF0ZUluZGlyZWN0U3RvcmFnZUF0dHJpYnV0ZSggYXR0cmlidXRlICkge1xyXG5cclxuXHRcdHRoaXMuYXR0cmlidXRlVXRpbHMuY3JlYXRlQXR0cmlidXRlKCBhdHRyaWJ1dGUsIEdQVUJ1ZmZlclVzYWdlLlNUT1JBR0UgfCBHUFVCdWZmZXJVc2FnZS5JTkRJUkVDVCB8IEdQVUJ1ZmZlclVzYWdlLkNPUFlfU1JDIHwgR1BVQnVmZmVyVXNhZ2UuQ09QWV9EU1QgKTtcclxuXHJcblx0fVxyXG5cclxuXHR1cGRhdGVBdHRyaWJ1dGUoIGF0dHJpYnV0ZSApIHtcclxuXHJcblx0XHR0aGlzLmF0dHJpYnV0ZVV0aWxzLnVwZGF0ZUF0dHJpYnV0ZSggYXR0cmlidXRlICk7XHJcblxyXG5cdH1cclxuXHJcblx0ZGVzdHJveUF0dHJpYnV0ZSggYXR0cmlidXRlICkge1xyXG5cclxuXHRcdHRoaXMuYXR0cmlidXRlVXRpbHMuZGVzdHJveUF0dHJpYnV0ZSggYXR0cmlidXRlICk7XHJcblxyXG5cdH1cclxuXHJcblx0Ly8gY2FudmFzXHJcblxyXG5cdHVwZGF0ZVNpemUoKSB7XHJcblxyXG5cdFx0dGhpcy5jb2xvckJ1ZmZlciA9IHRoaXMudGV4dHVyZVV0aWxzLmdldENvbG9yQnVmZmVyKCk7XHJcblx0XHR0aGlzLmRlZmF1bHRSZW5kZXJQYXNzZGVzY3JpcHRvciA9IG51bGw7XHJcblxyXG5cdH1cclxuXHJcblx0Ly8gdXRpbHMgcHVibGljXHJcblxyXG5cdGdldE1heEFuaXNvdHJvcHkoKSB7XHJcblxyXG5cdFx0cmV0dXJuIDE2O1xyXG5cclxuXHR9XHJcblxyXG5cdGhhc0ZlYXR1cmUoIG5hbWUgKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuZGV2aWNlLmZlYXR1cmVzLmhhcyggbmFtZSApO1xyXG5cclxuXHR9XHJcblxyXG5cdGNvcHlUZXh0dXJlVG9UZXh0dXJlKCBzcmNUZXh0dXJlLCBkc3RUZXh0dXJlLCBzcmNSZWdpb24gPSBudWxsLCBkc3RQb3NpdGlvbiA9IG51bGwsIGxldmVsID0gMCApIHtcclxuXHJcblx0XHRsZXQgZHN0WCA9IDA7XHJcblx0XHRsZXQgZHN0WSA9IDA7XHJcblx0XHRsZXQgZHN0TGF5ZXIgPSAwO1xyXG5cclxuXHRcdGxldCBzcmNYID0gMDtcclxuXHRcdGxldCBzcmNZID0gMDtcclxuXHRcdGxldCBzcmNMYXllciA9IDA7XHJcblxyXG5cdFx0bGV0IHNyY1dpZHRoID0gc3JjVGV4dHVyZS5pbWFnZS53aWR0aDtcclxuXHRcdGxldCBzcmNIZWlnaHQgPSBzcmNUZXh0dXJlLmltYWdlLmhlaWdodDtcclxuXHJcblx0XHRpZiAoIHNyY1JlZ2lvbiAhPT0gbnVsbCApIHtcclxuXHJcblx0XHRcdHNyY1ggPSBzcmNSZWdpb24ueDtcclxuXHRcdFx0c3JjWSA9IHNyY1JlZ2lvbi55O1xyXG5cdFx0XHRzcmNMYXllciA9IHNyY1JlZ2lvbi56IHx8IDA7XHJcblx0XHRcdHNyY1dpZHRoID0gc3JjUmVnaW9uLndpZHRoO1xyXG5cdFx0XHRzcmNIZWlnaHQgPSBzcmNSZWdpb24uaGVpZ2h0O1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIGRzdFBvc2l0aW9uICE9PSBudWxsICkge1xyXG5cclxuXHRcdFx0ZHN0WCA9IGRzdFBvc2l0aW9uLng7XHJcblx0XHRcdGRzdFkgPSBkc3RQb3NpdGlvbi55O1xyXG5cdFx0XHRkc3RMYXllciA9IGRzdFBvc2l0aW9uLnogfHwgMDtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Y29uc3QgZW5jb2RlciA9IHRoaXMuZGV2aWNlLmNyZWF0ZUNvbW1hbmRFbmNvZGVyKCB7IGxhYmVsOiAnY29weVRleHR1cmVUb1RleHR1cmVfJyArIHNyY1RleHR1cmUuaWQgKyAnXycgKyBkc3RUZXh0dXJlLmlkIH0gKTtcclxuXHJcblx0XHRjb25zdCBzb3VyY2VHUFUgPSB0aGlzLmdldCggc3JjVGV4dHVyZSApLnRleHR1cmU7XHJcblx0XHRjb25zdCBkZXN0aW5hdGlvbkdQVSA9IHRoaXMuZ2V0KCBkc3RUZXh0dXJlICkudGV4dHVyZTtcclxuXHJcblx0XHRlbmNvZGVyLmNvcHlUZXh0dXJlVG9UZXh0dXJlKFxyXG5cdFx0XHR7XHJcblx0XHRcdFx0dGV4dHVyZTogc291cmNlR1BVLFxyXG5cdFx0XHRcdG1pcExldmVsOiBsZXZlbCxcclxuXHRcdFx0XHRvcmlnaW46IHsgeDogc3JjWCwgeTogc3JjWSwgejogc3JjTGF5ZXIgfVxyXG5cdFx0XHR9LFxyXG5cdFx0XHR7XHJcblx0XHRcdFx0dGV4dHVyZTogZGVzdGluYXRpb25HUFUsXHJcblx0XHRcdFx0bWlwTGV2ZWw6IGxldmVsLFxyXG5cdFx0XHRcdG9yaWdpbjogeyB4OiBkc3RYLCB5OiBkc3RZLCB6OiBkc3RMYXllciB9XHJcblx0XHRcdH0sXHJcblx0XHRcdFtcclxuXHRcdFx0XHRzcmNXaWR0aCxcclxuXHRcdFx0XHRzcmNIZWlnaHQsXHJcblx0XHRcdFx0MVxyXG5cdFx0XHRdXHJcblx0XHQpO1xyXG5cclxuXHRcdHRoaXMuZGV2aWNlLnF1ZXVlLnN1Ym1pdCggWyBlbmNvZGVyLmZpbmlzaCgpIF0gKTtcclxuXHJcblx0fVxyXG5cclxuXHRjb3B5RnJhbWVidWZmZXJUb1RleHR1cmUoIHRleHR1cmUsIHJlbmRlckNvbnRleHQsIHJlY3RhbmdsZSApIHtcclxuXHJcblx0XHRjb25zdCByZW5kZXJDb250ZXh0RGF0YSA9IHRoaXMuZ2V0KCByZW5kZXJDb250ZXh0ICk7XHJcblxyXG5cdFx0bGV0IHNvdXJjZUdQVSA9IG51bGw7XHJcblxyXG5cdFx0aWYgKCByZW5kZXJDb250ZXh0LnJlbmRlclRhcmdldCApIHtcclxuXHJcblx0XHRcdGlmICggdGV4dHVyZS5pc0RlcHRoVGV4dHVyZSApIHtcclxuXHJcblx0XHRcdFx0c291cmNlR1BVID0gdGhpcy5nZXQoIHJlbmRlckNvbnRleHQuZGVwdGhUZXh0dXJlICkudGV4dHVyZTtcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdHNvdXJjZUdQVSA9IHRoaXMuZ2V0KCByZW5kZXJDb250ZXh0LnRleHR1cmVzWyAwIF0gKS50ZXh0dXJlO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRpZiAoIHRleHR1cmUuaXNEZXB0aFRleHR1cmUgKSB7XHJcblxyXG5cdFx0XHRcdHNvdXJjZUdQVSA9IHRoaXMudGV4dHVyZVV0aWxzLmdldERlcHRoQnVmZmVyKCByZW5kZXJDb250ZXh0LmRlcHRoLCByZW5kZXJDb250ZXh0LnN0ZW5jaWwgKTtcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdHNvdXJjZUdQVSA9IHRoaXMuY29udGV4dC5nZXRDdXJyZW50VGV4dHVyZSgpO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRjb25zdCBkZXN0aW5hdGlvbkdQVSA9IHRoaXMuZ2V0KCB0ZXh0dXJlICkudGV4dHVyZTtcclxuXHJcblx0XHRpZiAoIHNvdXJjZUdQVS5mb3JtYXQgIT09IGRlc3RpbmF0aW9uR1BVLmZvcm1hdCApIHtcclxuXHJcblx0XHRcdGNvbnNvbGUuZXJyb3IoICdXZWJHUFVCYWNrZW5kOiBjb3B5RnJhbWVidWZmZXJUb1RleHR1cmU6IFNvdXJjZSBhbmQgZGVzdGluYXRpb24gZm9ybWF0cyBkbyBub3QgbWF0Y2guJywgc291cmNlR1BVLmZvcm1hdCwgZGVzdGluYXRpb25HUFUuZm9ybWF0ICk7XHJcblxyXG5cdFx0XHRyZXR1cm47XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGxldCBlbmNvZGVyO1xyXG5cclxuXHRcdGlmICggcmVuZGVyQ29udGV4dERhdGEuY3VycmVudFBhc3MgKSB7XHJcblxyXG5cdFx0XHRyZW5kZXJDb250ZXh0RGF0YS5jdXJyZW50UGFzcy5lbmQoKTtcclxuXHJcblx0XHRcdGVuY29kZXIgPSByZW5kZXJDb250ZXh0RGF0YS5lbmNvZGVyO1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRlbmNvZGVyID0gdGhpcy5kZXZpY2UuY3JlYXRlQ29tbWFuZEVuY29kZXIoIHsgbGFiZWw6ICdjb3B5RnJhbWVidWZmZXJUb1RleHR1cmVfJyArIHRleHR1cmUuaWQgfSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRlbmNvZGVyLmNvcHlUZXh0dXJlVG9UZXh0dXJlKFxyXG5cdFx0XHR7XHJcblx0XHRcdFx0dGV4dHVyZTogc291cmNlR1BVLFxyXG5cdFx0XHRcdG9yaWdpbjogWyByZWN0YW5nbGUueCwgcmVjdGFuZ2xlLnksIDAgXSxcclxuXHRcdFx0fSxcclxuXHRcdFx0e1xyXG5cdFx0XHRcdHRleHR1cmU6IGRlc3RpbmF0aW9uR1BVXHJcblx0XHRcdH0sXHJcblx0XHRcdFtcclxuXHRcdFx0XHRyZWN0YW5nbGUueixcclxuXHRcdFx0XHRyZWN0YW5nbGUud1xyXG5cdFx0XHRdXHJcblx0XHQpO1xyXG5cclxuXHRcdGlmICggdGV4dHVyZS5nZW5lcmF0ZU1pcG1hcHMgKSB0aGlzLnRleHR1cmVVdGlscy5nZW5lcmF0ZU1pcG1hcHMoIHRleHR1cmUgKTtcclxuXHJcblx0XHRpZiAoIHJlbmRlckNvbnRleHREYXRhLmN1cnJlbnRQYXNzICkge1xyXG5cclxuXHRcdFx0Y29uc3QgeyBkZXNjcmlwdG9yIH0gPSByZW5kZXJDb250ZXh0RGF0YTtcclxuXHJcblx0XHRcdGZvciAoIGxldCBpID0gMDsgaSA8IGRlc2NyaXB0b3IuY29sb3JBdHRhY2htZW50cy5sZW5ndGg7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdGRlc2NyaXB0b3IuY29sb3JBdHRhY2htZW50c1sgaSBdLmxvYWRPcCA9IEdQVUxvYWRPcC5Mb2FkO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKCByZW5kZXJDb250ZXh0LmRlcHRoICkgZGVzY3JpcHRvci5kZXB0aFN0ZW5jaWxBdHRhY2htZW50LmRlcHRoTG9hZE9wID0gR1BVTG9hZE9wLkxvYWQ7XHJcblx0XHRcdGlmICggcmVuZGVyQ29udGV4dC5zdGVuY2lsICkgZGVzY3JpcHRvci5kZXB0aFN0ZW5jaWxBdHRhY2htZW50LnN0ZW5jaWxMb2FkT3AgPSBHUFVMb2FkT3AuTG9hZDtcclxuXHJcblx0XHRcdHJlbmRlckNvbnRleHREYXRhLmN1cnJlbnRQYXNzID0gZW5jb2Rlci5iZWdpblJlbmRlclBhc3MoIGRlc2NyaXB0b3IgKTtcclxuXHRcdFx0cmVuZGVyQ29udGV4dERhdGEuY3VycmVudFNldHMgPSB7IGF0dHJpYnV0ZXM6IHt9LCBiaW5kaW5nR3JvdXBzOiBbXSwgcGlwZWxpbmU6IG51bGwsIGluZGV4OiBudWxsIH07XHJcblxyXG5cdFx0XHRpZiAoIHJlbmRlckNvbnRleHQudmlld3BvcnQgKSB7XHJcblxyXG5cdFx0XHRcdHRoaXMudXBkYXRlVmlld3BvcnQoIHJlbmRlckNvbnRleHQgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICggcmVuZGVyQ29udGV4dC5zY2lzc29yICkge1xyXG5cclxuXHRcdFx0XHRjb25zdCB7IHgsIHksIHdpZHRoLCBoZWlnaHQgfSA9IHJlbmRlckNvbnRleHQuc2Npc3NvclZhbHVlO1xyXG5cclxuXHRcdFx0XHRyZW5kZXJDb250ZXh0RGF0YS5jdXJyZW50UGFzcy5zZXRTY2lzc29yUmVjdCggeCwgeSwgd2lkdGgsIGhlaWdodCApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHR0aGlzLmRldmljZS5xdWV1ZS5zdWJtaXQoIFsgZW5jb2Rlci5maW5pc2goKSBdICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBXZWJHUFVCYWNrZW5kO1xyXG4iLCJpbXBvcnQgeyBTcG90TGlnaHQgfSBmcm9tICcuLi9TcG90TGlnaHQuanMnO1xyXG5cclxuY2xhc3MgSUVTU3BvdExpZ2h0IGV4dGVuZHMgU3BvdExpZ2h0IHtcclxuXHJcblx0Y29uc3RydWN0b3IoIGNvbG9yLCBpbnRlbnNpdHksIGRpc3RhbmNlLCBhbmdsZSwgcGVudW1icmEsIGRlY2F5ICkge1xyXG5cclxuXHRcdHN1cGVyKCBjb2xvciwgaW50ZW5zaXR5LCBkaXN0YW5jZSwgYW5nbGUsIHBlbnVtYnJhLCBkZWNheSApO1xyXG5cclxuXHRcdHRoaXMuaWVzTWFwID0gbnVsbDtcclxuXHJcblx0fVxyXG5cclxuXHRjb3B5KCBzb3VyY2UsIHJlY3Vyc2l2ZSApIHtcclxuXHJcblx0XHRzdXBlci5jb3B5KCBzb3VyY2UsIHJlY3Vyc2l2ZSApO1xyXG5cclxuXHRcdHRoaXMuaWVzTWFwID0gc291cmNlLmllc01hcDtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fVxyXG5cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgSUVTU3BvdExpZ2h0O1xyXG4iLCJpbXBvcnQgTm9kZUxpYnJhcnkgZnJvbSAnLi4vLi4vY29tbW9uL25vZGVzL05vZGVMaWJyYXJ5LmpzJztcclxuXHJcbi8vIExpZ2h0c1xyXG5pbXBvcnQgeyBQb2ludExpZ2h0IH0gZnJvbSAnLi4vLi4vLi4vbGlnaHRzL1BvaW50TGlnaHQuanMnO1xyXG5pbXBvcnQgeyBEaXJlY3Rpb25hbExpZ2h0IH0gZnJvbSAnLi4vLi4vLi4vbGlnaHRzL0RpcmVjdGlvbmFsTGlnaHQuanMnO1xyXG5pbXBvcnQgeyBSZWN0QXJlYUxpZ2h0IH0gZnJvbSAnLi4vLi4vLi4vbGlnaHRzL1JlY3RBcmVhTGlnaHQuanMnO1xyXG5pbXBvcnQgeyBTcG90TGlnaHQgfSBmcm9tICcuLi8uLi8uLi9saWdodHMvU3BvdExpZ2h0LmpzJztcclxuaW1wb3J0IHsgQW1iaWVudExpZ2h0IH0gZnJvbSAnLi4vLi4vLi4vbGlnaHRzL0FtYmllbnRMaWdodC5qcyc7XHJcbmltcG9ydCB7IEhlbWlzcGhlcmVMaWdodCB9IGZyb20gJy4uLy4uLy4uL2xpZ2h0cy9IZW1pc3BoZXJlTGlnaHQuanMnO1xyXG5pbXBvcnQgeyBMaWdodFByb2JlIH0gZnJvbSAnLi4vLi4vLi4vbGlnaHRzL0xpZ2h0UHJvYmUuanMnO1xyXG5pbXBvcnQgSUVTU3BvdExpZ2h0IGZyb20gJy4uLy4uLy4uL2xpZ2h0cy93ZWJncHUvSUVTU3BvdExpZ2h0LmpzJztcclxuaW1wb3J0IHtcclxuXHRQb2ludExpZ2h0Tm9kZSxcclxuXHREaXJlY3Rpb25hbExpZ2h0Tm9kZSxcclxuXHRSZWN0QXJlYUxpZ2h0Tm9kZSxcclxuXHRTcG90TGlnaHROb2RlLFxyXG5cdEFtYmllbnRMaWdodE5vZGUsXHJcblx0SGVtaXNwaGVyZUxpZ2h0Tm9kZSxcclxuXHRMaWdodFByb2JlTm9kZSxcclxuXHRJRVNTcG90TGlnaHROb2RlXHJcbn0gZnJvbSAnLi4vLi4vLi4vbm9kZXMvTm9kZXMuanMnO1xyXG5cclxuLy8gVG9uZSBNYXBwaW5nXHJcbmltcG9ydCB7IExpbmVhclRvbmVNYXBwaW5nLCBSZWluaGFyZFRvbmVNYXBwaW5nLCBDaW5lb25Ub25lTWFwcGluZywgQUNFU0ZpbG1pY1RvbmVNYXBwaW5nLCBBZ1hUb25lTWFwcGluZywgTmV1dHJhbFRvbmVNYXBwaW5nIH0gZnJvbSAnLi4vLi4vLi4vY29uc3RhbnRzLmpzJztcclxuaW1wb3J0IHsgbGluZWFyVG9uZU1hcHBpbmcsIHJlaW5oYXJkVG9uZU1hcHBpbmcsIGNpbmVvblRvbmVNYXBwaW5nLCBhY2VzRmlsbWljVG9uZU1hcHBpbmcsIGFneFRvbmVNYXBwaW5nLCBuZXV0cmFsVG9uZU1hcHBpbmcgfSBmcm9tICcuLi8uLi8uLi9ub2Rlcy9kaXNwbGF5L1RvbmVNYXBwaW5nRnVuY3Rpb25zLmpzJztcclxuXHJcbmNsYXNzIEJhc2ljTm9kZUxpYnJhcnkgZXh0ZW5kcyBOb2RlTGlicmFyeSB7XHJcblxyXG5cdGNvbnN0cnVjdG9yKCkge1xyXG5cclxuXHRcdHN1cGVyKCk7XHJcblxyXG5cdFx0dGhpcy5hZGRMaWdodCggUG9pbnRMaWdodE5vZGUsIFBvaW50TGlnaHQgKTtcclxuXHRcdHRoaXMuYWRkTGlnaHQoIERpcmVjdGlvbmFsTGlnaHROb2RlLCBEaXJlY3Rpb25hbExpZ2h0ICk7XHJcblx0XHR0aGlzLmFkZExpZ2h0KCBSZWN0QXJlYUxpZ2h0Tm9kZSwgUmVjdEFyZWFMaWdodCApO1xyXG5cdFx0dGhpcy5hZGRMaWdodCggU3BvdExpZ2h0Tm9kZSwgU3BvdExpZ2h0ICk7XHJcblx0XHR0aGlzLmFkZExpZ2h0KCBBbWJpZW50TGlnaHROb2RlLCBBbWJpZW50TGlnaHQgKTtcclxuXHRcdHRoaXMuYWRkTGlnaHQoIEhlbWlzcGhlcmVMaWdodE5vZGUsIEhlbWlzcGhlcmVMaWdodCApO1xyXG5cdFx0dGhpcy5hZGRMaWdodCggTGlnaHRQcm9iZU5vZGUsIExpZ2h0UHJvYmUgKTtcclxuXHRcdHRoaXMuYWRkTGlnaHQoIElFU1Nwb3RMaWdodE5vZGUsIElFU1Nwb3RMaWdodCApO1xyXG5cclxuXHRcdHRoaXMuYWRkVG9uZU1hcHBpbmcoIGxpbmVhclRvbmVNYXBwaW5nLCBMaW5lYXJUb25lTWFwcGluZyApO1xyXG5cdFx0dGhpcy5hZGRUb25lTWFwcGluZyggcmVpbmhhcmRUb25lTWFwcGluZywgUmVpbmhhcmRUb25lTWFwcGluZyApO1xyXG5cdFx0dGhpcy5hZGRUb25lTWFwcGluZyggY2luZW9uVG9uZU1hcHBpbmcsIENpbmVvblRvbmVNYXBwaW5nICk7XHJcblx0XHR0aGlzLmFkZFRvbmVNYXBwaW5nKCBhY2VzRmlsbWljVG9uZU1hcHBpbmcsIEFDRVNGaWxtaWNUb25lTWFwcGluZyApO1xyXG5cdFx0dGhpcy5hZGRUb25lTWFwcGluZyggYWd4VG9uZU1hcHBpbmcsIEFnWFRvbmVNYXBwaW5nICk7XHJcblx0XHR0aGlzLmFkZFRvbmVNYXBwaW5nKCBuZXV0cmFsVG9uZU1hcHBpbmcsIE5ldXRyYWxUb25lTWFwcGluZyApO1xyXG5cclxuXHR9XHJcblxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBCYXNpY05vZGVMaWJyYXJ5O1xyXG4iLCJpbXBvcnQgUmVuZGVyZXIgZnJvbSAnLi4vY29tbW9uL1JlbmRlcmVyLmpzJztcclxuaW1wb3J0IFdlYkdMQmFja2VuZCBmcm9tICcuLi93ZWJnbC1mYWxsYmFjay9XZWJHTEJhY2tlbmQuanMnO1xyXG5pbXBvcnQgV2ViR1BVQmFja2VuZCBmcm9tICcuL1dlYkdQVUJhY2tlbmQuanMnO1xyXG5pbXBvcnQgQmFzaWNOb2RlTGlicmFyeSBmcm9tICcuL25vZGVzL0Jhc2ljTm9kZUxpYnJhcnkuanMnO1xyXG5cclxuY2xhc3MgV2ViR1BVUmVuZGVyZXIgZXh0ZW5kcyBSZW5kZXJlciB7XHJcblxyXG5cdGNvbnN0cnVjdG9yKCBwYXJhbWV0ZXJzID0ge30gKSB7XHJcblxyXG5cdFx0bGV0IEJhY2tlbmRDbGFzcztcclxuXHJcblx0XHRpZiAoIHBhcmFtZXRlcnMuZm9yY2VXZWJHTCApIHtcclxuXHJcblx0XHRcdEJhY2tlbmRDbGFzcyA9IFdlYkdMQmFja2VuZDtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0QmFja2VuZENsYXNzID0gV2ViR1BVQmFja2VuZDtcclxuXHJcblx0XHRcdHBhcmFtZXRlcnMuZ2V0RmFsbGJhY2sgPSAoKSA9PiB7XHJcblxyXG5cdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdQVVJlbmRlcmVyOiBXZWJHUFUgaXMgbm90IGF2YWlsYWJsZSwgcnVubmluZyB1bmRlciBXZWJHTDIgYmFja2VuZC4nICk7XHJcblxyXG5cdFx0XHRcdHJldHVybiBuZXcgV2ViR0xCYWNrZW5kKCBwYXJhbWV0ZXJzICk7XHJcblxyXG5cdFx0XHR9O1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRjb25zdCBiYWNrZW5kID0gbmV3IEJhY2tlbmRDbGFzcyggcGFyYW1ldGVycyApO1xyXG5cclxuXHRcdHN1cGVyKCBiYWNrZW5kLCBwYXJhbWV0ZXJzICk7XHJcblxyXG5cdFx0dGhpcy5saWJyYXJ5ID0gbmV3IEJhc2ljTm9kZUxpYnJhcnkoKTtcclxuXHJcblx0XHR0aGlzLmlzV2ViR1BVUmVuZGVyZXIgPSB0cnVlO1xyXG5cclxuXHR9XHJcblxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBXZWJHUFVSZW5kZXJlcjtcclxuIiwiaW1wb3J0IHsgR3JvdXAgfSBmcm9tICcuLi8uLi9vYmplY3RzL0dyb3VwLmpzJztcclxuXHJcbmNsYXNzIEJ1bmRsZUdyb3VwIGV4dGVuZHMgR3JvdXAge1xyXG5cclxuXHRjb25zdHJ1Y3RvcigpIHtcclxuXHJcblx0XHRzdXBlcigpO1xyXG5cclxuXHRcdHRoaXMuaXNCdW5kbGVHcm91cCA9IHRydWU7XHJcblxyXG5cdFx0dGhpcy50eXBlID0gJ0J1bmRsZUdyb3VwJztcclxuXHJcblx0XHR0aGlzLnN0YXRpYyA9IHRydWU7XHJcblx0XHR0aGlzLnZlcnNpb24gPSAwO1xyXG5cclxuXHR9XHJcblxyXG5cdHNldCBuZWVkc1VwZGF0ZSggdmFsdWUgKSB7XHJcblxyXG5cdFx0aWYgKCB2YWx1ZSA9PT0gdHJ1ZSApIHRoaXMudmVyc2lvbiArKztcclxuXHJcblx0fVxyXG5cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgQnVuZGxlR3JvdXA7XHJcbiIsImltcG9ydCBOb2RlTWF0ZXJpYWwgZnJvbSAnLi4vLi4vbWF0ZXJpYWxzL25vZGVzL05vZGVNYXRlcmlhbC5qcyc7XHJcbmltcG9ydCB7IHZlYzQsIHJlbmRlck91dHB1dCB9IGZyb20gJy4uLy4uL25vZGVzL1RTTC5qcyc7XHJcbmltcG9ydCB7IExpbmVhclNSR0JDb2xvclNwYWNlLCBOb1RvbmVNYXBwaW5nIH0gZnJvbSAnLi4vLi4vY29uc3RhbnRzLmpzJztcclxuaW1wb3J0IFF1YWRNZXNoIGZyb20gJy4uLy4uL3JlbmRlcmVycy9jb21tb24vUXVhZE1lc2guanMnO1xyXG5cclxuY29uc3QgX21hdGVyaWFsID0gLypAX19QVVJFX18qLyBuZXcgTm9kZU1hdGVyaWFsKCk7XHJcbmNvbnN0IF9xdWFkTWVzaCA9IC8qQF9fUFVSRV9fKi8gbmV3IFF1YWRNZXNoKCBfbWF0ZXJpYWwgKTtcclxuXHJcbmNsYXNzIFBvc3RQcm9jZXNzaW5nIHtcclxuXHJcblx0Y29uc3RydWN0b3IoIHJlbmRlcmVyLCBvdXRwdXROb2RlID0gdmVjNCggMCwgMCwgMSwgMSApICkge1xyXG5cclxuXHRcdHRoaXMucmVuZGVyZXIgPSByZW5kZXJlcjtcclxuXHRcdHRoaXMub3V0cHV0Tm9kZSA9IG91dHB1dE5vZGU7XHJcblxyXG5cdFx0dGhpcy5vdXRwdXRDb2xvclRyYW5zZm9ybSA9IHRydWU7XHJcblxyXG5cdFx0dGhpcy5uZWVkc1VwZGF0ZSA9IHRydWU7XHJcblxyXG5cdFx0X21hdGVyaWFsLm5hbWUgPSAnUG9zdFByb2Nlc3NpbmcnO1xyXG5cclxuXHR9XHJcblxyXG5cdHJlbmRlcigpIHtcclxuXHJcblx0XHR0aGlzLnVwZGF0ZSgpO1xyXG5cclxuXHRcdGNvbnN0IHJlbmRlcmVyID0gdGhpcy5yZW5kZXJlcjtcclxuXHJcblx0XHRjb25zdCB0b25lTWFwcGluZyA9IHJlbmRlcmVyLnRvbmVNYXBwaW5nO1xyXG5cdFx0Y29uc3Qgb3V0cHV0Q29sb3JTcGFjZSA9IHJlbmRlcmVyLm91dHB1dENvbG9yU3BhY2U7XHJcblxyXG5cdFx0cmVuZGVyZXIudG9uZU1hcHBpbmcgPSBOb1RvbmVNYXBwaW5nO1xyXG5cdFx0cmVuZGVyZXIub3V0cHV0Q29sb3JTcGFjZSA9IExpbmVhclNSR0JDb2xvclNwYWNlO1xyXG5cclxuXHRcdC8vXHJcblxyXG5cdFx0X3F1YWRNZXNoLnJlbmRlciggcmVuZGVyZXIgKTtcclxuXHJcblx0XHQvL1xyXG5cclxuXHRcdHJlbmRlcmVyLnRvbmVNYXBwaW5nID0gdG9uZU1hcHBpbmc7XHJcblx0XHRyZW5kZXJlci5vdXRwdXRDb2xvclNwYWNlID0gb3V0cHV0Q29sb3JTcGFjZTtcclxuXHJcblx0fVxyXG5cclxuXHR1cGRhdGUoKSB7XHJcblxyXG5cdFx0aWYgKCB0aGlzLm5lZWRzVXBkYXRlID09PSB0cnVlICkge1xyXG5cclxuXHRcdFx0Y29uc3QgcmVuZGVyZXIgPSB0aGlzLnJlbmRlcmVyO1xyXG5cclxuXHRcdFx0Y29uc3QgdG9uZU1hcHBpbmcgPSByZW5kZXJlci50b25lTWFwcGluZztcclxuXHRcdFx0Y29uc3Qgb3V0cHV0Q29sb3JTcGFjZSA9IHJlbmRlcmVyLm91dHB1dENvbG9yU3BhY2U7XHJcblxyXG5cdFx0XHRfcXVhZE1lc2gubWF0ZXJpYWwuZnJhZ21lbnROb2RlID0gdGhpcy5vdXRwdXRDb2xvclRyYW5zZm9ybSA9PT0gdHJ1ZSA/IHJlbmRlck91dHB1dCggdGhpcy5vdXRwdXROb2RlLCB0b25lTWFwcGluZywgb3V0cHV0Q29sb3JTcGFjZSApIDogdGhpcy5vdXRwdXROb2RlLmNvbnRleHQoIHsgdG9uZU1hcHBpbmcsIG91dHB1dENvbG9yU3BhY2UgfSApO1xyXG5cdFx0XHRfcXVhZE1lc2gubWF0ZXJpYWwubmVlZHNVcGRhdGUgPSB0cnVlO1xyXG5cclxuXHRcdFx0dGhpcy5uZWVkc1VwZGF0ZSA9IGZhbHNlO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHRhc3luYyByZW5kZXJBc3luYygpIHtcclxuXHJcblx0XHR0aGlzLnVwZGF0ZSgpO1xyXG5cclxuXHRcdGNvbnN0IHJlbmRlcmVyID0gdGhpcy5yZW5kZXJlcjtcclxuXHJcblx0XHRjb25zdCB0b25lTWFwcGluZyA9IHJlbmRlcmVyLnRvbmVNYXBwaW5nO1xyXG5cdFx0Y29uc3Qgb3V0cHV0Q29sb3JTcGFjZSA9IHJlbmRlcmVyLm91dHB1dENvbG9yU3BhY2U7XHJcblxyXG5cdFx0cmVuZGVyZXIudG9uZU1hcHBpbmcgPSBOb1RvbmVNYXBwaW5nO1xyXG5cdFx0cmVuZGVyZXIub3V0cHV0Q29sb3JTcGFjZSA9IExpbmVhclNSR0JDb2xvclNwYWNlO1xyXG5cclxuXHRcdC8vXHJcblxyXG5cdFx0YXdhaXQgX3F1YWRNZXNoLnJlbmRlckFzeW5jKCByZW5kZXJlciApO1xyXG5cclxuXHRcdC8vXHJcblxyXG5cdFx0cmVuZGVyZXIudG9uZU1hcHBpbmcgPSB0b25lTWFwcGluZztcclxuXHRcdHJlbmRlcmVyLm91dHB1dENvbG9yU3BhY2UgPSBvdXRwdXRDb2xvclNwYWNlO1xyXG5cclxuXHR9XHJcblxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBQb3N0UHJvY2Vzc2luZztcclxuIiwiaW1wb3J0IHsgQ29sb3IgfSBmcm9tICcuLi8uLi9tYXRoL0NvbG9yLmpzJztcclxuXHJcbi8vIHJlbmRlcmVyIHN0YXRlXHJcblxyXG5leHBvcnQgZnVuY3Rpb24gc2F2ZVJlbmRlcmVyU3RhdGUoIHJlbmRlcmVyLCBzdGF0ZSA9IHt9ICkge1xyXG5cclxuXHRzdGF0ZS50b25lTWFwcGluZyA9IHJlbmRlcmVyLnRvbmVNYXBwaW5nO1xyXG5cdHN0YXRlLnRvbmVNYXBwaW5nRXhwb3N1cmUgPSByZW5kZXJlci50b25lTWFwcGluZ0V4cG9zdXJlO1xyXG5cdHN0YXRlLm91dHB1dENvbG9yU3BhY2UgPSByZW5kZXJlci5vdXRwdXRDb2xvclNwYWNlO1xyXG5cdHN0YXRlLnJlbmRlclRhcmdldCA9IHJlbmRlcmVyLmdldFJlbmRlclRhcmdldCgpO1xyXG5cdHN0YXRlLmFjdGl2ZUN1YmVGYWNlID0gcmVuZGVyZXIuZ2V0QWN0aXZlQ3ViZUZhY2UoKTtcclxuXHRzdGF0ZS5hY3RpdmVNaXBtYXBMZXZlbCA9IHJlbmRlcmVyLmdldEFjdGl2ZU1pcG1hcExldmVsKCk7XHJcblx0c3RhdGUucmVuZGVyT2JqZWN0RnVuY3Rpb24gPSByZW5kZXJlci5nZXRSZW5kZXJPYmplY3RGdW5jdGlvbigpO1xyXG5cdHN0YXRlLnBpeGVsUmF0aW8gPSByZW5kZXJlci5nZXRQaXhlbFJhdGlvKCk7XHJcblx0c3RhdGUubXJ0ID0gcmVuZGVyZXIuZ2V0TVJUKCk7XHJcblx0c3RhdGUuY2xlYXJDb2xvciA9IHJlbmRlcmVyLmdldENsZWFyQ29sb3IoIHN0YXRlLmNsZWFyQ29sb3IgfHwgbmV3IENvbG9yKCkgKTtcclxuXHRzdGF0ZS5jbGVhckFscGhhID0gcmVuZGVyZXIuZ2V0Q2xlYXJBbHBoYSgpO1xyXG5cdHN0YXRlLmF1dG9DbGVhciA9IHJlbmRlcmVyLmF1dG9DbGVhcjtcclxuXHRzdGF0ZS5zY2lzc29yVGVzdCA9IHJlbmRlcmVyLmdldFNjaXNzb3JUZXN0KCk7XHJcblxyXG5cdHJldHVybiBzdGF0ZTtcclxuXHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiByZXNldFJlbmRlcmVyU3RhdGUoIHJlbmRlcmVyLCBzdGF0ZSApIHtcclxuXHJcblx0c3RhdGUgPSBzYXZlUmVuZGVyZXJTdGF0ZSggcmVuZGVyZXIsIHN0YXRlICk7XHJcblxyXG5cdHJlbmRlcmVyLnNldE1SVCggbnVsbCApO1xyXG5cdHJlbmRlcmVyLnNldFJlbmRlck9iamVjdEZ1bmN0aW9uKCBudWxsICk7XHJcblx0cmVuZGVyZXIuc2V0Q2xlYXJDb2xvciggMHgwMDAwMDAsIDEgKTtcclxuXHRyZW5kZXJlci5hdXRvQ2xlYXIgPSB0cnVlO1xyXG5cclxuXHRyZXR1cm4gc3RhdGU7XHJcblxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gcmVzdG9yZVJlbmRlcmVyU3RhdGUoIHJlbmRlcmVyLCBzdGF0ZSApIHtcclxuXHJcblx0cmVuZGVyZXIudG9uZU1hcHBpbmcgPSBzdGF0ZS50b25lTWFwcGluZztcclxuXHRyZW5kZXJlci50b25lTWFwcGluZ0V4cG9zdXJlID0gc3RhdGUudG9uZU1hcHBpbmdFeHBvc3VyZTtcclxuXHRyZW5kZXJlci5vdXRwdXRDb2xvclNwYWNlID0gc3RhdGUub3V0cHV0Q29sb3JTcGFjZTtcclxuXHRyZW5kZXJlci5zZXRSZW5kZXJUYXJnZXQoIHN0YXRlLnJlbmRlclRhcmdldCwgc3RhdGUuYWN0aXZlQ3ViZUZhY2UsIHN0YXRlLmFjdGl2ZU1pcG1hcExldmVsICk7XHJcblx0cmVuZGVyZXIuc2V0UmVuZGVyT2JqZWN0RnVuY3Rpb24oIHN0YXRlLnJlbmRlck9iamVjdEZ1bmN0aW9uICk7XHJcblx0cmVuZGVyZXIuc2V0UGl4ZWxSYXRpbyggc3RhdGUucGl4ZWxSYXRpbyApO1xyXG5cdHJlbmRlcmVyLnNldE1SVCggc3RhdGUubXJ0ICk7XHJcblx0cmVuZGVyZXIuc2V0Q2xlYXJDb2xvciggc3RhdGUuY2xlYXJDb2xvciwgc3RhdGUuY2xlYXJBbHBoYSApO1xyXG5cdHJlbmRlcmVyLmF1dG9DbGVhciA9IHN0YXRlLmF1dG9DbGVhcjtcclxuXHRyZW5kZXJlci5zZXRTY2lzc29yVGVzdCggc3RhdGUuc2Npc3NvclRlc3QgKTtcclxuXHJcbn1cclxuXHJcbi8vIHJlbmRlcmVyIGFuZCBzY2VuZSBzdGF0ZVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHNhdmVSZW5kZXJlckFuZFNjZW5lU3RhdGUoIHJlbmRlcmVyLCBzY2VuZSwgc3RhdGUgPSB7fSApIHtcclxuXHJcblx0c3RhdGUgPSBzYXZlUmVuZGVyZXJTdGF0ZSggcmVuZGVyZXIsIHN0YXRlICk7XHJcblx0c3RhdGUuYmFja2dyb3VuZCA9IHNjZW5lLmJhY2tncm91bmQ7XHJcblx0c3RhdGUuYmFja2dyb3VuZE5vZGUgPSBzY2VuZS5iYWNrZ3JvdW5kTm9kZTtcclxuXHRzdGF0ZS5vdmVycmlkZU1hdGVyaWFsID0gc2NlbmUub3ZlcnJpZGVNYXRlcmlhbDtcclxuXHJcblx0cmV0dXJuIHN0YXRlO1xyXG5cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHJlc2V0UmVuZGVyZXJBbmRTY2VuZVN0YXRlKCByZW5kZXJlciwgc2NlbmUsIHN0YXRlICkge1xyXG5cclxuXHRzdGF0ZSA9IHNhdmVSZW5kZXJlckFuZFNjZW5lU3RhdGUoIHJlbmRlcmVyLCBzY2VuZSwgc3RhdGUgKTtcclxuXHJcblx0c2NlbmUuYmFja2dyb3VuZCA9IG51bGw7XHJcblx0c2NlbmUuYmFja2dyb3VuZE5vZGUgPSBudWxsO1xyXG5cdHNjZW5lLm92ZXJyaWRlTWF0ZXJpYWwgPSBudWxsO1xyXG5cclxuXHRyZXR1cm4gc3RhdGU7XHJcblxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gcmVzdG9yZVJlbmRlcmVyQW5kU2NlbmVTdGF0ZSggcmVuZGVyZXIsIHNjZW5lLCBzdGF0ZSApIHtcclxuXHJcblx0cmVzdG9yZVJlbmRlcmVyU3RhdGUoIHJlbmRlcmVyLCBzdGF0ZSApO1xyXG5cclxuXHRzY2VuZS5iYWNrZ3JvdW5kID0gc3RhdGUuYmFja2dyb3VuZDtcclxuXHRzY2VuZS5iYWNrZ3JvdW5kTm9kZSA9IHN0YXRlLmJhY2tncm91bmROb2RlO1xyXG5cdHNjZW5lLm92ZXJyaWRlTWF0ZXJpYWwgPSBzdGF0ZS5vdmVycmlkZU1hdGVyaWFsO1xyXG5cclxufVxyXG4iLCJpbXBvcnQgeyBUZXh0dXJlIH0gZnJvbSAnLi4vLi4vdGV4dHVyZXMvVGV4dHVyZS5qcyc7XHJcbmltcG9ydCB7IExpbmVhckZpbHRlciB9IGZyb20gJy4uLy4uL2NvbnN0YW50cy5qcyc7XHJcblxyXG5jbGFzcyBTdG9yYWdlVGV4dHVyZSBleHRlbmRzIFRleHR1cmUge1xyXG5cclxuXHRjb25zdHJ1Y3Rvciggd2lkdGggPSAxLCBoZWlnaHQgPSAxICkge1xyXG5cclxuXHRcdHN1cGVyKCk7XHJcblxyXG5cdFx0dGhpcy5pbWFnZSA9IHsgd2lkdGgsIGhlaWdodCB9O1xyXG5cclxuXHRcdHRoaXMubWFnRmlsdGVyID0gTGluZWFyRmlsdGVyO1xyXG5cdFx0dGhpcy5taW5GaWx0ZXIgPSBMaW5lYXJGaWx0ZXI7XHJcblxyXG5cdFx0dGhpcy5pc1N0b3JhZ2VUZXh0dXJlID0gdHJ1ZTtcclxuXHJcblx0fVxyXG5cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgU3RvcmFnZVRleHR1cmU7XHJcbiIsImltcG9ydCBTdG9yYWdlQnVmZmVyQXR0cmlidXRlIGZyb20gJy4vU3RvcmFnZUJ1ZmZlckF0dHJpYnV0ZS5qcyc7XHJcblxyXG5jbGFzcyBJbmRpcmVjdFN0b3JhZ2VCdWZmZXJBdHRyaWJ1dGUgZXh0ZW5kcyBTdG9yYWdlQnVmZmVyQXR0cmlidXRlIHtcclxuXHJcblx0Y29uc3RydWN0b3IoIGFycmF5LCBpdGVtU2l6ZSApIHtcclxuXHJcblx0XHRzdXBlciggYXJyYXksIGl0ZW1TaXplLCBVaW50MzJBcnJheSApO1xyXG5cclxuXHRcdHRoaXMuaXNJbmRpcmVjdFN0b3JhZ2VCdWZmZXJBdHRyaWJ1dGUgPSB0cnVlO1xyXG5cclxuXHR9XHJcblxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBJbmRpcmVjdFN0b3JhZ2VCdWZmZXJBdHRyaWJ1dGU7XHJcbiIsImltcG9ydCB7IG5vZGVPYmplY3QsIGZsb2F0IH0gZnJvbSAnLi4vLi4vbm9kZXMvdHNsL1RTTEJhc2UuanMnO1xyXG5cclxuaW1wb3J0IHsgTG9hZGVyIH0gZnJvbSAnLi4vTG9hZGVyLmpzJztcclxuaW1wb3J0IHsgRmlsZUxvYWRlciB9IGZyb20gJy4uLy4uL2xvYWRlcnMvRmlsZUxvYWRlci5qcyc7XHJcblxyXG5jbGFzcyBOb2RlTG9hZGVyIGV4dGVuZHMgTG9hZGVyIHtcclxuXHJcblx0Y29uc3RydWN0b3IoIG1hbmFnZXIgKSB7XHJcblxyXG5cdFx0c3VwZXIoIG1hbmFnZXIgKTtcclxuXHJcblx0XHR0aGlzLnRleHR1cmVzID0ge307XHJcblx0XHR0aGlzLm5vZGVzID0ge307XHJcblxyXG5cdH1cclxuXHJcblx0bG9hZCggdXJsLCBvbkxvYWQsIG9uUHJvZ3Jlc3MsIG9uRXJyb3IgKSB7XHJcblxyXG5cdFx0Y29uc3QgbG9hZGVyID0gbmV3IEZpbGVMb2FkZXIoIHRoaXMubWFuYWdlciApO1xyXG5cdFx0bG9hZGVyLnNldFBhdGgoIHRoaXMucGF0aCApO1xyXG5cdFx0bG9hZGVyLnNldFJlcXVlc3RIZWFkZXIoIHRoaXMucmVxdWVzdEhlYWRlciApO1xyXG5cdFx0bG9hZGVyLnNldFdpdGhDcmVkZW50aWFscyggdGhpcy53aXRoQ3JlZGVudGlhbHMgKTtcclxuXHRcdGxvYWRlci5sb2FkKCB1cmwsICggdGV4dCApID0+IHtcclxuXHJcblx0XHRcdHRyeSB7XHJcblxyXG5cdFx0XHRcdG9uTG9hZCggdGhpcy5wYXJzZSggSlNPTi5wYXJzZSggdGV4dCApICkgKTtcclxuXHJcblx0XHRcdH0gY2F0Y2ggKCBlICkge1xyXG5cclxuXHRcdFx0XHRpZiAoIG9uRXJyb3IgKSB7XHJcblxyXG5cdFx0XHRcdFx0b25FcnJvciggZSApO1xyXG5cclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdGNvbnNvbGUuZXJyb3IoIGUgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR0aGlzLm1hbmFnZXIuaXRlbUVycm9yKCB1cmwgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9LCBvblByb2dyZXNzLCBvbkVycm9yICk7XHJcblxyXG5cdH1cclxuXHJcblx0cGFyc2VOb2RlcygganNvbiApIHtcclxuXHJcblx0XHRjb25zdCBub2RlcyA9IHt9O1xyXG5cclxuXHRcdGlmICgganNvbiAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0Zm9yICggY29uc3Qgbm9kZUpTT04gb2YganNvbiApIHtcclxuXHJcblx0XHRcdFx0Y29uc3QgeyB1dWlkLCB0eXBlIH0gPSBub2RlSlNPTjtcclxuXHJcblx0XHRcdFx0bm9kZXNbIHV1aWQgXSA9IHRoaXMuY3JlYXRlTm9kZUZyb21UeXBlKCB0eXBlICk7XHJcblx0XHRcdFx0bm9kZXNbIHV1aWQgXS51dWlkID0gdXVpZDtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGNvbnN0IG1ldGEgPSB7IG5vZGVzLCB0ZXh0dXJlczogdGhpcy50ZXh0dXJlcyB9O1xyXG5cclxuXHRcdFx0Zm9yICggY29uc3Qgbm9kZUpTT04gb2YganNvbiApIHtcclxuXHJcblx0XHRcdFx0bm9kZUpTT04ubWV0YSA9IG1ldGE7XHJcblxyXG5cdFx0XHRcdGNvbnN0IG5vZGUgPSBub2Rlc1sgbm9kZUpTT04udXVpZCBdO1xyXG5cdFx0XHRcdG5vZGUuZGVzZXJpYWxpemUoIG5vZGVKU09OICk7XHJcblxyXG5cdFx0XHRcdGRlbGV0ZSBub2RlSlNPTi5tZXRhO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gbm9kZXM7XHJcblxyXG5cdH1cclxuXHJcblx0cGFyc2UoIGpzb24gKSB7XHJcblxyXG5cdFx0Y29uc3Qgbm9kZSA9IHRoaXMuY3JlYXRlTm9kZUZyb21UeXBlKCBqc29uLnR5cGUgKTtcclxuXHRcdG5vZGUudXVpZCA9IGpzb24udXVpZDtcclxuXHJcblx0XHRjb25zdCBub2RlcyA9IHRoaXMucGFyc2VOb2RlcygganNvbi5ub2RlcyApO1xyXG5cdFx0Y29uc3QgbWV0YSA9IHsgbm9kZXMsIHRleHR1cmVzOiB0aGlzLnRleHR1cmVzIH07XHJcblxyXG5cdFx0anNvbi5tZXRhID0gbWV0YTtcclxuXHJcblx0XHRub2RlLmRlc2VyaWFsaXplKCBqc29uICk7XHJcblxyXG5cdFx0ZGVsZXRlIGpzb24ubWV0YTtcclxuXHJcblx0XHRyZXR1cm4gbm9kZTtcclxuXHJcblx0fVxyXG5cclxuXHRzZXRUZXh0dXJlcyggdmFsdWUgKSB7XHJcblxyXG5cdFx0dGhpcy50ZXh0dXJlcyA9IHZhbHVlO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHJcblx0c2V0Tm9kZXMoIHZhbHVlICkge1xyXG5cclxuXHRcdHRoaXMubm9kZXMgPSB2YWx1ZTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9XHJcblxyXG5cdGNyZWF0ZU5vZGVGcm9tVHlwZSggdHlwZSApIHtcclxuXHJcblx0XHRpZiAoIHRoaXMubm9kZXNbIHR5cGUgXSA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLk5vZGVMb2FkZXI6IE5vZGUgdHlwZSBub3QgZm91bmQ6JywgdHlwZSApO1xyXG5cdFx0XHRyZXR1cm4gZmxvYXQoKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIG5vZGVPYmplY3QoIG5ldyB0aGlzLm5vZGVzWyB0eXBlIF0oKSApO1xyXG5cclxuXHR9XHJcblxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBOb2RlTG9hZGVyO1xyXG4iLCJpbXBvcnQgeyBNYXRlcmlhbExvYWRlciB9IGZyb20gJy4uLy4uL2xvYWRlcnMvTWF0ZXJpYWxMb2FkZXIuanMnO1xyXG5cclxuY2xhc3MgTm9kZU1hdGVyaWFsTG9hZGVyIGV4dGVuZHMgTWF0ZXJpYWxMb2FkZXIge1xyXG5cclxuXHRjb25zdHJ1Y3RvciggbWFuYWdlciApIHtcclxuXHJcblx0XHRzdXBlciggbWFuYWdlciApO1xyXG5cclxuXHRcdHRoaXMubm9kZXMgPSB7fTtcclxuXHRcdHRoaXMubm9kZU1hdGVyaWFscyA9IHt9O1xyXG5cclxuXHR9XHJcblxyXG5cdHBhcnNlKCBqc29uICkge1xyXG5cclxuXHRcdGNvbnN0IG1hdGVyaWFsID0gc3VwZXIucGFyc2UoIGpzb24gKTtcclxuXHJcblx0XHRjb25zdCBub2RlcyA9IHRoaXMubm9kZXM7XHJcblx0XHRjb25zdCBpbnB1dE5vZGVzID0ganNvbi5pbnB1dE5vZGVzO1xyXG5cclxuXHRcdGZvciAoIGNvbnN0IHByb3BlcnR5IGluIGlucHV0Tm9kZXMgKSB7XHJcblxyXG5cdFx0XHRjb25zdCB1dWlkID0gaW5wdXROb2Rlc1sgcHJvcGVydHkgXTtcclxuXHJcblx0XHRcdG1hdGVyaWFsWyBwcm9wZXJ0eSBdID0gbm9kZXNbIHV1aWQgXTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIG1hdGVyaWFsO1xyXG5cclxuXHR9XHJcblxyXG5cdHNldE5vZGVzKCB2YWx1ZSApIHtcclxuXHJcblx0XHR0aGlzLm5vZGVzID0gdmFsdWU7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fVxyXG5cclxuXHRzZXROb2RlTWF0ZXJpYWxzKCB2YWx1ZSApIHtcclxuXHJcblx0XHR0aGlzLm5vZGVNYXRlcmlhbHMgPSB2YWx1ZTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9XHJcblxyXG5cdGNyZWF0ZU1hdGVyaWFsRnJvbVR5cGUoIHR5cGUgKSB7XHJcblxyXG5cdFx0Y29uc3QgbWF0ZXJpYWxDbGFzcyA9IHRoaXMubm9kZU1hdGVyaWFsc1sgdHlwZSBdO1xyXG5cclxuXHRcdGlmICggbWF0ZXJpYWxDbGFzcyAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0cmV0dXJuIG5ldyBtYXRlcmlhbENsYXNzKCk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBzdXBlci5jcmVhdGVNYXRlcmlhbEZyb21UeXBlKCB0eXBlICk7XHJcblxyXG5cdH1cclxuXHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IE5vZGVNYXRlcmlhbExvYWRlcjtcclxuIiwiaW1wb3J0IE5vZGVMb2FkZXIgZnJvbSAnLi9Ob2RlTG9hZGVyLmpzJztcclxuaW1wb3J0IE5vZGVNYXRlcmlhbExvYWRlciBmcm9tICcuL05vZGVNYXRlcmlhbExvYWRlci5qcyc7XHJcblxyXG5pbXBvcnQgeyBPYmplY3RMb2FkZXIgfSBmcm9tICcuLi8uLi9sb2FkZXJzL09iamVjdExvYWRlci5qcyc7XHJcblxyXG5jbGFzcyBOb2RlT2JqZWN0TG9hZGVyIGV4dGVuZHMgT2JqZWN0TG9hZGVyIHtcclxuXHJcblx0Y29uc3RydWN0b3IoIG1hbmFnZXIgKSB7XHJcblxyXG5cdFx0c3VwZXIoIG1hbmFnZXIgKTtcclxuXHJcblx0XHR0aGlzLm5vZGVzID0ge307XHJcblx0XHR0aGlzLm5vZGVNYXRlcmlhbHMgPSB7fTtcclxuXHJcblx0XHR0aGlzLl9ub2Rlc0pTT04gPSBudWxsO1xyXG5cclxuXHR9XHJcblxyXG5cdHNldE5vZGVzKCB2YWx1ZSApIHtcclxuXHJcblx0XHR0aGlzLm5vZGVzID0gdmFsdWU7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fVxyXG5cclxuXHRzZXROb2RlTWF0ZXJpYWxzKCB2YWx1ZSApIHtcclxuXHJcblx0XHR0aGlzLm5vZGVNYXRlcmlhbHMgPSB2YWx1ZTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9XHJcblxyXG5cdHBhcnNlKCBqc29uLCBvbkxvYWQgKSB7XHJcblxyXG5cdFx0dGhpcy5fbm9kZXNKU09OID0ganNvbi5ub2RlcztcclxuXHJcblx0XHRjb25zdCBkYXRhID0gc3VwZXIucGFyc2UoIGpzb24sIG9uTG9hZCApO1xyXG5cclxuXHRcdHRoaXMuX25vZGVzSlNPTiA9IG51bGw7IC8vIGRpc3Bvc2VcclxuXHJcblx0XHRyZXR1cm4gZGF0YTtcclxuXHJcblx0fVxyXG5cclxuXHRwYXJzZU5vZGVzKCBqc29uLCB0ZXh0dXJlcyApIHtcclxuXHJcblx0XHRpZiAoIGpzb24gIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdGNvbnN0IGxvYWRlciA9IG5ldyBOb2RlTG9hZGVyKCk7XHJcblx0XHRcdGxvYWRlci5zZXROb2RlcyggdGhpcy5ub2RlcyApO1xyXG5cdFx0XHRsb2FkZXIuc2V0VGV4dHVyZXMoIHRleHR1cmVzICk7XHJcblxyXG5cdFx0XHRyZXR1cm4gbG9hZGVyLnBhcnNlTm9kZXMoIGpzb24gKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHt9O1xyXG5cclxuXHR9XHJcblxyXG5cdHBhcnNlTWF0ZXJpYWxzKCBqc29uLCB0ZXh0dXJlcyApIHtcclxuXHJcblx0XHRjb25zdCBtYXRlcmlhbHMgPSB7fTtcclxuXHJcblx0XHRpZiAoIGpzb24gIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdGNvbnN0IG5vZGVzID0gdGhpcy5wYXJzZU5vZGVzKCB0aGlzLl9ub2Rlc0pTT04sIHRleHR1cmVzICk7XHJcblxyXG5cdFx0XHRjb25zdCBsb2FkZXIgPSBuZXcgTm9kZU1hdGVyaWFsTG9hZGVyKCk7XHJcblx0XHRcdGxvYWRlci5zZXRUZXh0dXJlcyggdGV4dHVyZXMgKTtcclxuXHRcdFx0bG9hZGVyLnNldE5vZGVzKCBub2RlcyApO1xyXG5cdFx0XHRsb2FkZXIuc2V0Tm9kZU1hdGVyaWFscyggdGhpcy5ub2RlTWF0ZXJpYWxzICk7XHJcblxyXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSBqc29uLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdGNvbnN0IGRhdGEgPSBqc29uWyBpIF07XHJcblxyXG5cdFx0XHRcdG1hdGVyaWFsc1sgZGF0YS51dWlkIF0gPSBsb2FkZXIucGFyc2UoIGRhdGEgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIG1hdGVyaWFscztcclxuXHJcblx0fVxyXG5cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgTm9kZU9iamVjdExvYWRlcjtcclxuIiwiaW1wb3J0IHsgR3JvdXAgfSBmcm9tICcuL0dyb3VwLmpzJztcclxuXHJcbmNsYXNzIENsaXBwaW5nR3JvdXAgZXh0ZW5kcyBHcm91cCB7XHJcblxyXG5cdGNvbnN0cnVjdG9yKCkge1xyXG5cclxuXHRcdHN1cGVyKCk7XHJcblxyXG5cdFx0dGhpcy5pc0NsaXBwaW5nR3JvdXAgPSB0cnVlO1xyXG5cdFx0dGhpcy5jbGlwcGluZ1BsYW5lcyA9IFtdO1xyXG5cdFx0dGhpcy5lbmFibGVkID0gdHJ1ZTtcclxuXHRcdHRoaXMuY2xpcEludGVyc2VjdGlvbiA9IGZhbHNlO1xyXG5cdFx0dGhpcy5jbGlwU2hhZG93cyA9IGZhbHNlO1xyXG5cclxuXHR9XHJcblxyXG59XHJcblxyXG5leHBvcnQgeyBDbGlwcGluZ0dyb3VwIH07XHJcbiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNsWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ1k7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ1k7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ1k7QUFDQTtBQUNBO0FBQ0E7O0FDL0RaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1MUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25GQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNQO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBT1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDTztBQUNQO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNPO0FBQ0E7QUFDQTtBQUNBO0FBQ1A7QUFDTztBQUNBO0FBQ0E7QUFDQTtBQUNQO0FBQ087QUFDQTtBQUNBO0FBQ0E7QUFDUDtBQUNPO0FBQ0E7QUFDQTtBQUNBO0FBQ1A7QUFDTztBQUNBO0FBQ0E7QUFDUDtBQUNPO0FBQ0E7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNBO0FBQ0E7QUFDUDtBQUNBO0FBQ0E7O0FDanBCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTzs7QUNqSVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDTztBQUNBO0FBQ1A7QUFDTztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqSVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBOztBQzdLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbmlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNPO0FBQ0E7QUFDQTtBQUNBO0FBQ1A7QUFDTztBQUNBO0FBQ0E7QUFDUDtBQUNPO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ1A7QUFDTztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDUDtBQUNPO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDUDtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ0E7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hjQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTs7QUMxSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7O0FDL0tBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNoTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDTzs7QUNyS1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDTzs7QUMzQlA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBOztBQy9HQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNPO0FBQ0E7QUFDUDtBQUNPO0FBQ0E7QUFDUDtBQUNBOztBQ2hLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNPO0FBQ1A7QUFDQTs7QUM3RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBOztBQ3hGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBOztBQzFGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7O0FDekhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPOztBQ2hFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBOztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7O0FDNUhBO0FBQ0E7QUFDQTtBQXNCQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FDMUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPOztBQ3JLUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTzs7QUNSUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTzs7QUN6RVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTzs7QUM1RlA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNPO0FBQ0E7QUFDUDtBQUNBO0FBQ0E7QUFDTzs7QUN0Y1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPOztBQ3JEUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDTztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdIUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDTztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNQO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087O0FDckRQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPOztBQ2xFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdJTzs7QUNHQTtBQUNBO0FBQ1A7QUFDTztBQUNBOztBQ0hQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ087O0FDM0VQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPOztBQy9GUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTzs7QUNoWlA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNPOztBQ3hDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPOztBQ3BEUDtBQUNBO0FBQ087QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ1A7QUFDTztBQUNBO0FBQ1A7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPOztBQzdJUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTzs7QUMxR1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNPO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNQO0FBQ087QUFDQTtBQUNQO0FBQ087QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyYk87O0FDQVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTzs7QUNqSlA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDTzs7QUN6SVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNPOztBQ2ZQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ087O0FDbkhQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ087QUFDQTs7QUMxTFA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ087O0FDblFQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ087O0FDaEhQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbFFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPOztBQ25JUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087O0FDakRQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7O0FDMVJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDTzs7QUNmUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ087QUFDQTtBQUNBOztBQ3RMUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxc0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNySkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087O0FDN0NQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbGNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPOztBQ1hQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPOztBQ3JEUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTzs7QUMxT1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25FQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0dBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyeEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087O0FDeldQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9PQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTzs7QUN4Q1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087O0FDNUZQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ087O0FDM0ZQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzRGU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2U7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxYUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkRPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ087QUFDQTs7QUNUUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeFFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNU5BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087O0FDM0RQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPOztBQ3ZMUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPOztBQzFGUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPOztBQ3BKUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTzs7QUNuRFA7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPOztBQ3JKUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPOztBQ25DUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTzs7QUNuRlA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087O0FDbklQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPOztBQ3hlUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTzs7QUMxSFA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ087QUFDUDtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZMTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPOztBQzNHUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087O0FDL0NQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPOztBQzFJUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDTztBQUNQO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTzs7QUNsRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPOztBQzlOQTtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTzs7QUNyRFA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPOztBQ3BwQlA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087O0FDbExQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTzs7QUNsTFA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDQTs7QUN6SlA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNPOztBQ3BLUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ087O0FDcGZQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPOztBQ3pLUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNPO0FBQ0E7QUFDQTtBQUNBOztBQzdGUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNPO0FBQ0E7QUFDQTs7QUNsQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDTzs7QUM5RlA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUZQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTzs7QUNsRlA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTzs7QUNsWVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTzs7QUN2RVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTzs7QUNoeEJQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4TkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPOztBQ3pTQTtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0QkE7QUFDQTtBQUNBO0FBT0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087O0FDOXlDUDtBQUNBO0FBQ0E7QUFJQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5SEE7QUFDQTtBQUNBO0FBSUE7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNWTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNBO0FBQ1A7QUFDQTtBQUNPO0FBQ0E7QUFDUDtBQUNPO0FBQ1A7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNPO0FBQ1A7QUFDTztBQUNBO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDQTtBQUNBO0FBQ1A7QUFDTztBQUNQO0FBQ087QUFDQTtBQUNBO0FBQ0E7O0FDOURQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6QkE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcklBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcDNFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9TQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL2dCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0S0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ253REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDemdDQTtBQUNBO0FBQ0E7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbk1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNVBBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeHdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdlFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ243QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMXBETztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBa0NBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBT0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5VEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuc0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbExBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbCtDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9WQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDem9CQTtBQUNBO0FBQ0E7QUFDQTtBQWFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxakRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckZBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDbEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzsifQ==
